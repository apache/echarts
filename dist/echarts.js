(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['exports'], factory);
    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {
        // CommonJS
        factory(exports);
    } else {
        // Browser globals
        factory((root.echarts = {}));
    }
}(typeof self !== 'undefined' ? self : this, function (exports, b) {

var __defProp = Object.defineProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};

// src/echarts.all.ts
__export(exports, {
  Axis: () => Axis_default,
  ChartView: () => Chart_default,
  ComponentModel: () => Component_default,
  ComponentView: () => Component_default2,
  List: () => SeriesData_default,
  Model: () => Model_default,
  PRIORITY: () => PRIORITY,
  SeriesModel: () => Series_default,
  color: () => color_exports,
  connect: () => connect,
  dataTool: () => dataTool,
  dependencies: () => dependencies,
  disConnect: () => disConnect,
  disconnect: () => disconnect,
  dispose: () => dispose2,
  env: () => env_default,
  extendChartView: () => extendChartView,
  extendComponentModel: () => extendComponentModel,
  extendComponentView: () => extendComponentView,
  extendSeriesModel: () => extendSeriesModel,
  format: () => format_exports,
  getCoordinateSystemDimensions: () => getCoordinateSystemDimensions,
  getInstanceByDom: () => getInstanceByDom,
  getInstanceById: () => getInstanceById,
  getMap: () => getMap,
  graphic: () => graphic_exports2,
  helper: () => helper_exports,
  init: () => init2,
  innerDrawElementOnCanvas: () => brushSingle,
  matrix: () => matrix_exports,
  number: () => number_exports,
  parseGeoJSON: () => parseGeoJSON,
  parseGeoJson: () => parseGeoJSON,
  registerAction: () => registerAction,
  registerCoordinateSystem: () => registerCoordinateSystem,
  registerCustomSeries: () => registerCustomSeries2,
  registerLayout: () => registerLayout,
  registerLoading: () => registerLoading,
  registerLocale: () => registerLocale,
  registerMap: () => registerMap,
  registerPostInit: () => registerPostInit,
  registerPostUpdate: () => registerPostUpdate,
  registerPreprocessor: () => registerPreprocessor,
  registerProcessor: () => registerProcessor,
  registerTheme: () => registerTheme,
  registerTransform: () => registerTransform,
  registerUpdateLifecycle: () => registerUpdateLifecycle,
  registerVisual: () => registerVisual,
  setCanvasCreator: () => setCanvasCreator,
  setPlatformAPI: () => setPlatformAPI,
  throttle: () => throttle,
  time: () => time_exports,
  use: () => use,
  util: () => util_exports2,
  vector: () => vector_exports,
  version: () => version2,
  zrUtil: () => util_exports,
  zrender: () => zrender_exports
});

// ../zrender/src/zrender.ts
var zrender_exports = {};
__export(zrender_exports, {
  dispose: () => dispose,
  disposeAll: () => disposeAll,
  getElementSSRData: () => getElementSSRData,
  getInstance: () => getInstance,
  init: () => init,
  registerPainter: () => registerPainter,
  registerSSRDataGetter: () => registerSSRDataGetter,
  version: () => version
});

// ../zrender/src/core/env.ts
var Browser = class {
  constructor() {
    this.firefox = false;
    this.ie = false;
    this.edge = false;
    this.newEdge = false;
    this.weChat = false;
  }
};
var Env = class {
  constructor() {
    this.browser = new Browser();
    this.node = false;
    this.wxa = false;
    this.worker = false;
    this.svgSupported = false;
    this.touchEventsSupported = false;
    this.pointerEventsSupported = false;
    this.domSupported = false;
    this.transformSupported = false;
    this.transform3dSupported = false;
    this.hasGlobalWindow = typeof window !== "undefined";
  }
};
var env = new Env();
if (typeof wx === "object" && typeof wx.getSystemInfoSync === "function") {
  env.wxa = true;
  env.touchEventsSupported = true;
} else if (typeof document === "undefined" && typeof self !== "undefined") {
  env.worker = true;
} else if (!env.hasGlobalWindow || "Deno" in window || typeof navigator !== "undefined" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Node.js") > -1) {
  env.node = true;
  env.svgSupported = true;
} else {
  detect(navigator.userAgent, env);
}
function detect(ua, env2) {
  const browser = env2.browser;
  const firefox = ua.match(/Firefox\/([\d.]+)/);
  const ie = ua.match(/MSIE\s([\d.]+)/) || ua.match(/Trident\/.+?rv:(([\d.]+))/);
  const edge = ua.match(/Edge?\/([\d.]+)/);
  const weChat = /micromessenger/i.test(ua);
  if (firefox) {
    browser.firefox = true;
    browser.version = firefox[1];
  }
  if (ie) {
    browser.ie = true;
    browser.version = ie[1];
  }
  if (edge) {
    browser.edge = true;
    browser.version = edge[1];
    browser.newEdge = +edge[1].split(".")[0] > 18;
  }
  if (weChat) {
    browser.weChat = true;
  }
  env2.svgSupported = typeof SVGRect !== "undefined";
  env2.touchEventsSupported = "ontouchstart" in window && !browser.ie && !browser.edge;
  env2.pointerEventsSupported = "onpointerdown" in window && (browser.edge || browser.ie && +browser.version >= 11);
  const domSupported = env2.domSupported = typeof document !== "undefined";
  if (domSupported) {
    const style = document.documentElement.style;
    env2.transform3dSupported = (browser.ie && "transition" in style || browser.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in style) && !("OTransition" in style);
    env2.transformSupported = env2.transform3dSupported || browser.ie && +browser.version >= 9;
  }
}
var env_default = env;

// ../zrender/src/core/util.ts
var util_exports = {};
__export(util_exports, {
  EPSILON: () => EPSILON,
  HashMap: () => HashMap,
  RADIAN_TO_DEGREE: () => RADIAN_TO_DEGREE,
  assert: () => assert,
  bind: () => bind,
  clone: () => clone,
  concatArray: () => concatArray,
  createCanvas: () => createCanvas,
  createHashMap: () => createHashMap,
  createObject: () => createObject,
  curry: () => curry,
  defaults: () => defaults,
  disableUserSelect: () => disableUserSelect,
  each: () => each,
  eqNaN: () => eqNaN,
  extend: () => extend,
  filter: () => filter,
  find: () => find,
  guid: () => guid,
  hasOwn: () => hasOwn,
  indexOf: () => indexOf,
  inherits: () => inherits,
  isArray: () => isArray,
  isArrayLike: () => isArrayLike,
  isBuiltInObject: () => isBuiltInObject,
  isDom: () => isDom,
  isFunction: () => isFunction,
  isGradientObject: () => isGradientObject,
  isImagePatternObject: () => isImagePatternObject,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isPrimitive: () => isPrimitive,
  isRegExp: () => isRegExp,
  isString: () => isString,
  isStringSafe: () => isStringSafe,
  isTypedArray: () => isTypedArray,
  keys: () => keys,
  logError: () => logError,
  map: () => map,
  merge: () => merge,
  mergeAll: () => mergeAll,
  mixin: () => mixin,
  noop: () => noop,
  normalizeCssArray: () => normalizeCssArray,
  reduce: () => reduce,
  retrieve: () => retrieve,
  retrieve2: () => retrieve2,
  retrieve3: () => retrieve3,
  setAsPrimitive: () => setAsPrimitive,
  slice: () => slice,
  trim: () => trim
});

// ../zrender/src/core/platform.ts
var DEFAULT_FONT_SIZE = 12;
var DEFAULT_FONT_FAMILY = "sans-serif";
var DEFAULT_FONT = `${DEFAULT_FONT_SIZE}px ${DEFAULT_FONT_FAMILY}`;
var OFFSET = 20;
var SCALE = 100;
var defaultWidthMapStr = `007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N`;
function getTextWidthMap(mapStr) {
  const map3 = {};
  if (typeof JSON === "undefined") {
    return map3;
  }
  for (let i = 0; i < mapStr.length; i++) {
    const char = String.fromCharCode(i + 32);
    const size = (mapStr.charCodeAt(i) - OFFSET) / SCALE;
    map3[char] = size;
  }
  return map3;
}
var DEFAULT_TEXT_WIDTH_MAP = getTextWidthMap(defaultWidthMapStr);
var platformApi = {
  createCanvas() {
    return typeof document !== "undefined" && document.createElement("canvas");
  },
  measureText: function() {
    let _ctx;
    let _cachedFont;
    return (text, font) => {
      if (!_ctx) {
        const canvas = platformApi.createCanvas();
        _ctx = canvas && canvas.getContext("2d");
      }
      if (_ctx) {
        if (_cachedFont !== font) {
          _cachedFont = _ctx.font = font || DEFAULT_FONT;
        }
        return _ctx.measureText(text);
      } else {
        text = text || "";
        font = font || DEFAULT_FONT;
        const res = /((?:\d+)?\.?\d*)px/.exec(font);
        const fontSize = res && +res[1] || DEFAULT_FONT_SIZE;
        let width = 0;
        if (font.indexOf("mono") >= 0) {
          width = fontSize * text.length;
        } else {
          for (let i = 0; i < text.length; i++) {
            const preCalcWidth = DEFAULT_TEXT_WIDTH_MAP[text[i]];
            width += preCalcWidth == null ? fontSize : preCalcWidth * fontSize;
          }
        }
        return {width};
      }
    };
  }(),
  loadImage(src, onload, onerror) {
    const image = new Image();
    image.onload = onload;
    image.onerror = onerror;
    image.src = src;
    return image;
  }
};
function setPlatformAPI(newPlatformApis) {
  for (let key in platformApi) {
    if (newPlatformApis[key]) {
      platformApi[key] = newPlatformApis[key];
    }
  }
}

// ../zrender/src/core/util.ts
var BUILTIN_OBJECT = reduce([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], (obj, val) => {
  obj["[object " + val + "]"] = true;
  return obj;
}, {});
var TYPED_ARRAY = reduce([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], (obj, val) => {
  obj["[object " + val + "Array]"] = true;
  return obj;
}, {});
var objToString = Object.prototype.toString;
var arrayProto = Array.prototype;
var nativeForEach = arrayProto.forEach;
var nativeFilter = arrayProto.filter;
var nativeSlice = arrayProto.slice;
var nativeMap = arrayProto.map;
var ctorFunction = function() {
}.constructor;
var protoFunction = ctorFunction ? ctorFunction.prototype : null;
var protoKey = "__proto__";
var idStart = 2311;
function guid() {
  return idStart++;
}
function logError(...args) {
  if (typeof console !== "undefined") {
    console.error.apply(console, args);
  }
}
function clone(source) {
  if (source == null || typeof source !== "object") {
    return source;
  }
  let result = source;
  const typeStr = objToString.call(source);
  if (typeStr === "[object Array]") {
    if (!isPrimitive(source)) {
      result = [];
      for (let i = 0, len2 = source.length; i < len2; i++) {
        result[i] = clone(source[i]);
      }
    }
  } else if (TYPED_ARRAY[typeStr]) {
    if (!isPrimitive(source)) {
      const Ctor = source.constructor;
      if (Ctor.from) {
        result = Ctor.from(source);
      } else {
        result = new Ctor(source.length);
        for (let i = 0, len2 = source.length; i < len2; i++) {
          result[i] = source[i];
        }
      }
    }
  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
    result = {};
    for (let key in source) {
      if (source.hasOwnProperty(key) && key !== protoKey) {
        result[key] = clone(source[key]);
      }
    }
  }
  return result;
}
function merge(target, source, overwrite) {
  if (!isObject(source) || !isObject(target)) {
    return overwrite ? clone(source) : target;
  }
  for (let key in source) {
    if (source.hasOwnProperty(key) && key !== protoKey) {
      const targetProp = target[key];
      const sourceProp = source[key];
      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
        merge(targetProp, sourceProp, overwrite);
      } else if (overwrite || !(key in target)) {
        target[key] = clone(source[key]);
      }
    }
  }
  return target;
}
function mergeAll(targetAndSources, overwrite) {
  let result = targetAndSources[0];
  for (let i = 1, len2 = targetAndSources.length; i < len2; i++) {
    result = merge(result, targetAndSources[i], overwrite);
  }
  return result;
}
function extend(target, source) {
  if (Object.assign) {
    Object.assign(target, source);
  } else {
    for (let key in source) {
      if (source.hasOwnProperty(key) && key !== protoKey) {
        target[key] = source[key];
      }
    }
  }
  return target;
}
function defaults(target, source, overlay) {
  const keysArr = keys(source);
  for (let i = 0, len2 = keysArr.length; i < len2; i++) {
    let key = keysArr[i];
    if (overlay ? source[key] != null : target[key] == null) {
      target[key] = source[key];
    }
  }
  return target;
}
var createCanvas = platformApi.createCanvas;
function indexOf(array, value) {
  if (array) {
    if (array.indexOf) {
      return array.indexOf(value);
    }
    for (let i = 0, len2 = array.length; i < len2; i++) {
      if (array[i] === value) {
        return i;
      }
    }
  }
  return -1;
}
function inherits(clazz, baseClazz) {
  const clazzPrototype = clazz.prototype;
  function F() {
  }
  F.prototype = baseClazz.prototype;
  clazz.prototype = new F();
  for (let prop in clazzPrototype) {
    if (clazzPrototype.hasOwnProperty(prop)) {
      clazz.prototype[prop] = clazzPrototype[prop];
    }
  }
  clazz.prototype.constructor = clazz;
  clazz.superClass = baseClazz;
}
function mixin(target, source, override) {
  target = "prototype" in target ? target.prototype : target;
  source = "prototype" in source ? source.prototype : source;
  if (Object.getOwnPropertyNames) {
    const keyList = Object.getOwnPropertyNames(source);
    for (let i = 0; i < keyList.length; i++) {
      const key = keyList[i];
      if (key !== "constructor") {
        if (override ? source[key] != null : target[key] == null) {
          target[key] = source[key];
        }
      }
    }
  } else {
    defaults(target, source, override);
  }
}
function isArrayLike(data) {
  if (!data) {
    return false;
  }
  if (typeof data === "string") {
    return false;
  }
  return typeof data.length === "number";
}
function each(arr, cb, context) {
  if (!(arr && cb)) {
    return;
  }
  if (arr.forEach && arr.forEach === nativeForEach) {
    arr.forEach(cb, context);
  } else if (arr.length === +arr.length) {
    for (let i = 0, len2 = arr.length; i < len2; i++) {
      cb.call(context, arr[i], i, arr);
    }
  } else {
    for (let key in arr) {
      if (arr.hasOwnProperty(key)) {
        cb.call(context, arr[key], key, arr);
      }
    }
  }
}
function map(arr, cb, context) {
  if (!arr) {
    return [];
  }
  if (!cb) {
    return slice(arr);
  }
  if (arr.map && arr.map === nativeMap) {
    return arr.map(cb, context);
  } else {
    const result = [];
    for (let i = 0, len2 = arr.length; i < len2; i++) {
      result.push(cb.call(context, arr[i], i, arr));
    }
    return result;
  }
}
function reduce(arr, cb, memo, context) {
  if (!(arr && cb)) {
    return;
  }
  for (let i = 0, len2 = arr.length; i < len2; i++) {
    memo = cb.call(context, memo, arr[i], i, arr);
  }
  return memo;
}
function filter(arr, cb, context) {
  if (!arr) {
    return [];
  }
  if (!cb) {
    return slice(arr);
  }
  if (arr.filter && arr.filter === nativeFilter) {
    return arr.filter(cb, context);
  } else {
    const result = [];
    for (let i = 0, len2 = arr.length; i < len2; i++) {
      if (cb.call(context, arr[i], i, arr)) {
        result.push(arr[i]);
      }
    }
    return result;
  }
}
function find(arr, cb, context) {
  if (!(arr && cb)) {
    return;
  }
  for (let i = 0, len2 = arr.length; i < len2; i++) {
    if (cb.call(context, arr[i], i, arr)) {
      return arr[i];
    }
  }
}
function keys(obj) {
  if (!obj) {
    return [];
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  let keyList = [];
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      keyList.push(key);
    }
  }
  return keyList;
}
function bindPolyfill(func, context, ...args) {
  return function() {
    return func.apply(context, args.concat(nativeSlice.call(arguments)));
  };
}
var bind = protoFunction && isFunction(protoFunction.bind) ? protoFunction.call.bind(protoFunction.bind) : bindPolyfill;
function curry(func, ...args) {
  return function() {
    return func.apply(this, args.concat(nativeSlice.call(arguments)));
  };
}
function isArray(value) {
  if (Array.isArray) {
    return Array.isArray(value);
  }
  return objToString.call(value) === "[object Array]";
}
function isFunction(value) {
  return typeof value === "function";
}
function isString(value) {
  return typeof value === "string";
}
function isStringSafe(value) {
  return objToString.call(value) === "[object String]";
}
function isNumber(value) {
  return typeof value === "number";
}
function isObject(value) {
  const type = typeof value;
  return type === "function" || !!value && type === "object";
}
function isBuiltInObject(value) {
  return !!BUILTIN_OBJECT[objToString.call(value)];
}
function isTypedArray(value) {
  return !!TYPED_ARRAY[objToString.call(value)];
}
function isDom(value) {
  return typeof value === "object" && typeof value.nodeType === "number" && typeof value.ownerDocument === "object";
}
function isGradientObject(value) {
  return value.colorStops != null;
}
function isImagePatternObject(value) {
  return value.image != null;
}
function isRegExp(value) {
  return objToString.call(value) === "[object RegExp]";
}
function eqNaN(value) {
  return value !== value;
}
function retrieve(...args) {
  for (let i = 0, len2 = args.length; i < len2; i++) {
    if (args[i] != null) {
      return args[i];
    }
  }
}
function retrieve2(value0, value1) {
  return value0 != null ? value0 : value1;
}
function retrieve3(value0, value1, value2) {
  return value0 != null ? value0 : value1 != null ? value1 : value2;
}
function slice(arr, ...args) {
  return nativeSlice.apply(arr, args);
}
function normalizeCssArray(val) {
  if (typeof val === "number") {
    return [val, val, val, val];
  }
  const len2 = val.length;
  if (len2 === 2) {
    return [val[0], val[1], val[0], val[1]];
  } else if (len2 === 3) {
    return [val[0], val[1], val[2], val[1]];
  }
  return val;
}
function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
function trim(str) {
  if (str == null) {
    return null;
  } else if (typeof str.trim === "function") {
    return str.trim();
  } else {
    return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  }
}
var primitiveKey = "__ec_primitive__";
function setAsPrimitive(obj) {
  obj[primitiveKey] = true;
}
function isPrimitive(obj) {
  return obj[primitiveKey];
}
var MapPolyfill = class {
  constructor() {
    this.data = {};
  }
  delete(key) {
    const existed = this.has(key);
    if (existed) {
      delete this.data[key];
    }
    return existed;
  }
  has(key) {
    return this.data.hasOwnProperty(key);
  }
  get(key) {
    return this.data[key];
  }
  set(key, value) {
    this.data[key] = value;
    return this;
  }
  keys() {
    return keys(this.data);
  }
  forEach(callback) {
    const data = this.data;
    for (const key in data) {
      if (data.hasOwnProperty(key)) {
        callback(data[key], key);
      }
    }
  }
};
var isNativeMapSupported = typeof Map === "function";
function maybeNativeMap() {
  return isNativeMapSupported ? new Map() : new MapPolyfill();
}
var HashMap = class {
  constructor(obj) {
    const isArr = isArray(obj);
    this.data = maybeNativeMap();
    const thisMap = this;
    obj instanceof HashMap ? obj.each(visit) : obj && each(obj, visit);
    function visit(value, key) {
      isArr ? thisMap.set(value, key) : thisMap.set(key, value);
    }
  }
  hasKey(key) {
    return this.data.has(key);
  }
  get(key) {
    return this.data.get(key);
  }
  set(key, value) {
    this.data.set(key, value);
    return value;
  }
  each(cb, context) {
    this.data.forEach((value, key) => {
      cb.call(context, value, key);
    });
  }
  keys() {
    const keys2 = this.data.keys();
    return isNativeMapSupported ? Array.from(keys2) : keys2;
  }
  removeKey(key) {
    this.data.delete(key);
  }
};
function createHashMap(obj) {
  return new HashMap(obj);
}
function concatArray(a, b) {
  const newArray = new a.constructor(a.length + b.length);
  for (let i = 0; i < a.length; i++) {
    newArray[i] = a[i];
  }
  const offset = a.length;
  for (let i = 0; i < b.length; i++) {
    newArray[i + offset] = b[i];
  }
  return newArray;
}
function createObject(proto, properties) {
  let obj;
  if (Object.create) {
    obj = Object.create(proto);
  } else {
    const StyleCtor = function() {
    };
    StyleCtor.prototype = proto;
    obj = new StyleCtor();
  }
  if (properties) {
    extend(obj, properties);
  }
  return obj;
}
function disableUserSelect(dom) {
  const domStyle = dom.style;
  domStyle.webkitUserSelect = "none";
  domStyle.userSelect = "none";
  domStyle.webkitTapHighlightColor = "rgba(0,0,0,0)";
  domStyle["-webkit-touch-callout"] = "none";
}
function hasOwn(own, prop) {
  return own.hasOwnProperty(prop);
}
function noop() {
}
var RADIAN_TO_DEGREE = 180 / Math.PI;
var EPSILON = Number.EPSILON || Math.pow(2, -52);

// ../zrender/src/core/vector.ts
var vector_exports = {};
__export(vector_exports, {
  add: () => add,
  applyTransform: () => applyTransform,
  clone: () => clone2,
  copy: () => copy,
  create: () => create,
  dist: () => dist,
  distSquare: () => distSquare,
  distance: () => distance,
  distanceSquare: () => distanceSquare,
  div: () => div,
  dot: () => dot,
  len: () => len,
  lenSquare: () => lenSquare,
  length: () => length,
  lengthSquare: () => lengthSquare,
  lerp: () => lerp,
  max: () => max,
  min: () => min,
  mul: () => mul,
  negate: () => negate,
  normalize: () => normalize,
  scale: () => scale,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set,
  sub: () => sub
});
function create(x, y) {
  if (x == null) {
    x = 0;
  }
  if (y == null) {
    y = 0;
  }
  return [x, y];
}
function copy(out2, v) {
  out2[0] = v[0];
  out2[1] = v[1];
  return out2;
}
function clone2(v) {
  return [v[0], v[1]];
}
function set(out2, a, b) {
  out2[0] = a;
  out2[1] = b;
  return out2;
}
function add(out2, v12, v22) {
  out2[0] = v12[0] + v22[0];
  out2[1] = v12[1] + v22[1];
  return out2;
}
function scaleAndAdd(out2, v12, v22, a) {
  out2[0] = v12[0] + v22[0] * a;
  out2[1] = v12[1] + v22[1] * a;
  return out2;
}
function sub(out2, v12, v22) {
  out2[0] = v12[0] - v22[0];
  out2[1] = v12[1] - v22[1];
  return out2;
}
function len(v) {
  return Math.sqrt(lenSquare(v));
}
var length = len;
function lenSquare(v) {
  return v[0] * v[0] + v[1] * v[1];
}
var lengthSquare = lenSquare;
function mul(out2, v12, v22) {
  out2[0] = v12[0] * v22[0];
  out2[1] = v12[1] * v22[1];
  return out2;
}
function div(out2, v12, v22) {
  out2[0] = v12[0] / v22[0];
  out2[1] = v12[1] / v22[1];
  return out2;
}
function dot(v12, v22) {
  return v12[0] * v22[0] + v12[1] * v22[1];
}
function scale(out2, v, s) {
  out2[0] = v[0] * s;
  out2[1] = v[1] * s;
  return out2;
}
function normalize(out2, v) {
  const d = len(v);
  if (d === 0) {
    out2[0] = 0;
    out2[1] = 0;
  } else {
    out2[0] = v[0] / d;
    out2[1] = v[1] / d;
  }
  return out2;
}
function distance(v12, v22) {
  return Math.sqrt((v12[0] - v22[0]) * (v12[0] - v22[0]) + (v12[1] - v22[1]) * (v12[1] - v22[1]));
}
var dist = distance;
function distanceSquare(v12, v22) {
  return (v12[0] - v22[0]) * (v12[0] - v22[0]) + (v12[1] - v22[1]) * (v12[1] - v22[1]);
}
var distSquare = distanceSquare;
function negate(out2, v) {
  out2[0] = -v[0];
  out2[1] = -v[1];
  return out2;
}
function lerp(out2, v12, v22, t) {
  out2[0] = v12[0] + t * (v22[0] - v12[0]);
  out2[1] = v12[1] + t * (v22[1] - v12[1]);
  return out2;
}
function applyTransform(out2, v, m2) {
  const x = v[0];
  const y = v[1];
  out2[0] = m2[0] * x + m2[2] * y + m2[4];
  out2[1] = m2[1] * x + m2[3] * y + m2[5];
  return out2;
}
function min(out2, v12, v22) {
  out2[0] = Math.min(v12[0], v22[0]);
  out2[1] = Math.min(v12[1], v22[1]);
  return out2;
}
function max(out2, v12, v22) {
  out2[0] = Math.max(v12[0], v22[0]);
  out2[1] = Math.max(v12[1], v22[1]);
  return out2;
}

// ../zrender/src/mixin/Draggable.ts
var Param = class {
  constructor(target, e2) {
    this.target = target;
    this.topTarget = e2 && e2.topTarget;
  }
};
var Draggable = class {
  constructor(handler) {
    this.handler = handler;
    handler.on("mousedown", this._dragStart, this);
    handler.on("mousemove", this._drag, this);
    handler.on("mouseup", this._dragEnd, this);
  }
  _dragStart(e2) {
    let draggingTarget = e2.target;
    while (draggingTarget && !draggingTarget.draggable) {
      draggingTarget = draggingTarget.parent || draggingTarget.__hostTarget;
    }
    if (draggingTarget) {
      this._draggingTarget = draggingTarget;
      draggingTarget.dragging = true;
      this._x = e2.offsetX;
      this._y = e2.offsetY;
      this.handler.dispatchToElement(new Param(draggingTarget, e2), "dragstart", e2.event);
    }
  }
  _drag(e2) {
    const draggingTarget = this._draggingTarget;
    if (draggingTarget) {
      const x = e2.offsetX;
      const y = e2.offsetY;
      const dx = x - this._x;
      const dy = y - this._y;
      this._x = x;
      this._y = y;
      draggingTarget.drift(dx, dy, e2);
      this.handler.dispatchToElement(new Param(draggingTarget, e2), "drag", e2.event);
      const dropTarget = this.handler.findHover(x, y, draggingTarget).target;
      const lastDropTarget = this._dropTarget;
      this._dropTarget = dropTarget;
      if (draggingTarget !== dropTarget) {
        if (lastDropTarget && dropTarget !== lastDropTarget) {
          this.handler.dispatchToElement(new Param(lastDropTarget, e2), "dragleave", e2.event);
        }
        if (dropTarget && dropTarget !== lastDropTarget) {
          this.handler.dispatchToElement(new Param(dropTarget, e2), "dragenter", e2.event);
        }
      }
    }
  }
  _dragEnd(e2) {
    const draggingTarget = this._draggingTarget;
    if (draggingTarget) {
      draggingTarget.dragging = false;
    }
    this.handler.dispatchToElement(new Param(draggingTarget, e2), "dragend", e2.event);
    if (this._dropTarget) {
      this.handler.dispatchToElement(new Param(this._dropTarget, e2), "drop", e2.event);
    }
    this._draggingTarget = null;
    this._dropTarget = null;
  }
};
var Draggable_default = Draggable;

// ../zrender/src/core/Eventful.ts
var Eventful = class {
  constructor(eventProcessors) {
    if (eventProcessors) {
      this._$eventProcessor = eventProcessors;
    }
  }
  on(event, query, handler, context) {
    if (!this._$handlers) {
      this._$handlers = {};
    }
    const _h = this._$handlers;
    if (typeof query === "function") {
      context = handler;
      handler = query;
      query = null;
    }
    if (!handler || !event) {
      return this;
    }
    const eventProcessor = this._$eventProcessor;
    if (query != null && eventProcessor && eventProcessor.normalizeQuery) {
      query = eventProcessor.normalizeQuery(query);
    }
    if (!_h[event]) {
      _h[event] = [];
    }
    for (let i = 0; i < _h[event].length; i++) {
      if (_h[event][i].h === handler) {
        return this;
      }
    }
    const wrap = {
      h: handler,
      query,
      ctx: context || this,
      callAtLast: handler.zrEventfulCallAtLast
    };
    const lastIndex = _h[event].length - 1;
    const lastWrap = _h[event][lastIndex];
    lastWrap && lastWrap.callAtLast ? _h[event].splice(lastIndex, 0, wrap) : _h[event].push(wrap);
    return this;
  }
  isSilent(eventName) {
    const _h = this._$handlers;
    return !_h || !_h[eventName] || !_h[eventName].length;
  }
  off(eventType, handler) {
    const _h = this._$handlers;
    if (!_h) {
      return this;
    }
    if (!eventType) {
      this._$handlers = {};
      return this;
    }
    if (handler) {
      if (_h[eventType]) {
        const newList = [];
        for (let i = 0, l = _h[eventType].length; i < l; i++) {
          if (_h[eventType][i].h !== handler) {
            newList.push(_h[eventType][i]);
          }
        }
        _h[eventType] = newList;
      }
      if (_h[eventType] && _h[eventType].length === 0) {
        delete _h[eventType];
      }
    } else {
      delete _h[eventType];
    }
    return this;
  }
  trigger(eventType, ...args) {
    if (!this._$handlers) {
      return this;
    }
    const _h = this._$handlers[eventType];
    const eventProcessor = this._$eventProcessor;
    if (_h) {
      const argLen = args.length;
      const len2 = _h.length;
      for (let i = 0; i < len2; i++) {
        const hItem = _h[i];
        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(eventType, hItem.query)) {
          continue;
        }
        switch (argLen) {
          case 0:
            hItem.h.call(hItem.ctx);
            break;
          case 1:
            hItem.h.call(hItem.ctx, args[0]);
            break;
          case 2:
            hItem.h.call(hItem.ctx, args[0], args[1]);
            break;
          default:
            hItem.h.apply(hItem.ctx, args);
            break;
        }
      }
    }
    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(eventType);
    return this;
  }
  triggerWithContext(type, ...args) {
    if (!this._$handlers) {
      return this;
    }
    const _h = this._$handlers[type];
    const eventProcessor = this._$eventProcessor;
    if (_h) {
      const argLen = args.length;
      const ctx = args[argLen - 1];
      const len2 = _h.length;
      for (let i = 0; i < len2; i++) {
        const hItem = _h[i];
        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
          continue;
        }
        switch (argLen) {
          case 0:
            hItem.h.call(ctx);
            break;
          case 1:
            hItem.h.call(ctx, args[0]);
            break;
          case 2:
            hItem.h.call(ctx, args[0], args[1]);
            break;
          default:
            hItem.h.apply(ctx, args.slice(1, argLen - 1));
            break;
        }
      }
    }
    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
    return this;
  }
};
var Eventful_default = Eventful;

// ../zrender/src/core/fourPointsTransform.ts
var LN2 = Math.log(2);
function determinant(rows, rank, rowStart, rowMask, colMask, detCache) {
  const cacheKey = rowMask + "-" + colMask;
  const fullRank = rows.length;
  if (detCache.hasOwnProperty(cacheKey)) {
    return detCache[cacheKey];
  }
  if (rank === 1) {
    const colStart = Math.round(Math.log((1 << fullRank) - 1 & ~colMask) / LN2);
    return rows[rowStart][colStart];
  }
  const subRowMask = rowMask | 1 << rowStart;
  let subRowStart = rowStart + 1;
  while (rowMask & 1 << subRowStart) {
    subRowStart++;
  }
  let sum2 = 0;
  for (let j = 0, colLocalIdx = 0; j < fullRank; j++) {
    const colTag = 1 << j;
    if (!(colTag & colMask)) {
      sum2 += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j] * determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache);
      colLocalIdx++;
    }
  }
  detCache[cacheKey] = sum2;
  return sum2;
}
function buildTransformer(src, dest) {
  const mA = [
    [src[0], src[1], 1, 0, 0, 0, -dest[0] * src[0], -dest[0] * src[1]],
    [0, 0, 0, src[0], src[1], 1, -dest[1] * src[0], -dest[1] * src[1]],
    [src[2], src[3], 1, 0, 0, 0, -dest[2] * src[2], -dest[2] * src[3]],
    [0, 0, 0, src[2], src[3], 1, -dest[3] * src[2], -dest[3] * src[3]],
    [src[4], src[5], 1, 0, 0, 0, -dest[4] * src[4], -dest[4] * src[5]],
    [0, 0, 0, src[4], src[5], 1, -dest[5] * src[4], -dest[5] * src[5]],
    [src[6], src[7], 1, 0, 0, 0, -dest[6] * src[6], -dest[6] * src[7]],
    [0, 0, 0, src[6], src[7], 1, -dest[7] * src[6], -dest[7] * src[7]]
  ];
  const detCache = {};
  const det = determinant(mA, 8, 0, 0, 0, detCache);
  if (det === 0) {
    return;
  }
  const vh = [];
  for (let i = 0; i < 8; i++) {
    for (let j = 0; j < 8; j++) {
      vh[j] == null && (vh[j] = 0);
      vh[j] += ((i + j) % 2 ? -1 : 1) * determinant(mA, 7, i === 0 ? 1 : 0, 1 << i, 1 << j, detCache) / det * dest[i];
    }
  }
  return function(out2, srcPointX, srcPointY) {
    const pk = srcPointX * vh[6] + srcPointY * vh[7] + 1;
    out2[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk;
    out2[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk;
  };
}

// ../zrender/src/core/dom.ts
var EVENT_SAVED_PROP = "___zrEVENTSAVED";
var _calcOut = [];
function transformLocalCoord(out2, elFrom, elTarget, inX, inY) {
  return transformCoordWithViewport(_calcOut, elFrom, inX, inY, true) && transformCoordWithViewport(out2, elTarget, _calcOut[0], _calcOut[1]);
}
function transformLocalCoordClear(elFrom, elTarget) {
  elFrom && dealClear(elFrom);
  elTarget && dealClear(elTarget);
  function dealClear(el) {
    const saved = el[EVENT_SAVED_PROP];
    if (saved) {
      saved.clearMarkers && saved.clearMarkers();
      delete el[EVENT_SAVED_PROP];
    }
  }
}
function transformCoordWithViewport(out2, el, inX, inY, inverse) {
  if (el.getBoundingClientRect && env_default.domSupported && !isCanvasEl(el)) {
    const saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});
    const markers = prepareCoordMarkers(el, saved);
    const transformer = preparePointerTransformer(markers, saved, inverse);
    if (transformer) {
      transformer(out2, inX, inY);
      return true;
    }
  }
  return false;
}
function prepareCoordMarkers(el, saved) {
  let markers = saved.markers;
  if (markers) {
    return markers;
  }
  markers = saved.markers = [];
  const propLR = ["left", "right"];
  const propTB = ["top", "bottom"];
  for (let i = 0; i < 4; i++) {
    const marker = document.createElement("div");
    const stl = marker.style;
    const idxLR = i % 2;
    const idxTB = (i >> 1) % 2;
    stl.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      propLR[idxLR] + ":0",
      propTB[idxTB] + ":0",
      propLR[1 - idxLR] + ":auto",
      propTB[1 - idxTB] + ":auto",
      ""
    ].join("!important;");
    el.appendChild(marker);
    markers.push(marker);
  }
  saved.clearMarkers = function() {
    each(markers, function(marker) {
      marker.parentNode && marker.parentNode.removeChild(marker);
    });
  };
  return markers;
}
function preparePointerTransformer(markers, saved, inverse) {
  const transformerName = inverse ? "invTrans" : "trans";
  const transformer = saved[transformerName];
  const oldSrcCoords = saved.srcCoords;
  const srcCoords = [];
  const destCoords = [];
  let oldCoordTheSame = true;
  for (let i = 0; i < 4; i++) {
    const rect = markers[i].getBoundingClientRect();
    const ii = 2 * i;
    const x = rect.left;
    const y = rect.top;
    srcCoords.push(x, y);
    oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1];
    destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);
  }
  return oldCoordTheSame && transformer ? transformer : (saved.srcCoords = srcCoords, saved[transformerName] = inverse ? buildTransformer(destCoords, srcCoords) : buildTransformer(srcCoords, destCoords));
}
function isCanvasEl(el) {
  return el.nodeName.toUpperCase() === "CANVAS";
}
var replaceReg = /([&<>"'])/g;
var replaceMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function encodeHTML(source) {
  return source == null ? "" : (source + "").replace(replaceReg, function(str, c) {
    return replaceMap[c];
  });
}

// ../zrender/src/core/event.ts
var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
var _calcOut2 = [];
var firefoxNotSupportOffsetXY = env_default.browser.firefox && +env_default.browser.version.split(".")[0] < 39;
function clientToLocal(el, e2, out2, calculate) {
  out2 = out2 || {};
  if (calculate) {
    calculateZrXY(el, e2, out2);
  } else if (firefoxNotSupportOffsetXY && e2.layerX != null && e2.layerX !== e2.offsetX) {
    out2.zrX = e2.layerX;
    out2.zrY = e2.layerY;
  } else if (e2.offsetX != null) {
    out2.zrX = e2.offsetX;
    out2.zrY = e2.offsetY;
  } else {
    calculateZrXY(el, e2, out2);
  }
  return out2;
}
function calculateZrXY(el, e2, out2) {
  if (env_default.domSupported && el.getBoundingClientRect) {
    const ex = e2.clientX;
    const ey = e2.clientY;
    if (isCanvasEl(el)) {
      const box2 = el.getBoundingClientRect();
      out2.zrX = ex - box2.left;
      out2.zrY = ey - box2.top;
      return;
    } else {
      if (transformCoordWithViewport(_calcOut2, el, ex, ey)) {
        out2.zrX = _calcOut2[0];
        out2.zrY = _calcOut2[1];
        return;
      }
    }
  }
  out2.zrX = out2.zrY = 0;
}
function getNativeEvent(e2) {
  return e2 || window.event;
}
function normalizeEvent(el, e2, calculate) {
  e2 = getNativeEvent(e2);
  if (e2.zrX != null) {
    return e2;
  }
  const eventType = e2.type;
  const isTouch = eventType && eventType.indexOf("touch") >= 0;
  if (!isTouch) {
    clientToLocal(el, e2, e2, calculate);
    const wheelDelta = getWheelDeltaMayPolyfill(e2);
    e2.zrDelta = wheelDelta ? wheelDelta / 120 : -(e2.detail || 0) / 3;
  } else {
    const touch = eventType !== "touchend" ? e2.targetTouches[0] : e2.changedTouches[0];
    touch && clientToLocal(el, touch, e2, calculate);
  }
  const button = e2.button;
  if (e2.which == null && button !== void 0 && MOUSE_EVENT_REG.test(e2.type)) {
    e2.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
  }
  return e2;
}
function getWheelDeltaMayPolyfill(e2) {
  const rawWheelDelta = e2.wheelDelta;
  if (rawWheelDelta) {
    return rawWheelDelta;
  }
  const deltaX = e2.deltaX;
  const deltaY = e2.deltaY;
  if (deltaX == null || deltaY == null) {
    return rawWheelDelta;
  }
  const delta = deltaY !== 0 ? Math.abs(deltaY) : Math.abs(deltaX);
  const sign = deltaY > 0 ? -1 : deltaY < 0 ? 1 : deltaX > 0 ? -1 : 1;
  return 3 * delta * sign;
}
function addEventListener(el, name, handler, opt) {
  el.addEventListener(name, handler, opt);
}
function removeEventListener(el, name, handler, opt) {
  el.removeEventListener(name, handler, opt);
}
var stop = function(e2) {
  e2.preventDefault();
  e2.stopPropagation();
  e2.cancelBubble = true;
};
function isMiddleOrRightButtonOnMouseUpDown(e2) {
  return e2.which === 2 || e2.which === 3;
}

// ../zrender/src/core/GestureMgr.ts
var GestureMgr = class {
  constructor() {
    this._track = [];
  }
  recognize(event, target, root) {
    this._doTrack(event, target, root);
    return this._recognize(event);
  }
  clear() {
    this._track.length = 0;
    return this;
  }
  _doTrack(event, target, root) {
    const touches = event.touches;
    if (!touches) {
      return;
    }
    const trackItem = {
      points: [],
      touches: [],
      target,
      event
    };
    for (let i = 0, len2 = touches.length; i < len2; i++) {
      const touch = touches[i];
      const pos = clientToLocal(root, touch, {});
      trackItem.points.push([pos.zrX, pos.zrY]);
      trackItem.touches.push(touch);
    }
    this._track.push(trackItem);
  }
  _recognize(event) {
    for (let eventName in recognizers) {
      if (recognizers.hasOwnProperty(eventName)) {
        const gestureInfo = recognizers[eventName](this._track, event);
        if (gestureInfo) {
          return gestureInfo;
        }
      }
    }
  }
};
function dist2(pointPair) {
  const dx = pointPair[1][0] - pointPair[0][0];
  const dy = pointPair[1][1] - pointPair[0][1];
  return Math.sqrt(dx * dx + dy * dy);
}
function center(pointPair) {
  return [
    (pointPair[0][0] + pointPair[1][0]) / 2,
    (pointPair[0][1] + pointPair[1][1]) / 2
  ];
}
var recognizers = {
  pinch: function(tracks, event) {
    const trackLen = tracks.length;
    if (!trackLen) {
      return;
    }
    const pinchEnd = (tracks[trackLen - 1] || {}).points;
    const pinchPre = (tracks[trackLen - 2] || {}).points || pinchEnd;
    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
      let pinchScale = dist2(pinchEnd) / dist2(pinchPre);
      !isFinite(pinchScale) && (pinchScale = 1);
      event.pinchScale = pinchScale;
      const pinchCenter = center(pinchEnd);
      event.pinchX = pinchCenter[0];
      event.pinchY = pinchCenter[1];
      return {
        type: "pinch",
        target: tracks[0].target,
        event
      };
    }
  }
};

// ../zrender/src/core/matrix.ts
var matrix_exports = {};
__export(matrix_exports, {
  clone: () => clone3,
  copy: () => copy2,
  create: () => create2,
  identity: () => identity,
  invert: () => invert,
  mul: () => mul2,
  rotate: () => rotate,
  scale: () => scale2,
  translate: () => translate
});
function create2() {
  return [1, 0, 0, 1, 0, 0];
}
function identity(out2) {
  out2[0] = 1;
  out2[1] = 0;
  out2[2] = 0;
  out2[3] = 1;
  out2[4] = 0;
  out2[5] = 0;
  return out2;
}
function copy2(out2, m2) {
  out2[0] = m2[0];
  out2[1] = m2[1];
  out2[2] = m2[2];
  out2[3] = m2[3];
  out2[4] = m2[4];
  out2[5] = m2[5];
  return out2;
}
function mul2(out2, m1, m2) {
  const out0 = m1[0] * m2[0] + m1[2] * m2[1];
  const out1 = m1[1] * m2[0] + m1[3] * m2[1];
  const out22 = m1[0] * m2[2] + m1[2] * m2[3];
  const out3 = m1[1] * m2[2] + m1[3] * m2[3];
  const out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
  const out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
  out2[0] = out0;
  out2[1] = out1;
  out2[2] = out22;
  out2[3] = out3;
  out2[4] = out4;
  out2[5] = out5;
  return out2;
}
function translate(out2, a, v) {
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  out2[3] = a[3];
  out2[4] = a[4] + v[0];
  out2[5] = a[5] + v[1];
  return out2;
}
function rotate(out2, a, rad, pivot = [0, 0]) {
  const aa = a[0];
  const ac = a[2];
  const atx = a[4];
  const ab = a[1];
  const ad = a[3];
  const aty = a[5];
  const st = Math.sin(rad);
  const ct = Math.cos(rad);
  out2[0] = aa * ct + ab * st;
  out2[1] = -aa * st + ab * ct;
  out2[2] = ac * ct + ad * st;
  out2[3] = -ac * st + ct * ad;
  out2[4] = ct * (atx - pivot[0]) + st * (aty - pivot[1]) + pivot[0];
  out2[5] = ct * (aty - pivot[1]) - st * (atx - pivot[0]) + pivot[1];
  return out2;
}
function scale2(out2, a, v) {
  const vx = v[0];
  const vy = v[1];
  out2[0] = a[0] * vx;
  out2[1] = a[1] * vy;
  out2[2] = a[2] * vx;
  out2[3] = a[3] * vy;
  out2[4] = a[4] * vx;
  out2[5] = a[5] * vy;
  return out2;
}
function invert(out2, a) {
  const aa = a[0];
  const ac = a[2];
  const atx = a[4];
  const ab = a[1];
  const ad = a[3];
  const aty = a[5];
  let det = aa * ad - ab * ac;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out2[0] = ad * det;
  out2[1] = -ab * det;
  out2[2] = -ac * det;
  out2[3] = aa * det;
  out2[4] = (ac * aty - ad * atx) * det;
  out2[5] = (ab * atx - aa * aty) * det;
  return out2;
}
function clone3(a) {
  const b = create2();
  copy2(b, a);
  return b;
}

// ../zrender/src/core/Point.ts
var Point = class {
  constructor(x, y) {
    this.x = x || 0;
    this.y = y || 0;
  }
  copy(other) {
    this.x = other.x;
    this.y = other.y;
    return this;
  }
  clone() {
    return new Point(this.x, this.y);
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  equal(other) {
    return other.x === this.x && other.y === this.y;
  }
  add(other) {
    this.x += other.x;
    this.y += other.y;
    return this;
  }
  scale(scalar) {
    this.x *= scalar;
    this.y *= scalar;
  }
  scaleAndAdd(other, scalar) {
    this.x += other.x * scalar;
    this.y += other.y * scalar;
  }
  sub(other) {
    this.x -= other.x;
    this.y -= other.y;
    return this;
  }
  dot(other) {
    return this.x * other.x + this.y * other.y;
  }
  len() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  lenSquare() {
    return this.x * this.x + this.y * this.y;
  }
  normalize() {
    const len2 = this.len();
    this.x /= len2;
    this.y /= len2;
    return this;
  }
  distance(other) {
    const dx = this.x - other.x;
    const dy = this.y - other.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
  distanceSquare(other) {
    const dx = this.x - other.x;
    const dy = this.y - other.y;
    return dx * dx + dy * dy;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  transform(m2) {
    if (!m2) {
      return;
    }
    const x = this.x;
    const y = this.y;
    this.x = m2[0] * x + m2[2] * y + m2[4];
    this.y = m2[1] * x + m2[3] * y + m2[5];
    return this;
  }
  toArray(out2) {
    out2[0] = this.x;
    out2[1] = this.y;
    return out2;
  }
  fromArray(input) {
    this.x = input[0];
    this.y = input[1];
  }
  static set(p, x, y) {
    p.x = x;
    p.y = y;
  }
  static copy(p, p2) {
    p.x = p2.x;
    p.y = p2.y;
  }
  static len(p) {
    return Math.sqrt(p.x * p.x + p.y * p.y);
  }
  static lenSquare(p) {
    return p.x * p.x + p.y * p.y;
  }
  static dot(p0, p1) {
    return p0.x * p1.x + p0.y * p1.y;
  }
  static add(out2, p0, p1) {
    out2.x = p0.x + p1.x;
    out2.y = p0.y + p1.y;
  }
  static sub(out2, p0, p1) {
    out2.x = p0.x - p1.x;
    out2.y = p0.y - p1.y;
  }
  static scale(out2, p0, scalar) {
    out2.x = p0.x * scalar;
    out2.y = p0.y * scalar;
  }
  static scaleAndAdd(out2, p0, p1, scalar) {
    out2.x = p0.x + p1.x * scalar;
    out2.y = p0.y + p1.y * scalar;
  }
  static lerp(out2, p0, p1, t) {
    const onet = 1 - t;
    out2.x = onet * p0.x + t * p1.x;
    out2.y = onet * p0.y + t * p1.y;
  }
};
var Point_default = Point;

// ../zrender/src/core/BoundingRect.ts
var mathMin = Math.min;
var mathMax = Math.max;
var mathAbs = Math.abs;
var XY = ["x", "y"];
var WH = ["width", "height"];
var lt = new Point_default();
var rb = new Point_default();
var lb = new Point_default();
var rt = new Point_default();
var _intersectCtx = createIntersectContext();
var _minTv = _intersectCtx.minTv;
var _maxTv = _intersectCtx.maxTv;
var _lenMinMax = [0, 0];
var BoundingRect = class {
  constructor(x, y, width, height) {
    BoundingRect.set(this, x, y, width, height);
  }
  static set(target, x, y, width, height) {
    if (width < 0) {
      x = x + width;
      width = -width;
    }
    if (height < 0) {
      y = y + height;
      height = -height;
    }
    target.x = x;
    target.y = y;
    target.width = width;
    target.height = height;
    return target;
  }
  union(other) {
    const x = mathMin(other.x, this.x);
    const y = mathMin(other.y, this.y);
    if (isFinite(this.x) && isFinite(this.width)) {
      this.width = mathMax(other.x + other.width, this.x + this.width) - x;
    } else {
      this.width = other.width;
    }
    if (isFinite(this.y) && isFinite(this.height)) {
      this.height = mathMax(other.y + other.height, this.y + this.height) - y;
    } else {
      this.height = other.height;
    }
    this.x = x;
    this.y = y;
  }
  applyTransform(m2) {
    BoundingRect.applyTransform(this, this, m2);
  }
  calculateTransform(b) {
    const a = this;
    const sx = b.width / a.width;
    const sy = b.height / a.height;
    const m2 = create2();
    translate(m2, m2, [-a.x, -a.y]);
    scale2(m2, m2, [sx, sy]);
    translate(m2, m2, [b.x, b.y]);
    return m2;
  }
  intersect(b, mtv, opt) {
    return BoundingRect.intersect(this, b, mtv, opt);
  }
  static intersect(a, b, mtv, opt) {
    if (mtv) {
      Point_default.set(mtv, 0, 0);
    }
    const outIntersectRect = opt && opt.outIntersectRect || null;
    const clamp2 = opt && opt.clamp;
    if (outIntersectRect) {
      outIntersectRect.x = outIntersectRect.y = outIntersectRect.width = outIntersectRect.height = NaN;
    }
    if (!a || !b) {
      return false;
    }
    if (!(a instanceof BoundingRect)) {
      a = BoundingRect.set(_tmpIntersectA, a.x, a.y, a.width, a.height);
    }
    if (!(b instanceof BoundingRect)) {
      b = BoundingRect.set(_tmpIntersectB, b.x, b.y, b.width, b.height);
    }
    const useMTV = !!mtv;
    _intersectCtx.reset(opt, useMTV);
    const touchThreshold = _intersectCtx.touchThreshold;
    const ax0 = a.x + touchThreshold;
    const ax1 = a.x + a.width - touchThreshold;
    const ay0 = a.y + touchThreshold;
    const ay1 = a.y + a.height - touchThreshold;
    const bx0 = b.x + touchThreshold;
    const bx1 = b.x + b.width - touchThreshold;
    const by0 = b.y + touchThreshold;
    const by1 = b.y + b.height - touchThreshold;
    if (ax0 > ax1 || ay0 > ay1 || bx0 > bx1 || by0 > by1) {
      return false;
    }
    const overlap = !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
    if (useMTV || outIntersectRect) {
      _lenMinMax[0] = Infinity;
      _lenMinMax[1] = 0;
      intersectOneDim(ax0, ax1, bx0, bx1, 0, useMTV, outIntersectRect, clamp2);
      intersectOneDim(ay0, ay1, by0, by1, 1, useMTV, outIntersectRect, clamp2);
      if (useMTV) {
        Point_default.copy(mtv, overlap ? _intersectCtx.useDir ? _intersectCtx.dirMinTv : _minTv : _maxTv);
      }
    }
    return overlap;
  }
  static contain(rect, x, y) {
    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
  }
  contain(x, y) {
    return BoundingRect.contain(this, x, y);
  }
  clone() {
    return new BoundingRect(this.x, this.y, this.width, this.height);
  }
  copy(other) {
    BoundingRect.copy(this, other);
  }
  plain() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }
  isFinite() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  }
  isZero() {
    return this.width === 0 || this.height === 0;
  }
  static create(rect) {
    return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
  }
  static copy(target, source) {
    target.x = source.x;
    target.y = source.y;
    target.width = source.width;
    target.height = source.height;
    return target;
  }
  static applyTransform(target, source, m2) {
    if (!m2) {
      if (target !== source) {
        BoundingRect.copy(target, source);
      }
      return;
    }
    if (m2[1] < 1e-5 && m2[1] > -1e-5 && m2[2] < 1e-5 && m2[2] > -1e-5) {
      const sx = m2[0];
      const sy = m2[3];
      const tx = m2[4];
      const ty = m2[5];
      target.x = source.x * sx + tx;
      target.y = source.y * sy + ty;
      target.width = source.width * sx;
      target.height = source.height * sy;
      if (target.width < 0) {
        target.x += target.width;
        target.width = -target.width;
      }
      if (target.height < 0) {
        target.y += target.height;
        target.height = -target.height;
      }
      return;
    }
    lt.x = lb.x = source.x;
    lt.y = rt.y = source.y;
    rb.x = rt.x = source.x + source.width;
    rb.y = lb.y = source.y + source.height;
    lt.transform(m2);
    rt.transform(m2);
    rb.transform(m2);
    lb.transform(m2);
    target.x = mathMin(lt.x, rb.x, lb.x, rt.x);
    target.y = mathMin(lt.y, rb.y, lb.y, rt.y);
    const maxX = mathMax(lt.x, rb.x, lb.x, rt.x);
    const maxY = mathMax(lt.y, rb.y, lb.y, rt.y);
    target.width = maxX - target.x;
    target.height = maxY - target.y;
  }
};
var _tmpIntersectA = new BoundingRect(0, 0, 0, 0);
var _tmpIntersectB = new BoundingRect(0, 0, 0, 0);
function intersectOneDim(a0, a1, b0, b1, updateDimIdx, useMTV, outIntersectRect, clamp2) {
  const d0 = mathAbs(a1 - b0);
  const d1 = mathAbs(b1 - a0);
  const d01min = mathMin(d0, d1);
  const updateDim = XY[updateDimIdx];
  const zeroDim = XY[1 - updateDimIdx];
  const wh = WH[updateDimIdx];
  if (a1 < b0 || b1 < a0) {
    if (d0 < d1) {
      if (useMTV) {
        _maxTv[updateDim] = -d0;
      }
      if (clamp2) {
        outIntersectRect[updateDim] = a1;
        outIntersectRect[wh] = 0;
      }
    } else {
      if (useMTV) {
        _maxTv[updateDim] = d1;
      }
      if (clamp2) {
        outIntersectRect[updateDim] = a0;
        outIntersectRect[wh] = 0;
      }
    }
  } else {
    if (outIntersectRect) {
      outIntersectRect[updateDim] = mathMax(a0, b0);
      outIntersectRect[wh] = mathMin(a1, b1) - outIntersectRect[updateDim];
    }
    if (useMTV) {
      if (d01min < _lenMinMax[0] || _intersectCtx.useDir) {
        _lenMinMax[0] = mathMin(d01min, _lenMinMax[0]);
        if (d0 < d1 || !_intersectCtx.bidirectional) {
          _minTv[updateDim] = d0;
          _minTv[zeroDim] = 0;
          if (_intersectCtx.useDir) {
            _intersectCtx.calcDirMTV();
          }
        }
        if (d0 >= d1 || !_intersectCtx.bidirectional) {
          _minTv[updateDim] = -d1;
          _minTv[zeroDim] = 0;
          if (_intersectCtx.useDir) {
            _intersectCtx.calcDirMTV();
          }
        }
      }
    }
  }
}
function createIntersectContext() {
  let _direction = 0;
  const _dirCheckVec = new Point_default();
  const _dirTmp = new Point_default();
  const _ctx = {
    minTv: new Point_default(),
    maxTv: new Point_default(),
    useDir: false,
    dirMinTv: new Point_default(),
    touchThreshold: 0,
    bidirectional: true,
    negativeSize: false,
    reset(opt, useMTV) {
      _ctx.touchThreshold = 0;
      if (opt && opt.touchThreshold != null) {
        _ctx.touchThreshold = mathMax(0, opt.touchThreshold);
      }
      _ctx.negativeSize = false;
      if (!useMTV) {
        return;
      }
      _ctx.minTv.set(Infinity, Infinity);
      _ctx.maxTv.set(0, 0);
      _ctx.useDir = false;
      if (opt && opt.direction != null) {
        _ctx.useDir = true;
        _ctx.dirMinTv.copy(_ctx.minTv);
        _dirTmp.copy(_ctx.minTv);
        _direction = opt.direction;
        _ctx.bidirectional = opt.bidirectional == null || !!opt.bidirectional;
        if (!_ctx.bidirectional) {
          _dirCheckVec.set(Math.cos(_direction), Math.sin(_direction));
        }
      }
    },
    calcDirMTV() {
      const minTv = _ctx.minTv;
      const dirMinTv = _ctx.dirMinTv;
      const squareMag = minTv.y * minTv.y + minTv.x * minTv.x;
      const dirSin = Math.sin(_direction);
      const dirCos = Math.cos(_direction);
      const dotProd = dirSin * minTv.y + dirCos * minTv.x;
      if (nearZero2(dotProd)) {
        if (nearZero2(minTv.x) && nearZero2(minTv.y)) {
          dirMinTv.set(0, 0);
        }
        return;
      }
      _dirTmp.x = squareMag * dirCos / dotProd;
      _dirTmp.y = squareMag * dirSin / dotProd;
      if (nearZero2(_dirTmp.x) && nearZero2(_dirTmp.y)) {
        dirMinTv.set(0, 0);
        return;
      }
      if ((_ctx.bidirectional || _dirCheckVec.dot(_dirTmp) > 0) && _dirTmp.len() < dirMinTv.len()) {
        dirMinTv.copy(_dirTmp);
      }
    }
  };
  function nearZero2(val) {
    return mathAbs(val) < 1e-10;
  }
  return _ctx;
}
var BoundingRect_default = BoundingRect;

// ../zrender/src/Handler.ts
var SILENT = "silent";
function makeEventPacket(eveType, targetInfo, event) {
  return {
    type: eveType,
    event,
    target: targetInfo.target,
    topTarget: targetInfo.topTarget,
    cancelBubble: false,
    offsetX: event.zrX,
    offsetY: event.zrY,
    gestureEvent: event.gestureEvent,
    pinchX: event.pinchX,
    pinchY: event.pinchY,
    pinchScale: event.pinchScale,
    wheelDelta: event.zrDelta,
    zrByTouch: event.zrByTouch,
    which: event.which,
    stop: stopEvent
  };
}
function stopEvent() {
  stop(this.event);
}
var EmptyProxy = class extends Eventful_default {
  constructor() {
    super(...arguments);
    this.handler = null;
  }
  dispose() {
  }
  setCursor() {
  }
};
var HoveredResult = class {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
};
var handlerNames = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
];
var tmpRect = new BoundingRect_default(0, 0, 0, 0);
var Handler = class extends Eventful_default {
  constructor(storage2, painter, proxy, painterRoot, pointerSize) {
    super();
    this._hovered = new HoveredResult(0, 0);
    this.storage = storage2;
    this.painter = painter;
    this.painterRoot = painterRoot;
    this._pointerSize = pointerSize;
    proxy = proxy || new EmptyProxy();
    this.proxy = null;
    this.setHandlerProxy(proxy);
    this._draggingMgr = new Draggable_default(this);
  }
  setHandlerProxy(proxy) {
    if (this.proxy) {
      this.proxy.dispose();
    }
    if (proxy) {
      each(handlerNames, function(name) {
        proxy.on && proxy.on(name, this[name], this);
      }, this);
      proxy.handler = this;
    }
    this.proxy = proxy;
  }
  mousemove(event) {
    const x = event.zrX;
    const y = event.zrY;
    const isOutside = isOutsideBoundary(this, x, y);
    let lastHovered = this._hovered;
    let lastHoveredTarget = lastHovered.target;
    if (lastHoveredTarget && !lastHoveredTarget.__zr) {
      lastHovered = this.findHover(lastHovered.x, lastHovered.y);
      lastHoveredTarget = lastHovered.target;
    }
    const hovered = this._hovered = isOutside ? new HoveredResult(x, y) : this.findHover(x, y);
    const hoveredTarget = hovered.target;
    const proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : "default");
    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(lastHovered, "mouseout", event);
    }
    this.dispatchToElement(hovered, "mousemove", event);
    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(hovered, "mouseover", event);
    }
  }
  mouseout(event) {
    const eventControl = event.zrEventControl;
    if (eventControl !== "only_globalout") {
      this.dispatchToElement(this._hovered, "mouseout", event);
    }
    if (eventControl !== "no_globalout") {
      this.trigger("globalout", {type: "globalout", event});
    }
  }
  resize() {
    this._hovered = new HoveredResult(0, 0);
  }
  dispatch(eventName, eventArgs) {
    const handler = this[eventName];
    handler && handler.call(this, eventArgs);
  }
  dispose() {
    this.proxy.dispose();
    this.storage = null;
    this.proxy = null;
    this.painter = null;
  }
  setCursorStyle(cursorStyle) {
    const proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(cursorStyle);
  }
  dispatchToElement(targetInfo, eventName, event) {
    targetInfo = targetInfo || {};
    let el = targetInfo.target;
    if (el && el.silent) {
      return;
    }
    const eventKey = "on" + eventName;
    const eventPacket = makeEventPacket(eventName, targetInfo, event);
    while (el) {
      el[eventKey] && (eventPacket.cancelBubble = !!el[eventKey].call(el, eventPacket));
      el.trigger(eventName, eventPacket);
      el = el.__hostTarget ? el.__hostTarget : el.parent;
      if (eventPacket.cancelBubble) {
        break;
      }
    }
    if (!eventPacket.cancelBubble) {
      this.trigger(eventName, eventPacket);
      if (this.painter && this.painter.eachOtherLayer) {
        this.painter.eachOtherLayer(function(layer) {
          if (typeof layer[eventKey] === "function") {
            layer[eventKey].call(layer, eventPacket);
          }
          if (layer.trigger) {
            layer.trigger(eventName, eventPacket);
          }
        });
      }
    }
  }
  findHover(x, y, exclude) {
    const list = this.storage.getDisplayList();
    const out2 = new HoveredResult(x, y);
    setHoverTarget(list, out2, x, y, exclude);
    if (this._pointerSize && !out2.target) {
      const candidates = [];
      const pointerSize = this._pointerSize;
      const targetSizeHalf = pointerSize / 2;
      const pointerRect = new BoundingRect_default(x - targetSizeHalf, y - targetSizeHalf, pointerSize, pointerSize);
      for (let i = list.length - 1; i >= 0; i--) {
        const el = list[i];
        if (el !== exclude && !el.ignore && !el.ignoreCoarsePointer && (!el.parent || !el.parent.ignoreCoarsePointer)) {
          tmpRect.copy(el.getBoundingRect());
          if (el.transform) {
            tmpRect.applyTransform(el.transform);
          }
          if (tmpRect.intersect(pointerRect)) {
            candidates.push(el);
          }
        }
      }
      if (candidates.length) {
        const rStep = 4;
        const thetaStep = Math.PI / 12;
        const PI210 = Math.PI * 2;
        for (let r = 0; r < targetSizeHalf; r += rStep) {
          for (let theta = 0; theta < PI210; theta += thetaStep) {
            const x1 = x + r * Math.cos(theta);
            const y1 = y + r * Math.sin(theta);
            setHoverTarget(candidates, out2, x1, y1, exclude);
            if (out2.target) {
              return out2;
            }
          }
        }
      }
    }
    return out2;
  }
  processGesture(event, stage) {
    if (!this._gestureMgr) {
      this._gestureMgr = new GestureMgr();
    }
    const gestureMgr = this._gestureMgr;
    stage === "start" && gestureMgr.clear();
    const gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);
    stage === "end" && gestureMgr.clear();
    if (gestureInfo) {
      const type = gestureInfo.type;
      event.gestureEvent = type;
      let res = new HoveredResult();
      res.target = gestureInfo.target;
      this.dispatchToElement(res, type, gestureInfo.event);
    }
  }
};
each(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(name) {
  Handler.prototype[name] = function(event) {
    const x = event.zrX;
    const y = event.zrY;
    const isOutside = isOutsideBoundary(this, x, y);
    let hovered;
    let hoveredTarget;
    if (name !== "mouseup" || !isOutside) {
      hovered = this.findHover(x, y);
      hoveredTarget = hovered.target;
    }
    if (name === "mousedown") {
      this._downEl = hoveredTarget;
      this._downPoint = [event.zrX, event.zrY];
      this._upEl = hoveredTarget;
    } else if (name === "mouseup") {
      this._upEl = hoveredTarget;
    } else if (name === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || dist(this._downPoint, [event.zrX, event.zrY]) > 4) {
        return;
      }
      this._downPoint = null;
    }
    this.dispatchToElement(hovered, name, event);
  };
});
function isHover(displayable, x, y) {
  if (displayable[displayable.rectHover ? "rectContain" : "contain"](x, y)) {
    let el = displayable;
    let isSilent;
    let ignoreClip = false;
    while (el) {
      if (el.ignoreClip) {
        ignoreClip = true;
      }
      if (!ignoreClip) {
        let clipPath = el.getClipPath();
        if (clipPath && !clipPath.contain(x, y)) {
          return false;
        }
      }
      if (el.silent) {
        isSilent = true;
      }
      const hostEl = el.__hostTarget;
      el = hostEl ? el.ignoreHostSilent ? null : hostEl : el.parent;
    }
    return isSilent ? SILENT : true;
  }
  return false;
}
function setHoverTarget(list, out2, x, y, exclude) {
  for (let i = list.length - 1; i >= 0; i--) {
    const el = list[i];
    let hoverCheckResult;
    if (el !== exclude && !el.ignore && (hoverCheckResult = isHover(el, x, y))) {
      !out2.topTarget && (out2.topTarget = el);
      if (hoverCheckResult !== SILENT) {
        out2.target = el;
        break;
      }
    }
  }
}
function isOutsideBoundary(handlerInstance, x, y) {
  const painter = handlerInstance.painter;
  return x < 0 || x > painter.getWidth() || y < 0 || y > painter.getHeight();
}
var Handler_default = Handler;

// ../zrender/src/core/timsort.ts
var DEFAULT_MIN_MERGE = 32;
var DEFAULT_MIN_GALLOPING = 7;
function minRunLength(n) {
  var r = 0;
  while (n >= DEFAULT_MIN_MERGE) {
    r |= n & 1;
    n >>= 1;
  }
  return n + r;
}
function makeAscendingRun(array, lo, hi, compare2) {
  var runHi = lo + 1;
  if (runHi === hi) {
    return 1;
  }
  if (compare2(array[runHi++], array[lo]) < 0) {
    while (runHi < hi && compare2(array[runHi], array[runHi - 1]) < 0) {
      runHi++;
    }
    reverseRun(array, lo, runHi);
  } else {
    while (runHi < hi && compare2(array[runHi], array[runHi - 1]) >= 0) {
      runHi++;
    }
  }
  return runHi - lo;
}
function reverseRun(array, lo, hi) {
  hi--;
  while (lo < hi) {
    var t = array[lo];
    array[lo++] = array[hi];
    array[hi--] = t;
  }
}
function binaryInsertionSort(array, lo, hi, start2, compare2) {
  if (start2 === lo) {
    start2++;
  }
  for (; start2 < hi; start2++) {
    var pivot = array[start2];
    var left = lo;
    var right = start2;
    var mid;
    while (left < right) {
      mid = left + right >>> 1;
      if (compare2(pivot, array[mid]) < 0) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }
    var n = start2 - left;
    switch (n) {
      case 3:
        array[left + 3] = array[left + 2];
      case 2:
        array[left + 2] = array[left + 1];
      case 1:
        array[left + 1] = array[left];
        break;
      default:
        while (n > 0) {
          array[left + n] = array[left + n - 1];
          n--;
        }
    }
    array[left] = pivot;
  }
}
function gallopLeft(value, array, start2, length2, hint, compare2) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset = 1;
  if (compare2(value, array[start2 + hint]) > 0) {
    maxOffset = length2 - hint;
    while (offset < maxOffset && compare2(value, array[start2 + hint + offset]) > 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    lastOffset += hint;
    offset += hint;
  } else {
    maxOffset = hint + 1;
    while (offset < maxOffset && compare2(value, array[start2 + hint - offset]) <= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    var tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  }
  lastOffset++;
  while (lastOffset < offset) {
    var m2 = lastOffset + (offset - lastOffset >>> 1);
    if (compare2(value, array[start2 + m2]) > 0) {
      lastOffset = m2 + 1;
    } else {
      offset = m2;
    }
  }
  return offset;
}
function gallopRight(value, array, start2, length2, hint, compare2) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset = 1;
  if (compare2(value, array[start2 + hint]) < 0) {
    maxOffset = hint + 1;
    while (offset < maxOffset && compare2(value, array[start2 + hint - offset]) < 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    var tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  } else {
    maxOffset = length2 - hint;
    while (offset < maxOffset && compare2(value, array[start2 + hint + offset]) >= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    lastOffset += hint;
    offset += hint;
  }
  lastOffset++;
  while (lastOffset < offset) {
    var m2 = lastOffset + (offset - lastOffset >>> 1);
    if (compare2(value, array[start2 + m2]) < 0) {
      offset = m2;
    } else {
      lastOffset = m2 + 1;
    }
  }
  return offset;
}
function TimSort(array, compare2) {
  let minGallop = DEFAULT_MIN_GALLOPING;
  let runStart;
  let runLength;
  let stackSize = 0;
  var tmp = [];
  runStart = [];
  runLength = [];
  function pushRun(_runStart, _runLength) {
    runStart[stackSize] = _runStart;
    runLength[stackSize] = _runLength;
    stackSize += 1;
  }
  function mergeRuns() {
    while (stackSize > 1) {
      var n = stackSize - 2;
      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
        if (runLength[n - 1] < runLength[n + 1]) {
          n--;
        }
      } else if (runLength[n] > runLength[n + 1]) {
        break;
      }
      mergeAt(n);
    }
  }
  function forceMergeRuns() {
    while (stackSize > 1) {
      var n = stackSize - 2;
      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
        n--;
      }
      mergeAt(n);
    }
  }
  function mergeAt(i) {
    var start1 = runStart[i];
    var length1 = runLength[i];
    var start2 = runStart[i + 1];
    var length2 = runLength[i + 1];
    runLength[i] = length1 + length2;
    if (i === stackSize - 3) {
      runStart[i + 1] = runStart[i + 2];
      runLength[i + 1] = runLength[i + 2];
    }
    stackSize--;
    var k = gallopRight(array[start2], array, start1, length1, 0, compare2);
    start1 += k;
    length1 -= k;
    if (length1 === 0) {
      return;
    }
    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare2);
    if (length2 === 0) {
      return;
    }
    if (length1 <= length2) {
      mergeLow(start1, length1, start2, length2);
    } else {
      mergeHigh(start1, length1, start2, length2);
    }
  }
  function mergeLow(start1, length1, start2, length2) {
    var i = 0;
    for (i = 0; i < length1; i++) {
      tmp[i] = array[start1 + i];
    }
    var cursor1 = 0;
    var cursor2 = start2;
    var dest = start1;
    array[dest++] = array[cursor2++];
    if (--length2 === 0) {
      for (i = 0; i < length1; i++) {
        array[dest + i] = tmp[cursor1 + i];
      }
      return;
    }
    if (length1 === 1) {
      for (i = 0; i < length2; i++) {
        array[dest + i] = array[cursor2 + i];
      }
      array[dest + length2] = tmp[cursor1];
      return;
    }
    var _minGallop = minGallop;
    var count1;
    var count2;
    var exit;
    while (1) {
      count1 = 0;
      count2 = 0;
      exit = false;
      do {
        if (compare2(array[cursor2], tmp[cursor1]) < 0) {
          array[dest++] = array[cursor2++];
          count2++;
          count1 = 0;
          if (--length2 === 0) {
            exit = true;
            break;
          }
        } else {
          array[dest++] = tmp[cursor1++];
          count1++;
          count2 = 0;
          if (--length1 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < _minGallop);
      if (exit) {
        break;
      }
      do {
        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare2);
        if (count1 !== 0) {
          for (i = 0; i < count1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }
          dest += count1;
          cursor1 += count1;
          length1 -= count1;
          if (length1 <= 1) {
            exit = true;
            break;
          }
        }
        array[dest++] = array[cursor2++];
        if (--length2 === 0) {
          exit = true;
          break;
        }
        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare2);
        if (count2 !== 0) {
          for (i = 0; i < count2; i++) {
            array[dest + i] = array[cursor2 + i];
          }
          dest += count2;
          cursor2 += count2;
          length2 -= count2;
          if (length2 === 0) {
            exit = true;
            break;
          }
        }
        array[dest++] = tmp[cursor1++];
        if (--length1 === 1) {
          exit = true;
          break;
        }
        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
      if (exit) {
        break;
      }
      if (_minGallop < 0) {
        _minGallop = 0;
      }
      _minGallop += 2;
    }
    minGallop = _minGallop;
    minGallop < 1 && (minGallop = 1);
    if (length1 === 1) {
      for (i = 0; i < length2; i++) {
        array[dest + i] = array[cursor2 + i];
      }
      array[dest + length2] = tmp[cursor1];
    } else if (length1 === 0) {
      throw new Error();
    } else {
      for (i = 0; i < length1; i++) {
        array[dest + i] = tmp[cursor1 + i];
      }
    }
  }
  function mergeHigh(start1, length1, start2, length2) {
    var i = 0;
    for (i = 0; i < length2; i++) {
      tmp[i] = array[start2 + i];
    }
    var cursor1 = start1 + length1 - 1;
    var cursor2 = length2 - 1;
    var dest = start2 + length2 - 1;
    var customCursor = 0;
    var customDest = 0;
    array[dest--] = array[cursor1--];
    if (--length1 === 0) {
      customCursor = dest - (length2 - 1);
      for (i = 0; i < length2; i++) {
        array[customCursor + i] = tmp[i];
      }
      return;
    }
    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;
      for (i = length1 - 1; i >= 0; i--) {
        array[customDest + i] = array[customCursor + i];
      }
      array[dest] = tmp[cursor2];
      return;
    }
    var _minGallop = minGallop;
    while (true) {
      var count1 = 0;
      var count2 = 0;
      var exit = false;
      do {
        if (compare2(tmp[cursor2], array[cursor1]) < 0) {
          array[dest--] = array[cursor1--];
          count1++;
          count2 = 0;
          if (--length1 === 0) {
            exit = true;
            break;
          }
        } else {
          array[dest--] = tmp[cursor2--];
          count2++;
          count1 = 0;
          if (--length2 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < _minGallop);
      if (exit) {
        break;
      }
      do {
        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare2);
        if (count1 !== 0) {
          dest -= count1;
          cursor1 -= count1;
          length1 -= count1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = count1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }
          if (length1 === 0) {
            exit = true;
            break;
          }
        }
        array[dest--] = tmp[cursor2--];
        if (--length2 === 1) {
          exit = true;
          break;
        }
        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare2);
        if (count2 !== 0) {
          dest -= count2;
          cursor2 -= count2;
          length2 -= count2;
          customDest = dest + 1;
          customCursor = cursor2 + 1;
          for (i = 0; i < count2; i++) {
            array[customDest + i] = tmp[customCursor + i];
          }
          if (length2 <= 1) {
            exit = true;
            break;
          }
        }
        array[dest--] = array[cursor1--];
        if (--length1 === 0) {
          exit = true;
          break;
        }
        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
      if (exit) {
        break;
      }
      if (_minGallop < 0) {
        _minGallop = 0;
      }
      _minGallop += 2;
    }
    minGallop = _minGallop;
    if (minGallop < 1) {
      minGallop = 1;
    }
    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;
      for (i = length1 - 1; i >= 0; i--) {
        array[customDest + i] = array[customCursor + i];
      }
      array[dest] = tmp[cursor2];
    } else if (length2 === 0) {
      throw new Error();
    } else {
      customCursor = dest - (length2 - 1);
      for (i = 0; i < length2; i++) {
        array[customCursor + i] = tmp[i];
      }
    }
  }
  return {
    mergeRuns,
    forceMergeRuns,
    pushRun
  };
}
function sort(array, compare2, lo, hi) {
  if (!lo) {
    lo = 0;
  }
  if (!hi) {
    hi = array.length;
  }
  var remaining = hi - lo;
  if (remaining < 2) {
    return;
  }
  var runLength = 0;
  if (remaining < DEFAULT_MIN_MERGE) {
    runLength = makeAscendingRun(array, lo, hi, compare2);
    binaryInsertionSort(array, lo, hi, lo + runLength, compare2);
    return;
  }
  var ts = TimSort(array, compare2);
  var minRun = minRunLength(remaining);
  do {
    runLength = makeAscendingRun(array, lo, hi, compare2);
    if (runLength < minRun) {
      var force = remaining;
      if (force > minRun) {
        force = minRun;
      }
      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare2);
      runLength = force;
    }
    ts.pushRun(lo, runLength);
    ts.mergeRuns();
    remaining -= runLength;
    lo += runLength;
  } while (remaining !== 0);
  ts.forceMergeRuns();
}

// ../zrender/src/graphic/constants.ts
var REDRAW_BIT = 1;
var STYLE_CHANGED_BIT = 2;
var SHAPE_CHANGED_BIT = 4;

// ../zrender/src/Storage.ts
var invalidZErrorLogged = false;
function logInvalidZError() {
  if (invalidZErrorLogged) {
    return;
  }
  invalidZErrorLogged = true;
  console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors");
}
function shapeCompareFunc(a, b) {
  if (a.zlevel === b.zlevel) {
    if (a.z === b.z) {
      return a.z2 - b.z2;
    }
    return a.z - b.z;
  }
  return a.zlevel - b.zlevel;
}
var Storage = class {
  constructor() {
    this._roots = [];
    this._displayList = [];
    this._displayListLen = 0;
    this.displayableSortFunc = shapeCompareFunc;
  }
  traverse(cb, context) {
    for (let i = 0; i < this._roots.length; i++) {
      this._roots[i].traverse(cb, context);
    }
  }
  getDisplayList(update, includeIgnore) {
    includeIgnore = includeIgnore || false;
    const displayList = this._displayList;
    if (update || !displayList.length) {
      this.updateDisplayList(includeIgnore);
    }
    return displayList;
  }
  updateDisplayList(includeIgnore) {
    this._displayListLen = 0;
    const roots2 = this._roots;
    const displayList = this._displayList;
    for (let i = 0, len2 = roots2.length; i < len2; i++) {
      this._updateAndAddDisplayable(roots2[i], null, includeIgnore);
    }
    displayList.length = this._displayListLen;
    sort(displayList, shapeCompareFunc);
  }
  _updateAndAddDisplayable(el, parentClipPaths, includeIgnore) {
    if (el.ignore && !includeIgnore) {
      return;
    }
    el.beforeUpdate();
    el.update();
    el.afterUpdate();
    const userSetClipPath = el.getClipPath();
    const parentHasClipPaths = parentClipPaths && parentClipPaths.length;
    let clipPathIdx = 0;
    let thisClipPaths = el.__clipPaths;
    if (!el.ignoreClip && (parentHasClipPaths || userSetClipPath)) {
      if (!thisClipPaths) {
        thisClipPaths = el.__clipPaths = [];
      }
      if (parentHasClipPaths) {
        for (let idx = 0; idx < parentClipPaths.length; idx++) {
          thisClipPaths[clipPathIdx++] = parentClipPaths[idx];
        }
      }
      let currentClipPath = userSetClipPath;
      let parentClipPath = el;
      while (currentClipPath) {
        currentClipPath.parent = parentClipPath;
        currentClipPath.updateTransform();
        thisClipPaths[clipPathIdx++] = currentClipPath;
        parentClipPath = currentClipPath;
        currentClipPath = currentClipPath.getClipPath();
      }
    }
    if (thisClipPaths) {
      thisClipPaths.length = clipPathIdx;
    }
    if (el.childrenRef) {
      const children = el.childrenRef();
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (el.__dirty) {
          child.__dirty |= REDRAW_BIT;
        }
        this._updateAndAddDisplayable(child, thisClipPaths, includeIgnore);
      }
      el.__dirty = 0;
    } else {
      const disp = el;
      if (isNaN(disp.z)) {
        logInvalidZError();
        disp.z = 0;
      }
      if (isNaN(disp.z2)) {
        logInvalidZError();
        disp.z2 = 0;
      }
      if (isNaN(disp.zlevel)) {
        logInvalidZError();
        disp.zlevel = 0;
      }
      this._displayList[this._displayListLen++] = disp;
    }
    const decalEl = el.getDecalElement && el.getDecalElement();
    if (decalEl) {
      this._updateAndAddDisplayable(decalEl, thisClipPaths, includeIgnore);
    }
    const textGuide = el.getTextGuideLine();
    if (textGuide) {
      this._updateAndAddDisplayable(textGuide, thisClipPaths, includeIgnore);
    }
    const textEl = el.getTextContent();
    if (textEl) {
      this._updateAndAddDisplayable(textEl, thisClipPaths, includeIgnore);
    }
  }
  addRoot(el) {
    if (el.__zr && el.__zr.storage === this) {
      return;
    }
    this._roots.push(el);
  }
  delRoot(el) {
    if (el instanceof Array) {
      for (let i = 0, l = el.length; i < l; i++) {
        this.delRoot(el[i]);
      }
      return;
    }
    const idx = indexOf(this._roots, el);
    if (idx >= 0) {
      this._roots.splice(idx, 1);
    }
  }
  delAllRoots() {
    this._roots = [];
    this._displayList = [];
    this._displayListLen = 0;
    return;
  }
  getRoots() {
    return this._roots;
  }
  dispose() {
    this._displayList = null;
    this._roots = null;
  }
};
var Storage_default = Storage;

// ../zrender/src/animation/requestAnimationFrame.ts
var requestAnimationFrame;
requestAnimationFrame = env_default.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(func) {
  return setTimeout(func, 16);
};
var requestAnimationFrame_default = requestAnimationFrame;

// ../zrender/src/animation/easing.ts
var easingFuncs = {
  linear(k) {
    return k;
  },
  quadraticIn(k) {
    return k * k;
  },
  quadraticOut(k) {
    return k * (2 - k);
  },
  quadraticInOut(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k;
    }
    return -0.5 * (--k * (k - 2) - 1);
  },
  cubicIn(k) {
    return k * k * k;
  },
  cubicOut(k) {
    return --k * k * k + 1;
  },
  cubicInOut(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k;
    }
    return 0.5 * ((k -= 2) * k * k + 2);
  },
  quarticIn(k) {
    return k * k * k * k;
  },
  quarticOut(k) {
    return 1 - --k * k * k * k;
  },
  quarticInOut(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k * k;
    }
    return -0.5 * ((k -= 2) * k * k * k - 2);
  },
  quinticIn(k) {
    return k * k * k * k * k;
  },
  quinticOut(k) {
    return --k * k * k * k * k + 1;
  },
  quinticInOut(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k * k * k;
    }
    return 0.5 * ((k -= 2) * k * k * k * k + 2);
  },
  sinusoidalIn(k) {
    return 1 - Math.cos(k * Math.PI / 2);
  },
  sinusoidalOut(k) {
    return Math.sin(k * Math.PI / 2);
  },
  sinusoidalInOut(k) {
    return 0.5 * (1 - Math.cos(Math.PI * k));
  },
  exponentialIn(k) {
    return k === 0 ? 0 : Math.pow(1024, k - 1);
  },
  exponentialOut(k) {
    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
  },
  exponentialInOut(k) {
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if ((k *= 2) < 1) {
      return 0.5 * Math.pow(1024, k - 1);
    }
    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
  },
  circularIn(k) {
    return 1 - Math.sqrt(1 - k * k);
  },
  circularOut(k) {
    return Math.sqrt(1 - --k * k);
  },
  circularInOut(k) {
    if ((k *= 2) < 1) {
      return -0.5 * (Math.sqrt(1 - k * k) - 1);
    }
    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
  },
  elasticIn(k) {
    let s;
    let a = 0.1;
    let p = 0.4;
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }
    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
  },
  elasticOut(k) {
    let s;
    let a = 0.1;
    let p = 0.4;
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }
    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
  },
  elasticInOut(k) {
    let s;
    let a = 0.1;
    let p = 0.4;
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }
    if ((k *= 2) < 1) {
      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
    }
    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
  },
  backIn(k) {
    let s = 1.70158;
    return k * k * ((s + 1) * k - s);
  },
  backOut(k) {
    let s = 1.70158;
    return --k * k * ((s + 1) * k + s) + 1;
  },
  backInOut(k) {
    let s = 1.70158 * 1.525;
    if ((k *= 2) < 1) {
      return 0.5 * (k * k * ((s + 1) * k - s));
    }
    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
  },
  bounceIn(k) {
    return 1 - easingFuncs.bounceOut(1 - k);
  },
  bounceOut(k) {
    if (k < 1 / 2.75) {
      return 7.5625 * k * k;
    } else if (k < 2 / 2.75) {
      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
    } else if (k < 2.5 / 2.75) {
      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
    } else {
      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
    }
  },
  bounceInOut(k) {
    if (k < 0.5) {
      return easingFuncs.bounceIn(k * 2) * 0.5;
    }
    return easingFuncs.bounceOut(k * 2 - 1) * 0.5 + 0.5;
  }
};
var easing_default = easingFuncs;

// ../zrender/src/core/curve.ts
var mathPow = Math.pow;
var mathSqrt = Math.sqrt;
var EPSILON2 = 1e-8;
var EPSILON_NUMERIC = 1e-4;
var THREE_SQRT = mathSqrt(3);
var ONE_THIRD = 1 / 3;
var _v0 = create();
var _v1 = create();
var _v2 = create();
function isAroundZero(val) {
  return val > -EPSILON2 && val < EPSILON2;
}
function isNotAroundZero(val) {
  return val > EPSILON2 || val < -EPSILON2;
}
function cubicAt(p0, p1, p2, p3, t) {
  const onet = 1 - t;
  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
}
function cubicDerivativeAt(p0, p1, p2, p3, t) {
  const onet = 1 - t;
  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
}
function cubicRootAt(p0, p1, p2, p3, val, roots2) {
  const a = p3 + 3 * (p1 - p2) - p0;
  const b = 3 * (p2 - p1 * 2 + p0);
  const c = 3 * (p1 - p0);
  const d = p0 - val;
  const A = b * b - 3 * a * c;
  const B = b * c - 9 * a * d;
  const C = c * c - 3 * b * d;
  let n = 0;
  if (isAroundZero(A) && isAroundZero(B)) {
    if (isAroundZero(b)) {
      roots2[0] = 0;
    } else {
      const t1 = -c / b;
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    }
  } else {
    const disc = B * B - 4 * A * C;
    if (isAroundZero(disc)) {
      const K = B / A;
      const t1 = -b / a + K;
      const t2 = -K / 2;
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        roots2[n++] = t2;
      }
    } else if (disc > 0) {
      const discSqrt = mathSqrt(disc);
      let Y1 = A * b + 1.5 * a * (-B + discSqrt);
      let Y2 = A * b + 1.5 * a * (-B - discSqrt);
      if (Y1 < 0) {
        Y1 = -mathPow(-Y1, ONE_THIRD);
      } else {
        Y1 = mathPow(Y1, ONE_THIRD);
      }
      if (Y2 < 0) {
        Y2 = -mathPow(-Y2, ONE_THIRD);
      } else {
        Y2 = mathPow(Y2, ONE_THIRD);
      }
      const t1 = (-b - (Y1 + Y2)) / (3 * a);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    } else {
      const T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
      const theta = Math.acos(T) / 3;
      const ASqrt = mathSqrt(A);
      const tmp = Math.cos(theta);
      const t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
      const t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
      const t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        roots2[n++] = t2;
      }
      if (t3 >= 0 && t3 <= 1) {
        roots2[n++] = t3;
      }
    }
  }
  return n;
}
function cubicExtrema(p0, p1, p2, p3, extrema2) {
  const b = 6 * p2 - 12 * p1 + 6 * p0;
  const a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
  const c = 3 * p1 - 3 * p0;
  let n = 0;
  if (isAroundZero(a)) {
    if (isNotAroundZero(b)) {
      const t1 = -c / b;
      if (t1 >= 0 && t1 <= 1) {
        extrema2[n++] = t1;
      }
    }
  } else {
    const disc = b * b - 4 * a * c;
    if (isAroundZero(disc)) {
      extrema2[0] = -b / (2 * a);
    } else if (disc > 0) {
      const discSqrt = mathSqrt(disc);
      const t1 = (-b + discSqrt) / (2 * a);
      const t2 = (-b - discSqrt) / (2 * a);
      if (t1 >= 0 && t1 <= 1) {
        extrema2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        extrema2[n++] = t2;
      }
    }
  }
  return n;
}
function cubicSubdivide(p0, p1, p2, p3, t, out2) {
  const p01 = (p1 - p0) * t + p0;
  const p12 = (p2 - p1) * t + p1;
  const p23 = (p3 - p2) * t + p2;
  const p012 = (p12 - p01) * t + p01;
  const p123 = (p23 - p12) * t + p12;
  const p0123 = (p123 - p012) * t + p012;
  out2[0] = p0;
  out2[1] = p01;
  out2[2] = p012;
  out2[3] = p0123;
  out2[4] = p0123;
  out2[5] = p123;
  out2[6] = p23;
  out2[7] = p3;
}
function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out2) {
  let t;
  let interval = 5e-3;
  let d = Infinity;
  let prev;
  let next;
  let d1;
  let d2;
  _v0[0] = x;
  _v0[1] = y;
  for (let _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = cubicAt(x0, x1, x2, x3, _t);
    _v1[1] = cubicAt(y0, y1, y2, y3, _t);
    d1 = distSquare(_v0, _v1);
    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }
  d = Infinity;
  for (let i = 0; i < 32; i++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }
    prev = t - interval;
    next = t + interval;
    _v1[0] = cubicAt(x0, x1, x2, x3, prev);
    _v1[1] = cubicAt(y0, y1, y2, y3, prev);
    d1 = distSquare(_v1, _v0);
    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      _v2[0] = cubicAt(x0, x1, x2, x3, next);
      _v2[1] = cubicAt(y0, y1, y2, y3, next);
      d2 = distSquare(_v2, _v0);
      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval *= 0.5;
      }
    }
  }
  if (out2) {
    out2[0] = cubicAt(x0, x1, x2, x3, t);
    out2[1] = cubicAt(y0, y1, y2, y3, t);
  }
  return mathSqrt(d);
}
function cubicLength(x0, y0, x1, y1, x2, y2, x3, y3, iteration) {
  let px = x0;
  let py = y0;
  let d = 0;
  const step = 1 / iteration;
  for (let i = 1; i <= iteration; i++) {
    let t = i * step;
    const x = cubicAt(x0, x1, x2, x3, t);
    const y = cubicAt(y0, y1, y2, y3, t);
    const dx = x - px;
    const dy = y - py;
    d += Math.sqrt(dx * dx + dy * dy);
    px = x;
    py = y;
  }
  return d;
}
function quadraticAt(p0, p1, p2, t) {
  const onet = 1 - t;
  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
}
function quadraticDerivativeAt(p0, p1, p2, t) {
  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
}
function quadraticRootAt(p0, p1, p2, val, roots2) {
  const a = p0 - 2 * p1 + p2;
  const b = 2 * (p1 - p0);
  const c = p0 - val;
  let n = 0;
  if (isAroundZero(a)) {
    if (isNotAroundZero(b)) {
      const t1 = -c / b;
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    }
  } else {
    const disc = b * b - 4 * a * c;
    if (isAroundZero(disc)) {
      const t1 = -b / (2 * a);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    } else if (disc > 0) {
      const discSqrt = mathSqrt(disc);
      const t1 = (-b + discSqrt) / (2 * a);
      const t2 = (-b - discSqrt) / (2 * a);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        roots2[n++] = t2;
      }
    }
  }
  return n;
}
function quadraticExtremum(p0, p1, p2) {
  const divider = p0 + p2 - 2 * p1;
  if (divider === 0) {
    return 0.5;
  } else {
    return (p0 - p1) / divider;
  }
}
function quadraticSubdivide(p0, p1, p2, t, out2) {
  const p01 = (p1 - p0) * t + p0;
  const p12 = (p2 - p1) * t + p1;
  const p012 = (p12 - p01) * t + p01;
  out2[0] = p0;
  out2[1] = p01;
  out2[2] = p012;
  out2[3] = p012;
  out2[4] = p12;
  out2[5] = p2;
}
function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out2) {
  let t;
  let interval = 5e-3;
  let d = Infinity;
  _v0[0] = x;
  _v0[1] = y;
  for (let _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = quadraticAt(x0, x1, x2, _t);
    _v1[1] = quadraticAt(y0, y1, y2, _t);
    const d1 = distSquare(_v0, _v1);
    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }
  d = Infinity;
  for (let i = 0; i < 32; i++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }
    const prev = t - interval;
    const next = t + interval;
    _v1[0] = quadraticAt(x0, x1, x2, prev);
    _v1[1] = quadraticAt(y0, y1, y2, prev);
    const d1 = distSquare(_v1, _v0);
    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      _v2[0] = quadraticAt(x0, x1, x2, next);
      _v2[1] = quadraticAt(y0, y1, y2, next);
      const d2 = distSquare(_v2, _v0);
      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval *= 0.5;
      }
    }
  }
  if (out2) {
    out2[0] = quadraticAt(x0, x1, x2, t);
    out2[1] = quadraticAt(y0, y1, y2, t);
  }
  return mathSqrt(d);
}
function quadraticLength(x0, y0, x1, y1, x2, y2, iteration) {
  let px = x0;
  let py = y0;
  let d = 0;
  const step = 1 / iteration;
  for (let i = 1; i <= iteration; i++) {
    let t = i * step;
    const x = quadraticAt(x0, x1, x2, t);
    const y = quadraticAt(y0, y1, y2, t);
    const dx = x - px;
    const dy = y - py;
    d += Math.sqrt(dx * dx + dy * dy);
    px = x;
    py = y;
  }
  return d;
}

// ../zrender/src/animation/cubicEasing.ts
var regexp = /cubic-bezier\(([0-9,\.e ]+)\)/;
function createCubicEasingFunc(cubicEasingStr) {
  const cubic2 = cubicEasingStr && regexp.exec(cubicEasingStr);
  if (cubic2) {
    const points4 = cubic2[1].split(",");
    const a = +trim(points4[0]);
    const b = +trim(points4[1]);
    const c = +trim(points4[2]);
    const d = +trim(points4[3]);
    if (isNaN(a + b + c + d)) {
      return;
    }
    const roots2 = [];
    return (p) => {
      return p <= 0 ? 0 : p >= 1 ? 1 : cubicRootAt(0, a, c, 1, p, roots2) && cubicAt(0, b, d, 1, roots2[0]);
    };
  }
}

// ../zrender/src/animation/Clip.ts
var Clip = class {
  constructor(opts) {
    this._inited = false;
    this._startTime = 0;
    this._pausedTime = 0;
    this._paused = false;
    this._life = opts.life || 1e3;
    this._delay = opts.delay || 0;
    this.loop = opts.loop || false;
    this.onframe = opts.onframe || noop;
    this.ondestroy = opts.ondestroy || noop;
    this.onrestart = opts.onrestart || noop;
    opts.easing && this.setEasing(opts.easing);
  }
  step(globalTime, deltaTime) {
    if (!this._inited) {
      this._startTime = globalTime + this._delay;
      this._inited = true;
    }
    if (this._paused) {
      this._pausedTime += deltaTime;
      return;
    }
    const life = this._life;
    let elapsedTime = globalTime - this._startTime - this._pausedTime;
    let percent = elapsedTime / life;
    if (percent < 0) {
      percent = 0;
    }
    percent = Math.min(percent, 1);
    const easingFunc = this.easingFunc;
    const schedule = easingFunc ? easingFunc(percent) : percent;
    this.onframe(schedule);
    if (percent === 1) {
      if (this.loop) {
        const remainder = elapsedTime % life;
        this._startTime = globalTime - remainder;
        this._pausedTime = 0;
        this.onrestart();
      } else {
        return true;
      }
    }
    return false;
  }
  pause() {
    this._paused = true;
  }
  resume() {
    this._paused = false;
  }
  setEasing(easing) {
    this.easing = easing;
    this.easingFunc = isFunction(easing) ? easing : easing_default[easing] || createCubicEasingFunc(easing);
  }
};
var Clip_default = Clip;

// ../zrender/src/tool/color.ts
var color_exports = {};
__export(color_exports, {
  fastLerp: () => fastLerp,
  fastMapToColor: () => fastMapToColor,
  lerp: () => lerp2,
  lift: () => lift,
  liftColor: () => liftColor,
  lum: () => lum,
  mapToColor: () => mapToColor,
  modifyAlpha: () => modifyAlpha,
  modifyHSL: () => modifyHSL,
  parse: () => parse,
  parseCssFloat: () => parseCssFloat,
  parseCssInt: () => parseCssInt,
  random: () => random,
  stringify: () => stringify,
  toHex: () => toHex
});

// ../zrender/src/core/LRU.ts
var Entry = class {
  constructor(val) {
    this.value = val;
  }
};
var LinkedList = class {
  constructor() {
    this._len = 0;
  }
  insert(val) {
    const entry = new Entry(val);
    this.insertEntry(entry);
    return entry;
  }
  insertEntry(entry) {
    if (!this.head) {
      this.head = this.tail = entry;
    } else {
      this.tail.next = entry;
      entry.prev = this.tail;
      entry.next = null;
      this.tail = entry;
    }
    this._len++;
  }
  remove(entry) {
    const prev = entry.prev;
    const next = entry.next;
    if (prev) {
      prev.next = next;
    } else {
      this.head = next;
    }
    if (next) {
      next.prev = prev;
    } else {
      this.tail = prev;
    }
    entry.next = entry.prev = null;
    this._len--;
  }
  len() {
    return this._len;
  }
  clear() {
    this.head = this.tail = null;
    this._len = 0;
  }
};
var LRU = class {
  constructor(maxSize) {
    this._list = new LinkedList();
    this._maxSize = 10;
    this._map = {};
    this._maxSize = maxSize;
  }
  put(key, value) {
    const list = this._list;
    const map3 = this._map;
    let removed = null;
    if (map3[key] == null) {
      const len2 = list.len();
      let entry = this._lastRemovedEntry;
      if (len2 >= this._maxSize && len2 > 0) {
        const leastUsedEntry = list.head;
        list.remove(leastUsedEntry);
        delete map3[leastUsedEntry.key];
        removed = leastUsedEntry.value;
        this._lastRemovedEntry = leastUsedEntry;
      }
      if (entry) {
        entry.value = value;
      } else {
        entry = new Entry(value);
      }
      entry.key = key;
      list.insertEntry(entry);
      map3[key] = entry;
    }
    return removed;
  }
  get(key) {
    const entry = this._map[key];
    const list = this._list;
    if (entry != null) {
      if (entry !== list.tail) {
        list.remove(entry);
        list.insertEntry(entry);
      }
      return entry.value;
    }
  }
  clear() {
    this._list.clear();
    this._map = {};
  }
  len() {
    return this._list.len();
  }
};
var LRU_default = LRU;

// ../zrender/src/tool/color.ts
var kCSSColorTable = {
  transparent: [0, 0, 0, 0],
  aliceblue: [240, 248, 255, 1],
  antiquewhite: [250, 235, 215, 1],
  aqua: [0, 255, 255, 1],
  aquamarine: [127, 255, 212, 1],
  azure: [240, 255, 255, 1],
  beige: [245, 245, 220, 1],
  bisque: [255, 228, 196, 1],
  black: [0, 0, 0, 1],
  blanchedalmond: [255, 235, 205, 1],
  blue: [0, 0, 255, 1],
  blueviolet: [138, 43, 226, 1],
  brown: [165, 42, 42, 1],
  burlywood: [222, 184, 135, 1],
  cadetblue: [95, 158, 160, 1],
  chartreuse: [127, 255, 0, 1],
  chocolate: [210, 105, 30, 1],
  coral: [255, 127, 80, 1],
  cornflowerblue: [100, 149, 237, 1],
  cornsilk: [255, 248, 220, 1],
  crimson: [220, 20, 60, 1],
  cyan: [0, 255, 255, 1],
  darkblue: [0, 0, 139, 1],
  darkcyan: [0, 139, 139, 1],
  darkgoldenrod: [184, 134, 11, 1],
  darkgray: [169, 169, 169, 1],
  darkgreen: [0, 100, 0, 1],
  darkgrey: [169, 169, 169, 1],
  darkkhaki: [189, 183, 107, 1],
  darkmagenta: [139, 0, 139, 1],
  darkolivegreen: [85, 107, 47, 1],
  darkorange: [255, 140, 0, 1],
  darkorchid: [153, 50, 204, 1],
  darkred: [139, 0, 0, 1],
  darksalmon: [233, 150, 122, 1],
  darkseagreen: [143, 188, 143, 1],
  darkslateblue: [72, 61, 139, 1],
  darkslategray: [47, 79, 79, 1],
  darkslategrey: [47, 79, 79, 1],
  darkturquoise: [0, 206, 209, 1],
  darkviolet: [148, 0, 211, 1],
  deeppink: [255, 20, 147, 1],
  deepskyblue: [0, 191, 255, 1],
  dimgray: [105, 105, 105, 1],
  dimgrey: [105, 105, 105, 1],
  dodgerblue: [30, 144, 255, 1],
  firebrick: [178, 34, 34, 1],
  floralwhite: [255, 250, 240, 1],
  forestgreen: [34, 139, 34, 1],
  fuchsia: [255, 0, 255, 1],
  gainsboro: [220, 220, 220, 1],
  ghostwhite: [248, 248, 255, 1],
  gold: [255, 215, 0, 1],
  goldenrod: [218, 165, 32, 1],
  gray: [128, 128, 128, 1],
  green: [0, 128, 0, 1],
  greenyellow: [173, 255, 47, 1],
  grey: [128, 128, 128, 1],
  honeydew: [240, 255, 240, 1],
  hotpink: [255, 105, 180, 1],
  indianred: [205, 92, 92, 1],
  indigo: [75, 0, 130, 1],
  ivory: [255, 255, 240, 1],
  khaki: [240, 230, 140, 1],
  lavender: [230, 230, 250, 1],
  lavenderblush: [255, 240, 245, 1],
  lawngreen: [124, 252, 0, 1],
  lemonchiffon: [255, 250, 205, 1],
  lightblue: [173, 216, 230, 1],
  lightcoral: [240, 128, 128, 1],
  lightcyan: [224, 255, 255, 1],
  lightgoldenrodyellow: [250, 250, 210, 1],
  lightgray: [211, 211, 211, 1],
  lightgreen: [144, 238, 144, 1],
  lightgrey: [211, 211, 211, 1],
  lightpink: [255, 182, 193, 1],
  lightsalmon: [255, 160, 122, 1],
  lightseagreen: [32, 178, 170, 1],
  lightskyblue: [135, 206, 250, 1],
  lightslategray: [119, 136, 153, 1],
  lightslategrey: [119, 136, 153, 1],
  lightsteelblue: [176, 196, 222, 1],
  lightyellow: [255, 255, 224, 1],
  lime: [0, 255, 0, 1],
  limegreen: [50, 205, 50, 1],
  linen: [250, 240, 230, 1],
  magenta: [255, 0, 255, 1],
  maroon: [128, 0, 0, 1],
  mediumaquamarine: [102, 205, 170, 1],
  mediumblue: [0, 0, 205, 1],
  mediumorchid: [186, 85, 211, 1],
  mediumpurple: [147, 112, 219, 1],
  mediumseagreen: [60, 179, 113, 1],
  mediumslateblue: [123, 104, 238, 1],
  mediumspringgreen: [0, 250, 154, 1],
  mediumturquoise: [72, 209, 204, 1],
  mediumvioletred: [199, 21, 133, 1],
  midnightblue: [25, 25, 112, 1],
  mintcream: [245, 255, 250, 1],
  mistyrose: [255, 228, 225, 1],
  moccasin: [255, 228, 181, 1],
  navajowhite: [255, 222, 173, 1],
  navy: [0, 0, 128, 1],
  oldlace: [253, 245, 230, 1],
  olive: [128, 128, 0, 1],
  olivedrab: [107, 142, 35, 1],
  orange: [255, 165, 0, 1],
  orangered: [255, 69, 0, 1],
  orchid: [218, 112, 214, 1],
  palegoldenrod: [238, 232, 170, 1],
  palegreen: [152, 251, 152, 1],
  paleturquoise: [175, 238, 238, 1],
  palevioletred: [219, 112, 147, 1],
  papayawhip: [255, 239, 213, 1],
  peachpuff: [255, 218, 185, 1],
  peru: [205, 133, 63, 1],
  pink: [255, 192, 203, 1],
  plum: [221, 160, 221, 1],
  powderblue: [176, 224, 230, 1],
  purple: [128, 0, 128, 1],
  red: [255, 0, 0, 1],
  rosybrown: [188, 143, 143, 1],
  royalblue: [65, 105, 225, 1],
  saddlebrown: [139, 69, 19, 1],
  salmon: [250, 128, 114, 1],
  sandybrown: [244, 164, 96, 1],
  seagreen: [46, 139, 87, 1],
  seashell: [255, 245, 238, 1],
  sienna: [160, 82, 45, 1],
  silver: [192, 192, 192, 1],
  skyblue: [135, 206, 235, 1],
  slateblue: [106, 90, 205, 1],
  slategray: [112, 128, 144, 1],
  slategrey: [112, 128, 144, 1],
  snow: [255, 250, 250, 1],
  springgreen: [0, 255, 127, 1],
  steelblue: [70, 130, 180, 1],
  tan: [210, 180, 140, 1],
  teal: [0, 128, 128, 1],
  thistle: [216, 191, 216, 1],
  tomato: [255, 99, 71, 1],
  turquoise: [64, 224, 208, 1],
  violet: [238, 130, 238, 1],
  wheat: [245, 222, 179, 1],
  white: [255, 255, 255, 1],
  whitesmoke: [245, 245, 245, 1],
  yellow: [255, 255, 0, 1],
  yellowgreen: [154, 205, 50, 1]
};
function clampCssByte(i) {
  i = Math.round(i);
  return i < 0 ? 0 : i > 255 ? 255 : i;
}
function clampCssAngle(i) {
  i = Math.round(i);
  return i < 0 ? 0 : i > 360 ? 360 : i;
}
function clampCssFloat(f) {
  return f < 0 ? 0 : f > 1 ? 1 : f;
}
function parseCssInt(val) {
  let str = val;
  if (str.length && str.charAt(str.length - 1) === "%") {
    return clampCssByte(parseFloat(str) / 100 * 255);
  }
  return clampCssByte(parseInt(str, 10));
}
function parseCssFloat(val) {
  let str = val;
  if (str.length && str.charAt(str.length - 1) === "%") {
    return clampCssFloat(parseFloat(str) / 100);
  }
  return clampCssFloat(parseFloat(str));
}
function cssHueToRgb(m1, m2, h) {
  if (h < 0) {
    h += 1;
  } else if (h > 1) {
    h -= 1;
  }
  if (h * 6 < 1) {
    return m1 + (m2 - m1) * h * 6;
  }
  if (h * 2 < 1) {
    return m2;
  }
  if (h * 3 < 2) {
    return m1 + (m2 - m1) * (2 / 3 - h) * 6;
  }
  return m1;
}
function lerpNumber(a, b, p) {
  return a + (b - a) * p;
}
function setRgba(out2, r, g, b, a) {
  out2[0] = r;
  out2[1] = g;
  out2[2] = b;
  out2[3] = a;
  return out2;
}
function copyRgba(out2, a) {
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  out2[3] = a[3];
  return out2;
}
var colorCache = new LRU_default(20);
var lastRemovedArr = null;
function putToCache(colorStr, rgbaArr) {
  if (lastRemovedArr) {
    copyRgba(lastRemovedArr, rgbaArr);
  }
  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
}
function parse(colorStr, rgbaArr) {
  if (!colorStr) {
    return;
  }
  rgbaArr = rgbaArr || [];
  let cached = colorCache.get(colorStr);
  if (cached) {
    return copyRgba(rgbaArr, cached);
  }
  colorStr = colorStr + "";
  let str = colorStr.replace(/ /g, "").toLowerCase();
  if (str in kCSSColorTable) {
    copyRgba(rgbaArr, kCSSColorTable[str]);
    putToCache(colorStr, rgbaArr);
    return rgbaArr;
  }
  const strLen = str.length;
  if (str.charAt(0) === "#") {
    if (strLen === 4 || strLen === 5) {
      const iv = parseInt(str.slice(1, 4), 16);
      if (!(iv >= 0 && iv <= 4095)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return;
      }
      setRgba(rgbaArr, (iv & 3840) >> 4 | (iv & 3840) >> 8, iv & 240 | (iv & 240) >> 4, iv & 15 | (iv & 15) << 4, strLen === 5 ? parseInt(str.slice(4), 16) / 15 : 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    } else if (strLen === 7 || strLen === 9) {
      const iv = parseInt(str.slice(1, 7), 16);
      if (!(iv >= 0 && iv <= 16777215)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return;
      }
      setRgba(rgbaArr, (iv & 16711680) >> 16, (iv & 65280) >> 8, iv & 255, strLen === 9 ? parseInt(str.slice(7), 16) / 255 : 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    }
    return;
  }
  let op = str.indexOf("(");
  let ep = str.indexOf(")");
  if (op !== -1 && ep + 1 === strLen) {
    let fname = str.substr(0, op);
    let params = str.substr(op + 1, ep - (op + 1)).split(",");
    let alpha = 1;
    switch (fname) {
      case "rgba":
        if (params.length !== 4) {
          return params.length === 3 ? setRgba(rgbaArr, +params[0], +params[1], +params[2], 1) : setRgba(rgbaArr, 0, 0, 0, 1);
        }
        alpha = parseCssFloat(params.pop());
      case "rgb":
        if (params.length >= 3) {
          setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), params.length === 3 ? alpha : parseCssFloat(params[3]));
          putToCache(colorStr, rgbaArr);
          return rgbaArr;
        } else {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
      case "hsla":
        if (params.length !== 4) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        params[3] = parseCssFloat(params[3]);
        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      case "hsl":
        if (params.length !== 3) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      default:
        return;
    }
  }
  setRgba(rgbaArr, 0, 0, 0, 1);
  return;
}
function hsla2rgba(hsla, rgba) {
  const h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;
  const s = parseCssFloat(hsla[1]);
  const l = parseCssFloat(hsla[2]);
  const m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
  const m1 = l * 2 - m2;
  rgba = rgba || [];
  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);
  if (hsla.length === 4) {
    rgba[3] = hsla[3];
  }
  return rgba;
}
function rgba2hsla(rgba) {
  if (!rgba) {
    return;
  }
  const R = rgba[0] / 255;
  const G = rgba[1] / 255;
  const B = rgba[2] / 255;
  const vMin = Math.min(R, G, B);
  const vMax = Math.max(R, G, B);
  const delta = vMax - vMin;
  const L = (vMax + vMin) / 2;
  let H;
  let S;
  if (delta === 0) {
    H = 0;
    S = 0;
  } else {
    if (L < 0.5) {
      S = delta / (vMax + vMin);
    } else {
      S = delta / (2 - vMax - vMin);
    }
    const deltaR = ((vMax - R) / 6 + delta / 2) / delta;
    const deltaG = ((vMax - G) / 6 + delta / 2) / delta;
    const deltaB = ((vMax - B) / 6 + delta / 2) / delta;
    if (R === vMax) {
      H = deltaB - deltaG;
    } else if (G === vMax) {
      H = 1 / 3 + deltaR - deltaB;
    } else if (B === vMax) {
      H = 2 / 3 + deltaG - deltaR;
    }
    if (H < 0) {
      H += 1;
    }
    if (H > 1) {
      H -= 1;
    }
  }
  const hsla = [H * 360, S, L];
  if (rgba[3] != null) {
    hsla.push(rgba[3]);
  }
  return hsla;
}
function lift(color4, level) {
  const colorArr = parse(color4);
  if (colorArr) {
    for (let i = 0; i < 3; i++) {
      if (level < 0) {
        colorArr[i] = colorArr[i] * (1 - level) | 0;
      } else {
        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
      }
      if (colorArr[i] > 255) {
        colorArr[i] = 255;
      } else if (colorArr[i] < 0) {
        colorArr[i] = 0;
      }
    }
    return stringify(colorArr, colorArr.length === 4 ? "rgba" : "rgb");
  }
}
function toHex(color4) {
  const colorArr = parse(color4);
  if (colorArr) {
    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
  }
}
function fastLerp(normalizedValue, colors, out2) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }
  out2 = out2 || [];
  const value = normalizedValue * (colors.length - 1);
  const leftIndex = Math.floor(value);
  const rightIndex = Math.ceil(value);
  const leftColor = colors[leftIndex];
  const rightColor = colors[rightIndex];
  const dv = value - leftIndex;
  out2[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
  out2[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
  out2[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
  out2[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
  return out2;
}
var fastMapToColor = fastLerp;
function lerp2(normalizedValue, colors, fullOutput) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }
  const value = normalizedValue * (colors.length - 1);
  const leftIndex = Math.floor(value);
  const rightIndex = Math.ceil(value);
  const leftColor = parse(colors[leftIndex]);
  const rightColor = parse(colors[rightIndex]);
  const dv = value - leftIndex;
  const color4 = stringify([
    clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),
    clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),
    clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),
    clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))
  ], "rgba");
  return fullOutput ? {
    color: color4,
    leftIndex,
    rightIndex,
    value
  } : color4;
}
var mapToColor = lerp2;
function modifyHSL(color4, h, s, l) {
  let colorArr = parse(color4);
  if (color4) {
    colorArr = rgba2hsla(colorArr);
    h != null && (colorArr[0] = clampCssAngle(isFunction(h) ? h(colorArr[0]) : h));
    s != null && (colorArr[1] = parseCssFloat(isFunction(s) ? s(colorArr[1]) : s));
    l != null && (colorArr[2] = parseCssFloat(isFunction(l) ? l(colorArr[2]) : l));
    return stringify(hsla2rgba(colorArr), "rgba");
  }
}
function modifyAlpha(color4, alpha) {
  const colorArr = parse(color4);
  if (colorArr && alpha != null) {
    colorArr[3] = clampCssFloat(alpha);
    return stringify(colorArr, "rgba");
  }
}
function stringify(arrColor, type) {
  if (!arrColor || !arrColor.length) {
    return;
  }
  let colorStr = arrColor[0] + "," + arrColor[1] + "," + arrColor[2];
  if (type === "rgba" || type === "hsva" || type === "hsla") {
    colorStr += "," + arrColor[3];
  }
  return type + "(" + colorStr + ")";
}
function lum(color4, backgroundLum) {
  const arr = parse(color4);
  return arr ? (0.299 * arr[0] + 0.587 * arr[1] + 0.114 * arr[2]) * arr[3] / 255 + (1 - arr[3]) * backgroundLum : 0;
}
function random() {
  return stringify([
    Math.round(Math.random() * 255),
    Math.round(Math.random() * 255),
    Math.round(Math.random() * 255)
  ], "rgb");
}
var liftedColorCache = new LRU_default(100);
function liftColor(color4) {
  if (isString(color4)) {
    let liftedColor = liftedColorCache.get(color4);
    if (!liftedColor) {
      liftedColor = lift(color4, -0.1);
      liftedColorCache.put(color4, liftedColor);
    }
    return liftedColor;
  } else if (isGradientObject(color4)) {
    const ret = extend({}, color4);
    ret.colorStops = map(color4.colorStops, (stop2) => ({
      offset: stop2.offset,
      color: lift(stop2.color, -0.1)
    }));
    return ret;
  }
  return color4;
}

// ../zrender/src/svg/helper.ts
var mathRound = Math.round;
function normalizeColor(color4) {
  let opacity;
  if (!color4 || color4 === "transparent") {
    color4 = "none";
  } else if (typeof color4 === "string" && color4.indexOf("rgba") > -1) {
    const arr = parse(color4);
    if (arr) {
      color4 = "rgb(" + arr[0] + "," + arr[1] + "," + arr[2] + ")";
      opacity = arr[3];
    }
  }
  return {
    color: color4,
    opacity: opacity == null ? 1 : opacity
  };
}
var EPSILON3 = 1e-4;
function isAroundZero2(transform2) {
  return transform2 < EPSILON3 && transform2 > -EPSILON3;
}
function round3(transform2) {
  return mathRound(transform2 * 1e3) / 1e3;
}
function round4(transform2) {
  return mathRound(transform2 * 1e4) / 1e4;
}
function getMatrixStr(m2) {
  return "matrix(" + round3(m2[0]) + "," + round3(m2[1]) + "," + round3(m2[2]) + "," + round3(m2[3]) + "," + round4(m2[4]) + "," + round4(m2[5]) + ")";
}
var TEXT_ALIGN_TO_ANCHOR = {
  left: "start",
  right: "end",
  center: "middle",
  middle: "middle"
};
function adjustTextY(y, lineHeight, textBaseline) {
  if (textBaseline === "top") {
    y += lineHeight / 2;
  } else if (textBaseline === "bottom") {
    y -= lineHeight / 2;
  }
  return y;
}
function hasShadow(style) {
  return style && (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY);
}
function getShadowKey(displayable) {
  const style = displayable.style;
  const globalScale = displayable.getGlobalScale();
  return [
    style.shadowColor,
    (style.shadowBlur || 0).toFixed(2),
    (style.shadowOffsetX || 0).toFixed(2),
    (style.shadowOffsetY || 0).toFixed(2),
    globalScale[0],
    globalScale[1]
  ].join(",");
}
function isImagePattern(val) {
  return val && !!val.image;
}
function isSVGPattern(val) {
  return val && !!val.svgElement;
}
function isPattern(val) {
  return isImagePattern(val) || isSVGPattern(val);
}
function isLinearGradient(val) {
  return val.type === "linear";
}
function isRadialGradient(val) {
  return val.type === "radial";
}
function isGradient(val) {
  return val && (val.type === "linear" || val.type === "radial");
}
function getIdURL(id) {
  return `url(#${id})`;
}
function getPathPrecision(el) {
  const scale4 = el.getGlobalScale();
  const size = Math.max(scale4[0], scale4[1]);
  return Math.max(Math.ceil(Math.log(size) / Math.log(10)), 1);
}
function getSRTTransformString(transform2) {
  const x = transform2.x || 0;
  const y = transform2.y || 0;
  const rotation = (transform2.rotation || 0) * RADIAN_TO_DEGREE;
  const scaleX = retrieve2(transform2.scaleX, 1);
  const scaleY = retrieve2(transform2.scaleY, 1);
  const skewX = transform2.skewX || 0;
  const skewY = transform2.skewY || 0;
  const res = [];
  if (x || y) {
    res.push(`translate(${x}px,${y}px)`);
  }
  if (rotation) {
    res.push(`rotate(${rotation})`);
  }
  if (scaleX !== 1 || scaleY !== 1) {
    res.push(`scale(${scaleX},${scaleY})`);
  }
  if (skewX || skewY) {
    res.push(`skew(${mathRound(skewX * RADIAN_TO_DEGREE)}deg, ${mathRound(skewY * RADIAN_TO_DEGREE)}deg)`);
  }
  return res.join(" ");
}
var encodeBase64 = function() {
  if (env_default.hasGlobalWindow && isFunction(window.btoa)) {
    return function(str) {
      return window.btoa(unescape(encodeURIComponent(str)));
    };
  }
  if (typeof Buffer !== "undefined") {
    return function(str) {
      return Buffer.from(str).toString("base64");
    };
  }
  return function(str) {
    if (true) {
      logError("Base64 isn't natively supported in the current environment.");
    }
    return null;
  };
}();

// ../zrender/src/animation/Animator.ts
var arraySlice = Array.prototype.slice;
function interpolateNumber(p0, p1, percent) {
  return (p1 - p0) * percent + p0;
}
function interpolate1DArray(out2, p0, p1, percent) {
  const len2 = p0.length;
  for (let i = 0; i < len2; i++) {
    out2[i] = interpolateNumber(p0[i], p1[i], percent);
  }
  return out2;
}
function interpolate2DArray(out2, p0, p1, percent) {
  const len2 = p0.length;
  const len22 = len2 && p0[0].length;
  for (let i = 0; i < len2; i++) {
    if (!out2[i]) {
      out2[i] = [];
    }
    for (let j = 0; j < len22; j++) {
      out2[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
    }
  }
  return out2;
}
function add1DArray(out2, p0, p1, sign) {
  const len2 = p0.length;
  for (let i = 0; i < len2; i++) {
    out2[i] = p0[i] + p1[i] * sign;
  }
  return out2;
}
function add2DArray(out2, p0, p1, sign) {
  const len2 = p0.length;
  const len22 = len2 && p0[0].length;
  for (let i = 0; i < len2; i++) {
    if (!out2[i]) {
      out2[i] = [];
    }
    for (let j = 0; j < len22; j++) {
      out2[i][j] = p0[i][j] + p1[i][j] * sign;
    }
  }
  return out2;
}
function fillColorStops(val0, val1) {
  const len0 = val0.length;
  const len1 = val1.length;
  const shorterArr = len0 > len1 ? val1 : val0;
  const shorterLen = Math.min(len0, len1);
  const last = shorterArr[shorterLen - 1] || {color: [0, 0, 0, 0], offset: 0};
  for (let i = shorterLen; i < Math.max(len0, len1); i++) {
    shorterArr.push({
      offset: last.offset,
      color: last.color.slice()
    });
  }
}
function fillArray(val0, val1, arrDim) {
  let arr0 = val0;
  let arr1 = val1;
  if (!arr0.push || !arr1.push) {
    return;
  }
  const arr0Len = arr0.length;
  const arr1Len = arr1.length;
  if (arr0Len !== arr1Len) {
    const isPreviousLarger = arr0Len > arr1Len;
    if (isPreviousLarger) {
      arr0.length = arr1Len;
    } else {
      for (let i = arr0Len; i < arr1Len; i++) {
        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
      }
    }
  }
  const len2 = arr0[0] && arr0[0].length;
  for (let i = 0; i < arr0.length; i++) {
    if (arrDim === 1) {
      if (isNaN(arr0[i])) {
        arr0[i] = arr1[i];
      }
    } else {
      for (let j = 0; j < len2; j++) {
        if (isNaN(arr0[i][j])) {
          arr0[i][j] = arr1[i][j];
        }
      }
    }
  }
}
function cloneValue(value) {
  if (isArrayLike(value)) {
    const len2 = value.length;
    if (isArrayLike(value[0])) {
      const ret = [];
      for (let i = 0; i < len2; i++) {
        ret.push(arraySlice.call(value[i]));
      }
      return ret;
    }
    return arraySlice.call(value);
  }
  return value;
}
function rgba2String(rgba) {
  rgba[0] = Math.floor(rgba[0]) || 0;
  rgba[1] = Math.floor(rgba[1]) || 0;
  rgba[2] = Math.floor(rgba[2]) || 0;
  rgba[3] = rgba[3] == null ? 1 : rgba[3];
  return "rgba(" + rgba.join(",") + ")";
}
function guessArrayDim(value) {
  return isArrayLike(value && value[0]) ? 2 : 1;
}
var VALUE_TYPE_NUMBER = 0;
var VALUE_TYPE_1D_ARRAY = 1;
var VALUE_TYPE_2D_ARRAY = 2;
var VALUE_TYPE_COLOR = 3;
var VALUE_TYPE_LINEAR_GRADIENT = 4;
var VALUE_TYPE_RADIAL_GRADIENT = 5;
var VALUE_TYPE_UNKOWN = 6;
function isGradientValueType(valType) {
  return valType === VALUE_TYPE_LINEAR_GRADIENT || valType === VALUE_TYPE_RADIAL_GRADIENT;
}
function isArrayValueType(valType) {
  return valType === VALUE_TYPE_1D_ARRAY || valType === VALUE_TYPE_2D_ARRAY;
}
var tmpRgba = [0, 0, 0, 0];
var Track = class {
  constructor(propName) {
    this.keyframes = [];
    this.discrete = false;
    this._invalid = false;
    this._needsSort = false;
    this._lastFr = 0;
    this._lastFrP = 0;
    this.propName = propName;
  }
  isFinished() {
    return this._finished;
  }
  setFinished() {
    this._finished = true;
    if (this._additiveTrack) {
      this._additiveTrack.setFinished();
    }
  }
  needsAnimate() {
    return this.keyframes.length >= 1;
  }
  getAdditiveTrack() {
    return this._additiveTrack;
  }
  addKeyframe(time, rawValue, easing) {
    this._needsSort = true;
    let keyframes = this.keyframes;
    let len2 = keyframes.length;
    let discrete = false;
    let valType = VALUE_TYPE_UNKOWN;
    let value = rawValue;
    if (isArrayLike(rawValue)) {
      let arrayDim = guessArrayDim(rawValue);
      valType = arrayDim;
      if (arrayDim === 1 && !isNumber(rawValue[0]) || arrayDim === 2 && !isNumber(rawValue[0][0])) {
        discrete = true;
      }
    } else {
      if (isNumber(rawValue) && !eqNaN(rawValue)) {
        valType = VALUE_TYPE_NUMBER;
      } else if (isString(rawValue)) {
        if (!isNaN(+rawValue)) {
          valType = VALUE_TYPE_NUMBER;
        } else {
          const colorArray = parse(rawValue);
          if (colorArray) {
            value = colorArray;
            valType = VALUE_TYPE_COLOR;
          }
        }
      } else if (isGradientObject(rawValue)) {
        const parsedGradient = extend({}, value);
        parsedGradient.colorStops = map(rawValue.colorStops, (colorStop) => ({
          offset: colorStop.offset,
          color: parse(colorStop.color)
        }));
        if (isLinearGradient(rawValue)) {
          valType = VALUE_TYPE_LINEAR_GRADIENT;
        } else if (isRadialGradient(rawValue)) {
          valType = VALUE_TYPE_RADIAL_GRADIENT;
        }
        value = parsedGradient;
      }
    }
    if (len2 === 0) {
      this.valType = valType;
    } else if (valType !== this.valType || valType === VALUE_TYPE_UNKOWN) {
      discrete = true;
    }
    this.discrete = this.discrete || discrete;
    const kf = {
      time,
      value,
      rawValue,
      percent: 0
    };
    if (easing) {
      kf.easing = easing;
      kf.easingFunc = isFunction(easing) ? easing : easing_default[easing] || createCubicEasingFunc(easing);
    }
    keyframes.push(kf);
    return kf;
  }
  prepare(maxTime, additiveTrack) {
    let kfs = this.keyframes;
    if (this._needsSort) {
      kfs.sort(function(a, b) {
        return a.time - b.time;
      });
    }
    const valType = this.valType;
    const kfsLen = kfs.length;
    const lastKf = kfs[kfsLen - 1];
    const isDiscrete = this.discrete;
    const isArr = isArrayValueType(valType);
    const isGradient2 = isGradientValueType(valType);
    for (let i = 0; i < kfsLen; i++) {
      const kf = kfs[i];
      const value = kf.value;
      const lastValue = lastKf.value;
      kf.percent = kf.time / maxTime;
      if (!isDiscrete) {
        if (isArr && i !== kfsLen - 1) {
          fillArray(value, lastValue, valType);
        } else if (isGradient2) {
          fillColorStops(value.colorStops, lastValue.colorStops);
        }
      }
    }
    if (!isDiscrete && valType !== VALUE_TYPE_RADIAL_GRADIENT && additiveTrack && this.needsAnimate() && additiveTrack.needsAnimate() && valType === additiveTrack.valType && !additiveTrack._finished) {
      this._additiveTrack = additiveTrack;
      const startValue = kfs[0].value;
      for (let i = 0; i < kfsLen; i++) {
        if (valType === VALUE_TYPE_NUMBER) {
          kfs[i].additiveValue = kfs[i].value - startValue;
        } else if (valType === VALUE_TYPE_COLOR) {
          kfs[i].additiveValue = add1DArray([], kfs[i].value, startValue, -1);
        } else if (isArrayValueType(valType)) {
          kfs[i].additiveValue = valType === VALUE_TYPE_1D_ARRAY ? add1DArray([], kfs[i].value, startValue, -1) : add2DArray([], kfs[i].value, startValue, -1);
        }
      }
    }
  }
  step(target, percent) {
    if (this._finished) {
      return;
    }
    if (this._additiveTrack && this._additiveTrack._finished) {
      this._additiveTrack = null;
    }
    const isAdditive = this._additiveTrack != null;
    const valueKey = isAdditive ? "additiveValue" : "value";
    const valType = this.valType;
    const keyframes = this.keyframes;
    const kfsNum = keyframes.length;
    const propName = this.propName;
    const isValueColor = valType === VALUE_TYPE_COLOR;
    let frameIdx;
    const lastFrame = this._lastFr;
    const mathMin13 = Math.min;
    let frame;
    let nextFrame;
    if (kfsNum === 1) {
      frame = nextFrame = keyframes[0];
    } else {
      if (percent < 0) {
        frameIdx = 0;
      } else if (percent < this._lastFrP) {
        const start2 = mathMin13(lastFrame + 1, kfsNum - 1);
        for (frameIdx = start2; frameIdx >= 0; frameIdx--) {
          if (keyframes[frameIdx].percent <= percent) {
            break;
          }
        }
        frameIdx = mathMin13(frameIdx, kfsNum - 2);
      } else {
        for (frameIdx = lastFrame; frameIdx < kfsNum; frameIdx++) {
          if (keyframes[frameIdx].percent > percent) {
            break;
          }
        }
        frameIdx = mathMin13(frameIdx - 1, kfsNum - 2);
      }
      nextFrame = keyframes[frameIdx + 1];
      frame = keyframes[frameIdx];
    }
    if (!(frame && nextFrame)) {
      return;
    }
    this._lastFr = frameIdx;
    this._lastFrP = percent;
    const interval = nextFrame.percent - frame.percent;
    let w = interval === 0 ? 1 : mathMin13((percent - frame.percent) / interval, 1);
    if (nextFrame.easingFunc) {
      w = nextFrame.easingFunc(w);
    }
    let targetArr = isAdditive ? this._additiveValue : isValueColor ? tmpRgba : target[propName];
    if ((isArrayValueType(valType) || isValueColor) && !targetArr) {
      targetArr = this._additiveValue = [];
    }
    if (this.discrete) {
      target[propName] = w < 1 ? frame.rawValue : nextFrame.rawValue;
    } else if (isArrayValueType(valType)) {
      valType === VALUE_TYPE_1D_ARRAY ? interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w) : interpolate2DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);
    } else if (isGradientValueType(valType)) {
      const val = frame[valueKey];
      const nextVal = nextFrame[valueKey];
      const isLinearGradient2 = valType === VALUE_TYPE_LINEAR_GRADIENT;
      target[propName] = {
        type: isLinearGradient2 ? "linear" : "radial",
        x: interpolateNumber(val.x, nextVal.x, w),
        y: interpolateNumber(val.y, nextVal.y, w),
        colorStops: map(val.colorStops, (colorStop, idx) => {
          const nextColorStop = nextVal.colorStops[idx];
          return {
            offset: interpolateNumber(colorStop.offset, nextColorStop.offset, w),
            color: rgba2String(interpolate1DArray([], colorStop.color, nextColorStop.color, w))
          };
        }),
        global: nextVal.global
      };
      if (isLinearGradient2) {
        target[propName].x2 = interpolateNumber(val.x2, nextVal.x2, w);
        target[propName].y2 = interpolateNumber(val.y2, nextVal.y2, w);
      } else {
        target[propName].r = interpolateNumber(val.r, nextVal.r, w);
      }
    } else if (isValueColor) {
      interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);
      if (!isAdditive) {
        target[propName] = rgba2String(targetArr);
      }
    } else {
      const value = interpolateNumber(frame[valueKey], nextFrame[valueKey], w);
      if (isAdditive) {
        this._additiveValue = value;
      } else {
        target[propName] = value;
      }
    }
    if (isAdditive) {
      this._addToTarget(target);
    }
  }
  _addToTarget(target) {
    const valType = this.valType;
    const propName = this.propName;
    const additiveValue = this._additiveValue;
    if (valType === VALUE_TYPE_NUMBER) {
      target[propName] = target[propName] + additiveValue;
    } else if (valType === VALUE_TYPE_COLOR) {
      parse(target[propName], tmpRgba);
      add1DArray(tmpRgba, tmpRgba, additiveValue, 1);
      target[propName] = rgba2String(tmpRgba);
    } else if (valType === VALUE_TYPE_1D_ARRAY) {
      add1DArray(target[propName], target[propName], additiveValue, 1);
    } else if (valType === VALUE_TYPE_2D_ARRAY) {
      add2DArray(target[propName], target[propName], additiveValue, 1);
    }
  }
};
var Animator = class {
  constructor(target, loop, allowDiscreteAnimation, additiveTo) {
    this._tracks = {};
    this._trackKeys = [];
    this._maxTime = 0;
    this._started = 0;
    this._clip = null;
    this._target = target;
    this._loop = loop;
    if (loop && additiveTo) {
      logError("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = additiveTo;
    this._allowDiscrete = allowDiscreteAnimation;
  }
  getMaxTime() {
    return this._maxTime;
  }
  getDelay() {
    return this._delay;
  }
  getLoop() {
    return this._loop;
  }
  getTarget() {
    return this._target;
  }
  changeTarget(target) {
    this._target = target;
  }
  when(time, props, easing) {
    return this.whenWithKeys(time, props, keys(props), easing);
  }
  whenWithKeys(time, props, propNames, easing) {
    const tracks = this._tracks;
    for (let i = 0; i < propNames.length; i++) {
      const propName = propNames[i];
      let track = tracks[propName];
      if (!track) {
        track = tracks[propName] = new Track(propName);
        let initialValue;
        const additiveTrack = this._getAdditiveTrack(propName);
        if (additiveTrack) {
          const addtiveTrackKfs = additiveTrack.keyframes;
          const lastFinalKf = addtiveTrackKfs[addtiveTrackKfs.length - 1];
          initialValue = lastFinalKf && lastFinalKf.value;
          if (additiveTrack.valType === VALUE_TYPE_COLOR && initialValue) {
            initialValue = rgba2String(initialValue);
          }
        } else {
          initialValue = this._target[propName];
        }
        if (initialValue == null) {
          continue;
        }
        if (time > 0) {
          track.addKeyframe(0, cloneValue(initialValue), easing);
        }
        this._trackKeys.push(propName);
      }
      track.addKeyframe(time, cloneValue(props[propName]), easing);
    }
    this._maxTime = Math.max(this._maxTime, time);
    return this;
  }
  pause() {
    this._clip.pause();
    this._paused = true;
  }
  resume() {
    this._clip.resume();
    this._paused = false;
  }
  isPaused() {
    return !!this._paused;
  }
  duration(duration) {
    this._maxTime = duration;
    this._force = true;
    return this;
  }
  _doneCallback() {
    this._setTracksFinished();
    this._clip = null;
    const doneList = this._doneCbs;
    if (doneList) {
      const len2 = doneList.length;
      for (let i = 0; i < len2; i++) {
        doneList[i].call(this);
      }
    }
  }
  _abortedCallback() {
    this._setTracksFinished();
    const animation = this.animation;
    const abortedList = this._abortedCbs;
    if (animation) {
      animation.removeClip(this._clip);
    }
    this._clip = null;
    if (abortedList) {
      for (let i = 0; i < abortedList.length; i++) {
        abortedList[i].call(this);
      }
    }
  }
  _setTracksFinished() {
    const tracks = this._tracks;
    const tracksKeys = this._trackKeys;
    for (let i = 0; i < tracksKeys.length; i++) {
      tracks[tracksKeys[i]].setFinished();
    }
  }
  _getAdditiveTrack(trackName) {
    let additiveTrack;
    const additiveAnimators = this._additiveAnimators;
    if (additiveAnimators) {
      for (let i = 0; i < additiveAnimators.length; i++) {
        const track = additiveAnimators[i].getTrack(trackName);
        if (track) {
          additiveTrack = track;
        }
      }
    }
    return additiveTrack;
  }
  start(easing) {
    if (this._started > 0) {
      return;
    }
    this._started = 1;
    const self2 = this;
    const tracks = [];
    const maxTime = this._maxTime || 0;
    for (let i = 0; i < this._trackKeys.length; i++) {
      const propName = this._trackKeys[i];
      const track = this._tracks[propName];
      const additiveTrack = this._getAdditiveTrack(propName);
      const kfs = track.keyframes;
      const kfsNum = kfs.length;
      track.prepare(maxTime, additiveTrack);
      if (track.needsAnimate()) {
        if (!this._allowDiscrete && track.discrete) {
          const lastKf = kfs[kfsNum - 1];
          if (lastKf) {
            self2._target[track.propName] = lastKf.rawValue;
          }
          track.setFinished();
        } else {
          tracks.push(track);
        }
      }
    }
    if (tracks.length || this._force) {
      const clip2 = new Clip_default({
        life: maxTime,
        loop: this._loop,
        delay: this._delay || 0,
        onframe(percent) {
          self2._started = 2;
          const additiveAnimators = self2._additiveAnimators;
          if (additiveAnimators) {
            let stillHasAdditiveAnimator = false;
            for (let i = 0; i < additiveAnimators.length; i++) {
              if (additiveAnimators[i]._clip) {
                stillHasAdditiveAnimator = true;
                break;
              }
            }
            if (!stillHasAdditiveAnimator) {
              self2._additiveAnimators = null;
            }
          }
          for (let i = 0; i < tracks.length; i++) {
            tracks[i].step(self2._target, percent);
          }
          const onframeList = self2._onframeCbs;
          if (onframeList) {
            for (let i = 0; i < onframeList.length; i++) {
              onframeList[i](self2._target, percent);
            }
          }
        },
        ondestroy() {
          self2._doneCallback();
        }
      });
      this._clip = clip2;
      if (this.animation) {
        this.animation.addClip(clip2);
      }
      if (easing) {
        clip2.setEasing(easing);
      }
    } else {
      this._doneCallback();
    }
    return this;
  }
  stop(forwardToLast) {
    if (!this._clip) {
      return;
    }
    const clip2 = this._clip;
    if (forwardToLast) {
      clip2.onframe(1);
    }
    this._abortedCallback();
  }
  delay(time) {
    this._delay = time;
    return this;
  }
  during(cb) {
    if (cb) {
      if (!this._onframeCbs) {
        this._onframeCbs = [];
      }
      this._onframeCbs.push(cb);
    }
    return this;
  }
  done(cb) {
    if (cb) {
      if (!this._doneCbs) {
        this._doneCbs = [];
      }
      this._doneCbs.push(cb);
    }
    return this;
  }
  aborted(cb) {
    if (cb) {
      if (!this._abortedCbs) {
        this._abortedCbs = [];
      }
      this._abortedCbs.push(cb);
    }
    return this;
  }
  getClip() {
    return this._clip;
  }
  getTrack(propName) {
    return this._tracks[propName];
  }
  getTracks() {
    return map(this._trackKeys, (key) => this._tracks[key]);
  }
  stopTracks(propNames, forwardToLast) {
    if (!propNames.length || !this._clip) {
      return true;
    }
    const tracks = this._tracks;
    const tracksKeys = this._trackKeys;
    for (let i = 0; i < propNames.length; i++) {
      const track = tracks[propNames[i]];
      if (track && !track.isFinished()) {
        if (forwardToLast) {
          track.step(this._target, 1);
        } else if (this._started === 1) {
          track.step(this._target, 0);
        }
        track.setFinished();
      }
    }
    let allAborted = true;
    for (let i = 0; i < tracksKeys.length; i++) {
      if (!tracks[tracksKeys[i]].isFinished()) {
        allAborted = false;
        break;
      }
    }
    if (allAborted) {
      this._abortedCallback();
    }
    return allAborted;
  }
  saveTo(target, trackKeys, firstOrLast) {
    if (!target) {
      return;
    }
    trackKeys = trackKeys || this._trackKeys;
    for (let i = 0; i < trackKeys.length; i++) {
      const propName = trackKeys[i];
      const track = this._tracks[propName];
      if (!track || track.isFinished()) {
        continue;
      }
      const kfs = track.keyframes;
      const kf = kfs[firstOrLast ? 0 : kfs.length - 1];
      if (kf) {
        target[propName] = cloneValue(kf.rawValue);
      }
    }
  }
  __changeFinalValue(finalProps, trackKeys) {
    trackKeys = trackKeys || keys(finalProps);
    for (let i = 0; i < trackKeys.length; i++) {
      const propName = trackKeys[i];
      const track = this._tracks[propName];
      if (!track) {
        continue;
      }
      const kfs = track.keyframes;
      if (kfs.length > 1) {
        const lastKf = kfs.pop();
        track.addKeyframe(lastKf.time, finalProps[propName]);
        track.prepare(this._maxTime, track.getAdditiveTrack());
      }
    }
  }
};
var Animator_default = Animator;

// ../zrender/src/animation/Animation.ts
function getTime() {
  return new Date().getTime();
}
var Animation = class extends Eventful_default {
  constructor(opts) {
    super();
    this._running = false;
    this._time = 0;
    this._pausedTime = 0;
    this._pauseStart = 0;
    this._paused = false;
    opts = opts || {};
    this.stage = opts.stage || {};
  }
  addClip(clip2) {
    if (clip2.animation) {
      this.removeClip(clip2);
    }
    if (!this._head) {
      this._head = this._tail = clip2;
    } else {
      this._tail.next = clip2;
      clip2.prev = this._tail;
      clip2.next = null;
      this._tail = clip2;
    }
    clip2.animation = this;
  }
  addAnimator(animator) {
    animator.animation = this;
    const clip2 = animator.getClip();
    if (clip2) {
      this.addClip(clip2);
    }
  }
  removeClip(clip2) {
    if (!clip2.animation) {
      return;
    }
    const prev = clip2.prev;
    const next = clip2.next;
    if (prev) {
      prev.next = next;
    } else {
      this._head = next;
    }
    if (next) {
      next.prev = prev;
    } else {
      this._tail = prev;
    }
    clip2.next = clip2.prev = clip2.animation = null;
  }
  removeAnimator(animator) {
    const clip2 = animator.getClip();
    if (clip2) {
      this.removeClip(clip2);
    }
    animator.animation = null;
  }
  update(notTriggerFrameAndStageUpdate) {
    const time = getTime() - this._pausedTime;
    const delta = time - this._time;
    let clip2 = this._head;
    while (clip2) {
      const nextClip = clip2.next;
      let finished = clip2.step(time, delta);
      if (finished) {
        clip2.ondestroy();
        this.removeClip(clip2);
        clip2 = nextClip;
      } else {
        clip2 = nextClip;
      }
    }
    this._time = time;
    if (!notTriggerFrameAndStageUpdate) {
      this.trigger("frame", delta);
      this.stage.update && this.stage.update();
    }
  }
  _startLoop() {
    const self2 = this;
    this._running = true;
    function step() {
      if (self2._running) {
        requestAnimationFrame_default(step);
        !self2._paused && self2.update();
      }
    }
    requestAnimationFrame_default(step);
  }
  start() {
    if (this._running) {
      return;
    }
    this._time = getTime();
    this._pausedTime = 0;
    this._startLoop();
  }
  stop() {
    this._running = false;
  }
  pause() {
    if (!this._paused) {
      this._pauseStart = getTime();
      this._paused = true;
    }
  }
  resume() {
    if (this._paused) {
      this._pausedTime += getTime() - this._pauseStart;
      this._paused = false;
    }
  }
  clear() {
    let clip2 = this._head;
    while (clip2) {
      let nextClip = clip2.next;
      clip2.prev = clip2.next = clip2.animation = null;
      clip2 = nextClip;
    }
    this._head = this._tail = null;
  }
  isFinished() {
    return this._head == null;
  }
  animate(target, options) {
    options = options || {};
    this.start();
    const animator = new Animator_default(target, options.loop);
    this.addAnimator(animator);
    return animator;
  }
};
var Animation_default = Animation;

// ../zrender/src/dom/HandlerProxy.ts
var TOUCH_CLICK_DELAY = 300;
var globalEventSupported = env_default.domSupported;
var localNativeListenerNames = function() {
  const mouseHandlerNames = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ];
  const touchHandlerNames = [
    "touchstart",
    "touchend",
    "touchmove"
  ];
  const pointerEventNameMap = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  };
  const pointerHandlerNames = map(mouseHandlerNames, function(name) {
    const nm = name.replace("mouse", "pointer");
    return pointerEventNameMap.hasOwnProperty(nm) ? nm : name;
  });
  return {
    mouse: mouseHandlerNames,
    touch: touchHandlerNames,
    pointer: pointerHandlerNames
  };
}();
var globalNativeListenerNames = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
};
var wheelEventSupported = false;
function isPointerFromTouch(event) {
  const pointerType = event.pointerType;
  return pointerType === "pen" || pointerType === "touch";
}
function setTouchTimer(scope) {
  scope.touching = true;
  if (scope.touchTimer != null) {
    clearTimeout(scope.touchTimer);
    scope.touchTimer = null;
  }
  scope.touchTimer = setTimeout(function() {
    scope.touching = false;
    scope.touchTimer = null;
  }, 700);
}
function markTouch(event) {
  event && (event.zrByTouch = true);
}
function normalizeGlobalEvent(instance, event) {
  return normalizeEvent(instance.dom, new FakeGlobalEvent(instance, event), true);
}
function isLocalEl(instance, el) {
  let elTmp = el;
  let isLocal = false;
  while (elTmp && elTmp.nodeType !== 9 && !(isLocal = elTmp.domBelongToZr || elTmp !== el && elTmp === instance.painterRoot)) {
    elTmp = elTmp.parentNode;
  }
  return isLocal;
}
var FakeGlobalEvent = class {
  constructor(instance, event) {
    this.stopPropagation = noop;
    this.stopImmediatePropagation = noop;
    this.preventDefault = noop;
    this.type = event.type;
    this.target = this.currentTarget = instance.dom;
    this.pointerType = event.pointerType;
    this.clientX = event.clientX;
    this.clientY = event.clientY;
  }
};
var localDOMHandlers = {
  mousedown(event) {
    event = normalizeEvent(this.dom, event);
    this.__mayPointerCapture = [event.zrX, event.zrY];
    this.trigger("mousedown", event);
  },
  mousemove(event) {
    event = normalizeEvent(this.dom, event);
    const downPoint = this.__mayPointerCapture;
    if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {
      this.__togglePointerCapture(true);
    }
    this.trigger("mousemove", event);
  },
  mouseup(event) {
    event = normalizeEvent(this.dom, event);
    this.__togglePointerCapture(false);
    this.trigger("mouseup", event);
  },
  mouseout(event) {
    event = normalizeEvent(this.dom, event);
    const element = event.toElement || event.relatedTarget;
    if (!isLocalEl(this, element)) {
      if (this.__pointerCapturing) {
        event.zrEventControl = "no_globalout";
      }
      this.trigger("mouseout", event);
    }
  },
  wheel(event) {
    wheelEventSupported = true;
    event = normalizeEvent(this.dom, event);
    this.trigger("mousewheel", event);
  },
  mousewheel(event) {
    if (wheelEventSupported) {
      return;
    }
    event = normalizeEvent(this.dom, event);
    this.trigger("mousewheel", event);
  },
  touchstart(event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.__lastTouchMoment = new Date();
    this.handler.processGesture(event, "start");
    localDOMHandlers.mousemove.call(this, event);
    localDOMHandlers.mousedown.call(this, event);
  },
  touchmove(event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.handler.processGesture(event, "change");
    localDOMHandlers.mousemove.call(this, event);
  },
  touchend(event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.handler.processGesture(event, "end");
    localDOMHandlers.mouseup.call(this, event);
    if (+new Date() - +this.__lastTouchMoment < TOUCH_CLICK_DELAY) {
      localDOMHandlers.click.call(this, event);
    }
  },
  pointerdown(event) {
    localDOMHandlers.mousedown.call(this, event);
  },
  pointermove(event) {
    if (!isPointerFromTouch(event)) {
      localDOMHandlers.mousemove.call(this, event);
    }
  },
  pointerup(event) {
    localDOMHandlers.mouseup.call(this, event);
  },
  pointerout(event) {
    if (!isPointerFromTouch(event)) {
      localDOMHandlers.mouseout.call(this, event);
    }
  }
};
each(["click", "dblclick", "contextmenu"], function(name) {
  localDOMHandlers[name] = function(event) {
    event = normalizeEvent(this.dom, event);
    this.trigger(name, event);
  };
});
var globalDOMHandlers = {
  pointermove: function(event) {
    if (!isPointerFromTouch(event)) {
      globalDOMHandlers.mousemove.call(this, event);
    }
  },
  pointerup: function(event) {
    globalDOMHandlers.mouseup.call(this, event);
  },
  mousemove: function(event) {
    this.trigger("mousemove", event);
  },
  mouseup: function(event) {
    const pointerCaptureReleasing = this.__pointerCapturing;
    this.__togglePointerCapture(false);
    this.trigger("mouseup", event);
    if (pointerCaptureReleasing) {
      event.zrEventControl = "only_globalout";
      this.trigger("mouseout", event);
    }
  }
};
function mountLocalDOMEventListeners(instance, scope) {
  const domHandlers = scope.domHandlers;
  if (env_default.pointerEventsSupported) {
    each(localNativeListenerNames.pointer, function(nativeEventName) {
      mountSingleDOMEventListener(scope, nativeEventName, function(event) {
        domHandlers[nativeEventName].call(instance, event);
      });
    });
  } else {
    if (env_default.touchEventsSupported) {
      each(localNativeListenerNames.touch, function(nativeEventName) {
        mountSingleDOMEventListener(scope, nativeEventName, function(event) {
          domHandlers[nativeEventName].call(instance, event);
          setTouchTimer(scope);
        });
      });
    }
    each(localNativeListenerNames.mouse, function(nativeEventName) {
      mountSingleDOMEventListener(scope, nativeEventName, function(event) {
        event = getNativeEvent(event);
        if (!scope.touching) {
          domHandlers[nativeEventName].call(instance, event);
        }
      });
    });
  }
}
function mountGlobalDOMEventListeners(instance, scope) {
  if (env_default.pointerEventsSupported) {
    each(globalNativeListenerNames.pointer, mount);
  } else if (!env_default.touchEventsSupported) {
    each(globalNativeListenerNames.mouse, mount);
  }
  function mount(nativeEventName) {
    function nativeEventListener(event) {
      event = getNativeEvent(event);
      if (!isLocalEl(instance, event.target)) {
        event = normalizeGlobalEvent(instance, event);
        scope.domHandlers[nativeEventName].call(instance, event);
      }
    }
    mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, {capture: true});
  }
}
function mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {
  scope.mounted[nativeEventName] = listener;
  scope.listenerOpts[nativeEventName] = opt;
  addEventListener(scope.domTarget, nativeEventName, listener, opt);
}
function unmountDOMEventListeners(scope) {
  const mounted = scope.mounted;
  for (let nativeEventName in mounted) {
    if (mounted.hasOwnProperty(nativeEventName)) {
      removeEventListener(scope.domTarget, nativeEventName, mounted[nativeEventName], scope.listenerOpts[nativeEventName]);
    }
  }
  scope.mounted = {};
}
var DOMHandlerScope = class {
  constructor(domTarget, domHandlers) {
    this.mounted = {};
    this.listenerOpts = {};
    this.touching = false;
    this.domTarget = domTarget;
    this.domHandlers = domHandlers;
  }
};
var HandlerDomProxy = class extends Eventful_default {
  constructor(dom, painterRoot) {
    super();
    this.__pointerCapturing = false;
    this.dom = dom;
    this.painterRoot = painterRoot;
    this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);
    if (globalEventSupported) {
      this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);
    }
    mountLocalDOMEventListeners(this, this._localHandlerScope);
  }
  dispose() {
    unmountDOMEventListeners(this._localHandlerScope);
    if (globalEventSupported) {
      unmountDOMEventListeners(this._globalHandlerScope);
    }
  }
  setCursor(cursorStyle) {
    this.dom.style && (this.dom.style.cursor = cursorStyle || "default");
  }
  __togglePointerCapture(isPointerCapturing) {
    this.__mayPointerCapture = null;
    if (globalEventSupported && +this.__pointerCapturing ^ +isPointerCapturing) {
      this.__pointerCapturing = isPointerCapturing;
      const globalHandlerScope = this._globalHandlerScope;
      isPointerCapturing ? mountGlobalDOMEventListeners(this, globalHandlerScope) : unmountDOMEventListeners(globalHandlerScope);
    }
  }
};
var HandlerProxy_default = HandlerDomProxy;

// ../zrender/src/config.ts
var dpr = 1;
if (env_default.hasGlobalWindow) {
  dpr = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1);
}
var devicePixelRatio = dpr;
var DARK_MODE_THRESHOLD = 0.4;
var DARK_LABEL_COLOR = "#333";
var LIGHT_LABEL_COLOR = "#ccc";
var LIGHTER_LABEL_COLOR = "#eee";

// ../zrender/src/core/Transformable.ts
var mIdentity = identity;
var EPSILON4 = 5e-5;
function isNotAroundZero2(val) {
  return val > EPSILON4 || val < -EPSILON4;
}
var scaleTmp = [];
var tmpTransform = [];
var originTransform = create2();
var abs = Math.abs;
var Transformable2 = class {
  getLocalTransform(m2) {
    return Transformable2.getLocalTransform(this, m2);
  }
  setPosition(arr) {
    this.x = arr[0];
    this.y = arr[1];
  }
  setScale(arr) {
    this.scaleX = arr[0];
    this.scaleY = arr[1];
  }
  setSkew(arr) {
    this.skewX = arr[0];
    this.skewY = arr[1];
  }
  setOrigin(arr) {
    this.originX = arr[0];
    this.originY = arr[1];
  }
  needLocalTransform() {
    return isNotAroundZero2(this.rotation) || isNotAroundZero2(this.x) || isNotAroundZero2(this.y) || isNotAroundZero2(this.scaleX - 1) || isNotAroundZero2(this.scaleY - 1) || isNotAroundZero2(this.skewX) || isNotAroundZero2(this.skewY);
  }
  updateTransform() {
    const parentTransform = this.parent && this.parent.transform;
    const needLocalTransform = this.needLocalTransform();
    let m2 = this.transform;
    if (!(needLocalTransform || parentTransform)) {
      if (m2) {
        mIdentity(m2);
        this.invTransform = null;
      }
      return;
    }
    m2 = m2 || create2();
    if (needLocalTransform) {
      this.getLocalTransform(m2);
    } else {
      mIdentity(m2);
    }
    if (parentTransform) {
      if (needLocalTransform) {
        mul2(m2, parentTransform, m2);
      } else {
        copy2(m2, parentTransform);
      }
    }
    this.transform = m2;
    this._resolveGlobalScaleRatio(m2);
  }
  _resolveGlobalScaleRatio(m2) {
    const globalScaleRatio = this.globalScaleRatio;
    if (globalScaleRatio != null && globalScaleRatio !== 1) {
      this.getGlobalScale(scaleTmp);
      const relX = scaleTmp[0] < 0 ? -1 : 1;
      const relY = scaleTmp[1] < 0 ? -1 : 1;
      const sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;
      const sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;
      m2[0] *= sx;
      m2[1] *= sx;
      m2[2] *= sy;
      m2[3] *= sy;
    }
    this.invTransform = this.invTransform || create2();
    invert(this.invTransform, m2);
  }
  getComputedTransform() {
    let transformNode = this;
    const ancestors = [];
    while (transformNode) {
      ancestors.push(transformNode);
      transformNode = transformNode.parent;
    }
    while (transformNode = ancestors.pop()) {
      transformNode.updateTransform();
    }
    return this.transform;
  }
  setLocalTransform(m2) {
    if (!m2) {
      return;
    }
    let sx = m2[0] * m2[0] + m2[1] * m2[1];
    let sy = m2[2] * m2[2] + m2[3] * m2[3];
    const rotation = Math.atan2(m2[1], m2[0]);
    const shearX = Math.PI / 2 + rotation - Math.atan2(m2[3], m2[2]);
    sy = Math.sqrt(sy) * Math.cos(shearX);
    sx = Math.sqrt(sx);
    this.skewX = shearX;
    this.skewY = 0;
    this.rotation = -rotation;
    this.x = +m2[4];
    this.y = +m2[5];
    this.scaleX = sx;
    this.scaleY = sy;
    this.originX = 0;
    this.originY = 0;
  }
  decomposeTransform() {
    if (!this.transform) {
      return;
    }
    const parent = this.parent;
    let m2 = this.transform;
    if (parent && parent.transform) {
      parent.invTransform = parent.invTransform || create2();
      mul2(tmpTransform, parent.invTransform, m2);
      m2 = tmpTransform;
    }
    const ox = this.originX;
    const oy = this.originY;
    if (ox || oy) {
      originTransform[4] = ox;
      originTransform[5] = oy;
      mul2(tmpTransform, m2, originTransform);
      tmpTransform[4] -= ox;
      tmpTransform[5] -= oy;
      m2 = tmpTransform;
    }
    this.setLocalTransform(m2);
  }
  getGlobalScale(out2) {
    const m2 = this.transform;
    out2 = out2 || [];
    if (!m2) {
      out2[0] = 1;
      out2[1] = 1;
      return out2;
    }
    out2[0] = Math.sqrt(m2[0] * m2[0] + m2[1] * m2[1]);
    out2[1] = Math.sqrt(m2[2] * m2[2] + m2[3] * m2[3]);
    if (m2[0] < 0) {
      out2[0] = -out2[0];
    }
    if (m2[3] < 0) {
      out2[1] = -out2[1];
    }
    return out2;
  }
  transformCoordToLocal(x, y) {
    const v22 = [x, y];
    const invTransform = this.invTransform;
    if (invTransform) {
      applyTransform(v22, v22, invTransform);
    }
    return v22;
  }
  transformCoordToGlobal(x, y) {
    const v22 = [x, y];
    const transform2 = this.transform;
    if (transform2) {
      applyTransform(v22, v22, transform2);
    }
    return v22;
  }
  getLineScale() {
    const m2 = this.transform;
    return m2 && abs(m2[0] - 1) > 1e-10 && abs(m2[3] - 1) > 1e-10 ? Math.sqrt(abs(m2[0] * m2[3] - m2[2] * m2[1])) : 1;
  }
  copyTransform(source) {
    copyTransform(this, source);
  }
  static getLocalTransform(target, m2) {
    m2 = m2 || [];
    const ox = target.originX || 0;
    const oy = target.originY || 0;
    const sx = target.scaleX;
    const sy = target.scaleY;
    const ax = target.anchorX;
    const ay = target.anchorY;
    const rotation = target.rotation || 0;
    const x = target.x;
    const y = target.y;
    const skewX = target.skewX ? Math.tan(target.skewX) : 0;
    const skewY = target.skewY ? Math.tan(-target.skewY) : 0;
    if (ox || oy || ax || ay) {
      const dx = ox + ax;
      const dy = oy + ay;
      m2[4] = -dx * sx - skewX * dy * sy;
      m2[5] = -dy * sy - skewY * dx * sx;
    } else {
      m2[4] = m2[5] = 0;
    }
    m2[0] = sx;
    m2[3] = sy;
    m2[1] = skewY * sx;
    m2[2] = skewX * sy;
    rotation && rotate(m2, m2, rotation);
    m2[4] += ox + x;
    m2[5] += oy + y;
    return m2;
  }
};
var Transformable = Transformable2;
Transformable.initDefaultProps = function() {
  const proto = Transformable2.prototype;
  proto.scaleX = proto.scaleY = proto.globalScaleRatio = 1;
  proto.x = proto.y = proto.originX = proto.originY = proto.skewX = proto.skewY = proto.rotation = proto.anchorX = proto.anchorY = 0;
}();
var TRANSFORMABLE_PROPS = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function copyTransform(target, source) {
  for (let i = 0; i < TRANSFORMABLE_PROPS.length; i++) {
    const propName = TRANSFORMABLE_PROPS[i];
    target[propName] = source[propName];
  }
}
var Transformable_default = Transformable;

// ../zrender/src/contain/text.ts
function ensureFontMeasureInfo(font) {
  if (!_fontMeasureInfoCache) {
    _fontMeasureInfoCache = new LRU_default(100);
  }
  font = font || DEFAULT_FONT;
  let measureInfo = _fontMeasureInfoCache.get(font);
  if (!measureInfo) {
    measureInfo = {
      font,
      strWidthCache: new LRU_default(500),
      asciiWidthMap: null,
      asciiWidthMapTried: false,
      stWideCharWidth: platformApi.measureText("\u56FD", font).width,
      asciiCharWidth: platformApi.measureText("a", font).width
    };
    _fontMeasureInfoCache.put(font, measureInfo);
  }
  return measureInfo;
}
var _fontMeasureInfoCache;
function tryCreateASCIIWidthMap(font) {
  if (_getASCIIWidthMapLongCount >= GET_ASCII_WIDTH_LONG_COUNT_MAX) {
    return;
  }
  font = font || DEFAULT_FONT;
  const asciiWidthMap = [];
  const start2 = +new Date();
  for (let code = 0; code <= 127; code++) {
    asciiWidthMap[code] = platformApi.measureText(String.fromCharCode(code), font).width;
  }
  const cost = +new Date() - start2;
  if (cost > 16) {
    _getASCIIWidthMapLongCount = GET_ASCII_WIDTH_LONG_COUNT_MAX;
  } else if (cost > 2) {
    _getASCIIWidthMapLongCount++;
  }
  return asciiWidthMap;
}
var _getASCIIWidthMapLongCount = 0;
var GET_ASCII_WIDTH_LONG_COUNT_MAX = 5;
function measureCharWidth(fontMeasureInfo, charCode) {
  if (!fontMeasureInfo.asciiWidthMapTried) {
    fontMeasureInfo.asciiWidthMap = tryCreateASCIIWidthMap(fontMeasureInfo.font);
    fontMeasureInfo.asciiWidthMapTried = true;
  }
  return 0 <= charCode && charCode <= 127 ? fontMeasureInfo.asciiWidthMap != null ? fontMeasureInfo.asciiWidthMap[charCode] : fontMeasureInfo.asciiCharWidth : fontMeasureInfo.stWideCharWidth;
}
function measureWidth(fontMeasureInfo, text) {
  const strWidthCache = fontMeasureInfo.strWidthCache;
  let width = strWidthCache.get(text);
  if (width == null) {
    width = platformApi.measureText(text, fontMeasureInfo.font).width;
    strWidthCache.put(text, width);
  }
  return width;
}
function innerGetBoundingRect(text, font, textAlign, textBaseline) {
  const width = measureWidth(ensureFontMeasureInfo(font), text);
  const height = getLineHeight(font);
  const x = adjustTextX(0, width, textAlign);
  const y = adjustTextY2(0, height, textBaseline);
  const rect = new BoundingRect_default(x, y, width, height);
  return rect;
}
function getBoundingRect(text, font, textAlign, textBaseline) {
  const textLines = ((text || "") + "").split("\n");
  const len2 = textLines.length;
  if (len2 === 1) {
    return innerGetBoundingRect(textLines[0], font, textAlign, textBaseline);
  } else {
    const uniondRect = new BoundingRect_default(0, 0, 0, 0);
    for (let i = 0; i < textLines.length; i++) {
      const rect = innerGetBoundingRect(textLines[i], font, textAlign, textBaseline);
      i === 0 ? uniondRect.copy(rect) : uniondRect.union(rect);
    }
    return uniondRect;
  }
}
function adjustTextX(x, width, textAlign, inverse) {
  if (textAlign === "right") {
    !inverse ? x -= width : x += width;
  } else if (textAlign === "center") {
    !inverse ? x -= width / 2 : x += width / 2;
  }
  return x;
}
function adjustTextY2(y, height, verticalAlign, inverse) {
  if (verticalAlign === "middle") {
    !inverse ? y -= height / 2 : y += height / 2;
  } else if (verticalAlign === "bottom") {
    !inverse ? y -= height : y += height;
  }
  return y;
}
function getLineHeight(font) {
  return ensureFontMeasureInfo(font).stWideCharWidth;
}
function parsePercent(value, maxValue) {
  if (typeof value === "string") {
    if (value.lastIndexOf("%") >= 0) {
      return parseFloat(value) / 100 * maxValue;
    }
    return parseFloat(value);
  }
  return value;
}
function calculateTextPosition(out2, opts, rect) {
  const textPosition = opts.position || "inside";
  const distance2 = opts.distance != null ? opts.distance : 5;
  const height = rect.height;
  const width = rect.width;
  const halfHeight = height / 2;
  let x = rect.x;
  let y = rect.y;
  let textAlign = "left";
  let textVerticalAlign = "top";
  if (textPosition instanceof Array) {
    x += parsePercent(textPosition[0], rect.width);
    y += parsePercent(textPosition[1], rect.height);
    textAlign = null;
    textVerticalAlign = null;
  } else {
    switch (textPosition) {
      case "left":
        x -= distance2;
        y += halfHeight;
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      case "right":
        x += distance2 + width;
        y += halfHeight;
        textVerticalAlign = "middle";
        break;
      case "top":
        x += width / 2;
        y -= distance2;
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "bottom":
        x += width / 2;
        y += height + distance2;
        textAlign = "center";
        break;
      case "inside":
        x += width / 2;
        y += halfHeight;
        textAlign = "center";
        textVerticalAlign = "middle";
        break;
      case "insideLeft":
        x += distance2;
        y += halfHeight;
        textVerticalAlign = "middle";
        break;
      case "insideRight":
        x += width - distance2;
        y += halfHeight;
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      case "insideTop":
        x += width / 2;
        y += distance2;
        textAlign = "center";
        break;
      case "insideBottom":
        x += width / 2;
        y += height - distance2;
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "insideTopLeft":
        x += distance2;
        y += distance2;
        break;
      case "insideTopRight":
        x += width - distance2;
        y += distance2;
        textAlign = "right";
        break;
      case "insideBottomLeft":
        x += distance2;
        y += height - distance2;
        textVerticalAlign = "bottom";
        break;
      case "insideBottomRight":
        x += width - distance2;
        y += height - distance2;
        textAlign = "right";
        textVerticalAlign = "bottom";
        break;
    }
  }
  out2 = out2 || {};
  out2.x = x;
  out2.y = y;
  out2.align = textAlign;
  out2.verticalAlign = textVerticalAlign;
  return out2;
}

// ../zrender/src/Element.ts
var PRESERVED_NORMAL_STATE = "__zr_normal__";
var PRIMARY_STATES_KEYS = TRANSFORMABLE_PROPS.concat(["ignore"]);
var DEFAULT_ANIMATABLE_MAP = reduce(TRANSFORMABLE_PROPS, (obj, key) => {
  obj[key] = true;
  return obj;
}, {ignore: false});
var tmpTextPosCalcRes = {};
var tmpBoundingRect = new BoundingRect_default(0, 0, 0, 0);
var tmpInnerTextTrans = [];
var Element2 = class {
  constructor(props) {
    this.id = guid();
    this.animators = [];
    this.currentStates = [];
    this.states = {};
    this._init(props);
  }
  _init(props) {
    this.attr(props);
  }
  drift(dx, dy, e2) {
    switch (this.draggable) {
      case "horizontal":
        dy = 0;
        break;
      case "vertical":
        dx = 0;
        break;
    }
    let m2 = this.transform;
    if (!m2) {
      m2 = this.transform = [1, 0, 0, 1, 0, 0];
    }
    m2[4] += dx;
    m2[5] += dy;
    this.decomposeTransform();
    this.markRedraw();
  }
  beforeUpdate() {
  }
  afterUpdate() {
  }
  update() {
    this.updateTransform();
    if (this.__dirty) {
      this.updateInnerText();
    }
  }
  updateInnerText(forceUpdate) {
    const textEl = this._textContent;
    if (textEl && (!textEl.ignore || forceUpdate)) {
      if (!this.textConfig) {
        this.textConfig = {};
      }
      const textConfig = this.textConfig;
      const isLocal = textConfig.local;
      const innerTransformable = textEl.innerTransformable;
      let textAlign;
      let textVerticalAlign;
      let textStyleChanged = false;
      innerTransformable.parent = isLocal ? this : null;
      let innerOrigin = false;
      innerTransformable.copyTransform(textEl);
      const hasPosition = textConfig.position != null;
      const autoOverflowArea = textConfig.autoOverflowArea;
      let layoutRect;
      if (autoOverflowArea || hasPosition) {
        layoutRect = tmpBoundingRect;
        if (textConfig.layoutRect) {
          layoutRect.copy(textConfig.layoutRect);
        } else {
          layoutRect.copy(this.getBoundingRect());
        }
        if (!isLocal) {
          layoutRect.applyTransform(this.transform);
        }
      }
      if (hasPosition) {
        if (this.calculateTextPosition) {
          this.calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
        } else {
          calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
        }
        innerTransformable.x = tmpTextPosCalcRes.x;
        innerTransformable.y = tmpTextPosCalcRes.y;
        textAlign = tmpTextPosCalcRes.align;
        textVerticalAlign = tmpTextPosCalcRes.verticalAlign;
        const textOrigin = textConfig.origin;
        if (textOrigin && textConfig.rotation != null) {
          let relOriginX;
          let relOriginY;
          if (textOrigin === "center") {
            relOriginX = layoutRect.width * 0.5;
            relOriginY = layoutRect.height * 0.5;
          } else {
            relOriginX = parsePercent(textOrigin[0], layoutRect.width);
            relOriginY = parsePercent(textOrigin[1], layoutRect.height);
          }
          innerOrigin = true;
          innerTransformable.originX = -innerTransformable.x + relOriginX + (isLocal ? 0 : layoutRect.x);
          innerTransformable.originY = -innerTransformable.y + relOriginY + (isLocal ? 0 : layoutRect.y);
        }
      }
      if (textConfig.rotation != null) {
        innerTransformable.rotation = textConfig.rotation;
      }
      const textOffset = textConfig.offset;
      if (textOffset) {
        innerTransformable.x += textOffset[0];
        innerTransformable.y += textOffset[1];
        if (!innerOrigin) {
          innerTransformable.originX = -textOffset[0];
          innerTransformable.originY = -textOffset[1];
        }
      }
      const innerTextDefaultStyle = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});
      if (autoOverflowArea) {
        const overflowRect = innerTextDefaultStyle.overflowRect = innerTextDefaultStyle.overflowRect || new BoundingRect_default(0, 0, 0, 0);
        innerTransformable.getLocalTransform(tmpInnerTextTrans);
        invert(tmpInnerTextTrans, tmpInnerTextTrans);
        BoundingRect_default.copy(overflowRect, layoutRect);
        overflowRect.applyTransform(tmpInnerTextTrans);
      } else {
        innerTextDefaultStyle.overflowRect = null;
      }
      const isInside = textConfig.inside == null ? typeof textConfig.position === "string" && textConfig.position.indexOf("inside") >= 0 : textConfig.inside;
      let textFill;
      let textStroke;
      let autoStroke;
      if (isInside && this.canBeInsideText()) {
        textFill = textConfig.insideFill;
        textStroke = textConfig.insideStroke;
        if (textFill == null || textFill === "auto") {
          textFill = this.getInsideTextFill();
        }
        if (textStroke == null || textStroke === "auto") {
          textStroke = this.getInsideTextStroke(textFill);
          autoStroke = true;
        }
      } else {
        textFill = textConfig.outsideFill;
        textStroke = textConfig.outsideStroke;
        if (textFill == null || textFill === "auto") {
          textFill = this.getOutsideFill();
        }
        if (textStroke == null || textStroke === "auto") {
          textStroke = this.getOutsideStroke(textFill);
          autoStroke = true;
        }
      }
      textFill = textFill || "#000";
      if (textFill !== innerTextDefaultStyle.fill || textStroke !== innerTextDefaultStyle.stroke || autoStroke !== innerTextDefaultStyle.autoStroke || textAlign !== innerTextDefaultStyle.align || textVerticalAlign !== innerTextDefaultStyle.verticalAlign) {
        textStyleChanged = true;
        innerTextDefaultStyle.fill = textFill;
        innerTextDefaultStyle.stroke = textStroke;
        innerTextDefaultStyle.autoStroke = autoStroke;
        innerTextDefaultStyle.align = textAlign;
        innerTextDefaultStyle.verticalAlign = textVerticalAlign;
        textEl.setDefaultTextStyle(innerTextDefaultStyle);
      }
      textEl.__dirty |= REDRAW_BIT;
      if (textStyleChanged) {
        textEl.dirtyStyle(true);
      }
    }
  }
  canBeInsideText() {
    return true;
  }
  getInsideTextFill() {
    return "#fff";
  }
  getInsideTextStroke(textFill) {
    return "#000";
  }
  getOutsideFill() {
    return this.__zr && this.__zr.isDarkMode() ? LIGHT_LABEL_COLOR : DARK_LABEL_COLOR;
  }
  getOutsideStroke(textFill) {
    const backgroundColor2 = this.__zr && this.__zr.getBackgroundColor();
    let colorArr = typeof backgroundColor2 === "string" && parse(backgroundColor2);
    if (!colorArr) {
      colorArr = [255, 255, 255, 1];
    }
    const alpha = colorArr[3];
    const isDark = this.__zr.isDarkMode();
    for (let i = 0; i < 3; i++) {
      colorArr[i] = colorArr[i] * alpha + (isDark ? 0 : 255) * (1 - alpha);
    }
    colorArr[3] = 1;
    return stringify(colorArr, "rgba");
  }
  traverse(cb, context) {
  }
  attrKV(key, value) {
    if (key === "textConfig") {
      this.setTextConfig(value);
    } else if (key === "textContent") {
      this.setTextContent(value);
    } else if (key === "clipPath") {
      this.setClipPath(value);
    } else if (key === "extra") {
      this.extra = this.extra || {};
      extend(this.extra, value);
    } else {
      this[key] = value;
    }
  }
  hide() {
    this.ignore = true;
    this.markRedraw();
  }
  show() {
    this.ignore = false;
    this.markRedraw();
  }
  attr(keyOrObj, value) {
    if (typeof keyOrObj === "string") {
      this.attrKV(keyOrObj, value);
    } else if (isObject(keyOrObj)) {
      let obj = keyOrObj;
      let keysArr = keys(obj);
      for (let i = 0; i < keysArr.length; i++) {
        let key = keysArr[i];
        this.attrKV(key, keyOrObj[key]);
      }
    }
    this.markRedraw();
    return this;
  }
  saveCurrentToNormalState(toState) {
    this._innerSaveToNormal(toState);
    const normalState = this._normalState;
    for (let i = 0; i < this.animators.length; i++) {
      const animator = this.animators[i];
      const fromStateTransition = animator.__fromStateTransition;
      if (animator.getLoop() || fromStateTransition && fromStateTransition !== PRESERVED_NORMAL_STATE) {
        continue;
      }
      const targetName = animator.targetName;
      const target = targetName ? normalState[targetName] : normalState;
      animator.saveTo(target);
    }
  }
  _innerSaveToNormal(toState) {
    let normalState = this._normalState;
    if (!normalState) {
      normalState = this._normalState = {};
    }
    if (toState.textConfig && !normalState.textConfig) {
      normalState.textConfig = this.textConfig;
    }
    this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS);
  }
  _savePrimaryToNormal(toState, normalState, primaryKeys) {
    for (let i = 0; i < primaryKeys.length; i++) {
      let key = primaryKeys[i];
      if (toState[key] != null && !(key in normalState)) {
        normalState[key] = this[key];
      }
    }
  }
  hasState() {
    return this.currentStates.length > 0;
  }
  getState(name) {
    return this.states[name];
  }
  ensureState(name) {
    const states = this.states;
    if (!states[name]) {
      states[name] = {};
    }
    return states[name];
  }
  clearStates(noAnimation) {
    this.useState(PRESERVED_NORMAL_STATE, false, noAnimation);
  }
  useState(stateName, keepCurrentStates, noAnimation, forceUseHoverLayer) {
    const toNormalState = stateName === PRESERVED_NORMAL_STATE;
    const hasStates = this.hasState();
    if (!hasStates && toNormalState) {
      return;
    }
    const currentStates = this.currentStates;
    const animationCfg = this.stateTransition;
    if (indexOf(currentStates, stateName) >= 0 && (keepCurrentStates || currentStates.length === 1)) {
      return;
    }
    let state;
    if (this.stateProxy && !toNormalState) {
      state = this.stateProxy(stateName);
    }
    if (!state) {
      state = this.states && this.states[stateName];
    }
    if (!state && !toNormalState) {
      logError(`State ${stateName} not exists.`);
      return;
    }
    if (!toNormalState) {
      this.saveCurrentToNormalState(state);
    }
    const useHoverLayer = !!(state && state.hoverLayer || forceUseHoverLayer);
    if (useHoverLayer) {
      this._toggleHoverLayerFlag(true);
    }
    this._applyStateObj(stateName, state, this._normalState, keepCurrentStates, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
    const textContent = this._textContent;
    const textGuide = this._textGuide;
    if (textContent) {
      textContent.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
    }
    if (textGuide) {
      textGuide.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
    }
    if (toNormalState) {
      this.currentStates = [];
      this._normalState = {};
    } else {
      if (!keepCurrentStates) {
        this.currentStates = [stateName];
      } else {
        this.currentStates.push(stateName);
      }
    }
    this._updateAnimationTargets();
    this.markRedraw();
    if (!useHoverLayer && this.__inHover) {
      this._toggleHoverLayerFlag(false);
      this.__dirty &= ~REDRAW_BIT;
    }
    return state;
  }
  useStates(states, noAnimation, forceUseHoverLayer) {
    if (!states.length) {
      this.clearStates();
    } else {
      const stateObjects = [];
      const currentStates = this.currentStates;
      const len2 = states.length;
      let notChange = len2 === currentStates.length;
      if (notChange) {
        for (let i = 0; i < len2; i++) {
          if (states[i] !== currentStates[i]) {
            notChange = false;
            break;
          }
        }
      }
      if (notChange) {
        return;
      }
      for (let i = 0; i < len2; i++) {
        const stateName = states[i];
        let stateObj;
        if (this.stateProxy) {
          stateObj = this.stateProxy(stateName, states);
        }
        if (!stateObj) {
          stateObj = this.states[stateName];
        }
        if (stateObj) {
          stateObjects.push(stateObj);
        }
      }
      const lastStateObj = stateObjects[len2 - 1];
      const useHoverLayer = !!(lastStateObj && lastStateObj.hoverLayer || forceUseHoverLayer);
      if (useHoverLayer) {
        this._toggleHoverLayerFlag(true);
      }
      const mergedState = this._mergeStates(stateObjects);
      const animationCfg = this.stateTransition;
      this.saveCurrentToNormalState(mergedState);
      this._applyStateObj(states.join(","), mergedState, this._normalState, false, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
      const textContent = this._textContent;
      const textGuide = this._textGuide;
      if (textContent) {
        textContent.useStates(states, noAnimation, useHoverLayer);
      }
      if (textGuide) {
        textGuide.useStates(states, noAnimation, useHoverLayer);
      }
      this._updateAnimationTargets();
      this.currentStates = states.slice();
      this.markRedraw();
      if (!useHoverLayer && this.__inHover) {
        this._toggleHoverLayerFlag(false);
        this.__dirty &= ~REDRAW_BIT;
      }
    }
  }
  isSilent() {
    let el = this;
    while (el) {
      if (el.silent) {
        return true;
      }
      const hostEl = el.__hostTarget;
      el = hostEl ? el.ignoreHostSilent ? null : hostEl : el.parent;
    }
    return false;
  }
  _updateAnimationTargets() {
    for (let i = 0; i < this.animators.length; i++) {
      const animator = this.animators[i];
      if (animator.targetName) {
        animator.changeTarget(this[animator.targetName]);
      }
    }
  }
  removeState(state) {
    const idx = indexOf(this.currentStates, state);
    if (idx >= 0) {
      const currentStates = this.currentStates.slice();
      currentStates.splice(idx, 1);
      this.useStates(currentStates);
    }
  }
  replaceState(oldState, newState, forceAdd) {
    const currentStates = this.currentStates.slice();
    const idx = indexOf(currentStates, oldState);
    const newStateExists = indexOf(currentStates, newState) >= 0;
    if (idx >= 0) {
      if (!newStateExists) {
        currentStates[idx] = newState;
      } else {
        currentStates.splice(idx, 1);
      }
    } else if (forceAdd && !newStateExists) {
      currentStates.push(newState);
    }
    this.useStates(currentStates);
  }
  toggleState(state, enable) {
    if (enable) {
      this.useState(state, true);
    } else {
      this.removeState(state);
    }
  }
  _mergeStates(states) {
    const mergedState = {};
    let mergedTextConfig;
    for (let i = 0; i < states.length; i++) {
      const state = states[i];
      extend(mergedState, state);
      if (state.textConfig) {
        mergedTextConfig = mergedTextConfig || {};
        extend(mergedTextConfig, state.textConfig);
      }
    }
    if (mergedTextConfig) {
      mergedState.textConfig = mergedTextConfig;
    }
    return mergedState;
  }
  _applyStateObj(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
    const needsRestoreToNormal = !(state && keepCurrentStates);
    if (state && state.textConfig) {
      this.textConfig = extend({}, keepCurrentStates ? this.textConfig : normalState.textConfig);
      extend(this.textConfig, state.textConfig);
    } else if (needsRestoreToNormal) {
      if (normalState.textConfig) {
        this.textConfig = normalState.textConfig;
      }
    }
    const transitionTarget = {};
    let hasTransition = false;
    for (let i = 0; i < PRIMARY_STATES_KEYS.length; i++) {
      const key = PRIMARY_STATES_KEYS[i];
      const propNeedsTransition = transition && DEFAULT_ANIMATABLE_MAP[key];
      if (state && state[key] != null) {
        if (propNeedsTransition) {
          hasTransition = true;
          transitionTarget[key] = state[key];
        } else {
          this[key] = state[key];
        }
      } else if (needsRestoreToNormal) {
        if (normalState[key] != null) {
          if (propNeedsTransition) {
            hasTransition = true;
            transitionTarget[key] = normalState[key];
          } else {
            this[key] = normalState[key];
          }
        }
      }
    }
    if (!transition) {
      for (let i = 0; i < this.animators.length; i++) {
        const animator = this.animators[i];
        const targetName = animator.targetName;
        if (!animator.getLoop()) {
          animator.__changeFinalValue(targetName ? (state || normalState)[targetName] : state || normalState);
        }
      }
    }
    if (hasTransition) {
      this._transitionState(stateName, transitionTarget, animationCfg);
    }
  }
  _attachComponent(componentEl) {
    if (componentEl.__zr && !componentEl.__hostTarget) {
      if (true) {
        throw new Error("Text element has been added to zrender.");
      }
      return;
    }
    if (componentEl === this) {
      if (true) {
        throw new Error("Recursive component attachment.");
      }
      return;
    }
    const zr = this.__zr;
    if (zr) {
      componentEl.addSelfToZr(zr);
    }
    componentEl.__zr = zr;
    componentEl.__hostTarget = this;
  }
  _detachComponent(componentEl) {
    if (componentEl.__zr) {
      componentEl.removeSelfFromZr(componentEl.__zr);
    }
    componentEl.__zr = null;
    componentEl.__hostTarget = null;
  }
  getClipPath() {
    return this._clipPath;
  }
  setClipPath(clipPath) {
    if (this._clipPath && this._clipPath !== clipPath) {
      this.removeClipPath();
    }
    this._attachComponent(clipPath);
    this._clipPath = clipPath;
    this.markRedraw();
  }
  removeClipPath() {
    const clipPath = this._clipPath;
    if (clipPath) {
      this._detachComponent(clipPath);
      this._clipPath = null;
      this.markRedraw();
    }
  }
  getTextContent() {
    return this._textContent;
  }
  setTextContent(textEl) {
    const previousTextContent = this._textContent;
    if (previousTextContent === textEl) {
      return;
    }
    if (previousTextContent && previousTextContent !== textEl) {
      this.removeTextContent();
    }
    if (true) {
      if (textEl.__zr && !textEl.__hostTarget) {
        throw new Error("Text element has been added to zrender.");
      }
    }
    textEl.innerTransformable = new Transformable_default();
    this._attachComponent(textEl);
    this._textContent = textEl;
    this.markRedraw();
  }
  setTextConfig(cfg) {
    if (!this.textConfig) {
      this.textConfig = {};
    }
    extend(this.textConfig, cfg);
    this.markRedraw();
  }
  removeTextConfig() {
    this.textConfig = null;
    this.markRedraw();
  }
  removeTextContent() {
    const textEl = this._textContent;
    if (textEl) {
      textEl.innerTransformable = null;
      this._detachComponent(textEl);
      this._textContent = null;
      this._innerTextDefaultStyle = null;
      this.markRedraw();
    }
  }
  getTextGuideLine() {
    return this._textGuide;
  }
  setTextGuideLine(guideLine) {
    if (this._textGuide && this._textGuide !== guideLine) {
      this.removeTextGuideLine();
    }
    this._attachComponent(guideLine);
    this._textGuide = guideLine;
    this.markRedraw();
  }
  removeTextGuideLine() {
    const textGuide = this._textGuide;
    if (textGuide) {
      this._detachComponent(textGuide);
      this._textGuide = null;
      this.markRedraw();
    }
  }
  markRedraw() {
    this.__dirty |= REDRAW_BIT;
    const zr = this.__zr;
    if (zr) {
      if (this.__inHover) {
        zr.refreshHover();
      } else {
        zr.refresh();
      }
    }
    if (this.__hostTarget) {
      this.__hostTarget.markRedraw();
    }
  }
  dirty() {
    this.markRedraw();
  }
  _toggleHoverLayerFlag(inHover) {
    this.__inHover = inHover;
    const textContent = this._textContent;
    const textGuide = this._textGuide;
    if (textContent) {
      textContent.__inHover = inHover;
    }
    if (textGuide) {
      textGuide.__inHover = inHover;
    }
  }
  addSelfToZr(zr) {
    if (this.__zr === zr) {
      return;
    }
    this.__zr = zr;
    const animators = this.animators;
    if (animators) {
      for (let i = 0; i < animators.length; i++) {
        zr.animation.addAnimator(animators[i]);
      }
    }
    if (this._clipPath) {
      this._clipPath.addSelfToZr(zr);
    }
    if (this._textContent) {
      this._textContent.addSelfToZr(zr);
    }
    if (this._textGuide) {
      this._textGuide.addSelfToZr(zr);
    }
  }
  removeSelfFromZr(zr) {
    if (!this.__zr) {
      return;
    }
    this.__zr = null;
    const animators = this.animators;
    if (animators) {
      for (let i = 0; i < animators.length; i++) {
        zr.animation.removeAnimator(animators[i]);
      }
    }
    if (this._clipPath) {
      this._clipPath.removeSelfFromZr(zr);
    }
    if (this._textContent) {
      this._textContent.removeSelfFromZr(zr);
    }
    if (this._textGuide) {
      this._textGuide.removeSelfFromZr(zr);
    }
  }
  animate(key, loop, allowDiscreteAnimation) {
    let target = key ? this[key] : this;
    if (true) {
      if (!target) {
        logError('Property "' + key + '" is not existed in element ' + this.id);
        return;
      }
    }
    const animator = new Animator_default(target, loop, allowDiscreteAnimation);
    key && (animator.targetName = key);
    this.addAnimator(animator, key);
    return animator;
  }
  addAnimator(animator, key) {
    const zr = this.__zr;
    const el = this;
    animator.during(function() {
      el.updateDuringAnimation(key);
    }).done(function() {
      const animators = el.animators;
      const idx = indexOf(animators, animator);
      if (idx >= 0) {
        animators.splice(idx, 1);
      }
    });
    this.animators.push(animator);
    if (zr) {
      zr.animation.addAnimator(animator);
    }
    zr && zr.wakeUp();
  }
  updateDuringAnimation(key) {
    this.markRedraw();
  }
  stopAnimation(scope, forwardToLast) {
    const animators = this.animators;
    const len2 = animators.length;
    const leftAnimators = [];
    for (let i = 0; i < len2; i++) {
      const animator = animators[i];
      if (!scope || scope === animator.scope) {
        animator.stop(forwardToLast);
      } else {
        leftAnimators.push(animator);
      }
    }
    this.animators = leftAnimators;
    return this;
  }
  animateTo(target, cfg, animationProps) {
    animateTo(this, target, cfg, animationProps);
  }
  animateFrom(target, cfg, animationProps) {
    animateTo(this, target, cfg, animationProps, true);
  }
  _transitionState(stateName, target, cfg, animationProps) {
    const animators = animateTo(this, target, cfg, animationProps);
    for (let i = 0; i < animators.length; i++) {
      animators[i].__fromStateTransition = stateName;
    }
  }
  getBoundingRect() {
    return null;
  }
  getPaintRect() {
    return null;
  }
};
var Element = Element2;
Element.initDefaultProps = function() {
  const elProto = Element2.prototype;
  elProto.type = "element";
  elProto.name = "";
  elProto.ignore = elProto.silent = elProto.ignoreHostSilent = elProto.isGroup = elProto.draggable = elProto.dragging = elProto.ignoreClip = elProto.__inHover = false;
  elProto.__dirty = REDRAW_BIT;
  const logs = {};
  function logDeprecatedError(key, xKey, yKey) {
    if (!logs[key + xKey + yKey]) {
      console.warn(`DEPRECATED: '${key}' has been deprecated. use '${xKey}', '${yKey}' instead`);
      logs[key + xKey + yKey] = true;
    }
  }
  function createLegacyProperty(key, privateKey, xKey, yKey) {
    Object.defineProperty(elProto, key, {
      get() {
        if (true) {
          logDeprecatedError(key, xKey, yKey);
        }
        if (!this[privateKey]) {
          const pos = this[privateKey] = [];
          enhanceArray(this, pos);
        }
        return this[privateKey];
      },
      set(pos) {
        if (true) {
          logDeprecatedError(key, xKey, yKey);
        }
        this[xKey] = pos[0];
        this[yKey] = pos[1];
        this[privateKey] = pos;
        enhanceArray(this, pos);
      }
    });
    function enhanceArray(self2, pos) {
      Object.defineProperty(pos, 0, {
        get() {
          return self2[xKey];
        },
        set(val) {
          self2[xKey] = val;
        }
      });
      Object.defineProperty(pos, 1, {
        get() {
          return self2[yKey];
        },
        set(val) {
          self2[yKey] = val;
        }
      });
    }
  }
  if (Object.defineProperty) {
    createLegacyProperty("position", "_legacyPos", "x", "y");
    createLegacyProperty("scale", "_legacyScale", "scaleX", "scaleY");
    createLegacyProperty("origin", "_legacyOrigin", "originX", "originY");
  }
}();
mixin(Element, Eventful_default);
mixin(Element, Transformable_default);
function animateTo(animatable, target, cfg, animationProps, reverse2) {
  cfg = cfg || {};
  const animators = [];
  animateToShallow(animatable, "", animatable, target, cfg, animationProps, animators, reverse2);
  let finishCount = animators.length;
  let doneHappened = false;
  const cfgDone = cfg.done;
  const cfgAborted = cfg.aborted;
  const doneCb = () => {
    doneHappened = true;
    finishCount--;
    if (finishCount <= 0) {
      doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();
    }
  };
  const abortedCb = () => {
    finishCount--;
    if (finishCount <= 0) {
      doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();
    }
  };
  if (!finishCount) {
    cfgDone && cfgDone();
  }
  if (animators.length > 0 && cfg.during) {
    animators[0].during((target2, percent) => {
      cfg.during(percent);
    });
  }
  for (let i = 0; i < animators.length; i++) {
    const animator = animators[i];
    if (doneCb) {
      animator.done(doneCb);
    }
    if (abortedCb) {
      animator.aborted(abortedCb);
    }
    if (cfg.force) {
      animator.duration(cfg.duration);
    }
    animator.start(cfg.easing);
  }
  return animators;
}
function copyArrShallow(source, target, len2) {
  for (let i = 0; i < len2; i++) {
    source[i] = target[i];
  }
}
function is2DArray(value) {
  return isArrayLike(value[0]);
}
function copyValue(target, source, key) {
  if (isArrayLike(source[key])) {
    if (!isArrayLike(target[key])) {
      target[key] = [];
    }
    if (isTypedArray(source[key])) {
      const len2 = source[key].length;
      if (target[key].length !== len2) {
        target[key] = new source[key].constructor(len2);
        copyArrShallow(target[key], source[key], len2);
      }
    } else {
      const sourceArr = source[key];
      const targetArr = target[key];
      const len0 = sourceArr.length;
      if (is2DArray(sourceArr)) {
        const len1 = sourceArr[0].length;
        for (let i = 0; i < len0; i++) {
          if (!targetArr[i]) {
            targetArr[i] = Array.prototype.slice.call(sourceArr[i]);
          } else {
            copyArrShallow(targetArr[i], sourceArr[i], len1);
          }
        }
      } else {
        copyArrShallow(targetArr, sourceArr, len0);
      }
      targetArr.length = sourceArr.length;
    }
  } else {
    target[key] = source[key];
  }
}
function isValueSame(val1, val2) {
  return val1 === val2 || isArrayLike(val1) && isArrayLike(val2) && is1DArraySame(val1, val2);
}
function is1DArraySame(arr0, arr1) {
  const len2 = arr0.length;
  if (len2 !== arr1.length) {
    return false;
  }
  for (let i = 0; i < len2; i++) {
    if (arr0[i] !== arr1[i]) {
      return false;
    }
  }
  return true;
}
function animateToShallow(animatable, topKey, animateObj, target, cfg, animationProps, animators, reverse2) {
  const targetKeys = keys(target);
  const duration = cfg.duration;
  const delay = cfg.delay;
  const additive = cfg.additive;
  const setToFinal = cfg.setToFinal;
  const animateAll = !isObject(animationProps);
  const existsAnimators = animatable.animators;
  let animationKeys = [];
  for (let k = 0; k < targetKeys.length; k++) {
    const innerKey = targetKeys[k];
    const targetVal = target[innerKey];
    if (targetVal != null && animateObj[innerKey] != null && (animateAll || animationProps[innerKey])) {
      if (isObject(targetVal) && !isArrayLike(targetVal) && !isGradientObject(targetVal)) {
        if (topKey) {
          if (!reverse2) {
            animateObj[innerKey] = targetVal;
            animatable.updateDuringAnimation(topKey);
          }
          continue;
        }
        animateToShallow(animatable, innerKey, animateObj[innerKey], targetVal, cfg, animationProps && animationProps[innerKey], animators, reverse2);
      } else {
        animationKeys.push(innerKey);
      }
    } else if (!reverse2) {
      animateObj[innerKey] = targetVal;
      animatable.updateDuringAnimation(topKey);
      animationKeys.push(innerKey);
    }
  }
  let keyLen = animationKeys.length;
  if (!additive && keyLen) {
    for (let i = 0; i < existsAnimators.length; i++) {
      const animator = existsAnimators[i];
      if (animator.targetName === topKey) {
        const allAborted = animator.stopTracks(animationKeys);
        if (allAborted) {
          const idx = indexOf(existsAnimators, animator);
          existsAnimators.splice(idx, 1);
        }
      }
    }
  }
  if (!cfg.force) {
    animationKeys = filter(animationKeys, (key) => !isValueSame(target[key], animateObj[key]));
    keyLen = animationKeys.length;
  }
  if (keyLen > 0 || cfg.force && !animators.length) {
    let revertedSource;
    let reversedTarget;
    let sourceClone;
    if (reverse2) {
      reversedTarget = {};
      if (setToFinal) {
        revertedSource = {};
      }
      for (let i = 0; i < keyLen; i++) {
        const innerKey = animationKeys[i];
        reversedTarget[innerKey] = animateObj[innerKey];
        if (setToFinal) {
          revertedSource[innerKey] = target[innerKey];
        } else {
          animateObj[innerKey] = target[innerKey];
        }
      }
    } else if (setToFinal) {
      sourceClone = {};
      for (let i = 0; i < keyLen; i++) {
        const innerKey = animationKeys[i];
        sourceClone[innerKey] = cloneValue(animateObj[innerKey]);
        copyValue(animateObj, target, innerKey);
      }
    }
    const animator = new Animator_default(animateObj, false, false, additive ? filter(existsAnimators, (animator2) => animator2.targetName === topKey) : null);
    animator.targetName = topKey;
    if (cfg.scope) {
      animator.scope = cfg.scope;
    }
    if (setToFinal && revertedSource) {
      animator.whenWithKeys(0, revertedSource, animationKeys);
    }
    if (sourceClone) {
      animator.whenWithKeys(0, sourceClone, animationKeys);
    }
    animator.whenWithKeys(duration == null ? 500 : duration, reverse2 ? reversedTarget : target, animationKeys).delay(delay || 0);
    animatable.addAnimator(animator, topKey);
    animators.push(animator);
  }
}
var Element_default = Element;

// ../zrender/src/graphic/Group.ts
var Group = class extends Element_default {
  constructor(opts) {
    super();
    this.isGroup = true;
    this._children = [];
    this.attr(opts);
  }
  childrenRef() {
    return this._children;
  }
  children() {
    return this._children.slice();
  }
  childAt(idx) {
    return this._children[idx];
  }
  childOfName(name) {
    const children = this._children;
    for (let i = 0; i < children.length; i++) {
      if (children[i].name === name) {
        return children[i];
      }
    }
  }
  childCount() {
    return this._children.length;
  }
  add(child) {
    if (child) {
      if (child !== this && child.parent !== this) {
        this._children.push(child);
        this._doAdd(child);
      }
      if (true) {
        if (child.__hostTarget) {
          throw "This elemenet has been used as an attachment";
        }
      }
    }
    return this;
  }
  addBefore(child, nextSibling2) {
    if (child && child !== this && child.parent !== this && nextSibling2 && nextSibling2.parent === this) {
      const children = this._children;
      const idx = children.indexOf(nextSibling2);
      if (idx >= 0) {
        children.splice(idx, 0, child);
        this._doAdd(child);
      }
    }
    return this;
  }
  replace(oldChild, newChild) {
    const idx = indexOf(this._children, oldChild);
    if (idx >= 0) {
      this.replaceAt(newChild, idx);
    }
    return this;
  }
  replaceAt(child, index) {
    const children = this._children;
    const old = children[index];
    if (child && child !== this && child.parent !== this && child !== old) {
      children[index] = child;
      old.parent = null;
      const zr = this.__zr;
      if (zr) {
        old.removeSelfFromZr(zr);
      }
      this._doAdd(child);
    }
    return this;
  }
  _doAdd(child) {
    if (child.parent) {
      child.parent.remove(child);
    }
    child.parent = this;
    const zr = this.__zr;
    if (zr && zr !== child.__zr) {
      child.addSelfToZr(zr);
    }
    zr && zr.refresh();
  }
  remove(child) {
    const zr = this.__zr;
    const children = this._children;
    const idx = indexOf(children, child);
    if (idx < 0) {
      return this;
    }
    children.splice(idx, 1);
    child.parent = null;
    if (zr) {
      child.removeSelfFromZr(zr);
    }
    zr && zr.refresh();
    return this;
  }
  removeAll() {
    const children = this._children;
    const zr = this.__zr;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (zr) {
        child.removeSelfFromZr(zr);
      }
      child.parent = null;
    }
    children.length = 0;
    return this;
  }
  eachChild(cb, context) {
    const children = this._children;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      cb.call(context, child, i);
    }
    return this;
  }
  traverse(cb, context) {
    for (let i = 0; i < this._children.length; i++) {
      const child = this._children[i];
      const stopped = cb.call(context, child);
      if (child.isGroup && !stopped) {
        child.traverse(cb, context);
      }
    }
    return this;
  }
  addSelfToZr(zr) {
    super.addSelfToZr(zr);
    for (let i = 0; i < this._children.length; i++) {
      const child = this._children[i];
      child.addSelfToZr(zr);
    }
  }
  removeSelfFromZr(zr) {
    super.removeSelfFromZr(zr);
    for (let i = 0; i < this._children.length; i++) {
      const child = this._children[i];
      child.removeSelfFromZr(zr);
    }
  }
  getBoundingRect(includeChildren) {
    const tmpRect3 = new BoundingRect_default(0, 0, 0, 0);
    const children = includeChildren || this._children;
    const tmpMat = [];
    let rect = null;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.ignore || child.invisible) {
        continue;
      }
      const childRect = child.getBoundingRect();
      const transform2 = child.getLocalTransform(tmpMat);
      if (transform2) {
        BoundingRect_default.applyTransform(tmpRect3, childRect, transform2);
        rect = rect || tmpRect3.clone();
        rect.union(tmpRect3);
      } else {
        rect = rect || childRect.clone();
        rect.union(childRect);
      }
    }
    return rect || tmpRect3;
  }
};
Group.prototype.type = "group";
var Group_default = Group;

// ../zrender/src/zrender.ts
/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var painterCtors = {};
var instances = {};
function delInstance(id) {
  delete instances[id];
}
function isDarkMode(backgroundColor2) {
  if (!backgroundColor2) {
    return false;
  }
  if (typeof backgroundColor2 === "string") {
    return lum(backgroundColor2, 1) < DARK_MODE_THRESHOLD;
  } else if (backgroundColor2.colorStops) {
    const colorStops = backgroundColor2.colorStops;
    let totalLum = 0;
    const len2 = colorStops.length;
    for (let i = 0; i < len2; i++) {
      totalLum += lum(colorStops[i].color, 1);
    }
    totalLum /= len2;
    return totalLum < DARK_MODE_THRESHOLD;
  }
  return false;
}
var ZRender = class {
  constructor(id, dom, opts) {
    this._sleepAfterStill = 10;
    this._stillFrameAccum = 0;
    this._needsRefresh = true;
    this._needsRefreshHover = true;
    this._darkMode = false;
    opts = opts || {};
    this.dom = dom;
    this.id = id;
    const storage2 = new Storage_default();
    let rendererType = opts.renderer || "canvas";
    if (!painterCtors[rendererType]) {
      rendererType = keys(painterCtors)[0];
    }
    if (true) {
      if (!painterCtors[rendererType]) {
        throw new Error(`Renderer '${rendererType}' is not imported. Please import it first.`);
      }
    }
    opts.useDirtyRect = opts.useDirtyRect == null ? false : opts.useDirtyRect;
    const painter = new painterCtors[rendererType](dom, storage2, opts, id);
    const ssrMode = opts.ssr || painter.ssrOnly;
    this.storage = storage2;
    this.painter = painter;
    const handlerProxy = !env_default.node && !env_default.worker && !ssrMode ? new HandlerProxy_default(painter.getViewportRoot(), painter.root) : null;
    const useCoarsePointer = opts.useCoarsePointer;
    const usePointerSize = useCoarsePointer == null || useCoarsePointer === "auto" ? env_default.touchEventsSupported : !!useCoarsePointer;
    const defaultPointerSize = 44;
    let pointerSize;
    if (usePointerSize) {
      pointerSize = retrieve2(opts.pointerSize, defaultPointerSize);
    }
    this.handler = new Handler_default(storage2, painter, handlerProxy, painter.root, pointerSize);
    this.animation = new Animation_default({
      stage: {
        update: ssrMode ? null : () => this._flush(true)
      }
    });
    if (!ssrMode) {
      this.animation.start();
    }
  }
  add(el) {
    if (this._disposed || !el) {
      return;
    }
    this.storage.addRoot(el);
    el.addSelfToZr(this);
    this.refresh();
  }
  remove(el) {
    if (this._disposed || !el) {
      return;
    }
    this.storage.delRoot(el);
    el.removeSelfFromZr(this);
    this.refresh();
  }
  configLayer(zLevel, config) {
    if (this._disposed) {
      return;
    }
    if (this.painter.configLayer) {
      this.painter.configLayer(zLevel, config);
    }
    this.refresh();
  }
  setBackgroundColor(backgroundColor2) {
    if (this._disposed) {
      return;
    }
    if (this.painter.setBackgroundColor) {
      this.painter.setBackgroundColor(backgroundColor2);
    }
    this.refresh();
    this._backgroundColor = backgroundColor2;
    this._darkMode = isDarkMode(backgroundColor2);
  }
  getBackgroundColor() {
    return this._backgroundColor;
  }
  setDarkMode(darkMode) {
    this._darkMode = darkMode;
  }
  isDarkMode() {
    return this._darkMode;
  }
  refreshImmediately(fromInside) {
    if (this._disposed) {
      return;
    }
    if (!fromInside) {
      this.animation.update(true);
    }
    this._needsRefresh = false;
    this.painter.refresh();
    this._needsRefresh = false;
  }
  refresh() {
    if (this._disposed) {
      return;
    }
    this._needsRefresh = true;
    this.animation.start();
  }
  flush() {
    if (this._disposed) {
      return;
    }
    this._flush(false);
  }
  _flush(fromInside) {
    let triggerRendered;
    const start2 = getTime();
    if (this._needsRefresh) {
      triggerRendered = true;
      this.refreshImmediately(fromInside);
    }
    if (this._needsRefreshHover) {
      triggerRendered = true;
      this.refreshHoverImmediately();
    }
    const end2 = getTime();
    if (triggerRendered) {
      this._stillFrameAccum = 0;
      this.trigger("rendered", {
        elapsedTime: end2 - start2
      });
    } else if (this._sleepAfterStill > 0) {
      this._stillFrameAccum++;
      if (this._stillFrameAccum > this._sleepAfterStill) {
        this.animation.stop();
      }
    }
  }
  setSleepAfterStill(stillFramesCount) {
    this._sleepAfterStill = stillFramesCount;
  }
  wakeUp() {
    if (this._disposed) {
      return;
    }
    this.animation.start();
    this._stillFrameAccum = 0;
  }
  refreshHover() {
    this._needsRefreshHover = true;
  }
  refreshHoverImmediately() {
    if (this._disposed) {
      return;
    }
    this._needsRefreshHover = false;
    if (this.painter.refreshHover && this.painter.getType() === "canvas") {
      this.painter.refreshHover();
    }
  }
  resize(opts) {
    if (this._disposed) {
      return;
    }
    opts = opts || {};
    this.painter.resize(opts.width, opts.height);
    this.handler.resize();
  }
  clearAnimation() {
    if (this._disposed) {
      return;
    }
    this.animation.clear();
  }
  getWidth() {
    if (this._disposed) {
      return;
    }
    return this.painter.getWidth();
  }
  getHeight() {
    if (this._disposed) {
      return;
    }
    return this.painter.getHeight();
  }
  setCursorStyle(cursorStyle) {
    if (this._disposed) {
      return;
    }
    this.handler.setCursorStyle(cursorStyle);
  }
  findHover(x, y) {
    if (this._disposed) {
      return;
    }
    return this.handler.findHover(x, y);
  }
  on(eventName, eventHandler, context) {
    if (!this._disposed) {
      this.handler.on(eventName, eventHandler, context);
    }
    return this;
  }
  off(eventName, eventHandler) {
    if (this._disposed) {
      return;
    }
    this.handler.off(eventName, eventHandler);
  }
  trigger(eventName, event) {
    if (this._disposed) {
      return;
    }
    this.handler.trigger(eventName, event);
  }
  clear() {
    if (this._disposed) {
      return;
    }
    const roots2 = this.storage.getRoots();
    for (let i = 0; i < roots2.length; i++) {
      if (roots2[i] instanceof Group_default) {
        roots2[i].removeSelfFromZr(this);
      }
    }
    this.storage.delAllRoots();
    this.painter.clear();
  }
  dispose() {
    if (this._disposed) {
      return;
    }
    this.animation.stop();
    this.clear();
    this.storage.dispose();
    this.painter.dispose();
    this.handler.dispose();
    this.animation = this.storage = this.painter = this.handler = null;
    this._disposed = true;
    delInstance(this.id);
  }
};
function init(dom, opts) {
  const zr = new ZRender(guid(), dom, opts);
  instances[zr.id] = zr;
  return zr;
}
function dispose(zr) {
  zr.dispose();
}
function disposeAll() {
  for (let key in instances) {
    if (instances.hasOwnProperty(key)) {
      instances[key].dispose();
    }
  }
  instances = {};
}
function getInstance(id) {
  return instances[id];
}
function registerPainter(name, Ctor) {
  painterCtors[name] = Ctor;
}
var ssrDataGetter;
function getElementSSRData(el) {
  if (typeof ssrDataGetter === "function") {
    return ssrDataGetter(el);
  }
}
function registerSSRDataGetter(getter) {
  ssrDataGetter = getter;
}
var version = "6.0.0-rc.1";

// src/util/number.ts
var RADIAN_EPSILON = 1e-4;
var ROUND_SUPPORTED_PRECISION_MAX = 20;
function _trim(str) {
  return str.replace(/^\s+|\s+$/g, "");
}
var mathMin2 = Math.min;
var mathMax2 = Math.max;
var mathAbs2 = Math.abs;
function linearMap(val, domain, range, clamp2) {
  const d0 = domain[0];
  const d1 = domain[1];
  const r0 = range[0];
  const r1 = range[1];
  const subDomain = d1 - d0;
  const subRange = r1 - r0;
  if (subDomain === 0) {
    return subRange === 0 ? r0 : (r0 + r1) / 2;
  }
  if (clamp2) {
    if (subDomain > 0) {
      if (val <= d0) {
        return r0;
      } else if (val >= d1) {
        return r1;
      }
    } else {
      if (val >= d0) {
        return r0;
      } else if (val <= d1) {
        return r1;
      }
    }
  } else {
    if (val === d0) {
      return r0;
    }
    if (val === d1) {
      return r1;
    }
  }
  return (val - d0) / subDomain * subRange + r0;
}
var parsePercent2 = parsePositionOption;
function parsePositionOption(option, percentBase, percentOffset) {
  switch (option) {
    case "center":
    case "middle":
      option = "50%";
      break;
    case "left":
    case "top":
      option = "0%";
      break;
    case "right":
    case "bottom":
      option = "100%";
      break;
  }
  return parsePositionSizeOption(option, percentBase, percentOffset);
}
function parsePositionSizeOption(option, percentBase, percentOffset) {
  if (isString(option)) {
    if (_trim(option).match(/%$/)) {
      return parseFloat(option) / 100 * percentBase + (percentOffset || 0);
    }
    return parseFloat(option);
  }
  return option == null ? NaN : +option;
}
function round(x, precision, returnStr) {
  if (precision == null) {
    precision = 10;
  }
  precision = Math.min(Math.max(0, precision), ROUND_SUPPORTED_PRECISION_MAX);
  x = (+x).toFixed(precision);
  return returnStr ? x : +x;
}
function asc(arr) {
  arr.sort(function(a, b) {
    return a - b;
  });
  return arr;
}
function getPrecision(val) {
  val = +val;
  if (isNaN(val)) {
    return 0;
  }
  if (val > 1e-14) {
    let e2 = 1;
    for (let i = 0; i < 15; i++, e2 *= 10) {
      if (Math.round(val * e2) / e2 === val) {
        return i;
      }
    }
  }
  return getPrecisionSafe(val);
}
function getPrecisionSafe(val) {
  const str = val.toString().toLowerCase();
  const eIndex = str.indexOf("e");
  const exp = eIndex > 0 ? +str.slice(eIndex + 1) : 0;
  const significandPartLen = eIndex > 0 ? eIndex : str.length;
  const dotIndex = str.indexOf(".");
  const decimalPartLen = dotIndex < 0 ? 0 : significandPartLen - 1 - dotIndex;
  return Math.max(0, decimalPartLen - exp);
}
function getPixelPrecision(dataExtent, pixelExtent) {
  const log2 = Math.log;
  const LN10 = Math.LN10;
  const dataQuantity = Math.floor(log2(dataExtent[1] - dataExtent[0]) / LN10);
  const sizeQuantity = Math.round(log2(mathAbs2(pixelExtent[1] - pixelExtent[0])) / LN10);
  const precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
  return !isFinite(precision) ? 20 : precision;
}
function getPercentWithPrecision(valueList, idx, precision) {
  if (!valueList[idx]) {
    return 0;
  }
  const seats = getPercentSeats(valueList, precision);
  return seats[idx] || 0;
}
function getPercentSeats(valueList, precision) {
  const sum2 = reduce(valueList, function(acc, val) {
    return acc + (isNaN(val) ? 0 : val);
  }, 0);
  if (sum2 === 0) {
    return [];
  }
  const digits = Math.pow(10, precision);
  const votesPerQuota = map(valueList, function(val) {
    return (isNaN(val) ? 0 : val) / sum2 * digits * 100;
  });
  const targetSeats = digits * 100;
  const seats = map(votesPerQuota, function(votes) {
    return Math.floor(votes);
  });
  let currentSum = reduce(seats, function(acc, val) {
    return acc + val;
  }, 0);
  const remainder = map(votesPerQuota, function(votes, idx) {
    return votes - seats[idx];
  });
  while (currentSum < targetSeats) {
    let max3 = Number.NEGATIVE_INFINITY;
    let maxId = null;
    for (let i = 0, len2 = remainder.length; i < len2; ++i) {
      if (remainder[i] > max3) {
        max3 = remainder[i];
        maxId = i;
      }
    }
    ++seats[maxId];
    remainder[maxId] = 0;
    ++currentSum;
  }
  return map(seats, function(seat) {
    return seat / digits;
  });
}
function addSafe(val0, val1) {
  const maxPrecision = Math.max(getPrecision(val0), getPrecision(val1));
  const sum2 = val0 + val1;
  return maxPrecision > ROUND_SUPPORTED_PRECISION_MAX ? sum2 : round(sum2, maxPrecision);
}
var MAX_SAFE_INTEGER = 9007199254740991;
function remRadian(radian) {
  const pi2 = Math.PI * 2;
  return (radian % pi2 + pi2) % pi2;
}
function isRadianAroundZero(val) {
  return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
}
var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function parseDate(value) {
  if (value instanceof Date) {
    return value;
  } else if (isString(value)) {
    const match = TIME_REG.exec(value);
    if (!match) {
      return new Date(NaN);
    }
    if (!match[8]) {
      return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0);
    } else {
      let hour = +match[4] || 0;
      if (match[8].toUpperCase() !== "Z") {
        hour -= +match[8].slice(0, 3);
      }
      return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0));
    }
  } else if (value == null) {
    return new Date(NaN);
  }
  return new Date(Math.round(value));
}
function quantity(val) {
  return Math.pow(10, quantityExponent(val));
}
function quantityExponent(val) {
  if (val === 0) {
    return 0;
  }
  let exp = Math.floor(Math.log(val) / Math.LN10);
  if (val / Math.pow(10, exp) >= 10) {
    exp++;
  }
  return exp;
}
function nice(val, round8) {
  const exponent = quantityExponent(val);
  const exp10 = Math.pow(10, exponent);
  const f = val / exp10;
  let nf;
  if (round8) {
    if (f < 1.5) {
      nf = 1;
    } else if (f < 2.5) {
      nf = 2;
    } else if (f < 4) {
      nf = 3;
    } else if (f < 7) {
      nf = 5;
    } else {
      nf = 10;
    }
  } else {
    if (f < 1) {
      nf = 1;
    } else if (f < 2) {
      nf = 2;
    } else if (f < 3) {
      nf = 3;
    } else if (f < 5) {
      nf = 5;
    } else {
      nf = 10;
    }
  }
  val = nf * exp10;
  return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
}
function quantile(ascArr, p) {
  const H = (ascArr.length - 1) * p + 1;
  const h = Math.floor(H);
  const v = +ascArr[h - 1];
  const e2 = H - h;
  return e2 ? v + e2 * (ascArr[h] - v) : v;
}
function reformIntervals(list) {
  list.sort(function(a, b) {
    return littleThan2(a, b, 0) ? -1 : 1;
  });
  let curr = -Infinity;
  let currClose = 1;
  for (let i = 0; i < list.length; ) {
    const interval = list[i].interval;
    const close = list[i].close;
    for (let lg = 0; lg < 2; lg++) {
      if (interval[lg] <= curr) {
        interval[lg] = curr;
        close[lg] = !lg ? 1 - currClose : 1;
      }
      curr = interval[lg];
      currClose = close[lg];
    }
    if (interval[0] === interval[1] && close[0] * close[1] !== 1) {
      list.splice(i, 1);
    } else {
      i++;
    }
  }
  return list;
  function littleThan2(a, b, lg) {
    return a.interval[lg] < b.interval[lg] || a.interval[lg] === b.interval[lg] && (a.close[lg] - b.close[lg] === (!lg ? 1 : -1) || !lg && littleThan2(a, b, 1));
  }
}
function numericToNumber(val) {
  const valFloat = parseFloat(val);
  return valFloat == val && (valFloat !== 0 || !isString(val) || val.indexOf("x") <= 0) ? valFloat : NaN;
}
function isNumeric(val) {
  return !isNaN(numericToNumber(val));
}
function getRandomIdBase() {
  return Math.round(Math.random() * 9);
}
function getGreatestCommonDividor(a, b) {
  if (b === 0) {
    return a;
  }
  return getGreatestCommonDividor(b, a % b);
}
function getLeastCommonMultiple(a, b) {
  if (a == null) {
    return b;
  }
  if (b == null) {
    return a;
  }
  return a * b / getGreatestCommonDividor(a, b);
}

// src/util/log.ts
var ECHARTS_PREFIX = "[ECharts] ";
var storedLogs = {};
var hasConsole = typeof console !== "undefined" && console.warn && console.log;
function outputLog(type, str, onlyOnce) {
  if (hasConsole) {
    if (onlyOnce) {
      if (storedLogs[str]) {
        return;
      }
      storedLogs[str] = true;
    }
    console[type](ECHARTS_PREFIX + str);
  }
}
function log(str, onlyOnce) {
  outputLog("log", str, onlyOnce);
}
function warn(str, onlyOnce) {
  outputLog("warn", str, onlyOnce);
}
function error(str, onlyOnce) {
  outputLog("error", str, onlyOnce);
}
function deprecateLog(str) {
  if (true) {
    outputLog("warn", "DEPRECATED: " + str, true);
  }
}
function deprecateReplaceLog(oldOpt, newOpt, scope) {
  if (true) {
    deprecateLog((scope ? `[${scope}]` : "") + `${oldOpt} is deprecated; use ${newOpt} instead.`);
  }
}
function makePrintable(...hintInfo) {
  let msg = "";
  if (true) {
    const makePrintableStringIfPossible = (val) => {
      return val === void 0 ? "undefined" : val === Infinity ? "Infinity" : val === -Infinity ? "-Infinity" : eqNaN(val) ? "NaN" : val instanceof Date ? "Date(" + val.toISOString() + ")" : isFunction(val) ? "function () { ... }" : isRegExp(val) ? val + "" : null;
    };
    msg = map(hintInfo, (arg) => {
      if (isString(arg)) {
        return arg;
      } else {
        const printableStr = makePrintableStringIfPossible(arg);
        if (printableStr != null) {
          return printableStr;
        } else if (typeof JSON !== "undefined" && JSON.stringify) {
          try {
            return JSON.stringify(arg, function(n, val) {
              const printableStr2 = makePrintableStringIfPossible(val);
              return printableStr2 == null ? val : printableStr2;
            });
          } catch (err) {
            return "?";
          }
        } else {
          return "?";
        }
      }
    }).join(" ");
  }
  return msg;
}
function throwError(msg) {
  throw new Error(msg);
}

// src/util/model.ts
function interpolateNumber2(p0, p1, percent) {
  return (p1 - p0) * percent + p0;
}
var DUMMY_COMPONENT_NAME_PREFIX = "series\0";
var INTERNAL_COMPONENT_ID_PREFIX = "\0_ec_\0";
function normalizeToArray(value) {
  return value instanceof Array ? value : value == null ? [] : [value];
}
function defaultEmphasis(opt, key, subOpts) {
  if (opt) {
    opt[key] = opt[key] || {};
    opt.emphasis = opt.emphasis || {};
    opt.emphasis[key] = opt.emphasis[key] || {};
    for (let i = 0, len2 = subOpts.length; i < len2; i++) {
      const subOptName = subOpts[i];
      if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {
        opt.emphasis[key][subOptName] = opt[key][subOptName];
      }
    }
  }
}
var TEXT_STYLE_OPTIONS = [
  "fontStyle",
  "fontWeight",
  "fontSize",
  "fontFamily",
  "rich",
  "tag",
  "color",
  "textBorderColor",
  "textBorderWidth",
  "width",
  "height",
  "lineHeight",
  "align",
  "verticalAlign",
  "baseline",
  "shadowColor",
  "shadowBlur",
  "shadowOffsetX",
  "shadowOffsetY",
  "textShadowColor",
  "textShadowBlur",
  "textShadowOffsetX",
  "textShadowOffsetY",
  "backgroundColor",
  "borderColor",
  "borderWidth",
  "borderRadius",
  "padding"
];
function getDataItemValue(dataItem) {
  return isObject(dataItem) && !isArray(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;
}
function isDataItemOption(dataItem) {
  return isObject(dataItem) && !(dataItem instanceof Array);
}
function mappingToExists(existings, newCmptOptions, mode) {
  const isNormalMergeMode = mode === "normalMerge";
  const isReplaceMergeMode = mode === "replaceMerge";
  const isReplaceAllMode = mode === "replaceAll";
  existings = existings || [];
  newCmptOptions = (newCmptOptions || []).slice();
  const existingIdIdxMap = createHashMap();
  each(newCmptOptions, function(cmptOption, index) {
    if (!isObject(cmptOption)) {
      newCmptOptions[index] = null;
      return;
    }
    if (true) {
      if (cmptOption.id != null && !isValidIdOrName(cmptOption.id)) {
        warnInvalidateIdOrName(cmptOption.id);
      }
      if (cmptOption.name != null && !isValidIdOrName(cmptOption.name)) {
        warnInvalidateIdOrName(cmptOption.name);
      }
    }
  });
  const result = prepareResult(existings, existingIdIdxMap, mode);
  if (isNormalMergeMode || isReplaceMergeMode) {
    mappingById(result, existings, existingIdIdxMap, newCmptOptions);
  }
  if (isNormalMergeMode) {
    mappingByName(result, newCmptOptions);
  }
  if (isNormalMergeMode || isReplaceMergeMode) {
    mappingByIndex(result, newCmptOptions, isReplaceMergeMode);
  } else if (isReplaceAllMode) {
    mappingInReplaceAllMode(result, newCmptOptions);
  }
  makeIdAndName(result);
  return result;
}
function prepareResult(existings, existingIdIdxMap, mode) {
  const result = [];
  if (mode === "replaceAll") {
    return result;
  }
  for (let index = 0; index < existings.length; index++) {
    const existing = existings[index];
    if (existing && existing.id != null) {
      existingIdIdxMap.set(existing.id, index);
    }
    result.push({
      existing: mode === "replaceMerge" || isComponentIdInternal(existing) ? null : existing,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return result;
}
function mappingById(result, existings, existingIdIdxMap, newCmptOptions) {
  each(newCmptOptions, function(cmptOption, index) {
    if (!cmptOption || cmptOption.id == null) {
      return;
    }
    const optionId = makeComparableKey(cmptOption.id);
    const existingIdx = existingIdIdxMap.get(optionId);
    if (existingIdx != null) {
      const resultItem = result[existingIdx];
      assert(!resultItem.newOption, 'Duplicated option on id "' + optionId + '".');
      resultItem.newOption = cmptOption;
      resultItem.existing = existings[existingIdx];
      newCmptOptions[index] = null;
    }
  });
}
function mappingByName(result, newCmptOptions) {
  each(newCmptOptions, function(cmptOption, index) {
    if (!cmptOption || cmptOption.name == null) {
      return;
    }
    for (let i = 0; i < result.length; i++) {
      const existing = result[i].existing;
      if (!result[i].newOption && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual("name", existing, cmptOption)) {
        result[i].newOption = cmptOption;
        newCmptOptions[index] = null;
        return;
      }
    }
  });
}
function mappingByIndex(result, newCmptOptions, brandNew) {
  each(newCmptOptions, function(cmptOption) {
    if (!cmptOption) {
      return;
    }
    let resultItem;
    let nextIdx = 0;
    while ((resultItem = result[nextIdx]) && (resultItem.newOption || isComponentIdInternal(resultItem.existing) || resultItem.existing && cmptOption.id != null && !keyExistAndEqual("id", cmptOption, resultItem.existing))) {
      nextIdx++;
    }
    if (resultItem) {
      resultItem.newOption = cmptOption;
      resultItem.brandNew = brandNew;
    } else {
      result.push({
        newOption: cmptOption,
        brandNew,
        existing: null,
        keyInfo: null
      });
    }
    nextIdx++;
  });
}
function mappingInReplaceAllMode(result, newCmptOptions) {
  each(newCmptOptions, function(cmptOption) {
    result.push({
      newOption: cmptOption,
      brandNew: true,
      existing: null,
      keyInfo: null
    });
  });
}
function makeIdAndName(mapResult) {
  const idMap = createHashMap();
  each(mapResult, function(item) {
    const existing = item.existing;
    existing && idMap.set(existing.id, item);
  });
  each(mapResult, function(item) {
    const opt = item.newOption;
    assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, "id duplicates: " + (opt && opt.id));
    opt && opt.id != null && idMap.set(opt.id, item);
    !item.keyInfo && (item.keyInfo = {});
  });
  each(mapResult, function(item, index) {
    const existing = item.existing;
    const opt = item.newOption;
    const keyInfo = item.keyInfo;
    if (!isObject(opt)) {
      return;
    }
    keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name : DUMMY_COMPONENT_NAME_PREFIX + index;
    if (existing) {
      keyInfo.id = makeComparableKey(existing.id);
    } else if (opt.id != null) {
      keyInfo.id = makeComparableKey(opt.id);
    } else {
      let idNum = 0;
      do {
        keyInfo.id = "\0" + keyInfo.name + "\0" + idNum++;
      } while (idMap.get(keyInfo.id));
    }
    idMap.set(keyInfo.id, item);
  });
}
function keyExistAndEqual(attr, obj1, obj2) {
  const key1 = convertOptionIdName(obj1[attr], null);
  const key2 = convertOptionIdName(obj2[attr], null);
  return key1 != null && key2 != null && key1 === key2;
}
function makeComparableKey(val) {
  if (true) {
    if (val == null) {
      throw new Error();
    }
  }
  return convertOptionIdName(val, "");
}
function convertOptionIdName(idOrName, defaultValue) {
  if (idOrName == null) {
    return defaultValue;
  }
  return isString(idOrName) ? idOrName : isNumber(idOrName) || isStringSafe(idOrName) ? idOrName + "" : defaultValue;
}
function warnInvalidateIdOrName(idOrName) {
  if (true) {
    warn("`" + idOrName + "` is invalid id or name. Must be a string or number.");
  }
}
function isValidIdOrName(idOrName) {
  return isStringSafe(idOrName) || isNumeric(idOrName);
}
function isNameSpecified(componentModel) {
  const name = componentModel.name;
  return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
}
function isComponentIdInternal(cmptOption) {
  return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;
}
function makeInternalComponentId(idSuffix) {
  return INTERNAL_COMPONENT_ID_PREFIX + idSuffix;
}
function setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {
  each(mappingResult, function(item) {
    const newOption = item.newOption;
    if (isObject(newOption)) {
      item.keyInfo.mainType = mainType;
      item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);
    }
  });
}
function determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {
  const subType = newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType : componentModelCtor.determineSubType(mainType, newCmptOption);
  return subType;
}
function compressBatches(batchA, batchB) {
  const mapA = {};
  const mapB = {};
  makeMap(batchA || [], mapA);
  makeMap(batchB || [], mapB, mapA);
  return [mapToArray(mapA), mapToArray(mapB)];
  function makeMap(sourceBatch, map3, otherMap) {
    for (let i = 0, len2 = sourceBatch.length; i < len2; i++) {
      const seriesId = convertOptionIdName(sourceBatch[i].seriesId, null);
      if (seriesId == null) {
        return;
      }
      const dataIndices = normalizeToArray(sourceBatch[i].dataIndex);
      const otherDataIndices = otherMap && otherMap[seriesId];
      for (let j = 0, lenj = dataIndices.length; j < lenj; j++) {
        const dataIndex = dataIndices[j];
        if (otherDataIndices && otherDataIndices[dataIndex]) {
          otherDataIndices[dataIndex] = null;
        } else {
          (map3[seriesId] || (map3[seriesId] = {}))[dataIndex] = 1;
        }
      }
    }
  }
  function mapToArray(map3, isData) {
    const result = [];
    for (const i in map3) {
      if (map3.hasOwnProperty(i) && map3[i] != null) {
        if (isData) {
          result.push(+i);
        } else {
          const dataIndices = mapToArray(map3[i], true);
          dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});
        }
      }
    }
    return result;
  }
}
function queryDataIndex(data, payload) {
  if (payload.dataIndexInside != null) {
    return payload.dataIndexInside;
  } else if (payload.dataIndex != null) {
    return isArray(payload.dataIndex) ? map(payload.dataIndex, function(value) {
      return data.indexOfRawIndex(value);
    }) : data.indexOfRawIndex(payload.dataIndex);
  } else if (payload.name != null) {
    return isArray(payload.name) ? map(payload.name, function(value) {
      return data.indexOfName(value);
    }) : data.indexOfName(payload.name);
  }
}
function makeInner() {
  const key = "__ec_inner_" + innerUniqueIndex++;
  return function(hostObj) {
    return hostObj[key] || (hostObj[key] = {});
  };
}
var innerUniqueIndex = getRandomIdBase();
function parseFinder(ecModel, finderInput, opt) {
  const {mainTypeSpecified, queryOptionMap, others} = preParseFinder(finderInput, opt);
  const result = others;
  const defaultMainType = opt ? opt.defaultMainType : null;
  if (!mainTypeSpecified && defaultMainType) {
    queryOptionMap.set(defaultMainType, {});
  }
  queryOptionMap.each(function(queryOption, mainType) {
    const queryResult = queryReferringComponents(ecModel, mainType, queryOption, {
      useDefault: defaultMainType === mainType,
      enableAll: opt && opt.enableAll != null ? opt.enableAll : true,
      enableNone: opt && opt.enableNone != null ? opt.enableNone : true
    });
    result[mainType + "Models"] = queryResult.models;
    result[mainType + "Model"] = queryResult.models[0];
  });
  return result;
}
function preParseFinder(finderInput, opt) {
  let finder;
  if (isString(finderInput)) {
    const obj = {};
    obj[finderInput + "Index"] = 0;
    finder = obj;
  } else {
    finder = finderInput;
  }
  const queryOptionMap = createHashMap();
  const others = {};
  let mainTypeSpecified = false;
  each(finder, function(value, key) {
    if (key === "dataIndex" || key === "dataIndexInside") {
      others[key] = value;
      return;
    }
    const parsedKey = key.match(/^(\w+)(Index|Id|Name)$/) || [];
    const mainType = parsedKey[1];
    const queryType = (parsedKey[2] || "").toLowerCase();
    if (!mainType || !queryType || opt && opt.includeMainTypes && indexOf(opt.includeMainTypes, mainType) < 0) {
      return;
    }
    mainTypeSpecified = mainTypeSpecified || !!mainType;
    const queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});
    queryOption[queryType] = value;
  });
  return {mainTypeSpecified, queryOptionMap, others};
}
var SINGLE_REFERRING = {useDefault: true, enableAll: false, enableNone: false};
var MULTIPLE_REFERRING = {useDefault: false, enableAll: true, enableNone: true};
function queryReferringComponents(ecModel, mainType, userOption, opt) {
  opt = opt || SINGLE_REFERRING;
  let indexOption = userOption.index;
  let idOption = userOption.id;
  let nameOption = userOption.name;
  const result = {
    models: null,
    specified: indexOption != null || idOption != null || nameOption != null
  };
  if (!result.specified) {
    let firstCmpt;
    result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];
    return result;
  }
  if (indexOption === "none" || indexOption === false) {
    if (opt.enableNone) {
      result.models = [];
      return result;
    } else {
      if (true) {
        error('`"none"` or `false` is not a valid value on index option.');
      }
      indexOption = -1;
    }
  }
  if (indexOption === "all") {
    if (opt.enableAll) {
      indexOption = idOption = nameOption = null;
    } else {
      if (true) {
        error('`"all"` is not a valid value on index option.');
      }
      indexOption = -1;
    }
  }
  result.models = ecModel.queryComponents({
    mainType,
    index: indexOption,
    id: idOption,
    name: nameOption
  });
  return result;
}
function setAttribute(dom, key, value) {
  dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;
}
function getAttribute(dom, key) {
  return dom.getAttribute ? dom.getAttribute(key) : dom[key];
}
function getTooltipRenderMode(renderModeOption) {
  if (renderModeOption === "auto") {
    return env_default.domSupported ? "html" : "richText";
  } else {
    return renderModeOption || "html";
  }
}
function groupData(array, getKey2) {
  const buckets = createHashMap();
  const keys2 = [];
  each(array, function(item) {
    const key = getKey2(item);
    (buckets.get(key) || (keys2.push(key), buckets.set(key, []))).push(item);
  });
  return {
    keys: keys2,
    buckets
  };
}
function interpolateRawValues(data, precision, sourceValue, targetValue, percent) {
  const isAutoPrecision = precision == null || precision === "auto";
  if (targetValue == null) {
    return targetValue;
  }
  if (isNumber(targetValue)) {
    const value = interpolateNumber2(sourceValue || 0, targetValue, percent);
    return round(value, isAutoPrecision ? Math.max(getPrecision(sourceValue || 0), getPrecision(targetValue)) : precision);
  } else if (isString(targetValue)) {
    return percent < 1 ? sourceValue : targetValue;
  } else {
    const interpolated = [];
    const leftArr = sourceValue;
    const rightArr = targetValue;
    const length2 = Math.max(leftArr ? leftArr.length : 0, rightArr.length);
    for (let i = 0; i < length2; ++i) {
      const info = data.getDimensionInfo(i);
      if (info && info.type === "ordinal") {
        interpolated[i] = (percent < 1 && leftArr ? leftArr : rightArr)[i];
      } else {
        const leftVal = leftArr && leftArr[i] ? leftArr[i] : 0;
        const rightVal = rightArr[i];
        const value = interpolateNumber2(leftVal, rightVal, percent);
        interpolated[i] = round(value, isAutoPrecision ? Math.max(getPrecision(leftVal), getPrecision(rightVal)) : precision);
      }
    }
    return interpolated;
  }
}
var ListIterator = class {
  reset(list, start2, end2, step) {
    this._list = list;
    this._step = step = step || 1;
    this._idx = start2;
    this._end = end2 != null ? end2 : step > 0 ? list.length : 0;
    this.item = null;
    this.key = NaN;
    return this;
  }
  next() {
    if (this._step > 0 ? this._idx < this._end : this._idx >= this._end) {
      this.item = this._list[this._idx];
      this.key = this._idx = this._idx + this._step;
      return true;
    }
    return false;
  }
};

// src/util/clazz.ts
var TYPE_DELIMITER = ".";
var IS_CONTAINER = "___EC__COMPONENT__CONTAINER___";
var IS_EXTENDED_CLASS = "___EC__EXTENDED_CLASS___";
function parseClassType(componentType) {
  const ret = {main: "", sub: ""};
  if (componentType) {
    const typeArr = componentType.split(TYPE_DELIMITER);
    ret.main = typeArr[0] || "";
    ret.sub = typeArr[1] || "";
  }
  return ret;
}
function checkClassType(componentType) {
  assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal');
}
function isExtendedClass(clz) {
  return !!(clz && clz[IS_EXTENDED_CLASS]);
}
function enableClassExtend(rootClz, mandatoryMethods) {
  rootClz.$constructor = rootClz;
  rootClz.extend = function(proto) {
    if (true) {
      each(mandatoryMethods, function(method) {
        if (!proto[method]) {
          console.warn("Method `" + method + "` should be implemented" + (proto.type ? " in " + proto.type : "") + ".");
        }
      });
    }
    const superClass = this;
    let ExtendedClass;
    if (isESClass(superClass)) {
      ExtendedClass = class extends superClass {
        constructor() {
          super(...arguments);
        }
      };
    } else {
      ExtendedClass = function() {
        (proto.$constructor || superClass).apply(this, arguments);
      };
      inherits(ExtendedClass, this);
    }
    extend(ExtendedClass.prototype, proto);
    ExtendedClass[IS_EXTENDED_CLASS] = true;
    ExtendedClass.extend = this.extend;
    ExtendedClass.superCall = superCall;
    ExtendedClass.superApply = superApply;
    ExtendedClass.superClass = superClass;
    return ExtendedClass;
  };
}
function isESClass(fn) {
  return isFunction(fn) && /^class\s/.test(Function.prototype.toString.call(fn));
}
function mountExtend(SubClz, SupperClz) {
  SubClz.extend = SupperClz.extend;
}
var classBase = Math.round(Math.random() * 10);
function enableClassCheck(target) {
  const classAttr = ["__\0is_clz", classBase++].join("_");
  target.prototype[classAttr] = true;
  if (true) {
    assert(!target.isInstance, 'The method "is" can not be defined.');
  }
  target.isInstance = function(obj) {
    return !!(obj && obj[classAttr]);
  };
}
function superCall(context, methodName, ...args) {
  return this.superClass.prototype[methodName].apply(context, args);
}
function superApply(context, methodName, args) {
  return this.superClass.prototype[methodName].apply(context, args);
}
function enableClassManagement(target) {
  const storage2 = {};
  target.registerClass = function(clz) {
    const componentFullType = clz.type || clz.prototype.type;
    if (componentFullType) {
      checkClassType(componentFullType);
      clz.prototype.type = componentFullType;
      const componentTypeInfo = parseClassType(componentFullType);
      if (!componentTypeInfo.sub) {
        if (true) {
          if (storage2[componentTypeInfo.main]) {
            console.warn(componentTypeInfo.main + " exists.");
          }
        }
        storage2[componentTypeInfo.main] = clz;
      } else if (componentTypeInfo.sub !== IS_CONTAINER) {
        const container = makeContainer(componentTypeInfo);
        container[componentTypeInfo.sub] = clz;
      }
    }
    return clz;
  };
  target.getClass = function(mainType, subType, throwWhenNotFound) {
    let clz = storage2[mainType];
    if (clz && clz[IS_CONTAINER]) {
      clz = subType ? clz[subType] : null;
    }
    if (throwWhenNotFound && !clz) {
      throw new Error(!subType ? mainType + ".type should be specified." : "Component " + mainType + "." + (subType || "") + " is used but not imported.");
    }
    return clz;
  };
  target.getClassesByMainType = function(componentType) {
    const componentTypeInfo = parseClassType(componentType);
    const result = [];
    const obj = storage2[componentTypeInfo.main];
    if (obj && obj[IS_CONTAINER]) {
      each(obj, function(o, type) {
        type !== IS_CONTAINER && result.push(o);
      });
    } else {
      result.push(obj);
    }
    return result;
  };
  target.hasClass = function(componentType) {
    const componentTypeInfo = parseClassType(componentType);
    return !!storage2[componentTypeInfo.main];
  };
  target.getAllClassMainTypes = function() {
    const types = [];
    each(storage2, function(obj, type) {
      types.push(type);
    });
    return types;
  };
  target.hasSubTypes = function(componentType) {
    const componentTypeInfo = parseClassType(componentType);
    const obj = storage2[componentTypeInfo.main];
    return obj && obj[IS_CONTAINER];
  };
  function makeContainer(componentTypeInfo) {
    let container = storage2[componentTypeInfo.main];
    if (!container || !container[IS_CONTAINER]) {
      container = storage2[componentTypeInfo.main] = {};
      container[IS_CONTAINER] = true;
    }
    return container;
  }
}

// src/model/mixin/makeStyleMapper.ts
function makeStyleMapper(properties, ignoreParent) {
  for (let i = 0; i < properties.length; i++) {
    if (!properties[i][1]) {
      properties[i][1] = properties[i][0];
    }
  }
  ignoreParent = ignoreParent || false;
  return function(model, excludes, includes) {
    const style = {};
    for (let i = 0; i < properties.length; i++) {
      const propName = properties[i][1];
      if (excludes && indexOf(excludes, propName) >= 0 || includes && indexOf(includes, propName) < 0) {
        continue;
      }
      const val = model.getShallow(propName, ignoreParent);
      if (val != null) {
        style[properties[i][0]] = val;
      }
    }
    return style;
  };
}

// src/model/mixin/areaStyle.ts
var AREA_STYLE_KEY_MAP = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
];
var getAreaStyle = makeStyleMapper(AREA_STYLE_KEY_MAP);
var AreaStyleMixin = class {
  getAreaStyle(excludes, includes) {
    return getAreaStyle(this, excludes, includes);
  }
};

// ../zrender/src/graphic/helper/image.ts
var globalImageCache = new LRU_default(50);
function findExistImage(newImageOrSrc) {
  if (typeof newImageOrSrc === "string") {
    const cachedImgObj = globalImageCache.get(newImageOrSrc);
    return cachedImgObj && cachedImgObj.image;
  } else {
    return newImageOrSrc;
  }
}
function createOrUpdateImage(newImageOrSrc, image, hostEl, onload, cbPayload) {
  if (!newImageOrSrc) {
    return image;
  } else if (typeof newImageOrSrc === "string") {
    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
      return image;
    }
    const cachedImgObj = globalImageCache.get(newImageOrSrc);
    const pendingWrap = {hostEl, cb: onload, cbPayload};
    if (cachedImgObj) {
      image = cachedImgObj.image;
      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
    } else {
      image = platformApi.loadImage(newImageOrSrc, imageOnLoad, imageOnLoad);
      image.__zrImageSrc = newImageOrSrc;
      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
        image,
        pending: [pendingWrap]
      });
    }
    return image;
  } else {
    return newImageOrSrc;
  }
}
function imageOnLoad() {
  const cachedImgObj = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (let i = 0; i < cachedImgObj.pending.length; i++) {
    const pendingWrap = cachedImgObj.pending[i];
    const cb = pendingWrap.cb;
    cb && cb(this, pendingWrap.cbPayload);
    pendingWrap.hostEl.dirty();
  }
  cachedImgObj.pending.length = 0;
}
function isImageReady(image) {
  return image && image.width && image.height;
}

// ../zrender/src/graphic/helper/parseText.ts
var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function truncateText(text, containerWidth, font, ellipsis, options) {
  const out2 = {};
  truncateText2(out2, text, containerWidth, font, ellipsis, options);
  return out2.text;
}
function truncateText2(out2, text, containerWidth, font, ellipsis, options) {
  if (!containerWidth) {
    out2.text = "";
    out2.isTruncated = false;
    return;
  }
  const textLines = (text + "").split("\n");
  options = prepareTruncateOptions(containerWidth, font, ellipsis, options);
  let isTruncated = false;
  const truncateOut = {};
  for (let i = 0, len2 = textLines.length; i < len2; i++) {
    truncateSingleLine(truncateOut, textLines[i], options);
    textLines[i] = truncateOut.textLine;
    isTruncated = isTruncated || truncateOut.isTruncated;
  }
  out2.text = textLines.join("\n");
  out2.isTruncated = isTruncated;
}
function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
  options = options || {};
  let preparedOpts = extend({}, options);
  ellipsis = retrieve2(ellipsis, "...");
  preparedOpts.maxIterations = retrieve2(options.maxIterations, 2);
  const minChar = preparedOpts.minChar = retrieve2(options.minChar, 0);
  const fontMeasureInfo = preparedOpts.fontMeasureInfo = ensureFontMeasureInfo(font);
  const ascCharWidth = fontMeasureInfo.asciiCharWidth;
  preparedOpts.placeholder = retrieve2(options.placeholder, "");
  let contentWidth = containerWidth = Math.max(0, containerWidth - 1);
  for (let i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
    contentWidth -= ascCharWidth;
  }
  let ellipsisWidth = measureWidth(fontMeasureInfo, ellipsis);
  if (ellipsisWidth > contentWidth) {
    ellipsis = "";
    ellipsisWidth = 0;
  }
  contentWidth = containerWidth - ellipsisWidth;
  preparedOpts.ellipsis = ellipsis;
  preparedOpts.ellipsisWidth = ellipsisWidth;
  preparedOpts.contentWidth = contentWidth;
  preparedOpts.containerWidth = containerWidth;
  return preparedOpts;
}
function truncateSingleLine(out2, textLine, options) {
  const containerWidth = options.containerWidth;
  const contentWidth = options.contentWidth;
  const fontMeasureInfo = options.fontMeasureInfo;
  if (!containerWidth) {
    out2.textLine = "";
    out2.isTruncated = false;
    return;
  }
  let lineWidth = measureWidth(fontMeasureInfo, textLine);
  if (lineWidth <= containerWidth) {
    out2.textLine = textLine;
    out2.isTruncated = false;
    return;
  }
  for (let j = 0; ; j++) {
    if (lineWidth <= contentWidth || j >= options.maxIterations) {
      textLine += options.ellipsis;
      break;
    }
    const subLength = j === 0 ? estimateLength(textLine, contentWidth, fontMeasureInfo) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
    textLine = textLine.substr(0, subLength);
    lineWidth = measureWidth(fontMeasureInfo, textLine);
  }
  if (textLine === "") {
    textLine = options.placeholder;
  }
  out2.textLine = textLine;
  out2.isTruncated = true;
}
function estimateLength(text, contentWidth, fontMeasureInfo) {
  let width = 0;
  let i = 0;
  for (let len2 = text.length; i < len2 && width < contentWidth; i++) {
    width += measureCharWidth(fontMeasureInfo, text.charCodeAt(i));
  }
  return i;
}
function parsePlainText(text, style, defaultOuterWidth, defaultOuterHeight) {
  text != null && (text += "");
  const overflow = style.overflow;
  const padding = style.padding;
  const paddingH = padding ? padding[1] + padding[3] : 0;
  const paddingV = padding ? padding[0] + padding[2] : 0;
  const font = style.font;
  const truncate = overflow === "truncate";
  const calculatedLineHeight = getLineHeight(font);
  const lineHeight = retrieve2(style.lineHeight, calculatedLineHeight);
  const truncateLineOverflow = style.lineOverflow === "truncate";
  let isTruncated = false;
  let width = style.width;
  if (width == null && defaultOuterWidth != null) {
    width = defaultOuterWidth - paddingH;
  }
  let height = style.height;
  if (height == null && defaultOuterHeight != null) {
    height = defaultOuterHeight - paddingV;
  }
  let lines;
  if (width != null && (overflow === "break" || overflow === "breakAll")) {
    lines = text ? wrapText(text, style.font, width, overflow === "breakAll", 0).lines : [];
  } else {
    lines = text ? text.split("\n") : [];
  }
  let contentHeight = lines.length * lineHeight;
  if (height == null) {
    height = contentHeight;
  }
  if (contentHeight > height && truncateLineOverflow) {
    const lineCount = Math.floor(height / lineHeight);
    isTruncated = isTruncated || lines.length > lineCount;
    lines = lines.slice(0, lineCount);
    contentHeight = lines.length * lineHeight;
  }
  if (text && truncate && width != null) {
    const options = prepareTruncateOptions(width, font, style.ellipsis, {
      minChar: style.truncateMinChar,
      placeholder: style.placeholder
    });
    const singleOut = {};
    for (let i = 0; i < lines.length; i++) {
      truncateSingleLine(singleOut, lines[i], options);
      lines[i] = singleOut.textLine;
      isTruncated = isTruncated || singleOut.isTruncated;
    }
  }
  let outerHeight = height;
  let contentWidth = 0;
  const fontMeasureInfo = ensureFontMeasureInfo(font);
  for (let i = 0; i < lines.length; i++) {
    contentWidth = Math.max(measureWidth(fontMeasureInfo, lines[i]), contentWidth);
  }
  if (width == null) {
    width = contentWidth;
  }
  let outerWidth = width;
  outerHeight += paddingV;
  outerWidth += paddingH;
  return {
    lines,
    height,
    outerWidth,
    outerHeight,
    lineHeight,
    calculatedLineHeight,
    contentWidth,
    contentHeight,
    width,
    isTruncated
  };
}
var RichTextToken = class {
};
var RichTextLine = class {
  constructor(tokens2) {
    this.tokens = [];
    if (tokens2) {
      this.tokens = tokens2;
    }
  }
};
var RichTextContentBlock = class {
  constructor() {
    this.width = 0;
    this.height = 0;
    this.contentWidth = 0;
    this.contentHeight = 0;
    this.outerWidth = 0;
    this.outerHeight = 0;
    this.lines = [];
    this.isTruncated = false;
  }
};
function parseRichText(text, style, defaultOuterWidth, defaultOuterHeight, topTextAlign) {
  const contentBlock = new RichTextContentBlock();
  text != null && (text += "");
  if (!text) {
    return contentBlock;
  }
  const stlPadding = style.padding;
  const stlPaddingH = stlPadding ? stlPadding[1] + stlPadding[3] : 0;
  const stlPaddingV = stlPadding ? stlPadding[0] + stlPadding[2] : 0;
  let topWidth = style.width;
  if (topWidth == null && defaultOuterWidth != null) {
    topWidth = defaultOuterWidth - stlPaddingH;
  }
  let topHeight = style.height;
  if (topHeight == null && defaultOuterHeight != null) {
    topHeight = defaultOuterHeight - stlPaddingV;
  }
  const overflow = style.overflow;
  let wrapInfo = (overflow === "break" || overflow === "breakAll") && topWidth != null ? {width: topWidth, accumWidth: 0, breakAll: overflow === "breakAll"} : null;
  let lastIndex = STYLE_REG.lastIndex = 0;
  let result;
  while ((result = STYLE_REG.exec(text)) != null) {
    const matchedIndex = result.index;
    if (matchedIndex > lastIndex) {
      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex), style, wrapInfo);
    }
    pushTokens(contentBlock, result[2], style, wrapInfo, result[1]);
    lastIndex = STYLE_REG.lastIndex;
  }
  if (lastIndex < text.length) {
    pushTokens(contentBlock, text.substring(lastIndex, text.length), style, wrapInfo);
  }
  let pendingList = [];
  let calculatedHeight = 0;
  let calculatedWidth = 0;
  const truncate = overflow === "truncate";
  const truncateLine = style.lineOverflow === "truncate";
  const tmpTruncateOut = {};
  function finishLine(line2, lineWidth, lineHeight) {
    line2.width = lineWidth;
    line2.lineHeight = lineHeight;
    calculatedHeight += lineHeight;
    calculatedWidth = Math.max(calculatedWidth, lineWidth);
  }
  outer:
    for (let i = 0; i < contentBlock.lines.length; i++) {
      const line2 = contentBlock.lines[i];
      let lineHeight = 0;
      let lineWidth = 0;
      for (let j = 0; j < line2.tokens.length; j++) {
        const token = line2.tokens[j];
        const tokenStyle = token.styleName && style.rich[token.styleName] || {};
        const textPadding = token.textPadding = tokenStyle.padding;
        const paddingH = textPadding ? textPadding[1] + textPadding[3] : 0;
        const font = token.font = tokenStyle.font || style.font;
        token.contentHeight = getLineHeight(font);
        let tokenHeight = retrieve2(tokenStyle.height, token.contentHeight);
        token.innerHeight = tokenHeight;
        textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
        token.height = tokenHeight;
        token.lineHeight = retrieve3(tokenStyle.lineHeight, style.lineHeight, tokenHeight);
        token.align = tokenStyle && tokenStyle.align || topTextAlign;
        token.verticalAlign = tokenStyle && tokenStyle.verticalAlign || "middle";
        if (truncateLine && topHeight != null && calculatedHeight + token.lineHeight > topHeight) {
          const originalLength = contentBlock.lines.length;
          if (j > 0) {
            line2.tokens = line2.tokens.slice(0, j);
            finishLine(line2, lineWidth, lineHeight);
            contentBlock.lines = contentBlock.lines.slice(0, i + 1);
          } else {
            contentBlock.lines = contentBlock.lines.slice(0, i);
          }
          contentBlock.isTruncated = contentBlock.isTruncated || contentBlock.lines.length < originalLength;
          break outer;
        }
        let styleTokenWidth = tokenStyle.width;
        let tokenWidthNotSpecified = styleTokenWidth == null || styleTokenWidth === "auto";
        if (typeof styleTokenWidth === "string" && styleTokenWidth.charAt(styleTokenWidth.length - 1) === "%") {
          token.percentWidth = styleTokenWidth;
          pendingList.push(token);
          token.contentWidth = measureWidth(ensureFontMeasureInfo(font), token.text);
        } else {
          if (tokenWidthNotSpecified) {
            const textBackgroundColor = tokenStyle.backgroundColor;
            let bgImg = textBackgroundColor && textBackgroundColor.image;
            if (bgImg) {
              bgImg = findExistImage(bgImg);
              if (isImageReady(bgImg)) {
                token.width = Math.max(token.width, bgImg.width * tokenHeight / bgImg.height);
              }
            }
          }
          const remainTruncWidth = truncate && topWidth != null ? topWidth - lineWidth : null;
          if (remainTruncWidth != null && remainTruncWidth < token.width) {
            if (!tokenWidthNotSpecified || remainTruncWidth < paddingH) {
              token.text = "";
              token.width = token.contentWidth = 0;
            } else {
              truncateText2(tmpTruncateOut, token.text, remainTruncWidth - paddingH, font, style.ellipsis, {minChar: style.truncateMinChar});
              token.text = tmpTruncateOut.text;
              contentBlock.isTruncated = contentBlock.isTruncated || tmpTruncateOut.isTruncated;
              token.width = token.contentWidth = measureWidth(ensureFontMeasureInfo(font), token.text);
            }
          } else {
            token.contentWidth = measureWidth(ensureFontMeasureInfo(font), token.text);
          }
        }
        token.width += paddingH;
        lineWidth += token.width;
        tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
      }
      finishLine(line2, lineWidth, lineHeight);
    }
  contentBlock.outerWidth = contentBlock.width = retrieve2(topWidth, calculatedWidth);
  contentBlock.outerHeight = contentBlock.height = retrieve2(topHeight, calculatedHeight);
  contentBlock.contentHeight = calculatedHeight;
  contentBlock.contentWidth = calculatedWidth;
  contentBlock.outerWidth += stlPaddingH;
  contentBlock.outerHeight += stlPaddingV;
  for (let i = 0; i < pendingList.length; i++) {
    const token = pendingList[i];
    const percentWidth = token.percentWidth;
    token.width = parseInt(percentWidth, 10) / 100 * contentBlock.width;
  }
  return contentBlock;
}
function pushTokens(block, str, style, wrapInfo, styleName) {
  const isEmptyStr = str === "";
  const tokenStyle = styleName && style.rich[styleName] || {};
  const lines = block.lines;
  const font = tokenStyle.font || style.font;
  let newLine = false;
  let strLines;
  let linesWidths;
  if (wrapInfo) {
    const tokenPadding = tokenStyle.padding;
    let tokenPaddingH = tokenPadding ? tokenPadding[1] + tokenPadding[3] : 0;
    if (tokenStyle.width != null && tokenStyle.width !== "auto") {
      const outerWidth = parsePercent(tokenStyle.width, wrapInfo.width) + tokenPaddingH;
      if (lines.length > 0) {
        if (outerWidth + wrapInfo.accumWidth > wrapInfo.width) {
          strLines = str.split("\n");
          newLine = true;
        }
      }
      wrapInfo.accumWidth = outerWidth;
    } else {
      const res = wrapText(str, font, wrapInfo.width, wrapInfo.breakAll, wrapInfo.accumWidth);
      wrapInfo.accumWidth = res.accumWidth + tokenPaddingH;
      linesWidths = res.linesWidths;
      strLines = res.lines;
    }
  }
  if (!strLines) {
    strLines = str.split("\n");
  }
  const fontMeasureInfo = ensureFontMeasureInfo(font);
  for (let i = 0; i < strLines.length; i++) {
    const text = strLines[i];
    const token = new RichTextToken();
    token.styleName = styleName;
    token.text = text;
    token.isLineHolder = !text && !isEmptyStr;
    if (typeof tokenStyle.width === "number") {
      token.width = tokenStyle.width;
    } else {
      token.width = linesWidths ? linesWidths[i] : measureWidth(fontMeasureInfo, text);
    }
    if (!i && !newLine) {
      const tokens2 = (lines[lines.length - 1] || (lines[0] = new RichTextLine())).tokens;
      const tokensLen = tokens2.length;
      tokensLen === 1 && tokens2[0].isLineHolder ? tokens2[0] = token : (text || !tokensLen || isEmptyStr) && tokens2.push(token);
    } else {
      lines.push(new RichTextLine([token]));
    }
  }
}
function isAlphabeticLetter(ch) {
  let code = ch.charCodeAt(0);
  return code >= 32 && code <= 591 || code >= 880 && code <= 4351 || code >= 4608 && code <= 5119 || code >= 7680 && code <= 8303;
}
var breakCharMap = reduce(",&?/;] ".split(""), function(obj, ch) {
  obj[ch] = true;
  return obj;
}, {});
function isWordBreakChar(ch) {
  if (isAlphabeticLetter(ch)) {
    if (breakCharMap[ch]) {
      return true;
    }
    return false;
  }
  return true;
}
function wrapText(text, font, lineWidth, isBreakAll, lastAccumWidth) {
  let lines = [];
  let linesWidths = [];
  let line2 = "";
  let currentWord = "";
  let currentWordWidth = 0;
  let accumWidth = 0;
  const fontMeasureInfo = ensureFontMeasureInfo(font);
  for (let i = 0; i < text.length; i++) {
    const ch = text.charAt(i);
    if (ch === "\n") {
      if (currentWord) {
        line2 += currentWord;
        accumWidth += currentWordWidth;
      }
      lines.push(line2);
      linesWidths.push(accumWidth);
      line2 = "";
      currentWord = "";
      currentWordWidth = 0;
      accumWidth = 0;
      continue;
    }
    const chWidth = measureCharWidth(fontMeasureInfo, ch.charCodeAt(0));
    const inWord = isBreakAll ? false : !isWordBreakChar(ch);
    if (!lines.length ? lastAccumWidth + accumWidth + chWidth > lineWidth : accumWidth + chWidth > lineWidth) {
      if (!accumWidth) {
        if (inWord) {
          lines.push(currentWord);
          linesWidths.push(currentWordWidth);
          currentWord = ch;
          currentWordWidth = chWidth;
        } else {
          lines.push(ch);
          linesWidths.push(chWidth);
        }
      } else if (line2 || currentWord) {
        if (inWord) {
          if (!line2) {
            line2 = currentWord;
            currentWord = "";
            currentWordWidth = 0;
            accumWidth = currentWordWidth;
          }
          lines.push(line2);
          linesWidths.push(accumWidth - currentWordWidth);
          currentWord += ch;
          currentWordWidth += chWidth;
          line2 = "";
          accumWidth = currentWordWidth;
        } else {
          if (currentWord) {
            line2 += currentWord;
            currentWord = "";
            currentWordWidth = 0;
          }
          lines.push(line2);
          linesWidths.push(accumWidth);
          line2 = ch;
          accumWidth = chWidth;
        }
      }
      continue;
    }
    accumWidth += chWidth;
    if (inWord) {
      currentWord += ch;
      currentWordWidth += chWidth;
    } else {
      if (currentWord) {
        line2 += currentWord;
        currentWord = "";
        currentWordWidth = 0;
      }
      line2 += ch;
    }
  }
  if (currentWord) {
    line2 += currentWord;
  }
  if (line2) {
    lines.push(line2);
    linesWidths.push(accumWidth);
  }
  if (lines.length === 1) {
    accumWidth += lastAccumWidth;
  }
  return {
    accumWidth,
    lines,
    linesWidths
  };
}
function calcInnerTextOverflowArea(out2, overflowRect, baseX, baseY, textAlign, textVerticalAlign) {
  out2.baseX = baseX;
  out2.baseY = baseY;
  out2.outerWidth = out2.outerHeight = null;
  if (!overflowRect) {
    return;
  }
  const textWidth = overflowRect.width * 2;
  const textHeight = overflowRect.height * 2;
  BoundingRect_default.set(tmpCITCTextRect, adjustTextX(baseX, textWidth, textAlign), adjustTextY2(baseY, textHeight, textVerticalAlign), textWidth, textHeight);
  BoundingRect_default.intersect(overflowRect, tmpCITCTextRect, null, tmpCITCIntersectRectOpt);
  const outIntersectRect = tmpCITCIntersectRectOpt.outIntersectRect;
  out2.outerWidth = outIntersectRect.width;
  out2.outerHeight = outIntersectRect.height;
  out2.baseX = adjustTextX(outIntersectRect.x, outIntersectRect.width, textAlign, true);
  out2.baseY = adjustTextY2(outIntersectRect.y, outIntersectRect.height, textVerticalAlign, true);
}
var tmpCITCTextRect = new BoundingRect_default(0, 0, 0, 0);
var tmpCITCIntersectRectOpt = {outIntersectRect: {}, clamp: true};

// ../zrender/src/graphic/Displayable.ts
var STYLE_MAGIC_KEY = "__zr_style_" + Math.round(Math.random() * 10);
var DEFAULT_COMMON_STYLE = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
};
var DEFAULT_COMMON_ANIMATION_PROPS = {
  style: {
    shadowBlur: true,
    shadowOffsetX: true,
    shadowOffsetY: true,
    shadowColor: true,
    opacity: true
  }
};
DEFAULT_COMMON_STYLE[STYLE_MAGIC_KEY] = true;
var PRIMARY_STATES_KEYS2 = ["z", "z2", "invisible"];
var PRIMARY_STATES_KEYS_IN_HOVER_LAYER = ["invisible"];
var Displayable2 = class extends Element_default {
  constructor(props) {
    super(props);
  }
  _init(props) {
    const keysArr = keys(props);
    for (let i = 0; i < keysArr.length; i++) {
      const key = keysArr[i];
      if (key === "style") {
        this.useStyle(props[key]);
      } else {
        super.attrKV(key, props[key]);
      }
    }
    if (!this.style) {
      this.useStyle({});
    }
  }
  beforeBrush() {
  }
  afterBrush() {
  }
  innerBeforeBrush() {
  }
  innerAfterBrush() {
  }
  shouldBePainted(viewWidth, viewHeight, considerClipPath, considerAncestors) {
    const m2 = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && isDisplayableCulled(this, viewWidth, viewHeight) || m2 && !m2[0] && !m2[3]) {
      return false;
    }
    if (considerClipPath && this.__clipPaths && this.__clipPaths.length) {
      for (let i = 0; i < this.__clipPaths.length; ++i) {
        if (this.__clipPaths[i].isZeroArea()) {
          return false;
        }
      }
    }
    if (considerAncestors && this.parent) {
      let parent = this.parent;
      while (parent) {
        if (parent.ignore) {
          return false;
        }
        parent = parent.parent;
      }
    }
    return true;
  }
  contain(x, y) {
    return this.rectContain(x, y);
  }
  traverse(cb, context) {
    cb.call(context, this);
  }
  rectContain(x, y) {
    const coord = this.transformCoordToLocal(x, y);
    const rect = this.getBoundingRect();
    return rect.contain(coord[0], coord[1]);
  }
  getPaintRect() {
    let rect = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      const transform2 = this.transform;
      const elRect = this.getBoundingRect();
      const style = this.style;
      const shadowSize = style.shadowBlur || 0;
      const shadowOffsetX = style.shadowOffsetX || 0;
      const shadowOffsetY = style.shadowOffsetY || 0;
      rect = this._paintRect || (this._paintRect = new BoundingRect_default(0, 0, 0, 0));
      if (transform2) {
        BoundingRect_default.applyTransform(rect, elRect, transform2);
      } else {
        rect.copy(elRect);
      }
      if (shadowSize || shadowOffsetX || shadowOffsetY) {
        rect.width += shadowSize * 2 + Math.abs(shadowOffsetX);
        rect.height += shadowSize * 2 + Math.abs(shadowOffsetY);
        rect.x = Math.min(rect.x, rect.x + shadowOffsetX - shadowSize);
        rect.y = Math.min(rect.y, rect.y + shadowOffsetY - shadowSize);
      }
      const tolerance = this.dirtyRectTolerance;
      if (!rect.isZero()) {
        rect.x = Math.floor(rect.x - tolerance);
        rect.y = Math.floor(rect.y - tolerance);
        rect.width = Math.ceil(rect.width + 1 + tolerance * 2);
        rect.height = Math.ceil(rect.height + 1 + tolerance * 2);
      }
    }
    return rect;
  }
  setPrevPaintRect(paintRect) {
    if (paintRect) {
      this._prevPaintRect = this._prevPaintRect || new BoundingRect_default(0, 0, 0, 0);
      this._prevPaintRect.copy(paintRect);
    } else {
      this._prevPaintRect = null;
    }
  }
  getPrevPaintRect() {
    return this._prevPaintRect;
  }
  animateStyle(loop) {
    return this.animate("style", loop);
  }
  updateDuringAnimation(targetKey) {
    if (targetKey === "style") {
      this.dirtyStyle();
    } else {
      this.markRedraw();
    }
  }
  attrKV(key, value) {
    if (key !== "style") {
      super.attrKV(key, value);
    } else {
      if (!this.style) {
        this.useStyle(value);
      } else {
        this.setStyle(value);
      }
    }
  }
  setStyle(keyOrObj, value) {
    if (typeof keyOrObj === "string") {
      this.style[keyOrObj] = value;
    } else {
      extend(this.style, keyOrObj);
    }
    this.dirtyStyle();
    return this;
  }
  dirtyStyle(notRedraw) {
    if (!notRedraw) {
      this.markRedraw();
    }
    this.__dirty |= STYLE_CHANGED_BIT;
    if (this._rect) {
      this._rect = null;
    }
  }
  dirty() {
    this.dirtyStyle();
  }
  styleChanged() {
    return !!(this.__dirty & STYLE_CHANGED_BIT);
  }
  styleUpdated() {
    this.__dirty &= ~STYLE_CHANGED_BIT;
  }
  createStyle(obj) {
    return createObject(DEFAULT_COMMON_STYLE, obj);
  }
  useStyle(obj) {
    if (!obj[STYLE_MAGIC_KEY]) {
      obj = this.createStyle(obj);
    }
    if (this.__inHover) {
      this.__hoverStyle = obj;
    } else {
      this.style = obj;
    }
    this.dirtyStyle();
  }
  isStyleObject(obj) {
    return obj[STYLE_MAGIC_KEY];
  }
  _innerSaveToNormal(toState) {
    super._innerSaveToNormal(toState);
    const normalState = this._normalState;
    if (toState.style && !normalState.style) {
      normalState.style = this._mergeStyle(this.createStyle(), this.style);
    }
    this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS2);
  }
  _applyStateObj(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
    super._applyStateObj(stateName, state, normalState, keepCurrentStates, transition, animationCfg);
    const needsRestoreToNormal = !(state && keepCurrentStates);
    let targetStyle;
    if (state && state.style) {
      if (transition) {
        if (keepCurrentStates) {
          targetStyle = state.style;
        } else {
          targetStyle = this._mergeStyle(this.createStyle(), normalState.style);
          this._mergeStyle(targetStyle, state.style);
        }
      } else {
        targetStyle = this._mergeStyle(this.createStyle(), keepCurrentStates ? this.style : normalState.style);
        this._mergeStyle(targetStyle, state.style);
      }
    } else if (needsRestoreToNormal) {
      targetStyle = normalState.style;
    }
    if (targetStyle) {
      if (transition) {
        const sourceStyle = this.style;
        this.style = this.createStyle(needsRestoreToNormal ? {} : sourceStyle);
        if (needsRestoreToNormal) {
          const changedKeys = keys(sourceStyle);
          for (let i = 0; i < changedKeys.length; i++) {
            const key = changedKeys[i];
            if (key in targetStyle) {
              targetStyle[key] = targetStyle[key];
              this.style[key] = sourceStyle[key];
            }
          }
        }
        const targetKeys = keys(targetStyle);
        for (let i = 0; i < targetKeys.length; i++) {
          const key = targetKeys[i];
          this.style[key] = this.style[key];
        }
        this._transitionState(stateName, {
          style: targetStyle
        }, animationCfg, this.getAnimationStyleProps());
      } else {
        this.useStyle(targetStyle);
      }
    }
    const statesKeys = this.__inHover ? PRIMARY_STATES_KEYS_IN_HOVER_LAYER : PRIMARY_STATES_KEYS2;
    for (let i = 0; i < statesKeys.length; i++) {
      let key = statesKeys[i];
      if (state && state[key] != null) {
        this[key] = state[key];
      } else if (needsRestoreToNormal) {
        if (normalState[key] != null) {
          this[key] = normalState[key];
        }
      }
    }
  }
  _mergeStates(states) {
    const mergedState = super._mergeStates(states);
    let mergedStyle;
    for (let i = 0; i < states.length; i++) {
      const state = states[i];
      if (state.style) {
        mergedStyle = mergedStyle || {};
        this._mergeStyle(mergedStyle, state.style);
      }
    }
    if (mergedStyle) {
      mergedState.style = mergedStyle;
    }
    return mergedState;
  }
  _mergeStyle(targetStyle, sourceStyle) {
    extend(targetStyle, sourceStyle);
    return targetStyle;
  }
  getAnimationStyleProps() {
    return DEFAULT_COMMON_ANIMATION_PROPS;
  }
};
var Displayable = Displayable2;
Displayable.initDefaultProps = function() {
  const dispProto = Displayable2.prototype;
  dispProto.type = "displayable";
  dispProto.invisible = false;
  dispProto.z = 0;
  dispProto.z2 = 0;
  dispProto.zlevel = 0;
  dispProto.culling = false;
  dispProto.cursor = "pointer";
  dispProto.rectHover = false;
  dispProto.incremental = false;
  dispProto._rect = null;
  dispProto.dirtyRectTolerance = 0;
  dispProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT;
}();
var tmpRect2 = new BoundingRect_default(0, 0, 0, 0);
var viewRect = new BoundingRect_default(0, 0, 0, 0);
function isDisplayableCulled(el, width, height) {
  tmpRect2.copy(el.getBoundingRect());
  if (el.transform) {
    tmpRect2.applyTransform(el.transform);
  }
  viewRect.width = width;
  viewRect.height = height;
  return !tmpRect2.intersect(viewRect);
}
var Displayable_default = Displayable;

// ../zrender/src/core/bbox.ts
var mathMin3 = Math.min;
var mathMax3 = Math.max;
var mathSin = Math.sin;
var mathCos = Math.cos;
var PI2 = Math.PI * 2;
var start = create();
var end = create();
var extremity = create();
function fromPoints(points4, min3, max3) {
  if (points4.length === 0) {
    return;
  }
  let p = points4[0];
  let left = p[0];
  let right = p[0];
  let top = p[1];
  let bottom = p[1];
  for (let i = 1; i < points4.length; i++) {
    p = points4[i];
    left = mathMin3(left, p[0]);
    right = mathMax3(right, p[0]);
    top = mathMin3(top, p[1]);
    bottom = mathMax3(bottom, p[1]);
  }
  min3[0] = left;
  min3[1] = top;
  max3[0] = right;
  max3[1] = bottom;
}
function fromLine(x0, y0, x1, y1, min3, max3) {
  min3[0] = mathMin3(x0, x1);
  min3[1] = mathMin3(y0, y1);
  max3[0] = mathMax3(x0, x1);
  max3[1] = mathMax3(y0, y1);
}
var xDim = [];
var yDim = [];
function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min3, max3) {
  const cubicExtrema2 = cubicExtrema;
  const cubicAt2 = cubicAt;
  let n = cubicExtrema2(x0, x1, x2, x3, xDim);
  min3[0] = Infinity;
  min3[1] = Infinity;
  max3[0] = -Infinity;
  max3[1] = -Infinity;
  for (let i = 0; i < n; i++) {
    const x = cubicAt2(x0, x1, x2, x3, xDim[i]);
    min3[0] = mathMin3(x, min3[0]);
    max3[0] = mathMax3(x, max3[0]);
  }
  n = cubicExtrema2(y0, y1, y2, y3, yDim);
  for (let i = 0; i < n; i++) {
    const y = cubicAt2(y0, y1, y2, y3, yDim[i]);
    min3[1] = mathMin3(y, min3[1]);
    max3[1] = mathMax3(y, max3[1]);
  }
  min3[0] = mathMin3(x0, min3[0]);
  max3[0] = mathMax3(x0, max3[0]);
  min3[0] = mathMin3(x3, min3[0]);
  max3[0] = mathMax3(x3, max3[0]);
  min3[1] = mathMin3(y0, min3[1]);
  max3[1] = mathMax3(y0, max3[1]);
  min3[1] = mathMin3(y3, min3[1]);
  max3[1] = mathMax3(y3, max3[1]);
}
function fromQuadratic(x0, y0, x1, y1, x2, y2, min3, max3) {
  const quadraticExtremum2 = quadraticExtremum;
  const quadraticAt3 = quadraticAt;
  const tx = mathMax3(mathMin3(quadraticExtremum2(x0, x1, x2), 1), 0);
  const ty = mathMax3(mathMin3(quadraticExtremum2(y0, y1, y2), 1), 0);
  const x = quadraticAt3(x0, x1, x2, tx);
  const y = quadraticAt3(y0, y1, y2, ty);
  min3[0] = mathMin3(x0, x2, x);
  min3[1] = mathMin3(y0, y2, y);
  max3[0] = mathMax3(x0, x2, x);
  max3[1] = mathMax3(y0, y2, y);
}
function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min3, max3) {
  const vec2Min = min;
  const vec2Max = max;
  const diff = Math.abs(startAngle - endAngle);
  if (diff % PI2 < 1e-4 && diff > 1e-4) {
    min3[0] = x - rx;
    min3[1] = y - ry;
    max3[0] = x + rx;
    max3[1] = y + ry;
    return;
  }
  start[0] = mathCos(startAngle) * rx + x;
  start[1] = mathSin(startAngle) * ry + y;
  end[0] = mathCos(endAngle) * rx + x;
  end[1] = mathSin(endAngle) * ry + y;
  vec2Min(min3, start, end);
  vec2Max(max3, start, end);
  startAngle = startAngle % PI2;
  if (startAngle < 0) {
    startAngle = startAngle + PI2;
  }
  endAngle = endAngle % PI2;
  if (endAngle < 0) {
    endAngle = endAngle + PI2;
  }
  if (startAngle > endAngle && !anticlockwise) {
    endAngle += PI2;
  } else if (startAngle < endAngle && anticlockwise) {
    startAngle += PI2;
  }
  if (anticlockwise) {
    const tmp = endAngle;
    endAngle = startAngle;
    startAngle = tmp;
  }
  for (let angle = 0; angle < endAngle; angle += Math.PI / 2) {
    if (angle > startAngle) {
      extremity[0] = mathCos(angle) * rx + x;
      extremity[1] = mathSin(angle) * ry + y;
      vec2Min(min3, extremity, min3);
      vec2Max(max3, extremity, max3);
    }
  }
}

// ../zrender/src/core/PathProxy.ts
var CMD = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
};
var tmpOutX = [];
var tmpOutY = [];
var min2 = [];
var max2 = [];
var min22 = [];
var max22 = [];
var mathMin4 = Math.min;
var mathMax4 = Math.max;
var mathCos2 = Math.cos;
var mathSin2 = Math.sin;
var mathAbs3 = Math.abs;
var PI = Math.PI;
var PI22 = PI * 2;
var hasTypedArray = typeof Float32Array !== "undefined";
var tmpAngles = [];
function modPI2(radian) {
  const n = Math.round(radian / PI * 1e8) / 1e8;
  return n % 2 * PI;
}
function normalizeArcAngles(angles, anticlockwise) {
  let newStartAngle = modPI2(angles[0]);
  if (newStartAngle < 0) {
    newStartAngle += PI22;
  }
  let delta = newStartAngle - angles[0];
  let newEndAngle = angles[1];
  newEndAngle += delta;
  if (!anticlockwise && newEndAngle - newStartAngle >= PI22) {
    newEndAngle = newStartAngle + PI22;
  } else if (anticlockwise && newStartAngle - newEndAngle >= PI22) {
    newEndAngle = newStartAngle - PI22;
  } else if (!anticlockwise && newStartAngle > newEndAngle) {
    newEndAngle = newStartAngle + (PI22 - modPI2(newStartAngle - newEndAngle));
  } else if (anticlockwise && newStartAngle < newEndAngle) {
    newEndAngle = newStartAngle - (PI22 - modPI2(newEndAngle - newStartAngle));
  }
  angles[0] = newStartAngle;
  angles[1] = newEndAngle;
}
var PathProxy2 = class {
  constructor(notSaveData) {
    this.dpr = 1;
    this._xi = 0;
    this._yi = 0;
    this._x0 = 0;
    this._y0 = 0;
    this._len = 0;
    if (notSaveData) {
      this._saveData = false;
    }
    if (this._saveData) {
      this.data = [];
    }
  }
  increaseVersion() {
    this._version++;
  }
  getVersion() {
    return this._version;
  }
  setScale(sx, sy, segmentIgnoreThreshold) {
    segmentIgnoreThreshold = segmentIgnoreThreshold || 0;
    if (segmentIgnoreThreshold > 0) {
      this._ux = mathAbs3(segmentIgnoreThreshold / devicePixelRatio / sx) || 0;
      this._uy = mathAbs3(segmentIgnoreThreshold / devicePixelRatio / sy) || 0;
    }
  }
  setDPR(dpr2) {
    this.dpr = dpr2;
  }
  setContext(ctx) {
    this._ctx = ctx;
  }
  getContext() {
    return this._ctx;
  }
  beginPath() {
    this._ctx && this._ctx.beginPath();
    this.reset();
    return this;
  }
  reset() {
    if (this._saveData) {
      this._len = 0;
    }
    if (this._pathSegLen) {
      this._pathSegLen = null;
      this._pathLen = 0;
    }
    this._version++;
  }
  moveTo(x, y) {
    this._drawPendingPt();
    this.addData(CMD.M, x, y);
    this._ctx && this._ctx.moveTo(x, y);
    this._x0 = x;
    this._y0 = y;
    this._xi = x;
    this._yi = y;
    return this;
  }
  lineTo(x, y) {
    const dx = mathAbs3(x - this._xi);
    const dy = mathAbs3(y - this._yi);
    const exceedUnit = dx > this._ux || dy > this._uy;
    this.addData(CMD.L, x, y);
    if (this._ctx && exceedUnit) {
      this._ctx.lineTo(x, y);
    }
    if (exceedUnit) {
      this._xi = x;
      this._yi = y;
      this._pendingPtDist = 0;
    } else {
      const d2 = dx * dx + dy * dy;
      if (d2 > this._pendingPtDist) {
        this._pendingPtX = x;
        this._pendingPtY = y;
        this._pendingPtDist = d2;
      }
    }
    return this;
  }
  bezierCurveTo(x1, y1, x2, y2, x3, y3) {
    this._drawPendingPt();
    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
    if (this._ctx) {
      this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
    }
    this._xi = x3;
    this._yi = y3;
    return this;
  }
  quadraticCurveTo(x1, y1, x2, y2) {
    this._drawPendingPt();
    this.addData(CMD.Q, x1, y1, x2, y2);
    if (this._ctx) {
      this._ctx.quadraticCurveTo(x1, y1, x2, y2);
    }
    this._xi = x2;
    this._yi = y2;
    return this;
  }
  arc(cx, cy, r, startAngle, endAngle, anticlockwise) {
    this._drawPendingPt();
    tmpAngles[0] = startAngle;
    tmpAngles[1] = endAngle;
    normalizeArcAngles(tmpAngles, anticlockwise);
    startAngle = tmpAngles[0];
    endAngle = tmpAngles[1];
    let delta = endAngle - startAngle;
    this.addData(CMD.A, cx, cy, r, r, startAngle, delta, 0, anticlockwise ? 0 : 1);
    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
    this._xi = mathCos2(endAngle) * r + cx;
    this._yi = mathSin2(endAngle) * r + cy;
    return this;
  }
  arcTo(x1, y1, x2, y2, radius) {
    this._drawPendingPt();
    if (this._ctx) {
      this._ctx.arcTo(x1, y1, x2, y2, radius);
    }
    return this;
  }
  rect(x, y, w, h) {
    this._drawPendingPt();
    this._ctx && this._ctx.rect(x, y, w, h);
    this.addData(CMD.R, x, y, w, h);
    return this;
  }
  closePath() {
    this._drawPendingPt();
    this.addData(CMD.Z);
    const ctx = this._ctx;
    const x0 = this._x0;
    const y0 = this._y0;
    if (ctx) {
      ctx.closePath();
    }
    this._xi = x0;
    this._yi = y0;
    return this;
  }
  fill(ctx) {
    ctx && ctx.fill();
    this.toStatic();
  }
  stroke(ctx) {
    ctx && ctx.stroke();
    this.toStatic();
  }
  len() {
    return this._len;
  }
  setData(data) {
    if (!this._saveData) {
      return;
    }
    const len2 = data.length;
    if (!(this.data && this.data.length === len2) && hasTypedArray) {
      this.data = new Float32Array(len2);
    }
    for (let i = 0; i < len2; i++) {
      this.data[i] = data[i];
    }
    this._len = len2;
  }
  appendPath(path) {
    if (!this._saveData) {
      return;
    }
    if (!(path instanceof Array)) {
      path = [path];
    }
    const len2 = path.length;
    let appendSize = 0;
    let offset = this._len;
    for (let i = 0; i < len2; i++) {
      appendSize += path[i].len();
    }
    const oldData = this.data;
    if (hasTypedArray && (oldData instanceof Float32Array || !oldData)) {
      this.data = new Float32Array(offset + appendSize);
      if (offset > 0 && oldData) {
        for (let k = 0; k < offset; k++) {
          this.data[k] = oldData[k];
        }
      }
    }
    for (let i = 0; i < len2; i++) {
      const appendPathData = path[i].data;
      for (let k = 0; k < appendPathData.length; k++) {
        this.data[offset++] = appendPathData[k];
      }
    }
    this._len = offset;
  }
  addData(cmd, a, b, c, d, e2, f, g, h) {
    if (!this._saveData) {
      return;
    }
    let data = this.data;
    if (this._len + arguments.length > data.length) {
      this._expandData();
      data = this.data;
    }
    for (let i = 0; i < arguments.length; i++) {
      data[this._len++] = arguments[i];
    }
  }
  _drawPendingPt() {
    if (this._pendingPtDist > 0) {
      this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY);
      this._pendingPtDist = 0;
    }
  }
  _expandData() {
    if (!(this.data instanceof Array)) {
      const newData = [];
      for (let i = 0; i < this._len; i++) {
        newData[i] = this.data[i];
      }
      this.data = newData;
    }
  }
  toStatic() {
    if (!this._saveData) {
      return;
    }
    this._drawPendingPt();
    const data = this.data;
    if (data instanceof Array) {
      data.length = this._len;
      if (hasTypedArray && this._len > 11) {
        this.data = new Float32Array(data);
      }
    }
  }
  getBoundingRect() {
    min2[0] = min2[1] = min22[0] = min22[1] = Number.MAX_VALUE;
    max2[0] = max2[1] = max22[0] = max22[1] = -Number.MAX_VALUE;
    const data = this.data;
    let xi = 0;
    let yi = 0;
    let x0 = 0;
    let y0 = 0;
    let i;
    for (i = 0; i < this._len; ) {
      const cmd = data[i++];
      const isFirst = i === 1;
      if (isFirst) {
        xi = data[i];
        yi = data[i + 1];
        x0 = xi;
        y0 = yi;
      }
      switch (cmd) {
        case CMD.M:
          xi = x0 = data[i++];
          yi = y0 = data[i++];
          min22[0] = x0;
          min22[1] = y0;
          max22[0] = x0;
          max22[1] = y0;
          break;
        case CMD.L:
          fromLine(xi, yi, data[i], data[i + 1], min22, max22);
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD.C:
          fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min22, max22);
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD.Q:
          fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min22, max22);
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD.A:
          const cx = data[i++];
          const cy = data[i++];
          const rx = data[i++];
          const ry = data[i++];
          const startAngle = data[i++];
          const endAngle = data[i++] + startAngle;
          i += 1;
          const anticlockwise = !data[i++];
          if (isFirst) {
            x0 = mathCos2(startAngle) * rx + cx;
            y0 = mathSin2(startAngle) * ry + cy;
          }
          fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min22, max22);
          xi = mathCos2(endAngle) * rx + cx;
          yi = mathSin2(endAngle) * ry + cy;
          break;
        case CMD.R:
          x0 = xi = data[i++];
          y0 = yi = data[i++];
          const width = data[i++];
          const height = data[i++];
          fromLine(x0, y0, x0 + width, y0 + height, min22, max22);
          break;
        case CMD.Z:
          xi = x0;
          yi = y0;
          break;
      }
      min(min2, min2, min22);
      max(max2, max2, max22);
    }
    if (i === 0) {
      min2[0] = min2[1] = max2[0] = max2[1] = 0;
    }
    return new BoundingRect_default(min2[0], min2[1], max2[0] - min2[0], max2[1] - min2[1]);
  }
  _calculateLength() {
    const data = this.data;
    const len2 = this._len;
    const ux = this._ux;
    const uy = this._uy;
    let xi = 0;
    let yi = 0;
    let x0 = 0;
    let y0 = 0;
    if (!this._pathSegLen) {
      this._pathSegLen = [];
    }
    const pathSegLen = this._pathSegLen;
    let pathTotalLen = 0;
    let segCount = 0;
    for (let i = 0; i < len2; ) {
      const cmd = data[i++];
      const isFirst = i === 1;
      if (isFirst) {
        xi = data[i];
        yi = data[i + 1];
        x0 = xi;
        y0 = yi;
      }
      let l = -1;
      switch (cmd) {
        case CMD.M:
          xi = x0 = data[i++];
          yi = y0 = data[i++];
          break;
        case CMD.L: {
          const x2 = data[i++];
          const y2 = data[i++];
          const dx = x2 - xi;
          const dy = y2 - yi;
          if (mathAbs3(dx) > ux || mathAbs3(dy) > uy || i === len2 - 1) {
            l = Math.sqrt(dx * dx + dy * dy);
            xi = x2;
            yi = y2;
          }
          break;
        }
        case CMD.C: {
          const x1 = data[i++];
          const y1 = data[i++];
          const x2 = data[i++];
          const y2 = data[i++];
          const x3 = data[i++];
          const y3 = data[i++];
          l = cubicLength(xi, yi, x1, y1, x2, y2, x3, y3, 10);
          xi = x3;
          yi = y3;
          break;
        }
        case CMD.Q: {
          const x1 = data[i++];
          const y1 = data[i++];
          const x2 = data[i++];
          const y2 = data[i++];
          l = quadraticLength(xi, yi, x1, y1, x2, y2, 10);
          xi = x2;
          yi = y2;
          break;
        }
        case CMD.A:
          const cx = data[i++];
          const cy = data[i++];
          const rx = data[i++];
          const ry = data[i++];
          const startAngle = data[i++];
          let delta = data[i++];
          const endAngle = delta + startAngle;
          i += 1;
          if (isFirst) {
            x0 = mathCos2(startAngle) * rx + cx;
            y0 = mathSin2(startAngle) * ry + cy;
          }
          l = mathMax4(rx, ry) * mathMin4(PI22, Math.abs(delta));
          xi = mathCos2(endAngle) * rx + cx;
          yi = mathSin2(endAngle) * ry + cy;
          break;
        case CMD.R: {
          x0 = xi = data[i++];
          y0 = yi = data[i++];
          const width = data[i++];
          const height = data[i++];
          l = width * 2 + height * 2;
          break;
        }
        case CMD.Z: {
          const dx = x0 - xi;
          const dy = y0 - yi;
          l = Math.sqrt(dx * dx + dy * dy);
          xi = x0;
          yi = y0;
          break;
        }
      }
      if (l >= 0) {
        pathSegLen[segCount++] = l;
        pathTotalLen += l;
      }
    }
    this._pathLen = pathTotalLen;
    return pathTotalLen;
  }
  rebuildPath(ctx, percent) {
    const d = this.data;
    const ux = this._ux;
    const uy = this._uy;
    const len2 = this._len;
    let x0;
    let y0;
    let xi;
    let yi;
    let x;
    let y;
    const drawPart = percent < 1;
    let pathSegLen;
    let pathTotalLen;
    let accumLength = 0;
    let segCount = 0;
    let displayedLength;
    let pendingPtDist = 0;
    let pendingPtX;
    let pendingPtY;
    if (drawPart) {
      if (!this._pathSegLen) {
        this._calculateLength();
      }
      pathSegLen = this._pathSegLen;
      pathTotalLen = this._pathLen;
      displayedLength = percent * pathTotalLen;
      if (!displayedLength) {
        return;
      }
    }
    lo:
      for (let i = 0; i < len2; ) {
        const cmd = d[i++];
        const isFirst = i === 1;
        if (isFirst) {
          xi = d[i];
          yi = d[i + 1];
          x0 = xi;
          y0 = yi;
        }
        if (cmd !== CMD.L && pendingPtDist > 0) {
          ctx.lineTo(pendingPtX, pendingPtY);
          pendingPtDist = 0;
        }
        switch (cmd) {
          case CMD.M:
            x0 = xi = d[i++];
            y0 = yi = d[i++];
            ctx.moveTo(xi, yi);
            break;
          case CMD.L: {
            x = d[i++];
            y = d[i++];
            const dx = mathAbs3(x - xi);
            const dy = mathAbs3(y - yi);
            if (dx > ux || dy > uy) {
              if (drawPart) {
                const l = pathSegLen[segCount++];
                if (accumLength + l > displayedLength) {
                  const t = (displayedLength - accumLength) / l;
                  ctx.lineTo(xi * (1 - t) + x * t, yi * (1 - t) + y * t);
                  break lo;
                }
                accumLength += l;
              }
              ctx.lineTo(x, y);
              xi = x;
              yi = y;
              pendingPtDist = 0;
            } else {
              const d2 = dx * dx + dy * dy;
              if (d2 > pendingPtDist) {
                pendingPtX = x;
                pendingPtY = y;
                pendingPtDist = d2;
              }
            }
            break;
          }
          case CMD.C: {
            const x1 = d[i++];
            const y1 = d[i++];
            const x2 = d[i++];
            const y2 = d[i++];
            const x3 = d[i++];
            const y3 = d[i++];
            if (drawPart) {
              const l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                const t = (displayedLength - accumLength) / l;
                cubicSubdivide(xi, x1, x2, x3, t, tmpOutX);
                cubicSubdivide(yi, y1, y2, y3, t, tmpOutY);
                ctx.bezierCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2], tmpOutX[3], tmpOutY[3]);
                break lo;
              }
              accumLength += l;
            }
            ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
            xi = x3;
            yi = y3;
            break;
          }
          case CMD.Q: {
            const x1 = d[i++];
            const y1 = d[i++];
            const x2 = d[i++];
            const y2 = d[i++];
            if (drawPart) {
              const l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                const t = (displayedLength - accumLength) / l;
                quadraticSubdivide(xi, x1, x2, t, tmpOutX);
                quadraticSubdivide(yi, y1, y2, t, tmpOutY);
                ctx.quadraticCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2]);
                break lo;
              }
              accumLength += l;
            }
            ctx.quadraticCurveTo(x1, y1, x2, y2);
            xi = x2;
            yi = y2;
            break;
          }
          case CMD.A:
            const cx = d[i++];
            const cy = d[i++];
            const rx = d[i++];
            const ry = d[i++];
            let startAngle = d[i++];
            let delta = d[i++];
            const psi = d[i++];
            const anticlockwise = !d[i++];
            const r = rx > ry ? rx : ry;
            const isEllipse = mathAbs3(rx - ry) > 1e-3;
            let endAngle = startAngle + delta;
            let breakBuild = false;
            if (drawPart) {
              const l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                endAngle = startAngle + delta * (displayedLength - accumLength) / l;
                breakBuild = true;
              }
              accumLength += l;
            }
            if (isEllipse && ctx.ellipse) {
              ctx.ellipse(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise);
            } else {
              ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
            }
            if (breakBuild) {
              break lo;
            }
            if (isFirst) {
              x0 = mathCos2(startAngle) * rx + cx;
              y0 = mathSin2(startAngle) * ry + cy;
            }
            xi = mathCos2(endAngle) * rx + cx;
            yi = mathSin2(endAngle) * ry + cy;
            break;
          case CMD.R:
            x0 = xi = d[i];
            y0 = yi = d[i + 1];
            x = d[i++];
            y = d[i++];
            const width = d[i++];
            const height = d[i++];
            if (drawPart) {
              const l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                let d2 = displayedLength - accumLength;
                ctx.moveTo(x, y);
                ctx.lineTo(x + mathMin4(d2, width), y);
                d2 -= width;
                if (d2 > 0) {
                  ctx.lineTo(x + width, y + mathMin4(d2, height));
                }
                d2 -= height;
                if (d2 > 0) {
                  ctx.lineTo(x + mathMax4(width - d2, 0), y + height);
                }
                d2 -= width;
                if (d2 > 0) {
                  ctx.lineTo(x, y + mathMax4(height - d2, 0));
                }
                break lo;
              }
              accumLength += l;
            }
            ctx.rect(x, y, width, height);
            break;
          case CMD.Z:
            if (drawPart) {
              const l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                const t = (displayedLength - accumLength) / l;
                ctx.lineTo(xi * (1 - t) + x0 * t, yi * (1 - t) + y0 * t);
                break lo;
              }
              accumLength += l;
            }
            ctx.closePath();
            xi = x0;
            yi = y0;
        }
      }
  }
  clone() {
    const newProxy = new PathProxy2();
    const data = this.data;
    newProxy.data = data.slice ? data.slice() : Array.prototype.slice.call(data);
    newProxy._len = this._len;
    return newProxy;
  }
  canSave() {
    return !!this._saveData;
  }
};
var PathProxy = PathProxy2;
PathProxy.CMD = CMD;
PathProxy.initDefaultProps = function() {
  const proto = PathProxy2.prototype;
  proto._saveData = true;
  proto._ux = 0;
  proto._uy = 0;
  proto._pendingPtDist = 0;
  proto._version = 0;
}();
var PathProxy_default = PathProxy;

// ../zrender/src/contain/line.ts
function containStroke(x0, y0, x1, y1, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }
  const _l = lineWidth;
  let _a = 0;
  let _b = x0;
  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
    return false;
  }
  if (x0 !== x1) {
    _a = (y0 - y1) / (x0 - x1);
    _b = (x0 * y1 - x1 * y0) / (x0 - x1);
  } else {
    return Math.abs(x - x0) <= _l / 2;
  }
  const tmp = _a * x - y + _b;
  const _s = tmp * tmp / (_a * _a + 1);
  return _s <= _l / 2 * _l / 2;
}

// ../zrender/src/contain/cubic.ts
function containStroke2(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }
  const _l = lineWidth;
  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
    return false;
  }
  const d = cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
  return d <= _l / 2;
}

// ../zrender/src/contain/quadratic.ts
function containStroke3(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }
  const _l = lineWidth;
  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
    return false;
  }
  const d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
  return d <= _l / 2;
}

// ../zrender/src/contain/util.ts
var PI23 = Math.PI * 2;
function normalizeRadian(angle) {
  angle %= PI23;
  if (angle < 0) {
    angle += PI23;
  }
  return angle;
}

// ../zrender/src/contain/arc.ts
var PI24 = Math.PI * 2;
function containStroke4(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }
  const _l = lineWidth;
  x -= cx;
  y -= cy;
  const d = Math.sqrt(x * x + y * y);
  if (d - _l > r || d + _l < r) {
    return false;
  }
  if (Math.abs(startAngle - endAngle) % PI24 < 1e-4) {
    return true;
  }
  if (anticlockwise) {
    const tmp = startAngle;
    startAngle = normalizeRadian(endAngle);
    endAngle = normalizeRadian(tmp);
  } else {
    startAngle = normalizeRadian(startAngle);
    endAngle = normalizeRadian(endAngle);
  }
  if (startAngle > endAngle) {
    endAngle += PI24;
  }
  let angle = Math.atan2(y, x);
  if (angle < 0) {
    angle += PI24;
  }
  return angle >= startAngle && angle <= endAngle || angle + PI24 >= startAngle && angle + PI24 <= endAngle;
}

// ../zrender/src/contain/windingLine.ts
function windingLine(x0, y0, x1, y1, x, y) {
  if (y > y0 && y > y1 || y < y0 && y < y1) {
    return 0;
  }
  if (y1 === y0) {
    return 0;
  }
  const t = (y - y0) / (y1 - y0);
  let dir3 = y1 < y0 ? 1 : -1;
  if (t === 1 || t === 0) {
    dir3 = y1 < y0 ? 0.5 : -0.5;
  }
  const x_ = t * (x1 - x0) + x0;
  return x_ === x ? Infinity : x_ > x ? dir3 : 0;
}

// ../zrender/src/contain/path.ts
var CMD2 = PathProxy_default.CMD;
var PI25 = Math.PI * 2;
var EPSILON5 = 1e-4;
function isAroundEqual(a, b) {
  return Math.abs(a - b) < EPSILON5;
}
var roots = [-1, -1, -1];
var extrema = [-1, -1];
function swapExtrema() {
  const tmp = extrema[0];
  extrema[0] = extrema[1];
  extrema[1] = tmp;
}
function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
    return 0;
  }
  const nRoots = cubicRootAt(y0, y1, y2, y3, y, roots);
  if (nRoots === 0) {
    return 0;
  } else {
    let w = 0;
    let nExtrema = -1;
    let y0_;
    let y1_;
    for (let i = 0; i < nRoots; i++) {
      let t = roots[i];
      let unit = t === 0 || t === 1 ? 0.5 : 1;
      let x_ = cubicAt(x0, x1, x2, x3, t);
      if (x_ < x) {
        continue;
      }
      if (nExtrema < 0) {
        nExtrema = cubicExtrema(y0, y1, y2, y3, extrema);
        if (extrema[1] < extrema[0] && nExtrema > 1) {
          swapExtrema();
        }
        y0_ = cubicAt(y0, y1, y2, y3, extrema[0]);
        if (nExtrema > 1) {
          y1_ = cubicAt(y0, y1, y2, y3, extrema[1]);
        }
      }
      if (nExtrema === 2) {
        if (t < extrema[0]) {
          w += y0_ < y0 ? unit : -unit;
        } else if (t < extrema[1]) {
          w += y1_ < y0_ ? unit : -unit;
        } else {
          w += y3 < y1_ ? unit : -unit;
        }
      } else {
        if (t < extrema[0]) {
          w += y0_ < y0 ? unit : -unit;
        } else {
          w += y3 < y0_ ? unit : -unit;
        }
      }
    }
    return w;
  }
}
function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
    return 0;
  }
  const nRoots = quadraticRootAt(y0, y1, y2, y, roots);
  if (nRoots === 0) {
    return 0;
  } else {
    const t = quadraticExtremum(y0, y1, y2);
    if (t >= 0 && t <= 1) {
      let w = 0;
      let y_ = quadraticAt(y0, y1, y2, t);
      for (let i = 0; i < nRoots; i++) {
        let unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
        let x_ = quadraticAt(x0, x1, x2, roots[i]);
        if (x_ < x) {
          continue;
        }
        if (roots[i] < t) {
          w += y_ < y0 ? unit : -unit;
        } else {
          w += y2 < y_ ? unit : -unit;
        }
      }
      return w;
    } else {
      const unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
      const x_ = quadraticAt(x0, x1, x2, roots[0]);
      if (x_ < x) {
        return 0;
      }
      return y2 < y0 ? unit : -unit;
    }
  }
}
function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
  y -= cy;
  if (y > r || y < -r) {
    return 0;
  }
  const tmp = Math.sqrt(r * r - y * y);
  roots[0] = -tmp;
  roots[1] = tmp;
  const dTheta = Math.abs(startAngle - endAngle);
  if (dTheta < 1e-4) {
    return 0;
  }
  if (dTheta >= PI25 - 1e-4) {
    startAngle = 0;
    endAngle = PI25;
    const dir3 = anticlockwise ? 1 : -1;
    if (x >= roots[0] + cx && x <= roots[1] + cx) {
      return dir3;
    } else {
      return 0;
    }
  }
  if (startAngle > endAngle) {
    const tmp2 = startAngle;
    startAngle = endAngle;
    endAngle = tmp2;
  }
  if (startAngle < 0) {
    startAngle += PI25;
    endAngle += PI25;
  }
  let w = 0;
  for (let i = 0; i < 2; i++) {
    const x_ = roots[i];
    if (x_ + cx > x) {
      let angle = Math.atan2(y, x_);
      let dir3 = anticlockwise ? 1 : -1;
      if (angle < 0) {
        angle = PI25 + angle;
      }
      if (angle >= startAngle && angle <= endAngle || angle + PI25 >= startAngle && angle + PI25 <= endAngle) {
        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
          dir3 = -dir3;
        }
        w += dir3;
      }
    }
  }
  return w;
}
function containPath(path, lineWidth, isStroke, x, y) {
  const data = path.data;
  const len2 = path.len();
  let w = 0;
  let xi = 0;
  let yi = 0;
  let x0 = 0;
  let y0 = 0;
  let x1;
  let y1;
  for (let i = 0; i < len2; ) {
    const cmd = data[i++];
    const isFirst = i === 1;
    if (cmd === CMD2.M && i > 1) {
      if (!isStroke) {
        w += windingLine(xi, yi, x0, y0, x, y);
      }
    }
    if (isFirst) {
      xi = data[i];
      yi = data[i + 1];
      x0 = xi;
      y0 = yi;
    }
    switch (cmd) {
      case CMD2.M:
        x0 = data[i++];
        y0 = data[i++];
        xi = x0;
        yi = y0;
        break;
      case CMD2.L:
        if (isStroke) {
          if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
        }
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD2.C:
        if (isStroke) {
          if (containStroke2(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
        }
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD2.Q:
        if (isStroke) {
          if (containStroke3(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
        }
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD2.A:
        const cx = data[i++];
        const cy = data[i++];
        const rx = data[i++];
        const ry = data[i++];
        const theta = data[i++];
        const dTheta = data[i++];
        i += 1;
        const anticlockwise = !!(1 - data[i++]);
        x1 = Math.cos(theta) * rx + cx;
        y1 = Math.sin(theta) * ry + cy;
        if (!isFirst) {
          w += windingLine(xi, yi, x1, y1, x, y);
        } else {
          x0 = x1;
          y0 = y1;
        }
        const _x = (x - cx) * ry / rx + cx;
        if (isStroke) {
          if (containStroke4(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
            return true;
          }
        } else {
          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
        }
        xi = Math.cos(theta + dTheta) * rx + cx;
        yi = Math.sin(theta + dTheta) * ry + cy;
        break;
      case CMD2.R:
        x0 = xi = data[i++];
        y0 = yi = data[i++];
        const width = data[i++];
        const height = data[i++];
        x1 = x0 + width;
        y1 = y0 + height;
        if (isStroke) {
          if (containStroke(x0, y0, x1, y0, lineWidth, x, y) || containStroke(x1, y0, x1, y1, lineWidth, x, y) || containStroke(x1, y1, x0, y1, lineWidth, x, y) || containStroke(x0, y1, x0, y0, lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingLine(x1, y0, x1, y1, x, y);
          w += windingLine(x0, y1, x0, y0, x, y);
        }
        break;
      case CMD2.Z:
        if (isStroke) {
          if (containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingLine(xi, yi, x0, y0, x, y);
        }
        xi = x0;
        yi = y0;
        break;
    }
  }
  if (!isStroke && !isAroundEqual(yi, y0)) {
    w += windingLine(xi, yi, x0, y0, x, y) || 0;
  }
  return w !== 0;
}
function contain(pathProxy, x, y) {
  return containPath(pathProxy, 0, false, x, y);
}
function containStroke5(pathProxy, lineWidth, x, y) {
  return containPath(pathProxy, lineWidth, true, x, y);
}

// ../zrender/src/graphic/Path.ts
var DEFAULT_PATH_STYLE = defaults({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: false,
  strokeFirst: false
}, DEFAULT_COMMON_STYLE);
var DEFAULT_PATH_ANIMATION_PROPS = {
  style: defaults({
    fill: true,
    stroke: true,
    strokePercent: true,
    fillOpacity: true,
    strokeOpacity: true,
    lineDashOffset: true,
    lineWidth: true,
    miterLimit: true
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
var pathCopyParams = TRANSFORMABLE_PROPS.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]);
var Path2 = class extends Displayable_default {
  constructor(opts) {
    super(opts);
  }
  update() {
    super.update();
    const style = this.style;
    if (style.decal) {
      const decalEl = this._decalEl = this._decalEl || new Path2();
      if (decalEl.buildPath === Path2.prototype.buildPath) {
        decalEl.buildPath = (ctx) => {
          this.buildPath(ctx, this.shape);
        };
      }
      decalEl.silent = true;
      const decalElStyle = decalEl.style;
      for (let key in style) {
        if (decalElStyle[key] !== style[key]) {
          decalElStyle[key] = style[key];
        }
      }
      decalElStyle.fill = style.fill ? style.decal : null;
      decalElStyle.decal = null;
      decalElStyle.shadowColor = null;
      style.strokeFirst && (decalElStyle.stroke = null);
      for (let i = 0; i < pathCopyParams.length; ++i) {
        decalEl[pathCopyParams[i]] = this[pathCopyParams[i]];
      }
      decalEl.__dirty |= REDRAW_BIT;
    } else if (this._decalEl) {
      this._decalEl = null;
    }
  }
  getDecalElement() {
    return this._decalEl;
  }
  _init(props) {
    const keysArr = keys(props);
    this.shape = this.getDefaultShape();
    const defaultStyle = this.getDefaultStyle();
    if (defaultStyle) {
      this.useStyle(defaultStyle);
    }
    for (let i = 0; i < keysArr.length; i++) {
      const key = keysArr[i];
      const value = props[key];
      if (key === "style") {
        if (!this.style) {
          this.useStyle(value);
        } else {
          extend(this.style, value);
        }
      } else if (key === "shape") {
        extend(this.shape, value);
      } else {
        super.attrKV(key, value);
      }
    }
    if (!this.style) {
      this.useStyle({});
    }
  }
  getDefaultStyle() {
    return null;
  }
  getDefaultShape() {
    return {};
  }
  canBeInsideText() {
    return this.hasFill();
  }
  getInsideTextFill() {
    const pathFill = this.style.fill;
    if (pathFill !== "none") {
      if (isString(pathFill)) {
        const fillLum = lum(pathFill, 0);
        if (fillLum > 0.5) {
          return DARK_LABEL_COLOR;
        } else if (fillLum > 0.2) {
          return LIGHTER_LABEL_COLOR;
        }
        return LIGHT_LABEL_COLOR;
      } else if (pathFill) {
        return LIGHT_LABEL_COLOR;
      }
    }
    return DARK_LABEL_COLOR;
  }
  getInsideTextStroke(textFill) {
    const pathFill = this.style.fill;
    if (isString(pathFill)) {
      const zr = this.__zr;
      const isDarkMode2 = !!(zr && zr.isDarkMode());
      const isDarkLabel = lum(textFill, 0) < DARK_MODE_THRESHOLD;
      if (isDarkMode2 === isDarkLabel) {
        return pathFill;
      }
    }
  }
  buildPath(ctx, shapeCfg, inBatch) {
  }
  pathUpdated() {
    this.__dirty &= ~SHAPE_CHANGED_BIT;
  }
  getUpdatedPathProxy(inBatch) {
    !this.path && this.createPathProxy();
    this.path.beginPath();
    this.buildPath(this.path, this.shape, inBatch);
    return this.path;
  }
  createPathProxy() {
    this.path = new PathProxy_default(false);
  }
  hasStroke() {
    const style = this.style;
    const stroke = style.stroke;
    return !(stroke == null || stroke === "none" || !(style.lineWidth > 0));
  }
  hasFill() {
    const style = this.style;
    const fill = style.fill;
    return fill != null && fill !== "none";
  }
  getBoundingRect() {
    let rect = this._rect;
    const style = this.style;
    const needsUpdateRect = !rect;
    if (needsUpdateRect) {
      let firstInvoke = false;
      if (!this.path) {
        firstInvoke = true;
        this.createPathProxy();
      }
      let path = this.path;
      if (firstInvoke || this.__dirty & SHAPE_CHANGED_BIT) {
        path.beginPath();
        this.buildPath(path, this.shape, false);
        this.pathUpdated();
      }
      rect = path.getBoundingRect();
    }
    this._rect = rect;
    if (this.hasStroke() && this.path && this.path.len() > 0) {
      const rectStroke = this._rectStroke || (this._rectStroke = rect.clone());
      if (this.__dirty || needsUpdateRect) {
        rectStroke.copy(rect);
        const lineScale = style.strokeNoScale ? this.getLineScale() : 1;
        let w = style.lineWidth;
        if (!this.hasFill()) {
          const strokeContainThreshold = this.strokeContainThreshold;
          w = Math.max(w, strokeContainThreshold == null ? 4 : strokeContainThreshold);
        }
        if (lineScale > 1e-10) {
          rectStroke.width += w / lineScale;
          rectStroke.height += w / lineScale;
          rectStroke.x -= w / lineScale / 2;
          rectStroke.y -= w / lineScale / 2;
        }
      }
      return rectStroke;
    }
    return rect;
  }
  contain(x, y) {
    const localPos = this.transformCoordToLocal(x, y);
    const rect = this.getBoundingRect();
    const style = this.style;
    x = localPos[0];
    y = localPos[1];
    if (rect.contain(x, y)) {
      const pathProxy = this.path;
      if (this.hasStroke()) {
        let lineWidth = style.lineWidth;
        let lineScale = style.strokeNoScale ? this.getLineScale() : 1;
        if (lineScale > 1e-10) {
          if (!this.hasFill()) {
            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
          }
          if (containStroke5(pathProxy, lineWidth / lineScale, x, y)) {
            return true;
          }
        }
      }
      if (this.hasFill()) {
        return contain(pathProxy, x, y);
      }
    }
    return false;
  }
  dirtyShape() {
    this.__dirty |= SHAPE_CHANGED_BIT;
    if (this._rect) {
      this._rect = null;
    }
    if (this._decalEl) {
      this._decalEl.dirtyShape();
    }
    this.markRedraw();
  }
  dirty() {
    this.dirtyStyle();
    this.dirtyShape();
  }
  animateShape(loop) {
    return this.animate("shape", loop);
  }
  updateDuringAnimation(targetKey) {
    if (targetKey === "style") {
      this.dirtyStyle();
    } else if (targetKey === "shape") {
      this.dirtyShape();
    } else {
      this.markRedraw();
    }
  }
  attrKV(key, value) {
    if (key === "shape") {
      this.setShape(value);
    } else {
      super.attrKV(key, value);
    }
  }
  setShape(keyOrObj, value) {
    let shape = this.shape;
    if (!shape) {
      shape = this.shape = {};
    }
    if (typeof keyOrObj === "string") {
      shape[keyOrObj] = value;
    } else {
      extend(shape, keyOrObj);
    }
    this.dirtyShape();
    return this;
  }
  shapeChanged() {
    return !!(this.__dirty & SHAPE_CHANGED_BIT);
  }
  createStyle(obj) {
    return createObject(DEFAULT_PATH_STYLE, obj);
  }
  _innerSaveToNormal(toState) {
    super._innerSaveToNormal(toState);
    const normalState = this._normalState;
    if (toState.shape && !normalState.shape) {
      normalState.shape = extend({}, this.shape);
    }
  }
  _applyStateObj(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
    super._applyStateObj(stateName, state, normalState, keepCurrentStates, transition, animationCfg);
    const needsRestoreToNormal = !(state && keepCurrentStates);
    let targetShape;
    if (state && state.shape) {
      if (transition) {
        if (keepCurrentStates) {
          targetShape = state.shape;
        } else {
          targetShape = extend({}, normalState.shape);
          extend(targetShape, state.shape);
        }
      } else {
        targetShape = extend({}, keepCurrentStates ? this.shape : normalState.shape);
        extend(targetShape, state.shape);
      }
    } else if (needsRestoreToNormal) {
      targetShape = normalState.shape;
    }
    if (targetShape) {
      if (transition) {
        this.shape = extend({}, this.shape);
        const targetShapePrimaryProps = {};
        const shapeKeys = keys(targetShape);
        for (let i = 0; i < shapeKeys.length; i++) {
          const key = shapeKeys[i];
          if (typeof targetShape[key] === "object") {
            this.shape[key] = targetShape[key];
          } else {
            targetShapePrimaryProps[key] = targetShape[key];
          }
        }
        this._transitionState(stateName, {
          shape: targetShapePrimaryProps
        }, animationCfg);
      } else {
        this.shape = targetShape;
        this.dirtyShape();
      }
    }
  }
  _mergeStates(states) {
    const mergedState = super._mergeStates(states);
    let mergedShape;
    for (let i = 0; i < states.length; i++) {
      const state = states[i];
      if (state.shape) {
        mergedShape = mergedShape || {};
        this._mergeStyle(mergedShape, state.shape);
      }
    }
    if (mergedShape) {
      mergedState.shape = mergedShape;
    }
    return mergedState;
  }
  getAnimationStyleProps() {
    return DEFAULT_PATH_ANIMATION_PROPS;
  }
  isZeroArea() {
    return false;
  }
  static extend(defaultProps) {
    class Sub extends Path2 {
      getDefaultStyle() {
        return clone(defaultProps.style);
      }
      getDefaultShape() {
        return clone(defaultProps.shape);
      }
      constructor(opts) {
        super(opts);
        defaultProps.init && defaultProps.init.call(this, opts);
      }
    }
    for (let key in defaultProps) {
      if (typeof defaultProps[key] === "function") {
        Sub.prototype[key] = defaultProps[key];
      }
    }
    return Sub;
  }
};
var Path = Path2;
Path.initDefaultProps = function() {
  const pathProto = Path2.prototype;
  pathProto.type = "path";
  pathProto.strokeContainThreshold = 5;
  pathProto.segmentIgnoreThreshold = 0;
  pathProto.subPixelOptimize = false;
  pathProto.autoBatch = false;
  pathProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT | SHAPE_CHANGED_BIT;
}();
var Path_default = Path;

// ../zrender/src/graphic/TSpan.ts
var DEFAULT_TSPAN_STYLE = defaults({
  strokeFirst: true,
  font: DEFAULT_FONT,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, DEFAULT_PATH_STYLE);
var TSpan2 = class extends Displayable_default {
  hasStroke() {
    const style = this.style;
    const stroke = style.stroke;
    return stroke != null && stroke !== "none" && style.lineWidth > 0;
  }
  hasFill() {
    const style = this.style;
    const fill = style.fill;
    return fill != null && fill !== "none";
  }
  createStyle(obj) {
    return createObject(DEFAULT_TSPAN_STYLE, obj);
  }
  setBoundingRect(rect) {
    this._rect = rect;
  }
  getBoundingRect() {
    const style = this.style;
    if (!this._rect) {
      let text = style.text;
      text != null ? text += "" : text = "";
      const rect = getBoundingRect(text, style.font, style.textAlign, style.textBaseline);
      rect.x += style.x || 0;
      rect.y += style.y || 0;
      if (this.hasStroke()) {
        const w = style.lineWidth;
        rect.x -= w / 2;
        rect.y -= w / 2;
        rect.width += w;
        rect.height += w;
      }
      this._rect = rect;
    }
    return this._rect;
  }
};
var TSpan = TSpan2;
TSpan.initDefaultProps = function() {
  const tspanProto = TSpan2.prototype;
  tspanProto.dirtyRectTolerance = 10;
}();
TSpan.prototype.type = "tspan";
var TSpan_default = TSpan;

// ../zrender/src/graphic/Image.ts
var DEFAULT_IMAGE_STYLE = defaults({
  x: 0,
  y: 0
}, DEFAULT_COMMON_STYLE);
var DEFAULT_IMAGE_ANIMATION_PROPS = {
  style: defaults({
    x: true,
    y: true,
    width: true,
    height: true,
    sx: true,
    sy: true,
    sWidth: true,
    sHeight: true
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
function isImageLike(source) {
  return !!(source && typeof source !== "string" && source.width && source.height);
}
var ZRImage = class extends Displayable_default {
  createStyle(obj) {
    return createObject(DEFAULT_IMAGE_STYLE, obj);
  }
  _getSize(dim) {
    const style = this.style;
    let size = style[dim];
    if (size != null) {
      return size;
    }
    const imageSource = isImageLike(style.image) ? style.image : this.__image;
    if (!imageSource) {
      return 0;
    }
    const otherDim = dim === "width" ? "height" : "width";
    let otherDimSize = style[otherDim];
    if (otherDimSize == null) {
      return imageSource[dim];
    } else {
      return imageSource[dim] / imageSource[otherDim] * otherDimSize;
    }
  }
  getWidth() {
    return this._getSize("width");
  }
  getHeight() {
    return this._getSize("height");
  }
  getAnimationStyleProps() {
    return DEFAULT_IMAGE_ANIMATION_PROPS;
  }
  getBoundingRect() {
    const style = this.style;
    if (!this._rect) {
      this._rect = new BoundingRect_default(style.x || 0, style.y || 0, this.getWidth(), this.getHeight());
    }
    return this._rect;
  }
};
ZRImage.prototype.type = "image";
var Image_default = ZRImage;

// ../zrender/src/graphic/helper/roundRect.ts
function buildPath(ctx, shape) {
  let x = shape.x;
  let y = shape.y;
  let width = shape.width;
  let height = shape.height;
  let r = shape.r;
  let r1;
  let r2;
  let r3;
  let r4;
  if (width < 0) {
    x = x + width;
    width = -width;
  }
  if (height < 0) {
    y = y + height;
    height = -height;
  }
  if (typeof r === "number") {
    r1 = r2 = r3 = r4 = r;
  } else if (r instanceof Array) {
    if (r.length === 1) {
      r1 = r2 = r3 = r4 = r[0];
    } else if (r.length === 2) {
      r1 = r3 = r[0];
      r2 = r4 = r[1];
    } else if (r.length === 3) {
      r1 = r[0];
      r2 = r4 = r[1];
      r3 = r[2];
    } else {
      r1 = r[0];
      r2 = r[1];
      r3 = r[2];
      r4 = r[3];
    }
  } else {
    r1 = r2 = r3 = r4 = 0;
  }
  let total;
  if (r1 + r2 > width) {
    total = r1 + r2;
    r1 *= width / total;
    r2 *= width / total;
  }
  if (r3 + r4 > width) {
    total = r3 + r4;
    r3 *= width / total;
    r4 *= width / total;
  }
  if (r2 + r3 > height) {
    total = r2 + r3;
    r2 *= height / total;
    r3 *= height / total;
  }
  if (r1 + r4 > height) {
    total = r1 + r4;
    r1 *= height / total;
    r4 *= height / total;
  }
  ctx.moveTo(x + r1, y);
  ctx.lineTo(x + width - r2, y);
  r2 !== 0 && ctx.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
  ctx.lineTo(x + width, y + height - r3);
  r3 !== 0 && ctx.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
  ctx.lineTo(x + r4, y + height);
  r4 !== 0 && ctx.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
  ctx.lineTo(x, y + r1);
  r1 !== 0 && ctx.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
}

// ../zrender/src/graphic/helper/subPixelOptimize.ts
var round2 = Math.round;
function subPixelOptimizeLine(outputShape, inputShape, style) {
  if (!inputShape) {
    return;
  }
  const x1 = inputShape.x1;
  const x2 = inputShape.x2;
  const y1 = inputShape.y1;
  const y2 = inputShape.y2;
  outputShape.x1 = x1;
  outputShape.x2 = x2;
  outputShape.y1 = y1;
  outputShape.y2 = y2;
  const lineWidth = style && style.lineWidth;
  if (!lineWidth) {
    return outputShape;
  }
  if (round2(x1 * 2) === round2(x2 * 2)) {
    outputShape.x1 = outputShape.x2 = subPixelOptimize(x1, lineWidth, true);
  }
  if (round2(y1 * 2) === round2(y2 * 2)) {
    outputShape.y1 = outputShape.y2 = subPixelOptimize(y1, lineWidth, true);
  }
  return outputShape;
}
function subPixelOptimizeRect(outputShape, inputShape, style) {
  if (!inputShape) {
    return;
  }
  const originX = inputShape.x;
  const originY = inputShape.y;
  const originWidth = inputShape.width;
  const originHeight = inputShape.height;
  outputShape.x = originX;
  outputShape.y = originY;
  outputShape.width = originWidth;
  outputShape.height = originHeight;
  const lineWidth = style && style.lineWidth;
  if (!lineWidth) {
    return outputShape;
  }
  outputShape.x = subPixelOptimize(originX, lineWidth, true);
  outputShape.y = subPixelOptimize(originY, lineWidth, true);
  outputShape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);
  outputShape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);
  return outputShape;
}
function subPixelOptimize(position2, lineWidth, positiveOrNegative) {
  if (!lineWidth) {
    return position2;
  }
  const doubledPosition = round2(position2 * 2);
  return (doubledPosition + round2(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
}

// ../zrender/src/graphic/shape/Rect.ts
var RectShape = class {
  constructor() {
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
  }
};
var subPixelOptimizeOutputShape = {};
var Rect = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultShape() {
    return new RectShape();
  }
  buildPath(ctx, shape) {
    let x;
    let y;
    let width;
    let height;
    if (this.subPixelOptimize) {
      const optimizedShape = subPixelOptimizeRect(subPixelOptimizeOutputShape, shape, this.style);
      x = optimizedShape.x;
      y = optimizedShape.y;
      width = optimizedShape.width;
      height = optimizedShape.height;
      optimizedShape.r = shape.r;
      shape = optimizedShape;
    } else {
      x = shape.x;
      y = shape.y;
      width = shape.width;
      height = shape.height;
    }
    if (!shape.r) {
      ctx.rect(x, y, width, height);
    } else {
      buildPath(ctx, shape);
    }
  }
  isZeroArea() {
    return !this.shape.width || !this.shape.height;
  }
};
Rect.prototype.type = "rect";
var Rect_default = Rect;

// ../zrender/src/graphic/Text.ts
var DEFAULT_RICH_TEXT_COLOR = {
  fill: "#000"
};
var DEFAULT_STROKE_LINE_WIDTH = 2;
var tmpCITOverflowAreaOut = {};
var DEFAULT_TEXT_ANIMATION_PROPS = {
  style: defaults({
    fill: true,
    stroke: true,
    fillOpacity: true,
    strokeOpacity: true,
    lineWidth: true,
    fontSize: true,
    lineHeight: true,
    width: true,
    height: true,
    textShadowColor: true,
    textShadowBlur: true,
    textShadowOffsetX: true,
    textShadowOffsetY: true,
    backgroundColor: true,
    padding: true,
    borderColor: true,
    borderWidth: true,
    borderRadius: true
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
var ZRText = class extends Displayable_default {
  constructor(opts) {
    super();
    this.type = "text";
    this._children = [];
    this._defaultStyle = DEFAULT_RICH_TEXT_COLOR;
    this.attr(opts);
  }
  childrenRef() {
    return this._children;
  }
  update() {
    super.update();
    if (this.styleChanged()) {
      this._updateSubTexts();
    }
    for (let i = 0; i < this._children.length; i++) {
      const child = this._children[i];
      child.zlevel = this.zlevel;
      child.z = this.z;
      child.z2 = this.z2;
      child.culling = this.culling;
      child.cursor = this.cursor;
      child.invisible = this.invisible;
    }
  }
  updateTransform() {
    const innerTransformable = this.innerTransformable;
    if (innerTransformable) {
      innerTransformable.updateTransform();
      if (innerTransformable.transform) {
        this.transform = innerTransformable.transform;
      }
    } else {
      super.updateTransform();
    }
  }
  getLocalTransform(m2) {
    const innerTransformable = this.innerTransformable;
    return innerTransformable ? innerTransformable.getLocalTransform(m2) : super.getLocalTransform(m2);
  }
  getComputedTransform() {
    if (this.__hostTarget) {
      this.__hostTarget.getComputedTransform();
      this.__hostTarget.updateInnerText(true);
    }
    return super.getComputedTransform();
  }
  _updateSubTexts() {
    this._childCursor = 0;
    normalizeTextStyle(this.style);
    this.style.rich ? this._updateRichTexts() : this._updatePlainTexts();
    this._children.length = this._childCursor;
    this.styleUpdated();
  }
  addSelfToZr(zr) {
    super.addSelfToZr(zr);
    for (let i = 0; i < this._children.length; i++) {
      this._children[i].__zr = zr;
    }
  }
  removeSelfFromZr(zr) {
    super.removeSelfFromZr(zr);
    for (let i = 0; i < this._children.length; i++) {
      this._children[i].__zr = null;
    }
  }
  getBoundingRect() {
    if (this.styleChanged()) {
      this._updateSubTexts();
    }
    if (!this._rect) {
      const tmpRect3 = new BoundingRect_default(0, 0, 0, 0);
      const children = this._children;
      const tmpMat = [];
      let rect = null;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        const childRect = child.getBoundingRect();
        const transform2 = child.getLocalTransform(tmpMat);
        if (transform2) {
          tmpRect3.copy(childRect);
          tmpRect3.applyTransform(transform2);
          rect = rect || tmpRect3.clone();
          rect.union(tmpRect3);
        } else {
          rect = rect || childRect.clone();
          rect.union(childRect);
        }
      }
      this._rect = rect || tmpRect3;
    }
    return this._rect;
  }
  setDefaultTextStyle(defaultTextStyle) {
    this._defaultStyle = defaultTextStyle || DEFAULT_RICH_TEXT_COLOR;
  }
  setTextContent(textContent) {
    if (true) {
      throw new Error("Can't attach text on another text");
    }
  }
  _mergeStyle(targetStyle, sourceStyle) {
    if (!sourceStyle) {
      return targetStyle;
    }
    const sourceRich = sourceStyle.rich;
    const targetRich = targetStyle.rich || sourceRich && {};
    extend(targetStyle, sourceStyle);
    if (sourceRich && targetRich) {
      this._mergeRich(targetRich, sourceRich);
      targetStyle.rich = targetRich;
    } else if (targetRich) {
      targetStyle.rich = targetRich;
    }
    return targetStyle;
  }
  _mergeRich(targetRich, sourceRich) {
    const richNames = keys(sourceRich);
    for (let i = 0; i < richNames.length; i++) {
      const richName = richNames[i];
      targetRich[richName] = targetRich[richName] || {};
      extend(targetRich[richName], sourceRich[richName]);
    }
  }
  getAnimationStyleProps() {
    return DEFAULT_TEXT_ANIMATION_PROPS;
  }
  _getOrCreateChild(Ctor) {
    let child = this._children[this._childCursor];
    if (!child || !(child instanceof Ctor)) {
      child = new Ctor();
    }
    this._children[this._childCursor++] = child;
    child.__zr = this.__zr;
    child.parent = this;
    return child;
  }
  _updatePlainTexts() {
    const style = this.style;
    const textFont = style.font || DEFAULT_FONT;
    const textPadding = style.padding;
    const defaultStyle = this._defaultStyle;
    let baseX = style.x || 0;
    let baseY = style.y || 0;
    const textAlign = style.align || defaultStyle.align || "left";
    const verticalAlign = style.verticalAlign || defaultStyle.verticalAlign || "top";
    calcInnerTextOverflowArea(tmpCITOverflowAreaOut, defaultStyle.overflowRect, baseX, baseY, textAlign, verticalAlign);
    baseX = tmpCITOverflowAreaOut.baseX;
    baseY = tmpCITOverflowAreaOut.baseY;
    const text = getStyleText(style);
    const contentBlock = parsePlainText(text, style, tmpCITOverflowAreaOut.outerWidth, tmpCITOverflowAreaOut.outerHeight);
    const needDrawBg = needDrawBackground(style);
    const bgColorDrawn = !!style.backgroundColor;
    const outerHeight = contentBlock.outerHeight;
    const outerWidth = contentBlock.outerWidth;
    const contentWidth = contentBlock.contentWidth;
    const textLines = contentBlock.lines;
    const lineHeight = contentBlock.lineHeight;
    this.isTruncated = !!contentBlock.isTruncated;
    let textX = baseX;
    let textY = adjustTextY2(baseY, contentBlock.contentHeight, verticalAlign);
    if (needDrawBg || textPadding) {
      const boxX = adjustTextX(baseX, outerWidth, textAlign);
      const boxY = adjustTextY2(baseY, outerHeight, verticalAlign);
      needDrawBg && this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
    }
    textY += lineHeight / 2;
    if (textPadding) {
      textX = getTextXForPadding(baseX, textAlign, textPadding);
      if (verticalAlign === "top") {
        textY += textPadding[0];
      } else if (verticalAlign === "bottom") {
        textY -= textPadding[2];
      }
    }
    let defaultLineWidth = 0;
    let useDefaultFill = false;
    const textFill = getFill("fill" in style ? style.fill : (useDefaultFill = true, defaultStyle.fill));
    const textStroke = getStroke("stroke" in style ? style.stroke : !bgColorDrawn && (!defaultStyle.autoStroke || useDefaultFill) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke) : null);
    const hasShadow2 = style.textShadowBlur > 0;
    const fixedBoundingRect = style.width != null && (style.overflow === "truncate" || style.overflow === "break" || style.overflow === "breakAll");
    const calculatedLineHeight = contentBlock.calculatedLineHeight;
    for (let i = 0; i < textLines.length; i++) {
      const el = this._getOrCreateChild(TSpan_default);
      const subElStyle = el.createStyle();
      el.useStyle(subElStyle);
      subElStyle.text = textLines[i];
      subElStyle.x = textX;
      subElStyle.y = textY;
      if (textAlign) {
        subElStyle.textAlign = textAlign;
      }
      subElStyle.textBaseline = "middle";
      subElStyle.opacity = style.opacity;
      subElStyle.strokeFirst = true;
      if (hasShadow2) {
        subElStyle.shadowBlur = style.textShadowBlur || 0;
        subElStyle.shadowColor = style.textShadowColor || "transparent";
        subElStyle.shadowOffsetX = style.textShadowOffsetX || 0;
        subElStyle.shadowOffsetY = style.textShadowOffsetY || 0;
      }
      subElStyle.stroke = textStroke;
      subElStyle.fill = textFill;
      if (textStroke) {
        subElStyle.lineWidth = style.lineWidth || defaultLineWidth;
        subElStyle.lineDash = style.lineDash;
        subElStyle.lineDashOffset = style.lineDashOffset || 0;
      }
      subElStyle.font = textFont;
      setSeparateFont(subElStyle, style);
      textY += lineHeight;
      if (fixedBoundingRect) {
        el.setBoundingRect(new BoundingRect_default(adjustTextX(subElStyle.x, contentWidth, subElStyle.textAlign), adjustTextY2(subElStyle.y, calculatedLineHeight, subElStyle.textBaseline), contentWidth, calculatedLineHeight));
      }
    }
  }
  _updateRichTexts() {
    const style = this.style;
    const defaultStyle = this._defaultStyle;
    const textAlign = style.align || defaultStyle.align;
    const verticalAlign = style.verticalAlign || defaultStyle.verticalAlign;
    let baseX = style.x || 0;
    let baseY = style.y || 0;
    calcInnerTextOverflowArea(tmpCITOverflowAreaOut, defaultStyle.overflowRect, baseX, baseY, textAlign, verticalAlign);
    baseX = tmpCITOverflowAreaOut.baseX;
    baseY = tmpCITOverflowAreaOut.baseY;
    const text = getStyleText(style);
    const contentBlock = parseRichText(text, style, tmpCITOverflowAreaOut.outerWidth, tmpCITOverflowAreaOut.outerHeight, textAlign);
    const contentWidth = contentBlock.width;
    const outerWidth = contentBlock.outerWidth;
    const outerHeight = contentBlock.outerHeight;
    const textPadding = style.padding;
    this.isTruncated = !!contentBlock.isTruncated;
    const boxX = adjustTextX(baseX, outerWidth, textAlign);
    const boxY = adjustTextY2(baseY, outerHeight, verticalAlign);
    let xLeft = boxX;
    let lineTop = boxY;
    if (textPadding) {
      xLeft += textPadding[3];
      lineTop += textPadding[0];
    }
    let xRight = xLeft + contentWidth;
    if (needDrawBackground(style)) {
      this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
    }
    const bgColorDrawn = !!style.backgroundColor;
    for (let i = 0; i < contentBlock.lines.length; i++) {
      const line2 = contentBlock.lines[i];
      const tokens2 = line2.tokens;
      const tokenCount = tokens2.length;
      const lineHeight = line2.lineHeight;
      let remainedWidth = line2.width;
      let leftIndex = 0;
      let lineXLeft = xLeft;
      let lineXRight = xRight;
      let rightIndex = tokenCount - 1;
      let token;
      while (leftIndex < tokenCount && (token = tokens2[leftIndex], !token.align || token.align === "left")) {
        this._placeToken(token, style, lineHeight, lineTop, lineXLeft, "left", bgColorDrawn);
        remainedWidth -= token.width;
        lineXLeft += token.width;
        leftIndex++;
      }
      while (rightIndex >= 0 && (token = tokens2[rightIndex], token.align === "right")) {
        this._placeToken(token, style, lineHeight, lineTop, lineXRight, "right", bgColorDrawn);
        remainedWidth -= token.width;
        lineXRight -= token.width;
        rightIndex--;
      }
      lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - remainedWidth) / 2;
      while (leftIndex <= rightIndex) {
        token = tokens2[leftIndex];
        this._placeToken(token, style, lineHeight, lineTop, lineXLeft + token.width / 2, "center", bgColorDrawn);
        lineXLeft += token.width;
        leftIndex++;
      }
      lineTop += lineHeight;
    }
  }
  _placeToken(token, style, lineHeight, lineTop, x, textAlign, parentBgColorDrawn) {
    const tokenStyle = style.rich[token.styleName] || {};
    tokenStyle.text = token.text;
    const verticalAlign = token.verticalAlign;
    let y = lineTop + lineHeight / 2;
    if (verticalAlign === "top") {
      y = lineTop + token.height / 2;
    } else if (verticalAlign === "bottom") {
      y = lineTop + lineHeight - token.height / 2;
    }
    const needDrawBg = !token.isLineHolder && needDrawBackground(tokenStyle);
    needDrawBg && this._renderBackground(tokenStyle, style, textAlign === "right" ? x - token.width : textAlign === "center" ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);
    const bgColorDrawn = !!tokenStyle.backgroundColor;
    const textPadding = token.textPadding;
    if (textPadding) {
      x = getTextXForPadding(x, textAlign, textPadding);
      y -= token.height / 2 - textPadding[0] - token.innerHeight / 2;
    }
    const el = this._getOrCreateChild(TSpan_default);
    const subElStyle = el.createStyle();
    el.useStyle(subElStyle);
    const defaultStyle = this._defaultStyle;
    let useDefaultFill = false;
    let defaultLineWidth = 0;
    const textFill = getFill("fill" in tokenStyle ? tokenStyle.fill : "fill" in style ? style.fill : (useDefaultFill = true, defaultStyle.fill));
    const textStroke = getStroke("stroke" in tokenStyle ? tokenStyle.stroke : "stroke" in style ? style.stroke : !bgColorDrawn && !parentBgColorDrawn && (!defaultStyle.autoStroke || useDefaultFill) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke) : null);
    const hasShadow2 = tokenStyle.textShadowBlur > 0 || style.textShadowBlur > 0;
    subElStyle.text = token.text;
    subElStyle.x = x;
    subElStyle.y = y;
    if (hasShadow2) {
      subElStyle.shadowBlur = tokenStyle.textShadowBlur || style.textShadowBlur || 0;
      subElStyle.shadowColor = tokenStyle.textShadowColor || style.textShadowColor || "transparent";
      subElStyle.shadowOffsetX = tokenStyle.textShadowOffsetX || style.textShadowOffsetX || 0;
      subElStyle.shadowOffsetY = tokenStyle.textShadowOffsetY || style.textShadowOffsetY || 0;
    }
    subElStyle.textAlign = textAlign;
    subElStyle.textBaseline = "middle";
    subElStyle.font = token.font || DEFAULT_FONT;
    subElStyle.opacity = retrieve3(tokenStyle.opacity, style.opacity, 1);
    setSeparateFont(subElStyle, tokenStyle);
    if (textStroke) {
      subElStyle.lineWidth = retrieve3(tokenStyle.lineWidth, style.lineWidth, defaultLineWidth);
      subElStyle.lineDash = retrieve2(tokenStyle.lineDash, style.lineDash);
      subElStyle.lineDashOffset = style.lineDashOffset || 0;
      subElStyle.stroke = textStroke;
    }
    if (textFill) {
      subElStyle.fill = textFill;
    }
    const textWidth = token.contentWidth;
    const textHeight = token.contentHeight;
    el.setBoundingRect(new BoundingRect_default(adjustTextX(subElStyle.x, textWidth, subElStyle.textAlign), adjustTextY2(subElStyle.y, textHeight, subElStyle.textBaseline), textWidth, textHeight));
  }
  _renderBackground(style, topStyle, x, y, width, height) {
    const textBackgroundColor = style.backgroundColor;
    const textBorderWidth = style.borderWidth;
    const textBorderColor = style.borderColor;
    const isImageBg = textBackgroundColor && textBackgroundColor.image;
    const isPlainOrGradientBg = textBackgroundColor && !isImageBg;
    const textBorderRadius = style.borderRadius;
    const self2 = this;
    let rectEl;
    let imgEl;
    if (isPlainOrGradientBg || style.lineHeight || textBorderWidth && textBorderColor) {
      rectEl = this._getOrCreateChild(Rect_default);
      rectEl.useStyle(rectEl.createStyle());
      rectEl.style.fill = null;
      const rectShape = rectEl.shape;
      rectShape.x = x;
      rectShape.y = y;
      rectShape.width = width;
      rectShape.height = height;
      rectShape.r = textBorderRadius;
      rectEl.dirtyShape();
    }
    if (isPlainOrGradientBg) {
      const rectStyle = rectEl.style;
      rectStyle.fill = textBackgroundColor || null;
      rectStyle.fillOpacity = retrieve2(style.fillOpacity, 1);
    } else if (isImageBg) {
      imgEl = this._getOrCreateChild(Image_default);
      imgEl.onload = function() {
        self2.dirtyStyle();
      };
      const imgStyle = imgEl.style;
      imgStyle.image = textBackgroundColor.image;
      imgStyle.x = x;
      imgStyle.y = y;
      imgStyle.width = width;
      imgStyle.height = height;
    }
    if (textBorderWidth && textBorderColor) {
      const rectStyle = rectEl.style;
      rectStyle.lineWidth = textBorderWidth;
      rectStyle.stroke = textBorderColor;
      rectStyle.strokeOpacity = retrieve2(style.strokeOpacity, 1);
      rectStyle.lineDash = style.borderDash;
      rectStyle.lineDashOffset = style.borderDashOffset || 0;
      rectEl.strokeContainThreshold = 0;
      if (rectEl.hasFill() && rectEl.hasStroke()) {
        rectStyle.strokeFirst = true;
        rectStyle.lineWidth *= 2;
      }
    }
    const commonStyle = (rectEl || imgEl).style;
    commonStyle.shadowBlur = style.shadowBlur || 0;
    commonStyle.shadowColor = style.shadowColor || "transparent";
    commonStyle.shadowOffsetX = style.shadowOffsetX || 0;
    commonStyle.shadowOffsetY = style.shadowOffsetY || 0;
    commonStyle.opacity = retrieve3(style.opacity, topStyle.opacity, 1);
  }
  static makeFont(style) {
    let font = "";
    if (hasSeparateFont(style)) {
      font = [
        style.fontStyle,
        style.fontWeight,
        parseFontSize(style.fontSize),
        style.fontFamily || "sans-serif"
      ].join(" ");
    }
    return font && trim(font) || style.textFont || style.font;
  }
};
var VALID_TEXT_ALIGN = {left: true, right: 1, center: 1};
var VALID_TEXT_VERTICAL_ALIGN = {top: 1, bottom: 1, middle: 1};
var FONT_PARTS = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function parseFontSize(fontSize) {
  if (typeof fontSize === "string" && (fontSize.indexOf("px") !== -1 || fontSize.indexOf("rem") !== -1 || fontSize.indexOf("em") !== -1)) {
    return fontSize;
  } else if (!isNaN(+fontSize)) {
    return fontSize + "px";
  } else {
    return DEFAULT_FONT_SIZE + "px";
  }
}
function setSeparateFont(targetStyle, sourceStyle) {
  for (let i = 0; i < FONT_PARTS.length; i++) {
    const fontProp = FONT_PARTS[i];
    const val = sourceStyle[fontProp];
    if (val != null) {
      targetStyle[fontProp] = val;
    }
  }
}
function hasSeparateFont(style) {
  return style.fontSize != null || style.fontFamily || style.fontWeight;
}
function normalizeTextStyle(style) {
  normalizeStyle(style);
  each(style.rich, normalizeStyle);
  return style;
}
function normalizeStyle(style) {
  if (style) {
    style.font = ZRText.makeFont(style);
    let textAlign = style.align;
    textAlign === "middle" && (textAlign = "center");
    style.align = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : "left";
    let verticalAlign = style.verticalAlign;
    verticalAlign === "center" && (verticalAlign = "middle");
    style.verticalAlign = verticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[verticalAlign] ? verticalAlign : "top";
    const textPadding = style.padding;
    if (textPadding) {
      style.padding = normalizeCssArray(style.padding);
    }
  }
}
function getStroke(stroke, lineWidth) {
  return stroke == null || lineWidth <= 0 || stroke === "transparent" || stroke === "none" ? null : stroke.image || stroke.colorStops ? "#000" : stroke;
}
function getFill(fill) {
  return fill == null || fill === "none" ? null : fill.image || fill.colorStops ? "#000" : fill;
}
function getTextXForPadding(x, textAlign, textPadding) {
  return textAlign === "right" ? x - textPadding[1] : textAlign === "center" ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
}
function getStyleText(style) {
  let text = style.text;
  text != null && (text += "");
  return text;
}
function needDrawBackground(style) {
  return !!(style.backgroundColor || style.lineHeight || style.borderWidth && style.borderColor);
}
var Text_default = ZRText;

// src/util/types.ts
var VISUAL_DIMENSIONS = createHashMap([
  "tooltip",
  "label",
  "itemName",
  "itemId",
  "itemGroupId",
  "itemChildGroupId",
  "seriesName"
]);
var SOURCE_FORMAT_ORIGINAL = "original";
var SOURCE_FORMAT_ARRAY_ROWS = "arrayRows";
var SOURCE_FORMAT_OBJECT_ROWS = "objectRows";
var SOURCE_FORMAT_KEYED_COLUMNS = "keyedColumns";
var SOURCE_FORMAT_TYPED_ARRAY = "typedArray";
var SOURCE_FORMAT_UNKNOWN = "unknown";
var SERIES_LAYOUT_BY_COLUMN = "column";
var SERIES_LAYOUT_BY_ROW = "row";
var LabelMarginType = {
  minMargin: 0,
  textMargin: 1
};

// src/util/innerStore.ts
var getECData = makeInner();
var setCommonECData = (seriesIndex, dataType, dataIdx, el) => {
  if (el) {
    const ecData = getECData(el);
    ecData.dataIndex = dataIdx;
    ecData.dataType = dataType;
    ecData.seriesIndex = seriesIndex;
    ecData.ssrType = "chart";
    if (el.type === "group") {
      el.traverse(function(child) {
        const childECData = getECData(child);
        childECData.seriesIndex = seriesIndex;
        childECData.dataIndex = dataIdx;
        childECData.dataType = dataType;
        childECData.ssrType = "chart";
      });
    }
  }
};

// src/util/states.ts
var _highlightNextDigit = 1;
var _highlightKeyMap = {};
var getSavedStates = makeInner();
var getComponentStates = makeInner();
var HOVER_STATE_NORMAL = 0;
var HOVER_STATE_BLUR = 1;
var HOVER_STATE_EMPHASIS = 2;
var SPECIAL_STATES = ["emphasis", "blur", "select"];
var DISPLAY_STATES = ["normal", "emphasis", "blur", "select"];
var Z2_EMPHASIS_LIFT = 10;
var Z2_SELECT_LIFT = 9;
var HIGHLIGHT_ACTION_TYPE = "highlight";
var DOWNPLAY_ACTION_TYPE = "downplay";
var SELECT_ACTION_TYPE = "select";
var UNSELECT_ACTION_TYPE = "unselect";
var TOGGLE_SELECT_ACTION_TYPE = "toggleSelect";
var SELECT_CHANGED_EVENT_TYPE = "selectchanged";
function hasFillOrStroke(fillOrStroke) {
  return fillOrStroke != null && fillOrStroke !== "none";
}
function doChangeHoverState(el, stateName, hoverStateEnum) {
  if (el.onHoverStateChange && (el.hoverState || 0) !== hoverStateEnum) {
    el.onHoverStateChange(stateName);
  }
  el.hoverState = hoverStateEnum;
}
function singleEnterEmphasis(el) {
  doChangeHoverState(el, "emphasis", HOVER_STATE_EMPHASIS);
}
function singleLeaveEmphasis(el) {
  if (el.hoverState === HOVER_STATE_EMPHASIS) {
    doChangeHoverState(el, "normal", HOVER_STATE_NORMAL);
  }
}
function singleEnterBlur(el) {
  doChangeHoverState(el, "blur", HOVER_STATE_BLUR);
}
function singleLeaveBlur(el) {
  if (el.hoverState === HOVER_STATE_BLUR) {
    doChangeHoverState(el, "normal", HOVER_STATE_NORMAL);
  }
}
function singleEnterSelect(el) {
  el.selected = true;
}
function singleLeaveSelect(el) {
  el.selected = false;
}
function updateElementState(el, updater, commonParam) {
  updater(el, commonParam);
}
function traverseUpdateState(el, updater, commonParam) {
  updateElementState(el, updater, commonParam);
  el.isGroup && el.traverse(function(child) {
    updateElementState(child, updater, commonParam);
  });
}
function setStatesFlag(el, stateName) {
  switch (stateName) {
    case "emphasis":
      el.hoverState = HOVER_STATE_EMPHASIS;
      break;
    case "normal":
      el.hoverState = HOVER_STATE_NORMAL;
      break;
    case "blur":
      el.hoverState = HOVER_STATE_BLUR;
      break;
    case "select":
      el.selected = true;
  }
}
function getFromStateStyle(el, props, toStateName, defaultValue) {
  const style = el.style;
  const fromState = {};
  for (let i = 0; i < props.length; i++) {
    const propName = props[i];
    const val = style[propName];
    fromState[propName] = val == null ? defaultValue && defaultValue[propName] : val;
  }
  for (let i = 0; i < el.animators.length; i++) {
    const animator = el.animators[i];
    if (animator.__fromStateTransition && animator.__fromStateTransition.indexOf(toStateName) < 0 && animator.targetName === "style") {
      animator.saveTo(fromState, props);
    }
  }
  return fromState;
}
function createEmphasisDefaultState(el, stateName, targetStates, state) {
  const hasSelect = targetStates && indexOf(targetStates, "select") >= 0;
  let cloned = false;
  if (el instanceof Path_default) {
    const store = getSavedStates(el);
    const fromFill = hasSelect ? store.selectFill || store.normalFill : store.normalFill;
    const fromStroke = hasSelect ? store.selectStroke || store.normalStroke : store.normalStroke;
    if (hasFillOrStroke(fromFill) || hasFillOrStroke(fromStroke)) {
      state = state || {};
      let emphasisStyle = state.style || {};
      if (emphasisStyle.fill === "inherit") {
        cloned = true;
        state = extend({}, state);
        emphasisStyle = extend({}, emphasisStyle);
        emphasisStyle.fill = fromFill;
      } else if (!hasFillOrStroke(emphasisStyle.fill) && hasFillOrStroke(fromFill)) {
        cloned = true;
        state = extend({}, state);
        emphasisStyle = extend({}, emphasisStyle);
        emphasisStyle.fill = liftColor(fromFill);
      } else if (!hasFillOrStroke(emphasisStyle.stroke) && hasFillOrStroke(fromStroke)) {
        if (!cloned) {
          state = extend({}, state);
          emphasisStyle = extend({}, emphasisStyle);
        }
        emphasisStyle.stroke = liftColor(fromStroke);
      }
      state.style = emphasisStyle;
    }
  }
  if (state) {
    if (state.z2 == null) {
      if (!cloned) {
        state = extend({}, state);
      }
      const z2EmphasisLift = el.z2EmphasisLift;
      state.z2 = el.z2 + (z2EmphasisLift != null ? z2EmphasisLift : Z2_EMPHASIS_LIFT);
    }
  }
  return state;
}
function createSelectDefaultState(el, stateName, state) {
  if (state) {
    if (state.z2 == null) {
      state = extend({}, state);
      const z2SelectLift = el.z2SelectLift;
      state.z2 = el.z2 + (z2SelectLift != null ? z2SelectLift : Z2_SELECT_LIFT);
    }
  }
  return state;
}
function createBlurDefaultState(el, stateName, state) {
  const hasBlur = indexOf(el.currentStates, stateName) >= 0;
  const currentOpacity = el.style.opacity;
  const fromState = !hasBlur ? getFromStateStyle(el, ["opacity"], stateName, {
    opacity: 1
  }) : null;
  state = state || {};
  let blurStyle = state.style || {};
  if (blurStyle.opacity == null) {
    state = extend({}, state);
    blurStyle = extend({
      opacity: hasBlur ? currentOpacity : fromState.opacity * 0.1
    }, blurStyle);
    state.style = blurStyle;
  }
  return state;
}
function elementStateProxy(stateName, targetStates) {
  const state = this.states[stateName];
  if (this.style) {
    if (stateName === "emphasis") {
      return createEmphasisDefaultState(this, stateName, targetStates, state);
    } else if (stateName === "blur") {
      return createBlurDefaultState(this, stateName, state);
    } else if (stateName === "select") {
      return createSelectDefaultState(this, stateName, state);
    }
  }
  return state;
}
function setDefaultStateProxy(el) {
  el.stateProxy = elementStateProxy;
  const textContent = el.getTextContent();
  const textGuide = el.getTextGuideLine();
  if (textContent) {
    textContent.stateProxy = elementStateProxy;
  }
  if (textGuide) {
    textGuide.stateProxy = elementStateProxy;
  }
}
function enterEmphasisWhenMouseOver(el, e2) {
  !shouldSilent(el, e2) && !el.__highByOuter && traverseUpdateState(el, singleEnterEmphasis);
}
function leaveEmphasisWhenMouseOut(el, e2) {
  !shouldSilent(el, e2) && !el.__highByOuter && traverseUpdateState(el, singleLeaveEmphasis);
}
function enterEmphasis(el, highlightDigit) {
  el.__highByOuter |= 1 << (highlightDigit || 0);
  traverseUpdateState(el, singleEnterEmphasis);
}
function leaveEmphasis(el, highlightDigit) {
  !(el.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdateState(el, singleLeaveEmphasis);
}
function enterBlur(el) {
  traverseUpdateState(el, singleEnterBlur);
}
function leaveBlur(el) {
  traverseUpdateState(el, singleLeaveBlur);
}
function enterSelect(el) {
  traverseUpdateState(el, singleEnterSelect);
}
function leaveSelect(el) {
  traverseUpdateState(el, singleLeaveSelect);
}
function shouldSilent(el, e2) {
  return el.__highDownSilentOnTouch && e2.zrByTouch;
}
function allLeaveBlur(api2) {
  const model = api2.getModel();
  const leaveBlurredSeries = [];
  const allComponentViews = [];
  model.eachComponent(function(componentType, componentModel) {
    const componentStates = getComponentStates(componentModel);
    const isSeries2 = componentType === "series";
    const view = isSeries2 ? api2.getViewOfSeriesModel(componentModel) : api2.getViewOfComponentModel(componentModel);
    !isSeries2 && allComponentViews.push(view);
    if (componentStates.isBlured) {
      view.group.traverse(function(child) {
        singleLeaveBlur(child);
      });
      isSeries2 && leaveBlurredSeries.push(componentModel);
    }
    componentStates.isBlured = false;
  });
  each(allComponentViews, function(view) {
    if (view && view.toggleBlurSeries) {
      view.toggleBlurSeries(leaveBlurredSeries, false, model);
    }
  });
}
function blurSeries(targetSeriesIndex, focus, blurScope, api2) {
  const ecModel = api2.getModel();
  blurScope = blurScope || "coordinateSystem";
  function leaveBlurOfIndices(data, dataIndices) {
    for (let i = 0; i < dataIndices.length; i++) {
      const itemEl = data.getItemGraphicEl(dataIndices[i]);
      itemEl && leaveBlur(itemEl);
    }
  }
  if (targetSeriesIndex == null) {
    return;
  }
  if (!focus || focus === "none") {
    return;
  }
  const targetSeriesModel = ecModel.getSeriesByIndex(targetSeriesIndex);
  let targetCoordSys = targetSeriesModel.coordinateSystem;
  if (targetCoordSys && targetCoordSys.master) {
    targetCoordSys = targetCoordSys.master;
  }
  const blurredSeries = [];
  ecModel.eachSeries(function(seriesModel) {
    const sameSeries = targetSeriesModel === seriesModel;
    let coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.master) {
      coordSys = coordSys.master;
    }
    const sameCoordSys = coordSys && targetCoordSys ? coordSys === targetCoordSys : sameSeries;
    if (!(blurScope === "series" && !sameSeries || blurScope === "coordinateSystem" && !sameCoordSys || focus === "series" && sameSeries)) {
      const view = api2.getViewOfSeriesModel(seriesModel);
      view.group.traverse(function(child) {
        if (child.__highByOuter && sameSeries && focus === "self") {
          return;
        }
        singleEnterBlur(child);
      });
      if (isArrayLike(focus)) {
        leaveBlurOfIndices(seriesModel.getData(), focus);
      } else if (isObject(focus)) {
        const dataTypes = keys(focus);
        for (let d = 0; d < dataTypes.length; d++) {
          leaveBlurOfIndices(seriesModel.getData(dataTypes[d]), focus[dataTypes[d]]);
        }
      }
      blurredSeries.push(seriesModel);
      getComponentStates(seriesModel).isBlured = true;
    }
  });
  ecModel.eachComponent(function(componentType, componentModel) {
    if (componentType === "series") {
      return;
    }
    const view = api2.getViewOfComponentModel(componentModel);
    if (view && view.toggleBlurSeries) {
      view.toggleBlurSeries(blurredSeries, true, ecModel);
    }
  });
}
function blurComponent(componentMainType, componentIndex, api2) {
  if (componentMainType == null || componentIndex == null) {
    return;
  }
  const componentModel = api2.getModel().getComponent(componentMainType, componentIndex);
  if (!componentModel) {
    return;
  }
  getComponentStates(componentModel).isBlured = true;
  const view = api2.getViewOfComponentModel(componentModel);
  if (!view || !view.focusBlurEnabled) {
    return;
  }
  view.group.traverse(function(child) {
    singleEnterBlur(child);
  });
}
function blurSeriesFromHighlightPayload(seriesModel, payload, api2) {
  const seriesIndex = seriesModel.seriesIndex;
  const data = seriesModel.getData(payload.dataType);
  if (!data) {
    if (true) {
      error(`Unknown dataType ${payload.dataType}`);
    }
    return;
  }
  let dataIndex = queryDataIndex(data, payload);
  dataIndex = (isArray(dataIndex) ? dataIndex[0] : dataIndex) || 0;
  let el = data.getItemGraphicEl(dataIndex);
  if (!el) {
    const count2 = data.count();
    let current = 0;
    while (!el && current < count2) {
      el = data.getItemGraphicEl(current++);
    }
  }
  if (el) {
    const ecData = getECData(el);
    blurSeries(seriesIndex, ecData.focus, ecData.blurScope, api2);
  } else {
    const focus = seriesModel.get(["emphasis", "focus"]);
    const blurScope = seriesModel.get(["emphasis", "blurScope"]);
    if (focus != null) {
      blurSeries(seriesIndex, focus, blurScope, api2);
    }
  }
}
function findComponentHighDownDispatchers(componentMainType, componentIndex, name, api2) {
  const ret = {
    focusSelf: false,
    dispatchers: null
  };
  if (componentMainType == null || componentMainType === "series" || componentIndex == null || name == null) {
    return ret;
  }
  const componentModel = api2.getModel().getComponent(componentMainType, componentIndex);
  if (!componentModel) {
    return ret;
  }
  const view = api2.getViewOfComponentModel(componentModel);
  if (!view || !view.findHighDownDispatchers) {
    return ret;
  }
  const dispatchers = view.findHighDownDispatchers(name);
  let focusSelf;
  for (let i = 0; i < dispatchers.length; i++) {
    if (!isHighDownDispatcher(dispatchers[i])) {
      error("param should be highDownDispatcher");
    }
    if (getECData(dispatchers[i]).focus === "self") {
      focusSelf = true;
      break;
    }
  }
  return {focusSelf, dispatchers};
}
function handleGlobalMouseOverForHighDown(dispatcher, e2, api2) {
  if (!isHighDownDispatcher(dispatcher)) {
    error("param should be highDownDispatcher");
  }
  const ecData = getECData(dispatcher);
  const {dispatchers, focusSelf} = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api2);
  if (dispatchers) {
    if (focusSelf) {
      blurComponent(ecData.componentMainType, ecData.componentIndex, api2);
    }
    each(dispatchers, (dispatcher2) => enterEmphasisWhenMouseOver(dispatcher2, e2));
  } else {
    blurSeries(ecData.seriesIndex, ecData.focus, ecData.blurScope, api2);
    if (ecData.focus === "self") {
      blurComponent(ecData.componentMainType, ecData.componentIndex, api2);
    }
    enterEmphasisWhenMouseOver(dispatcher, e2);
  }
}
function handleGlobalMouseOutForHighDown(dispatcher, e2, api2) {
  if (!isHighDownDispatcher(dispatcher)) {
    error("param should be highDownDispatcher");
  }
  allLeaveBlur(api2);
  const ecData = getECData(dispatcher);
  const {dispatchers} = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api2);
  if (dispatchers) {
    each(dispatchers, (dispatcher2) => leaveEmphasisWhenMouseOut(dispatcher2, e2));
  } else {
    leaveEmphasisWhenMouseOut(dispatcher, e2);
  }
}
function toggleSelectionFromPayload(seriesModel, payload, api2) {
  if (!isSelectChangePayload(payload)) {
    return;
  }
  const dataType = payload.dataType;
  const data = seriesModel.getData(dataType);
  let dataIndex = queryDataIndex(data, payload);
  if (!isArray(dataIndex)) {
    dataIndex = [dataIndex];
  }
  seriesModel[payload.type === TOGGLE_SELECT_ACTION_TYPE ? "toggleSelect" : payload.type === SELECT_ACTION_TYPE ? "select" : "unselect"](dataIndex, dataType);
}
function updateSeriesElementSelection(seriesModel) {
  const allData = seriesModel.getAllData();
  each(allData, function({data, type}) {
    data.eachItemGraphicEl(function(el, idx) {
      seriesModel.isSelected(idx, type) ? enterSelect(el) : leaveSelect(el);
    });
  });
}
function getAllSelectedIndices(ecModel) {
  const ret = [];
  ecModel.eachSeries(function(seriesModel) {
    const allData = seriesModel.getAllData();
    each(allData, function({data, type}) {
      const dataIndices = seriesModel.getSelectedDataIndices();
      if (dataIndices.length > 0) {
        const item = {
          dataIndex: dataIndices,
          seriesIndex: seriesModel.seriesIndex
        };
        if (type != null) {
          item.dataType = type;
        }
        ret.push(item);
      }
    });
  });
  return ret;
}
function enableHoverEmphasis(el, focus, blurScope) {
  setAsHighDownDispatcher(el, true);
  traverseUpdateState(el, setDefaultStateProxy);
  enableHoverFocus(el, focus, blurScope);
}
function disableHoverEmphasis(el) {
  setAsHighDownDispatcher(el, false);
}
function toggleHoverEmphasis(el, focus, blurScope, isDisabled) {
  isDisabled ? disableHoverEmphasis(el) : enableHoverEmphasis(el, focus, blurScope);
}
function enableHoverFocus(el, focus, blurScope) {
  const ecData = getECData(el);
  if (focus != null) {
    ecData.focus = focus;
    ecData.blurScope = blurScope;
  } else if (ecData.focus) {
    ecData.focus = null;
  }
}
var OTHER_STATES = ["emphasis", "blur", "select"];
var defaultStyleGetterMap = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function setStatesStylesFromModel(el, itemModel, styleType, getter) {
  styleType = styleType || "itemStyle";
  for (let i = 0; i < OTHER_STATES.length; i++) {
    const stateName = OTHER_STATES[i];
    const model = itemModel.getModel([stateName, styleType]);
    const state = el.ensureState(stateName);
    state.style = getter ? getter(model) : model[defaultStyleGetterMap[styleType]]();
  }
}
function setAsHighDownDispatcher(el, asDispatcher) {
  const disable = asDispatcher === false;
  const extendedEl = el;
  if (el.highDownSilentOnTouch) {
    extendedEl.__highDownSilentOnTouch = el.highDownSilentOnTouch;
  }
  if (!disable || extendedEl.__highDownDispatcher) {
    extendedEl.__highByOuter = extendedEl.__highByOuter || 0;
    extendedEl.__highDownDispatcher = !disable;
  }
}
function isHighDownDispatcher(el) {
  return !!(el && el.__highDownDispatcher);
}
function enableComponentHighDownFeatures(el, componentModel, componentHighDownName) {
  const ecData = getECData(el);
  ecData.componentMainType = componentModel.mainType;
  ecData.componentIndex = componentModel.componentIndex;
  ecData.componentHighDownName = componentHighDownName;
}
function getHighlightDigit(highlightKey) {
  let highlightDigit = _highlightKeyMap[highlightKey];
  if (highlightDigit == null && _highlightNextDigit <= 32) {
    highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++;
  }
  return highlightDigit;
}
function isSelectChangePayload(payload) {
  const payloadType = payload.type;
  return payloadType === SELECT_ACTION_TYPE || payloadType === UNSELECT_ACTION_TYPE || payloadType === TOGGLE_SELECT_ACTION_TYPE;
}
function isHighDownPayload(payload) {
  const payloadType = payload.type;
  return payloadType === HIGHLIGHT_ACTION_TYPE || payloadType === DOWNPLAY_ACTION_TYPE;
}
function savePathStates(el) {
  const store = getSavedStates(el);
  store.normalFill = el.style.fill;
  store.normalStroke = el.style.stroke;
  const selectState = el.states.select || {};
  store.selectFill = selectState.style && selectState.style.fill || null;
  store.selectStroke = selectState.style && selectState.style.stroke || null;
}

// src/util/graphic.ts
var graphic_exports = {};
__export(graphic_exports, {
  Arc: () => Arc_default,
  BezierCurve: () => BezierCurve_default,
  BoundingRect: () => BoundingRect_default,
  Circle: () => Circle_default,
  CompoundPath: () => CompoundPath_default,
  Ellipse: () => Ellipse_default,
  Group: () => Group_default,
  Image: () => Image_default,
  IncrementalDisplayable: () => IncrementalDisplayable_default,
  Line: () => Line_default,
  LinearGradient: () => LinearGradient_default,
  OrientedBoundingRect: () => OrientedBoundingRect_default,
  Path: () => Path_default,
  Point: () => Point_default,
  Polygon: () => Polygon_default,
  Polyline: () => Polyline_default,
  RadialGradient: () => RadialGradient_default,
  Rect: () => Rect_default,
  Ring: () => Ring_default,
  Sector: () => Sector_default,
  Text: () => Text_default,
  WH: () => WH2,
  XY: () => XY2,
  applyTransform: () => applyTransform2,
  calcZ2Range: () => calcZ2Range,
  clipPointsByRect: () => clipPointsByRect,
  clipRectByRect: () => clipRectByRect,
  createIcon: () => createIcon,
  expandOrShrinkRect: () => expandOrShrinkRect,
  extendPath: () => extendPath,
  extendShape: () => extendShape,
  getShapeClass: () => getShapeClass,
  getTransform: () => getTransform,
  groupTransition: () => groupTransition,
  initProps: () => initProps,
  isBoundingRectAxisAligned: () => isBoundingRectAxisAligned,
  isElementRemoved: () => isElementRemoved,
  lineLineIntersect: () => lineLineIntersect,
  linePolygonIntersect: () => linePolygonIntersect,
  makeImage: () => makeImage,
  makePath: () => makePath,
  mergePath: () => mergePath2,
  registerShape: () => registerShape,
  removeElement: () => removeElement,
  removeElementWithFadeOut: () => removeElementWithFadeOut,
  resizePath: () => resizePath,
  retrieveZInfo: () => retrieveZInfo,
  setTooltipConfig: () => setTooltipConfig,
  subPixelOptimize: () => subPixelOptimize2,
  subPixelOptimizeLine: () => subPixelOptimizeLine2,
  subPixelOptimizeRect: () => subPixelOptimizeRect2,
  transformDirection: () => transformDirection,
  traverseElements: () => traverseElements,
  traverseUpdateZ: () => traverseUpdateZ,
  updateProps: () => updateProps
});

// ../zrender/src/tool/transformPath.ts
var CMD3 = PathProxy_default.CMD;
var points = [[], [], []];
var mathSqrt2 = Math.sqrt;
var mathAtan2 = Math.atan2;
function transformPath(path, m2) {
  if (!m2) {
    return;
  }
  let data = path.data;
  const len2 = path.len();
  let cmd;
  let nPoint;
  let i;
  let j;
  let k;
  let p;
  const M = CMD3.M;
  const C = CMD3.C;
  const L = CMD3.L;
  const R = CMD3.R;
  const A = CMD3.A;
  const Q = CMD3.Q;
  for (i = 0, j = 0; i < len2; ) {
    cmd = data[i++];
    j = i;
    nPoint = 0;
    switch (cmd) {
      case M:
        nPoint = 1;
        break;
      case L:
        nPoint = 1;
        break;
      case C:
        nPoint = 3;
        break;
      case Q:
        nPoint = 2;
        break;
      case A:
        const x = m2[4];
        const y = m2[5];
        const sx = mathSqrt2(m2[0] * m2[0] + m2[1] * m2[1]);
        const sy = mathSqrt2(m2[2] * m2[2] + m2[3] * m2[3]);
        const angle = mathAtan2(-m2[1] / sy, m2[0] / sx);
        data[i] *= sx;
        data[i++] += x;
        data[i] *= sy;
        data[i++] += y;
        data[i++] *= sx;
        data[i++] *= sy;
        data[i++] += angle;
        data[i++] += angle;
        i += 2;
        j = i;
        break;
      case R:
        p[0] = data[i++];
        p[1] = data[i++];
        applyTransform(p, p, m2);
        data[j++] = p[0];
        data[j++] = p[1];
        p[0] += data[i++];
        p[1] += data[i++];
        applyTransform(p, p, m2);
        data[j++] = p[0];
        data[j++] = p[1];
    }
    for (k = 0; k < nPoint; k++) {
      let p2 = points[k];
      p2[0] = data[i++];
      p2[1] = data[i++];
      applyTransform(p2, p2, m2);
      data[j++] = p2[0];
      data[j++] = p2[1];
    }
  }
  path.increaseVersion();
}

// ../zrender/src/tool/path.ts
var mathSqrt3 = Math.sqrt;
var mathSin3 = Math.sin;
var mathCos3 = Math.cos;
var PI3 = Math.PI;
function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio(u, v) {
  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
}
function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
  const psi = psiDeg * (PI3 / 180);
  const xp = mathCos3(psi) * (x1 - x2) / 2 + mathSin3(psi) * (y1 - y2) / 2;
  const yp = -1 * mathSin3(psi) * (x1 - x2) / 2 + mathCos3(psi) * (y1 - y2) / 2;
  const lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= mathSqrt3(lambda);
    ry *= mathSqrt3(lambda);
  }
  const f = (fa === fs ? -1 : 1) * mathSqrt3((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
  const cxp = f * rx * yp / ry;
  const cyp = f * -ry * xp / rx;
  const cx = (x1 + x2) / 2 + mathCos3(psi) * cxp - mathSin3(psi) * cyp;
  const cy = (y1 + y2) / 2 + mathSin3(psi) * cxp + mathCos3(psi) * cyp;
  const theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
  const u = [(xp - cxp) / rx, (yp - cyp) / ry];
  const v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  let dTheta = vAngle(u, v);
  if (vRatio(u, v) <= -1) {
    dTheta = PI3;
  }
  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }
  if (dTheta < 0) {
    const n = Math.round(dTheta / PI3 * 1e6) / 1e6;
    dTheta = PI3 * 2 + n % 2 * PI3;
  }
  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
}
var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig;
var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function createPathProxyFromString(data) {
  const path = new PathProxy_default();
  if (!data) {
    return path;
  }
  let cpx = 0;
  let cpy = 0;
  let subpathX = cpx;
  let subpathY = cpy;
  let prevCmd;
  const CMD6 = PathProxy_default.CMD;
  const cmdList = data.match(commandReg);
  if (!cmdList) {
    return path;
  }
  for (let l = 0; l < cmdList.length; l++) {
    const cmdText = cmdList[l];
    let cmdStr = cmdText.charAt(0);
    let cmd;
    const p = cmdText.match(numberReg) || [];
    const pLen = p.length;
    for (let i = 0; i < pLen; i++) {
      p[i] = parseFloat(p[i]);
    }
    let off = 0;
    while (off < pLen) {
      let ctlPtx;
      let ctlPty;
      let rx;
      let ry;
      let psi;
      let fa;
      let fs;
      let x1 = cpx;
      let y1 = cpy;
      let len2;
      let pathData;
      switch (cmdStr) {
        case "l":
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD6.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "L":
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD6.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "m":
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD6.M;
          path.addData(cmd, cpx, cpy);
          subpathX = cpx;
          subpathY = cpy;
          cmdStr = "l";
          break;
        case "M":
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD6.M;
          path.addData(cmd, cpx, cpy);
          subpathX = cpx;
          subpathY = cpy;
          cmdStr = "L";
          break;
        case "h":
          cpx += p[off++];
          cmd = CMD6.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "H":
          cpx = p[off++];
          cmd = CMD6.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "v":
          cpy += p[off++];
          cmd = CMD6.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "V":
          cpy = p[off++];
          cmd = CMD6.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "C":
          cmd = CMD6.C;
          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
          cpx = p[off - 2];
          cpy = p[off - 1];
          break;
        case "c":
          cmd = CMD6.C;
          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
          cpx += p[off - 2];
          cpy += p[off - 1];
          break;
        case "S":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD6.C) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cmd = CMD6.C;
          x1 = p[off++];
          y1 = p[off++];
          cpx = p[off++];
          cpy = p[off++];
          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
          break;
        case "s":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD6.C) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cmd = CMD6.C;
          x1 = cpx + p[off++];
          y1 = cpy + p[off++];
          cpx += p[off++];
          cpy += p[off++];
          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
          break;
        case "Q":
          x1 = p[off++];
          y1 = p[off++];
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD6.Q;
          path.addData(cmd, x1, y1, cpx, cpy);
          break;
        case "q":
          x1 = p[off++] + cpx;
          y1 = p[off++] + cpy;
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD6.Q;
          path.addData(cmd, x1, y1, cpx, cpy);
          break;
        case "T":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD6.Q) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD6.Q;
          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;
        case "t":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD6.Q) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD6.Q;
          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;
        case "A":
          rx = p[off++];
          ry = p[off++];
          psi = p[off++];
          fa = p[off++];
          fs = p[off++];
          x1 = cpx, y1 = cpy;
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD6.A;
          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
          break;
        case "a":
          rx = p[off++];
          ry = p[off++];
          psi = p[off++];
          fa = p[off++];
          fs = p[off++];
          x1 = cpx, y1 = cpy;
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD6.A;
          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
          break;
      }
    }
    if (cmdStr === "z" || cmdStr === "Z") {
      cmd = CMD6.Z;
      path.addData(cmd);
      cpx = subpathX;
      cpy = subpathY;
    }
    prevCmd = cmd;
  }
  path.toStatic();
  return path;
}
var SVGPath = class extends Path_default {
  applyTransform(m2) {
  }
};
function isPathProxy(path) {
  return path.setData != null;
}
function createPathOptions(str, opts) {
  const pathProxy = createPathProxyFromString(str);
  const innerOpts = extend({}, opts);
  innerOpts.buildPath = function(path) {
    const beProxy = isPathProxy(path);
    if (beProxy && path.canSave()) {
      path.appendPath(pathProxy);
      const ctx = path.getContext();
      if (ctx) {
        path.rebuildPath(ctx, 1);
      }
    } else {
      const ctx = beProxy ? path.getContext() : path;
      if (ctx) {
        pathProxy.rebuildPath(ctx, 1);
      }
    }
  };
  innerOpts.applyTransform = function(m2) {
    transformPath(pathProxy, m2);
    this.dirtyShape();
  };
  return innerOpts;
}
function createFromString(str, opts) {
  return new SVGPath(createPathOptions(str, opts));
}
function extendFromString(str, defaultOpts) {
  const innerOpts = createPathOptions(str, defaultOpts);
  class Sub extends SVGPath {
    constructor(opts) {
      super(opts);
      this.applyTransform = innerOpts.applyTransform;
      this.buildPath = innerOpts.buildPath;
    }
  }
  return Sub;
}
function mergePath(pathEls, opts) {
  const pathList = [];
  const len2 = pathEls.length;
  for (let i = 0; i < len2; i++) {
    const pathEl = pathEls[i];
    pathList.push(pathEl.getUpdatedPathProxy(true));
  }
  const pathBundle = new Path_default(opts);
  pathBundle.createPathProxy();
  pathBundle.buildPath = function(path) {
    if (isPathProxy(path)) {
      path.appendPath(pathList);
      const ctx = path.getContext();
      if (ctx) {
        path.rebuildPath(ctx, 1);
      }
    }
  };
  return pathBundle;
}
function clonePath(sourcePath, opts) {
  opts = opts || {};
  const path = new Path_default();
  if (sourcePath.shape) {
    path.setShape(sourcePath.shape);
  }
  path.setStyle(sourcePath.style);
  if (opts.bakeTransform) {
    transformPath(path.path, sourcePath.getComputedTransform());
  } else {
    if (opts.toLocal) {
      path.setLocalTransform(sourcePath.getComputedTransform());
    } else {
      path.copyTransform(sourcePath);
    }
  }
  path.buildPath = sourcePath.buildPath;
  path.applyTransform = path.applyTransform;
  path.z = sourcePath.z;
  path.z2 = sourcePath.z2;
  path.zlevel = sourcePath.zlevel;
  return path;
}

// ../zrender/src/graphic/shape/Circle.ts
var CircleShape = class {
  constructor() {
    this.cx = 0;
    this.cy = 0;
    this.r = 0;
  }
};
var Circle = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultShape() {
    return new CircleShape();
  }
  buildPath(ctx, shape) {
    ctx.moveTo(shape.cx + shape.r, shape.cy);
    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2);
  }
};
Circle.prototype.type = "circle";
var Circle_default = Circle;

// ../zrender/src/graphic/shape/Ellipse.ts
var EllipseShape = class {
  constructor() {
    this.cx = 0;
    this.cy = 0;
    this.rx = 0;
    this.ry = 0;
  }
};
var Ellipse = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultShape() {
    return new EllipseShape();
  }
  buildPath(ctx, shape) {
    const k = 0.5522848;
    const x = shape.cx;
    const y = shape.cy;
    const a = shape.rx;
    const b = shape.ry;
    const ox = a * k;
    const oy = b * k;
    ctx.moveTo(x - a, y);
    ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
    ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
    ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
    ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
    ctx.closePath();
  }
};
Ellipse.prototype.type = "ellipse";
var Ellipse_default = Ellipse;

// ../zrender/src/graphic/helper/roundSector.ts
var PI4 = Math.PI;
var PI26 = PI4 * 2;
var mathSin4 = Math.sin;
var mathCos4 = Math.cos;
var mathACos = Math.acos;
var mathATan2 = Math.atan2;
var mathAbs4 = Math.abs;
var mathSqrt4 = Math.sqrt;
var mathMax5 = Math.max;
var mathMin5 = Math.min;
var e = 1e-4;
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  const dx10 = x1 - x0;
  const dy10 = y1 - y0;
  const dx32 = x3 - x2;
  const dy32 = y3 - y2;
  let t = dy32 * dx10 - dx32 * dy10;
  if (t * t < e) {
    return;
  }
  t = (dx32 * (y0 - y2) - dy32 * (x0 - x2)) / t;
  return [x0 + t * dx10, y0 + t * dy10];
}
function computeCornerTangents(x0, y0, x1, y1, radius, cr, clockwise) {
  const x01 = x0 - x1;
  const y01 = y0 - y1;
  const lo = (clockwise ? cr : -cr) / mathSqrt4(x01 * x01 + y01 * y01);
  const ox = lo * y01;
  const oy = -lo * x01;
  const x11 = x0 + ox;
  const y11 = y0 + oy;
  const x10 = x1 + ox;
  const y10 = y1 + oy;
  const x00 = (x11 + x10) / 2;
  const y00 = (y11 + y10) / 2;
  const dx = x10 - x11;
  const dy = y10 - y11;
  const d2 = dx * dx + dy * dy;
  const r = radius - cr;
  const s = x11 * y10 - x10 * y11;
  const d = (dy < 0 ? -1 : 1) * mathSqrt4(mathMax5(0, r * r * d2 - s * s));
  let cx0 = (s * dy - dx * d) / d2;
  let cy0 = (-s * dx - dy * d) / d2;
  const cx1 = (s * dy + dx * d) / d2;
  const cy1 = (-s * dx + dy * d) / d2;
  const dx0 = cx0 - x00;
  const dy0 = cy0 - y00;
  const dx1 = cx1 - x00;
  const dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
    cx0 = cx1;
    cy0 = cy1;
  }
  return {
    cx: cx0,
    cy: cy0,
    x0: -ox,
    y0: -oy,
    x1: cx0 * (radius / r - 1),
    y1: cy0 * (radius / r - 1)
  };
}
function normalizeCornerRadius(cr) {
  let arr;
  if (isArray(cr)) {
    const len2 = cr.length;
    if (!len2) {
      return cr;
    }
    if (len2 === 1) {
      arr = [cr[0], cr[0], 0, 0];
    } else if (len2 === 2) {
      arr = [cr[0], cr[0], cr[1], cr[1]];
    } else if (len2 === 3) {
      arr = cr.concat(cr[2]);
    } else {
      arr = cr;
    }
  } else {
    arr = [cr, cr, cr, cr];
  }
  return arr;
}
function buildPath2(ctx, shape) {
  let radius = mathMax5(shape.r, 0);
  let innerRadius = mathMax5(shape.r0 || 0, 0);
  const hasRadius = radius > 0;
  const hasInnerRadius = innerRadius > 0;
  if (!hasRadius && !hasInnerRadius) {
    return;
  }
  if (!hasRadius) {
    radius = innerRadius;
    innerRadius = 0;
  }
  if (innerRadius > radius) {
    const tmp = radius;
    radius = innerRadius;
    innerRadius = tmp;
  }
  const {startAngle, endAngle} = shape;
  if (isNaN(startAngle) || isNaN(endAngle)) {
    return;
  }
  const {cx, cy} = shape;
  const clockwise = !!shape.clockwise;
  let arc2 = mathAbs4(endAngle - startAngle);
  const mod = arc2 > PI26 && arc2 % PI26;
  mod > e && (arc2 = mod);
  if (!(radius > e)) {
    ctx.moveTo(cx, cy);
  } else if (arc2 > PI26 - e) {
    ctx.moveTo(cx + radius * mathCos4(startAngle), cy + radius * mathSin4(startAngle));
    ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
    if (innerRadius > e) {
      ctx.moveTo(cx + innerRadius * mathCos4(endAngle), cy + innerRadius * mathSin4(endAngle));
      ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
    }
  } else {
    let icrStart;
    let icrEnd;
    let ocrStart;
    let ocrEnd;
    let ocrs;
    let ocre;
    let icrs;
    let icre;
    let ocrMax;
    let icrMax;
    let limitedOcrMax;
    let limitedIcrMax;
    let xre;
    let yre;
    let xirs;
    let yirs;
    const xrs = radius * mathCos4(startAngle);
    const yrs = radius * mathSin4(startAngle);
    const xire = innerRadius * mathCos4(endAngle);
    const yire = innerRadius * mathSin4(endAngle);
    const hasArc = arc2 > e;
    if (hasArc) {
      const cornerRadius = shape.cornerRadius;
      if (cornerRadius) {
        [icrStart, icrEnd, ocrStart, ocrEnd] = normalizeCornerRadius(cornerRadius);
      }
      const halfRd = mathAbs4(radius - innerRadius) / 2;
      ocrs = mathMin5(halfRd, ocrStart);
      ocre = mathMin5(halfRd, ocrEnd);
      icrs = mathMin5(halfRd, icrStart);
      icre = mathMin5(halfRd, icrEnd);
      limitedOcrMax = ocrMax = mathMax5(ocrs, ocre);
      limitedIcrMax = icrMax = mathMax5(icrs, icre);
      if (ocrMax > e || icrMax > e) {
        xre = radius * mathCos4(endAngle);
        yre = radius * mathSin4(endAngle);
        xirs = innerRadius * mathCos4(startAngle);
        yirs = innerRadius * mathSin4(startAngle);
        if (arc2 < PI4) {
          const it = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire);
          if (it) {
            const x0 = xrs - it[0];
            const y0 = yrs - it[1];
            const x1 = xre - it[0];
            const y1 = yre - it[1];
            const a = 1 / mathSin4(mathACos((x0 * x1 + y0 * y1) / (mathSqrt4(x0 * x0 + y0 * y0) * mathSqrt4(x1 * x1 + y1 * y1))) / 2);
            const b = mathSqrt4(it[0] * it[0] + it[1] * it[1]);
            limitedOcrMax = mathMin5(ocrMax, (radius - b) / (a + 1));
            limitedIcrMax = mathMin5(icrMax, (innerRadius - b) / (a - 1));
          }
        }
      }
    }
    if (!hasArc) {
      ctx.moveTo(cx + xrs, cy + yrs);
    } else if (limitedOcrMax > e) {
      const crStart = mathMin5(ocrStart, limitedOcrMax);
      const crEnd = mathMin5(ocrEnd, limitedOcrMax);
      const ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, radius, crStart, clockwise);
      const ct1 = computeCornerTangents(xre, yre, xire, yire, radius, crEnd, clockwise);
      ctx.moveTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
      if (limitedOcrMax < ocrMax && crStart === crEnd) {
        ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedOcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
      } else {
        crStart > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crStart, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
        ctx.arc(cx, cy, radius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), !clockwise);
        crEnd > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crEnd, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
      }
    } else {
      ctx.moveTo(cx + xrs, cy + yrs);
      ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
    }
    if (!(innerRadius > e) || !hasArc) {
      ctx.lineTo(cx + xire, cy + yire);
    } else if (limitedIcrMax > e) {
      const crStart = mathMin5(icrStart, limitedIcrMax);
      const crEnd = mathMin5(icrEnd, limitedIcrMax);
      const ct0 = computeCornerTangents(xire, yire, xre, yre, innerRadius, -crEnd, clockwise);
      const ct1 = computeCornerTangents(xrs, yrs, xirs, yirs, innerRadius, -crStart, clockwise);
      ctx.lineTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
      if (limitedIcrMax < icrMax && crStart === crEnd) {
        ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedIcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
      } else {
        crEnd > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crEnd, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
        ctx.arc(cx, cy, innerRadius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), clockwise);
        crStart > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crStart, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
      }
    } else {
      ctx.lineTo(cx + xire, cy + yire);
      ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
    }
  }
  ctx.closePath();
}

// ../zrender/src/graphic/shape/Sector.ts
var SectorShape = class {
  constructor() {
    this.cx = 0;
    this.cy = 0;
    this.r0 = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
    this.cornerRadius = 0;
  }
};
var Sector = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultShape() {
    return new SectorShape();
  }
  buildPath(ctx, shape) {
    buildPath2(ctx, shape);
  }
  isZeroArea() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  }
};
Sector.prototype.type = "sector";
var Sector_default = Sector;

// ../zrender/src/graphic/shape/Ring.ts
var RingShape = class {
  constructor() {
    this.cx = 0;
    this.cy = 0;
    this.r = 0;
    this.r0 = 0;
  }
};
var Ring = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultShape() {
    return new RingShape();
  }
  buildPath(ctx, shape) {
    const x = shape.cx;
    const y = shape.cy;
    const PI210 = Math.PI * 2;
    ctx.moveTo(x + shape.r, y);
    ctx.arc(x, y, shape.r, 0, PI210, false);
    ctx.moveTo(x + shape.r0, y);
    ctx.arc(x, y, shape.r0, 0, PI210, true);
  }
};
Ring.prototype.type = "ring";
var Ring_default = Ring;

// ../zrender/src/graphic/helper/smoothBezier.ts
function smoothBezier(points4, smooth, isLoop, constraint) {
  const cps = [];
  const v = [];
  const v12 = [];
  const v22 = [];
  let prevPoint;
  let nextPoint;
  let min3;
  let max3;
  if (constraint) {
    min3 = [Infinity, Infinity];
    max3 = [-Infinity, -Infinity];
    for (let i = 0, len2 = points4.length; i < len2; i++) {
      min(min3, min3, points4[i]);
      max(max3, max3, points4[i]);
    }
    min(min3, min3, constraint[0]);
    max(max3, max3, constraint[1]);
  }
  for (let i = 0, len2 = points4.length; i < len2; i++) {
    const point = points4[i];
    if (isLoop) {
      prevPoint = points4[i ? i - 1 : len2 - 1];
      nextPoint = points4[(i + 1) % len2];
    } else {
      if (i === 0 || i === len2 - 1) {
        cps.push(clone2(points4[i]));
        continue;
      } else {
        prevPoint = points4[i - 1];
        nextPoint = points4[i + 1];
      }
    }
    sub(v, nextPoint, prevPoint);
    scale(v, v, smooth);
    let d0 = distance(point, prevPoint);
    let d1 = distance(point, nextPoint);
    const sum2 = d0 + d1;
    if (sum2 !== 0) {
      d0 /= sum2;
      d1 /= sum2;
    }
    scale(v12, v, -d0);
    scale(v22, v, d1);
    const cp0 = add([], point, v12);
    const cp1 = add([], point, v22);
    if (constraint) {
      max(cp0, cp0, min3);
      min(cp0, cp0, max3);
      max(cp1, cp1, min3);
      min(cp1, cp1, max3);
    }
    cps.push(cp0);
    cps.push(cp1);
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
}

// ../zrender/src/graphic/helper/poly.ts
function buildPath3(ctx, shape, closePath) {
  const smooth = shape.smooth;
  let points4 = shape.points;
  if (points4 && points4.length >= 2) {
    if (smooth) {
      const controlPoints = smoothBezier(points4, smooth, closePath, shape.smoothConstraint);
      ctx.moveTo(points4[0][0], points4[0][1]);
      const len2 = points4.length;
      for (let i = 0; i < (closePath ? len2 : len2 - 1); i++) {
        const cp1 = controlPoints[i * 2];
        const cp2 = controlPoints[i * 2 + 1];
        const p = points4[(i + 1) % len2];
        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
      }
    } else {
      ctx.moveTo(points4[0][0], points4[0][1]);
      for (let i = 1, l = points4.length; i < l; i++) {
        ctx.lineTo(points4[i][0], points4[i][1]);
      }
    }
    closePath && ctx.closePath();
  }
}

// ../zrender/src/graphic/shape/Polygon.ts
var PolygonShape = class {
  constructor() {
    this.points = null;
    this.smooth = 0;
    this.smoothConstraint = null;
  }
};
var Polygon = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultShape() {
    return new PolygonShape();
  }
  buildPath(ctx, shape) {
    buildPath3(ctx, shape, true);
  }
};
Polygon.prototype.type = "polygon";
var Polygon_default = Polygon;

// ../zrender/src/graphic/shape/Polyline.ts
var PolylineShape = class {
  constructor() {
    this.points = null;
    this.percent = 1;
    this.smooth = 0;
    this.smoothConstraint = null;
  }
};
var Polyline = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultStyle() {
    return {
      stroke: "#000",
      fill: null
    };
  }
  getDefaultShape() {
    return new PolylineShape();
  }
  buildPath(ctx, shape) {
    buildPath3(ctx, shape, false);
  }
};
Polyline.prototype.type = "polyline";
var Polyline_default = Polyline;

// ../zrender/src/graphic/shape/Line.ts
var subPixelOptimizeOutputShape2 = {};
var LineShape = class {
  constructor() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.percent = 1;
  }
};
var Line = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultStyle() {
    return {
      stroke: "#000",
      fill: null
    };
  }
  getDefaultShape() {
    return new LineShape();
  }
  buildPath(ctx, shape) {
    let x1;
    let y1;
    let x2;
    let y2;
    if (this.subPixelOptimize) {
      const optimizedShape = subPixelOptimizeLine(subPixelOptimizeOutputShape2, shape, this.style);
      x1 = optimizedShape.x1;
      y1 = optimizedShape.y1;
      x2 = optimizedShape.x2;
      y2 = optimizedShape.y2;
    } else {
      x1 = shape.x1;
      y1 = shape.y1;
      x2 = shape.x2;
      y2 = shape.y2;
    }
    const percent = shape.percent;
    if (percent === 0) {
      return;
    }
    ctx.moveTo(x1, y1);
    if (percent < 1) {
      x2 = x1 * (1 - percent) + x2 * percent;
      y2 = y1 * (1 - percent) + y2 * percent;
    }
    ctx.lineTo(x2, y2);
  }
  pointAt(p) {
    const shape = this.shape;
    return [
      shape.x1 * (1 - p) + shape.x2 * p,
      shape.y1 * (1 - p) + shape.y2 * p
    ];
  }
};
Line.prototype.type = "line";
var Line_default = Line;

// ../zrender/src/graphic/shape/BezierCurve.ts
var out = [];
var BezierCurveShape = class {
  constructor() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.cpx1 = 0;
    this.cpy1 = 0;
    this.percent = 1;
  }
};
function someVectorAt(shape, t, isTangent) {
  const cpx2 = shape.cpx2;
  const cpy2 = shape.cpy2;
  if (cpx2 != null || cpy2 != null) {
    return [
      (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),
      (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)
    ];
  } else {
    return [
      (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),
      (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)
    ];
  }
}
var BezierCurve = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultStyle() {
    return {
      stroke: "#000",
      fill: null
    };
  }
  getDefaultShape() {
    return new BezierCurveShape();
  }
  buildPath(ctx, shape) {
    let x1 = shape.x1;
    let y1 = shape.y1;
    let x2 = shape.x2;
    let y2 = shape.y2;
    let cpx1 = shape.cpx1;
    let cpy1 = shape.cpy1;
    let cpx2 = shape.cpx2;
    let cpy2 = shape.cpy2;
    let percent = shape.percent;
    if (percent === 0) {
      return;
    }
    ctx.moveTo(x1, y1);
    if (cpx2 == null || cpy2 == null) {
      if (percent < 1) {
        quadraticSubdivide(x1, cpx1, x2, percent, out);
        cpx1 = out[1];
        x2 = out[2];
        quadraticSubdivide(y1, cpy1, y2, percent, out);
        cpy1 = out[1];
        y2 = out[2];
      }
      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
    } else {
      if (percent < 1) {
        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
        cpx1 = out[1];
        cpx2 = out[2];
        x2 = out[3];
        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
        cpy1 = out[1];
        cpy2 = out[2];
        y2 = out[3];
      }
      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
    }
  }
  pointAt(t) {
    return someVectorAt(this.shape, t, false);
  }
  tangentAt(t) {
    const p = someVectorAt(this.shape, t, true);
    return normalize(p, p);
  }
};
BezierCurve.prototype.type = "bezier-curve";
var BezierCurve_default = BezierCurve;

// ../zrender/src/graphic/shape/Arc.ts
var ArcShape = class {
  constructor() {
    this.cx = 0;
    this.cy = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
  }
};
var Arc = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultStyle() {
    return {
      stroke: "#000",
      fill: null
    };
  }
  getDefaultShape() {
    return new ArcShape();
  }
  buildPath(ctx, shape) {
    const x = shape.cx;
    const y = shape.cy;
    const r = Math.max(shape.r, 0);
    const startAngle = shape.startAngle;
    const endAngle = shape.endAngle;
    const clockwise = shape.clockwise;
    const unitX = Math.cos(startAngle);
    const unitY = Math.sin(startAngle);
    ctx.moveTo(unitX * r + x, unitY * r + y);
    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
  }
};
Arc.prototype.type = "arc";
var Arc_default = Arc;

// ../zrender/src/graphic/CompoundPath.ts
var CompoundPath = class extends Path_default {
  constructor() {
    super(...arguments);
    this.type = "compound";
  }
  _updatePathDirty() {
    const paths = this.shape.paths;
    let dirtyPath = this.shapeChanged();
    for (let i = 0; i < paths.length; i++) {
      dirtyPath = dirtyPath || paths[i].shapeChanged();
    }
    if (dirtyPath) {
      this.dirtyShape();
    }
  }
  beforeBrush() {
    this._updatePathDirty();
    const paths = this.shape.paths || [];
    const scale4 = this.getGlobalScale();
    for (let i = 0; i < paths.length; i++) {
      if (!paths[i].path) {
        paths[i].createPathProxy();
      }
      paths[i].path.setScale(scale4[0], scale4[1], paths[i].segmentIgnoreThreshold);
    }
  }
  buildPath(ctx, shape) {
    const paths = shape.paths || [];
    for (let i = 0; i < paths.length; i++) {
      paths[i].buildPath(ctx, paths[i].shape, true);
    }
  }
  afterBrush() {
    const paths = this.shape.paths || [];
    for (let i = 0; i < paths.length; i++) {
      paths[i].pathUpdated();
    }
  }
  getBoundingRect() {
    this._updatePathDirty.call(this);
    return Path_default.prototype.getBoundingRect.call(this);
  }
};
var CompoundPath_default = CompoundPath;

// ../zrender/src/graphic/Gradient.ts
var Gradient = class {
  constructor(colorStops) {
    this.colorStops = colorStops || [];
  }
  addColorStop(offset, color4) {
    this.colorStops.push({
      offset,
      color: color4
    });
  }
};
var Gradient_default = Gradient;

// ../zrender/src/graphic/LinearGradient.ts
var LinearGradient = class extends Gradient_default {
  constructor(x, y, x2, y2, colorStops, globalCoord) {
    super(colorStops);
    this.x = x == null ? 0 : x;
    this.y = y == null ? 0 : y;
    this.x2 = x2 == null ? 1 : x2;
    this.y2 = y2 == null ? 0 : y2;
    this.type = "linear";
    this.global = globalCoord || false;
  }
};
var LinearGradient_default = LinearGradient;

// ../zrender/src/graphic/RadialGradient.ts
var RadialGradient = class extends Gradient_default {
  constructor(x, y, r, colorStops, globalCoord) {
    super(colorStops);
    this.x = x == null ? 0.5 : x;
    this.y = y == null ? 0.5 : y;
    this.r = r == null ? 0.5 : r;
    this.type = "radial";
    this.global = globalCoord || false;
  }
};
var RadialGradient_default = RadialGradient;

// ../zrender/src/core/OrientedBoundingRect.ts
var mathMin6 = Math.min;
var mathMax6 = Math.max;
var mathAbs5 = Math.abs;
var _extent = [0, 0];
var _extent2 = [0, 0];
var _intersectCtx2 = createIntersectContext();
var _minTv2 = _intersectCtx2.minTv;
var _maxTv2 = _intersectCtx2.maxTv;
var OrientedBoundingRect = class {
  constructor(rect, transform2) {
    this._corners = [];
    this._axes = [];
    this._origin = [0, 0];
    for (let i = 0; i < 4; i++) {
      this._corners[i] = new Point_default();
    }
    for (let i = 0; i < 2; i++) {
      this._axes[i] = new Point_default();
    }
    if (rect) {
      this.fromBoundingRect(rect, transform2);
    }
  }
  fromBoundingRect(rect, transform2) {
    const corners = this._corners;
    const axes = this._axes;
    const x = rect.x;
    const y = rect.y;
    const x2 = x + rect.width;
    const y2 = y + rect.height;
    corners[0].set(x, y);
    corners[1].set(x2, y);
    corners[2].set(x2, y2);
    corners[3].set(x, y2);
    if (transform2) {
      for (let i = 0; i < 4; i++) {
        corners[i].transform(transform2);
      }
    }
    Point_default.sub(axes[0], corners[1], corners[0]);
    Point_default.sub(axes[1], corners[3], corners[0]);
    axes[0].normalize();
    axes[1].normalize();
    for (let i = 0; i < 2; i++) {
      this._origin[i] = axes[i].dot(corners[0]);
    }
  }
  intersect(other, mtv, opt) {
    let overlapped = true;
    const noMtv = !mtv;
    if (mtv) {
      Point_default.set(mtv, 0, 0);
    }
    _intersectCtx2.reset(opt, !noMtv);
    if (!this._intersectCheckOneSide(this, other, noMtv, 1)) {
      overlapped = false;
      if (noMtv) {
        return overlapped;
      }
    }
    if (!this._intersectCheckOneSide(other, this, noMtv, -1)) {
      overlapped = false;
      if (noMtv) {
        return overlapped;
      }
    }
    if (!noMtv && !_intersectCtx2.negativeSize) {
      Point_default.copy(mtv, overlapped ? _intersectCtx2.useDir ? _intersectCtx2.dirMinTv : _minTv2 : _maxTv2);
    }
    return overlapped;
  }
  _intersectCheckOneSide(self2, other, noMtv, inverse) {
    let overlapped = true;
    for (let i = 0; i < 2; i++) {
      const axis = self2._axes[i];
      self2._getProjMinMaxOnAxis(i, self2._corners, _extent);
      self2._getProjMinMaxOnAxis(i, other._corners, _extent2);
      if (_intersectCtx2.negativeSize || _extent[1] < _extent2[0] || _extent[0] > _extent2[1]) {
        overlapped = false;
        if (_intersectCtx2.negativeSize || noMtv) {
          return overlapped;
        }
        const dist0 = mathAbs5(_extent2[0] - _extent[1]);
        const dist1 = mathAbs5(_extent[0] - _extent2[1]);
        if (mathMin6(dist0, dist1) > _maxTv2.len()) {
          if (dist0 < dist1) {
            Point_default.scale(_maxTv2, axis, -dist0 * inverse);
          } else {
            Point_default.scale(_maxTv2, axis, dist1 * inverse);
          }
        }
      } else if (!noMtv) {
        const dist0 = mathAbs5(_extent2[0] - _extent[1]);
        const dist1 = mathAbs5(_extent[0] - _extent2[1]);
        if (_intersectCtx2.useDir || mathMin6(dist0, dist1) < _minTv2.len()) {
          if (dist0 < dist1 || !_intersectCtx2.bidirectional) {
            Point_default.scale(_minTv2, axis, dist0 * inverse);
            if (_intersectCtx2.useDir) {
              _intersectCtx2.calcDirMTV();
            }
          }
          if (dist0 >= dist1 || !_intersectCtx2.bidirectional) {
            Point_default.scale(_minTv2, axis, -dist1 * inverse);
            if (_intersectCtx2.useDir) {
              _intersectCtx2.calcDirMTV();
            }
          }
        }
      }
    }
    return overlapped;
  }
  _getProjMinMaxOnAxis(dim, corners, out2) {
    const axis = this._axes[dim];
    const origin = this._origin;
    const proj = corners[0].dot(axis) + origin[dim];
    let min3 = proj;
    let max3 = proj;
    for (let i = 1; i < corners.length; i++) {
      const proj2 = corners[i].dot(axis) + origin[dim];
      min3 = mathMin6(proj2, min3);
      max3 = mathMax6(proj2, max3);
    }
    out2[0] = min3 + _intersectCtx2.touchThreshold;
    out2[1] = max3 - _intersectCtx2.touchThreshold;
    _intersectCtx2.negativeSize = out2[1] < out2[0];
  }
};
var OrientedBoundingRect_default = OrientedBoundingRect;

// ../zrender/src/graphic/IncrementalDisplayable.ts
var m = [];
var IncrementalDisplayable = class extends Displayable_default {
  constructor() {
    super(...arguments);
    this.notClear = true;
    this.incremental = true;
    this._displayables = [];
    this._temporaryDisplayables = [];
    this._cursor = 0;
  }
  traverse(cb, context) {
    cb.call(context, this);
  }
  useStyle() {
    this.style = {};
  }
  getCursor() {
    return this._cursor;
  }
  innerAfterBrush() {
    this._cursor = this._displayables.length;
  }
  clearDisplaybles() {
    this._displayables = [];
    this._temporaryDisplayables = [];
    this._cursor = 0;
    this.markRedraw();
    this.notClear = false;
  }
  clearTemporalDisplayables() {
    this._temporaryDisplayables = [];
  }
  addDisplayable(displayable, notPersistent) {
    if (notPersistent) {
      this._temporaryDisplayables.push(displayable);
    } else {
      this._displayables.push(displayable);
    }
    this.markRedraw();
  }
  addDisplayables(displayables, notPersistent) {
    notPersistent = notPersistent || false;
    for (let i = 0; i < displayables.length; i++) {
      this.addDisplayable(displayables[i], notPersistent);
    }
  }
  getDisplayables() {
    return this._displayables;
  }
  getTemporalDisplayables() {
    return this._temporaryDisplayables;
  }
  eachPendingDisplayable(cb) {
    for (let i = this._cursor; i < this._displayables.length; i++) {
      cb && cb(this._displayables[i]);
    }
    for (let i = 0; i < this._temporaryDisplayables.length; i++) {
      cb && cb(this._temporaryDisplayables[i]);
    }
  }
  update() {
    this.updateTransform();
    for (let i = this._cursor; i < this._displayables.length; i++) {
      const displayable = this._displayables[i];
      displayable.parent = this;
      displayable.update();
      displayable.parent = null;
    }
    for (let i = 0; i < this._temporaryDisplayables.length; i++) {
      const displayable = this._temporaryDisplayables[i];
      displayable.parent = this;
      displayable.update();
      displayable.parent = null;
    }
  }
  getBoundingRect() {
    if (!this._rect) {
      const rect = new BoundingRect_default(Infinity, Infinity, -Infinity, -Infinity);
      for (let i = 0; i < this._displayables.length; i++) {
        const displayable = this._displayables[i];
        const childRect = displayable.getBoundingRect().clone();
        if (displayable.needLocalTransform()) {
          childRect.applyTransform(displayable.getLocalTransform(m));
        }
        rect.union(childRect);
      }
      this._rect = rect;
    }
    return this._rect;
  }
  contain(x, y) {
    const localPos = this.transformCoordToLocal(x, y);
    const rect = this.getBoundingRect();
    if (rect.contain(localPos[0], localPos[1])) {
      for (let i = 0; i < this._displayables.length; i++) {
        const displayable = this._displayables[i];
        if (displayable.contain(x, y)) {
          return true;
        }
      }
    }
    return false;
  }
};
var IncrementalDisplayable_default = IncrementalDisplayable;

// src/animation/basicTransition.ts
var transitionStore = makeInner();
function getAnimationConfig(animationType, animatableModel, dataIndex, extraOpts, extraDelayParams) {
  let animationPayload;
  if (animatableModel && animatableModel.ecModel) {
    const updatePayload = animatableModel.ecModel.getUpdatePayload();
    animationPayload = updatePayload && updatePayload.animation;
  }
  const animationEnabled = animatableModel && animatableModel.isAnimationEnabled();
  const isUpdate = animationType === "update";
  if (animationEnabled) {
    let duration;
    let easing;
    let delay;
    if (extraOpts) {
      duration = retrieve2(extraOpts.duration, 200);
      easing = retrieve2(extraOpts.easing, "cubicOut");
      delay = 0;
    } else {
      duration = animatableModel.getShallow(isUpdate ? "animationDurationUpdate" : "animationDuration");
      easing = animatableModel.getShallow(isUpdate ? "animationEasingUpdate" : "animationEasing");
      delay = animatableModel.getShallow(isUpdate ? "animationDelayUpdate" : "animationDelay");
    }
    if (animationPayload) {
      animationPayload.duration != null && (duration = animationPayload.duration);
      animationPayload.easing != null && (easing = animationPayload.easing);
      animationPayload.delay != null && (delay = animationPayload.delay);
    }
    if (isFunction(delay)) {
      delay = delay(dataIndex, extraDelayParams);
    }
    if (isFunction(duration)) {
      duration = duration(dataIndex);
    }
    const config = {
      duration: duration || 0,
      delay,
      easing
    };
    return config;
  } else {
    return null;
  }
}
function animateOrSetProps(animationType, el, props, animatableModel, dataIndex, cb, during) {
  let isFrom = false;
  let removeOpt;
  if (isFunction(dataIndex)) {
    during = cb;
    cb = dataIndex;
    dataIndex = null;
  } else if (isObject(dataIndex)) {
    cb = dataIndex.cb;
    during = dataIndex.during;
    isFrom = dataIndex.isFrom;
    removeOpt = dataIndex.removeOpt;
    dataIndex = dataIndex.dataIndex;
  }
  const isRemove = animationType === "leave";
  if (!isRemove) {
    el.stopAnimation("leave");
  }
  const animationConfig = getAnimationConfig(animationType, animatableModel, dataIndex, isRemove ? removeOpt || {} : null, animatableModel && animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);
  if (animationConfig && animationConfig.duration > 0) {
    const duration = animationConfig.duration;
    const animationDelay = animationConfig.delay;
    const animationEasing = animationConfig.easing;
    const animateConfig = {
      duration,
      delay: animationDelay || 0,
      easing: animationEasing,
      done: cb,
      force: !!cb || !!during,
      setToFinal: !isRemove,
      scope: animationType,
      during
    };
    isFrom ? el.animateFrom(props, animateConfig) : el.animateTo(props, animateConfig);
  } else {
    el.stopAnimation();
    !isFrom && el.attr(props);
    during && during(1);
    cb && cb();
  }
}
function updateProps(el, props, animatableModel, dataIndex, cb, during) {
  animateOrSetProps("update", el, props, animatableModel, dataIndex, cb, during);
}
function initProps(el, props, animatableModel, dataIndex, cb, during) {
  animateOrSetProps("enter", el, props, animatableModel, dataIndex, cb, during);
}
function isElementRemoved(el) {
  if (!el.__zr) {
    return true;
  }
  for (let i = 0; i < el.animators.length; i++) {
    const animator = el.animators[i];
    if (animator.scope === "leave") {
      return true;
    }
  }
  return false;
}
function removeElement(el, props, animatableModel, dataIndex, cb, during) {
  if (isElementRemoved(el)) {
    return;
  }
  animateOrSetProps("leave", el, props, animatableModel, dataIndex, cb, during);
}
function fadeOutDisplayable(el, animatableModel, dataIndex, done) {
  el.removeTextContent();
  el.removeTextGuideLine();
  removeElement(el, {
    style: {
      opacity: 0
    }
  }, animatableModel, dataIndex, done);
}
function removeElementWithFadeOut(el, animatableModel, dataIndex) {
  function doRemove() {
    el.parent && el.parent.remove(el);
  }
  if (!el.isGroup) {
    fadeOutDisplayable(el, animatableModel, dataIndex, doRemove);
  } else {
    el.traverse(function(disp) {
      if (!disp.isGroup) {
        fadeOutDisplayable(disp, animatableModel, dataIndex, doRemove);
      }
    });
  }
}
function saveOldStyle(el) {
  transitionStore(el).oldStyle = el.style;
}
function getOldStyle(el) {
  return transitionStore(el).oldStyle;
}

// src/util/graphic.ts
var _customShapeMap = {};
var XY2 = ["x", "y"];
var WH2 = ["width", "height"];
function extendShape(opts) {
  return Path_default.extend(opts);
}
var extendPathFromString = extendFromString;
function extendPath(pathData, opts) {
  return extendPathFromString(pathData, opts);
}
function registerShape(name, ShapeClass) {
  _customShapeMap[name] = ShapeClass;
}
function getShapeClass(name) {
  if (_customShapeMap.hasOwnProperty(name)) {
    return _customShapeMap[name];
  }
}
function makePath(pathData, opts, rect, layout14) {
  const path = createFromString(pathData, opts);
  if (rect) {
    if (layout14 === "center") {
      rect = centerGraphic(rect, path.getBoundingRect());
    }
    resizePath(path, rect);
  }
  return path;
}
function makeImage(imageUrl, rect, layout14) {
  const zrImg = new Image_default({
    style: {
      image: imageUrl,
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    onload(img) {
      if (layout14 === "center") {
        const boundingRect = {
          width: img.width,
          height: img.height
        };
        zrImg.setStyle(centerGraphic(rect, boundingRect));
      }
    }
  });
  return zrImg;
}
function centerGraphic(rect, boundingRect) {
  const aspect = boundingRect.width / boundingRect.height;
  let width = rect.height * aspect;
  let height;
  if (width <= rect.width) {
    height = rect.height;
  } else {
    width = rect.width;
    height = width / aspect;
  }
  const cx = rect.x + rect.width / 2;
  const cy = rect.y + rect.height / 2;
  return {
    x: cx - width / 2,
    y: cy - height / 2,
    width,
    height
  };
}
var mergePath2 = mergePath;
function resizePath(path, rect) {
  if (!path.applyTransform) {
    return;
  }
  const pathRect = path.getBoundingRect();
  const m2 = pathRect.calculateTransform(rect);
  path.applyTransform(m2);
}
function subPixelOptimizeLine2(shape, lineWidth) {
  subPixelOptimizeLine(shape, shape, {lineWidth});
  return shape;
}
function subPixelOptimizeRect2(shape, style) {
  subPixelOptimizeRect(shape, shape, style);
  return shape;
}
var subPixelOptimize2 = subPixelOptimize;
function getTransform(target, ancestor) {
  const mat = identity([]);
  while (target && target !== ancestor) {
    mul2(mat, target.getLocalTransform(), mat);
    target = target.parent;
  }
  return mat;
}
function applyTransform2(target, transform2, invert2) {
  if (transform2 && !isArrayLike(transform2)) {
    transform2 = Transformable_default.getLocalTransform(transform2);
  }
  if (invert2) {
    transform2 = invert([], transform2);
  }
  return applyTransform([], target, transform2);
}
function transformDirection(direction, transform2, invert2) {
  const hBase = transform2[4] === 0 || transform2[5] === 0 || transform2[0] === 0 ? 1 : mathAbs2(2 * transform2[4] / transform2[0]);
  const vBase = transform2[4] === 0 || transform2[5] === 0 || transform2[2] === 0 ? 1 : mathAbs2(2 * transform2[4] / transform2[2]);
  let vertex = [
    direction === "left" ? -hBase : direction === "right" ? hBase : 0,
    direction === "top" ? -vBase : direction === "bottom" ? vBase : 0
  ];
  vertex = applyTransform2(vertex, transform2, invert2);
  return mathAbs2(vertex[0]) > mathAbs2(vertex[1]) ? vertex[0] > 0 ? "right" : "left" : vertex[1] > 0 ? "bottom" : "top";
}
function isNotGroup(el) {
  return !el.isGroup;
}
function isPath(el) {
  return el.shape != null;
}
function groupTransition(g1, g2, animatableModel) {
  if (!g1 || !g2) {
    return;
  }
  function getElMap(g) {
    const elMap = {};
    g.traverse(function(el) {
      if (isNotGroup(el) && el.anid) {
        elMap[el.anid] = el;
      }
    });
    return elMap;
  }
  function getAnimatableProps(el) {
    const obj = {
      x: el.x,
      y: el.y,
      rotation: el.rotation
    };
    if (isPath(el)) {
      obj.shape = clone(el.shape);
    }
    return obj;
  }
  const elMap1 = getElMap(g1);
  g2.traverse(function(el) {
    if (isNotGroup(el) && el.anid) {
      const oldEl = elMap1[el.anid];
      if (oldEl) {
        const newProp = getAnimatableProps(el);
        el.attr(getAnimatableProps(oldEl));
        updateProps(el, newProp, animatableModel, getECData(el).dataIndex);
      }
    }
  });
}
function clipPointsByRect(points4, rect) {
  return map(points4, function(point) {
    let x = point[0];
    x = mathMax2(x, rect.x);
    x = mathMin2(x, rect.x + rect.width);
    let y = point[1];
    y = mathMax2(y, rect.y);
    y = mathMin2(y, rect.y + rect.height);
    return [x, y];
  });
}
function clipRectByRect(targetRect, rect) {
  const x = mathMax2(targetRect.x, rect.x);
  const x2 = mathMin2(targetRect.x + targetRect.width, rect.x + rect.width);
  const y = mathMax2(targetRect.y, rect.y);
  const y2 = mathMin2(targetRect.y + targetRect.height, rect.y + rect.height);
  if (x2 >= x && y2 >= y) {
    return {
      x,
      y,
      width: x2 - x,
      height: y2 - y
    };
  }
}
function createIcon(iconStr, opt, rect) {
  const innerOpts = extend({rectHover: true}, opt);
  const style = innerOpts.style = {strokeNoScale: true};
  rect = rect || {x: -1, y: -1, width: 2, height: 2};
  if (iconStr) {
    return iconStr.indexOf("image://") === 0 ? (style.image = iconStr.slice(8), defaults(style, rect), new Image_default(innerOpts)) : makePath(iconStr.replace("path://", ""), innerOpts, rect, "center");
  }
}
function linePolygonIntersect(a1x, a1y, a2x, a2y, points4) {
  for (let i = 0, p2 = points4[points4.length - 1]; i < points4.length; i++) {
    const p = points4[i];
    if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) {
      return true;
    }
    p2 = p;
  }
}
function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
  const mx = a2x - a1x;
  const my = a2y - a1y;
  const nx = b2x - b1x;
  const ny = b2y - b1y;
  const nmCrossProduct = crossProduct2d(nx, ny, mx, my);
  if (nearZero(nmCrossProduct)) {
    return false;
  }
  const b1a1x = a1x - b1x;
  const b1a1y = a1y - b1y;
  const q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;
  if (q < 0 || q > 1) {
    return false;
  }
  const p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
  if (p < 0 || p > 1) {
    return false;
  }
  return true;
}
function crossProduct2d(x1, y1, x2, y2) {
  return x1 * y2 - x2 * y1;
}
function nearZero(val) {
  return val <= 1e-6 && val >= -1e-6;
}
function expandOrShrinkRect(rect, delta, shrinkOrExpand, noNegative, minSize) {
  if (delta == null) {
    return rect;
  } else if (isNumber(delta)) {
    _tmpExpandRectDelta[0] = _tmpExpandRectDelta[1] = _tmpExpandRectDelta[2] = _tmpExpandRectDelta[3] = delta;
  } else {
    _tmpExpandRectDelta[0] = delta[0];
    _tmpExpandRectDelta[1] = delta[1];
    _tmpExpandRectDelta[2] = delta[2];
    _tmpExpandRectDelta[3] = delta[3];
  }
  if (noNegative) {
    _tmpExpandRectDelta[0] = mathMax2(0, _tmpExpandRectDelta[0]);
    _tmpExpandRectDelta[1] = mathMax2(0, _tmpExpandRectDelta[1]);
    _tmpExpandRectDelta[2] = mathMax2(0, _tmpExpandRectDelta[2]);
    _tmpExpandRectDelta[3] = mathMax2(0, _tmpExpandRectDelta[3]);
  }
  if (shrinkOrExpand) {
    _tmpExpandRectDelta[0] = -_tmpExpandRectDelta[0];
    _tmpExpandRectDelta[1] = -_tmpExpandRectDelta[1];
    _tmpExpandRectDelta[2] = -_tmpExpandRectDelta[2];
    _tmpExpandRectDelta[3] = -_tmpExpandRectDelta[3];
  }
  expandRectOnOneDimension(rect, _tmpExpandRectDelta, "x", "width", 3, 1, minSize && minSize[0] || 0);
  expandRectOnOneDimension(rect, _tmpExpandRectDelta, "y", "height", 0, 2, minSize && minSize[1] || 0);
  return rect;
}
var _tmpExpandRectDelta = [0, 0, 0, 0];
function expandRectOnOneDimension(rect, delta, xy, wh, ltIdx, rbIdx, minSize) {
  const deltaSum = delta[rbIdx] + delta[ltIdx];
  const oldSize = rect[wh];
  rect[wh] += deltaSum;
  minSize = mathMax2(0, mathMin2(minSize, oldSize));
  if (rect[wh] < minSize) {
    rect[wh] = minSize;
    rect[xy] += delta[ltIdx] >= 0 ? -delta[ltIdx] : delta[rbIdx] >= 0 ? oldSize + delta[rbIdx] : mathAbs2(deltaSum) > 1e-8 ? (oldSize - minSize) * delta[ltIdx] / deltaSum : 0;
  } else {
    rect[xy] -= delta[ltIdx];
  }
}
function setTooltipConfig(opt) {
  const itemTooltipOption = opt.itemTooltipOption;
  const componentModel = opt.componentModel;
  const itemName = opt.itemName;
  const itemTooltipOptionObj = isString(itemTooltipOption) ? {formatter: itemTooltipOption} : itemTooltipOption;
  const mainType = componentModel.mainType;
  const componentIndex = componentModel.componentIndex;
  const formatterParams = {
    componentType: mainType,
    name: itemName,
    $vars: ["name"]
  };
  formatterParams[mainType + "Index"] = componentIndex;
  const formatterParamsExtra = opt.formatterParamsExtra;
  if (formatterParamsExtra) {
    each(keys(formatterParamsExtra), (key) => {
      if (!hasOwn(formatterParams, key)) {
        formatterParams[key] = formatterParamsExtra[key];
        formatterParams.$vars.push(key);
      }
    });
  }
  const ecData = getECData(opt.el);
  ecData.componentMainType = mainType;
  ecData.componentIndex = componentIndex;
  ecData.tooltipConfig = {
    name: itemName,
    option: defaults({
      content: itemName,
      encodeHTMLContent: true,
      formatterParams
    }, itemTooltipOptionObj)
  };
}
function traverseElement(el, cb) {
  let stopped;
  if (el.isGroup) {
    stopped = cb(el);
  }
  if (!stopped) {
    el.traverse(cb);
  }
}
function traverseElements(els, cb) {
  if (els) {
    if (isArray(els)) {
      for (let i = 0; i < els.length; i++) {
        traverseElement(els[i], cb);
      }
    } else {
      traverseElement(els, cb);
    }
  }
}
function isBoundingRectAxisAligned(transform2) {
  return !transform2 || mathAbs2(transform2[1]) < AXIS_ALIGN_EPSILON && mathAbs2(transform2[2]) < AXIS_ALIGN_EPSILON || mathAbs2(transform2[0]) < AXIS_ALIGN_EPSILON && mathAbs2(transform2[3]) < AXIS_ALIGN_EPSILON;
}
var AXIS_ALIGN_EPSILON = 1e-5;
function retrieveZInfo(model) {
  return {
    z: model.get("z") || 0,
    zlevel: model.get("zlevel") || 0
  };
}
function calcZ2Range(el) {
  let max3 = -Infinity;
  let min3 = Infinity;
  traverseElement(el, (el2) => {
    visitEl(el2);
    visitEl(el2.getTextContent());
    visitEl(el2.getTextGuideLine());
  });
  function visitEl(el2) {
    if (!el2 || el2.isGroup) {
      return;
    }
    const currentStates = el2.currentStates;
    if (currentStates.length) {
      for (let idx = 0; idx < currentStates.length; idx++) {
        calcZ2(el2.states[currentStates[idx]]);
      }
    }
    calcZ2(el2);
  }
  function calcZ2(entity) {
    if (entity) {
      const z2 = entity.z2;
      if (z2 > max3) {
        max3 = z2;
      }
      if (z2 < min3) {
        min3 = z2;
      }
    }
  }
  if (min3 > max3) {
    min3 = max3 = 0;
  }
  return {min: min3, max: max3};
}
function traverseUpdateZ(el, z, zlevel) {
  doUpdateZ(el, z, zlevel, -Infinity);
}
function doUpdateZ(el, z, zlevel, maxZ2) {
  if (el.ignoreModelZ) {
    return maxZ2;
  }
  const label = el.getTextContent();
  const labelLine = el.getTextGuideLine();
  const isGroup = el.isGroup;
  if (isGroup) {
    const children = el.childrenRef();
    for (let i = 0; i < children.length; i++) {
      maxZ2 = mathMax2(doUpdateZ(children[i], z, zlevel, maxZ2), maxZ2);
    }
  } else {
    el.z = z;
    el.zlevel = zlevel;
    maxZ2 = mathMax2(el.z2 || 0, maxZ2);
  }
  if (label) {
    label.z = z;
    label.zlevel = zlevel;
    isFinite(maxZ2) && (label.z2 = maxZ2 + 2);
  }
  if (labelLine) {
    const textGuideLineConfig = el.textGuideLineConfig;
    labelLine.z = z;
    labelLine.zlevel = zlevel;
    isFinite(maxZ2) && (labelLine.z2 = maxZ2 + (textGuideLineConfig && textGuideLineConfig.showAbove ? 1 : -1));
  }
  return maxZ2;
}
registerShape("circle", Circle_default);
registerShape("ellipse", Ellipse_default);
registerShape("sector", Sector_default);
registerShape("ring", Ring_default);
registerShape("polygon", Polygon_default);
registerShape("polyline", Polyline_default);
registerShape("rect", Rect_default);
registerShape("line", Line_default);
registerShape("bezierCurve", BezierCurve_default);
registerShape("arc", Arc_default);

// src/label/labelStyle.ts
var EMPTY_OBJ = {};
function setLabelText(label, labelTexts) {
  for (let i = 0; i < SPECIAL_STATES.length; i++) {
    const stateName = SPECIAL_STATES[i];
    const text = labelTexts[stateName];
    const state = label.ensureState(stateName);
    state.style = state.style || {};
    state.style.text = text;
  }
  const oldStates = label.currentStates.slice();
  label.clearStates(true);
  label.setStyle({text: labelTexts.normal});
  label.useStates(oldStates, true);
}
function getLabelText(opt, stateModels, interpolatedValue) {
  const labelFetcher = opt.labelFetcher;
  const labelDataIndex = opt.labelDataIndex;
  const labelDimIndex = opt.labelDimIndex;
  const normalModel = stateModels.normal;
  let baseText;
  if (labelFetcher) {
    baseText = labelFetcher.getFormattedLabel(labelDataIndex, "normal", null, labelDimIndex, normalModel && normalModel.get("formatter"), interpolatedValue != null ? {
      interpolatedValue
    } : null);
  }
  if (baseText == null) {
    baseText = isFunction(opt.defaultText) ? opt.defaultText(labelDataIndex, opt, interpolatedValue) : opt.defaultText;
  }
  const statesText = {
    normal: baseText
  };
  for (let i = 0; i < SPECIAL_STATES.length; i++) {
    const stateName = SPECIAL_STATES[i];
    const stateModel = stateModels[stateName];
    statesText[stateName] = retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, stateName, null, labelDimIndex, stateModel && stateModel.get("formatter")) : null, baseText);
  }
  return statesText;
}
function setLabelStyle(targetEl, labelStatesModels, opt, stateSpecified) {
  opt = opt || EMPTY_OBJ;
  const isSetOnText = targetEl instanceof Text_default;
  let needsCreateText = false;
  for (let i = 0; i < DISPLAY_STATES.length; i++) {
    const stateModel = labelStatesModels[DISPLAY_STATES[i]];
    if (stateModel && stateModel.getShallow("show")) {
      needsCreateText = true;
      break;
    }
  }
  let textContent = isSetOnText ? targetEl : targetEl.getTextContent();
  if (needsCreateText) {
    if (!isSetOnText) {
      if (!textContent) {
        textContent = new Text_default();
        targetEl.setTextContent(textContent);
      }
      if (targetEl.stateProxy) {
        textContent.stateProxy = targetEl.stateProxy;
      }
    }
    const labelStatesTexts = getLabelText(opt, labelStatesModels);
    const normalModel = labelStatesModels.normal;
    const showNormal = !!normalModel.getShallow("show");
    const normalStyle = createTextStyle(normalModel, stateSpecified && stateSpecified.normal, opt, false, !isSetOnText);
    normalStyle.text = labelStatesTexts.normal;
    if (!isSetOnText) {
      targetEl.setTextConfig(createTextConfig(normalModel, opt, false));
    }
    for (let i = 0; i < SPECIAL_STATES.length; i++) {
      const stateName = SPECIAL_STATES[i];
      const stateModel = labelStatesModels[stateName];
      if (stateModel) {
        const stateObj = textContent.ensureState(stateName);
        const stateShow = !!retrieve2(stateModel.getShallow("show"), showNormal);
        if (stateShow !== showNormal) {
          stateObj.ignore = !stateShow;
        }
        stateObj.style = createTextStyle(stateModel, stateSpecified && stateSpecified[stateName], opt, true, !isSetOnText);
        stateObj.style.text = labelStatesTexts[stateName];
        if (!isSetOnText) {
          const targetElEmphasisState = targetEl.ensureState(stateName);
          targetElEmphasisState.textConfig = createTextConfig(stateModel, opt, true);
        }
      }
    }
    textContent.silent = !!normalModel.getShallow("silent");
    if (textContent.style.x != null) {
      normalStyle.x = textContent.style.x;
    }
    if (textContent.style.y != null) {
      normalStyle.y = textContent.style.y;
    }
    textContent.ignore = !showNormal;
    textContent.useStyle(normalStyle);
    textContent.dirty();
    if (opt.enableTextSetter) {
      labelInner(textContent).setLabelText = function(interpolatedValue) {
        const labelStatesTexts2 = getLabelText(opt, labelStatesModels, interpolatedValue);
        setLabelText(textContent, labelStatesTexts2);
      };
    }
  } else if (textContent) {
    textContent.ignore = true;
  }
  targetEl.dirty();
}
function getLabelStatesModels(itemModel, labelName) {
  labelName = labelName || "label";
  const statesModels = {
    normal: itemModel.getModel(labelName)
  };
  for (let i = 0; i < SPECIAL_STATES.length; i++) {
    const stateName = SPECIAL_STATES[i];
    statesModels[stateName] = itemModel.getModel([stateName, labelName]);
  }
  return statesModels;
}
function createTextStyle(textStyleModel, specifiedTextStyle, opt, isNotNormal, isAttached) {
  const textStyle = {};
  setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached);
  specifiedTextStyle && extend(textStyle, specifiedTextStyle);
  return textStyle;
}
function createTextConfig(textStyleModel, opt, isNotNormal) {
  opt = opt || {};
  const textConfig = {};
  let labelPosition;
  let labelRotate = textStyleModel.getShallow("rotate");
  const labelDistance = retrieve2(textStyleModel.getShallow("distance"), isNotNormal ? null : 5);
  const labelOffset = textStyleModel.getShallow("offset");
  labelPosition = textStyleModel.getShallow("position") || (isNotNormal ? null : "inside");
  labelPosition === "outside" && (labelPosition = opt.defaultOutsidePosition || "top");
  if (labelPosition != null) {
    textConfig.position = labelPosition;
  }
  if (labelOffset != null) {
    textConfig.offset = labelOffset;
  }
  if (labelRotate != null) {
    labelRotate *= Math.PI / 180;
    textConfig.rotation = labelRotate;
  }
  if (labelDistance != null) {
    textConfig.distance = labelDistance;
  }
  textConfig.outsideFill = textStyleModel.get("color") === "inherit" ? opt.inheritColor || null : "auto";
  if (opt.autoOverflowArea != null) {
    textConfig.autoOverflowArea = opt.autoOverflowArea;
  }
  if (opt.layoutRect != null) {
    textConfig.layoutRect = opt.layoutRect;
  }
  return textConfig;
}
function setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached) {
  opt = opt || EMPTY_OBJ;
  const ecModel = textStyleModel.ecModel;
  const globalTextStyle = ecModel && ecModel.option.textStyle;
  const richItemNames = getRichItemNames(textStyleModel);
  let richResult;
  if (richItemNames) {
    richResult = {};
    const richInheritPlainLabelOptionName = "richInheritPlainLabel";
    const richInheritPlainLabel = retrieve2(textStyleModel.get(richInheritPlainLabelOptionName), ecModel ? ecModel.get(richInheritPlainLabelOptionName) : void 0);
    for (const name in richItemNames) {
      if (richItemNames.hasOwnProperty(name)) {
        const richTextStyle = textStyleModel.getModel(["rich", name]);
        setTokenTextStyle(richResult[name] = {}, richTextStyle, globalTextStyle, textStyleModel, richInheritPlainLabel, opt, isNotNormal, isAttached, false, true);
      }
    }
  }
  if (richResult) {
    textStyle.rich = richResult;
  }
  const overflow = textStyleModel.get("overflow");
  if (overflow) {
    textStyle.overflow = overflow;
  }
  const minMargin = textStyleModel.get("minMargin");
  if (minMargin != null) {
    textStyle.margin = minMargin;
    textStyle.__marginType = LabelMarginType.minMargin;
  }
  const textMargin = textStyleModel.get("textMargin");
  if (textMargin != null) {
    textStyle.margin = clone(textMargin);
    textStyle.__marginType = LabelMarginType.textMargin;
  } else if (opt.defaultTextMargin != null) {
    textStyle.margin = clone(opt.defaultTextMargin);
    textStyle.__marginType = LabelMarginType.textMargin;
  }
  const lineOverflow = textStyleModel.get("lineOverflow");
  if (lineOverflow) {
    textStyle.lineOverflow = lineOverflow;
  }
  setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, null, null, opt, isNotNormal, isAttached, true, false);
}
function getRichItemNames(textStyleModel) {
  let richItemNameMap;
  while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
    const rich = (textStyleModel.option || EMPTY_OBJ).rich;
    if (rich) {
      richItemNameMap = richItemNameMap || {};
      const richKeys = keys(rich);
      for (let i = 0; i < richKeys.length; i++) {
        const richKey = richKeys[i];
        richItemNameMap[richKey] = 1;
      }
    }
    textStyleModel = textStyleModel.parentModel;
  }
  return richItemNameMap;
}
var TEXT_PROPS_WITH_GLOBAL = [
  "fontStyle",
  "fontWeight",
  "fontSize",
  "fontFamily",
  "textShadowColor",
  "textShadowBlur",
  "textShadowOffsetX",
  "textShadowOffsetY"
];
var TEXT_PROPS_SELF = [
  "align",
  "lineHeight",
  "width",
  "height",
  "tag",
  "verticalAlign",
  "ellipsis"
];
var TEXT_PROPS_BOX = [
  "padding",
  "borderWidth",
  "borderRadius",
  "borderDashOffset",
  "backgroundColor",
  "borderColor",
  "shadowColor",
  "shadowBlur",
  "shadowOffsetX",
  "shadowOffsetY"
];
function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, plainTextModel, richInheritPlainLabel, opt, isNotNormal, isAttached, isBlock, inRich) {
  globalTextStyle = !isNotNormal && globalTextStyle || EMPTY_OBJ;
  const inheritColor = opt && opt.inheritColor;
  let fillColor = textStyleModel.getShallow("color");
  let strokeColor = textStyleModel.getShallow("textBorderColor");
  let opacity = retrieve2(textStyleModel.getShallow("opacity"), globalTextStyle.opacity);
  if (fillColor === "inherit" || fillColor === "auto") {
    if (true) {
      if (fillColor === "auto") {
        deprecateReplaceLog("color: 'auto'", "color: 'inherit'");
      }
    }
    if (inheritColor) {
      fillColor = inheritColor;
    } else {
      fillColor = null;
    }
  }
  if (strokeColor === "inherit" || strokeColor === "auto") {
    if (true) {
      if (strokeColor === "auto") {
        deprecateReplaceLog("color: 'auto'", "color: 'inherit'");
      }
    }
    if (inheritColor) {
      strokeColor = inheritColor;
    } else {
      strokeColor = null;
    }
  }
  if (!isAttached) {
    fillColor = fillColor || globalTextStyle.color;
    strokeColor = strokeColor || globalTextStyle.textBorderColor;
  }
  if (fillColor != null) {
    textStyle.fill = fillColor;
  }
  if (strokeColor != null) {
    textStyle.stroke = strokeColor;
  }
  const textBorderWidth = retrieve2(textStyleModel.getShallow("textBorderWidth"), globalTextStyle.textBorderWidth);
  if (textBorderWidth != null) {
    textStyle.lineWidth = textBorderWidth;
  }
  const textBorderType = retrieve2(textStyleModel.getShallow("textBorderType"), globalTextStyle.textBorderType);
  if (textBorderType != null) {
    textStyle.lineDash = textBorderType;
  }
  const textBorderDashOffset = retrieve2(textStyleModel.getShallow("textBorderDashOffset"), globalTextStyle.textBorderDashOffset);
  if (textBorderDashOffset != null) {
    textStyle.lineDashOffset = textBorderDashOffset;
  }
  if (!isNotNormal && opacity == null && !inRich) {
    opacity = opt && opt.defaultOpacity;
  }
  if (opacity != null) {
    textStyle.opacity = opacity;
  }
  if (!isNotNormal && !isAttached) {
    if (textStyle.fill == null && opt.inheritColor) {
      textStyle.fill = opt.inheritColor;
    }
  }
  for (let i = 0; i < TEXT_PROPS_WITH_GLOBAL.length; i++) {
    const key = TEXT_PROPS_WITH_GLOBAL[i];
    const val = richInheritPlainLabel !== false && plainTextModel ? retrieve3(textStyleModel.getShallow(key), plainTextModel.getShallow(key), globalTextStyle[key]) : retrieve2(textStyleModel.getShallow(key), globalTextStyle[key]);
    if (val != null) {
      textStyle[key] = val;
    }
  }
  for (let i = 0; i < TEXT_PROPS_SELF.length; i++) {
    const key = TEXT_PROPS_SELF[i];
    const val = textStyleModel.getShallow(key);
    if (val != null) {
      textStyle[key] = val;
    }
  }
  if (textStyle.verticalAlign == null) {
    const baseline = textStyleModel.getShallow("baseline");
    if (baseline != null) {
      textStyle.verticalAlign = baseline;
    }
  }
  if (!isBlock || !opt.disableBox) {
    for (let i = 0; i < TEXT_PROPS_BOX.length; i++) {
      const key = TEXT_PROPS_BOX[i];
      const val = textStyleModel.getShallow(key);
      if (val != null) {
        textStyle[key] = val;
      }
    }
    const borderType = textStyleModel.getShallow("borderType");
    if (borderType != null) {
      textStyle.borderDash = borderType;
    }
    if ((textStyle.backgroundColor === "auto" || textStyle.backgroundColor === "inherit") && inheritColor) {
      if (true) {
        if (textStyle.backgroundColor === "auto") {
          deprecateReplaceLog("backgroundColor: 'auto'", "backgroundColor: 'inherit'");
        }
      }
      textStyle.backgroundColor = inheritColor;
    }
    if ((textStyle.borderColor === "auto" || textStyle.borderColor === "inherit") && inheritColor) {
      if (true) {
        if (textStyle.borderColor === "auto") {
          deprecateReplaceLog("borderColor: 'auto'", "borderColor: 'inherit'");
        }
      }
      textStyle.borderColor = inheritColor;
    }
  }
}
function getFont(opt, ecModel) {
  const gTextStyleModel = ecModel && ecModel.getModel("textStyle");
  return trim([
    opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow("fontStyle") || "",
    opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow("fontWeight") || "",
    (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow("fontSize") || 12) + "px",
    opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var labelInner = makeInner();
function setLabelValueAnimation(label, labelStatesModels, value, getDefaultText) {
  if (!label) {
    return;
  }
  const obj = labelInner(label);
  obj.prevValue = obj.value;
  obj.value = value;
  const normalLabelModel = labelStatesModels.normal;
  obj.valueAnimation = normalLabelModel.get("valueAnimation");
  if (obj.valueAnimation) {
    obj.precision = normalLabelModel.get("precision");
    obj.defaultInterpolatedText = getDefaultText;
    obj.statesModels = labelStatesModels;
  }
}
function animateLabelValue(textEl, dataIndex, data, animatableModel, labelFetcher) {
  const labelInnerStore = labelInner(textEl);
  if (!labelInnerStore.valueAnimation || labelInnerStore.prevValue === labelInnerStore.value) {
    return;
  }
  const defaultInterpolatedText = labelInnerStore.defaultInterpolatedText;
  const currValue = retrieve2(labelInnerStore.interpolatedValue, labelInnerStore.prevValue);
  const targetValue = labelInnerStore.value;
  function during(percent) {
    const interpolated = interpolateRawValues(data, labelInnerStore.precision, currValue, targetValue, percent);
    labelInnerStore.interpolatedValue = percent === 1 ? null : interpolated;
    const labelText = getLabelText({
      labelDataIndex: dataIndex,
      labelFetcher,
      defaultText: defaultInterpolatedText ? defaultInterpolatedText(interpolated) : interpolated + ""
    }, labelInnerStore.statesModels, interpolated);
    setLabelText(textEl, labelText);
  }
  textEl.percent = 0;
  (labelInnerStore.prevValue == null ? initProps : updateProps)(textEl, {
    percent: 1
  }, animatableModel, dataIndex, null, during);
}

// src/model/mixin/textStyle.ts
var PATH_COLOR = ["textStyle", "color"];
var textStyleParams = [
  "fontStyle",
  "fontWeight",
  "fontSize",
  "fontFamily",
  "padding",
  "lineHeight",
  "rich",
  "width",
  "height",
  "overflow"
];
var tmpText = new Text_default();
var TextStyleMixin = class {
  getTextColor(isEmphasis) {
    const ecModel = this.ecModel;
    return this.getShallow("color") || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
  }
  getFont() {
    return getFont({
      fontStyle: this.getShallow("fontStyle"),
      fontWeight: this.getShallow("fontWeight"),
      fontSize: this.getShallow("fontSize"),
      fontFamily: this.getShallow("fontFamily")
    }, this.ecModel);
  }
  getTextRect(text) {
    const style = {
      text,
      verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
    };
    for (let i = 0; i < textStyleParams.length; i++) {
      style[textStyleParams[i]] = this.getShallow(textStyleParams[i]);
    }
    tmpText.useStyle(style);
    tmpText.update();
    return tmpText.getBoundingRect();
  }
};
var textStyle_default = TextStyleMixin;

// src/model/mixin/lineStyle.ts
var LINE_STYLE_KEY_MAP = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
];
var getLineStyle = makeStyleMapper(LINE_STYLE_KEY_MAP);
var LineStyleMixin = class {
  getLineStyle(excludes) {
    return getLineStyle(this, excludes);
  }
};

// src/model/mixin/itemStyle.ts
var ITEM_STYLE_KEY_MAP = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
];
var getItemStyle = makeStyleMapper(ITEM_STYLE_KEY_MAP);
var ItemStyleMixin = class {
  getItemStyle(excludes, includes) {
    return getItemStyle(this, excludes, includes);
  }
};

// src/model/Model.ts
var Model = class {
  constructor(option, parentModel, ecModel) {
    this.parentModel = parentModel;
    this.ecModel = ecModel;
    this.option = option;
  }
  init(option, parentModel, ecModel, ...rest) {
  }
  mergeOption(option, ecModel) {
    merge(this.option, option, true);
  }
  get(path, ignoreParent) {
    if (path == null) {
      return this.option;
    }
    return this._doGet(this.parsePath(path), !ignoreParent && this.parentModel);
  }
  getShallow(key, ignoreParent) {
    const option = this.option;
    let val = option == null ? option : option[key];
    if (val == null && !ignoreParent) {
      const parentModel = this.parentModel;
      if (parentModel) {
        val = parentModel.getShallow(key);
      }
    }
    return val;
  }
  getModel(path, parentModel) {
    const hasPath = path != null;
    const pathFinal = hasPath ? this.parsePath(path) : null;
    const obj = hasPath ? this._doGet(pathFinal) : this.option;
    parentModel = parentModel || this.parentModel && this.parentModel.getModel(this.resolveParentPath(pathFinal));
    return new Model(obj, parentModel, this.ecModel);
  }
  isEmpty() {
    return this.option == null;
  }
  restoreData() {
  }
  clone() {
    const Ctor = this.constructor;
    return new Ctor(clone(this.option));
  }
  parsePath(path) {
    if (typeof path === "string") {
      return path.split(".");
    }
    return path;
  }
  resolveParentPath(path) {
    return path;
  }
  isAnimationEnabled() {
    if (!env_default.node && this.option) {
      if (this.option.animation != null) {
        return !!this.option.animation;
      } else if (this.parentModel) {
        return this.parentModel.isAnimationEnabled();
      }
    }
  }
  _doGet(pathArr, parentModel) {
    let obj = this.option;
    if (!pathArr) {
      return obj;
    }
    for (let i = 0; i < pathArr.length; i++) {
      if (!pathArr[i]) {
        continue;
      }
      obj = obj && typeof obj === "object" ? obj[pathArr[i]] : null;
      if (obj == null) {
        break;
      }
    }
    if (obj == null && parentModel) {
      obj = parentModel._doGet(this.resolveParentPath(pathArr), parentModel.parentModel);
    }
    return obj;
  }
};
enableClassExtend(Model);
enableClassCheck(Model);
mixin(Model, LineStyleMixin);
mixin(Model, ItemStyleMixin);
mixin(Model, AreaStyleMixin);
mixin(Model, textStyle_default);
var Model_default = Model;

// src/util/component.ts
var base = Math.round(Math.random() * 10);
function getUID(type) {
  return [type || "", base++].join("_");
}
function enableSubTypeDefaulter(target) {
  const subTypeDefaulters = {};
  target.registerSubTypeDefaulter = function(componentType, defaulter) {
    const componentTypeInfo = parseClassType(componentType);
    subTypeDefaulters[componentTypeInfo.main] = defaulter;
  };
  target.determineSubType = function(componentType, option) {
    let type = option.type;
    if (!type) {
      const componentTypeMain = parseClassType(componentType).main;
      if (target.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
        type = subTypeDefaulters[componentTypeMain](option);
      }
    }
    return type;
  };
}
function enableTopologicalTravel(entity, dependencyGetter) {
  entity.topologicalTravel = function(targetNameList, fullNameList, callback, context) {
    if (!targetNameList.length) {
      return;
    }
    const result = makeDepndencyGraph(fullNameList);
    const graph = result.graph;
    const noEntryList = result.noEntryList;
    const targetNameSet = {};
    each(targetNameList, function(name) {
      targetNameSet[name] = true;
    });
    while (noEntryList.length) {
      const currComponentType = noEntryList.pop();
      const currVertex = graph[currComponentType];
      const isInTargetNameSet = !!targetNameSet[currComponentType];
      if (isInTargetNameSet) {
        callback.call(context, currComponentType, currVertex.originalDeps.slice());
        delete targetNameSet[currComponentType];
      }
      each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
    }
    each(targetNameSet, function() {
      let errMsg = "";
      if (true) {
        errMsg = makePrintable("Circular dependency may exists: ", targetNameSet, targetNameList, fullNameList);
      }
      throw new Error(errMsg);
    });
    function removeEdge(succComponentType) {
      graph[succComponentType].entryCount--;
      if (graph[succComponentType].entryCount === 0) {
        noEntryList.push(succComponentType);
      }
    }
    function removeEdgeAndAdd(succComponentType) {
      targetNameSet[succComponentType] = true;
      removeEdge(succComponentType);
    }
  };
  function makeDepndencyGraph(fullNameList) {
    const graph = {};
    const noEntryList = [];
    each(fullNameList, function(name) {
      const thisItem = createDependencyGraphItem(graph, name);
      const originalDeps = thisItem.originalDeps = dependencyGetter(name);
      const availableDeps = getAvailableDependencies(originalDeps, fullNameList);
      thisItem.entryCount = availableDeps.length;
      if (thisItem.entryCount === 0) {
        noEntryList.push(name);
      }
      each(availableDeps, function(dependentName) {
        if (indexOf(thisItem.predecessor, dependentName) < 0) {
          thisItem.predecessor.push(dependentName);
        }
        const thatItem = createDependencyGraphItem(graph, dependentName);
        if (indexOf(thatItem.successor, dependentName) < 0) {
          thatItem.successor.push(name);
        }
      });
    });
    return {graph, noEntryList};
  }
  function createDependencyGraphItem(graph, name) {
    if (!graph[name]) {
      graph[name] = {predecessor: [], successor: []};
    }
    return graph[name];
  }
  function getAvailableDependencies(originalDeps, fullNameList) {
    const availableDeps = [];
    each(originalDeps, function(dep) {
      indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
    });
    return availableDeps;
  }
}
function inheritDefaultOption(superOption, subOption) {
  return merge(merge({}, superOption, true), subOption, true);
}

// src/i18n/langEN.ts
var langEN_default = {
  time: {
    month: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ],
    monthAbbr: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    dayOfWeek: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ],
    dayOfWeekAbbr: [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst",
      custom: "Custom chart",
      chart: "Chart"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
};

// src/i18n/langZH.ts
var langZH_default = {
  time: {
    month: [
      "\u4E00\u6708",
      "\u4E8C\u6708",
      "\u4E09\u6708",
      "\u56DB\u6708",
      "\u4E94\u6708",
      "\u516D\u6708",
      "\u4E03\u6708",
      "\u516B\u6708",
      "\u4E5D\u6708",
      "\u5341\u6708",
      "\u5341\u4E00\u6708",
      "\u5341\u4E8C\u6708"
    ],
    monthAbbr: [
      "1\u6708",
      "2\u6708",
      "3\u6708",
      "4\u6708",
      "5\u6708",
      "6\u6708",
      "7\u6708",
      "8\u6708",
      "9\u6708",
      "10\u6708",
      "11\u6708",
      "12\u6708"
    ],
    dayOfWeek: [
      "\u661F\u671F\u65E5",
      "\u661F\u671F\u4E00",
      "\u661F\u671F\u4E8C",
      "\u661F\u671F\u4E09",
      "\u661F\u671F\u56DB",
      "\u661F\u671F\u4E94",
      "\u661F\u671F\u516D"
    ],
    dayOfWeekAbbr: [
      "\u65E5",
      "\u4E00",
      "\u4E8C",
      "\u4E09",
      "\u56DB",
      "\u4E94",
      "\u516D"
    ]
  },
  legend: {
    selector: {
      all: "\u5168\u9009",
      inverse: "\u53CD\u9009"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "\u77E9\u5F62\u9009\u62E9",
        polygon: "\u5708\u9009",
        lineX: "\u6A2A\u5411\u9009\u62E9",
        lineY: "\u7EB5\u5411\u9009\u62E9",
        keep: "\u4FDD\u6301\u9009\u62E9",
        clear: "\u6E05\u9664\u9009\u62E9"
      }
    },
    dataView: {
      title: "\u6570\u636E\u89C6\u56FE",
      lang: ["\u6570\u636E\u89C6\u56FE", "\u5173\u95ED", "\u5237\u65B0"]
    },
    dataZoom: {
      title: {
        zoom: "\u533A\u57DF\u7F29\u653E",
        back: "\u533A\u57DF\u7F29\u653E\u8FD8\u539F"
      }
    },
    magicType: {
      title: {
        line: "\u5207\u6362\u4E3A\u6298\u7EBF\u56FE",
        bar: "\u5207\u6362\u4E3A\u67F1\u72B6\u56FE",
        stack: "\u5207\u6362\u4E3A\u5806\u53E0",
        tiled: "\u5207\u6362\u4E3A\u5E73\u94FA"
      }
    },
    restore: {
      title: "\u8FD8\u539F"
    },
    saveAsImage: {
      title: "\u4FDD\u5B58\u4E3A\u56FE\u7247",
      lang: ["\u53F3\u952E\u53E6\u5B58\u4E3A\u56FE\u7247"]
    }
  },
  series: {
    typeNames: {
      pie: "\u997C\u56FE",
      bar: "\u67F1\u72B6\u56FE",
      line: "\u6298\u7EBF\u56FE",
      scatter: "\u6563\u70B9\u56FE",
      effectScatter: "\u6D9F\u6F2A\u6563\u70B9\u56FE",
      radar: "\u96F7\u8FBE\u56FE",
      tree: "\u6811\u56FE",
      treemap: "\u77E9\u5F62\u6811\u56FE",
      boxplot: "\u7BB1\u578B\u56FE",
      candlestick: "K\u7EBF\u56FE",
      k: "K\u7EBF\u56FE",
      heatmap: "\u70ED\u529B\u56FE",
      map: "\u5730\u56FE",
      parallel: "\u5E73\u884C\u5750\u6807\u56FE",
      lines: "\u7EBF\u56FE",
      graph: "\u5173\u7CFB\u56FE",
      sankey: "\u6851\u57FA\u56FE",
      funnel: "\u6F0F\u6597\u56FE",
      gauge: "\u4EEA\u8868\u76D8\u56FE",
      pictorialBar: "\u8C61\u5F62\u67F1\u56FE",
      themeRiver: "\u4E3B\u9898\u6CB3\u6D41\u56FE",
      sunburst: "\u65ED\u65E5\u56FE",
      custom: "\u81EA\u5B9A\u4E49\u56FE\u8868",
      chart: "\u56FE\u8868"
    }
  },
  aria: {
    general: {
      withTitle: "\u8FD9\u662F\u4E00\u4E2A\u5173\u4E8E\u201C{title}\u201D\u7684\u56FE\u8868\u3002",
      withoutTitle: "\u8FD9\u662F\u4E00\u4E2A\u56FE\u8868\uFF0C"
    },
    series: {
      single: {
        prefix: "",
        withName: "\u56FE\u8868\u7C7B\u578B\u662F{seriesType}\uFF0C\u8868\u793A{seriesName}\u3002",
        withoutName: "\u56FE\u8868\u7C7B\u578B\u662F{seriesType}\u3002"
      },
      multiple: {
        prefix: "\u5B83\u7531{seriesCount}\u4E2A\u56FE\u8868\u7CFB\u5217\u7EC4\u6210\u3002",
        withName: "\u7B2C{seriesId}\u4E2A\u7CFB\u5217\u662F\u4E00\u4E2A\u8868\u793A{seriesName}\u7684{seriesType}\uFF0C",
        withoutName: "\u7B2C{seriesId}\u4E2A\u7CFB\u5217\u662F\u4E00\u4E2A{seriesType}\uFF0C",
        separator: {
          middle: "\uFF1B",
          end: "\u3002"
        }
      }
    },
    data: {
      allData: "\u5176\u6570\u636E\u662F\u2014\u2014",
      partialData: "\u5176\u4E2D\uFF0C\u524D{displayCnt}\u9879\u662F\u2014\u2014",
      withName: "{name}\u7684\u6570\u636E\u662F{value}",
      withoutName: "{value}",
      separator: {
        middle: "\uFF0C",
        end: ""
      }
    }
  }
};

// src/core/locale.ts
var LOCALE_ZH = "ZH";
var LOCALE_EN = "EN";
var DEFAULT_LOCALE = LOCALE_EN;
var localeStorage = {};
var localeModels = {};
var SYSTEM_LANG = !env_default.domSupported ? DEFAULT_LOCALE : function() {
  const langStr = (document.documentElement.lang || navigator.language || navigator.browserLanguage || DEFAULT_LOCALE).toUpperCase();
  return langStr.indexOf(LOCALE_ZH) > -1 ? LOCALE_ZH : DEFAULT_LOCALE;
}();
function registerLocale(locale, localeObj) {
  locale = locale.toUpperCase();
  localeModels[locale] = new Model_default(localeObj);
  localeStorage[locale] = localeObj;
}
function createLocaleObject(locale) {
  if (isString(locale)) {
    const localeObj = localeStorage[locale.toUpperCase()] || {};
    if (locale === LOCALE_ZH || locale === LOCALE_EN) {
      return clone(localeObj);
    } else {
      return merge(clone(localeObj), clone(localeStorage[DEFAULT_LOCALE]), false);
    }
  } else {
    return merge(clone(locale), clone(localeStorage[DEFAULT_LOCALE]), false);
  }
}
function getLocaleModel(lang) {
  return localeModels[lang];
}
function getDefaultLocaleModel() {
  return localeModels[DEFAULT_LOCALE];
}
registerLocale(LOCALE_EN, langEN_default);
registerLocale(LOCALE_ZH, langZH_default);

// src/scale/break.ts
var _impl = null;
function registerScaleBreakHelperImpl(impl) {
  if (!_impl) {
    _impl = impl;
  }
}
function getScaleBreakHelper() {
  return _impl;
}

// src/util/time.ts
var ONE_SECOND = 1e3;
var ONE_MINUTE = ONE_SECOND * 60;
var ONE_HOUR = ONE_MINUTE * 60;
var ONE_DAY = ONE_HOUR * 24;
var ONE_YEAR = ONE_DAY * 365;
var primaryTimeUnitFormatterMatchers = {
  year: /({yyyy}|{yy})/,
  month: /({MMMM}|{MMM}|{MM}|{M})/,
  day: /({dd}|{d})/,
  hour: /({HH}|{H}|{hh}|{h})/,
  minute: /({mm}|{m})/,
  second: /({ss}|{s})/,
  millisecond: /({SSS}|{S})/
};
var defaultFormatterSeed = {
  year: "{yyyy}",
  month: "{MMM}",
  day: "{d}",
  hour: "{HH}:{mm}",
  minute: "{HH}:{mm}",
  second: "{HH}:{mm}:{ss}",
  millisecond: "{HH}:{mm}:{ss} {SSS}"
};
var defaultFullFormatter = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}";
var fullDayFormatter = "{yyyy}-{MM}-{dd}";
var fullLeveledFormatter = {
  year: "{yyyy}",
  month: "{yyyy}-{MM}",
  day: fullDayFormatter,
  hour: fullDayFormatter + " " + defaultFormatterSeed.hour,
  minute: fullDayFormatter + " " + defaultFormatterSeed.minute,
  second: fullDayFormatter + " " + defaultFormatterSeed.second,
  millisecond: defaultFullFormatter
};
var primaryTimeUnits = [
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
var timeUnits = [
  "year",
  "half-year",
  "quarter",
  "month",
  "week",
  "half-week",
  "day",
  "half-day",
  "quarter-day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function parseTimeAxisLabelFormatter(formatter) {
  return !isString(formatter) && !isFunction(formatter) ? parseTimeAxisLabelFormatterDictionary(formatter) : formatter;
}
function parseTimeAxisLabelFormatterDictionary(dictOption) {
  dictOption = dictOption || {};
  const dict = {};
  let canAddHighlight = true;
  each(primaryTimeUnits, (lowestUnit) => {
    canAddHighlight &&= dictOption[lowestUnit] == null;
  });
  each(primaryTimeUnits, (lowestUnit, lowestUnitIdx) => {
    const upperDictOption = dictOption[lowestUnit];
    dict[lowestUnit] = {};
    let lowerTpl = null;
    for (let upperUnitIdx = lowestUnitIdx; upperUnitIdx >= 0; upperUnitIdx--) {
      const upperUnit = primaryTimeUnits[upperUnitIdx];
      const upperDictItemOption = isObject(upperDictOption) && !isArray(upperDictOption) ? upperDictOption[upperUnit] : upperDictOption;
      let tplArr;
      if (isArray(upperDictItemOption)) {
        tplArr = upperDictItemOption.slice();
        lowerTpl = tplArr[0] || "";
      } else if (isString(upperDictItemOption)) {
        lowerTpl = upperDictItemOption;
        tplArr = [lowerTpl];
      } else {
        if (lowerTpl == null) {
          lowerTpl = defaultFormatterSeed[lowestUnit];
        } else if (!primaryTimeUnitFormatterMatchers[upperUnit].test(lowerTpl)) {
          lowerTpl = `${dict[upperUnit][upperUnit][0]} ${lowerTpl}`;
        }
        tplArr = [lowerTpl];
        if (canAddHighlight) {
          tplArr[1] = `{primary|${lowerTpl}}`;
        }
      }
      dict[lowestUnit][upperUnit] = tplArr;
    }
  });
  return dict;
}
function pad(str, len2) {
  str += "";
  return "0000".substr(0, len2 - str.length) + str;
}
function getPrimaryTimeUnit(timeUnit) {
  switch (timeUnit) {
    case "half-year":
    case "quarter":
      return "month";
    case "week":
    case "half-week":
      return "day";
    case "half-day":
    case "quarter-day":
      return "hour";
    default:
      return timeUnit;
  }
}
function isPrimaryTimeUnit(timeUnit) {
  return timeUnit === getPrimaryTimeUnit(timeUnit);
}
function getDefaultFormatPrecisionOfInterval(timeUnit) {
  switch (timeUnit) {
    case "year":
    case "month":
      return "day";
    case "millisecond":
      return "millisecond";
    default:
      return "second";
  }
}
function format(time, template, isUTC, lang) {
  const date = parseDate(time);
  const y = date[fullYearGetterName(isUTC)]();
  const M = date[monthGetterName(isUTC)]() + 1;
  const q = Math.floor((M - 1) / 3) + 1;
  const d = date[dateGetterName(isUTC)]();
  const e2 = date["get" + (isUTC ? "UTC" : "") + "Day"]();
  const H = date[hoursGetterName(isUTC)]();
  const h = (H - 1) % 12 + 1;
  const m2 = date[minutesGetterName(isUTC)]();
  const s = date[secondsGetterName(isUTC)]();
  const S = date[millisecondsGetterName(isUTC)]();
  const a = H >= 12 ? "pm" : "am";
  const A = a.toUpperCase();
  const localeModel = lang instanceof Model_default ? lang : getLocaleModel(lang || SYSTEM_LANG) || getDefaultLocaleModel();
  const timeModel = localeModel.getModel("time");
  const month = timeModel.get("month");
  const monthAbbr = timeModel.get("monthAbbr");
  const dayOfWeek = timeModel.get("dayOfWeek");
  const dayOfWeekAbbr = timeModel.get("dayOfWeekAbbr");
  return (template || "").replace(/{a}/g, a + "").replace(/{A}/g, A + "").replace(/{yyyy}/g, y + "").replace(/{yy}/g, pad(y % 100 + "", 2)).replace(/{Q}/g, q + "").replace(/{MMMM}/g, month[M - 1]).replace(/{MMM}/g, monthAbbr[M - 1]).replace(/{MM}/g, pad(M, 2)).replace(/{M}/g, M + "").replace(/{dd}/g, pad(d, 2)).replace(/{d}/g, d + "").replace(/{eeee}/g, dayOfWeek[e2]).replace(/{ee}/g, dayOfWeekAbbr[e2]).replace(/{e}/g, e2 + "").replace(/{HH}/g, pad(H, 2)).replace(/{H}/g, H + "").replace(/{hh}/g, pad(h + "", 2)).replace(/{h}/g, h + "").replace(/{mm}/g, pad(m2, 2)).replace(/{m}/g, m2 + "").replace(/{ss}/g, pad(s, 2)).replace(/{s}/g, s + "").replace(/{SSS}/g, pad(S, 3)).replace(/{S}/g, S + "");
}
function leveledFormat(tick, idx, formatter, lang, isUTC) {
  let template = null;
  if (isString(formatter)) {
    template = formatter;
  } else if (isFunction(formatter)) {
    const extra = {
      time: tick.time,
      level: tick.time.level
    };
    const scaleBreakHelper = getScaleBreakHelper();
    if (scaleBreakHelper) {
      scaleBreakHelper.makeAxisLabelFormatterParamBreak(extra, tick.break);
    }
    template = formatter(tick.value, idx, extra);
  } else {
    const tickTime = tick.time;
    if (tickTime) {
      const leveledTplArr = formatter[tickTime.lowerTimeUnit][tickTime.upperTimeUnit];
      template = leveledTplArr[Math.min(tickTime.level, leveledTplArr.length - 1)] || "";
    } else {
      const unit = getUnitFromValue(tick.value, isUTC);
      template = formatter[unit][unit][0];
    }
  }
  return format(new Date(tick.value), template, isUTC, lang);
}
function getUnitFromValue(value, isUTC) {
  const date = parseDate(value);
  const M = date[monthGetterName(isUTC)]() + 1;
  const d = date[dateGetterName(isUTC)]();
  const h = date[hoursGetterName(isUTC)]();
  const m2 = date[minutesGetterName(isUTC)]();
  const s = date[secondsGetterName(isUTC)]();
  const S = date[millisecondsGetterName(isUTC)]();
  const isSecond = S === 0;
  const isMinute = isSecond && s === 0;
  const isHour = isMinute && m2 === 0;
  const isDay = isHour && h === 0;
  const isMonth = isDay && d === 1;
  const isYear = isMonth && M === 1;
  if (isYear) {
    return "year";
  } else if (isMonth) {
    return "month";
  } else if (isDay) {
    return "day";
  } else if (isHour) {
    return "hour";
  } else if (isMinute) {
    return "minute";
  } else if (isSecond) {
    return "second";
  } else {
    return "millisecond";
  }
}
function roundTime(date, timeUnit, isUTC) {
  switch (timeUnit) {
    case "year":
      date[monthSetterName(isUTC)](0);
    case "month":
      date[dateSetterName(isUTC)](1);
    case "day":
      date[hoursSetterName(isUTC)](0);
    case "hour":
      date[minutesSetterName(isUTC)](0);
    case "minute":
      date[secondsSetterName(isUTC)](0);
    case "second":
      date[millisecondsSetterName(isUTC)](0);
  }
  return date;
}
function fullYearGetterName(isUTC) {
  return isUTC ? "getUTCFullYear" : "getFullYear";
}
function monthGetterName(isUTC) {
  return isUTC ? "getUTCMonth" : "getMonth";
}
function dateGetterName(isUTC) {
  return isUTC ? "getUTCDate" : "getDate";
}
function hoursGetterName(isUTC) {
  return isUTC ? "getUTCHours" : "getHours";
}
function minutesGetterName(isUTC) {
  return isUTC ? "getUTCMinutes" : "getMinutes";
}
function secondsGetterName(isUTC) {
  return isUTC ? "getUTCSeconds" : "getSeconds";
}
function millisecondsGetterName(isUTC) {
  return isUTC ? "getUTCMilliseconds" : "getMilliseconds";
}
function fullYearSetterName(isUTC) {
  return isUTC ? "setUTCFullYear" : "setFullYear";
}
function monthSetterName(isUTC) {
  return isUTC ? "setUTCMonth" : "setMonth";
}
function dateSetterName(isUTC) {
  return isUTC ? "setUTCDate" : "setDate";
}
function hoursSetterName(isUTC) {
  return isUTC ? "setUTCHours" : "setHours";
}
function minutesSetterName(isUTC) {
  return isUTC ? "setUTCMinutes" : "setMinutes";
}
function secondsSetterName(isUTC) {
  return isUTC ? "setUTCSeconds" : "setSeconds";
}
function millisecondsSetterName(isUTC) {
  return isUTC ? "setUTCMilliseconds" : "setMilliseconds";
}

// src/legacy/getTextRect.ts
function getTextRect(text, font, align, verticalAlign, padding, rich, truncate, lineHeight) {
  const textEl = new Text_default({
    style: {
      text,
      font,
      align,
      verticalAlign,
      padding,
      rich,
      overflow: truncate ? "truncate" : null,
      lineHeight
    }
  });
  return textEl.getBoundingRect();
}

// src/util/format.ts
function addCommas(x) {
  if (!isNumeric(x)) {
    return isString(x) ? x : "-";
  }
  const parts = (x + "").split(".");
  return parts[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (parts.length > 1 ? "." + parts[1] : "");
}
function toCamelCase(str, upperCaseFirst) {
  str = (str || "").toLowerCase().replace(/-(.)/g, function(match, group1) {
    return group1.toUpperCase();
  });
  if (upperCaseFirst && str) {
    str = str.charAt(0).toUpperCase() + str.slice(1);
  }
  return str;
}
var normalizeCssArray2 = normalizeCssArray;
function makeValueReadable(value, valueType, useUTC) {
  const USER_READABLE_DEFUALT_TIME_PATTERN = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
  function stringToUserReadable(str) {
    return str && trim(str) ? str : "-";
  }
  function isNumberUserReadable(num) {
    return !!(num != null && !isNaN(num) && isFinite(num));
  }
  const isTypeTime = valueType === "time";
  const isValueDate = value instanceof Date;
  if (isTypeTime || isValueDate) {
    const date = isTypeTime ? parseDate(value) : value;
    if (!isNaN(+date)) {
      return format(date, USER_READABLE_DEFUALT_TIME_PATTERN, useUTC);
    } else if (isValueDate) {
      return "-";
    }
  }
  if (valueType === "ordinal") {
    return isStringSafe(value) ? stringToUserReadable(value) : isNumber(value) ? isNumberUserReadable(value) ? value + "" : "-" : "-";
  }
  const numericResult = numericToNumber(value);
  return isNumberUserReadable(numericResult) ? addCommas(numericResult) : isStringSafe(value) ? stringToUserReadable(value) : typeof value === "boolean" ? value + "" : "-";
}
var TPL_VAR_ALIAS = ["a", "b", "c", "d", "e", "f", "g"];
var wrapVar = function(varName, seriesIdx) {
  return "{" + varName + (seriesIdx == null ? "" : seriesIdx) + "}";
};
function formatTpl(tpl, paramsList, encode) {
  if (!isArray(paramsList)) {
    paramsList = [paramsList];
  }
  const seriesLen = paramsList.length;
  if (!seriesLen) {
    return "";
  }
  const $vars = paramsList[0].$vars || [];
  for (let i = 0; i < $vars.length; i++) {
    const alias = TPL_VAR_ALIAS[i];
    tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));
  }
  for (let seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
    for (let k = 0; k < $vars.length; k++) {
      const val = paramsList[seriesIdx][$vars[k]];
      tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val);
    }
  }
  return tpl;
}
function formatTplSimple(tpl, param, encode) {
  each(param, function(value, key) {
    tpl = tpl.replace("{" + key + "}", encode ? encodeHTML(value) : value);
  });
  return tpl;
}
function getTooltipMarker(inOpt, extraCssText) {
  const opt = isString(inOpt) ? {
    color: inOpt,
    extraCssText
  } : inOpt || {};
  const color4 = opt.color;
  const type = opt.type;
  extraCssText = opt.extraCssText;
  const renderMode = opt.renderMode || "html";
  if (!color4) {
    return "";
  }
  if (renderMode === "html") {
    return type === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + encodeHTML(color4) + ";" + (extraCssText || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + encodeHTML(color4) + ";" + (extraCssText || "") + '"></span>';
  } else {
    const markerId = opt.markerId || "markerX";
    return {
      renderMode,
      content: "{" + markerId + "|}  ",
      style: type === "subItem" ? {
        width: 4,
        height: 4,
        borderRadius: 2,
        backgroundColor: color4
      } : {
        width: 10,
        height: 10,
        borderRadius: 5,
        backgroundColor: color4
      }
    };
  }
}
function formatTime(tpl, value, isUTC) {
  if (true) {
    deprecateReplaceLog("echarts.format.formatTime", "echarts.time.format");
  }
  if (tpl === "week" || tpl === "month" || tpl === "quarter" || tpl === "half-year" || tpl === "year") {
    tpl = "MM-dd\nyyyy";
  }
  const date = parseDate(value);
  const getUTC = isUTC ? "getUTC" : "get";
  const y = date[getUTC + "FullYear"]();
  const M = date[getUTC + "Month"]() + 1;
  const d = date[getUTC + "Date"]();
  const h = date[getUTC + "Hours"]();
  const m2 = date[getUTC + "Minutes"]();
  const s = date[getUTC + "Seconds"]();
  const S = date[getUTC + "Milliseconds"]();
  tpl = tpl.replace("MM", pad(M, 2)).replace("M", M).replace("yyyy", y).replace("yy", pad(y % 100 + "", 2)).replace("dd", pad(d, 2)).replace("d", d).replace("hh", pad(h, 2)).replace("h", h).replace("mm", pad(m2, 2)).replace("m", m2).replace("ss", pad(s, 2)).replace("s", s).replace("SSS", pad(S, 3));
  return tpl;
}
function capitalFirst(str) {
  return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
}
function convertToColorString(color4, defaultColor) {
  defaultColor = defaultColor || "transparent";
  return isString(color4) ? color4 : isObject(color4) ? color4.colorStops && (color4.colorStops[0] || {}).color || defaultColor : defaultColor;
}
function windowOpen(link, target) {
  if (target === "_blank" || target === "blank") {
    const blank = window.open();
    blank.opener = null;
    blank.location.href = link;
  } else {
    window.open(link, target);
  }
}

// src/core/CoordinateSystem.ts
var nonSeriesBoxCoordSysCreators = {};
var normalCoordSysCreators = {};
var CoordinateSystemManager = class {
  constructor() {
    this._normalMasterList = [];
    this._nonSeriesBoxMasterList = [];
  }
  create(ecModel, api2) {
    this._nonSeriesBoxMasterList = dealCreate(nonSeriesBoxCoordSysCreators, true);
    this._normalMasterList = dealCreate(normalCoordSysCreators, false);
    function dealCreate(creatorMap, canBeNonSeriesBox) {
      let coordinateSystems = [];
      each(creatorMap, function(creator, type) {
        const list = creator.create(ecModel, api2);
        coordinateSystems = coordinateSystems.concat(list || []);
        if (true) {
          if (canBeNonSeriesBox) {
            each(list, (master) => assert(!master.update));
          }
        }
      });
      return coordinateSystems;
    }
  }
  update(ecModel, api2) {
    each(this._normalMasterList, function(coordSys) {
      coordSys.update && coordSys.update(ecModel, api2);
    });
  }
  getCoordinateSystems() {
    return this._normalMasterList.concat(this._nonSeriesBoxMasterList);
  }
};
CoordinateSystemManager.register = function(type, creator) {
  if (type === "matrix" || type === "calendar") {
    nonSeriesBoxCoordSysCreators[type] = creator;
    return;
  }
  normalCoordSysCreators[type] = creator;
};
CoordinateSystemManager.get = function(type) {
  return normalCoordSysCreators[type] || nonSeriesBoxCoordSysCreators[type];
};
function canBeNonSeriesBoxCoordSys(coordSysType) {
  return !!nonSeriesBoxCoordSysCreators[coordSysType];
}
var BoxCoordinateSystemCoordFrom = {
  coord: 1,
  coord2: 2
};
function registerLayOutOnCoordSysUsage(opt) {
  if (true) {
    assert(!coordSysUseMap.get(opt.fullType));
  }
  coordSysUseMap.set(opt.fullType, {getCoord2: void 0}).getCoord2 = opt.getCoord2;
}
var coordSysUseMap = createHashMap();
function getCoordForBoxCoordSys(model) {
  let coord = model.getShallow("coord", true);
  let from = BoxCoordinateSystemCoordFrom.coord;
  if (coord == null) {
    const store = coordSysUseMap.get(model.type);
    if (store && store.getCoord2) {
      from = BoxCoordinateSystemCoordFrom.coord2;
      coord = store.getCoord2(model);
    }
  }
  return {coord, from};
}
var CoordinateSystemUsageKind = {
  none: 0,
  dataCoordSys: 1,
  boxCoordSys: 2
};
function decideCoordSysUsageKind(model, printError) {
  const coordSysType = model.getShallow("coordinateSystem");
  let coordSysUsageOption = model.getShallow("coordinateSystemUsage", true);
  const isDeclaredExplicitly = coordSysUsageOption != null;
  let kind = CoordinateSystemUsageKind.none;
  if (coordSysType) {
    const isSeries2 = model.mainType === "series";
    if (coordSysUsageOption == null) {
      coordSysUsageOption = isSeries2 ? "data" : "box";
    }
    if (coordSysUsageOption === "data") {
      kind = CoordinateSystemUsageKind.dataCoordSys;
      if (!isSeries2) {
        if (true) {
          if (isDeclaredExplicitly && printError) {
            error('coordinateSystemUsage "data" is not supported in non-series components.');
          }
        }
        kind = CoordinateSystemUsageKind.none;
      }
    } else if (coordSysUsageOption === "box") {
      kind = CoordinateSystemUsageKind.boxCoordSys;
      if (!isSeries2 && !canBeNonSeriesBoxCoordSys(coordSysType)) {
        if (true) {
          if (isDeclaredExplicitly && printError) {
            error(`coordinateSystem "${coordSysType}" cannot be used as coordinateSystemUsage "box" for "${model.type}" yet.`);
          }
        }
        kind = CoordinateSystemUsageKind.none;
      }
    }
  }
  return {coordSysType, kind};
}
function injectCoordSysByOption(opt) {
  const {
    targetModel,
    coordSysType,
    coordSysProvider,
    isDefaultDataCoordSys,
    allowNotFound
  } = opt;
  if (true) {
    assert(!!coordSysType);
  }
  let {kind, coordSysType: declaredType} = decideCoordSysUsageKind(targetModel, true);
  if (isDefaultDataCoordSys && kind !== CoordinateSystemUsageKind.dataCoordSys) {
    kind = CoordinateSystemUsageKind.dataCoordSys;
    declaredType = coordSysType;
  }
  if (kind === CoordinateSystemUsageKind.none || declaredType !== coordSysType) {
    return false;
  }
  const coordSys = coordSysProvider(coordSysType, targetModel);
  if (!coordSys) {
    if (true) {
      if (!allowNotFound) {
        error(`${coordSysType} cannot be found for ${targetModel.type} (index: ${targetModel.componentIndex}).`);
      }
    }
    return false;
  }
  if (kind === CoordinateSystemUsageKind.dataCoordSys) {
    if (true) {
      assert(targetModel.mainType === "series");
    }
    targetModel.coordinateSystem = coordSys;
  } else {
    targetModel.boxCoordinateSystem = coordSys;
  }
  return true;
}
var simpleCoordSysInjectionProvider = function(coordSysType, injectTargetModel) {
  const coordSysModel = injectTargetModel.getReferringComponents(coordSysType, SINGLE_REFERRING).models[0];
  return coordSysModel && coordSysModel.coordinateSystem;
};
var CoordinateSystem_default = CoordinateSystemManager;

// src/util/layout.ts
var each2 = each;
var LOCATION_PARAMS = [
  "left",
  "right",
  "top",
  "bottom",
  "width",
  "height"
];
var HV_NAMES = [
  ["width", "left", "right"],
  ["height", "top", "bottom"]
];
function boxLayout(orient, group, gap, maxWidth, maxHeight) {
  let x = 0;
  let y = 0;
  if (maxWidth == null) {
    maxWidth = Infinity;
  }
  if (maxHeight == null) {
    maxHeight = Infinity;
  }
  let currentLineMaxSize = 0;
  group.eachChild(function(child, idx) {
    const rect = child.getBoundingRect();
    const nextChild = group.childAt(idx + 1);
    const nextChildRect = nextChild && nextChild.getBoundingRect();
    let nextX;
    let nextY;
    if (orient === "horizontal") {
      const moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
      nextX = x + moveX;
      if (nextX > maxWidth || child.newline) {
        x = 0;
        nextX = moveX;
        y += currentLineMaxSize + gap;
        currentLineMaxSize = rect.height;
      } else {
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
      }
    } else {
      const moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
      nextY = y + moveY;
      if (nextY > maxHeight || child.newline) {
        x += currentLineMaxSize + gap;
        y = 0;
        nextY = moveY;
        currentLineMaxSize = rect.width;
      } else {
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
      }
    }
    if (child.newline) {
      return;
    }
    child.x = x;
    child.y = y;
    child.markRedraw();
    orient === "horizontal" ? x = nextX + gap : y = nextY + gap;
  });
}
var box = boxLayout;
var vbox = curry(boxLayout, "vertical");
var hbox = curry(boxLayout, "horizontal");
function getBoxLayoutParams(boxLayoutModel, ignoreParent) {
  return {
    left: boxLayoutModel.getShallow("left", ignoreParent),
    top: boxLayoutModel.getShallow("top", ignoreParent),
    right: boxLayoutModel.getShallow("right", ignoreParent),
    bottom: boxLayoutModel.getShallow("bottom", ignoreParent),
    width: boxLayoutModel.getShallow("width", ignoreParent),
    height: boxLayoutModel.getShallow("height", ignoreParent)
  };
}
function getViewRectAndCenterForCircleLayout(seriesModel, api2) {
  const layoutRef = createBoxLayoutReference(seriesModel, api2, {
    enableLayoutOnlyByCenter: true
  });
  const boxLayoutParams = seriesModel.getBoxLayoutParams();
  let viewRect2;
  let center3;
  if (layoutRef.type === BoxLayoutReferenceType.point) {
    center3 = layoutRef.refPoint;
    viewRect2 = getLayoutRect(boxLayoutParams, {width: api2.getWidth(), height: api2.getHeight()});
  } else {
    const centerOption = seriesModel.get("center");
    const centerOptionArr = isArray(centerOption) ? centerOption : [centerOption, centerOption];
    viewRect2 = getLayoutRect(boxLayoutParams, layoutRef.refContainer);
    center3 = layoutRef.boxCoordFrom === BoxCoordinateSystemCoordFrom.coord2 ? layoutRef.refPoint : [
      parsePercent2(centerOptionArr[0], viewRect2.width) + viewRect2.x,
      parsePercent2(centerOptionArr[1], viewRect2.height) + viewRect2.y
    ];
  }
  return {viewRect: viewRect2, center: center3};
}
function getCircleLayout(seriesModel, api2) {
  const {viewRect: viewRect2, center: center3} = getViewRectAndCenterForCircleLayout(seriesModel, api2);
  let radius = seriesModel.get("radius");
  if (!isArray(radius)) {
    radius = [0, radius];
  }
  const width = parsePercent2(viewRect2.width, api2.getWidth());
  const height = parsePercent2(viewRect2.height, api2.getHeight());
  const size = Math.min(width, height);
  const r0 = parsePercent2(radius[0], size / 2);
  const r = parsePercent2(radius[1], size / 2);
  return {
    cx: center3[0],
    cy: center3[1],
    r0,
    r,
    viewRect: viewRect2
  };
}
function getLayoutRect(positionInfo, containerRect, margin) {
  margin = normalizeCssArray2(margin || 0);
  const containerWidth = containerRect.width;
  const containerHeight = containerRect.height;
  let left = parsePercent2(positionInfo.left, containerWidth);
  let top = parsePercent2(positionInfo.top, containerHeight);
  const right = parsePercent2(positionInfo.right, containerWidth);
  const bottom = parsePercent2(positionInfo.bottom, containerHeight);
  let width = parsePercent2(positionInfo.width, containerWidth);
  let height = parsePercent2(positionInfo.height, containerHeight);
  const verticalMargin = margin[2] + margin[0];
  const horizontalMargin = margin[1] + margin[3];
  const aspect = positionInfo.aspect;
  if (isNaN(width)) {
    width = containerWidth - right - horizontalMargin - left;
  }
  if (isNaN(height)) {
    height = containerHeight - bottom - verticalMargin - top;
  }
  if (aspect != null) {
    if (isNaN(width) && isNaN(height)) {
      if (aspect > containerWidth / containerHeight) {
        width = containerWidth * 0.8;
      } else {
        height = containerHeight * 0.8;
      }
    }
    if (isNaN(width)) {
      width = aspect * height;
    }
    if (isNaN(height)) {
      height = width / aspect;
    }
  }
  if (isNaN(left)) {
    left = containerWidth - right - width - horizontalMargin;
  }
  if (isNaN(top)) {
    top = containerHeight - bottom - height - verticalMargin;
  }
  switch (positionInfo.left || positionInfo.right) {
    case "center":
      left = containerWidth / 2 - width / 2 - margin[3];
      break;
    case "right":
      left = containerWidth - width - horizontalMargin;
      break;
  }
  switch (positionInfo.top || positionInfo.bottom) {
    case "middle":
    case "center":
      top = containerHeight / 2 - height / 2 - margin[0];
      break;
    case "bottom":
      top = containerHeight - height - verticalMargin;
      break;
  }
  left = left || 0;
  top = top || 0;
  if (isNaN(width)) {
    width = containerWidth - horizontalMargin - left - (right || 0);
  }
  if (isNaN(height)) {
    height = containerHeight - verticalMargin - top - (bottom || 0);
  }
  const rect = new BoundingRect_default((containerRect.x || 0) + left + margin[3], (containerRect.y || 0) + top + margin[0], width, height);
  rect.margin = margin;
  return rect;
}
function applyPreserveAspect(component, layoutRect, aspect) {
  const preserveAspect = component.getShallow("preserveAspect", true);
  if (!preserveAspect) {
    return layoutRect;
  }
  const actualAspect = layoutRect.width / layoutRect.height;
  if (Math.abs(Math.atan(aspect) - Math.atan(actualAspect)) < 1e-9) {
    return layoutRect;
  }
  const preserveAspectAlign = component.getShallow("preserveAspectAlign", true);
  const preserveAspectVerticalAlign = component.getShallow("preserveAspectVerticalAlign", true);
  const layoutOptInner = {width: layoutRect.width, height: layoutRect.height};
  const isCover = preserveAspect === "cover";
  if (actualAspect > aspect && !isCover || actualAspect < aspect && isCover) {
    layoutOptInner.width = layoutRect.height * aspect;
    preserveAspectAlign === "left" ? layoutOptInner.left = 0 : preserveAspectAlign === "right" ? layoutOptInner.right = 0 : layoutOptInner.left = "center";
  } else {
    layoutOptInner.height = layoutRect.width / aspect;
    preserveAspectVerticalAlign === "top" ? layoutOptInner.top = 0 : preserveAspectVerticalAlign === "bottom" ? layoutOptInner.bottom = 0 : layoutOptInner.top = "middle";
  }
  return getLayoutRect(layoutOptInner, layoutRect);
}
var BoxLayoutReferenceType = {
  rect: 1,
  point: 2
};
function createBoxLayoutReference(model, api2, opt) {
  let refContainer;
  let refPoint;
  let layoutRefType;
  const boxCoordSys = model.boxCoordinateSystem;
  let boxCoordFrom;
  if (boxCoordSys) {
    const {coord, from} = getCoordForBoxCoordSys(model);
    if (boxCoordSys.dataToLayout) {
      layoutRefType = BoxLayoutReferenceType.rect;
      boxCoordFrom = from;
      const result = boxCoordSys.dataToLayout(coord);
      refContainer = result.contentRect || result.rect;
    } else if (opt && opt.enableLayoutOnlyByCenter && boxCoordSys.dataToPoint) {
      layoutRefType = BoxLayoutReferenceType.point;
      boxCoordFrom = from;
      refPoint = boxCoordSys.dataToPoint(coord);
    } else {
      if (true) {
        error(`${model.type}[${model.componentIndex}] layout based on ${boxCoordSys.type} is not supported.`);
      }
    }
  }
  if (layoutRefType == null) {
    layoutRefType = BoxLayoutReferenceType.rect;
  }
  if (layoutRefType === BoxLayoutReferenceType.rect) {
    if (!refContainer) {
      refContainer = {x: 0, y: 0, width: api2.getWidth(), height: api2.getHeight()};
    }
    refPoint = [refContainer.x + refContainer.width / 2, refContainer.y + refContainer.height / 2];
  }
  return {type: layoutRefType, refContainer, refPoint, boxCoordFrom};
}
function positionElement(el, positionInfo, containerRect, margin, opt, out2) {
  const h = !opt || !opt.hv || opt.hv[0];
  const v = !opt || !opt.hv || opt.hv[1];
  const boundingMode = opt && opt.boundingMode || "all";
  out2 = out2 || el;
  out2.x = el.x;
  out2.y = el.y;
  if (!h && !v) {
    return false;
  }
  let rect;
  if (boundingMode === "raw") {
    rect = el.type === "group" ? new BoundingRect_default(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();
  } else {
    rect = el.getBoundingRect();
    if (el.needLocalTransform()) {
      const transform2 = el.getLocalTransform();
      rect = rect.clone();
      rect.applyTransform(transform2);
    }
  }
  const layoutRect = getLayoutRect(defaults({width: rect.width, height: rect.height}, positionInfo), containerRect, margin);
  const dx = h ? layoutRect.x - rect.x : 0;
  const dy = v ? layoutRect.y - rect.y : 0;
  if (boundingMode === "raw") {
    out2.x = dx;
    out2.y = dy;
  } else {
    out2.x += dx;
    out2.y += dy;
  }
  if (out2 === el) {
    el.markRedraw();
  }
  return true;
}
function sizeCalculable(option, hvIdx) {
  return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;
}
function fetchLayoutMode(ins) {
  const layoutMode = ins.layoutMode || ins.constructor.layoutMode;
  return isObject(layoutMode) ? layoutMode : layoutMode ? {type: layoutMode} : null;
}
function mergeLayoutParam(targetOption, newOption, opt) {
  let ignoreSize = opt && opt.ignoreSize;
  !isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);
  const hResult = merge2(HV_NAMES[0], 0);
  const vResult = merge2(HV_NAMES[1], 1);
  copy3(HV_NAMES[0], targetOption, hResult);
  copy3(HV_NAMES[1], targetOption, vResult);
  function merge2(names, hvIdx) {
    const newParams = {};
    let newValueCount = 0;
    const merged = {};
    let mergedValueCount = 0;
    const enoughParamNumber = 2;
    each2(names, function(name) {
      merged[name] = targetOption[name];
    });
    each2(names, function(name) {
      hasOwn(newOption, name) && (newParams[name] = merged[name] = newOption[name]);
      hasValue(newParams, name) && newValueCount++;
      hasValue(merged, name) && mergedValueCount++;
    });
    if (ignoreSize[hvIdx]) {
      if (hasValue(newOption, names[1])) {
        merged[names[2]] = null;
      } else if (hasValue(newOption, names[2])) {
        merged[names[1]] = null;
      }
      return merged;
    }
    if (mergedValueCount === enoughParamNumber || !newValueCount) {
      return merged;
    } else if (newValueCount >= enoughParamNumber) {
      return newParams;
    } else {
      for (let i = 0; i < names.length; i++) {
        const name = names[i];
        if (!hasOwn(newParams, name) && hasOwn(targetOption, name)) {
          newParams[name] = targetOption[name];
          break;
        }
      }
      return newParams;
    }
  }
  function hasValue(obj, name) {
    return obj[name] != null && obj[name] !== "auto";
  }
  function copy3(names, target, source) {
    each2(names, function(name) {
      target[name] = source[name];
    });
  }
}
function getLayoutParams(source) {
  return copyLayoutParams({}, source);
}
function copyLayoutParams(target, source) {
  source && target && each2(LOCATION_PARAMS, function(name) {
    hasOwn(source, name) && (target[name] = source[name]);
  });
  return target;
}

// src/model/Component.ts
var inner = makeInner();
var ComponentModel2 = class extends Model_default {
  constructor(option, parentModel, ecModel) {
    super(option, parentModel, ecModel);
    this.uid = getUID("ec_cpt_model");
  }
  init(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
  }
  mergeDefaultAndTheme(option, ecModel) {
    const layoutMode = fetchLayoutMode(this);
    const inputPositionParams = layoutMode ? getLayoutParams(option) : {};
    const themeModel = ecModel.getTheme();
    merge(option, themeModel.get(this.mainType));
    merge(option, this.getDefaultOption());
    if (layoutMode) {
      mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  }
  mergeOption(option, ecModel) {
    merge(this.option, option, true);
    const layoutMode = fetchLayoutMode(this);
    if (layoutMode) {
      mergeLayoutParam(this.option, option, layoutMode);
    }
  }
  optionUpdated(newCptOption, isInit) {
  }
  getDefaultOption() {
    const ctor = this.constructor;
    if (!isExtendedClass(ctor)) {
      return ctor.defaultOption;
    }
    const fields = inner(this);
    if (!fields.defaultOption) {
      const optList = [];
      let clz = ctor;
      while (clz) {
        const opt = clz.prototype.defaultOption;
        opt && optList.push(opt);
        clz = clz.superClass;
      }
      let defaultOption3 = {};
      for (let i = optList.length - 1; i >= 0; i--) {
        defaultOption3 = merge(defaultOption3, optList[i], true);
      }
      fields.defaultOption = defaultOption3;
    }
    return fields.defaultOption;
  }
  getReferringComponents(mainType, opt) {
    const indexKey = mainType + "Index";
    const idKey = mainType + "Id";
    return queryReferringComponents(this.ecModel, mainType, {
      index: this.get(indexKey, true),
      id: this.get(idKey, true)
    }, opt);
  }
  getBoxLayoutParams() {
    return getBoxLayoutParams(this, false);
  }
  getZLevelKey() {
    return "";
  }
  setZLevel(zlevel) {
    this.option.zlevel = zlevel;
  }
};
var ComponentModel = ComponentModel2;
ComponentModel.protoInitialize = function() {
  const proto = ComponentModel2.prototype;
  proto.type = "component";
  proto.id = "";
  proto.name = "";
  proto.mainType = "";
  proto.subType = "";
  proto.componentIndex = 0;
}();
mountExtend(ComponentModel, Model_default);
enableClassManagement(ComponentModel);
enableSubTypeDefaulter(ComponentModel);
enableTopologicalTravel(ComponentModel, getDependencies);
function getDependencies(componentType) {
  let deps = [];
  each(ComponentModel.getClassesByMainType(componentType), function(clz) {
    deps = deps.concat(clz.dependencies || clz.prototype.dependencies || []);
  });
  deps = map(deps, function(type) {
    return parseClassType(type).main;
  });
  if (componentType !== "dataset" && indexOf(deps, "dataset") <= 0) {
    deps.unshift("dataset");
  }
  return deps;
}
var Component_default = ComponentModel;

// src/visual/tokens.ts
var tokens = {
  color: {},
  darkColor: {},
  size: {}
};
var color2 = tokens.color = {
  theme: [
    "#5070dd",
    "#b6d634",
    "#505372",
    "#ff994d",
    "#0ca8df",
    "#ffd10a",
    "#fb628b",
    "#785db0",
    "#3fbe95"
  ],
  neutral00: "#fff",
  neutral05: "#f4f7fd",
  neutral10: "#e8ebf0",
  neutral15: "#dbdee4",
  neutral20: "#cfd2d7",
  neutral25: "#c3c5cb",
  neutral30: "#b7b9be",
  neutral35: "#aaacb2",
  neutral40: "#9ea0a5",
  neutral45: "#929399",
  neutral50: "#86878c",
  neutral55: "#797b7f",
  neutral60: "#6d6e73",
  neutral65: "#616266",
  neutral70: "#54555a",
  neutral75: "#48494d",
  neutral80: "#3c3c41",
  neutral85: "#303034",
  neutral90: "#232328",
  neutral95: "#17171b",
  neutral99: "#000",
  accent05: "#eff1f9",
  accent10: "#e0e4f2",
  accent15: "#d0d6ec",
  accent20: "#c0c9e6",
  accent25: "#b1bbdf",
  accent30: "#a1aed9",
  accent35: "#91a0d3",
  accent40: "#8292cc",
  accent45: "#7285c6",
  accent50: "#6578ba",
  accent55: "#5c6da9",
  accent60: "#536298",
  accent65: "#4a5787",
  accent70: "#404c76",
  accent75: "#374165",
  accent80: "#2e3654",
  accent85: "#252b43",
  accent90: "#1b2032",
  accent95: "#121521",
  transparent: "rgba(0,0,0,0)",
  highlight: "rgba(255,231,130,0.8)"
};
extend(color2, {
  primary: color2.neutral80,
  secondary: color2.neutral70,
  tertiary: color2.neutral60,
  quaternary: color2.neutral50,
  disabled: color2.neutral20,
  border: color2.neutral30,
  borderTint: color2.neutral20,
  borderShade: color2.neutral40,
  background: color2.neutral05,
  backgroundTint: "rgba(234,237,245,0.5)",
  backgroundTransparent: "rgba(255,255,255,0)",
  backgroundShade: color2.neutral10,
  shadow: "rgba(0,0,0,0.2)",
  shadowTint: "rgba(129,130,136,0.2)",
  axisLine: color2.neutral70,
  axisLineTint: color2.neutral40,
  axisTick: color2.neutral70,
  axisTickMinor: color2.neutral60,
  axisLabel: color2.neutral70,
  axisSplitLine: color2.neutral15,
  axisMinorSplitLine: color2.neutral05
});
for (const key in color2) {
  if (color2.hasOwnProperty(key)) {
    const hex = color2[key];
    if (key === "theme") {
      tokens.darkColor.theme = color2.theme.slice();
    } else if (key === "highlight") {
      tokens.darkColor.highlight = "rgba(255,231,130,0.4)";
    } else if (key.indexOf("accent") === 0) {
      tokens.darkColor[key] = modifyHSL(hex, null, (s) => s * 0.5, (l) => Math.min(1, 1.3 - l));
    } else {
      tokens.darkColor[key] = modifyHSL(hex, null, (s) => s * 0.9, (l) => 1 - l);
    }
  }
}
tokens.size = {
  xxs: 2,
  xs: 5,
  s: 10,
  m: 15,
  l: 20,
  xl: 30,
  xxl: 40,
  xxxl: 50
};
var tokens_default = tokens;

// src/model/globalDefault.ts
var platform = "";
if (typeof navigator !== "undefined") {
  platform = navigator.platform || "";
}
var decalColor = "rgba(0, 0, 0, 0.2)";
var themeColor = tokens_default.color.theme[0];
var lightThemeColor = modifyHSL(themeColor, null, null, 0.9);
var globalDefault_default = {
  darkMode: "auto",
  colorBy: "series",
  color: tokens_default.color.theme,
  gradientColor: [lightThemeColor, themeColor],
  aria: {
    decal: {
      decals: [{
        color: decalColor,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: decalColor,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: decalColor,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: decalColor,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: decalColor,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: decalColor,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  textStyle: {
    fontFamily: platform.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2e3,
  progressiveThreshold: 3e3,
  progressive: 400,
  hoverLayerThreshold: 3e3,
  useUTC: false
};

// src/data/helper/sourceHelper.ts
var BE_ORDINAL = {
  Must: 1,
  Might: 2,
  Not: 3
};
var innerGlobalModel = makeInner();
function resetSourceDefaulter(ecModel) {
  innerGlobalModel(ecModel).datasetMap = createHashMap();
}
function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {
  const encode = {};
  const datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
  if (!datasetModel || !coordDimensions) {
    return encode;
  }
  const encodeItemName = [];
  const encodeSeriesName = [];
  const ecModel = seriesModel.ecModel;
  const datasetMap = innerGlobalModel(ecModel).datasetMap;
  const key = datasetModel.uid + "_" + source.seriesLayoutBy;
  let baseCategoryDimIndex;
  let categoryWayValueDimStart;
  coordDimensions = coordDimensions.slice();
  each(coordDimensions, function(coordDimInfoLoose, coordDimIdx) {
    const coordDimInfo = isObject(coordDimInfoLoose) ? coordDimInfoLoose : coordDimensions[coordDimIdx] = {name: coordDimInfoLoose};
    if (coordDimInfo.type === "ordinal" && baseCategoryDimIndex == null) {
      baseCategoryDimIndex = coordDimIdx;
      categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimInfo);
    }
    encode[coordDimInfo.name] = [];
  });
  const datasetRecord = datasetMap.get(key) || datasetMap.set(key, {categoryWayDim: categoryWayValueDimStart, valueWayDim: 0});
  each(coordDimensions, function(coordDimInfo, coordDimIdx) {
    const coordDimName = coordDimInfo.name;
    const count2 = getDataDimCountOnCoordDim(coordDimInfo);
    if (baseCategoryDimIndex == null) {
      const start2 = datasetRecord.valueWayDim;
      pushDim(encode[coordDimName], start2, count2);
      pushDim(encodeSeriesName, start2, count2);
      datasetRecord.valueWayDim += count2;
    } else if (baseCategoryDimIndex === coordDimIdx) {
      pushDim(encode[coordDimName], 0, count2);
      pushDim(encodeItemName, 0, count2);
    } else {
      const start2 = datasetRecord.categoryWayDim;
      pushDim(encode[coordDimName], start2, count2);
      pushDim(encodeSeriesName, start2, count2);
      datasetRecord.categoryWayDim += count2;
    }
  });
  function pushDim(dimIdxArr, idxFrom, idxCount) {
    for (let i = 0; i < idxCount; i++) {
      dimIdxArr.push(idxFrom + i);
    }
  }
  function getDataDimCountOnCoordDim(coordDimInfo) {
    const dimsDef = coordDimInfo.dimsDef;
    return dimsDef ? dimsDef.length : 1;
  }
  encodeItemName.length && (encode.itemName = encodeItemName);
  encodeSeriesName.length && (encode.seriesName = encodeSeriesName);
  return encode;
}
function makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {
  const encode = {};
  const datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
  if (!datasetModel) {
    return encode;
  }
  const sourceFormat = source.sourceFormat;
  const dimensionsDefine = source.dimensionsDefine;
  let potentialNameDimIndex;
  if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    each(dimensionsDefine, function(dim, idx) {
      if ((isObject(dim) ? dim.name : dim) === "name") {
        potentialNameDimIndex = idx;
      }
    });
  }
  const idxResult = function() {
    const idxRes0 = {};
    const idxRes1 = {};
    const guessRecords = [];
    for (let i = 0, len2 = Math.min(5, dimCount); i < len2; i++) {
      const guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i);
      guessRecords.push(guessResult);
      const isPureNumber = guessResult === BE_ORDINAL.Not;
      if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {
        idxRes0.v = i;
      }
      if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {
        idxRes0.n = i;
      }
      if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {
        return idxRes0;
      }
      if (!isPureNumber) {
        if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {
          idxRes1.v = i;
        }
        if (idxRes1.n == null || idxRes1.n === idxRes1.v) {
          idxRes1.n = i;
        }
      }
    }
    function fulfilled(idxResult2) {
      return idxResult2.v != null && idxResult2.n != null;
    }
    return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;
  }();
  if (idxResult) {
    encode.value = [idxResult.v];
    const nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n;
    encode.itemName = [nameDimIndex];
    encode.seriesName = [nameDimIndex];
  }
  return encode;
}
function querySeriesUpstreamDatasetModel(seriesModel) {
  const thisData = seriesModel.get("data", true);
  if (!thisData) {
    return queryReferringComponents(seriesModel.ecModel, "dataset", {
      index: seriesModel.get("datasetIndex", true),
      id: seriesModel.get("datasetId", true)
    }, SINGLE_REFERRING).models[0];
  }
}
function queryDatasetUpstreamDatasetModels(datasetModel) {
  if (!datasetModel.get("transform", true) && !datasetModel.get("fromTransformResult", true)) {
    return [];
  }
  return queryReferringComponents(datasetModel.ecModel, "dataset", {
    index: datasetModel.get("fromDatasetIndex", true),
    id: datasetModel.get("fromDatasetId", true)
  }, SINGLE_REFERRING).models;
}
function guessOrdinal(source, dimIndex) {
  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);
}
function doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {
  let result;
  const maxLoop = 5;
  if (isTypedArray(data)) {
    return BE_ORDINAL.Not;
  }
  let dimName;
  let dimType;
  if (dimensionsDefine) {
    const dimDefItem = dimensionsDefine[dimIndex];
    if (isObject(dimDefItem)) {
      dimName = dimDefItem.name;
      dimType = dimDefItem.type;
    } else if (isString(dimDefItem)) {
      dimName = dimDefItem;
    }
  }
  if (dimType != null) {
    return dimType === "ordinal" ? BE_ORDINAL.Must : BE_ORDINAL.Not;
  }
  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    const dataArrayRows = data;
    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
      const sample = dataArrayRows[dimIndex];
      for (let i = 0; i < (sample || []).length && i < maxLoop; i++) {
        if ((result = detectValue(sample[startIndex + i])) != null) {
          return result;
        }
      }
    } else {
      for (let i = 0; i < dataArrayRows.length && i < maxLoop; i++) {
        const row = dataArrayRows[startIndex + i];
        if (row && (result = detectValue(row[dimIndex])) != null) {
          return result;
        }
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    const dataObjectRows = data;
    if (!dimName) {
      return BE_ORDINAL.Not;
    }
    for (let i = 0; i < dataObjectRows.length && i < maxLoop; i++) {
      const item = dataObjectRows[i];
      if (item && (result = detectValue(item[dimName])) != null) {
        return result;
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    const dataKeyedColumns = data;
    if (!dimName) {
      return BE_ORDINAL.Not;
    }
    const sample = dataKeyedColumns[dimName];
    if (!sample || isTypedArray(sample)) {
      return BE_ORDINAL.Not;
    }
    for (let i = 0; i < sample.length && i < maxLoop; i++) {
      if ((result = detectValue(sample[i])) != null) {
        return result;
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    const dataOriginal = data;
    for (let i = 0; i < dataOriginal.length && i < maxLoop; i++) {
      const item = dataOriginal[i];
      const val = getDataItemValue(item);
      if (!isArray(val)) {
        return BE_ORDINAL.Not;
      }
      if ((result = detectValue(val[dimIndex])) != null) {
        return result;
      }
    }
  }
  function detectValue(val) {
    const beStr = isString(val);
    if (val != null && Number.isFinite(Number(val)) && val !== "") {
      return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;
    } else if (beStr && val !== "-") {
      return BE_ORDINAL.Must;
    }
  }
  return BE_ORDINAL.Not;
}

// src/model/internalComponentCreator.ts
var internalOptionCreatorMap = createHashMap();
function registerInternalOptionCreator(mainType, creator) {
  assert(internalOptionCreatorMap.get(mainType) == null && creator);
  internalOptionCreatorMap.set(mainType, creator);
}
function concatInternalOptions(ecModel, mainType, newCmptOptionList) {
  const internalOptionCreator = internalOptionCreatorMap.get(mainType);
  if (!internalOptionCreator) {
    return newCmptOptionList;
  }
  const internalOptions = internalOptionCreator(ecModel);
  if (!internalOptions) {
    return newCmptOptionList;
  }
  if (true) {
    for (let i = 0; i < internalOptions.length; i++) {
      assert(isComponentIdInternal(internalOptions[i]));
    }
  }
  return newCmptOptionList.concat(internalOptions);
}

// src/model/mixin/palette.ts
var innerColor = makeInner();
var innerDecal = makeInner();
var PaletteMixin = class {
  getColorFromPalette(name, scope, requestNum) {
    const defaultPalette = normalizeToArray(this.get("color", true));
    const layeredPalette = this.get("colorLayer", true);
    return getFromPalette(this, innerColor, defaultPalette, layeredPalette, name, scope, requestNum);
  }
  clearColorPalette() {
    clearPalette(this, innerColor);
  }
};
function getDecalFromPalette(ecModel, name, scope, requestNum) {
  const defaultDecals = normalizeToArray(ecModel.get(["aria", "decal", "decals"]));
  return getFromPalette(ecModel, innerDecal, defaultDecals, null, name, scope, requestNum);
}
function getNearestPalette(palettes, requestColorNum) {
  const paletteNum = palettes.length;
  for (let i = 0; i < paletteNum; i++) {
    if (palettes[i].length > requestColorNum) {
      return palettes[i];
    }
  }
  return palettes[paletteNum - 1];
}
function getFromPalette(that, inner25, defaultPalette, layeredPalette, name, scope, requestNum) {
  scope = scope || that;
  const scopeFields = inner25(scope);
  const paletteIdx = scopeFields.paletteIdx || 0;
  const paletteNameMap = scopeFields.paletteNameMap = scopeFields.paletteNameMap || {};
  if (paletteNameMap.hasOwnProperty(name)) {
    return paletteNameMap[name];
  }
  let palette = requestNum == null || !layeredPalette ? defaultPalette : getNearestPalette(layeredPalette, requestNum);
  palette = palette || defaultPalette;
  if (!palette || !palette.length) {
    return;
  }
  const pickedPaletteItem = palette[paletteIdx];
  if (name) {
    paletteNameMap[name] = pickedPaletteItem;
  }
  scopeFields.paletteIdx = (paletteIdx + 1) % palette.length;
  return pickedPaletteItem;
}
function clearPalette(that, inner25) {
  inner25(that).paletteIdx = 0;
  inner25(that).paletteNameMap = {};
}

// src/model/Global.ts
var reCreateSeriesIndices;
var assertSeriesInitialized;
var initBase;
var OPTION_INNER_KEY = "\0_ec_inner";
var OPTION_INNER_VALUE = 1;
var BUITIN_COMPONENTS_MAP = {
  grid: "GridComponent",
  polar: "PolarComponent",
  geo: "GeoComponent",
  singleAxis: "SingleAxisComponent",
  parallel: "ParallelComponent",
  calendar: "CalendarComponent",
  matrix: "MatrixComponent",
  graphic: "GraphicComponent",
  toolbox: "ToolboxComponent",
  tooltip: "TooltipComponent",
  axisPointer: "AxisPointerComponent",
  brush: "BrushComponent",
  title: "TitleComponent",
  timeline: "TimelineComponent",
  markPoint: "MarkPointComponent",
  markLine: "MarkLineComponent",
  markArea: "MarkAreaComponent",
  legend: "LegendComponent",
  dataZoom: "DataZoomComponent",
  visualMap: "VisualMapComponent",
  xAxis: "GridComponent",
  yAxis: "GridComponent",
  angleAxis: "PolarComponent",
  radiusAxis: "PolarComponent"
};
var BUILTIN_CHARTS_MAP = {
  line: "LineChart",
  bar: "BarChart",
  pie: "PieChart",
  scatter: "ScatterChart",
  radar: "RadarChart",
  map: "MapChart",
  tree: "TreeChart",
  treemap: "TreemapChart",
  graph: "GraphChart",
  chord: "ChordChart",
  gauge: "GaugeChart",
  funnel: "FunnelChart",
  parallel: "ParallelChart",
  sankey: "SankeyChart",
  boxplot: "BoxplotChart",
  candlestick: "CandlestickChart",
  effectScatter: "EffectScatterChart",
  lines: "LinesChart",
  heatmap: "HeatmapChart",
  pictorialBar: "PictorialBarChart",
  themeRiver: "ThemeRiverChart",
  sunburst: "SunburstChart",
  custom: "CustomChart"
};
var componetsMissingLogPrinted = {};
function checkMissingComponents(option) {
  each(option, function(componentOption, mainType) {
    if (!Component_default.hasClass(mainType)) {
      const componentImportName = BUITIN_COMPONENTS_MAP[mainType];
      if (componentImportName && !componetsMissingLogPrinted[componentImportName]) {
        error(`Component ${mainType} is used but not imported.
import { ${componentImportName} } from 'echarts/components';
echarts.use([${componentImportName}]);`);
        componetsMissingLogPrinted[componentImportName] = true;
      }
    }
  });
}
var GlobalModel = class extends Model_default {
  init(option, parentModel, ecModel, theme2, locale, optionManager) {
    theme2 = theme2 || {};
    this.option = null;
    this._theme = new Model_default(theme2);
    this._locale = new Model_default(locale);
    this._optionManager = optionManager;
  }
  setOption(option, opts, optionPreprocessorFuncs2) {
    if (true) {
      assert(option != null, "option is null/undefined");
      assert(option[OPTION_INNER_KEY] !== OPTION_INNER_VALUE, "please use chart.getOption()");
    }
    const innerOpt = normalizeSetOptionInput(opts);
    this._optionManager.setOption(option, optionPreprocessorFuncs2, innerOpt);
    this._resetOption(null, innerOpt);
  }
  resetOption(type, opt) {
    return this._resetOption(type, normalizeSetOptionInput(opt));
  }
  _resetOption(type, opt) {
    let optionChanged = false;
    const optionManager = this._optionManager;
    if (!type || type === "recreate") {
      const baseOption = optionManager.mountOption(type === "recreate");
      if (true) {
        checkMissingComponents(baseOption);
      }
      if (!this.option || type === "recreate") {
        initBase(this, baseOption);
      } else {
        this.restoreData();
        this._mergeOption(baseOption, opt);
      }
      optionChanged = true;
    }
    if (type === "timeline" || type === "media") {
      this.restoreData();
    }
    if (!type || type === "recreate" || type === "timeline") {
      const timelineOption = optionManager.getTimelineOption(this);
      if (timelineOption) {
        optionChanged = true;
        this._mergeOption(timelineOption, opt);
      }
    }
    if (!type || type === "recreate" || type === "media") {
      const mediaOptions = optionManager.getMediaOption(this);
      if (mediaOptions.length) {
        each(mediaOptions, function(mediaOption) {
          optionChanged = true;
          this._mergeOption(mediaOption, opt);
        }, this);
      }
    }
    return optionChanged;
  }
  mergeOption(option) {
    this._mergeOption(option, null);
  }
  _mergeOption(newOption, opt) {
    const option = this.option;
    const componentsMap = this._componentsMap;
    const componentsCount = this._componentsCount;
    const newCmptTypes = [];
    const newCmptTypeMap = createHashMap();
    const replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap;
    resetSourceDefaulter(this);
    each(newOption, function(componentOption, mainType) {
      if (componentOption == null) {
        return;
      }
      if (!Component_default.hasClass(mainType)) {
        option[mainType] = option[mainType] == null ? clone(componentOption) : merge(option[mainType], componentOption, true);
      } else if (mainType) {
        newCmptTypes.push(mainType);
        newCmptTypeMap.set(mainType, true);
      }
    });
    if (replaceMergeMainTypeMap) {
      replaceMergeMainTypeMap.each(function(val, mainTypeInReplaceMerge) {
        if (Component_default.hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {
          newCmptTypes.push(mainTypeInReplaceMerge);
          newCmptTypeMap.set(mainTypeInReplaceMerge, true);
        }
      });
    }
    Component_default.topologicalTravel(newCmptTypes, Component_default.getAllClassMainTypes(), visitComponent, this);
    function visitComponent(mainType) {
      const newCmptOptionList = concatInternalOptions(this, mainType, normalizeToArray(newOption[mainType]));
      const oldCmptList = componentsMap.get(mainType);
      const mergeMode = !oldCmptList ? "replaceAll" : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? "replaceMerge" : "normalMerge";
      const mappingResult = mappingToExists(oldCmptList, newCmptOptionList, mergeMode);
      setComponentTypeToKeyInfo(mappingResult, mainType, Component_default);
      option[mainType] = null;
      componentsMap.set(mainType, null);
      componentsCount.set(mainType, 0);
      const optionsByMainType = [];
      const cmptsByMainType = [];
      let cmptsCountByMainType = 0;
      let tooltipExists;
      let tooltipWarningLogged;
      each(mappingResult, function(resultItem, index) {
        let componentModel = resultItem.existing;
        const newCmptOption = resultItem.newOption;
        if (!newCmptOption) {
          if (componentModel) {
            componentModel.mergeOption({}, this);
            componentModel.optionUpdated({}, false);
          }
        } else {
          const isSeriesType = mainType === "series";
          const ComponentModelClass = Component_default.getClass(mainType, resultItem.keyInfo.subType, !isSeriesType);
          if (!ComponentModelClass) {
            if (true) {
              const subType = resultItem.keyInfo.subType;
              const seriesImportName = BUILTIN_CHARTS_MAP[subType];
              if (!componetsMissingLogPrinted[subType]) {
                componetsMissingLogPrinted[subType] = true;
                if (seriesImportName) {
                  error(`Series ${subType} is used but not imported.
import { ${seriesImportName} } from 'echarts/charts';
echarts.use([${seriesImportName}]);`);
                } else {
                  error(`Unknown series ${subType}`);
                }
              }
            }
            return;
          }
          if (mainType === "tooltip") {
            if (tooltipExists) {
              if (true) {
                if (!tooltipWarningLogged) {
                  warn("Currently only one tooltip component is allowed.");
                  tooltipWarningLogged = true;
                }
              }
              return;
            }
            tooltipExists = true;
          }
          if (componentModel && componentModel.constructor === ComponentModelClass) {
            componentModel.name = resultItem.keyInfo.name;
            componentModel.mergeOption(newCmptOption, this);
            componentModel.optionUpdated(newCmptOption, false);
          } else {
            const extraOpt = extend({
              componentIndex: index
            }, resultItem.keyInfo);
            componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt);
            extend(componentModel, extraOpt);
            if (resultItem.brandNew) {
              componentModel.__requireNewView = true;
            }
            componentModel.init(newCmptOption, this, this);
            componentModel.optionUpdated(null, true);
          }
        }
        if (componentModel) {
          optionsByMainType.push(componentModel.option);
          cmptsByMainType.push(componentModel);
          cmptsCountByMainType++;
        } else {
          optionsByMainType.push(void 0);
          cmptsByMainType.push(void 0);
        }
      }, this);
      option[mainType] = optionsByMainType;
      componentsMap.set(mainType, cmptsByMainType);
      componentsCount.set(mainType, cmptsCountByMainType);
      if (mainType === "series") {
        reCreateSeriesIndices(this);
      }
    }
    if (!this._seriesIndices) {
      reCreateSeriesIndices(this);
    }
  }
  getOption() {
    const option = clone(this.option);
    each(option, function(optInMainType, mainType) {
      if (Component_default.hasClass(mainType)) {
        const opts = normalizeToArray(optInMainType);
        let realLen = opts.length;
        let metNonInner = false;
        for (let i = realLen - 1; i >= 0; i--) {
          if (opts[i] && !isComponentIdInternal(opts[i])) {
            metNonInner = true;
          } else {
            opts[i] = null;
            !metNonInner && realLen--;
          }
        }
        opts.length = realLen;
        option[mainType] = opts;
      }
    });
    delete option[OPTION_INNER_KEY];
    return option;
  }
  setTheme(theme2) {
    this._theme = new Model_default(theme2);
    this._resetOption("recreate", null);
  }
  getTheme() {
    return this._theme;
  }
  getLocaleModel() {
    return this._locale;
  }
  setUpdatePayload(payload) {
    this._payload = payload;
  }
  getUpdatePayload() {
    return this._payload;
  }
  getComponent(mainType, idx) {
    const list = this._componentsMap.get(mainType);
    if (list) {
      const cmpt = list[idx || 0];
      if (cmpt) {
        return cmpt;
      } else if (idx == null) {
        for (let i = 0; i < list.length; i++) {
          if (list[i]) {
            return list[i];
          }
        }
      }
    }
  }
  queryComponents(condition) {
    const mainType = condition.mainType;
    if (!mainType) {
      return [];
    }
    const index = condition.index;
    const id = condition.id;
    const name = condition.name;
    const cmpts = this._componentsMap.get(mainType);
    if (!cmpts || !cmpts.length) {
      return [];
    }
    let result;
    if (index != null) {
      result = [];
      each(normalizeToArray(index), function(idx) {
        cmpts[idx] && result.push(cmpts[idx]);
      });
    } else if (id != null) {
      result = queryByIdOrName("id", id, cmpts);
    } else if (name != null) {
      result = queryByIdOrName("name", name, cmpts);
    } else {
      result = filter(cmpts, (cmpt) => !!cmpt);
    }
    return filterBySubType(result, condition);
  }
  findComponents(condition) {
    const query = condition.query;
    const mainType = condition.mainType;
    const queryCond = getQueryCond(query);
    const result = queryCond ? this.queryComponents(queryCond) : filter(this._componentsMap.get(mainType), (cmpt) => !!cmpt);
    return doFilter(filterBySubType(result, condition));
    function getQueryCond(q) {
      const indexAttr = mainType + "Index";
      const idAttr = mainType + "Id";
      const nameAttr = mainType + "Name";
      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {
        mainType,
        index: q[indexAttr],
        id: q[idAttr],
        name: q[nameAttr]
      } : null;
    }
    function doFilter(res) {
      return condition.filter ? filter(res, condition.filter) : res;
    }
  }
  eachComponent(mainType, cb, context) {
    const componentsMap = this._componentsMap;
    if (isFunction(mainType)) {
      const ctxForAll = cb;
      const cbForAll = mainType;
      componentsMap.each(function(cmpts, componentType) {
        for (let i = 0; cmpts && i < cmpts.length; i++) {
          const cmpt = cmpts[i];
          cmpt && cbForAll.call(ctxForAll, componentType, cmpt, cmpt.componentIndex);
        }
      });
    } else {
      const cmpts = isString(mainType) ? componentsMap.get(mainType) : isObject(mainType) ? this.findComponents(mainType) : null;
      for (let i = 0; cmpts && i < cmpts.length; i++) {
        const cmpt = cmpts[i];
        cmpt && cb.call(context, cmpt, cmpt.componentIndex);
      }
    }
  }
  getSeriesByName(name) {
    const nameStr = convertOptionIdName(name, null);
    return filter(this._componentsMap.get("series"), (oneSeries) => !!oneSeries && nameStr != null && oneSeries.name === nameStr);
  }
  getSeriesByIndex(seriesIndex) {
    return this._componentsMap.get("series")[seriesIndex];
  }
  getSeriesByType(subType) {
    return filter(this._componentsMap.get("series"), (oneSeries) => !!oneSeries && oneSeries.subType === subType);
  }
  getSeries() {
    return filter(this._componentsMap.get("series"), (oneSeries) => !!oneSeries);
  }
  getSeriesCount() {
    return this._componentsCount.get("series");
  }
  eachSeries(cb, context) {
    assertSeriesInitialized(this);
    each(this._seriesIndices, function(rawSeriesIndex) {
      const series = this._componentsMap.get("series")[rawSeriesIndex];
      cb.call(context, series, rawSeriesIndex);
    }, this);
  }
  eachRawSeries(cb, context) {
    each(this._componentsMap.get("series"), function(series) {
      series && cb.call(context, series, series.componentIndex);
    });
  }
  eachSeriesByType(subType, cb, context) {
    assertSeriesInitialized(this);
    each(this._seriesIndices, function(rawSeriesIndex) {
      const series = this._componentsMap.get("series")[rawSeriesIndex];
      if (series.subType === subType) {
        cb.call(context, series, rawSeriesIndex);
      }
    }, this);
  }
  eachRawSeriesByType(subType, cb, context) {
    return each(this.getSeriesByType(subType), cb, context);
  }
  isSeriesFiltered(seriesModel) {
    assertSeriesInitialized(this);
    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;
  }
  getCurrentSeriesIndices() {
    return (this._seriesIndices || []).slice();
  }
  filterSeries(cb, context) {
    assertSeriesInitialized(this);
    const newSeriesIndices = [];
    each(this._seriesIndices, function(seriesRawIdx) {
      const series = this._componentsMap.get("series")[seriesRawIdx];
      cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx);
    }, this);
    this._seriesIndices = newSeriesIndices;
    this._seriesIndicesMap = createHashMap(newSeriesIndices);
  }
  restoreData(payload) {
    reCreateSeriesIndices(this);
    const componentsMap = this._componentsMap;
    const componentTypes = [];
    componentsMap.each(function(components, componentType) {
      if (Component_default.hasClass(componentType)) {
        componentTypes.push(componentType);
      }
    });
    Component_default.topologicalTravel(componentTypes, Component_default.getAllClassMainTypes(), function(componentType) {
      each(componentsMap.get(componentType), function(component) {
        if (component && (componentType !== "series" || !isNotTargetSeries(component, payload))) {
          component.restoreData();
        }
      });
    });
  }
};
GlobalModel.internalField = function() {
  reCreateSeriesIndices = function(ecModel) {
    const seriesIndices = ecModel._seriesIndices = [];
    each(ecModel._componentsMap.get("series"), function(series) {
      series && seriesIndices.push(series.componentIndex);
    });
    ecModel._seriesIndicesMap = createHashMap(seriesIndices);
  };
  assertSeriesInitialized = function(ecModel) {
    if (true) {
      if (!ecModel._seriesIndices) {
        throw new Error("Option should contains series.");
      }
    }
  };
  initBase = function(ecModel, baseOption) {
    ecModel.option = {};
    ecModel.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE;
    ecModel._componentsMap = createHashMap({series: []});
    ecModel._componentsCount = createHashMap();
    const airaOption = baseOption.aria;
    if (isObject(airaOption) && airaOption.enabled == null) {
      airaOption.enabled = true;
    }
    mergeTheme(baseOption, ecModel._theme.option);
    merge(baseOption, globalDefault_default, false);
    ecModel._mergeOption(baseOption, null);
  };
}();
function isNotTargetSeries(seriesModel, payload) {
  if (payload) {
    const index = payload.seriesIndex;
    const id = payload.seriesId;
    const name = payload.seriesName;
    return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name != null && seriesModel.name !== name;
  }
}
function mergeTheme(option, theme2) {
  const notMergeColorLayer = option.color && !option.colorLayer;
  each(theme2, function(themeItem, name) {
    if (name === "colorLayer" && notMergeColorLayer || name === "color" && option.color) {
      return;
    }
    if (!Component_default.hasClass(name)) {
      if (typeof themeItem === "object") {
        option[name] = !option[name] ? clone(themeItem) : merge(option[name], themeItem, false);
      } else {
        if (option[name] == null) {
          option[name] = themeItem;
        }
      }
    }
  });
}
function queryByIdOrName(attr, idOrName, cmpts) {
  if (isArray(idOrName)) {
    const keyMap = createHashMap();
    each(idOrName, function(idOrNameItem) {
      if (idOrNameItem != null) {
        const idName = convertOptionIdName(idOrNameItem, null);
        idName != null && keyMap.set(idOrNameItem, true);
      }
    });
    return filter(cmpts, (cmpt) => cmpt && keyMap.get(cmpt[attr]));
  } else {
    const idName = convertOptionIdName(idOrName, null);
    return filter(cmpts, (cmpt) => cmpt && idName != null && cmpt[attr] === idName);
  }
}
function filterBySubType(components, condition) {
  return condition.hasOwnProperty("subType") ? filter(components, (cmpt) => cmpt && cmpt.subType === condition.subType) : components;
}
function normalizeSetOptionInput(opts) {
  const replaceMergeMainTypeMap = createHashMap();
  opts && each(normalizeToArray(opts.replaceMerge), function(mainType) {
    if (true) {
      assert(Component_default.hasClass(mainType), '"' + mainType + '" is not valid component main type in "replaceMerge"');
    }
    replaceMergeMainTypeMap.set(mainType, true);
  });
  return {
    replaceMergeMainTypeMap
  };
}
mixin(GlobalModel, PaletteMixin);
var Global_default = GlobalModel;

// src/core/ExtensionAPI.ts
var availableMethods = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  "getOption",
  "getId",
  "updateLabelLayout"
];
var ExtensionAPI = class {
  constructor(ecInstance) {
    each(availableMethods, function(methodName) {
      this[methodName] = bind(ecInstance[methodName], ecInstance);
    }, this);
  }
};
var ExtensionAPI_default = ExtensionAPI;

// src/model/OptionManager.ts
var QUERY_REG = /^(min|max)?(.+)$/;
var OptionManager = class {
  constructor(api2) {
    this._timelineOptions = [];
    this._mediaList = [];
    this._currentMediaIndices = [];
    this._api = api2;
  }
  setOption(rawOption, optionPreprocessorFuncs2, opt) {
    if (rawOption) {
      each(normalizeToArray(rawOption.series), function(series) {
        series && series.data && isTypedArray(series.data) && setAsPrimitive(series.data);
      });
      each(normalizeToArray(rawOption.dataset), function(dataset) {
        dataset && dataset.source && isTypedArray(dataset.source) && setAsPrimitive(dataset.source);
      });
    }
    rawOption = clone(rawOption);
    const optionBackup = this._optionBackup;
    const newParsedOption = parseRawOption(rawOption, optionPreprocessorFuncs2, !optionBackup);
    this._newBaseOption = newParsedOption.baseOption;
    if (optionBackup) {
      if (newParsedOption.timelineOptions.length) {
        optionBackup.timelineOptions = newParsedOption.timelineOptions;
      }
      if (newParsedOption.mediaList.length) {
        optionBackup.mediaList = newParsedOption.mediaList;
      }
      if (newParsedOption.mediaDefault) {
        optionBackup.mediaDefault = newParsedOption.mediaDefault;
      }
    } else {
      this._optionBackup = newParsedOption;
    }
  }
  mountOption(isRecreate) {
    const optionBackup = this._optionBackup;
    this._timelineOptions = optionBackup.timelineOptions;
    this._mediaList = optionBackup.mediaList;
    this._mediaDefault = optionBackup.mediaDefault;
    this._currentMediaIndices = [];
    return clone(isRecreate ? optionBackup.baseOption : this._newBaseOption);
  }
  getTimelineOption(ecModel) {
    let option;
    const timelineOptions = this._timelineOptions;
    if (timelineOptions.length) {
      const timelineModel = ecModel.getComponent("timeline");
      if (timelineModel) {
        option = clone(timelineOptions[timelineModel.getCurrentIndex()]);
      }
    }
    return option;
  }
  getMediaOption(ecModel) {
    const ecWidth = this._api.getWidth();
    const ecHeight = this._api.getHeight();
    const mediaList = this._mediaList;
    const mediaDefault = this._mediaDefault;
    let indices = [];
    let result = [];
    if (!mediaList.length && !mediaDefault) {
      return result;
    }
    for (let i = 0, len2 = mediaList.length; i < len2; i++) {
      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
        indices.push(i);
      }
    }
    if (!indices.length && mediaDefault) {
      indices = [-1];
    }
    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
      result = map(indices, function(index) {
        return clone(index === -1 ? mediaDefault.option : mediaList[index].option);
      });
    }
    this._currentMediaIndices = indices;
    return result;
  }
};
function parseRawOption(rawOption, optionPreprocessorFuncs2, isNew) {
  const mediaList = [];
  let mediaDefault;
  let baseOption;
  const declaredBaseOption = rawOption.baseOption;
  const timelineOnRoot = rawOption.timeline;
  const timelineOptionsOnRoot = rawOption.options;
  const mediaOnRoot = rawOption.media;
  const hasMedia = !!rawOption.media;
  const hasTimeline = !!(timelineOptionsOnRoot || timelineOnRoot || declaredBaseOption && declaredBaseOption.timeline);
  if (declaredBaseOption) {
    baseOption = declaredBaseOption;
    if (!baseOption.timeline) {
      baseOption.timeline = timelineOnRoot;
    }
  } else {
    if (hasTimeline || hasMedia) {
      rawOption.options = rawOption.media = null;
    }
    baseOption = rawOption;
  }
  if (hasMedia) {
    if (isArray(mediaOnRoot)) {
      each(mediaOnRoot, function(singleMedia) {
        if (true) {
          if (singleMedia && !singleMedia.option && isObject(singleMedia.query) && isObject(singleMedia.query.option)) {
            error("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }");
          }
        }
        if (singleMedia && singleMedia.option) {
          if (singleMedia.query) {
            mediaList.push(singleMedia);
          } else if (!mediaDefault) {
            mediaDefault = singleMedia;
          }
        }
      });
    } else {
      if (true) {
        error("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }");
      }
    }
  }
  doPreprocess(baseOption);
  each(timelineOptionsOnRoot, (option) => doPreprocess(option));
  each(mediaList, (media) => doPreprocess(media.option));
  function doPreprocess(option) {
    each(optionPreprocessorFuncs2, function(preProcess) {
      preProcess(option, isNew);
    });
  }
  return {
    baseOption,
    timelineOptions: timelineOptionsOnRoot || [],
    mediaDefault,
    mediaList
  };
}
function applyMediaQuery(query, ecWidth, ecHeight) {
  const realMap = {
    width: ecWidth,
    height: ecHeight,
    aspectratio: ecWidth / ecHeight
  };
  let applicable = true;
  each(query, function(value, attr) {
    const matched = attr.match(QUERY_REG);
    if (!matched || !matched[1] || !matched[2]) {
      return;
    }
    const operator = matched[1];
    const realAttr = matched[2].toLowerCase();
    if (!compare(realMap[realAttr], value, operator)) {
      applicable = false;
    }
  });
  return applicable;
}
function compare(real, expect, operator) {
  if (operator === "min") {
    return real >= expect;
  } else if (operator === "max") {
    return real <= expect;
  } else {
    return real === expect;
  }
}
function indicesEquals(indices1, indices2) {
  return indices1.join(",") === indices2.join(",");
}
var OptionManager_default = OptionManager;

// src/preprocessor/helper/compatStyle.ts
var each3 = each;
var isObject2 = isObject;
var POSSIBLE_STYLES = [
  "areaStyle",
  "lineStyle",
  "nodeStyle",
  "linkStyle",
  "chordStyle",
  "label",
  "labelLine"
];
function compatEC2ItemStyle(opt) {
  const itemStyleOpt = opt && opt.itemStyle;
  if (!itemStyleOpt) {
    return;
  }
  for (let i = 0, len2 = POSSIBLE_STYLES.length; i < len2; i++) {
    const styleName = POSSIBLE_STYLES[i];
    const normalItemStyleOpt = itemStyleOpt.normal;
    const emphasisItemStyleOpt = itemStyleOpt.emphasis;
    if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
      if (true) {
        deprecateReplaceLog(`itemStyle.normal.${styleName}`, styleName);
      }
      opt[styleName] = opt[styleName] || {};
      if (!opt[styleName].normal) {
        opt[styleName].normal = normalItemStyleOpt[styleName];
      } else {
        merge(opt[styleName].normal, normalItemStyleOpt[styleName]);
      }
      normalItemStyleOpt[styleName] = null;
    }
    if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
      if (true) {
        deprecateReplaceLog(`itemStyle.emphasis.${styleName}`, `emphasis.${styleName}`);
      }
      opt[styleName] = opt[styleName] || {};
      if (!opt[styleName].emphasis) {
        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
      } else {
        merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
      }
      emphasisItemStyleOpt[styleName] = null;
    }
  }
}
function convertNormalEmphasis(opt, optType, useExtend) {
  if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {
    const normalOpt = opt[optType].normal;
    const emphasisOpt = opt[optType].emphasis;
    if (normalOpt) {
      if (true) {
        deprecateLog(`'normal' hierarchy in ${optType} has been removed since 4.0. All style properties are configured in ${optType} directly now.`);
      }
      if (useExtend) {
        opt[optType].normal = opt[optType].emphasis = null;
        defaults(opt[optType], normalOpt);
      } else {
        opt[optType] = normalOpt;
      }
    }
    if (emphasisOpt) {
      if (true) {
        deprecateLog(`${optType}.emphasis has been changed to emphasis.${optType} since 4.0`);
      }
      opt.emphasis = opt.emphasis || {};
      opt.emphasis[optType] = emphasisOpt;
      if (emphasisOpt.focus) {
        opt.emphasis.focus = emphasisOpt.focus;
      }
      if (emphasisOpt.blurScope) {
        opt.emphasis.blurScope = emphasisOpt.blurScope;
      }
    }
  }
}
function removeEC3NormalStatus(opt) {
  convertNormalEmphasis(opt, "itemStyle");
  convertNormalEmphasis(opt, "lineStyle");
  convertNormalEmphasis(opt, "areaStyle");
  convertNormalEmphasis(opt, "label");
  convertNormalEmphasis(opt, "labelLine");
  convertNormalEmphasis(opt, "upperLabel");
  convertNormalEmphasis(opt, "edgeLabel");
}
function compatTextStyle(opt, propName) {
  const labelOptSingle = isObject2(opt) && opt[propName];
  const textStyle = isObject2(labelOptSingle) && labelOptSingle.textStyle;
  if (textStyle) {
    if (true) {
      deprecateLog(`textStyle hierarchy in ${propName} has been removed since 4.0. All textStyle properties are configured in ${propName} directly now.`);
    }
    for (let i = 0, len2 = TEXT_STYLE_OPTIONS.length; i < len2; i++) {
      const textPropName = TEXT_STYLE_OPTIONS[i];
      if (textStyle.hasOwnProperty(textPropName)) {
        labelOptSingle[textPropName] = textStyle[textPropName];
      }
    }
  }
}
function compatEC3CommonStyles(opt) {
  if (opt) {
    removeEC3NormalStatus(opt);
    compatTextStyle(opt, "label");
    opt.emphasis && compatTextStyle(opt.emphasis, "label");
  }
}
function processSeries(seriesOpt) {
  if (!isObject2(seriesOpt)) {
    return;
  }
  compatEC2ItemStyle(seriesOpt);
  removeEC3NormalStatus(seriesOpt);
  compatTextStyle(seriesOpt, "label");
  compatTextStyle(seriesOpt, "upperLabel");
  compatTextStyle(seriesOpt, "edgeLabel");
  if (seriesOpt.emphasis) {
    compatTextStyle(seriesOpt.emphasis, "label");
    compatTextStyle(seriesOpt.emphasis, "upperLabel");
    compatTextStyle(seriesOpt.emphasis, "edgeLabel");
  }
  let markPoint = seriesOpt.markPoint;
  if (markPoint) {
    compatEC2ItemStyle(markPoint);
    compatEC3CommonStyles(markPoint);
  }
  let markLine = seriesOpt.markLine;
  if (markLine) {
    compatEC2ItemStyle(markLine);
    compatEC3CommonStyles(markLine);
  }
  const markArea = seriesOpt.markArea;
  if (markArea) {
    compatEC3CommonStyles(markArea);
  }
  let data = seriesOpt.data;
  if (seriesOpt.type === "graph") {
    data = data || seriesOpt.nodes;
    const edgeData = seriesOpt.links || seriesOpt.edges;
    if (edgeData && !isTypedArray(edgeData)) {
      for (let i = 0; i < edgeData.length; i++) {
        compatEC3CommonStyles(edgeData[i]);
      }
    }
    each(seriesOpt.categories, function(opt) {
      removeEC3NormalStatus(opt);
    });
  }
  if (data && !isTypedArray(data)) {
    for (let i = 0; i < data.length; i++) {
      compatEC3CommonStyles(data[i]);
    }
  }
  markPoint = seriesOpt.markPoint;
  if (markPoint && markPoint.data) {
    const mpData = markPoint.data;
    for (let i = 0; i < mpData.length; i++) {
      compatEC3CommonStyles(mpData[i]);
    }
  }
  markLine = seriesOpt.markLine;
  if (markLine && markLine.data) {
    const mlData = markLine.data;
    for (let i = 0; i < mlData.length; i++) {
      if (isArray(mlData[i])) {
        compatEC3CommonStyles(mlData[i][0]);
        compatEC3CommonStyles(mlData[i][1]);
      } else {
        compatEC3CommonStyles(mlData[i]);
      }
    }
  }
  if (seriesOpt.type === "gauge") {
    compatTextStyle(seriesOpt, "axisLabel");
    compatTextStyle(seriesOpt, "title");
    compatTextStyle(seriesOpt, "detail");
  } else if (seriesOpt.type === "treemap") {
    convertNormalEmphasis(seriesOpt.breadcrumb, "itemStyle");
    each(seriesOpt.levels, function(opt) {
      removeEC3NormalStatus(opt);
    });
  } else if (seriesOpt.type === "tree") {
    removeEC3NormalStatus(seriesOpt.leaves);
  }
}
function toArr(o) {
  return isArray(o) ? o : o ? [o] : [];
}
function toObj(o) {
  return (isArray(o) ? o[0] : o) || {};
}
function globalCompatStyle(option, isTheme) {
  each3(toArr(option.series), function(seriesOpt) {
    isObject2(seriesOpt) && processSeries(seriesOpt);
  });
  const axes = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  isTheme && axes.push("valueAxis", "categoryAxis", "logAxis", "timeAxis");
  each3(axes, function(axisName) {
    each3(toArr(option[axisName]), function(axisOpt) {
      if (axisOpt) {
        compatTextStyle(axisOpt, "axisLabel");
        compatTextStyle(axisOpt.axisPointer, "label");
      }
    });
  });
  each3(toArr(option.parallel), function(parallelOpt) {
    const parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
    compatTextStyle(parallelAxisDefault, "axisLabel");
    compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, "label");
  });
  each3(toArr(option.calendar), function(calendarOpt) {
    convertNormalEmphasis(calendarOpt, "itemStyle");
    compatTextStyle(calendarOpt, "dayLabel");
    compatTextStyle(calendarOpt, "monthLabel");
    compatTextStyle(calendarOpt, "yearLabel");
  });
  each3(toArr(option.radar), function(radarOpt) {
    compatTextStyle(radarOpt, "name");
    if (radarOpt.name && radarOpt.axisName == null) {
      radarOpt.axisName = radarOpt.name;
      delete radarOpt.name;
      if (true) {
        deprecateLog("name property in radar component has been changed to axisName");
      }
    }
    if (radarOpt.nameGap != null && radarOpt.axisNameGap == null) {
      radarOpt.axisNameGap = radarOpt.nameGap;
      delete radarOpt.nameGap;
      if (true) {
        deprecateLog("nameGap property in radar component has been changed to axisNameGap");
      }
    }
    if (true) {
      each3(radarOpt.indicator, function(indicatorOpt) {
        if (indicatorOpt.text) {
          deprecateReplaceLog("text", "name", "radar.indicator");
        }
      });
    }
  });
  each3(toArr(option.geo), function(geoOpt) {
    if (isObject2(geoOpt)) {
      compatEC3CommonStyles(geoOpt);
      each3(toArr(geoOpt.regions), function(regionObj) {
        compatEC3CommonStyles(regionObj);
      });
    }
  });
  each3(toArr(option.timeline), function(timelineOpt) {
    compatEC3CommonStyles(timelineOpt);
    convertNormalEmphasis(timelineOpt, "label");
    convertNormalEmphasis(timelineOpt, "itemStyle");
    convertNormalEmphasis(timelineOpt, "controlStyle", true);
    const data = timelineOpt.data;
    isArray(data) && each(data, function(item) {
      if (isObject(item)) {
        convertNormalEmphasis(item, "label");
        convertNormalEmphasis(item, "itemStyle");
      }
    });
  });
  each3(toArr(option.toolbox), function(toolboxOpt) {
    convertNormalEmphasis(toolboxOpt, "iconStyle");
    each3(toolboxOpt.feature, function(featureOpt) {
      convertNormalEmphasis(featureOpt, "iconStyle");
    });
  });
  compatTextStyle(toObj(option.axisPointer), "label");
  compatTextStyle(toObj(option.tooltip).axisPointer, "label");
}

// src/preprocessor/backwardCompat.ts
function get(opt, path) {
  const pathArr = path.split(",");
  let obj = opt;
  for (let i = 0; i < pathArr.length; i++) {
    obj = obj && obj[pathArr[i]];
    if (obj == null) {
      break;
    }
  }
  return obj;
}
function set2(opt, path, val, overwrite) {
  const pathArr = path.split(",");
  let obj = opt;
  let key;
  let i = 0;
  for (; i < pathArr.length - 1; i++) {
    key = pathArr[i];
    if (obj[key] == null) {
      obj[key] = {};
    }
    obj = obj[key];
  }
  if (overwrite || obj[pathArr[i]] == null) {
    obj[pathArr[i]] = val;
  }
}
function compatLayoutProperties(option) {
  option && each(LAYOUT_PROPERTIES, function(prop) {
    if (prop[0] in option && !(prop[1] in option)) {
      option[prop[1]] = option[prop[0]];
    }
  });
}
var LAYOUT_PROPERTIES = [
  ["x", "left"],
  ["y", "top"],
  ["x2", "right"],
  ["y2", "bottom"]
];
var COMPATITABLE_COMPONENTS = [
  "grid",
  "geo",
  "parallel",
  "legend",
  "toolbox",
  "title",
  "visualMap",
  "dataZoom",
  "timeline"
];
var BAR_ITEM_STYLE_MAP = [
  ["borderRadius", "barBorderRadius"],
  ["borderColor", "barBorderColor"],
  ["borderWidth", "barBorderWidth"]
];
function compatBarItemStyle(option) {
  const itemStyle = option && option.itemStyle;
  if (itemStyle) {
    for (let i = 0; i < BAR_ITEM_STYLE_MAP.length; i++) {
      const oldName = BAR_ITEM_STYLE_MAP[i][1];
      const newName = BAR_ITEM_STYLE_MAP[i][0];
      if (itemStyle[oldName] != null) {
        itemStyle[newName] = itemStyle[oldName];
        if (true) {
          deprecateReplaceLog(oldName, newName);
        }
      }
    }
  }
}
function compatPieLabel(option) {
  if (!option) {
    return;
  }
  if (option.alignTo === "edge" && option.margin != null && option.edgeDistance == null) {
    if (true) {
      deprecateReplaceLog("label.margin", "label.edgeDistance", "pie");
    }
    option.edgeDistance = option.margin;
  }
}
function compatSunburstState(option) {
  if (!option) {
    return;
  }
  if (option.downplay && !option.blur) {
    option.blur = option.downplay;
    if (true) {
      deprecateReplaceLog("downplay", "blur", "sunburst");
    }
  }
}
function compatGraphFocus(option) {
  if (!option) {
    return;
  }
  if (option.focusNodeAdjacency != null) {
    option.emphasis = option.emphasis || {};
    if (option.emphasis.focus == null) {
      if (true) {
        deprecateReplaceLog("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey");
      }
      option.emphasis.focus = "adjacency";
    }
  }
}
function traverseTree(data, cb) {
  if (data) {
    for (let i = 0; i < data.length; i++) {
      cb(data[i]);
      data[i] && traverseTree(data[i].children, cb);
    }
  }
}
function globalBackwardCompat(option, isTheme) {
  globalCompatStyle(option, isTheme);
  option.series = normalizeToArray(option.series);
  each(option.series, function(seriesOpt) {
    if (!isObject(seriesOpt)) {
      return;
    }
    const seriesType2 = seriesOpt.type;
    if (seriesType2 === "line") {
      if (seriesOpt.clipOverflow != null) {
        seriesOpt.clip = seriesOpt.clipOverflow;
        if (true) {
          deprecateReplaceLog("clipOverflow", "clip", "line");
        }
      }
    } else if (seriesType2 === "pie" || seriesType2 === "gauge") {
      if (seriesOpt.clockWise != null) {
        seriesOpt.clockwise = seriesOpt.clockWise;
        if (true) {
          deprecateReplaceLog("clockWise", "clockwise");
        }
      }
      compatPieLabel(seriesOpt.label);
      const data = seriesOpt.data;
      if (data && !isTypedArray(data)) {
        for (let i = 0; i < data.length; i++) {
          compatPieLabel(data[i]);
        }
      }
      if (seriesOpt.hoverOffset != null) {
        seriesOpt.emphasis = seriesOpt.emphasis || {};
        if (seriesOpt.emphasis.scaleSize = null) {
          if (true) {
            deprecateReplaceLog("hoverOffset", "emphasis.scaleSize");
          }
          seriesOpt.emphasis.scaleSize = seriesOpt.hoverOffset;
        }
      }
    } else if (seriesType2 === "gauge") {
      const pointerColor = get(seriesOpt, "pointer.color");
      pointerColor != null && set2(seriesOpt, "itemStyle.color", pointerColor);
    } else if (seriesType2 === "bar") {
      compatBarItemStyle(seriesOpt);
      compatBarItemStyle(seriesOpt.backgroundStyle);
      compatBarItemStyle(seriesOpt.emphasis);
      const data = seriesOpt.data;
      if (data && !isTypedArray(data)) {
        for (let i = 0; i < data.length; i++) {
          if (typeof data[i] === "object") {
            compatBarItemStyle(data[i]);
            compatBarItemStyle(data[i] && data[i].emphasis);
          }
        }
      }
    } else if (seriesType2 === "sunburst") {
      const highlightPolicy = seriesOpt.highlightPolicy;
      if (highlightPolicy) {
        seriesOpt.emphasis = seriesOpt.emphasis || {};
        if (!seriesOpt.emphasis.focus) {
          seriesOpt.emphasis.focus = highlightPolicy;
          if (true) {
            deprecateReplaceLog("highlightPolicy", "emphasis.focus", "sunburst");
          }
        }
      }
      compatSunburstState(seriesOpt);
      traverseTree(seriesOpt.data, compatSunburstState);
    } else if (seriesType2 === "graph" || seriesType2 === "sankey") {
      compatGraphFocus(seriesOpt);
    } else if (seriesType2 === "map") {
      if (seriesOpt.mapType && !seriesOpt.map) {
        if (true) {
          deprecateReplaceLog("mapType", "map", "map");
        }
        seriesOpt.map = seriesOpt.mapType;
      }
      if (seriesOpt.mapLocation) {
        if (true) {
          deprecateLog("`mapLocation` is not used anymore.");
        }
        defaults(seriesOpt, seriesOpt.mapLocation);
      }
    }
    if (seriesOpt.hoverAnimation != null) {
      seriesOpt.emphasis = seriesOpt.emphasis || {};
      if (seriesOpt.emphasis && seriesOpt.emphasis.scale == null) {
        if (true) {
          deprecateReplaceLog("hoverAnimation", "emphasis.scale");
        }
        seriesOpt.emphasis.scale = seriesOpt.hoverAnimation;
      }
    }
    compatLayoutProperties(seriesOpt);
  });
  if (option.dataRange) {
    option.visualMap = option.dataRange;
  }
  each(COMPATITABLE_COMPONENTS, function(componentName) {
    let options = option[componentName];
    if (options) {
      if (!isArray(options)) {
        options = [options];
      }
      each(options, function(option2) {
        compatLayoutProperties(option2);
      });
    }
  });
}

// src/processor/dataStack.ts
function dataStack(ecModel) {
  const stackInfoMap = createHashMap();
  ecModel.eachSeries(function(seriesModel) {
    const stack = seriesModel.get("stack");
    if (stack) {
      const stackInfoList = stackInfoMap.get(stack) || stackInfoMap.set(stack, []);
      const data = seriesModel.getData();
      const stackInfo = {
        stackResultDimension: data.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: data.getCalculationInfo("stackedOverDimension"),
        stackedDimension: data.getCalculationInfo("stackedDimension"),
        stackedByDimension: data.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: data.getCalculationInfo("isStackedByIndex"),
        data,
        seriesModel
      };
      if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) {
        return;
      }
      stackInfoList.push(stackInfo);
    }
  });
  stackInfoMap.each(function(stackInfoList) {
    if (stackInfoList.length === 0) {
      return;
    }
    const firstSeries = stackInfoList[0].seriesModel;
    const stackOrder = firstSeries.get("stackOrder") || "seriesAsc";
    if (stackOrder === "seriesDesc") {
      stackInfoList.reverse();
    }
    each(stackInfoList, function(stackInfo, index) {
      stackInfo.data.setCalculationInfo("stackedOnSeries", index > 0 ? stackInfoList[index - 1].seriesModel : null);
    });
    calculateStack(stackInfoList);
  });
}
function calculateStack(stackInfoList) {
  each(stackInfoList, function(targetStackInfo, idxInStack) {
    const resultVal = [];
    const resultNaN = [NaN, NaN];
    const dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension];
    const targetData = targetStackInfo.data;
    const isStackedByIndex = targetStackInfo.isStackedByIndex;
    const stackStrategy = targetStackInfo.seriesModel.get("stackStrategy") || "samesign";
    targetData.modify(dims, function(v0, v12, dataIndex) {
      let sum2 = targetData.get(targetStackInfo.stackedDimension, dataIndex);
      if (isNaN(sum2)) {
        return resultNaN;
      }
      let byValue;
      let stackedDataRawIndex;
      if (isStackedByIndex) {
        stackedDataRawIndex = targetData.getRawIndex(dataIndex);
      } else {
        byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);
      }
      let stackedOver = NaN;
      for (let j = idxInStack - 1; j >= 0; j--) {
        const stackInfo = stackInfoList[j];
        if (!isStackedByIndex) {
          stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue);
        }
        if (stackedDataRawIndex >= 0) {
          const val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex);
          if (stackStrategy === "all" || stackStrategy === "positive" && val > 0 || stackStrategy === "negative" && val < 0 || stackStrategy === "samesign" && sum2 >= 0 && val > 0 || stackStrategy === "samesign" && sum2 <= 0 && val < 0) {
            sum2 = addSafe(sum2, val);
            stackedOver = val;
            break;
          }
        }
      }
      resultVal[0] = sum2;
      resultVal[1] = stackedOver;
      return resultVal;
    });
  });
}

// src/data/Source.ts
var SourceImpl = class {
  constructor(fields) {
    this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []);
    this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN;
    this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN;
    this.startIndex = fields.startIndex || 0;
    this.dimensionsDetectedCount = fields.dimensionsDetectedCount;
    this.metaRawOption = fields.metaRawOption;
    const dimensionsDefine = this.dimensionsDefine = fields.dimensionsDefine;
    if (dimensionsDefine) {
      for (let i = 0; i < dimensionsDefine.length; i++) {
        const dim = dimensionsDefine[i];
        if (dim.type == null) {
          if (guessOrdinal(this, i) === BE_ORDINAL.Must) {
            dim.type = "ordinal";
          }
        }
      }
    }
  }
};
function isSourceInstance(val) {
  return val instanceof SourceImpl;
}
function createSource(sourceData, thisMetaRawOption, sourceFormat) {
  sourceFormat = sourceFormat || detectSourceFormat(sourceData);
  const seriesLayoutBy = thisMetaRawOption.seriesLayoutBy;
  const determined = determineSourceDimensions(sourceData, sourceFormat, seriesLayoutBy, thisMetaRawOption.sourceHeader, thisMetaRawOption.dimensions);
  const source = new SourceImpl({
    data: sourceData,
    sourceFormat,
    seriesLayoutBy,
    dimensionsDefine: determined.dimensionsDefine,
    startIndex: determined.startIndex,
    dimensionsDetectedCount: determined.dimensionsDetectedCount,
    metaRawOption: clone(thisMetaRawOption)
  });
  return source;
}
function createSourceFromSeriesDataOption(data) {
  return new SourceImpl({
    data,
    sourceFormat: isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL
  });
}
function cloneSourceShallow(source) {
  return new SourceImpl({
    data: source.data,
    sourceFormat: source.sourceFormat,
    seriesLayoutBy: source.seriesLayoutBy,
    dimensionsDefine: clone(source.dimensionsDefine),
    startIndex: source.startIndex,
    dimensionsDetectedCount: source.dimensionsDetectedCount
  });
}
function detectSourceFormat(data) {
  let sourceFormat = SOURCE_FORMAT_UNKNOWN;
  if (isTypedArray(data)) {
    sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;
  } else if (isArray(data)) {
    if (data.length === 0) {
      sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
    }
    for (let i = 0, len2 = data.length; i < len2; i++) {
      const item = data[i];
      if (item == null) {
        continue;
      } else if (isArray(item) || isTypedArray(item)) {
        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
        break;
      } else if (isObject(item)) {
        sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;
        break;
      }
    }
  } else if (isObject(data)) {
    for (const key in data) {
      if (hasOwn(data, key) && isArrayLike(data[key])) {
        sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;
        break;
      }
    }
  }
  return sourceFormat;
}
function determineSourceDimensions(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {
  let dimensionsDetectedCount;
  let startIndex;
  if (!data) {
    return {
      dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
      startIndex,
      dimensionsDetectedCount
    };
  }
  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    const dataArrayRows = data;
    if (sourceHeader === "auto" || sourceHeader == null) {
      arrayRowsTravelFirst(function(val) {
        if (val != null && val !== "-") {
          if (isString(val)) {
            startIndex == null && (startIndex = 1);
          } else {
            startIndex = 0;
          }
        }
      }, seriesLayoutBy, dataArrayRows, 10);
    } else {
      startIndex = isNumber(sourceHeader) ? sourceHeader : sourceHeader ? 1 : 0;
    }
    if (!dimensionsDefine && startIndex === 1) {
      dimensionsDefine = [];
      arrayRowsTravelFirst(function(val, index) {
        dimensionsDefine[index] = val != null ? val + "" : "";
      }, seriesLayoutBy, dataArrayRows, Infinity);
    }
    dimensionsDetectedCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? dataArrayRows.length : dataArrayRows[0] ? dataArrayRows[0].length : null;
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    if (!dimensionsDefine) {
      dimensionsDefine = objectRowsCollectDimensions(data);
    }
  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    if (!dimensionsDefine) {
      dimensionsDefine = [];
      each(data, function(colArr, key) {
        dimensionsDefine.push(key);
      });
    }
  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    const value0 = getDataItemValue(data[0]);
    dimensionsDetectedCount = isArray(value0) && value0.length || 1;
  } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
    if (true) {
      assert(!!dimensionsDefine, "dimensions must be given if data is TypedArray.");
    }
  }
  return {
    startIndex,
    dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
    dimensionsDetectedCount
  };
}
function objectRowsCollectDimensions(data) {
  let firstIndex = 0;
  let obj;
  while (firstIndex < data.length && !(obj = data[firstIndex++])) {
  }
  if (obj) {
    return keys(obj);
  }
}
function normalizeDimensionsOption(dimensionsDefine) {
  if (!dimensionsDefine) {
    return;
  }
  const nameMap = createHashMap();
  return map(dimensionsDefine, function(rawItem, index) {
    rawItem = isObject(rawItem) ? rawItem : {name: rawItem};
    const item = {
      name: rawItem.name,
      displayName: rawItem.displayName,
      type: rawItem.type
    };
    if (item.name == null) {
      return item;
    }
    item.name += "";
    if (item.displayName == null) {
      item.displayName = item.name;
    }
    const exist = nameMap.get(item.name);
    if (!exist) {
      nameMap.set(item.name, {count: 1});
    } else {
      item.name += "-" + exist.count++;
    }
    return item;
  });
}
function arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {
  if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
    for (let i = 0; i < data.length && i < maxLoop; i++) {
      cb(data[i] ? data[i][0] : null, i);
    }
  } else {
    const value0 = data[0] || [];
    for (let i = 0; i < value0.length && i < maxLoop; i++) {
      cb(value0[i], i);
    }
  }
}
function shouldRetrieveDataByName(source) {
  const sourceFormat = source.sourceFormat;
  return sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS;
}

// src/data/helper/dataProvider.ts
var providerMethods;
var mountMethods;
var DefaultDataProvider2 = class {
  constructor(sourceParam, dimSize) {
    const source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam;
    this._source = source;
    const data = this._data = source.data;
    const sourceFormat = source.sourceFormat;
    const seriesLayoutBy = source.seriesLayoutBy;
    if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
      if (true) {
        if (dimSize == null) {
          throw new Error("Typed array data must specify dimension size");
        }
      }
      this._offset = 0;
      this._dimSize = dimSize;
      this._data = data;
    }
    if (true) {
      const validator = rawSourceDataValidatorMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
      validator && validator(data, source.dimensionsDefine);
    }
    mountMethods(this, data, source);
  }
  getSource() {
    return this._source;
  }
  count() {
    return 0;
  }
  getItem(idx, out2) {
    return;
  }
  appendData(newData) {
  }
  clean() {
  }
};
var DefaultDataProvider = DefaultDataProvider2;
DefaultDataProvider.protoInitialize = function() {
  const proto = DefaultDataProvider2.prototype;
  proto.pure = false;
  proto.persistent = true;
}();
DefaultDataProvider.internalField = function() {
  mountMethods = function(provider, data, source) {
    const sourceFormat = source.sourceFormat;
    const seriesLayoutBy = source.seriesLayoutBy;
    const startIndex = source.startIndex;
    const dimsDef = source.dimensionsDefine;
    const methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];
    if (true) {
      assert(methods, "Invalide sourceFormat: " + sourceFormat);
    }
    extend(provider, methods);
    if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
      provider.getItem = getItemForTypedArray;
      provider.count = countForTypedArray;
      provider.fillStorage = fillStorageForTypedArray;
    } else {
      const rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);
      provider.getItem = bind(rawItemGetter, null, data, startIndex, dimsDef);
      const rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);
      provider.count = bind(rawCounter, null, data, startIndex, dimsDef);
    }
  };
  const getItemForTypedArray = function(idx, out2) {
    idx = idx - this._offset;
    out2 = out2 || [];
    const data = this._data;
    const dimSize = this._dimSize;
    const offset = dimSize * idx;
    for (let i = 0; i < dimSize; i++) {
      out2[i] = data[offset + i];
    }
    return out2;
  };
  const fillStorageForTypedArray = function(start2, end2, storage2, extent) {
    const data = this._data;
    const dimSize = this._dimSize;
    for (let dim = 0; dim < dimSize; dim++) {
      const dimExtent = extent[dim];
      let min3 = dimExtent[0] == null ? Infinity : dimExtent[0];
      let max3 = dimExtent[1] == null ? -Infinity : dimExtent[1];
      const count2 = end2 - start2;
      const arr = storage2[dim];
      for (let i = 0; i < count2; i++) {
        const val = data[i * dimSize + dim];
        arr[start2 + i] = val;
        val < min3 && (min3 = val);
        val > max3 && (max3 = val);
      }
      dimExtent[0] = min3;
      dimExtent[1] = max3;
    }
  };
  const countForTypedArray = function() {
    return this._data ? this._data.length / this._dimSize : 0;
  };
  providerMethods = {
    [SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN]: {
      pure: true,
      appendData: appendDataSimply
    },
    [SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW]: {
      pure: true,
      appendData: function() {
        throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
      }
    },
    [SOURCE_FORMAT_OBJECT_ROWS]: {
      pure: true,
      appendData: appendDataSimply
    },
    [SOURCE_FORMAT_KEYED_COLUMNS]: {
      pure: true,
      appendData: function(newData) {
        const data = this._data;
        each(newData, function(newCol, key) {
          const oldCol = data[key] || (data[key] = []);
          for (let i = 0; i < (newCol || []).length; i++) {
            oldCol.push(newCol[i]);
          }
        });
      }
    },
    [SOURCE_FORMAT_ORIGINAL]: {
      appendData: appendDataSimply
    },
    [SOURCE_FORMAT_TYPED_ARRAY]: {
      persistent: false,
      pure: true,
      appendData: function(newData) {
        if (true) {
          assert(isTypedArray(newData), "Added data must be TypedArray if data in initialization is TypedArray");
        }
        this._data = newData;
      },
      clean: function() {
        this._offset += this.count();
        this._data = null;
      }
    }
  };
  function appendDataSimply(newData) {
    for (let i = 0; i < newData.length; i++) {
      this._data.push(newData[i]);
    }
  }
}();
var validateSimply = function(rawData) {
  if (!isArray(rawData)) {
    error("series.data or dataset.source must be an array.");
  }
};
var rawSourceDataValidatorMap = {
  [SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN]: validateSimply,
  [SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW]: validateSimply,
  [SOURCE_FORMAT_OBJECT_ROWS]: validateSimply,
  [SOURCE_FORMAT_KEYED_COLUMNS]: function(rawData, dimsDef) {
    for (let i = 0; i < dimsDef.length; i++) {
      const dimName = dimsDef[i].name;
      if (dimName == null) {
        error("dimension name must not be null/undefined.");
      }
    }
  },
  [SOURCE_FORMAT_ORIGINAL]: validateSimply
};
var getItemSimply = function(rawData, startIndex, dimsDef, idx) {
  return rawData[idx];
};
var rawSourceItemGetterMap = {
  [SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN]: function(rawData, startIndex, dimsDef, idx) {
    return rawData[idx + startIndex];
  },
  [SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW]: function(rawData, startIndex, dimsDef, idx, out2) {
    idx += startIndex;
    const item = out2 || [];
    const data = rawData;
    for (let i = 0; i < data.length; i++) {
      const row = data[i];
      item[i] = row ? row[idx] : null;
    }
    return item;
  },
  [SOURCE_FORMAT_OBJECT_ROWS]: getItemSimply,
  [SOURCE_FORMAT_KEYED_COLUMNS]: function(rawData, startIndex, dimsDef, idx, out2) {
    const item = out2 || [];
    for (let i = 0; i < dimsDef.length; i++) {
      const dimName = dimsDef[i].name;
      const col = dimName != null ? rawData[dimName] : null;
      item[i] = col ? col[idx] : null;
    }
    return item;
  },
  [SOURCE_FORMAT_ORIGINAL]: getItemSimply
};
function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {
  const method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
  if (true) {
    assert(method, 'Do not support get item on "' + sourceFormat + '", "' + seriesLayoutBy + '".');
  }
  return method;
}
var countSimply = function(rawData, startIndex, dimsDef) {
  return rawData.length;
};
var rawSourceDataCounterMap = {
  [SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN]: function(rawData, startIndex, dimsDef) {
    return Math.max(0, rawData.length - startIndex);
  },
  [SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW]: function(rawData, startIndex, dimsDef) {
    const row = rawData[0];
    return row ? Math.max(0, row.length - startIndex) : 0;
  },
  [SOURCE_FORMAT_OBJECT_ROWS]: countSimply,
  [SOURCE_FORMAT_KEYED_COLUMNS]: function(rawData, startIndex, dimsDef) {
    const dimName = dimsDef[0].name;
    const col = dimName != null ? rawData[dimName] : null;
    return col ? col.length : 0;
  },
  [SOURCE_FORMAT_ORIGINAL]: countSimply
};
function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {
  const method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
  if (true) {
    assert(method, 'Do not support count on "' + sourceFormat + '", "' + seriesLayoutBy + '".');
  }
  return method;
}
var getRawValueSimply = function(dataItem, dimIndex, property) {
  return dataItem[dimIndex];
};
var rawSourceValueGetterMap = {
  [SOURCE_FORMAT_ARRAY_ROWS]: getRawValueSimply,
  [SOURCE_FORMAT_OBJECT_ROWS]: function(dataItem, dimIndex, property) {
    return dataItem[property];
  },
  [SOURCE_FORMAT_KEYED_COLUMNS]: getRawValueSimply,
  [SOURCE_FORMAT_ORIGINAL]: function(dataItem, dimIndex, property) {
    const value = getDataItemValue(dataItem);
    return !(value instanceof Array) ? value : value[dimIndex];
  },
  [SOURCE_FORMAT_TYPED_ARRAY]: getRawValueSimply
};
function getRawSourceValueGetter(sourceFormat) {
  const method = rawSourceValueGetterMap[sourceFormat];
  if (true) {
    assert(method, 'Do not support get value on "' + sourceFormat + '".');
  }
  return method;
}
function getMethodMapKey(sourceFormat, seriesLayoutBy) {
  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + "_" + seriesLayoutBy : sourceFormat;
}
function retrieveRawValue(data, dataIndex, dim) {
  if (!data) {
    return;
  }
  const dataItem = data.getRawDataItem(dataIndex);
  if (dataItem == null) {
    return;
  }
  const store = data.getStore();
  const sourceFormat = store.getSource().sourceFormat;
  if (dim != null) {
    const dimIndex = data.getDimensionIndex(dim);
    const property = store.getDimensionProperty(dimIndex);
    return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property);
  } else {
    let result = dataItem;
    if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
      result = getDataItemValue(dataItem);
    }
    return result;
  }
}

// src/model/mixin/dataFormat.ts
var DIMENSION_LABEL_REG = /\{@(.+?)\}/g;
var DataFormatMixin = class {
  getDataParams(dataIndex, dataType) {
    const data = this.getData(dataType);
    const rawValue = this.getRawValue(dataIndex, dataType);
    const rawDataIndex = data.getRawIndex(dataIndex);
    const name = data.getName(dataIndex);
    const itemOpt = data.getRawDataItem(dataIndex);
    const style = data.getItemVisual(dataIndex, "style");
    const color4 = style && style[data.getItemVisual(dataIndex, "drawType") || "fill"];
    const borderColor = style && style.stroke;
    const mainType = this.mainType;
    const isSeries2 = mainType === "series";
    const userOutput = data.userOutput && data.userOutput.get();
    return {
      componentType: mainType,
      componentSubType: this.subType,
      componentIndex: this.componentIndex,
      seriesType: isSeries2 ? this.subType : null,
      seriesIndex: this.seriesIndex,
      seriesId: isSeries2 ? this.id : null,
      seriesName: isSeries2 ? this.name : null,
      name,
      dataIndex: rawDataIndex,
      data: itemOpt,
      dataType,
      value: rawValue,
      color: color4,
      borderColor,
      dimensionNames: userOutput ? userOutput.fullDimensions : null,
      encode: userOutput ? userOutput.encode : null,
      $vars: ["seriesName", "name", "value"]
    };
  }
  getFormattedLabel(dataIndex, status, dataType, labelDimIndex, formatter, extendParams) {
    status = status || "normal";
    const data = this.getData(dataType);
    const params = this.getDataParams(dataIndex, dataType);
    if (extendParams) {
      params.value = extendParams.interpolatedValue;
    }
    if (labelDimIndex != null && isArray(params.value)) {
      params.value = params.value[labelDimIndex];
    }
    if (!formatter) {
      const itemModel = data.getItemModel(dataIndex);
      formatter = itemModel.get(status === "normal" ? ["label", "formatter"] : [status, "label", "formatter"]);
    }
    if (isFunction(formatter)) {
      params.status = status;
      params.dimensionIndex = labelDimIndex;
      return formatter(params);
    } else if (isString(formatter)) {
      const str = formatTpl(formatter, params);
      return str.replace(DIMENSION_LABEL_REG, function(origin, dimStr) {
        const len2 = dimStr.length;
        let dimLoose = dimStr;
        if (dimLoose.charAt(0) === "[" && dimLoose.charAt(len2 - 1) === "]") {
          dimLoose = +dimLoose.slice(1, len2 - 1);
          if (true) {
            if (isNaN(dimLoose)) {
              error(`Invalide label formatter: @${dimStr}, only support @[0], @[1], @[2], ...`);
            }
          }
        }
        let val = retrieveRawValue(data, dataIndex, dimLoose);
        if (extendParams && isArray(extendParams.interpolatedValue)) {
          const dimIndex = data.getDimensionIndex(dimLoose);
          if (dimIndex >= 0) {
            val = extendParams.interpolatedValue[dimIndex];
          }
        }
        return val != null ? val + "" : "";
      });
    }
  }
  getRawValue(idx, dataType) {
    return retrieveRawValue(this.getData(dataType), idx);
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    return;
  }
};
function normalizeTooltipFormatResult(result) {
  let markupText;
  let markupFragment;
  if (isObject(result)) {
    if (result.type) {
      markupFragment = result;
    } else {
      if (true) {
        console.warn("The return type of `formatTooltip` is not supported: " + makePrintable(result));
      }
    }
  } else {
    markupText = result;
  }
  return {
    text: markupText,
    frag: markupFragment
  };
}

// src/core/task.ts
function createTask(define) {
  return new Task(define);
}
var Task = class {
  constructor(define) {
    define = define || {};
    this._reset = define.reset;
    this._plan = define.plan;
    this._count = define.count;
    this._onDirty = define.onDirty;
    this._dirty = true;
  }
  perform(performArgs) {
    const upTask = this._upstream;
    const skip = performArgs && performArgs.skip;
    if (this._dirty && upTask) {
      const context = this.context;
      context.data = context.outputData = upTask.context.outputData;
    }
    if (this.__pipeline) {
      this.__pipeline.currentTask = this;
    }
    let planResult;
    if (this._plan && !skip) {
      planResult = this._plan(this.context);
    }
    const lastModBy = normalizeModBy(this._modBy);
    const lastModDataCount = this._modDataCount || 0;
    const modBy = normalizeModBy(performArgs && performArgs.modBy);
    const modDataCount = performArgs && performArgs.modDataCount || 0;
    if (lastModBy !== modBy || lastModDataCount !== modDataCount) {
      planResult = "reset";
    }
    function normalizeModBy(val) {
      !(val >= 1) && (val = 1);
      return val;
    }
    let forceFirstProgress;
    if (this._dirty || planResult === "reset") {
      this._dirty = false;
      forceFirstProgress = this._doReset(skip);
    }
    this._modBy = modBy;
    this._modDataCount = modDataCount;
    const step = performArgs && performArgs.step;
    if (upTask) {
      if (true) {
        assert(upTask._outputDueEnd != null);
      }
      this._dueEnd = upTask._outputDueEnd;
    } else {
      if (true) {
        assert(!this._progress || this._count);
      }
      this._dueEnd = this._count ? this._count(this.context) : Infinity;
    }
    if (this._progress) {
      const start2 = this._dueIndex;
      const end2 = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);
      if (!skip && (forceFirstProgress || start2 < end2)) {
        const progress = this._progress;
        if (isArray(progress)) {
          for (let i = 0; i < progress.length; i++) {
            this._doProgress(progress[i], start2, end2, modBy, modDataCount);
          }
        } else {
          this._doProgress(progress, start2, end2, modBy, modDataCount);
        }
      }
      this._dueIndex = end2;
      const outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end2;
      if (true) {
        assert(outputDueEnd >= this._outputDueEnd);
      }
      this._outputDueEnd = outputDueEnd;
    } else {
      this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
    }
    return this.unfinished();
  }
  dirty() {
    this._dirty = true;
    this._onDirty && this._onDirty(this.context);
  }
  _doProgress(progress, start2, end2, modBy, modDataCount) {
    iterator.reset(start2, end2, modBy, modDataCount);
    this._callingProgress = progress;
    this._callingProgress({
      start: start2,
      end: end2,
      count: end2 - start2,
      next: iterator.next
    }, this.context);
  }
  _doReset(skip) {
    this._dueIndex = this._outputDueEnd = this._dueEnd = 0;
    this._settedOutputEnd = null;
    let progress;
    let forceFirstProgress;
    if (!skip && this._reset) {
      progress = this._reset(this.context);
      if (progress && progress.progress) {
        forceFirstProgress = progress.forceFirstProgress;
        progress = progress.progress;
      }
      if (isArray(progress) && !progress.length) {
        progress = null;
      }
    }
    this._progress = progress;
    this._modBy = this._modDataCount = null;
    const downstream = this._downstream;
    downstream && downstream.dirty();
    return forceFirstProgress;
  }
  unfinished() {
    return this._progress && this._dueIndex < this._dueEnd;
  }
  pipe(downTask) {
    if (true) {
      assert(downTask && !downTask._disposed && downTask !== this);
    }
    if (this._downstream !== downTask || this._dirty) {
      this._downstream = downTask;
      downTask._upstream = this;
      downTask.dirty();
    }
  }
  dispose() {
    if (this._disposed) {
      return;
    }
    this._upstream && (this._upstream._downstream = null);
    this._downstream && (this._downstream._upstream = null);
    this._dirty = false;
    this._disposed = true;
  }
  getUpstream() {
    return this._upstream;
  }
  getDownstream() {
    return this._downstream;
  }
  setOutputEnd(end2) {
    this._outputDueEnd = this._settedOutputEnd = end2;
  }
};
var iterator = function() {
  let end2;
  let current;
  let modBy;
  let modDataCount;
  let winCount;
  const it = {
    reset: function(s, e2, sStep, sCount) {
      current = s;
      end2 = e2;
      modBy = sStep;
      modDataCount = sCount;
      winCount = Math.ceil(modDataCount / modBy);
      it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;
    }
  };
  return it;
  function sequentialNext() {
    return current < end2 ? current++ : null;
  }
  function modNext() {
    const dataIndex = current % winCount * modBy + Math.ceil(current / winCount);
    const result = current >= end2 ? null : dataIndex < modDataCount ? dataIndex : current;
    current++;
    return result;
  }
}();

// src/data/helper/dataValueHelper.ts
function parseDataValue(value, opt) {
  const dimType = opt && opt.type;
  if (dimType === "ordinal") {
    return value;
  }
  if (dimType === "time" && !isNumber(value) && value != null && value !== "-") {
    value = +parseDate(value);
  }
  return value == null || value === "" ? NaN : Number(value);
}
var valueParserMap = createHashMap({
  number: function(val) {
    return parseFloat(val);
  },
  time: function(val) {
    return +parseDate(val);
  },
  trim: function(val) {
    return isString(val) ? trim(val) : val;
  }
});
function getRawValueParser(type) {
  return valueParserMap.get(type);
}
var ORDER_COMPARISON_OP_MAP = {
  lt: (lval, rval) => lval < rval,
  lte: (lval, rval) => lval <= rval,
  gt: (lval, rval) => lval > rval,
  gte: (lval, rval) => lval >= rval
};
var FilterOrderComparator = class {
  constructor(op, rval) {
    if (!isNumber(rval)) {
      let errMsg = "";
      if (true) {
        errMsg = 'rvalue of "<", ">", "<=", ">=" can only be number in filter.';
      }
      throwError(errMsg);
    }
    this._opFn = ORDER_COMPARISON_OP_MAP[op];
    this._rvalFloat = numericToNumber(rval);
  }
  evaluate(lval) {
    return isNumber(lval) ? this._opFn(lval, this._rvalFloat) : this._opFn(numericToNumber(lval), this._rvalFloat);
  }
};
var SortOrderComparator = class {
  constructor(order, incomparable) {
    const isDesc = order === "desc";
    this._resultLT = isDesc ? 1 : -1;
    if (incomparable == null) {
      incomparable = isDesc ? "min" : "max";
    }
    this._incomparable = incomparable === "min" ? -Infinity : Infinity;
  }
  evaluate(lval, rval) {
    let lvalFloat = isNumber(lval) ? lval : numericToNumber(lval);
    let rvalFloat = isNumber(rval) ? rval : numericToNumber(rval);
    const lvalNotNumeric = isNaN(lvalFloat);
    const rvalNotNumeric = isNaN(rvalFloat);
    if (lvalNotNumeric) {
      lvalFloat = this._incomparable;
    }
    if (rvalNotNumeric) {
      rvalFloat = this._incomparable;
    }
    if (lvalNotNumeric && rvalNotNumeric) {
      const lvalIsStr = isString(lval);
      const rvalIsStr = isString(rval);
      if (lvalIsStr) {
        lvalFloat = rvalIsStr ? lval : 0;
      }
      if (rvalIsStr) {
        rvalFloat = lvalIsStr ? rval : 0;
      }
    }
    return lvalFloat < rvalFloat ? this._resultLT : lvalFloat > rvalFloat ? -this._resultLT : 0;
  }
};
var FilterEqualityComparator = class {
  constructor(isEq, rval) {
    this._rval = rval;
    this._isEQ = isEq;
    this._rvalTypeof = typeof rval;
    this._rvalFloat = numericToNumber(rval);
  }
  evaluate(lval) {
    let eqResult = lval === this._rval;
    if (!eqResult) {
      const lvalTypeof = typeof lval;
      if (lvalTypeof !== this._rvalTypeof && (lvalTypeof === "number" || this._rvalTypeof === "number")) {
        eqResult = numericToNumber(lval) === this._rvalFloat;
      }
    }
    return this._isEQ ? eqResult : !eqResult;
  }
};
function createFilterComparator(op, rval) {
  return op === "eq" || op === "ne" ? new FilterEqualityComparator(op === "eq", rval) : hasOwn(ORDER_COMPARISON_OP_MAP, op) ? new FilterOrderComparator(op, rval) : null;
}

// src/data/helper/transform.ts
var ExternalSource = class {
  getRawData() {
    throw new Error("not supported");
  }
  getRawDataItem(dataIndex) {
    throw new Error("not supported");
  }
  cloneRawData() {
    return;
  }
  getDimensionInfo(dim) {
    return;
  }
  cloneAllDimensionInfo() {
    return;
  }
  count() {
    return;
  }
  retrieveValue(dataIndex, dimIndex) {
    return;
  }
  retrieveValueFromItem(dataItem, dimIndex) {
    return;
  }
  convertValue(rawVal, dimInfo) {
    return parseDataValue(rawVal, dimInfo);
  }
};
function createExternalSource(internalSource, externalTransform) {
  const extSource = new ExternalSource();
  const data = internalSource.data;
  const sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;
  const sourceHeaderCount = internalSource.startIndex;
  let errMsg = "";
  if (internalSource.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN) {
    if (true) {
      errMsg = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.';
    }
    throwError(errMsg);
  }
  const dimensions = [];
  const dimsByName = {};
  const dimsDef = internalSource.dimensionsDefine;
  if (dimsDef) {
    each(dimsDef, function(dimDef, idx) {
      const name = dimDef.name;
      const dimDefExt = {
        index: idx,
        name,
        displayName: dimDef.displayName
      };
      dimensions.push(dimDefExt);
      if (name != null) {
        let errMsg2 = "";
        if (hasOwn(dimsByName, name)) {
          if (true) {
            errMsg2 = 'dimension name "' + name + '" duplicated.';
          }
          throwError(errMsg2);
        }
        dimsByName[name] = dimDefExt;
      }
    });
  } else {
    for (let i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {
      dimensions.push({index: i});
    }
  }
  const rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
  if (externalTransform.__isBuiltIn) {
    extSource.getRawDataItem = function(dataIndex) {
      return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
    };
    extSource.getRawData = bind(getRawData, null, internalSource);
  }
  extSource.cloneRawData = bind(cloneRawData, null, internalSource);
  const rawCounter = getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
  extSource.count = bind(rawCounter, null, data, sourceHeaderCount, dimensions);
  const rawValueGetter = getRawSourceValueGetter(sourceFormat);
  extSource.retrieveValue = function(dataIndex, dimIndex) {
    const rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
    return retrieveValueFromItem(rawItem, dimIndex);
  };
  const retrieveValueFromItem = extSource.retrieveValueFromItem = function(dataItem, dimIndex) {
    if (dataItem == null) {
      return;
    }
    const dimDef = dimensions[dimIndex];
    if (dimDef) {
      return rawValueGetter(dataItem, dimIndex, dimDef.name);
    }
  };
  extSource.getDimensionInfo = bind(getDimensionInfo, null, dimensions, dimsByName);
  extSource.cloneAllDimensionInfo = bind(cloneAllDimensionInfo, null, dimensions);
  return extSource;
}
function getRawData(upstream) {
  const sourceFormat = upstream.sourceFormat;
  if (!isSupportedSourceFormat(sourceFormat)) {
    let errMsg = "";
    if (true) {
      errMsg = "`getRawData` is not supported in source format " + sourceFormat;
    }
    throwError(errMsg);
  }
  return upstream.data;
}
function cloneRawData(upstream) {
  const sourceFormat = upstream.sourceFormat;
  const data = upstream.data;
  if (!isSupportedSourceFormat(sourceFormat)) {
    let errMsg = "";
    if (true) {
      errMsg = "`cloneRawData` is not supported in source format " + sourceFormat;
    }
    throwError(errMsg);
  }
  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    const result = [];
    for (let i = 0, len2 = data.length; i < len2; i++) {
      result.push(data[i].slice());
    }
    return result;
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    const result = [];
    for (let i = 0, len2 = data.length; i < len2; i++) {
      result.push(extend({}, data[i]));
    }
    return result;
  }
}
function getDimensionInfo(dimensions, dimsByName, dim) {
  if (dim == null) {
    return;
  }
  if (isNumber(dim) || !isNaN(dim) && !hasOwn(dimsByName, dim)) {
    return dimensions[dim];
  } else if (hasOwn(dimsByName, dim)) {
    return dimsByName[dim];
  }
}
function cloneAllDimensionInfo(dimensions) {
  return clone(dimensions);
}
var externalTransformMap = createHashMap();
function registerExternalTransform(externalTransform) {
  externalTransform = clone(externalTransform);
  let type = externalTransform.type;
  let errMsg = "";
  if (!type) {
    if (true) {
      errMsg = "Must have a `type` when `registerTransform`.";
    }
    throwError(errMsg);
  }
  const typeParsed = type.split(":");
  if (typeParsed.length !== 2) {
    if (true) {
      errMsg = 'Name must include namespace like "ns:regression".';
    }
    throwError(errMsg);
  }
  let isBuiltIn = false;
  if (typeParsed[0] === "echarts") {
    type = typeParsed[1];
    isBuiltIn = true;
  }
  externalTransform.__isBuiltIn = isBuiltIn;
  externalTransformMap.set(type, externalTransform);
}
function applyDataTransform(rawTransOption, sourceList, infoForPrint) {
  const pipedTransOption = normalizeToArray(rawTransOption);
  const pipeLen = pipedTransOption.length;
  let errMsg = "";
  if (!pipeLen) {
    if (true) {
      errMsg = "If `transform` declared, it should at least contain one transform.";
    }
    throwError(errMsg);
  }
  for (let i = 0, len2 = pipeLen; i < len2; i++) {
    const transOption = pipedTransOption[i];
    sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i);
    if (i !== len2 - 1) {
      sourceList.length = Math.max(sourceList.length, 1);
    }
  }
  return sourceList;
}
function applySingleDataTransform(transOption, upSourceList, infoForPrint, pipeIndex) {
  let errMsg = "";
  if (!upSourceList.length) {
    if (true) {
      errMsg = "Must have at least one upstream dataset.";
    }
    throwError(errMsg);
  }
  if (!isObject(transOption)) {
    if (true) {
      errMsg = "transform declaration must be an object rather than " + typeof transOption + ".";
    }
    throwError(errMsg);
  }
  const transType = transOption.type;
  const externalTransform = externalTransformMap.get(transType);
  if (!externalTransform) {
    if (true) {
      errMsg = 'Can not find transform on type "' + transType + '".';
    }
    throwError(errMsg);
  }
  const extUpSourceList = map(upSourceList, (upSource) => createExternalSource(upSource, externalTransform));
  const resultList = normalizeToArray(externalTransform.transform({
    upstream: extUpSourceList[0],
    upstreamList: extUpSourceList,
    config: clone(transOption.config)
  }));
  if (true) {
    if (transOption.print) {
      const printStrArr = map(resultList, (extSource) => {
        const pipeIndexStr = pipeIndex != null ? " === pipe index: " + pipeIndex : "";
        return [
          "=== dataset index: " + infoForPrint.datasetIndex + pipeIndexStr + " ===",
          "- transform result data:",
          makePrintable(extSource.data),
          "- transform result dimensions:",
          makePrintable(extSource.dimensions)
        ].join("\n");
      }).join("\n");
      log(printStrArr);
    }
  }
  return map(resultList, function(result, resultIndex) {
    let errMsg2 = "";
    if (!isObject(result)) {
      if (true) {
        errMsg2 = "A transform should not return some empty results.";
      }
      throwError(errMsg2);
    }
    if (!result.data) {
      if (true) {
        errMsg2 = "Transform result data should be not be null or undefined";
      }
      throwError(errMsg2);
    }
    const sourceFormat = detectSourceFormat(result.data);
    if (!isSupportedSourceFormat(sourceFormat)) {
      if (true) {
        errMsg2 = "Transform result data should be array rows or object rows.";
      }
      throwError(errMsg2);
    }
    let resultMetaRawOption;
    const firstUpSource = upSourceList[0];
    if (firstUpSource && resultIndex === 0 && !result.dimensions) {
      const startIndex = firstUpSource.startIndex;
      if (startIndex) {
        result.data = firstUpSource.data.slice(0, startIndex).concat(result.data);
      }
      resultMetaRawOption = {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
        sourceHeader: startIndex,
        dimensions: firstUpSource.metaRawOption.dimensions
      };
    } else {
      resultMetaRawOption = {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
        sourceHeader: 0,
        dimensions: result.dimensions
      };
    }
    return createSource(result.data, resultMetaRawOption, null);
  });
}
function isSupportedSourceFormat(sourceFormat) {
  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS;
}

// src/data/DataStore.ts
var UNDEFINED = "undefined";
var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;
var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;
var CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;
var CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;
var dataCtors = {
  float: CtorFloat64Array,
  int: CtorInt32Array,
  ordinal: Array,
  number: Array,
  time: CtorFloat64Array
};
var defaultDimValueGetters;
function getIndicesCtor(rawCount) {
  return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;
}
function getInitialExtent() {
  return [Infinity, -Infinity];
}
function cloneChunk(originalChunk) {
  const Ctor = originalChunk.constructor;
  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);
}
function prepareStore(store, dimIdx, dimType, end2, append) {
  const DataCtor = dataCtors[dimType || "float"];
  if (append) {
    const oldStore = store[dimIdx];
    const oldLen = oldStore && oldStore.length;
    if (!(oldLen === end2)) {
      const newStore = new DataCtor(end2);
      for (let j = 0; j < oldLen; j++) {
        newStore[j] = oldStore[j];
      }
      store[dimIdx] = newStore;
    }
  } else {
    store[dimIdx] = new DataCtor(end2);
  }
}
var DataStore2 = class {
  constructor() {
    this._chunks = [];
    this._rawExtent = [];
    this._extent = [];
    this._count = 0;
    this._rawCount = 0;
    this._calcDimNameToIdx = createHashMap();
  }
  initData(provider, inputDimensions, dimValueGetter) {
    if (true) {
      assert(isFunction(provider.getItem) && isFunction(provider.count), "Invalid data provider.");
    }
    this._provider = provider;
    this._chunks = [];
    this._indices = null;
    this.getRawIndex = this._getRawIdxIdentity;
    const source = provider.getSource();
    const defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat];
    this._dimValueGetter = dimValueGetter || defaultGetter;
    this._rawExtent = [];
    const willRetrieveDataByName = shouldRetrieveDataByName(source);
    this._dimensions = map(inputDimensions, (dim) => {
      if (true) {
        if (willRetrieveDataByName) {
          assert(dim.property != null);
        }
      }
      return {
        type: dim.type,
        property: dim.property
      };
    });
    this._initDataFromProvider(0, provider.count());
  }
  getProvider() {
    return this._provider;
  }
  getSource() {
    return this._provider.getSource();
  }
  ensureCalculationDimension(dimName, type) {
    const calcDimNameToIdx = this._calcDimNameToIdx;
    const dimensions = this._dimensions;
    let calcDimIdx = calcDimNameToIdx.get(dimName);
    if (calcDimIdx != null) {
      if (dimensions[calcDimIdx].type === type) {
        return calcDimIdx;
      }
    } else {
      calcDimIdx = dimensions.length;
    }
    dimensions[calcDimIdx] = {type};
    calcDimNameToIdx.set(dimName, calcDimIdx);
    this._chunks[calcDimIdx] = new dataCtors[type || "float"](this._rawCount);
    this._rawExtent[calcDimIdx] = getInitialExtent();
    return calcDimIdx;
  }
  collectOrdinalMeta(dimIdx, ordinalMeta) {
    const chunk = this._chunks[dimIdx];
    const dim = this._dimensions[dimIdx];
    const rawExtents = this._rawExtent;
    const offset = dim.ordinalOffset || 0;
    const len2 = chunk.length;
    if (offset === 0) {
      rawExtents[dimIdx] = getInitialExtent();
    }
    const dimRawExtent = rawExtents[dimIdx];
    for (let i = offset; i < len2; i++) {
      const val = chunk[i] = ordinalMeta.parseAndCollect(chunk[i]);
      if (!isNaN(val)) {
        dimRawExtent[0] = Math.min(val, dimRawExtent[0]);
        dimRawExtent[1] = Math.max(val, dimRawExtent[1]);
      }
    }
    dim.ordinalMeta = ordinalMeta;
    dim.ordinalOffset = len2;
    dim.type = "ordinal";
  }
  getOrdinalMeta(dimIdx) {
    const dimInfo = this._dimensions[dimIdx];
    const ordinalMeta = dimInfo.ordinalMeta;
    return ordinalMeta;
  }
  getDimensionProperty(dimIndex) {
    const item = this._dimensions[dimIndex];
    return item && item.property;
  }
  appendData(data) {
    if (true) {
      assert(!this._indices, "appendData can only be called on raw data.");
    }
    const provider = this._provider;
    const start2 = this.count();
    provider.appendData(data);
    let end2 = provider.count();
    if (!provider.persistent) {
      end2 += start2;
    }
    if (start2 < end2) {
      this._initDataFromProvider(start2, end2, true);
    }
    return [start2, end2];
  }
  appendValues(values, minFillLen) {
    const chunks = this._chunks;
    const dimensions = this._dimensions;
    const dimLen = dimensions.length;
    const rawExtent = this._rawExtent;
    const start2 = this.count();
    const end2 = start2 + Math.max(values.length, minFillLen || 0);
    for (let i = 0; i < dimLen; i++) {
      const dim = dimensions[i];
      prepareStore(chunks, i, dim.type, end2, true);
    }
    const emptyDataItem = [];
    for (let idx = start2; idx < end2; idx++) {
      const sourceIdx = idx - start2;
      for (let dimIdx = 0; dimIdx < dimLen; dimIdx++) {
        const dim = dimensions[dimIdx];
        const val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);
        chunks[dimIdx][idx] = val;
        const dimRawExtent = rawExtent[dimIdx];
        val < dimRawExtent[0] && (dimRawExtent[0] = val);
        val > dimRawExtent[1] && (dimRawExtent[1] = val);
      }
    }
    this._rawCount = this._count = end2;
    return {start: start2, end: end2};
  }
  _initDataFromProvider(start2, end2, append) {
    const provider = this._provider;
    const chunks = this._chunks;
    const dimensions = this._dimensions;
    const dimLen = dimensions.length;
    const rawExtent = this._rawExtent;
    const dimNames = map(dimensions, (dim) => dim.property);
    for (let i = 0; i < dimLen; i++) {
      const dim = dimensions[i];
      if (!rawExtent[i]) {
        rawExtent[i] = getInitialExtent();
      }
      prepareStore(chunks, i, dim.type, end2, append);
    }
    if (provider.fillStorage) {
      provider.fillStorage(start2, end2, chunks, rawExtent);
    } else {
      let dataItem = [];
      for (let idx = start2; idx < end2; idx++) {
        dataItem = provider.getItem(idx, dataItem);
        for (let dimIdx = 0; dimIdx < dimLen; dimIdx++) {
          const dimStorage = chunks[dimIdx];
          const val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);
          dimStorage[idx] = val;
          const dimRawExtent = rawExtent[dimIdx];
          val < dimRawExtent[0] && (dimRawExtent[0] = val);
          val > dimRawExtent[1] && (dimRawExtent[1] = val);
        }
      }
    }
    if (!provider.persistent && provider.clean) {
      provider.clean();
    }
    this._rawCount = this._count = end2;
    this._extent = [];
  }
  count() {
    return this._count;
  }
  get(dim, idx) {
    if (!(idx >= 0 && idx < this._count)) {
      return NaN;
    }
    const dimStore = this._chunks[dim];
    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;
  }
  getValues(dimensions, idx) {
    const values = [];
    let dimArr = [];
    if (idx == null) {
      idx = dimensions;
      dimensions = [];
      for (let i = 0; i < this._dimensions.length; i++) {
        dimArr.push(i);
      }
    } else {
      dimArr = dimensions;
    }
    for (let i = 0, len2 = dimArr.length; i < len2; i++) {
      values.push(this.get(dimArr[i], idx));
    }
    return values;
  }
  getByRawIndex(dim, rawIdx) {
    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {
      return NaN;
    }
    const dimStore = this._chunks[dim];
    return dimStore ? dimStore[rawIdx] : NaN;
  }
  getSum(dim) {
    const dimData = this._chunks[dim];
    let sum2 = 0;
    if (dimData) {
      for (let i = 0, len2 = this.count(); i < len2; i++) {
        const value = this.get(dim, i);
        if (!isNaN(value)) {
          sum2 += value;
        }
      }
    }
    return sum2;
  }
  getMedian(dim) {
    const dimDataArray = [];
    this.each([dim], function(val) {
      if (!isNaN(val)) {
        dimDataArray.push(val);
      }
    });
    const sortedDimDataArray = dimDataArray.sort(function(a, b) {
      return a - b;
    });
    const len2 = this.count();
    return len2 === 0 ? 0 : len2 % 2 === 1 ? sortedDimDataArray[(len2 - 1) / 2] : (sortedDimDataArray[len2 / 2] + sortedDimDataArray[len2 / 2 - 1]) / 2;
  }
  indexOfRawIndex(rawIndex) {
    if (rawIndex >= this._rawCount || rawIndex < 0) {
      return -1;
    }
    if (!this._indices) {
      return rawIndex;
    }
    const indices = this._indices;
    const rawDataIndex = indices[rawIndex];
    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {
      return rawIndex;
    }
    let left = 0;
    let right = this._count - 1;
    while (left <= right) {
      const mid = (left + right) / 2 | 0;
      if (indices[mid] < rawIndex) {
        left = mid + 1;
      } else if (indices[mid] > rawIndex) {
        right = mid - 1;
      } else {
        return mid;
      }
    }
    return -1;
  }
  getIndices() {
    let newIndices;
    const indices = this._indices;
    if (indices) {
      const Ctor = indices.constructor;
      const thisCount = this._count;
      if (Ctor === Array) {
        newIndices = new Ctor(thisCount);
        for (let i = 0; i < thisCount; i++) {
          newIndices[i] = indices[i];
        }
      } else {
        newIndices = new Ctor(indices.buffer, 0, thisCount);
      }
    } else {
      const Ctor = getIndicesCtor(this._rawCount);
      newIndices = new Ctor(this.count());
      for (let i = 0; i < newIndices.length; i++) {
        newIndices[i] = i;
      }
    }
    return newIndices;
  }
  filter(dims, cb) {
    if (!this._count) {
      return this;
    }
    const newStore = this.clone();
    const count2 = newStore.count();
    const Ctor = getIndicesCtor(newStore._rawCount);
    const newIndices = new Ctor(count2);
    const value = [];
    const dimSize = dims.length;
    let offset = 0;
    const dim0 = dims[0];
    const chunks = newStore._chunks;
    for (let i = 0; i < count2; i++) {
      let keep;
      const rawIdx = newStore.getRawIndex(i);
      if (dimSize === 0) {
        keep = cb(i);
      } else if (dimSize === 1) {
        const val = chunks[dim0][rawIdx];
        keep = cb(val, i);
      } else {
        let k = 0;
        for (; k < dimSize; k++) {
          value[k] = chunks[dims[k]][rawIdx];
        }
        value[k] = i;
        keep = cb.apply(null, value);
      }
      if (keep) {
        newIndices[offset++] = rawIdx;
      }
    }
    if (offset < count2) {
      newStore._indices = newIndices;
    }
    newStore._count = offset;
    newStore._extent = [];
    newStore._updateGetRawIdx();
    return newStore;
  }
  selectRange(range) {
    const newStore = this.clone();
    const len2 = newStore._count;
    if (!len2) {
      return this;
    }
    const dims = keys(range);
    const dimSize = dims.length;
    if (!dimSize) {
      return this;
    }
    const originalCount = newStore.count();
    const Ctor = getIndicesCtor(newStore._rawCount);
    const newIndices = new Ctor(originalCount);
    let offset = 0;
    const dim0 = dims[0];
    const min3 = range[dim0][0];
    const max3 = range[dim0][1];
    const storeArr = newStore._chunks;
    let quickFinished = false;
    if (!newStore._indices) {
      let idx = 0;
      if (dimSize === 1) {
        const dimStorage = storeArr[dims[0]];
        for (let i = 0; i < len2; i++) {
          const val = dimStorage[i];
          if (val >= min3 && val <= max3 || isNaN(val)) {
            newIndices[offset++] = idx;
          }
          idx++;
        }
        quickFinished = true;
      } else if (dimSize === 2) {
        const dimStorage = storeArr[dims[0]];
        const dimStorage2 = storeArr[dims[1]];
        const min23 = range[dims[1]][0];
        const max23 = range[dims[1]][1];
        for (let i = 0; i < len2; i++) {
          const val = dimStorage[i];
          const val2 = dimStorage2[i];
          if ((val >= min3 && val <= max3 || isNaN(val)) && (val2 >= min23 && val2 <= max23 || isNaN(val2))) {
            newIndices[offset++] = idx;
          }
          idx++;
        }
        quickFinished = true;
      }
    }
    if (!quickFinished) {
      if (dimSize === 1) {
        for (let i = 0; i < originalCount; i++) {
          const rawIndex = newStore.getRawIndex(i);
          const val = storeArr[dims[0]][rawIndex];
          if (val >= min3 && val <= max3 || isNaN(val)) {
            newIndices[offset++] = rawIndex;
          }
        }
      } else {
        for (let i = 0; i < originalCount; i++) {
          let keep = true;
          const rawIndex = newStore.getRawIndex(i);
          for (let k = 0; k < dimSize; k++) {
            const dimk = dims[k];
            const val = storeArr[dimk][rawIndex];
            if (val < range[dimk][0] || val > range[dimk][1]) {
              keep = false;
            }
          }
          if (keep) {
            newIndices[offset++] = newStore.getRawIndex(i);
          }
        }
      }
    }
    if (offset < originalCount) {
      newStore._indices = newIndices;
    }
    newStore._count = offset;
    newStore._extent = [];
    newStore._updateGetRawIdx();
    return newStore;
  }
  map(dims, cb) {
    const target = this.clone(dims);
    this._updateDims(target, dims, cb);
    return target;
  }
  modify(dims, cb) {
    this._updateDims(this, dims, cb);
  }
  _updateDims(target, dims, cb) {
    const targetChunks = target._chunks;
    const tmpRetValue = [];
    const dimSize = dims.length;
    const dataCount = target.count();
    const values = [];
    const rawExtent = target._rawExtent;
    for (let i = 0; i < dims.length; i++) {
      rawExtent[dims[i]] = getInitialExtent();
    }
    for (let dataIndex = 0; dataIndex < dataCount; dataIndex++) {
      const rawIndex = target.getRawIndex(dataIndex);
      for (let k = 0; k < dimSize; k++) {
        values[k] = targetChunks[dims[k]][rawIndex];
      }
      values[dimSize] = dataIndex;
      let retValue = cb && cb.apply(null, values);
      if (retValue != null) {
        if (typeof retValue !== "object") {
          tmpRetValue[0] = retValue;
          retValue = tmpRetValue;
        }
        for (let i = 0; i < retValue.length; i++) {
          const dim = dims[i];
          const val = retValue[i];
          const rawExtentOnDim = rawExtent[dim];
          const dimStore = targetChunks[dim];
          if (dimStore) {
            dimStore[rawIndex] = val;
          }
          if (val < rawExtentOnDim[0]) {
            rawExtentOnDim[0] = val;
          }
          if (val > rawExtentOnDim[1]) {
            rawExtentOnDim[1] = val;
          }
        }
      }
    }
  }
  lttbDownSample(valueDimension, rate) {
    const target = this.clone([valueDimension], true);
    const targetStorage = target._chunks;
    const dimStore = targetStorage[valueDimension];
    const len2 = this.count();
    let sampledIndex = 0;
    const frameSize = Math.floor(1 / rate);
    let currentRawIndex = this.getRawIndex(0);
    let maxArea;
    let area;
    let nextRawIndex;
    const newIndices = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(len2 / frameSize) + 2) * 2, len2));
    newIndices[sampledIndex++] = currentRawIndex;
    for (let i = 1; i < len2 - 1; i += frameSize) {
      const nextFrameStart = Math.min(i + frameSize, len2 - 1);
      const nextFrameEnd = Math.min(i + frameSize * 2, len2);
      const avgX = (nextFrameEnd + nextFrameStart) / 2;
      let avgY = 0;
      for (let idx = nextFrameStart; idx < nextFrameEnd; idx++) {
        const rawIndex = this.getRawIndex(idx);
        const y = dimStore[rawIndex];
        if (isNaN(y)) {
          continue;
        }
        avgY += y;
      }
      avgY /= nextFrameEnd - nextFrameStart;
      const frameStart = i;
      const frameEnd = Math.min(i + frameSize, len2);
      const pointAX = i - 1;
      const pointAY = dimStore[currentRawIndex];
      maxArea = -1;
      nextRawIndex = frameStart;
      let firstNaNIndex = -1;
      let countNaN = 0;
      for (let idx = frameStart; idx < frameEnd; idx++) {
        const rawIndex = this.getRawIndex(idx);
        const y = dimStore[rawIndex];
        if (isNaN(y)) {
          countNaN++;
          if (firstNaNIndex < 0) {
            firstNaNIndex = rawIndex;
          }
          continue;
        }
        area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));
        if (area > maxArea) {
          maxArea = area;
          nextRawIndex = rawIndex;
        }
      }
      if (countNaN > 0 && countNaN < frameEnd - frameStart) {
        newIndices[sampledIndex++] = Math.min(firstNaNIndex, nextRawIndex);
        nextRawIndex = Math.max(firstNaNIndex, nextRawIndex);
      }
      newIndices[sampledIndex++] = nextRawIndex;
      currentRawIndex = nextRawIndex;
    }
    newIndices[sampledIndex++] = this.getRawIndex(len2 - 1);
    target._count = sampledIndex;
    target._indices = newIndices;
    target.getRawIndex = this._getRawIdx;
    return target;
  }
  minmaxDownSample(valueDimension, rate) {
    const target = this.clone([valueDimension], true);
    const targetStorage = target._chunks;
    const frameSize = Math.floor(1 / rate);
    const dimStore = targetStorage[valueDimension];
    const len2 = this.count();
    const newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len2 / frameSize) * 2);
    let offset = 0;
    for (let i = 0; i < len2; i += frameSize) {
      let minIndex = i;
      let minValue = dimStore[this.getRawIndex(minIndex)];
      let maxIndex = i;
      let maxValue = dimStore[this.getRawIndex(maxIndex)];
      let thisFrameSize = frameSize;
      if (i + frameSize > len2) {
        thisFrameSize = len2 - i;
      }
      for (let k = 0; k < thisFrameSize; k++) {
        const rawIndex = this.getRawIndex(i + k);
        const value = dimStore[rawIndex];
        if (value < minValue) {
          minValue = value;
          minIndex = i + k;
        }
        if (value > maxValue) {
          maxValue = value;
          maxIndex = i + k;
        }
      }
      const rawMinIndex = this.getRawIndex(minIndex);
      const rawMaxIndex = this.getRawIndex(maxIndex);
      if (minIndex < maxIndex) {
        newIndices[offset++] = rawMinIndex;
        newIndices[offset++] = rawMaxIndex;
      } else {
        newIndices[offset++] = rawMaxIndex;
        newIndices[offset++] = rawMinIndex;
      }
    }
    target._count = offset;
    target._indices = newIndices;
    target._updateGetRawIdx();
    return target;
  }
  downSample(dimension, rate, sampleValue, sampleIndex) {
    const target = this.clone([dimension], true);
    const targetStorage = target._chunks;
    const frameValues = [];
    let frameSize = Math.floor(1 / rate);
    const dimStore = targetStorage[dimension];
    const len2 = this.count();
    const rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();
    const newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len2 / frameSize));
    let offset = 0;
    for (let i = 0; i < len2; i += frameSize) {
      if (frameSize > len2 - i) {
        frameSize = len2 - i;
        frameValues.length = frameSize;
      }
      for (let k = 0; k < frameSize; k++) {
        const dataIdx = this.getRawIndex(i + k);
        frameValues[k] = dimStore[dataIdx];
      }
      const value = sampleValue(frameValues);
      const sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len2 - 1));
      dimStore[sampleFrameIdx] = value;
      if (value < rawExtentOnDim[0]) {
        rawExtentOnDim[0] = value;
      }
      if (value > rawExtentOnDim[1]) {
        rawExtentOnDim[1] = value;
      }
      newIndices[offset++] = sampleFrameIdx;
    }
    target._count = offset;
    target._indices = newIndices;
    target._updateGetRawIdx();
    return target;
  }
  each(dims, cb) {
    if (!this._count) {
      return;
    }
    const dimSize = dims.length;
    const chunks = this._chunks;
    for (let i = 0, len2 = this.count(); i < len2; i++) {
      const rawIdx = this.getRawIndex(i);
      switch (dimSize) {
        case 0:
          cb(i);
          break;
        case 1:
          cb(chunks[dims[0]][rawIdx], i);
          break;
        case 2:
          cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i);
          break;
        default:
          let k = 0;
          const value = [];
          for (; k < dimSize; k++) {
            value[k] = chunks[dims[k]][rawIdx];
          }
          value[k] = i;
          cb.apply(null, value);
      }
    }
  }
  getDataExtent(dim) {
    const dimData = this._chunks[dim];
    const initialExtent = getInitialExtent();
    if (!dimData) {
      return initialExtent;
    }
    const currEnd = this.count();
    const useRaw = !this._indices;
    let dimExtent;
    if (useRaw) {
      return this._rawExtent[dim].slice();
    }
    dimExtent = this._extent[dim];
    if (dimExtent) {
      return dimExtent.slice();
    }
    dimExtent = initialExtent;
    let min3 = dimExtent[0];
    let max3 = dimExtent[1];
    for (let i = 0; i < currEnd; i++) {
      const rawIdx = this.getRawIndex(i);
      const value = dimData[rawIdx];
      value < min3 && (min3 = value);
      value > max3 && (max3 = value);
    }
    dimExtent = [min3, max3];
    this._extent[dim] = dimExtent;
    return dimExtent;
  }
  getRawDataItem(idx) {
    const rawIdx = this.getRawIndex(idx);
    if (!this._provider.persistent) {
      const val = [];
      const chunks = this._chunks;
      for (let i = 0; i < chunks.length; i++) {
        val.push(chunks[i][rawIdx]);
      }
      return val;
    } else {
      return this._provider.getItem(rawIdx);
    }
  }
  clone(clonedDims, ignoreIndices) {
    const target = new DataStore2();
    const chunks = this._chunks;
    const clonedDimsMap = clonedDims && reduce(clonedDims, (obj, dimIdx) => {
      obj[dimIdx] = true;
      return obj;
    }, {});
    if (clonedDimsMap) {
      for (let i = 0; i < chunks.length; i++) {
        target._chunks[i] = !clonedDimsMap[i] ? chunks[i] : cloneChunk(chunks[i]);
      }
    } else {
      target._chunks = chunks;
    }
    this._copyCommonProps(target);
    if (!ignoreIndices) {
      target._indices = this._cloneIndices();
    }
    target._updateGetRawIdx();
    return target;
  }
  _copyCommonProps(target) {
    target._count = this._count;
    target._rawCount = this._rawCount;
    target._provider = this._provider;
    target._dimensions = this._dimensions;
    target._extent = clone(this._extent);
    target._rawExtent = clone(this._rawExtent);
  }
  _cloneIndices() {
    if (this._indices) {
      const Ctor = this._indices.constructor;
      let indices;
      if (Ctor === Array) {
        const thisCount = this._indices.length;
        indices = new Ctor(thisCount);
        for (let i = 0; i < thisCount; i++) {
          indices[i] = this._indices[i];
        }
      } else {
        indices = new Ctor(this._indices);
      }
      return indices;
    }
    return null;
  }
  _getRawIdxIdentity(idx) {
    return idx;
  }
  _getRawIdx(idx) {
    if (idx < this._count && idx >= 0) {
      return this._indices[idx];
    }
    return -1;
  }
  _updateGetRawIdx() {
    this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
  }
};
var DataStore = DataStore2;
DataStore.internalField = function() {
  function getDimValueSimply(dataItem, property, dataIndex, dimIndex) {
    return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex]);
  }
  defaultDimValueGetters = {
    arrayRows: getDimValueSimply,
    objectRows(dataItem, property, dataIndex, dimIndex) {
      return parseDataValue(dataItem[property], this._dimensions[dimIndex]);
    },
    keyedColumns: getDimValueSimply,
    original(dataItem, property, dataIndex, dimIndex) {
      const value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);
      return parseDataValue(value instanceof Array ? value[dimIndex] : value, this._dimensions[dimIndex]);
    },
    typedArray: function(dataItem, property, dataIndex, dimIndex) {
      return dataItem[dimIndex];
    }
  };
}();
var DataStore_default = DataStore;

// src/data/helper/sourceManager.ts
var SourceManager = class {
  constructor(sourceHost) {
    this._sourceList = [];
    this._storeList = [];
    this._upstreamSignList = [];
    this._versionSignBase = 0;
    this._dirty = true;
    this._sourceHost = sourceHost;
  }
  dirty() {
    this._setLocalSource([], []);
    this._storeList = [];
    this._dirty = true;
  }
  _setLocalSource(sourceList, upstreamSignList) {
    this._sourceList = sourceList;
    this._upstreamSignList = upstreamSignList;
    this._versionSignBase++;
    if (this._versionSignBase > 9e10) {
      this._versionSignBase = 0;
    }
  }
  _getVersionSign() {
    return this._sourceHost.uid + "_" + this._versionSignBase;
  }
  prepareSource() {
    if (this._isDirty()) {
      this._createSource();
      this._dirty = false;
    }
  }
  _createSource() {
    this._setLocalSource([], []);
    const sourceHost = this._sourceHost;
    const upSourceMgrList = this._getUpstreamSourceManagers();
    const hasUpstream = !!upSourceMgrList.length;
    let resultSourceList;
    let upstreamSignList;
    if (isSeries(sourceHost)) {
      const seriesModel = sourceHost;
      let data;
      let sourceFormat;
      let upSource;
      if (hasUpstream) {
        const upSourceMgr = upSourceMgrList[0];
        upSourceMgr.prepareSource();
        upSource = upSourceMgr.getSource();
        data = upSource.data;
        sourceFormat = upSource.sourceFormat;
        upstreamSignList = [upSourceMgr._getVersionSign()];
      } else {
        data = seriesModel.get("data", true);
        sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;
        upstreamSignList = [];
      }
      const newMetaRawOption = this._getSourceMetaRawOption() || {};
      const upMetaRawOption = upSource && upSource.metaRawOption || {};
      const seriesLayoutBy = retrieve2(newMetaRawOption.seriesLayoutBy, upMetaRawOption.seriesLayoutBy) || null;
      const sourceHeader = retrieve2(newMetaRawOption.sourceHeader, upMetaRawOption.sourceHeader);
      const dimensions = retrieve2(newMetaRawOption.dimensions, upMetaRawOption.dimensions);
      const needsCreateSource = seriesLayoutBy !== upMetaRawOption.seriesLayoutBy || !!sourceHeader !== !!upMetaRawOption.sourceHeader || dimensions;
      resultSourceList = needsCreateSource ? [createSource(data, {seriesLayoutBy, sourceHeader, dimensions}, sourceFormat)] : [];
    } else {
      const datasetModel = sourceHost;
      if (hasUpstream) {
        const result = this._applyTransform(upSourceMgrList);
        resultSourceList = result.sourceList;
        upstreamSignList = result.upstreamSignList;
      } else {
        const sourceData = datasetModel.get("source", true);
        resultSourceList = [createSource(sourceData, this._getSourceMetaRawOption(), null)];
        upstreamSignList = [];
      }
    }
    if (true) {
      assert(resultSourceList && upstreamSignList);
    }
    this._setLocalSource(resultSourceList, upstreamSignList);
  }
  _applyTransform(upMgrList) {
    const datasetModel = this._sourceHost;
    const transformOption = datasetModel.get("transform", true);
    const fromTransformResult = datasetModel.get("fromTransformResult", true);
    if (true) {
      assert(fromTransformResult != null || transformOption != null);
    }
    if (fromTransformResult != null) {
      let errMsg = "";
      if (upMgrList.length !== 1) {
        if (true) {
          errMsg = "When using `fromTransformResult`, there should be only one upstream dataset";
        }
        doThrow(errMsg);
      }
    }
    let sourceList;
    const upSourceList = [];
    const upstreamSignList = [];
    each(upMgrList, (upMgr) => {
      upMgr.prepareSource();
      const upSource = upMgr.getSource(fromTransformResult || 0);
      let errMsg = "";
      if (fromTransformResult != null && !upSource) {
        if (true) {
          errMsg = "Can not retrieve result by `fromTransformResult`: " + fromTransformResult;
        }
        doThrow(errMsg);
      }
      upSourceList.push(upSource);
      upstreamSignList.push(upMgr._getVersionSign());
    });
    if (transformOption) {
      sourceList = applyDataTransform(transformOption, upSourceList, {datasetIndex: datasetModel.componentIndex});
    } else if (fromTransformResult != null) {
      sourceList = [cloneSourceShallow(upSourceList[0])];
    }
    return {sourceList, upstreamSignList};
  }
  _isDirty() {
    if (this._dirty) {
      return true;
    }
    const upSourceMgrList = this._getUpstreamSourceManagers();
    for (let i = 0; i < upSourceMgrList.length; i++) {
      const upSrcMgr = upSourceMgrList[i];
      if (upSrcMgr._isDirty() || this._upstreamSignList[i] !== upSrcMgr._getVersionSign()) {
        return true;
      }
    }
  }
  getSource(sourceIndex) {
    sourceIndex = sourceIndex || 0;
    const source = this._sourceList[sourceIndex];
    if (!source) {
      const upSourceMgrList = this._getUpstreamSourceManagers();
      return upSourceMgrList[0] && upSourceMgrList[0].getSource(sourceIndex);
    }
    return source;
  }
  getSharedDataStore(seriesDimRequest) {
    if (true) {
      assert(isSeries(this._sourceHost), "Can only call getDataStore on series source manager.");
    }
    const schema = seriesDimRequest.makeStoreSchema();
    return this._innerGetDataStore(schema.dimensions, seriesDimRequest.source, schema.hash);
  }
  _innerGetDataStore(storeDims, seriesSource, sourceReadKey) {
    const sourceIndex = 0;
    const storeList = this._storeList;
    let cachedStoreMap = storeList[sourceIndex];
    if (!cachedStoreMap) {
      cachedStoreMap = storeList[sourceIndex] = {};
    }
    let cachedStore = cachedStoreMap[sourceReadKey];
    if (!cachedStore) {
      const upSourceMgr = this._getUpstreamSourceManagers()[0];
      if (isSeries(this._sourceHost) && upSourceMgr) {
        cachedStore = upSourceMgr._innerGetDataStore(storeDims, seriesSource, sourceReadKey);
      } else {
        cachedStore = new DataStore_default();
        cachedStore.initData(new DefaultDataProvider(seriesSource, storeDims.length), storeDims);
      }
      cachedStoreMap[sourceReadKey] = cachedStore;
    }
    return cachedStore;
  }
  _getUpstreamSourceManagers() {
    const sourceHost = this._sourceHost;
    if (isSeries(sourceHost)) {
      const datasetModel = querySeriesUpstreamDatasetModel(sourceHost);
      return !datasetModel ? [] : [datasetModel.getSourceManager()];
    } else {
      return map(queryDatasetUpstreamDatasetModels(sourceHost), (datasetModel) => datasetModel.getSourceManager());
    }
  }
  _getSourceMetaRawOption() {
    const sourceHost = this._sourceHost;
    let seriesLayoutBy;
    let sourceHeader;
    let dimensions;
    if (isSeries(sourceHost)) {
      seriesLayoutBy = sourceHost.get("seriesLayoutBy", true);
      sourceHeader = sourceHost.get("sourceHeader", true);
      dimensions = sourceHost.get("dimensions", true);
    } else if (!this._getUpstreamSourceManagers().length) {
      const model = sourceHost;
      seriesLayoutBy = model.get("seriesLayoutBy", true);
      sourceHeader = model.get("sourceHeader", true);
      dimensions = model.get("dimensions", true);
    }
    return {seriesLayoutBy, sourceHeader, dimensions};
  }
};
function disableTransformOptionMerge(datasetModel) {
  const transformOption = datasetModel.option.transform;
  transformOption && setAsPrimitive(datasetModel.option.transform);
}
function isSeries(sourceHost) {
  return sourceHost.mainType === "series";
}
function doThrow(errMsg) {
  throw new Error(errMsg);
}

// src/component/tooltip/tooltipMarkup.ts
var TOOLTIP_LINE_HEIGHT_CSS = "line-height:1";
function getTooltipLineHeight(textStyle) {
  const lineHeight = textStyle.lineHeight;
  if (lineHeight == null) {
    return TOOLTIP_LINE_HEIGHT_CSS;
  } else {
    return `line-height:${encodeHTML(lineHeight + "")}px`;
  }
}
function getTooltipTextStyle(textStyle, renderMode) {
  const nameFontColor = textStyle.color || tokens_default.color.tertiary;
  const nameFontSize = textStyle.fontSize || 12;
  const nameFontWeight = textStyle.fontWeight || "400";
  const valueFontColor = textStyle.color || tokens_default.color.secondary;
  const valueFontSize = textStyle.fontSize || 14;
  const valueFontWeight = textStyle.fontWeight || "900";
  if (renderMode === "html") {
    return {
      nameStyle: `font-size:${encodeHTML(nameFontSize + "")}px;color:${encodeHTML(nameFontColor)};font-weight:${encodeHTML(nameFontWeight + "")}`,
      valueStyle: `font-size:${encodeHTML(valueFontSize + "")}px;color:${encodeHTML(valueFontColor)};font-weight:${encodeHTML(valueFontWeight + "")}`
    };
  } else {
    return {
      nameStyle: {
        fontSize: nameFontSize,
        fill: nameFontColor,
        fontWeight: nameFontWeight
      },
      valueStyle: {
        fontSize: valueFontSize,
        fill: valueFontColor,
        fontWeight: valueFontWeight
      }
    };
  }
}
var HTML_GAPS = [0, 10, 20, 30];
var RICH_TEXT_GAPS = ["", "\n", "\n\n", "\n\n\n"];
function createTooltipMarkup(type, option) {
  option.type = type;
  return option;
}
function isSectionFragment(frag) {
  return frag.type === "section";
}
function getBuilder(frag) {
  return isSectionFragment(frag) ? buildSection : buildNameValue;
}
function getBlockGapLevel(frag) {
  if (isSectionFragment(frag)) {
    let gapLevel = 0;
    const subBlockLen = frag.blocks.length;
    const hasInnerGap = subBlockLen > 1 || subBlockLen > 0 && !frag.noHeader;
    each(frag.blocks, function(subBlock) {
      const subGapLevel = getBlockGapLevel(subBlock);
      if (subGapLevel >= gapLevel) {
        gapLevel = subGapLevel + +(hasInnerGap && (!subGapLevel || isSectionFragment(subBlock) && !subBlock.noHeader));
      }
    });
    return gapLevel;
  }
  return 0;
}
function buildSection(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
  const noHeader = fragment.noHeader;
  const gaps = getGap(getBlockGapLevel(fragment));
  const subMarkupTextList = [];
  let subBlocks = fragment.blocks || [];
  assert(!subBlocks || isArray(subBlocks));
  subBlocks = subBlocks || [];
  const orderMode = ctx.orderMode;
  if (fragment.sortBlocks && orderMode) {
    subBlocks = subBlocks.slice();
    const orderMap = {valueAsc: "asc", valueDesc: "desc"};
    if (hasOwn(orderMap, orderMode)) {
      const comparator = new SortOrderComparator(orderMap[orderMode], null);
      subBlocks.sort((a, b) => comparator.evaluate(a.sortParam, b.sortParam));
    } else if (orderMode === "seriesDesc") {
      subBlocks.reverse();
    }
  }
  each(subBlocks, function(subBlock, idx) {
    const valueFormatter = fragment.valueFormatter;
    const subMarkupText2 = getBuilder(subBlock)(valueFormatter ? extend(extend({}, ctx), {valueFormatter}) : ctx, subBlock, idx > 0 ? gaps.html : 0, toolTipTextStyle);
    subMarkupText2 != null && subMarkupTextList.push(subMarkupText2);
  });
  const subMarkupText = ctx.renderMode === "richText" ? subMarkupTextList.join(gaps.richText) : wrapBlockHTML(toolTipTextStyle, subMarkupTextList.join(""), noHeader ? topMarginForOuterGap : gaps.html);
  if (noHeader) {
    return subMarkupText;
  }
  const displayableHeader = makeValueReadable(fragment.header, "ordinal", ctx.useUTC);
  const {nameStyle} = getTooltipTextStyle(toolTipTextStyle, ctx.renderMode);
  const tooltipLineHeight = getTooltipLineHeight(toolTipTextStyle);
  if (ctx.renderMode === "richText") {
    return wrapInlineNameRichText(ctx, displayableHeader, nameStyle) + gaps.richText + subMarkupText;
  } else {
    return wrapBlockHTML(toolTipTextStyle, `<div style="${nameStyle};${tooltipLineHeight};">` + encodeHTML(displayableHeader) + "</div>" + subMarkupText, topMarginForOuterGap);
  }
}
function buildNameValue(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
  const renderMode = ctx.renderMode;
  const noName = fragment.noName;
  const noValue = fragment.noValue;
  const noMarker = !fragment.markerType;
  const name = fragment.name;
  const useUTC = ctx.useUTC;
  const valueFormatter = fragment.valueFormatter || ctx.valueFormatter || ((value) => {
    value = isArray(value) ? value : [value];
    return map(value, (val, idx) => makeValueReadable(val, isArray(valueTypeOption) ? valueTypeOption[idx] : valueTypeOption, useUTC));
  });
  if (noName && noValue) {
    return;
  }
  const markerStr = noMarker ? "" : ctx.markupStyleCreator.makeTooltipMarker(fragment.markerType, fragment.markerColor || tokens_default.color.secondary, renderMode);
  const readableName = noName ? "" : makeValueReadable(name, "ordinal", useUTC);
  const valueTypeOption = fragment.valueType;
  const readableValueList = noValue ? [] : valueFormatter(fragment.value, fragment.dataIndex);
  const valueAlignRight = !noMarker || !noName;
  const valueCloseToMarker = !noMarker && noName;
  const {nameStyle, valueStyle} = getTooltipTextStyle(toolTipTextStyle, renderMode);
  return renderMode === "richText" ? (noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameRichText(ctx, readableName, nameStyle)) + (noValue ? "" : wrapInlineValueRichText(ctx, readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)) : wrapBlockHTML(toolTipTextStyle, (noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameHTML(readableName, !noMarker, nameStyle)) + (noValue ? "" : wrapInlineValueHTML(readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)), topMarginForOuterGap);
}
function buildTooltipMarkup(fragment, markupStyleCreator, renderMode, orderMode, useUTC, toolTipTextStyle) {
  if (!fragment) {
    return;
  }
  const builder = getBuilder(fragment);
  const ctx = {
    useUTC,
    renderMode,
    orderMode,
    markupStyleCreator,
    valueFormatter: fragment.valueFormatter
  };
  return builder(ctx, fragment, 0, toolTipTextStyle);
}
function getGap(gapLevel) {
  return {
    html: HTML_GAPS[gapLevel],
    richText: RICH_TEXT_GAPS[gapLevel]
  };
}
function wrapBlockHTML(textStyle, encodedContent, topGap) {
  const clearfix = '<div style="clear:both"></div>';
  const marginCSS = `margin: ${topGap}px 0 0`;
  const tooltipLineHeight = getTooltipLineHeight(textStyle);
  return `<div style="${marginCSS};${tooltipLineHeight};">` + encodedContent + clearfix + "</div>";
}
function wrapInlineNameHTML(name, leftHasMarker, style) {
  const marginCss = leftHasMarker ? "margin-left:2px" : "";
  return `<span style="${style};${marginCss}">` + encodeHTML(name) + "</span>";
}
function wrapInlineValueHTML(valueList, alignRight, valueCloseToMarker, style) {
  const paddingStr = valueCloseToMarker ? "10px" : "20px";
  const alignCSS = alignRight ? `float:right;margin-left:${paddingStr}` : "";
  valueList = isArray(valueList) ? valueList : [valueList];
  return `<span style="${alignCSS};${style}">` + map(valueList, (value) => encodeHTML(value)).join("&nbsp;&nbsp;") + "</span>";
}
function wrapInlineNameRichText(ctx, name, style) {
  return ctx.markupStyleCreator.wrapRichTextStyle(name, style);
}
function wrapInlineValueRichText(ctx, values, alignRight, valueCloseToMarker, style) {
  const styles = [style];
  const paddingLeft = valueCloseToMarker ? 10 : 20;
  alignRight && styles.push({padding: [0, 0, 0, paddingLeft], align: "right"});
  return ctx.markupStyleCreator.wrapRichTextStyle(isArray(values) ? values.join("  ") : values, styles);
}
function retrieveVisualColorForTooltipMarker(series, dataIndex) {
  const style = series.getData().getItemVisual(dataIndex, "style");
  const color4 = style[series.visualDrawType];
  return convertToColorString(color4);
}
function getPaddingFromTooltipModel(model, renderMode) {
  const padding = model.get("padding");
  return padding != null ? padding : renderMode === "richText" ? [8, 10] : 10;
}
var TooltipMarkupStyleCreator = class {
  constructor() {
    this.richTextStyles = {};
    this._nextStyleNameId = getRandomIdBase();
  }
  _generateStyleName() {
    return "__EC_aUTo_" + this._nextStyleNameId++;
  }
  makeTooltipMarker(markerType, colorStr, renderMode) {
    const markerId = renderMode === "richText" ? this._generateStyleName() : null;
    const marker = getTooltipMarker({
      color: colorStr,
      type: markerType,
      renderMode,
      markerId
    });
    if (isString(marker)) {
      return marker;
    } else {
      if (true) {
        assert(markerId);
      }
      this.richTextStyles[markerId] = marker.style;
      return marker.content;
    }
  }
  wrapRichTextStyle(text, styles) {
    const finalStl = {};
    if (isArray(styles)) {
      each(styles, (stl) => extend(finalStl, stl));
    } else {
      extend(finalStl, styles);
    }
    const styleName = this._generateStyleName();
    this.richTextStyles[styleName] = finalStl;
    return `{${styleName}|${text}}`;
  }
};

// src/component/tooltip/seriesFormatTooltip.ts
function defaultSeriesFormatTooltip(opt) {
  const series = opt.series;
  const dataIndex = opt.dataIndex;
  const multipleSeries = opt.multipleSeries;
  const data = series.getData();
  const tooltipDims = data.mapDimensionsAll("defaultedTooltip");
  const tooltipDimLen = tooltipDims.length;
  const value = series.getRawValue(dataIndex);
  const isValueArr = isArray(value);
  const markerColor = retrieveVisualColorForTooltipMarker(series, dataIndex);
  let inlineValue;
  let inlineValueType;
  let subBlocks;
  let sortParam;
  if (tooltipDimLen > 1 || isValueArr && !tooltipDimLen) {
    const formatArrResult = formatTooltipArrayValue(value, series, dataIndex, tooltipDims, markerColor);
    inlineValue = formatArrResult.inlineValues;
    inlineValueType = formatArrResult.inlineValueTypes;
    subBlocks = formatArrResult.blocks;
    sortParam = formatArrResult.inlineValues[0];
  } else if (tooltipDimLen) {
    const dimInfo = data.getDimensionInfo(tooltipDims[0]);
    sortParam = inlineValue = retrieveRawValue(data, dataIndex, tooltipDims[0]);
    inlineValueType = dimInfo.type;
  } else {
    sortParam = inlineValue = isValueArr ? value[0] : value;
  }
  const seriesNameSpecified = isNameSpecified(series);
  const seriesName = seriesNameSpecified && series.name || "";
  const itemName = data.getName(dataIndex);
  const inlineName = multipleSeries ? seriesName : itemName;
  return createTooltipMarkup("section", {
    header: seriesName,
    noHeader: multipleSeries || !seriesNameSpecified,
    sortParam,
    blocks: [
      createTooltipMarkup("nameValue", {
        markerType: "item",
        markerColor,
        name: inlineName,
        noName: !trim(inlineName),
        value: inlineValue,
        valueType: inlineValueType,
        dataIndex
      })
    ].concat(subBlocks || [])
  });
}
function formatTooltipArrayValue(value, series, dataIndex, tooltipDims, colorStr) {
  const data = series.getData();
  const isValueMultipleLine = reduce(value, function(isValueMultipleLine2, val, idx) {
    const dimItem = data.getDimensionInfo(idx);
    return isValueMultipleLine2 = isValueMultipleLine2 || dimItem && dimItem.tooltip !== false && dimItem.displayName != null;
  }, false);
  const inlineValues = [];
  const inlineValueTypes = [];
  const blocks = [];
  tooltipDims.length ? each(tooltipDims, function(dim) {
    setEachItem(retrieveRawValue(data, dataIndex, dim), dim);
  }) : each(value, setEachItem);
  function setEachItem(val, dim) {
    const dimInfo = data.getDimensionInfo(dim);
    if (!dimInfo || dimInfo.otherDims.tooltip === false) {
      return;
    }
    if (isValueMultipleLine) {
      blocks.push(createTooltipMarkup("nameValue", {
        markerType: "subItem",
        markerColor: colorStr,
        name: dimInfo.displayName,
        value: val,
        valueType: dimInfo.type
      }));
    } else {
      inlineValues.push(val);
      inlineValueTypes.push(dimInfo.type);
    }
  }
  return {inlineValues, inlineValueTypes, blocks};
}

// src/model/Series.ts
var inner2 = makeInner();
function getSelectionKey(data, dataIndex) {
  return data.getName(dataIndex) || data.getId(dataIndex);
}
var SERIES_UNIVERSAL_TRANSITION_PROP = "__universalTransitionEnabled";
var SeriesModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this._selectedDataIndicesMap = {};
  }
  init(option, parentModel, ecModel) {
    this.seriesIndex = this.componentIndex;
    this.dataTask = createTask({
      count: dataTaskCount,
      reset: dataTaskReset
    });
    this.dataTask.context = {model: this};
    this.mergeDefaultAndTheme(option, ecModel);
    const sourceManager = inner2(this).sourceManager = new SourceManager(this);
    sourceManager.prepareSource();
    const data = this.getInitialData(option, ecModel);
    wrapData(data, this);
    this.dataTask.context.data = data;
    if (true) {
      assert(data, "getInitialData returned invalid data.");
    }
    inner2(this).dataBeforeProcessed = data;
    autoSeriesName(this);
    this._initSelectedMapFromData(data);
  }
  mergeDefaultAndTheme(option, ecModel) {
    const layoutMode = fetchLayoutMode(this);
    const inputPositionParams = layoutMode ? getLayoutParams(option) : {};
    let themeSubType = this.subType;
    if (Component_default.hasClass(themeSubType)) {
      themeSubType += "Series";
    }
    merge(option, ecModel.getTheme().get(this.subType));
    merge(option, this.getDefaultOption());
    defaultEmphasis(option, "label", ["show"]);
    this.fillDataTextStyle(option.data);
    if (layoutMode) {
      mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  }
  mergeOption(newSeriesOption, ecModel) {
    newSeriesOption = merge(this.option, newSeriesOption, true);
    this.fillDataTextStyle(newSeriesOption.data);
    const layoutMode = fetchLayoutMode(this);
    if (layoutMode) {
      mergeLayoutParam(this.option, newSeriesOption, layoutMode);
    }
    const sourceManager = inner2(this).sourceManager;
    sourceManager.dirty();
    sourceManager.prepareSource();
    const data = this.getInitialData(newSeriesOption, ecModel);
    wrapData(data, this);
    this.dataTask.dirty();
    this.dataTask.context.data = data;
    inner2(this).dataBeforeProcessed = data;
    autoSeriesName(this);
    this._initSelectedMapFromData(data);
  }
  fillDataTextStyle(data) {
    if (data && !isTypedArray(data)) {
      const props = ["show"];
      for (let i = 0; i < data.length; i++) {
        if (data[i] && data[i].label) {
          defaultEmphasis(data[i], "label", props);
        }
      }
    }
  }
  getInitialData(option, ecModel) {
    return;
  }
  appendData(params) {
    const data = this.getRawData();
    data.appendData(params.data);
  }
  getData(dataType) {
    const task = getCurrentTask(this);
    if (task) {
      const data = task.context.data;
      return dataType == null || !data.getLinkedData ? data : data.getLinkedData(dataType);
    } else {
      return inner2(this).data;
    }
  }
  getAllData() {
    const mainData = this.getData();
    return mainData && mainData.getLinkedDataAll ? mainData.getLinkedDataAll() : [{data: mainData}];
  }
  setData(data) {
    const task = getCurrentTask(this);
    if (task) {
      const context = task.context;
      context.outputData = data;
      if (task !== this.dataTask) {
        context.data = data;
      }
    }
    inner2(this).data = data;
  }
  getEncode() {
    const encode = this.get("encode", true);
    if (encode) {
      return createHashMap(encode);
    }
  }
  getSourceManager() {
    return inner2(this).sourceManager;
  }
  getSource() {
    return this.getSourceManager().getSource();
  }
  getRawData() {
    return inner2(this).dataBeforeProcessed;
  }
  getColorBy() {
    const colorBy = this.get("colorBy");
    return colorBy || "series";
  }
  isColorBySeries() {
    return this.getColorBy() === "series";
  }
  getBaseAxis() {
    const coordSys = this.coordinateSystem;
    return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
  }
  indicesOfNearest(axisDim, dim, value, maxDistance) {
    const data = this.getData();
    const coordSys = this.coordinateSystem;
    const axis = coordSys && coordSys.getAxis(axisDim);
    if (!coordSys || !axis) {
      return [];
    }
    const targetCoord = axis.dataToCoord(value);
    if (maxDistance == null) {
      maxDistance = Infinity;
    }
    const nearestIndices = [];
    let minDist = Infinity;
    let minDiff = -1;
    let nearestIndicesLen = 0;
    data.each(dim, (dimValue, idx) => {
      const dataCoord = axis.dataToCoord(dimValue);
      const diff = targetCoord - dataCoord;
      const dist3 = Math.abs(diff);
      if (dist3 <= maxDistance) {
        if (dist3 < minDist || dist3 === minDist && diff >= 0 && minDiff < 0) {
          minDist = dist3;
          minDiff = diff;
          nearestIndicesLen = 0;
        }
        if (diff === minDiff) {
          nearestIndices[nearestIndicesLen++] = idx;
        }
      }
    });
    nearestIndices.length = nearestIndicesLen;
    return nearestIndices;
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    return defaultSeriesFormatTooltip({
      series: this,
      dataIndex,
      multipleSeries
    });
  }
  isAnimationEnabled() {
    const ecModel = this.ecModel;
    if (env_default.node && !(ecModel && ecModel.ssr)) {
      return false;
    }
    let animationEnabled = this.getShallow("animation");
    if (animationEnabled) {
      if (this.getData().count() > this.getShallow("animationThreshold")) {
        animationEnabled = false;
      }
    }
    return !!animationEnabled;
  }
  restoreData() {
    this.dataTask.dirty();
  }
  getColorFromPalette(name, scope, requestColorNum) {
    const ecModel = this.ecModel;
    let color4 = PaletteMixin.prototype.getColorFromPalette.call(this, name, scope, requestColorNum);
    if (!color4) {
      color4 = ecModel.getColorFromPalette(name, scope, requestColorNum);
    }
    return color4;
  }
  coordDimToDataDim(coordDim) {
    return this.getRawData().mapDimensionsAll(coordDim);
  }
  getProgressive() {
    return this.get("progressive");
  }
  getProgressiveThreshold() {
    return this.get("progressiveThreshold");
  }
  select(innerDataIndices, dataType) {
    this._innerSelect(this.getData(dataType), innerDataIndices);
  }
  unselect(innerDataIndices, dataType) {
    const selectedMap = this.option.selectedMap;
    if (!selectedMap) {
      return;
    }
    const selectedMode = this.option.selectedMode;
    const data = this.getData(dataType);
    if (selectedMode === "series" || selectedMap === "all") {
      this.option.selectedMap = {};
      this._selectedDataIndicesMap = {};
      return;
    }
    for (let i = 0; i < innerDataIndices.length; i++) {
      const dataIndex = innerDataIndices[i];
      const nameOrId = getSelectionKey(data, dataIndex);
      selectedMap[nameOrId] = false;
      this._selectedDataIndicesMap[nameOrId] = -1;
    }
  }
  toggleSelect(innerDataIndices, dataType) {
    const tmpArr2 = [];
    for (let i = 0; i < innerDataIndices.length; i++) {
      tmpArr2[0] = innerDataIndices[i];
      this.isSelected(innerDataIndices[i], dataType) ? this.unselect(tmpArr2, dataType) : this.select(tmpArr2, dataType);
    }
  }
  getSelectedDataIndices() {
    if (this.option.selectedMap === "all") {
      return [].slice.call(this.getData().getIndices());
    }
    const selectedDataIndicesMap = this._selectedDataIndicesMap;
    const nameOrIds = keys(selectedDataIndicesMap);
    const dataIndices = [];
    for (let i = 0; i < nameOrIds.length; i++) {
      const dataIndex = selectedDataIndicesMap[nameOrIds[i]];
      if (dataIndex >= 0) {
        dataIndices.push(dataIndex);
      }
    }
    return dataIndices;
  }
  isSelected(dataIndex, dataType) {
    const selectedMap = this.option.selectedMap;
    if (!selectedMap) {
      return false;
    }
    const data = this.getData(dataType);
    return (selectedMap === "all" || selectedMap[getSelectionKey(data, dataIndex)]) && !data.getItemModel(dataIndex).get(["select", "disabled"]);
  }
  isUniversalTransitionEnabled() {
    if (this[SERIES_UNIVERSAL_TRANSITION_PROP]) {
      return true;
    }
    const universalTransitionOpt = this.option.universalTransition;
    if (!universalTransitionOpt) {
      return false;
    }
    if (universalTransitionOpt === true) {
      return true;
    }
    return universalTransitionOpt && universalTransitionOpt.enabled;
  }
  _innerSelect(data, innerDataIndices) {
    const option = this.option;
    const selectedMode = option.selectedMode;
    const len2 = innerDataIndices.length;
    if (!selectedMode || !len2) {
      return;
    }
    if (selectedMode === "series") {
      option.selectedMap = "all";
    } else if (selectedMode === "multiple") {
      if (!isObject(option.selectedMap)) {
        option.selectedMap = {};
      }
      const selectedMap = option.selectedMap;
      for (let i = 0; i < len2; i++) {
        const dataIndex = innerDataIndices[i];
        const nameOrId = getSelectionKey(data, dataIndex);
        selectedMap[nameOrId] = true;
        this._selectedDataIndicesMap[nameOrId] = data.getRawIndex(dataIndex);
      }
    } else if (selectedMode === "single" || selectedMode === true) {
      const lastDataIndex = innerDataIndices[len2 - 1];
      const nameOrId = getSelectionKey(data, lastDataIndex);
      option.selectedMap = {
        [nameOrId]: true
      };
      this._selectedDataIndicesMap = {
        [nameOrId]: data.getRawIndex(lastDataIndex)
      };
    }
  }
  _initSelectedMapFromData(data) {
    if (this.option.selectedMap) {
      return;
    }
    const dataIndices = [];
    if (data.hasItemOption) {
      data.each(function(idx) {
        const rawItem = data.getRawDataItem(idx);
        if (rawItem && rawItem.selected) {
          dataIndices.push(idx);
        }
      });
    }
    if (dataIndices.length > 0) {
      this._innerSelect(data, dataIndices);
    }
  }
  static registerClass(clz) {
    return Component_default.registerClass(clz);
  }
};
var SeriesModel = SeriesModel2;
SERIES_UNIVERSAL_TRANSITION_PROP;
SeriesModel.protoInitialize = function() {
  const proto = SeriesModel2.prototype;
  proto.type = "series.__base__";
  proto.seriesIndex = 0;
  proto.ignoreStyleOnData = false;
  proto.hasSymbolVisual = false;
  proto.defaultSymbol = "circle";
  proto.visualStyleAccessPath = "itemStyle";
  proto.visualDrawType = "fill";
}();
mixin(SeriesModel, DataFormatMixin);
mixin(SeriesModel, PaletteMixin);
mountExtend(SeriesModel, Component_default);
function autoSeriesName(seriesModel) {
  const name = seriesModel.name;
  if (!isNameSpecified(seriesModel)) {
    seriesModel.name = getSeriesAutoName(seriesModel) || name;
  }
}
function getSeriesAutoName(seriesModel) {
  const data = seriesModel.getRawData();
  const dataDims = data.mapDimensionsAll("seriesName");
  const nameArr = [];
  each(dataDims, function(dataDim) {
    const dimInfo = data.getDimensionInfo(dataDim);
    dimInfo.displayName && nameArr.push(dimInfo.displayName);
  });
  return nameArr.join(" ");
}
function dataTaskCount(context) {
  return context.model.getRawData().count();
}
function dataTaskReset(context) {
  const seriesModel = context.model;
  seriesModel.setData(seriesModel.getRawData().cloneShallow());
  return dataTaskProgress;
}
function dataTaskProgress(param, context) {
  if (context.outputData && param.end > context.outputData.count()) {
    context.model.getRawData().cloneShallow(context.outputData);
  }
}
function wrapData(data, seriesModel) {
  each(concatArray(data.CHANGABLE_METHODS, data.DOWNSAMPLE_METHODS), function(methodName) {
    data.wrapMethod(methodName, curry(onDataChange, seriesModel));
  });
}
function onDataChange(seriesModel, newList) {
  const task = getCurrentTask(seriesModel);
  if (task) {
    task.setOutputEnd((newList || this).count());
  }
  return newList;
}
function getCurrentTask(seriesModel) {
  const scheduler = (seriesModel.ecModel || {}).scheduler;
  const pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);
  if (pipeline) {
    let task = pipeline.currentTask;
    if (task) {
      const agentStubMap = task.agentStubMap;
      if (agentStubMap) {
        task = agentStubMap.get(seriesModel.uid);
      }
    }
    return task;
  }
}
var Series_default = SeriesModel;

// src/view/Component.ts
var ComponentView = class {
  constructor() {
    this.group = new Group_default();
    this.uid = getUID("viewComponent");
  }
  init(ecModel, api2) {
  }
  render(model, ecModel, api2, payload) {
  }
  dispose(ecModel, api2) {
  }
  updateView(model, ecModel, api2, payload) {
  }
  updateLayout(model, ecModel, api2, payload) {
  }
  updateVisual(model, ecModel, api2, payload) {
  }
  toggleBlurSeries(seriesModels, isBlur, ecModel) {
  }
  eachRendered(cb) {
    const group = this.group;
    if (group) {
      group.traverse(cb);
    }
  }
};
enableClassExtend(ComponentView);
enableClassManagement(ComponentView);
var Component_default2 = ComponentView;

// src/chart/helper/createRenderPlanner.ts
function createRenderPlanner() {
  const inner25 = makeInner();
  return function(seriesModel) {
    const fields = inner25(seriesModel);
    const pipelineContext = seriesModel.pipelineContext;
    const originalLarge = !!fields.large;
    const originalProgressive = !!fields.progressiveRender;
    const large = fields.large = !!(pipelineContext && pipelineContext.large);
    const progressive = fields.progressiveRender = !!(pipelineContext && pipelineContext.progressiveRender);
    return !!(originalLarge !== large || originalProgressive !== progressive) && "reset";
  };
}

// src/view/Chart.ts
var inner3 = makeInner();
var renderPlanner = createRenderPlanner();
var ChartView2 = class {
  constructor() {
    this.group = new Group_default();
    this.uid = getUID("viewChart");
    this.renderTask = createTask({
      plan: renderTaskPlan,
      reset: renderTaskReset
    });
    this.renderTask.context = {view: this};
  }
  init(ecModel, api2) {
  }
  render(seriesModel, ecModel, api2, payload) {
    if (true) {
      throw new Error("render method must been implemented");
    }
  }
  highlight(seriesModel, ecModel, api2, payload) {
    const data = seriesModel.getData(payload && payload.dataType);
    if (!data) {
      if (true) {
        error(`Unknown dataType ${payload.dataType}`);
      }
      return;
    }
    toggleHighlight(data, payload, "emphasis");
  }
  downplay(seriesModel, ecModel, api2, payload) {
    const data = seriesModel.getData(payload && payload.dataType);
    if (!data) {
      if (true) {
        error(`Unknown dataType ${payload.dataType}`);
      }
      return;
    }
    toggleHighlight(data, payload, "normal");
  }
  remove(ecModel, api2) {
    this.group.removeAll();
  }
  dispose(ecModel, api2) {
  }
  updateView(seriesModel, ecModel, api2, payload) {
    this.render(seriesModel, ecModel, api2, payload);
  }
  updateLayout(seriesModel, ecModel, api2, payload) {
    this.render(seriesModel, ecModel, api2, payload);
  }
  updateVisual(seriesModel, ecModel, api2, payload) {
    this.render(seriesModel, ecModel, api2, payload);
  }
  eachRendered(cb) {
    traverseElements(this.group, cb);
  }
  static markUpdateMethod(payload, methodName) {
    inner3(payload).updateMethod = methodName;
  }
};
var ChartView = ChartView2;
ChartView.protoInitialize = function() {
  const proto = ChartView2.prototype;
  proto.type = "chart";
}();
function elSetState(el, state, highlightDigit) {
  if (el && isHighDownDispatcher(el)) {
    (state === "emphasis" ? enterEmphasis : leaveEmphasis)(el, highlightDigit);
  }
}
function toggleHighlight(data, payload, state) {
  const dataIndex = queryDataIndex(data, payload);
  const highlightDigit = payload && payload.highlightKey != null ? getHighlightDigit(payload.highlightKey) : null;
  if (dataIndex != null) {
    each(normalizeToArray(dataIndex), function(dataIdx) {
      elSetState(data.getItemGraphicEl(dataIdx), state, highlightDigit);
    });
  } else {
    data.eachItemGraphicEl(function(el) {
      elSetState(el, state, highlightDigit);
    });
  }
}
enableClassExtend(ChartView, ["dispose"]);
enableClassManagement(ChartView);
function renderTaskPlan(context) {
  return renderPlanner(context.model);
}
function renderTaskReset(context) {
  const seriesModel = context.model;
  const ecModel = context.ecModel;
  const api2 = context.api;
  const payload = context.payload;
  const progressiveRender = seriesModel.pipelineContext.progressiveRender;
  const view = context.view;
  const updateMethod = payload && inner3(payload).updateMethod;
  const methodName = progressiveRender ? "incrementalPrepareRender" : updateMethod && view[updateMethod] ? updateMethod : "render";
  if (methodName !== "render") {
    view[methodName](seriesModel, ecModel, api2, payload);
  }
  return progressMethodMap[methodName];
}
var progressMethodMap = {
  incrementalPrepareRender: {
    progress: function(params, context) {
      context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload);
    }
  },
  render: {
    forceFirstProgress: true,
    progress: function(params, context) {
      context.view.render(context.model, context.ecModel, context.api, context.payload);
    }
  }
};
var Chart_default = ChartView;

// src/util/throttle.ts
var ORIGIN_METHOD = "\0__throttleOriginMethod";
var RATE = "\0__throttleRate";
var THROTTLE_TYPE = "\0__throttleType";
function throttle(fn, delay, debounce) {
  let currCall;
  let lastCall = 0;
  let lastExec = 0;
  let timer = null;
  let diff;
  let scope;
  let args;
  let debounceNextCall;
  delay = delay || 0;
  function exec() {
    lastExec = new Date().getTime();
    timer = null;
    fn.apply(scope, args || []);
  }
  const cb = function(...cbArgs) {
    currCall = new Date().getTime();
    scope = this;
    args = cbArgs;
    const thisDelay = debounceNextCall || delay;
    const thisDebounce = debounceNextCall || debounce;
    debounceNextCall = null;
    diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;
    clearTimeout(timer);
    if (thisDebounce) {
      timer = setTimeout(exec, thisDelay);
    } else {
      if (diff >= 0) {
        exec();
      } else {
        timer = setTimeout(exec, -diff);
      }
    }
    lastCall = currCall;
  };
  cb.clear = function() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  };
  cb.debounceNextCall = function(debounceDelay) {
    debounceNextCall = debounceDelay;
  };
  return cb;
}
function createOrUpdate(obj, fnAttr, rate, throttleType) {
  let fn = obj[fnAttr];
  if (!fn) {
    return;
  }
  const originFn = fn[ORIGIN_METHOD] || fn;
  const lastThrottleType = fn[THROTTLE_TYPE];
  const lastRate = fn[RATE];
  if (lastRate !== rate || lastThrottleType !== throttleType) {
    if (rate == null || !throttleType) {
      return obj[fnAttr] = originFn;
    }
    fn = obj[fnAttr] = throttle(originFn, rate, throttleType === "debounce");
    fn[ORIGIN_METHOD] = originFn;
    fn[THROTTLE_TYPE] = throttleType;
    fn[RATE] = rate;
  }
  return fn;
}
function clear(obj, fnAttr) {
  const fn = obj[fnAttr];
  if (fn && fn[ORIGIN_METHOD]) {
    fn.clear && fn.clear();
    obj[fnAttr] = fn[ORIGIN_METHOD];
  }
}

// src/visual/style.ts
var inner4 = makeInner();
var defaultStyleMappers = {
  itemStyle: makeStyleMapper(ITEM_STYLE_KEY_MAP, true),
  lineStyle: makeStyleMapper(LINE_STYLE_KEY_MAP, true)
};
var defaultColorKey = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function getStyleMapper(seriesModel, stylePath) {
  const styleMapper = seriesModel.visualStyleMapper || defaultStyleMappers[stylePath];
  if (!styleMapper) {
    console.warn(`Unknown style type '${stylePath}'.`);
    return defaultStyleMappers.itemStyle;
  }
  return styleMapper;
}
function getDefaultColorKey(seriesModel, stylePath) {
  const colorKey = seriesModel.visualDrawType || defaultColorKey[stylePath];
  if (!colorKey) {
    console.warn(`Unknown style type '${stylePath}'.`);
    return "fill";
  }
  return colorKey;
}
var seriesStyleTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset(seriesModel, ecModel) {
    const data = seriesModel.getData();
    const stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
    const styleModel = seriesModel.getModel(stylePath);
    const getStyle2 = getStyleMapper(seriesModel, stylePath);
    const globalStyle = getStyle2(styleModel);
    const decalOption = styleModel.getShallow("decal");
    if (decalOption) {
      data.setVisual("decal", decalOption);
      decalOption.dirty = true;
    }
    const colorKey = getDefaultColorKey(seriesModel, stylePath);
    const color4 = globalStyle[colorKey];
    const colorCallback = isFunction(color4) ? color4 : null;
    const hasAutoColor = globalStyle.fill === "auto" || globalStyle.stroke === "auto";
    if (!globalStyle[colorKey] || colorCallback || hasAutoColor) {
      const colorPalette = seriesModel.getColorFromPalette(seriesModel.name, null, ecModel.getSeriesCount());
      if (!globalStyle[colorKey]) {
        globalStyle[colorKey] = colorPalette;
        data.setVisual("colorFromPalette", true);
      }
      globalStyle.fill = globalStyle.fill === "auto" || isFunction(globalStyle.fill) ? colorPalette : globalStyle.fill;
      globalStyle.stroke = globalStyle.stroke === "auto" || isFunction(globalStyle.stroke) ? colorPalette : globalStyle.stroke;
    }
    data.setVisual("style", globalStyle);
    data.setVisual("drawType", colorKey);
    if (!ecModel.isSeriesFiltered(seriesModel) && colorCallback) {
      data.setVisual("colorFromPalette", false);
      return {
        dataEach(data2, idx) {
          const dataParams = seriesModel.getDataParams(idx);
          const itemStyle = extend({}, globalStyle);
          itemStyle[colorKey] = colorCallback(dataParams);
          data2.setItemVisual(idx, "style", itemStyle);
        }
      };
    }
  }
};
var sharedModel = new Model_default();
var dataStyleTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset(seriesModel, ecModel) {
    if (seriesModel.ignoreStyleOnData || ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    const data = seriesModel.getData();
    const stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
    const getStyle2 = getStyleMapper(seriesModel, stylePath);
    const colorKey = data.getVisual("drawType");
    return {
      dataEach: data.hasItemOption ? function(data2, idx) {
        const rawItem = data2.getRawDataItem(idx);
        if (rawItem && rawItem[stylePath]) {
          sharedModel.option = rawItem[stylePath];
          const style = getStyle2(sharedModel);
          const existsStyle = data2.ensureUniqueItemVisual(idx, "style");
          extend(existsStyle, style);
          if (sharedModel.option.decal) {
            data2.setItemVisual(idx, "decal", sharedModel.option.decal);
            sharedModel.option.decal.dirty = true;
          }
          if (colorKey in style) {
            data2.setItemVisual(idx, "colorFromPalette", false);
          }
        }
      } : null
    };
  }
};
var dataColorPaletteTask = {
  performRawSeries: true,
  overallReset(ecModel) {
    const paletteScopeGroupByType = createHashMap();
    ecModel.eachSeries((seriesModel) => {
      const colorBy = seriesModel.getColorBy();
      if (seriesModel.isColorBySeries()) {
        return;
      }
      const key = seriesModel.type + "-" + colorBy;
      let colorScope = paletteScopeGroupByType.get(key);
      if (!colorScope) {
        colorScope = {};
        paletteScopeGroupByType.set(key, colorScope);
      }
      inner4(seriesModel).scope = colorScope;
    });
    ecModel.eachSeries((seriesModel) => {
      if (seriesModel.isColorBySeries() || ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }
      const dataAll = seriesModel.getRawData();
      const idxMap = {};
      const data = seriesModel.getData();
      const colorScope = inner4(seriesModel).scope;
      const stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
      const colorKey = getDefaultColorKey(seriesModel, stylePath);
      data.each(function(idx) {
        const rawIdx = data.getRawIndex(idx);
        idxMap[rawIdx] = idx;
      });
      dataAll.each(function(rawIdx) {
        const idx = idxMap[rawIdx];
        const fromPalette = data.getItemVisual(idx, "colorFromPalette");
        if (fromPalette) {
          const itemStyle = data.ensureUniqueItemVisual(idx, "style");
          const name = dataAll.getName(rawIdx) || rawIdx + "";
          const dataCount = dataAll.count();
          itemStyle[colorKey] = seriesModel.getColorFromPalette(name, colorScope, dataCount);
        }
      });
    });
  }
};

// src/loading/default.ts
var PI5 = Math.PI;
function defaultLoading(api2, opts) {
  opts = opts || {};
  defaults(opts, {
    text: "loading",
    textColor: tokens_default.color.primary,
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255,255,255,0.8)",
    showSpinner: true,
    color: tokens_default.color.theme[0],
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  const group = new Group_default();
  const mask = new Rect_default({
    style: {
      fill: opts.maskColor
    },
    zlevel: opts.zlevel,
    z: 1e4
  });
  group.add(mask);
  const textContent = new Text_default({
    style: {
      text: opts.text,
      fill: opts.textColor,
      fontSize: opts.fontSize,
      fontWeight: opts.fontWeight,
      fontStyle: opts.fontStyle,
      fontFamily: opts.fontFamily
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  const labelRect = new Rect_default({
    style: {
      fill: "none"
    },
    textContent,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  group.add(labelRect);
  let arc2;
  if (opts.showSpinner) {
    arc2 = new Arc_default({
      shape: {
        startAngle: -PI5 / 2,
        endAngle: -PI5 / 2 + 0.1,
        r: opts.spinnerRadius
      },
      style: {
        stroke: opts.color,
        lineCap: "round",
        lineWidth: opts.lineWidth
      },
      zlevel: opts.zlevel,
      z: 10001
    });
    arc2.animateShape(true).when(1e3, {
      endAngle: PI5 * 3 / 2
    }).start("circularInOut");
    arc2.animateShape(true).when(1e3, {
      startAngle: PI5 * 3 / 2
    }).delay(300).start("circularInOut");
    group.add(arc2);
  }
  group.resize = function() {
    const textWidth = textContent.getBoundingRect().width;
    const r = opts.showSpinner ? opts.spinnerRadius : 0;
    const cx = (api2.getWidth() - r * 2 - (opts.showSpinner && textWidth ? 10 : 0) - textWidth) / 2 - (opts.showSpinner && textWidth ? 0 : 5 + textWidth / 2) + (opts.showSpinner ? 0 : textWidth / 2) + (textWidth ? 0 : r);
    const cy = api2.getHeight() / 2;
    opts.showSpinner && arc2.setShape({
      cx,
      cy
    });
    labelRect.setShape({
      x: cx - r,
      y: cy - r,
      width: r * 2,
      height: r * 2
    });
    mask.setShape({
      x: 0,
      y: 0,
      width: api2.getWidth(),
      height: api2.getHeight()
    });
  };
  group.resize();
  return group;
}

// src/core/Scheduler.ts
var Scheduler = class {
  constructor(ecInstance, api2, dataProcessorHandlers, visualHandlers) {
    this._stageTaskMap = createHashMap();
    this.ecInstance = ecInstance;
    this.api = api2;
    dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();
    visualHandlers = this._visualHandlers = visualHandlers.slice();
    this._allHandlers = dataProcessorHandlers.concat(visualHandlers);
  }
  restoreData(ecModel, payload) {
    ecModel.restoreData(payload);
    this._stageTaskMap.each(function(taskRecord) {
      const overallTask = taskRecord.overallTask;
      overallTask && overallTask.dirty();
    });
  }
  getPerformArgs(task, isBlock) {
    if (!task.__pipeline) {
      return;
    }
    const pipeline = this._pipelineMap.get(task.__pipeline.id);
    const pCtx = pipeline.context;
    const incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;
    const step = incremental ? pipeline.step : null;
    const modDataCount = pCtx && pCtx.modDataCount;
    const modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;
    return {step, modBy, modDataCount};
  }
  getPipeline(pipelineId) {
    return this._pipelineMap.get(pipelineId);
  }
  updateStreamModes(seriesModel, view) {
    const pipeline = this._pipelineMap.get(seriesModel.uid);
    const data = seriesModel.getData();
    const dataLen = data.count();
    const progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;
    const large = seriesModel.get("large") && dataLen >= seriesModel.get("largeThreshold");
    const modDataCount = seriesModel.get("progressiveChunkMode") === "mod" ? dataLen : null;
    seriesModel.pipelineContext = pipeline.context = {
      progressiveRender,
      modDataCount,
      large
    };
  }
  restorePipelines(ecModel) {
    const scheduler = this;
    const pipelineMap = scheduler._pipelineMap = createHashMap();
    ecModel.eachSeries(function(seriesModel) {
      const progressive = seriesModel.getProgressive();
      const pipelineId = seriesModel.uid;
      pipelineMap.set(pipelineId, {
        id: pipelineId,
        head: null,
        tail: null,
        threshold: seriesModel.getProgressiveThreshold(),
        progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),
        blockIndex: -1,
        step: Math.round(progressive || 700),
        count: 0
      });
      scheduler._pipe(seriesModel, seriesModel.dataTask);
    });
  }
  prepareStageTasks() {
    const stageTaskMap = this._stageTaskMap;
    const ecModel = this.api.getModel();
    const api2 = this.api;
    each(this._allHandlers, function(handler) {
      const record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {});
      let errMsg = "";
      if (true) {
        errMsg = '"reset" and "overallReset" must not be both specified.';
      }
      assert(!(handler.reset && handler.overallReset), errMsg);
      handler.reset && this._createSeriesStageTask(handler, record, ecModel, api2);
      handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api2);
    }, this);
  }
  prepareView(view, model, ecModel, api2) {
    const renderTask = view.renderTask;
    const context = renderTask.context;
    context.model = model;
    context.ecModel = ecModel;
    context.api = api2;
    renderTask.__block = !view.incrementalPrepareRender;
    this._pipe(model, renderTask);
  }
  performDataProcessorTasks(ecModel, payload) {
    this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, {block: true});
  }
  performVisualTasks(ecModel, payload, opt) {
    this._performStageTasks(this._visualHandlers, ecModel, payload, opt);
  }
  _performStageTasks(stageHandlers, ecModel, payload, opt) {
    opt = opt || {};
    let unfinished = false;
    const scheduler = this;
    each(stageHandlers, function(stageHandler, idx) {
      if (opt.visualType && opt.visualType !== stageHandler.visualType) {
        return;
      }
      const stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);
      const seriesTaskMap = stageHandlerRecord.seriesTaskMap;
      const overallTask = stageHandlerRecord.overallTask;
      if (overallTask) {
        let overallNeedDirty;
        const agentStubMap = overallTask.agentStubMap;
        agentStubMap.each(function(stub) {
          if (needSetDirty(opt, stub)) {
            stub.dirty();
            overallNeedDirty = true;
          }
        });
        overallNeedDirty && overallTask.dirty();
        scheduler.updatePayload(overallTask, payload);
        const performArgs = scheduler.getPerformArgs(overallTask, opt.block);
        agentStubMap.each(function(stub) {
          stub.perform(performArgs);
        });
        if (overallTask.perform(performArgs)) {
          unfinished = true;
        }
      } else if (seriesTaskMap) {
        seriesTaskMap.each(function(task, pipelineId) {
          if (needSetDirty(opt, task)) {
            task.dirty();
          }
          const performArgs = scheduler.getPerformArgs(task, opt.block);
          performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);
          scheduler.updatePayload(task, payload);
          if (task.perform(performArgs)) {
            unfinished = true;
          }
        });
      }
    });
    function needSetDirty(opt2, task) {
      return opt2.setDirty && (!opt2.dirtyMap || opt2.dirtyMap.get(task.__pipeline.id));
    }
    this.unfinished = unfinished || this.unfinished;
  }
  performSeriesTasks(ecModel) {
    let unfinished;
    ecModel.eachSeries(function(seriesModel) {
      unfinished = seriesModel.dataTask.perform() || unfinished;
    });
    this.unfinished = unfinished || this.unfinished;
  }
  plan() {
    this._pipelineMap.each(function(pipeline) {
      let task = pipeline.tail;
      do {
        if (task.__block) {
          pipeline.blockIndex = task.__idxInPipeline;
          break;
        }
        task = task.getUpstream();
      } while (task);
    });
  }
  updatePayload(task, payload) {
    payload !== "remain" && (task.context.payload = payload);
  }
  _createSeriesStageTask(stageHandler, stageHandlerRecord, ecModel, api2) {
    const scheduler = this;
    const oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap;
    const newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = createHashMap();
    const seriesType2 = stageHandler.seriesType;
    const getTargetSeries = stageHandler.getTargetSeries;
    if (stageHandler.createOnAllSeries) {
      ecModel.eachRawSeries(create4);
    } else if (seriesType2) {
      ecModel.eachRawSeriesByType(seriesType2, create4);
    } else if (getTargetSeries) {
      getTargetSeries(ecModel, api2).each(create4);
    }
    function create4(seriesModel) {
      const pipelineId = seriesModel.uid;
      const task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || createTask({
        plan: seriesTaskPlan,
        reset: seriesTaskReset,
        count: seriesTaskCount
      }));
      task.context = {
        model: seriesModel,
        ecModel,
        api: api2,
        useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,
        plan: stageHandler.plan,
        reset: stageHandler.reset,
        scheduler
      };
      scheduler._pipe(seriesModel, task);
    }
  }
  _createOverallStageTask(stageHandler, stageHandlerRecord, ecModel, api2) {
    const scheduler = this;
    const overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || createTask({reset: overallTaskReset});
    overallTask.context = {
      ecModel,
      api: api2,
      overallReset: stageHandler.overallReset,
      scheduler
    };
    const oldAgentStubMap = overallTask.agentStubMap;
    const newAgentStubMap = overallTask.agentStubMap = createHashMap();
    const seriesType2 = stageHandler.seriesType;
    const getTargetSeries = stageHandler.getTargetSeries;
    let overallProgress = true;
    let shouldOverallTaskDirty = false;
    let errMsg = "";
    if (true) {
      errMsg = '"createOnAllSeries" is not supported for "overallReset", because it will block all streams.';
    }
    assert(!stageHandler.createOnAllSeries, errMsg);
    if (seriesType2) {
      ecModel.eachRawSeriesByType(seriesType2, createStub);
    } else if (getTargetSeries) {
      getTargetSeries(ecModel, api2).each(createStub);
    } else {
      overallProgress = false;
      each(ecModel.getSeries(), createStub);
    }
    function createStub(seriesModel) {
      const pipelineId = seriesModel.uid;
      const stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || (shouldOverallTaskDirty = true, createTask({reset: stubReset, onDirty: stubOnDirty})));
      stub.context = {
        model: seriesModel,
        overallProgress
      };
      stub.agent = overallTask;
      stub.__block = overallProgress;
      scheduler._pipe(seriesModel, stub);
    }
    if (shouldOverallTaskDirty) {
      overallTask.dirty();
    }
  }
  _pipe(seriesModel, task) {
    const pipelineId = seriesModel.uid;
    const pipeline = this._pipelineMap.get(pipelineId);
    !pipeline.head && (pipeline.head = task);
    pipeline.tail && pipeline.tail.pipe(task);
    pipeline.tail = task;
    task.__idxInPipeline = pipeline.count++;
    task.__pipeline = pipeline;
  }
  static wrapStageHandler(stageHandler, visualType) {
    if (isFunction(stageHandler)) {
      stageHandler = {
        overallReset: stageHandler,
        seriesType: detectSeriseType(stageHandler)
      };
    }
    stageHandler.uid = getUID("stageHandler");
    visualType && (stageHandler.visualType = visualType);
    return stageHandler;
  }
};
function overallTaskReset(context) {
  context.overallReset(context.ecModel, context.api, context.payload);
}
function stubReset(context) {
  return context.overallProgress && stubProgress;
}
function stubProgress() {
  this.agent.dirty();
  this.getDownstream().dirty();
}
function stubOnDirty() {
  this.agent && this.agent.dirty();
}
function seriesTaskPlan(context) {
  return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;
}
function seriesTaskReset(context) {
  if (context.useClearVisual) {
    context.data.clearAllVisual();
  }
  const resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));
  return resetDefines.length > 1 ? map(resetDefines, function(v, idx) {
    return makeSeriesTaskProgress(idx);
  }) : singleSeriesTaskProgress;
}
var singleSeriesTaskProgress = makeSeriesTaskProgress(0);
function makeSeriesTaskProgress(resetDefineIdx) {
  return function(params, context) {
    const data = context.data;
    const resetDefine = context.resetDefines[resetDefineIdx];
    if (resetDefine && resetDefine.dataEach) {
      for (let i = params.start; i < params.end; i++) {
        resetDefine.dataEach(data, i);
      }
    } else if (resetDefine && resetDefine.progress) {
      resetDefine.progress(params, data);
    }
  };
}
function seriesTaskCount(context) {
  return context.data.count();
}
function detectSeriseType(legacyFunc) {
  seriesType = null;
  try {
    legacyFunc(ecModelMock, apiMock);
  } catch (e2) {
  }
  return seriesType;
}
var ecModelMock = {};
var apiMock = {};
var seriesType;
mockMethods(ecModelMock, Global_default);
mockMethods(apiMock, ExtensionAPI_default);
ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function(type) {
  seriesType = type;
};
ecModelMock.eachComponent = function(cond) {
  if (cond.mainType === "series" && cond.subType) {
    seriesType = cond.subType;
  }
};
function mockMethods(target, Clz) {
  for (let name in Clz.prototype) {
    target[name] = noop;
  }
}
var Scheduler_default = Scheduler;

// src/theme/dark.ts
var color3 = tokens_default.darkColor;
var backgroundColor = color3.background;
var axisCommon = function() {
  return {
    axisLine: {
      lineStyle: {
        color: color3.axisLine
      }
    },
    splitLine: {
      lineStyle: {
        color: color3.axisSplitLine
      }
    },
    splitArea: {
      areaStyle: {
        color: [
          color3.backgroundTint,
          color3.backgroundTransparent
        ]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: color3.axisMinorSplitLine
      }
    },
    axisLabel: {
      color: color3.axisLabel
    },
    axisName: {}
  };
};
var matrixAxis = {
  label: {
    color: color3.secondary
  },
  itemStyle: {
    borderColor: color3.neutral20
  }
};
var theme = {
  darkMode: true,
  color: color3.theme,
  backgroundColor,
  axisPointer: {
    lineStyle: {
      color: color3.border
    },
    crossStyle: {
      color: color3.borderShade
    },
    label: {
      color: color3.tertiary
    }
  },
  legend: {
    textStyle: {
      color: color3.secondary
    },
    pageTextStyle: {
      color: color3.tertiary
    }
  },
  textStyle: {
    color: color3.secondary
  },
  title: {
    textStyle: {
      color: color3.primary
    },
    subtextStyle: {
      color: color3.quaternary
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: color3.accent50
    }
  },
  tooltip: {
    backgroundColor: color3.neutral20,
    defaultBorderColor: color3.border,
    textStyle: {
      color: color3.tertiary
    }
  },
  dataZoom: {
    borderColor: color3.accent10,
    textStyle: {
      color: color3.tertiary
    },
    brushStyle: {
      color: color3.backgroundTint
    },
    handleStyle: {
      color: color3.neutral00,
      borderColor: color3.accent20
    },
    moveHandleStyle: {
      color: color3.accent40
    },
    emphasis: {
      handleStyle: {
        borderColor: color3.accent50
      }
    },
    dataBackground: {
      lineStyle: {
        color: color3.accent30
      },
      areaStyle: {
        color: color3.accent20
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: color3.accent50
      },
      areaStyle: {
        color: color3.accent30
      }
    }
  },
  visualMap: {
    textStyle: {
      color: color3.secondary
    },
    inRange: {
      color: [color3.neutral10, color3.theme[0]]
    },
    handleStyle: {
      borderColor: color3.neutral30
    }
  },
  timeline: {
    lineStyle: {
      color: color3.accent10
    },
    label: {
      color: color3.tertiary
    },
    controlStyle: {
      color: color3.accent30,
      borderColor: color3.accent30
    }
  },
  calendar: {
    itemStyle: {
      color: color3.neutral00,
      borderColor: color3.neutral20
    },
    dayLabel: {
      color: color3.tertiary
    },
    monthLabel: {
      color: color3.secondary
    },
    yearLabel: {
      color: color3.secondary
    }
  },
  matrix: {
    x: matrixAxis,
    y: matrixAxis,
    backgroundColor: {
      borderColor: "#817f91"
    },
    innerBackgroundStyle: {
      borderColor: "#484753"
    }
  },
  timeAxis: axisCommon(),
  logAxis: axisCommon(),
  valueAxis: axisCommon(),
  categoryAxis: axisCommon(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: color3.theme
  },
  gauge: {
    title: {
      color: color3.secondary
    },
    axisLine: {
      lineStyle: {
        color: [[1, color3.neutral05]]
      }
    },
    axisLabel: {
      color: color3.axisLabel
    },
    detail: {
      color: color3.primary
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
    }
  },
  funnel: {
    itemStyle: {
      borderColor: color3.background
    }
  },
  radar: (() => {
    const radar = axisCommon();
    radar.axisName = {
      color: color3.axisLabel
    };
    radar.axisLine.lineStyle.color = color3.neutral20;
    return radar;
  })(),
  treemap: {
    breadcrumb: {
      itemStyle: {
        color: color3.neutral20,
        textStyle: {
          color: color3.secondary
        }
      },
      emphasis: {
        itemStyle: {
          color: color3.neutral30
        }
      }
    }
  },
  sunburst: {
    itemStyle: {
      borderColor: color3.background
    }
  },
  map: {
    itemStyle: {
      borderColor: color3.border,
      areaColor: color3.neutral10
    },
    label: {
      color: color3.tertiary
    },
    emphasis: {
      label: {
        color: color3.primary
      },
      itemStyle: {
        areaColor: color3.highlight
      }
    },
    select: {
      label: {
        color: color3.primary
      },
      itemStyle: {
        areaColor: color3.highlight
      }
    }
  },
  geo: {
    itemStyle: {
      borderColor: color3.border,
      areaColor: color3.neutral10
    },
    emphasis: {
      label: {
        color: color3.primary
      },
      itemStyle: {
        areaColor: color3.highlight
      }
    },
    select: {
      label: {
        color: color3.primary
      },
      itemStyle: {
        color: color3.highlight
      }
    }
  }
};
theme.categoryAxis.splitLine.show = false;
var dark_default = theme;

// src/util/ECEventProcessor.ts
var ECEventProcessor = class {
  normalizeQuery(query) {
    const cptQuery = {};
    const dataQuery = {};
    const otherQuery = {};
    if (isString(query)) {
      const condCptType = parseClassType(query);
      cptQuery.mainType = condCptType.main || null;
      cptQuery.subType = condCptType.sub || null;
    } else {
      const suffixes = ["Index", "Name", "Id"];
      const dataKeys = {name: 1, dataIndex: 1, dataType: 1};
      each(query, function(val, key) {
        let reserved = false;
        for (let i = 0; i < suffixes.length; i++) {
          const propSuffix = suffixes[i];
          const suffixPos = key.lastIndexOf(propSuffix);
          if (suffixPos > 0 && suffixPos === key.length - propSuffix.length) {
            const mainType = key.slice(0, suffixPos);
            if (mainType !== "data") {
              cptQuery.mainType = mainType;
              cptQuery[propSuffix.toLowerCase()] = val;
              reserved = true;
            }
          }
        }
        if (dataKeys.hasOwnProperty(key)) {
          dataQuery[key] = val;
          reserved = true;
        }
        if (!reserved) {
          otherQuery[key] = val;
        }
      });
    }
    return {
      cptQuery,
      dataQuery,
      otherQuery
    };
  }
  filter(eventType, query) {
    const eventInfo = this.eventInfo;
    if (!eventInfo) {
      return true;
    }
    const targetEl = eventInfo.targetEl;
    const packedEvent = eventInfo.packedEvent;
    const model = eventInfo.model;
    const view = eventInfo.view;
    if (!model || !view) {
      return true;
    }
    const cptQuery = query.cptQuery;
    const dataQuery = query.dataQuery;
    return check(cptQuery, model, "mainType") && check(cptQuery, model, "subType") && check(cptQuery, model, "index", "componentIndex") && check(cptQuery, model, "name") && check(cptQuery, model, "id") && check(dataQuery, packedEvent, "name") && check(dataQuery, packedEvent, "dataIndex") && check(dataQuery, packedEvent, "dataType") && (!view.filterForExposedEvent || view.filterForExposedEvent(eventType, query.otherQuery, targetEl, packedEvent));
    function check(query2, host, prop, propOnHost) {
      return query2[prop] == null || host[propOnHost || prop] === query2[prop];
    }
  }
  afterTrigger() {
    this.eventInfo = null;
  }
};

// src/visual/symbol.ts
var SYMBOL_PROPS_WITH_CB = [
  "symbol",
  "symbolSize",
  "symbolRotate",
  "symbolOffset"
];
var SYMBOL_PROPS = SYMBOL_PROPS_WITH_CB.concat([
  "symbolKeepAspect"
]);
var seriesSymbolTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    const data = seriesModel.getData();
    if (seriesModel.legendIcon) {
      data.setVisual("legendIcon", seriesModel.legendIcon);
    }
    if (!seriesModel.hasSymbolVisual) {
      return;
    }
    const symbolOptions = {};
    const symbolOptionsCb = {};
    let hasCallback = false;
    for (let i = 0; i < SYMBOL_PROPS_WITH_CB.length; i++) {
      const symbolPropName = SYMBOL_PROPS_WITH_CB[i];
      const val = seriesModel.get(symbolPropName);
      if (isFunction(val)) {
        hasCallback = true;
        symbolOptionsCb[symbolPropName] = val;
      } else {
        symbolOptions[symbolPropName] = val;
      }
    }
    symbolOptions.symbol = symbolOptions.symbol || seriesModel.defaultSymbol;
    data.setVisual(extend({
      legendIcon: seriesModel.legendIcon || symbolOptions.symbol,
      symbolKeepAspect: seriesModel.get("symbolKeepAspect")
    }, symbolOptions));
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    const symbolPropsCb = keys(symbolOptionsCb);
    function dataEach(data2, idx) {
      const rawValue = seriesModel.getRawValue(idx);
      const params = seriesModel.getDataParams(idx);
      for (let i = 0; i < symbolPropsCb.length; i++) {
        const symbolPropName = symbolPropsCb[i];
        data2.setItemVisual(idx, symbolPropName, symbolOptionsCb[symbolPropName](rawValue, params));
      }
    }
    return {dataEach: hasCallback ? dataEach : null};
  }
};
var dataSymbolTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    if (!seriesModel.hasSymbolVisual) {
      return;
    }
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    const data = seriesModel.getData();
    function dataEach(data2, idx) {
      const itemModel = data2.getItemModel(idx);
      for (let i = 0; i < SYMBOL_PROPS.length; i++) {
        const symbolPropName = SYMBOL_PROPS[i];
        const val = itemModel.getShallow(symbolPropName, true);
        if (val != null) {
          data2.setItemVisual(idx, symbolPropName, val);
        }
      }
    }
    return {dataEach: data.hasItemOption ? dataEach : null};
  }
};

// src/visual/helper.ts
function getItemVisualFromData(data, dataIndex, key) {
  switch (key) {
    case "color":
      const style = data.getItemVisual(dataIndex, "style");
      return style[data.getVisual("drawType")];
    case "opacity":
      return data.getItemVisual(dataIndex, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return data.getItemVisual(dataIndex, key);
    default:
      if (true) {
        console.warn(`Unknown visual type ${key}`);
      }
  }
}
function getVisualFromData(data, key) {
  switch (key) {
    case "color":
      const style = data.getVisual("style");
      return style[data.getVisual("drawType")];
    case "opacity":
      return data.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return data.getVisual(key);
    default:
      if (true) {
        console.warn(`Unknown visual type ${key}`);
      }
  }
}
function setItemVisualFromData(data, dataIndex, key, value) {
  switch (key) {
    case "color":
      const style = data.ensureUniqueItemVisual(dataIndex, "style");
      style[data.getVisual("drawType")] = value;
      data.setItemVisual(dataIndex, "colorFromPalette", false);
      break;
    case "opacity":
      data.ensureUniqueItemVisual(dataIndex, "style").opacity = value;
      break;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      data.setItemVisual(dataIndex, key, value);
      break;
    default:
      if (true) {
        console.warn(`Unknown visual type ${key}`);
      }
  }
}

// src/legacy/dataSelectAction.ts
function createLegacyDataSelectAction(seriesType2, ecRegisterAction) {
  function getSeriesIndices(ecModel, payload) {
    const seriesIndices = [];
    ecModel.eachComponent({
      mainType: "series",
      subType: seriesType2,
      query: payload
    }, function(seriesModel) {
      seriesIndices.push(seriesModel.seriesIndex);
    });
    return seriesIndices;
  }
  each([
    [seriesType2 + "ToggleSelect", "toggleSelect"],
    [seriesType2 + "Select", "select"],
    [seriesType2 + "UnSelect", "unselect"]
  ], function(eventsMap) {
    ecRegisterAction(eventsMap[0], function(payload, ecModel, api2) {
      payload = extend({}, payload);
      if (true) {
        deprecateReplaceLog(payload.type, eventsMap[1]);
      }
      api2.dispatchAction(extend(payload, {
        type: eventsMap[1],
        seriesIndex: getSeriesIndices(ecModel, payload)
      }));
    });
  });
}
function handleSeriesLegacySelectEvents(type, eventPostfix, ecIns, ecModel, payload) {
  const legacyEventName = type + eventPostfix;
  if (!ecIns.isSilent(legacyEventName)) {
    if (true) {
      deprecateLog(`event ${legacyEventName} is deprecated.`);
    }
    ecModel.eachComponent({
      mainType: "series",
      subType: "pie"
    }, function(seriesModel) {
      const seriesIndex = seriesModel.seriesIndex;
      const selectedMap = seriesModel.option.selectedMap;
      const selected = payload.selected;
      for (let i = 0; i < selected.length; i++) {
        if (selected[i].seriesIndex === seriesIndex) {
          const data = seriesModel.getData();
          const dataIndex = queryDataIndex(data, payload.fromActionPayload);
          ecIns.trigger(legacyEventName, {
            type: legacyEventName,
            seriesId: seriesModel.id,
            name: isArray(dataIndex) ? data.getName(dataIndex[0]) : data.getName(dataIndex),
            selected: isString(selectedMap) ? selectedMap : extend({}, selectedMap)
          });
        }
      }
    });
  }
}
function handleLegacySelectEvents(messageCenter, ecIns, api2) {
  messageCenter.on("selectchanged", function(params) {
    const ecModel = api2.getModel();
    if (params.isFromClick) {
      handleSeriesLegacySelectEvents("map", "selectchanged", ecIns, ecModel, params);
      handleSeriesLegacySelectEvents("pie", "selectchanged", ecIns, ecModel, params);
    } else if (params.fromAction === "select") {
      handleSeriesLegacySelectEvents("map", "selected", ecIns, ecModel, params);
      handleSeriesLegacySelectEvents("pie", "selected", ecIns, ecModel, params);
    } else if (params.fromAction === "unselect") {
      handleSeriesLegacySelectEvents("map", "unselected", ecIns, ecModel, params);
      handleSeriesLegacySelectEvents("pie", "unselected", ecIns, ecModel, params);
    }
  });
}

// src/util/event.ts
function findEventDispatcher(target, det, returnFirstMatch) {
  let found;
  while (target) {
    if (det(target)) {
      found = target;
      if (returnFirstMatch) {
        break;
      }
    }
    target = target.__hostTarget || target.parent;
  }
  return found;
}

// ../zrender/src/core/WeakMap.ts
var wmUniqueIndex = Math.round(Math.random() * 9);
var supportDefineProperty = typeof Object.defineProperty === "function";
var WeakMap = class {
  constructor() {
    this._id = "__ec_inner_" + wmUniqueIndex++;
  }
  get(key) {
    return this._guard(key)[this._id];
  }
  set(key, value) {
    const target = this._guard(key);
    if (supportDefineProperty) {
      Object.defineProperty(target, this._id, {
        value,
        enumerable: false,
        configurable: true
      });
    } else {
      target[this._id] = value;
    }
    return this;
  }
  delete(key) {
    if (this.has(key)) {
      delete this._guard(key)[this._id];
      return true;
    }
    return false;
  }
  has(key) {
    return !!this._guard(key)[this._id];
  }
  _guard(key) {
    if (key !== Object(key)) {
      throw TypeError("Value of WeakMap is not a non-null object.");
    }
    return key;
  }
};
var WeakMap_default = WeakMap;

// src/util/symbol.ts
var Triangle = Path_default.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(path, shape) {
    const cx = shape.cx;
    const cy = shape.cy;
    const width = shape.width / 2;
    const height = shape.height / 2;
    path.moveTo(cx, cy - height);
    path.lineTo(cx + width, cy + height);
    path.lineTo(cx - width, cy + height);
    path.closePath();
  }
});
var Diamond = Path_default.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(path, shape) {
    const cx = shape.cx;
    const cy = shape.cy;
    const width = shape.width / 2;
    const height = shape.height / 2;
    path.moveTo(cx, cy - height);
    path.lineTo(cx + width, cy);
    path.lineTo(cx, cy + height);
    path.lineTo(cx - width, cy);
    path.closePath();
  }
});
var Pin = Path_default.extend({
  type: "pin",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(path, shape) {
    const x = shape.x;
    const y = shape.y;
    const w = shape.width / 5 * 3;
    const h = Math.max(w, shape.height);
    const r = w / 2;
    const dy = r * r / (h - r);
    const cy = y - h + r + dy;
    const angle = Math.asin(dy / r);
    const dx = Math.cos(angle) * r;
    const tanX = Math.sin(angle);
    const tanY = Math.cos(angle);
    const cpLen = r * 0.6;
    const cpLen2 = r * 0.7;
    path.moveTo(x - dx, cy + dy);
    path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);
    path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);
    path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);
    path.closePath();
  }
});
var Arrow = Path_default.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(ctx, shape) {
    const height = shape.height;
    const width = shape.width;
    const x = shape.x;
    const y = shape.y;
    const dx = width / 3 * 2;
    ctx.moveTo(x, y);
    ctx.lineTo(x + dx, y + height);
    ctx.lineTo(x, y + height / 4 * 3);
    ctx.lineTo(x - dx, y + height);
    ctx.lineTo(x, y);
    ctx.closePath();
  }
});
var symbolCtors = {
  line: Line_default,
  rect: Rect_default,
  roundRect: Rect_default,
  square: Rect_default,
  circle: Circle_default,
  diamond: Diamond,
  pin: Pin,
  arrow: Arrow,
  triangle: Triangle
};
var symbolShapeMakers = {
  line: function(x, y, w, h, shape) {
    shape.x1 = x;
    shape.y1 = y + h / 2;
    shape.x2 = x + w;
    shape.y2 = y + h / 2;
  },
  rect: function(x, y, w, h, shape) {
    shape.x = x;
    shape.y = y;
    shape.width = w;
    shape.height = h;
  },
  roundRect: function(x, y, w, h, shape) {
    shape.x = x;
    shape.y = y;
    shape.width = w;
    shape.height = h;
    shape.r = Math.min(w, h) / 4;
  },
  square: function(x, y, w, h, shape) {
    const size = Math.min(w, h);
    shape.x = x;
    shape.y = y;
    shape.width = size;
    shape.height = size;
  },
  circle: function(x, y, w, h, shape) {
    shape.cx = x + w / 2;
    shape.cy = y + h / 2;
    shape.r = Math.min(w, h) / 2;
  },
  diamond: function(x, y, w, h, shape) {
    shape.cx = x + w / 2;
    shape.cy = y + h / 2;
    shape.width = w;
    shape.height = h;
  },
  pin: function(x, y, w, h, shape) {
    shape.x = x + w / 2;
    shape.y = y + h / 2;
    shape.width = w;
    shape.height = h;
  },
  arrow: function(x, y, w, h, shape) {
    shape.x = x + w / 2;
    shape.y = y + h / 2;
    shape.width = w;
    shape.height = h;
  },
  triangle: function(x, y, w, h, shape) {
    shape.cx = x + w / 2;
    shape.cy = y + h / 2;
    shape.width = w;
    shape.height = h;
  }
};
var symbolBuildProxies = {};
each(symbolCtors, function(Ctor, name) {
  symbolBuildProxies[name] = new Ctor();
});
var SymbolClz = Path_default.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition(out2, config, rect) {
    const res = calculateTextPosition(out2, config, rect);
    const shape = this.shape;
    if (shape && shape.symbolType === "pin" && config.position === "inside") {
      res.y = rect.y + rect.height * 0.4;
    }
    return res;
  },
  buildPath(ctx, shape, inBundle) {
    let symbolType = shape.symbolType;
    if (symbolType !== "none") {
      let proxySymbol = symbolBuildProxies[symbolType];
      if (!proxySymbol) {
        symbolType = "rect";
        proxySymbol = symbolBuildProxies[symbolType];
      }
      symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
      proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
    }
  }
});
function symbolPathSetColor(color4, innerColor2) {
  if (this.type !== "image") {
    const symbolStyle = this.style;
    if (this.__isEmptyBrush) {
      symbolStyle.stroke = color4;
      symbolStyle.fill = innerColor2 || tokens_default.color.neutral00;
      symbolStyle.lineWidth = 2;
    } else if (this.shape.symbolType === "line") {
      symbolStyle.stroke = color4;
    } else {
      symbolStyle.fill = color4;
    }
    this.markRedraw();
  }
}
function createSymbol(symbolType, x, y, w, h, color4, keepAspect) {
  const isEmpty = symbolType.indexOf("empty") === 0;
  if (isEmpty) {
    symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
  }
  let symbolPath;
  if (symbolType.indexOf("image://") === 0) {
    symbolPath = makeImage(symbolType.slice(8), new BoundingRect_default(x, y, w, h), keepAspect ? "center" : "cover");
  } else if (symbolType.indexOf("path://") === 0) {
    symbolPath = makePath(symbolType.slice(7), {}, new BoundingRect_default(x, y, w, h), keepAspect ? "center" : "cover");
  } else {
    symbolPath = new SymbolClz({
      shape: {
        symbolType,
        x,
        y,
        width: w,
        height: h
      }
    });
  }
  symbolPath.__isEmptyBrush = isEmpty;
  symbolPath.setColor = symbolPathSetColor;
  if (color4) {
    symbolPath.setColor(color4);
  }
  return symbolPath;
}
function normalizeSymbolSize(symbolSize) {
  if (!isArray(symbolSize)) {
    symbolSize = [+symbolSize, +symbolSize];
  }
  return [symbolSize[0] || 0, symbolSize[1] || 0];
}
function normalizeSymbolOffset(symbolOffset, symbolSize) {
  if (symbolOffset == null) {
    return;
  }
  if (!isArray(symbolOffset)) {
    symbolOffset = [symbolOffset, symbolOffset];
  }
  return [
    parsePercent2(symbolOffset[0], symbolSize[0]) || 0,
    parsePercent2(retrieve2(symbolOffset[1], symbolOffset[0]), symbolSize[1]) || 0
  ];
}

// ../zrender/src/canvas/helper.ts
function isSafeNum(num) {
  return isFinite(num);
}
function createLinearGradient(ctx, obj, rect) {
  let x = obj.x == null ? 0 : obj.x;
  let x2 = obj.x2 == null ? 1 : obj.x2;
  let y = obj.y == null ? 0 : obj.y;
  let y2 = obj.y2 == null ? 0 : obj.y2;
  if (!obj.global) {
    x = x * rect.width + rect.x;
    x2 = x2 * rect.width + rect.x;
    y = y * rect.height + rect.y;
    y2 = y2 * rect.height + rect.y;
  }
  x = isSafeNum(x) ? x : 0;
  x2 = isSafeNum(x2) ? x2 : 1;
  y = isSafeNum(y) ? y : 0;
  y2 = isSafeNum(y2) ? y2 : 0;
  const canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
  return canvasGradient;
}
function createRadialGradient(ctx, obj, rect) {
  const width = rect.width;
  const height = rect.height;
  const min3 = Math.min(width, height);
  let x = obj.x == null ? 0.5 : obj.x;
  let y = obj.y == null ? 0.5 : obj.y;
  let r = obj.r == null ? 0.5 : obj.r;
  if (!obj.global) {
    x = x * width + rect.x;
    y = y * height + rect.y;
    r = r * min3;
  }
  x = isSafeNum(x) ? x : 0.5;
  y = isSafeNum(y) ? y : 0.5;
  r = r >= 0 && isSafeNum(r) ? r : 0.5;
  const canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
  return canvasGradient;
}
function getCanvasGradient(ctx, obj, rect) {
  const canvasGradient = obj.type === "radial" ? createRadialGradient(ctx, obj, rect) : createLinearGradient(ctx, obj, rect);
  const colorStops = obj.colorStops;
  for (let i = 0; i < colorStops.length; i++) {
    canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
  }
  return canvasGradient;
}
function isClipPathChanged(clipPaths, prevClipPaths) {
  if (clipPaths === prevClipPaths || !clipPaths && !prevClipPaths) {
    return false;
  }
  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
    return true;
  }
  for (let i = 0; i < clipPaths.length; i++) {
    if (clipPaths[i] !== prevClipPaths[i]) {
      return true;
    }
  }
  return false;
}
function parseInt10(val) {
  return parseInt(val, 10);
}
function getSize(root, whIdx, opts) {
  const wh = ["width", "height"][whIdx];
  const cwh = ["clientWidth", "clientHeight"][whIdx];
  const plt = ["paddingLeft", "paddingTop"][whIdx];
  const prb = ["paddingRight", "paddingBottom"][whIdx];
  if (opts[wh] != null && opts[wh] !== "auto") {
    return parseFloat(opts[wh]);
  }
  const stl = document.defaultView.getComputedStyle(root);
  return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
}

// ../zrender/src/canvas/dashStyle.ts
function normalizeLineDash(lineType, lineWidth) {
  if (!lineType || lineType === "solid" || !(lineWidth > 0)) {
    return null;
  }
  return lineType === "dashed" ? [4 * lineWidth, 2 * lineWidth] : lineType === "dotted" ? [lineWidth] : isNumber(lineType) ? [lineType] : isArray(lineType) ? lineType : null;
}
function getLineDash(el) {
  const style = el.style;
  let lineDash = style.lineDash && style.lineWidth > 0 && normalizeLineDash(style.lineDash, style.lineWidth);
  let lineDashOffset = style.lineDashOffset;
  if (lineDash) {
    const lineScale = style.strokeNoScale && el.getLineScale ? el.getLineScale() : 1;
    if (lineScale && lineScale !== 1) {
      lineDash = map(lineDash, function(rawVal) {
        return rawVal / lineScale;
      });
      lineDashOffset /= lineScale;
    }
  }
  return [lineDash, lineDashOffset];
}

// ../zrender/src/canvas/graphic.ts
var pathProxyForDraw = new PathProxy_default(true);
function styleHasStroke(style) {
  const stroke = style.stroke;
  return !(stroke == null || stroke === "none" || !(style.lineWidth > 0));
}
function isValidStrokeFillStyle(strokeOrFill) {
  return typeof strokeOrFill === "string" && strokeOrFill !== "none";
}
function styleHasFill(style) {
  const fill = style.fill;
  return fill != null && fill !== "none";
}
function doFillPath(ctx, style) {
  if (style.fillOpacity != null && style.fillOpacity !== 1) {
    const originalGlobalAlpha = ctx.globalAlpha;
    ctx.globalAlpha = style.fillOpacity * style.opacity;
    ctx.fill();
    ctx.globalAlpha = originalGlobalAlpha;
  } else {
    ctx.fill();
  }
}
function doStrokePath(ctx, style) {
  if (style.strokeOpacity != null && style.strokeOpacity !== 1) {
    const originalGlobalAlpha = ctx.globalAlpha;
    ctx.globalAlpha = style.strokeOpacity * style.opacity;
    ctx.stroke();
    ctx.globalAlpha = originalGlobalAlpha;
  } else {
    ctx.stroke();
  }
}
function createCanvasPattern(ctx, pattern, el) {
  const image = createOrUpdateImage(pattern.image, pattern.__image, el);
  if (isImageReady(image)) {
    const canvasPattern = ctx.createPattern(image, pattern.repeat || "repeat");
    if (typeof DOMMatrix === "function" && canvasPattern && canvasPattern.setTransform) {
      const matrix14 = new DOMMatrix();
      matrix14.translateSelf(pattern.x || 0, pattern.y || 0);
      matrix14.rotateSelf(0, 0, (pattern.rotation || 0) * RADIAN_TO_DEGREE);
      matrix14.scaleSelf(pattern.scaleX || 1, pattern.scaleY || 1);
      canvasPattern.setTransform(matrix14);
    }
    return canvasPattern;
  }
}
function brushPath(ctx, el, style, inBatch) {
  let hasStroke = styleHasStroke(style);
  let hasFill = styleHasFill(style);
  const strokePercent = style.strokePercent;
  const strokePart = strokePercent < 1;
  const firstDraw = !el.path;
  if ((!el.silent || strokePart) && firstDraw) {
    el.createPathProxy();
  }
  const path = el.path || pathProxyForDraw;
  const dirtyFlag = el.__dirty;
  if (!inBatch) {
    const fill = style.fill;
    const stroke = style.stroke;
    const hasFillGradient = hasFill && !!fill.colorStops;
    const hasStrokeGradient = hasStroke && !!stroke.colorStops;
    const hasFillPattern = hasFill && !!fill.image;
    const hasStrokePattern = hasStroke && !!stroke.image;
    let fillGradient;
    let strokeGradient;
    let fillPattern;
    let strokePattern;
    let rect;
    if (hasFillGradient || hasStrokeGradient) {
      rect = el.getBoundingRect();
    }
    if (hasFillGradient) {
      fillGradient = dirtyFlag ? getCanvasGradient(ctx, fill, rect) : el.__canvasFillGradient;
      el.__canvasFillGradient = fillGradient;
    }
    if (hasStrokeGradient) {
      strokeGradient = dirtyFlag ? getCanvasGradient(ctx, stroke, rect) : el.__canvasStrokeGradient;
      el.__canvasStrokeGradient = strokeGradient;
    }
    if (hasFillPattern) {
      fillPattern = dirtyFlag || !el.__canvasFillPattern ? createCanvasPattern(ctx, fill, el) : el.__canvasFillPattern;
      el.__canvasFillPattern = fillPattern;
    }
    if (hasStrokePattern) {
      strokePattern = dirtyFlag || !el.__canvasStrokePattern ? createCanvasPattern(ctx, stroke, el) : el.__canvasStrokePattern;
      el.__canvasStrokePattern = strokePattern;
    }
    if (hasFillGradient) {
      ctx.fillStyle = fillGradient;
    } else if (hasFillPattern) {
      if (fillPattern) {
        ctx.fillStyle = fillPattern;
      } else {
        hasFill = false;
      }
    }
    if (hasStrokeGradient) {
      ctx.strokeStyle = strokeGradient;
    } else if (hasStrokePattern) {
      if (strokePattern) {
        ctx.strokeStyle = strokePattern;
      } else {
        hasStroke = false;
      }
    }
  }
  const scale4 = el.getGlobalScale();
  path.setScale(scale4[0], scale4[1], el.segmentIgnoreThreshold);
  let lineDash;
  let lineDashOffset;
  if (ctx.setLineDash && style.lineDash) {
    [lineDash, lineDashOffset] = getLineDash(el);
  }
  let needsRebuild = true;
  if (firstDraw || dirtyFlag & SHAPE_CHANGED_BIT) {
    path.setDPR(ctx.dpr);
    if (strokePart) {
      path.setContext(null);
    } else {
      path.setContext(ctx);
      needsRebuild = false;
    }
    path.reset();
    el.buildPath(path, el.shape, inBatch);
    path.toStatic();
    el.pathUpdated();
  }
  if (needsRebuild) {
    path.rebuildPath(ctx, strokePart ? strokePercent : 1);
  }
  if (lineDash) {
    ctx.setLineDash(lineDash);
    ctx.lineDashOffset = lineDashOffset;
  }
  if (!inBatch) {
    if (style.strokeFirst) {
      if (hasStroke) {
        doStrokePath(ctx, style);
      }
      if (hasFill) {
        doFillPath(ctx, style);
      }
    } else {
      if (hasFill) {
        doFillPath(ctx, style);
      }
      if (hasStroke) {
        doStrokePath(ctx, style);
      }
    }
  }
  if (lineDash) {
    ctx.setLineDash([]);
  }
}
function brushImage(ctx, el, style) {
  const image = el.__image = createOrUpdateImage(style.image, el.__image, el, el.onload);
  if (!image || !isImageReady(image)) {
    return;
  }
  const x = style.x || 0;
  const y = style.y || 0;
  let width = el.getWidth();
  let height = el.getHeight();
  const aspect = image.width / image.height;
  if (width == null && height != null) {
    width = height * aspect;
  } else if (height == null && width != null) {
    height = width / aspect;
  } else if (width == null && height == null) {
    width = image.width;
    height = image.height;
  }
  if (style.sWidth && style.sHeight) {
    const sx = style.sx || 0;
    const sy = style.sy || 0;
    ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
  } else if (style.sx && style.sy) {
    const sx = style.sx;
    const sy = style.sy;
    const sWidth = width - sx;
    const sHeight = height - sy;
    ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
  } else {
    ctx.drawImage(image, x, y, width, height);
  }
}
function brushText(ctx, el, style) {
  let text = style.text;
  text != null && (text += "");
  if (text) {
    ctx.font = style.font || DEFAULT_FONT;
    ctx.textAlign = style.textAlign;
    ctx.textBaseline = style.textBaseline;
    let lineDash;
    let lineDashOffset;
    if (ctx.setLineDash && style.lineDash) {
      [lineDash, lineDashOffset] = getLineDash(el);
    }
    if (lineDash) {
      ctx.setLineDash(lineDash);
      ctx.lineDashOffset = lineDashOffset;
    }
    if (style.strokeFirst) {
      if (styleHasStroke(style)) {
        ctx.strokeText(text, style.x, style.y);
      }
      if (styleHasFill(style)) {
        ctx.fillText(text, style.x, style.y);
      }
    } else {
      if (styleHasFill(style)) {
        ctx.fillText(text, style.x, style.y);
      }
      if (styleHasStroke(style)) {
        ctx.strokeText(text, style.x, style.y);
      }
    }
    if (lineDash) {
      ctx.setLineDash([]);
    }
  }
}
var SHADOW_NUMBER_PROPS = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"];
var STROKE_PROPS = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function bindCommonProps(ctx, style, prevStyle, forceSetAll, scope) {
  let styleChanged = false;
  if (!forceSetAll) {
    prevStyle = prevStyle || {};
    if (style === prevStyle) {
      return false;
    }
  }
  if (forceSetAll || style.opacity !== prevStyle.opacity) {
    flushPathDrawn(ctx, scope);
    styleChanged = true;
    const opacity = Math.max(Math.min(style.opacity, 1), 0);
    ctx.globalAlpha = isNaN(opacity) ? DEFAULT_COMMON_STYLE.opacity : opacity;
  }
  if (forceSetAll || style.blend !== prevStyle.blend) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    ctx.globalCompositeOperation = style.blend || DEFAULT_COMMON_STYLE.blend;
  }
  for (let i = 0; i < SHADOW_NUMBER_PROPS.length; i++) {
    const propName = SHADOW_NUMBER_PROPS[i];
    if (forceSetAll || style[propName] !== prevStyle[propName]) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx[propName] = ctx.dpr * (style[propName] || 0);
    }
  }
  if (forceSetAll || style.shadowColor !== prevStyle.shadowColor) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    ctx.shadowColor = style.shadowColor || DEFAULT_COMMON_STYLE.shadowColor;
  }
  return styleChanged;
}
function bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetAll, scope) {
  const style = getStyle(el, scope.inHover);
  const prevStyle = forceSetAll ? null : prevEl && getStyle(prevEl, scope.inHover) || {};
  if (style === prevStyle) {
    return false;
  }
  let styleChanged = bindCommonProps(ctx, style, prevStyle, forceSetAll, scope);
  if (forceSetAll || style.fill !== prevStyle.fill) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    isValidStrokeFillStyle(style.fill) && (ctx.fillStyle = style.fill);
  }
  if (forceSetAll || style.stroke !== prevStyle.stroke) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    isValidStrokeFillStyle(style.stroke) && (ctx.strokeStyle = style.stroke);
  }
  if (forceSetAll || style.opacity !== prevStyle.opacity) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
  }
  if (el.hasStroke()) {
    const lineWidth = style.lineWidth;
    const newLineWidth = lineWidth / (style.strokeNoScale && el.getLineScale ? el.getLineScale() : 1);
    if (ctx.lineWidth !== newLineWidth) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx.lineWidth = newLineWidth;
    }
  }
  for (let i = 0; i < STROKE_PROPS.length; i++) {
    const prop = STROKE_PROPS[i];
    const propName = prop[0];
    if (forceSetAll || style[propName] !== prevStyle[propName]) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx[propName] = style[propName] || prop[1];
    }
  }
  return styleChanged;
}
function bindImageStyle(ctx, el, prevEl, forceSetAll, scope) {
  return bindCommonProps(ctx, getStyle(el, scope.inHover), prevEl && getStyle(prevEl, scope.inHover), forceSetAll, scope);
}
function setContextTransform(ctx, el) {
  const m2 = el.transform;
  const dpr2 = ctx.dpr || 1;
  if (m2) {
    ctx.setTransform(dpr2 * m2[0], dpr2 * m2[1], dpr2 * m2[2], dpr2 * m2[3], dpr2 * m2[4], dpr2 * m2[5]);
  } else {
    ctx.setTransform(dpr2, 0, 0, dpr2, 0, 0);
  }
}
function updateClipStatus(clipPaths, ctx, scope) {
  let allClipped = false;
  for (let i = 0; i < clipPaths.length; i++) {
    const clipPath = clipPaths[i];
    allClipped = allClipped || clipPath.isZeroArea();
    setContextTransform(ctx, clipPath);
    ctx.beginPath();
    clipPath.buildPath(ctx, clipPath.shape);
    ctx.clip();
  }
  scope.allClipped = allClipped;
}
function isTransformChanged(m0, m1) {
  if (m0 && m1) {
    return m0[0] !== m1[0] || m0[1] !== m1[1] || m0[2] !== m1[2] || m0[3] !== m1[3] || m0[4] !== m1[4] || m0[5] !== m1[5];
  } else if (!m0 && !m1) {
    return false;
  }
  return true;
}
var DRAW_TYPE_PATH = 1;
var DRAW_TYPE_IMAGE = 2;
var DRAW_TYPE_TEXT = 3;
var DRAW_TYPE_INCREMENTAL = 4;
function canPathBatch(style) {
  const hasFill = styleHasFill(style);
  const hasStroke = styleHasStroke(style);
  return !(style.lineDash || !(+hasFill ^ +hasStroke) || hasFill && typeof style.fill !== "string" || hasStroke && typeof style.stroke !== "string" || style.strokePercent < 1 || style.strokeOpacity < 1 || style.fillOpacity < 1);
}
function flushPathDrawn(ctx, scope) {
  scope.batchFill && ctx.fill();
  scope.batchStroke && ctx.stroke();
  scope.batchFill = "";
  scope.batchStroke = "";
}
function getStyle(el, inHover) {
  return inHover ? el.__hoverStyle || el.style : el.style;
}
function brushSingle(ctx, el) {
  brush(ctx, el, {inHover: false, viewWidth: 0, viewHeight: 0}, true);
}
function brush(ctx, el, scope, isLast) {
  const m2 = el.transform;
  if (!el.shouldBePainted(scope.viewWidth, scope.viewHeight, false, false)) {
    el.__dirty &= ~REDRAW_BIT;
    el.__isRendered = false;
    return;
  }
  const clipPaths = el.__clipPaths;
  const prevElClipPaths = scope.prevElClipPaths;
  let forceSetTransform = false;
  let forceSetStyle = false;
  if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {
    if (prevElClipPaths && prevElClipPaths.length) {
      flushPathDrawn(ctx, scope);
      ctx.restore();
      forceSetStyle = forceSetTransform = true;
      scope.prevElClipPaths = null;
      scope.allClipped = false;
      scope.prevEl = null;
    }
    if (clipPaths && clipPaths.length) {
      flushPathDrawn(ctx, scope);
      ctx.save();
      updateClipStatus(clipPaths, ctx, scope);
      forceSetTransform = true;
    }
    scope.prevElClipPaths = clipPaths;
  }
  if (scope.allClipped) {
    el.__isRendered = false;
    return;
  }
  el.beforeBrush && el.beforeBrush();
  el.innerBeforeBrush();
  const prevEl = scope.prevEl;
  if (!prevEl) {
    forceSetStyle = forceSetTransform = true;
  }
  let canBatchPath = el instanceof Path_default && el.autoBatch && canPathBatch(el.style);
  if (forceSetTransform || isTransformChanged(m2, prevEl.transform)) {
    flushPathDrawn(ctx, scope);
    setContextTransform(ctx, el);
  } else if (!canBatchPath) {
    flushPathDrawn(ctx, scope);
  }
  const style = getStyle(el, scope.inHover);
  if (el instanceof Path_default) {
    if (scope.lastDrawType !== DRAW_TYPE_PATH) {
      forceSetStyle = true;
      scope.lastDrawType = DRAW_TYPE_PATH;
    }
    bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
    if (!canBatchPath || !scope.batchFill && !scope.batchStroke) {
      ctx.beginPath();
    }
    brushPath(ctx, el, style, canBatchPath);
    if (canBatchPath) {
      scope.batchFill = style.fill || "";
      scope.batchStroke = style.stroke || "";
    }
  } else {
    if (el instanceof TSpan_default) {
      if (scope.lastDrawType !== DRAW_TYPE_TEXT) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_TEXT;
      }
      bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
      brushText(ctx, el, style);
    } else if (el instanceof Image_default) {
      if (scope.lastDrawType !== DRAW_TYPE_IMAGE) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_IMAGE;
      }
      bindImageStyle(ctx, el, prevEl, forceSetStyle, scope);
      brushImage(ctx, el, style);
    } else if (el.getTemporalDisplayables) {
      if (scope.lastDrawType !== DRAW_TYPE_INCREMENTAL) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_INCREMENTAL;
      }
      brushIncremental(ctx, el, scope);
    }
  }
  if (canBatchPath && isLast) {
    flushPathDrawn(ctx, scope);
  }
  el.innerAfterBrush();
  el.afterBrush && el.afterBrush();
  scope.prevEl = el;
  el.__dirty = 0;
  el.__isRendered = true;
}
function brushIncremental(ctx, el, scope) {
  let displayables = el.getDisplayables();
  let temporalDisplayables = el.getTemporalDisplayables();
  ctx.save();
  let innerScope = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: false,
    viewWidth: scope.viewWidth,
    viewHeight: scope.viewHeight,
    inHover: scope.inHover
  };
  let i;
  let len2;
  for (i = el.getCursor(), len2 = displayables.length; i < len2; i++) {
    const displayable = displayables[i];
    displayable.beforeBrush && displayable.beforeBrush();
    displayable.innerBeforeBrush();
    brush(ctx, displayable, innerScope, i === len2 - 1);
    displayable.innerAfterBrush();
    displayable.afterBrush && displayable.afterBrush();
    innerScope.prevEl = displayable;
  }
  for (let i2 = 0, len3 = temporalDisplayables.length; i2 < len3; i2++) {
    const displayable = temporalDisplayables[i2];
    displayable.beforeBrush && displayable.beforeBrush();
    displayable.innerBeforeBrush();
    brush(ctx, displayable, innerScope, i2 === len3 - 1);
    displayable.innerAfterBrush();
    displayable.afterBrush && displayable.afterBrush();
    innerScope.prevEl = displayable;
  }
  el.clearTemporalDisplayables();
  el.notClear = true;
  ctx.restore();
}

// src/util/decal.ts
var decalMap = new WeakMap_default();
var decalCache = new LRU_default(100);
var decalKeys = [
  "symbol",
  "symbolSize",
  "symbolKeepAspect",
  "color",
  "backgroundColor",
  "dashArrayX",
  "dashArrayY",
  "maxTileWidth",
  "maxTileHeight"
];
function createOrUpdatePatternFromDecal(decalObject, api2) {
  if (decalObject === "none") {
    return null;
  }
  const dpr2 = api2.getDevicePixelRatio();
  const zr = api2.getZr();
  const isSVG = zr.painter.type === "svg";
  if (decalObject.dirty) {
    decalMap.delete(decalObject);
  }
  const oldPattern = decalMap.get(decalObject);
  if (oldPattern) {
    return oldPattern;
  }
  const decalOpt = defaults(decalObject, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: true,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  if (decalOpt.backgroundColor === "none") {
    decalOpt.backgroundColor = null;
  }
  const pattern = {repeat: "repeat"};
  setPatternnSource(pattern);
  pattern.rotation = decalOpt.rotation;
  pattern.scaleX = pattern.scaleY = isSVG ? 1 : 1 / dpr2;
  decalMap.set(decalObject, pattern);
  decalObject.dirty = false;
  return pattern;
  function setPatternnSource(pattern2) {
    const keys2 = [dpr2];
    let isValidKey = true;
    for (let i = 0; i < decalKeys.length; ++i) {
      const value = decalOpt[decalKeys[i]];
      if (value != null && !isArray(value) && !isString(value) && !isNumber(value) && typeof value !== "boolean") {
        isValidKey = false;
        break;
      }
      keys2.push(value);
    }
    let cacheKey;
    if (isValidKey) {
      cacheKey = keys2.join(",") + (isSVG ? "-svg" : "");
      const cache = decalCache.get(cacheKey);
      if (cache) {
        isSVG ? pattern2.svgElement = cache : pattern2.image = cache;
      }
    }
    const dashArrayX = normalizeDashArrayX(decalOpt.dashArrayX);
    const dashArrayY = normalizeDashArrayY(decalOpt.dashArrayY);
    const symbolArray = normalizeSymbolArray(decalOpt.symbol);
    const lineBlockLengthsX = getLineBlockLengthX(dashArrayX);
    const lineBlockLengthY = getLineBlockLengthY(dashArrayY);
    const canvas = !isSVG && platformApi.createCanvas();
    const svgRoot = isSVG && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    };
    const pSize = getPatternSize();
    let ctx;
    if (canvas) {
      canvas.width = pSize.width * dpr2;
      canvas.height = pSize.height * dpr2;
      ctx = canvas.getContext("2d");
    }
    brushDecal();
    if (isValidKey) {
      decalCache.put(cacheKey, canvas || svgRoot);
    }
    pattern2.image = canvas;
    pattern2.svgElement = svgRoot;
    pattern2.svgWidth = pSize.width;
    pattern2.svgHeight = pSize.height;
    function getPatternSize() {
      let width = 1;
      for (let i = 0, xlen = lineBlockLengthsX.length; i < xlen; ++i) {
        width = getLeastCommonMultiple(width, lineBlockLengthsX[i]);
      }
      let symbolRepeats = 1;
      for (let i = 0, xlen = symbolArray.length; i < xlen; ++i) {
        symbolRepeats = getLeastCommonMultiple(symbolRepeats, symbolArray[i].length);
      }
      width *= symbolRepeats;
      const height = lineBlockLengthY * lineBlockLengthsX.length * symbolArray.length;
      if (true) {
        const warn2 = (attrName) => {
          console.warn(`Calculated decal size is greater than ${attrName} due to decal option settings so ${attrName} is used for the decal size. Please consider changing the decal option to make a smaller decal or set ${attrName} to be larger to avoid incontinuity.`);
        };
        if (width > decalOpt.maxTileWidth) {
          warn2("maxTileWidth");
        }
        if (height > decalOpt.maxTileHeight) {
          warn2("maxTileHeight");
        }
      }
      return {
        width: Math.max(1, Math.min(width, decalOpt.maxTileWidth)),
        height: Math.max(1, Math.min(height, decalOpt.maxTileHeight))
      };
    }
    function brushDecal() {
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (decalOpt.backgroundColor) {
          ctx.fillStyle = decalOpt.backgroundColor;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
      }
      let ySum = 0;
      for (let i = 0; i < dashArrayY.length; ++i) {
        ySum += dashArrayY[i];
      }
      if (ySum <= 0) {
        return;
      }
      let y = -lineBlockLengthY;
      let yId = 0;
      let yIdTotal = 0;
      let xId0 = 0;
      while (y < pSize.height) {
        if (yId % 2 === 0) {
          const symbolYId = yIdTotal / 2 % symbolArray.length;
          let x = 0;
          let xId1 = 0;
          let xId1Total = 0;
          while (x < pSize.width * 2) {
            let xSum = 0;
            for (let i = 0; i < dashArrayX[xId0].length; ++i) {
              xSum += dashArrayX[xId0][i];
            }
            if (xSum <= 0) {
              break;
            }
            if (xId1 % 2 === 0) {
              const size = (1 - decalOpt.symbolSize) * 0.5;
              const left = x + dashArrayX[xId0][xId1] * size;
              const top = y + dashArrayY[yId] * size;
              const width = dashArrayX[xId0][xId1] * decalOpt.symbolSize;
              const height = dashArrayY[yId] * decalOpt.symbolSize;
              const symbolXId = xId1Total / 2 % symbolArray[symbolYId].length;
              brushSymbol(left, top, width, height, symbolArray[symbolYId][symbolXId]);
            }
            x += dashArrayX[xId0][xId1];
            ++xId1Total;
            ++xId1;
            if (xId1 === dashArrayX[xId0].length) {
              xId1 = 0;
            }
          }
          ++xId0;
          if (xId0 === dashArrayX.length) {
            xId0 = 0;
          }
        }
        y += dashArrayY[yId];
        ++yIdTotal;
        ++yId;
        if (yId === dashArrayY.length) {
          yId = 0;
        }
      }
      function brushSymbol(x, y2, width, height, symbolType) {
        const scale4 = isSVG ? 1 : dpr2;
        const symbol = createSymbol(symbolType, x * scale4, y2 * scale4, width * scale4, height * scale4, decalOpt.color, decalOpt.symbolKeepAspect);
        if (isSVG) {
          const symbolVNode = zr.painter.renderOneToVNode(symbol);
          if (symbolVNode) {
            svgRoot.children.push(symbolVNode);
          }
        } else {
          brushSingle(ctx, symbol);
        }
      }
    }
  }
}
function normalizeSymbolArray(symbol) {
  if (!symbol || symbol.length === 0) {
    return [["rect"]];
  }
  if (isString(symbol)) {
    return [[symbol]];
  }
  let isAllString = true;
  for (let i = 0; i < symbol.length; ++i) {
    if (!isString(symbol[i])) {
      isAllString = false;
      break;
    }
  }
  if (isAllString) {
    return normalizeSymbolArray([symbol]);
  }
  const result = [];
  for (let i = 0; i < symbol.length; ++i) {
    if (isString(symbol[i])) {
      result.push([symbol[i]]);
    } else {
      result.push(symbol[i]);
    }
  }
  return result;
}
function normalizeDashArrayX(dash) {
  if (!dash || dash.length === 0) {
    return [[0, 0]];
  }
  if (isNumber(dash)) {
    const dashValue = Math.ceil(dash);
    return [[dashValue, dashValue]];
  }
  let isAllNumber = true;
  for (let i = 0; i < dash.length; ++i) {
    if (!isNumber(dash[i])) {
      isAllNumber = false;
      break;
    }
  }
  if (isAllNumber) {
    return normalizeDashArrayX([dash]);
  }
  const result = [];
  for (let i = 0; i < dash.length; ++i) {
    if (isNumber(dash[i])) {
      const dashValue = Math.ceil(dash[i]);
      result.push([dashValue, dashValue]);
    } else {
      const dashValue = map(dash[i], (n) => Math.ceil(n));
      if (dashValue.length % 2 === 1) {
        result.push(dashValue.concat(dashValue));
      } else {
        result.push(dashValue);
      }
    }
  }
  return result;
}
function normalizeDashArrayY(dash) {
  if (!dash || typeof dash === "object" && dash.length === 0) {
    return [0, 0];
  }
  if (isNumber(dash)) {
    const dashValue2 = Math.ceil(dash);
    return [dashValue2, dashValue2];
  }
  const dashValue = map(dash, (n) => Math.ceil(n));
  return dash.length % 2 ? dashValue.concat(dashValue) : dashValue;
}
function getLineBlockLengthX(dash) {
  return map(dash, function(line2) {
    return getLineBlockLengthY(line2);
  });
}
function getLineBlockLengthY(dash) {
  let blockLength = 0;
  for (let i = 0; i < dash.length; ++i) {
    blockLength += dash[i];
  }
  if (dash.length % 2 === 1) {
    return blockLength * 2;
  }
  return blockLength;
}

// src/visual/decal.ts
function decalVisual(ecModel, api2) {
  ecModel.eachRawSeries((seriesModel) => {
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    const data = seriesModel.getData();
    if (data.hasItemVisual()) {
      data.each((idx) => {
        const decal2 = data.getItemVisual(idx, "decal");
        if (decal2) {
          const itemStyle = data.ensureUniqueItemVisual(idx, "style");
          itemStyle.decal = createOrUpdatePatternFromDecal(decal2, api2);
        }
      });
    }
    const decal = data.getVisual("decal");
    if (decal) {
      const style = data.getVisual("style");
      style.decal = createOrUpdatePatternFromDecal(decal, api2);
    }
  });
}

// src/core/lifecycle.ts
var lifecycle = new Eventful_default();
var lifecycle_default = lifecycle;

// src/core/impl.ts
var implsStore = {};
function registerImpl(name, impl) {
  if (true) {
    if (implsStore[name]) {
      error(`Already has an implementation of ${name}.`);
    }
  }
  implsStore[name] = impl;
}
function getImpl(name) {
  if (true) {
    if (!implsStore[name]) {
      error(`Implementation of ${name} doesn't exists.`);
    }
  }
  return implsStore[name];
}

// src/chart/custom/customSeriesRegister.ts
var customRenderers = {};
function registerCustomSeries(type, renderItem) {
  customRenderers[type] = renderItem;
}
function getCustomSeries(type) {
  return customRenderers[type];
}

// src/core/echarts.ts
var version2 = "6.0.0-beta.1";
var dependencies = {
  zrender: "6.0.0-rc.1"
};
var TEST_FRAME_REMAIN_TIME = 1;
var PRIORITY_PROCESSOR_SERIES_FILTER = 800;
var PRIORITY_PROCESSOR_DATASTACK = 900;
var PRIORITY_PROCESSOR_FILTER = 1e3;
var PRIORITY_PROCESSOR_DEFAULT = 2e3;
var PRIORITY_PROCESSOR_STATISTIC = 5e3;
var PRIORITY_VISUAL_LAYOUT = 1e3;
var PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100;
var PRIORITY_VISUAL_GLOBAL = 2e3;
var PRIORITY_VISUAL_CHART = 3e3;
var PRIORITY_VISUAL_COMPONENT = 4e3;
var PRIORITY_VISUAL_CHART_DATA_CUSTOM = 4500;
var PRIORITY_VISUAL_POST_CHART_LAYOUT = 4600;
var PRIORITY_VISUAL_BRUSH = 5e3;
var PRIORITY_VISUAL_ARIA = 6e3;
var PRIORITY_VISUAL_DECAL = 7e3;
var PRIORITY = {
  PROCESSOR: {
    FILTER: PRIORITY_PROCESSOR_FILTER,
    SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
    STATISTIC: PRIORITY_PROCESSOR_STATISTIC
  },
  VISUAL: {
    LAYOUT: PRIORITY_VISUAL_LAYOUT,
    PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
    GLOBAL: PRIORITY_VISUAL_GLOBAL,
    CHART: PRIORITY_VISUAL_CHART,
    POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
    COMPONENT: PRIORITY_VISUAL_COMPONENT,
    BRUSH: PRIORITY_VISUAL_BRUSH,
    CHART_ITEM: PRIORITY_VISUAL_CHART_DATA_CUSTOM,
    ARIA: PRIORITY_VISUAL_ARIA,
    DECAL: PRIORITY_VISUAL_DECAL
  }
};
var IN_MAIN_PROCESS_KEY = "__flagInMainProcess";
var MAIN_PROCESS_VERSION_KEY = "__mainProcessVersion";
var PENDING_UPDATE = "__pendingUpdate";
var STATUS_NEEDS_UPDATE_KEY = "__needsUpdateStatus";
var ACTION_REG = /^[a-zA-Z0-9_]+$/;
var CONNECT_STATUS_KEY = "__connectUpdateStatus";
var CONNECT_STATUS_PENDING = 0;
var CONNECT_STATUS_UPDATING = 1;
var CONNECT_STATUS_UPDATED = 2;
function createRegisterEventWithLowercaseECharts(method) {
  return function(...args) {
    if (this.isDisposed()) {
      disposedWarning(this.id);
      return;
    }
    return toLowercaseNameAndCallEventful(this, method, args);
  };
}
function createRegisterEventWithLowercaseMessageCenter(method) {
  return function(...args) {
    return toLowercaseNameAndCallEventful(this, method, args);
  };
}
function toLowercaseNameAndCallEventful(host, method, args) {
  args[0] = args[0] && args[0].toLowerCase();
  return Eventful_default.prototype[method].apply(host, args);
}
var MessageCenter = class extends Eventful_default {
};
var messageCenterProto = MessageCenter.prototype;
messageCenterProto.on = createRegisterEventWithLowercaseMessageCenter("on");
messageCenterProto.off = createRegisterEventWithLowercaseMessageCenter("off");
var prepare;
var prepareView;
var updateDirectly;
var updateMethods;
var doConvertPixel;
var updateStreamModes;
var doDispatchAction;
var flushPendingActions;
var triggerUpdatedEvent;
var bindRenderedEvent;
var bindMouseEvent;
var render;
var renderComponents;
var renderSeries;
var createExtensionAPI;
var enableConnect;
var markStatusToUpdate;
var applyChangedStates;
var updateMainProcessVersion;
var ECharts = class extends Eventful_default {
  constructor(dom, theme2, opts) {
    super(new ECEventProcessor());
    this._chartsViews = [];
    this._chartsMap = {};
    this._componentsViews = [];
    this._componentsMap = {};
    this._pendingActions = [];
    opts = opts || {};
    this._dom = dom;
    let defaultRenderer = "canvas";
    let defaultCoarsePointer = "auto";
    let defaultUseDirtyRect = false;
    this[MAIN_PROCESS_VERSION_KEY] = 1;
    if (true) {
      const root = env_default.hasGlobalWindow ? window : global;
      if (root) {
        defaultRenderer = retrieve2(root.__ECHARTS__DEFAULT__RENDERER__, defaultRenderer);
        defaultCoarsePointer = retrieve2(root.__ECHARTS__DEFAULT__COARSE_POINTER, defaultCoarsePointer);
        defaultUseDirtyRect = retrieve2(root.__ECHARTS__DEFAULT__USE_DIRTY_RECT__, defaultUseDirtyRect);
      }
    }
    if (opts.ssr) {
      registerSSRDataGetter((el) => {
        const ecData = getECData(el);
        const dataIndex = ecData.dataIndex;
        if (dataIndex == null) {
          return;
        }
        const hashMap = createHashMap();
        hashMap.set("series_index", ecData.seriesIndex);
        hashMap.set("data_index", dataIndex);
        ecData.ssrType && hashMap.set("ssr_type", ecData.ssrType);
        return hashMap;
      });
    }
    const zr = this._zr = init(dom, {
      renderer: opts.renderer || defaultRenderer,
      devicePixelRatio: opts.devicePixelRatio,
      width: opts.width,
      height: opts.height,
      ssr: opts.ssr,
      useDirtyRect: retrieve2(opts.useDirtyRect, defaultUseDirtyRect),
      useCoarsePointer: retrieve2(opts.useCoarsePointer, defaultCoarsePointer),
      pointerSize: opts.pointerSize
    });
    this._ssr = opts.ssr;
    this._throttledZrFlush = throttle(bind(zr.flush, zr), 17);
    this._updateTheme(theme2);
    this._locale = createLocaleObject(opts.locale || SYSTEM_LANG);
    this._coordSysMgr = new CoordinateSystem_default();
    const api2 = this._api = createExtensionAPI(this);
    function prioritySortFunc(a, b) {
      return a.__prio - b.__prio;
    }
    sort(visualFuncs, prioritySortFunc);
    sort(dataProcessorFuncs, prioritySortFunc);
    this._scheduler = new Scheduler_default(this, api2, dataProcessorFuncs, visualFuncs);
    this._messageCenter = new MessageCenter();
    this._initEvents();
    this.resize = bind(this.resize, this);
    zr.animation.on("frame", this._onframe, this);
    bindRenderedEvent(zr, this);
    bindMouseEvent(zr, this);
    setAsPrimitive(this);
  }
  _onframe() {
    if (this._disposed) {
      return;
    }
    applyChangedStates(this);
    const scheduler = this._scheduler;
    if (this[PENDING_UPDATE]) {
      const silent = this[PENDING_UPDATE].silent;
      this[IN_MAIN_PROCESS_KEY] = true;
      updateMainProcessVersion(this);
      try {
        prepare(this);
        updateMethods.update.call(this, null, this[PENDING_UPDATE].updateParams);
      } catch (e2) {
        this[IN_MAIN_PROCESS_KEY] = false;
        this[PENDING_UPDATE] = null;
        throw e2;
      }
      this._zr.flush();
      this[IN_MAIN_PROCESS_KEY] = false;
      this[PENDING_UPDATE] = null;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    } else if (scheduler.unfinished) {
      let remainTime = TEST_FRAME_REMAIN_TIME;
      const ecModel = this._model;
      const api2 = this._api;
      scheduler.unfinished = false;
      do {
        const startTime = +new Date();
        scheduler.performSeriesTasks(ecModel);
        scheduler.performDataProcessorTasks(ecModel);
        updateStreamModes(this, ecModel);
        scheduler.performVisualTasks(ecModel);
        renderSeries(this, this._model, api2, "remain", {});
        remainTime -= +new Date() - startTime;
      } while (remainTime > 0 && scheduler.unfinished);
      if (!scheduler.unfinished) {
        this._zr.flush();
      }
    }
  }
  getDom() {
    return this._dom;
  }
  getId() {
    return this.id;
  }
  getZr() {
    return this._zr;
  }
  isSSR() {
    return this._ssr;
  }
  setOption(option, notMerge, lazyUpdate) {
    if (this[IN_MAIN_PROCESS_KEY]) {
      if (true) {
        error("`setOption` should not be called during main process.");
      }
      return;
    }
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    let silent;
    let replaceMerge;
    let transitionOpt;
    if (isObject(notMerge)) {
      lazyUpdate = notMerge.lazyUpdate;
      silent = notMerge.silent;
      replaceMerge = notMerge.replaceMerge;
      transitionOpt = notMerge.transition;
      notMerge = notMerge.notMerge;
    }
    this[IN_MAIN_PROCESS_KEY] = true;
    updateMainProcessVersion(this);
    if (!this._model || notMerge) {
      const optionManager = new OptionManager_default(this._api);
      const theme2 = this._theme;
      const ecModel = this._model = new Global_default();
      ecModel.scheduler = this._scheduler;
      ecModel.ssr = this._ssr;
      ecModel.init(null, null, null, theme2, this._locale, optionManager);
    }
    this._model.setOption(option, {replaceMerge}, optionPreprocessorFuncs);
    const updateParams = {
      seriesTransition: transitionOpt,
      optionChanged: true
    };
    if (lazyUpdate) {
      this[PENDING_UPDATE] = {
        silent,
        updateParams
      };
      this[IN_MAIN_PROCESS_KEY] = false;
      this.getZr().wakeUp();
    } else {
      try {
        prepare(this);
        updateMethods.update.call(this, null, updateParams);
      } catch (e2) {
        this[PENDING_UPDATE] = null;
        this[IN_MAIN_PROCESS_KEY] = false;
        throw e2;
      }
      if (!this._ssr) {
        this._zr.flush();
      }
      this[PENDING_UPDATE] = null;
      this[IN_MAIN_PROCESS_KEY] = false;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    }
  }
  setTheme(theme2, opts) {
    if (this[IN_MAIN_PROCESS_KEY]) {
      if (true) {
        error("`setTheme` should not be called during main process.");
      }
      return;
    }
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    const ecModel = this._model;
    if (!ecModel) {
      return;
    }
    let silent = opts && opts.silent;
    let updateParams = null;
    if (this[PENDING_UPDATE]) {
      if (silent == null) {
        silent = this[PENDING_UPDATE].silent;
      }
      updateParams = this[PENDING_UPDATE].updateParams;
      this[PENDING_UPDATE] = null;
    }
    this[IN_MAIN_PROCESS_KEY] = true;
    updateMainProcessVersion(this);
    try {
      this._updateTheme(theme2);
      ecModel.setTheme(this._theme);
      prepare(this);
      updateMethods.update.call(this, {type: "setTheme"}, updateParams);
    } catch (e2) {
      this[IN_MAIN_PROCESS_KEY] = false;
      throw e2;
    }
    this[IN_MAIN_PROCESS_KEY] = false;
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  }
  _updateTheme(theme2) {
    if (isString(theme2)) {
      theme2 = themeStorage[theme2];
    }
    if (theme2) {
      theme2 = clone(theme2);
      theme2 && globalBackwardCompat(theme2, true);
      this._theme = theme2;
    }
  }
  getModel() {
    return this._model;
  }
  getOption() {
    return this._model && this._model.getOption();
  }
  getWidth() {
    return this._zr.getWidth();
  }
  getHeight() {
    return this._zr.getHeight();
  }
  getDevicePixelRatio() {
    return this._zr.painter.dpr || env_default.hasGlobalWindow && window.devicePixelRatio || 1;
  }
  getRenderedCanvas(opts) {
    if (true) {
      deprecateReplaceLog("getRenderedCanvas", "renderToCanvas");
    }
    return this.renderToCanvas(opts);
  }
  renderToCanvas(opts) {
    opts = opts || {};
    const painter = this._zr.painter;
    if (true) {
      if (painter.type !== "canvas") {
        throw new Error("renderToCanvas can only be used in the canvas renderer.");
      }
    }
    return painter.getRenderedCanvas({
      backgroundColor: opts.backgroundColor || this._model.get("backgroundColor"),
      pixelRatio: opts.pixelRatio || this.getDevicePixelRatio()
    });
  }
  renderToSVGString(opts) {
    opts = opts || {};
    const painter = this._zr.painter;
    if (true) {
      if (painter.type !== "svg") {
        throw new Error("renderToSVGString can only be used in the svg renderer.");
      }
    }
    return painter.renderToString({
      useViewBox: opts.useViewBox
    });
  }
  getSvgDataURL() {
    const zr = this._zr;
    const list = zr.storage.getDisplayList();
    each(list, function(el) {
      el.stopAnimation(null, true);
    });
    return zr.painter.toDataURL();
  }
  getDataURL(opts) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    opts = opts || {};
    const excludeComponents = opts.excludeComponents;
    const ecModel = this._model;
    const excludesComponentViews = [];
    const self2 = this;
    each(excludeComponents, function(componentType) {
      ecModel.eachComponent({
        mainType: componentType
      }, function(component) {
        const view = self2._componentsMap[component.__viewId];
        if (!view.group.ignore) {
          excludesComponentViews.push(view);
          view.group.ignore = true;
        }
      });
    });
    const url = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(opts).toDataURL("image/" + (opts && opts.type || "png"));
    each(excludesComponentViews, function(view) {
      view.group.ignore = false;
    });
    return url;
  }
  getConnectedDataURL(opts) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    const isSvg = opts.type === "svg";
    const groupId = this.group;
    const mathMin13 = Math.min;
    const mathMax13 = Math.max;
    const MAX_NUMBER = Infinity;
    if (connectedGroups[groupId]) {
      let left = MAX_NUMBER;
      let top = MAX_NUMBER;
      let right = -MAX_NUMBER;
      let bottom = -MAX_NUMBER;
      const canvasList = [];
      const dpr2 = opts && opts.pixelRatio || this.getDevicePixelRatio();
      each(instances2, function(chart, id) {
        if (chart.group === groupId) {
          const canvas = isSvg ? chart.getZr().painter.getSvgDom().innerHTML : chart.renderToCanvas(clone(opts));
          const boundingRect = chart.getDom().getBoundingClientRect();
          left = mathMin13(boundingRect.left, left);
          top = mathMin13(boundingRect.top, top);
          right = mathMax13(boundingRect.right, right);
          bottom = mathMax13(boundingRect.bottom, bottom);
          canvasList.push({
            dom: canvas,
            left: boundingRect.left,
            top: boundingRect.top
          });
        }
      });
      left *= dpr2;
      top *= dpr2;
      right *= dpr2;
      bottom *= dpr2;
      const width = right - left;
      const height = bottom - top;
      const targetCanvas = platformApi.createCanvas();
      const zr = init(targetCanvas, {
        renderer: isSvg ? "svg" : "canvas"
      });
      zr.resize({
        width,
        height
      });
      if (isSvg) {
        let content = "";
        each(canvasList, function(item) {
          const x = item.left - left;
          const y = item.top - top;
          content += '<g transform="translate(' + x + "," + y + ')">' + item.dom + "</g>";
        });
        zr.painter.getSvgRoot().innerHTML = content;
        if (opts.connectedBackgroundColor) {
          zr.painter.setBackgroundColor(opts.connectedBackgroundColor);
        }
        zr.refreshImmediately();
        return zr.painter.toDataURL();
      } else {
        if (opts.connectedBackgroundColor) {
          zr.add(new Rect_default({
            shape: {
              x: 0,
              y: 0,
              width,
              height
            },
            style: {
              fill: opts.connectedBackgroundColor
            }
          }));
        }
        each(canvasList, function(item) {
          const img = new Image_default({
            style: {
              x: item.left * dpr2 - left,
              y: item.top * dpr2 - top,
              image: item.dom
            }
          });
          zr.add(img);
        });
        zr.refreshImmediately();
        return targetCanvas.toDataURL("image/" + (opts && opts.type || "png"));
      }
    } else {
      return this.getDataURL(opts);
    }
  }
  convertToPixel(finder, value, opt) {
    return doConvertPixel(this, "convertToPixel", finder, value, opt);
  }
  convertToLayout(finder, value, opt) {
    return doConvertPixel(this, "convertToLayout", finder, value, opt);
  }
  convertFromPixel(finder, value, opt) {
    return doConvertPixel(this, "convertFromPixel", finder, value, opt);
  }
  containPixel(finder, value) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    const ecModel = this._model;
    let result;
    const findResult = parseFinder(ecModel, finder);
    each(findResult, function(models, key) {
      key.indexOf("Models") >= 0 && each(models, function(model) {
        const coordSys = model.coordinateSystem;
        if (coordSys && coordSys.containPoint) {
          result = result || !!coordSys.containPoint(value);
        } else if (key === "seriesModels") {
          const view = this._chartsMap[model.__viewId];
          if (view && view.containPoint) {
            result = result || view.containPoint(value, model);
          } else {
            if (true) {
              warn(key + ": " + (view ? "The found component do not support containPoint." : "No view mapping to the found component."));
            }
          }
        } else {
          if (true) {
            warn(key + ": containPoint is not supported");
          }
        }
      }, this);
    }, this);
    return !!result;
  }
  getVisual(finder, visualType) {
    const ecModel = this._model;
    const parsedFinder = parseFinder(ecModel, finder, {
      defaultMainType: "series"
    });
    const seriesModel = parsedFinder.seriesModel;
    if (true) {
      if (!seriesModel) {
        warn("There is no specified series model");
      }
    }
    const data = seriesModel.getData();
    const dataIndexInside = parsedFinder.hasOwnProperty("dataIndexInside") ? parsedFinder.dataIndexInside : parsedFinder.hasOwnProperty("dataIndex") ? data.indexOfRawIndex(parsedFinder.dataIndex) : null;
    return dataIndexInside != null ? getItemVisualFromData(data, dataIndexInside, visualType) : getVisualFromData(data, visualType);
  }
  getViewOfComponentModel(componentModel) {
    return this._componentsMap[componentModel.__viewId];
  }
  getViewOfSeriesModel(seriesModel) {
    return this._chartsMap[seriesModel.__viewId];
  }
  _initEvents() {
    each(MOUSE_EVENT_NAMES, (eveName) => {
      const handler = (e2) => {
        const ecModel = this.getModel();
        const el = e2.target;
        let params;
        const isGlobalOut = eveName === "globalout";
        if (isGlobalOut) {
          params = {};
        } else {
          el && findEventDispatcher(el, (parent) => {
            const ecData = getECData(parent);
            if (ecData && ecData.dataIndex != null) {
              const dataModel = ecData.dataModel || ecModel.getSeriesByIndex(ecData.seriesIndex);
              params = dataModel && dataModel.getDataParams(ecData.dataIndex, ecData.dataType, el) || {};
              return true;
            } else if (ecData.eventData) {
              params = extend({}, ecData.eventData);
              return true;
            }
          }, true);
        }
        if (params) {
          let componentType = params.componentType;
          let componentIndex = params.componentIndex;
          if (componentType === "markLine" || componentType === "markPoint" || componentType === "markArea") {
            componentType = "series";
            componentIndex = params.seriesIndex;
          }
          const model = componentType && componentIndex != null && ecModel.getComponent(componentType, componentIndex);
          const view = model && this[model.mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId];
          if (true) {
            if (!isGlobalOut && !(model && view)) {
              warn("model or view can not be found by params");
            }
          }
          params.event = e2;
          params.type = eveName;
          this._$eventProcessor.eventInfo = {
            targetEl: el,
            packedEvent: params,
            model,
            view
          };
          this.trigger(eveName, params);
        }
      };
      handler.zrEventfulCallAtLast = true;
      this._zr.on(eveName, handler, this);
    });
    const messageCenter = this._messageCenter;
    each(publicEventTypeMap, (_, eventType) => {
      messageCenter.on(eventType, (event) => {
        this.trigger(eventType, event);
      });
    });
    handleLegacySelectEvents(messageCenter, this, this._api);
  }
  isDisposed() {
    return this._disposed;
  }
  clear() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this.setOption({series: []}, true);
  }
  dispose() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._disposed = true;
    const dom = this.getDom();
    if (dom) {
      setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, "");
    }
    const chart = this;
    const api2 = chart._api;
    const ecModel = chart._model;
    each(chart._componentsViews, function(component) {
      component.dispose(ecModel, api2);
    });
    each(chart._chartsViews, function(chart2) {
      chart2.dispose(ecModel, api2);
    });
    chart._zr.dispose();
    chart._dom = chart._model = chart._chartsMap = chart._componentsMap = chart._chartsViews = chart._componentsViews = chart._scheduler = chart._api = chart._zr = chart._throttledZrFlush = chart._theme = chart._coordSysMgr = chart._messageCenter = null;
    delete instances2[chart.id];
  }
  resize(opts) {
    if (this[IN_MAIN_PROCESS_KEY]) {
      if (true) {
        error("`resize` should not be called during main process.");
      }
      return;
    }
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._zr.resize(opts);
    const ecModel = this._model;
    this._loadingFX && this._loadingFX.resize();
    if (!ecModel) {
      return;
    }
    let needPrepare = ecModel.resetOption("media");
    let silent = opts && opts.silent;
    if (this[PENDING_UPDATE]) {
      if (silent == null) {
        silent = this[PENDING_UPDATE].silent;
      }
      needPrepare = true;
      this[PENDING_UPDATE] = null;
    }
    this[IN_MAIN_PROCESS_KEY] = true;
    updateMainProcessVersion(this);
    try {
      needPrepare && prepare(this);
      updateMethods.update.call(this, {
        type: "resize",
        animation: extend({
          duration: 0
        }, opts && opts.animation)
      });
    } catch (e2) {
      this[IN_MAIN_PROCESS_KEY] = false;
      throw e2;
    }
    this[IN_MAIN_PROCESS_KEY] = false;
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  }
  showLoading(name, cfg) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    if (isObject(name)) {
      cfg = name;
      name = "";
    }
    name = name || "default";
    this.hideLoading();
    if (!loadingEffects[name]) {
      if (true) {
        warn("Loading effects " + name + " not exists.");
      }
      return;
    }
    const el = loadingEffects[name](this._api, cfg);
    const zr = this._zr;
    this._loadingFX = el;
    zr.add(el);
  }
  hideLoading() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._loadingFX && this._zr.remove(this._loadingFX);
    this._loadingFX = null;
  }
  makeActionFromEvent(eventObj) {
    const payload = extend({}, eventObj);
    payload.type = connectionEventRevertMap[eventObj.type];
    return payload;
  }
  dispatchAction(payload, opt) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    if (!isObject(opt)) {
      opt = {silent: !!opt};
    }
    if (!actions[payload.type]) {
      return;
    }
    if (!this._model) {
      return;
    }
    if (this[IN_MAIN_PROCESS_KEY]) {
      this._pendingActions.push(payload);
      return;
    }
    const silent = opt.silent;
    doDispatchAction.call(this, payload, silent);
    const flush = opt.flush;
    if (flush) {
      this._zr.flush();
    } else if (flush !== false && env_default.browser.weChat) {
      this._throttledZrFlush();
    }
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  }
  updateLabelLayout() {
    lifecycle_default.trigger("series:layoutlabels", this._model, this._api, {
      updatedSeries: []
    });
  }
  appendData(params) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    const seriesIndex = params.seriesIndex;
    const ecModel = this.getModel();
    const seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    if (true) {
      assert(params.data && seriesModel);
    }
    seriesModel.appendData(params);
    this._scheduler.unfinished = true;
    this.getZr().wakeUp();
  }
};
PENDING_UPDATE, IN_MAIN_PROCESS_KEY, MAIN_PROCESS_VERSION_KEY, CONNECT_STATUS_KEY, STATUS_NEEDS_UPDATE_KEY;
ECharts.internalField = function() {
  prepare = function(ecIns) {
    const scheduler = ecIns._scheduler;
    scheduler.restorePipelines(ecIns._model);
    scheduler.prepareStageTasks();
    prepareView(ecIns, true);
    prepareView(ecIns, false);
    scheduler.plan();
  };
  prepareView = function(ecIns, isComponent) {
    const ecModel = ecIns._model;
    const scheduler = ecIns._scheduler;
    const viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews;
    const viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap;
    const zr = ecIns._zr;
    const api2 = ecIns._api;
    for (let i = 0; i < viewList.length; i++) {
      viewList[i].__alive = false;
    }
    isComponent ? ecModel.eachComponent(function(componentType, model) {
      componentType !== "series" && doPrepare(model);
    }) : ecModel.eachSeries(doPrepare);
    function doPrepare(model) {
      const requireNewView = model.__requireNewView;
      model.__requireNewView = false;
      const viewId = "_ec_" + model.id + "_" + model.type;
      let view = !requireNewView && viewMap[viewId];
      if (!view) {
        const classType = parseClassType(model.type);
        const Clazz = isComponent ? Component_default2.getClass(classType.main, classType.sub) : Chart_default.getClass(classType.sub);
        if (true) {
          assert(Clazz, classType.sub + " does not exist.");
        }
        view = new Clazz();
        view.init(ecModel, api2);
        viewMap[viewId] = view;
        viewList.push(view);
        zr.add(view.group);
      }
      model.__viewId = view.__id = viewId;
      view.__alive = true;
      view.__model = model;
      view.group.__ecComponentInfo = {
        mainType: model.mainType,
        index: model.componentIndex
      };
      !isComponent && scheduler.prepareView(view, model, ecModel, api2);
    }
    for (let i = 0; i < viewList.length; ) {
      const view = viewList[i];
      if (!view.__alive) {
        !isComponent && view.renderTask.dispose();
        zr.remove(view.group);
        view.dispose(ecModel, api2);
        viewList.splice(i, 1);
        if (viewMap[view.__id] === view) {
          delete viewMap[view.__id];
        }
        view.__id = view.group.__ecComponentInfo = null;
      } else {
        i++;
      }
    }
  };
  updateDirectly = function(ecIns, method, payload, mainType, subType) {
    const ecModel = ecIns._model;
    ecModel.setUpdatePayload(payload);
    if (!mainType) {
      each([].concat(ecIns._componentsViews).concat(ecIns._chartsViews), callView);
      return;
    }
    const query = {};
    query[mainType + "Id"] = payload[mainType + "Id"];
    query[mainType + "Index"] = payload[mainType + "Index"];
    query[mainType + "Name"] = payload[mainType + "Name"];
    const condition = {mainType, query};
    subType && (condition.subType = subType);
    const excludeSeriesId = payload.excludeSeriesId;
    let excludeSeriesIdMap;
    if (excludeSeriesId != null) {
      excludeSeriesIdMap = createHashMap();
      each(normalizeToArray(excludeSeriesId), (id) => {
        const modelId = convertOptionIdName(id, null);
        if (modelId != null) {
          excludeSeriesIdMap.set(modelId, true);
        }
      });
    }
    ecModel && ecModel.eachComponent(condition, function(model) {
      const isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) != null;
      if (isExcluded) {
        return;
      }
      ;
      if (isHighDownPayload(payload)) {
        if (model instanceof Series_default) {
          if (payload.type === HIGHLIGHT_ACTION_TYPE && !payload.notBlur && !model.get(["emphasis", "disabled"])) {
            blurSeriesFromHighlightPayload(model, payload, ecIns._api);
          }
        } else {
          const {focusSelf, dispatchers} = findComponentHighDownDispatchers(model.mainType, model.componentIndex, payload.name, ecIns._api);
          if (payload.type === HIGHLIGHT_ACTION_TYPE && focusSelf && !payload.notBlur) {
            blurComponent(model.mainType, model.componentIndex, ecIns._api);
          }
          if (dispatchers) {
            each(dispatchers, (dispatcher) => {
              payload.type === HIGHLIGHT_ACTION_TYPE ? enterEmphasis(dispatcher) : leaveEmphasis(dispatcher);
            });
          }
        }
      } else if (isSelectChangePayload(payload)) {
        if (model instanceof Series_default) {
          toggleSelectionFromPayload(model, payload, ecIns._api);
          updateSeriesElementSelection(model);
          markStatusToUpdate(ecIns);
        }
      }
    }, ecIns);
    ecModel && ecModel.eachComponent(condition, function(model) {
      const isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) != null;
      if (isExcluded) {
        return;
      }
      ;
      callView(ecIns[mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId]);
    }, ecIns);
    function callView(view) {
      view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
    }
  };
  updateMethods = {
    prepareAndUpdate(payload) {
      prepare(this);
      updateMethods.update.call(this, payload, payload && {
        optionChanged: payload.newOption != null
      });
    },
    update(payload, updateParams) {
      const ecModel = this._model;
      const api2 = this._api;
      const zr = this._zr;
      const coordSysMgr = this._coordSysMgr;
      const scheduler = this._scheduler;
      if (!ecModel) {
        return;
      }
      ecModel.setUpdatePayload(payload);
      scheduler.restoreData(ecModel, payload);
      scheduler.performSeriesTasks(ecModel);
      coordSysMgr.create(ecModel, api2);
      scheduler.performDataProcessorTasks(ecModel, payload);
      updateStreamModes(this, ecModel);
      coordSysMgr.update(ecModel, api2);
      clearColorPalette(ecModel);
      scheduler.performVisualTasks(ecModel, payload);
      render(this, ecModel, api2, payload, updateParams);
      const backgroundColor2 = ecModel.get("backgroundColor") || "transparent";
      const darkMode = ecModel.get("darkMode");
      zr.setBackgroundColor(backgroundColor2);
      if (darkMode != null && darkMode !== "auto") {
        zr.setDarkMode(darkMode);
      }
      lifecycle_default.trigger("afterupdate", ecModel, api2);
    },
    updateTransform(payload) {
      const ecModel = this._model;
      const api2 = this._api;
      if (!ecModel) {
        return;
      }
      ecModel.setUpdatePayload(payload);
      const componentDirtyList = [];
      ecModel.eachComponent((componentType, componentModel) => {
        if (componentType === "series") {
          return;
        }
        const componentView = this.getViewOfComponentModel(componentModel);
        if (componentView && componentView.__alive) {
          if (componentView.updateTransform) {
            const result = componentView.updateTransform(componentModel, ecModel, api2, payload);
            result && result.update && componentDirtyList.push(componentView);
          } else {
            componentDirtyList.push(componentView);
          }
        }
      });
      const seriesDirtyMap = createHashMap();
      ecModel.eachSeries((seriesModel) => {
        const chartView = this._chartsMap[seriesModel.__viewId];
        if (chartView.updateTransform) {
          const result = chartView.updateTransform(seriesModel, ecModel, api2, payload);
          result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);
        } else {
          seriesDirtyMap.set(seriesModel.uid, 1);
        }
      });
      clearColorPalette(ecModel);
      this._scheduler.performVisualTasks(ecModel, payload, {setDirty: true, dirtyMap: seriesDirtyMap});
      renderSeries(this, ecModel, api2, payload, {}, seriesDirtyMap);
      lifecycle_default.trigger("afterupdate", ecModel, api2);
    },
    updateView(payload) {
      const ecModel = this._model;
      if (!ecModel) {
        return;
      }
      ecModel.setUpdatePayload(payload);
      Chart_default.markUpdateMethod(payload, "updateView");
      clearColorPalette(ecModel);
      this._scheduler.performVisualTasks(ecModel, payload, {setDirty: true});
      render(this, ecModel, this._api, payload, {});
      lifecycle_default.trigger("afterupdate", ecModel, this._api);
    },
    updateVisual(payload) {
      const ecModel = this._model;
      if (!ecModel) {
        return;
      }
      ecModel.setUpdatePayload(payload);
      ecModel.eachSeries(function(seriesModel) {
        seriesModel.getData().clearAllVisual();
      });
      Chart_default.markUpdateMethod(payload, "updateVisual");
      clearColorPalette(ecModel);
      this._scheduler.performVisualTasks(ecModel, payload, {visualType: "visual", setDirty: true});
      ecModel.eachComponent((componentType, componentModel) => {
        if (componentType !== "series") {
          const componentView = this.getViewOfComponentModel(componentModel);
          componentView && componentView.__alive && componentView.updateVisual(componentModel, ecModel, this._api, payload);
        }
      });
      ecModel.eachSeries((seriesModel) => {
        const chartView = this._chartsMap[seriesModel.__viewId];
        chartView.updateVisual(seriesModel, ecModel, this._api, payload);
      });
      lifecycle_default.trigger("afterupdate", ecModel, this._api);
    },
    updateLayout(payload) {
      updateMethods.update.call(this, payload);
    }
  };
  function doConvertPixelImpl(ecIns, methodName, finder, value, opt) {
    if (ecIns._disposed) {
      disposedWarning(ecIns.id);
      return;
    }
    const ecModel = ecIns._model;
    const coordSysList = ecIns._coordSysMgr.getCoordinateSystems();
    let result;
    const parsedFinder = parseFinder(ecModel, finder);
    for (let i = 0; i < coordSysList.length; i++) {
      const coordSys = coordSysList[i];
      if (coordSys[methodName] && (result = coordSys[methodName](ecModel, parsedFinder, value, opt)) != null) {
        return result;
      }
    }
    if (true) {
      warn("No coordinate system that supports " + methodName + " found by the given finder.");
    }
  }
  ;
  doConvertPixel = doConvertPixelImpl;
  updateStreamModes = function(ecIns, ecModel) {
    const chartsMap = ecIns._chartsMap;
    const scheduler = ecIns._scheduler;
    ecModel.eachSeries(function(seriesModel) {
      scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);
    });
  };
  doDispatchAction = function(payload, silent) {
    const ecModel = this.getModel();
    const payloadType = payload.type;
    const escapeConnect = payload.escapeConnect;
    const actionInfo2 = actions[payloadType];
    const cptTypeTmp = (actionInfo2.update || "update").split(":");
    const updateMethod = cptTypeTmp.pop();
    const cptType = cptTypeTmp[0] != null && parseClassType(cptTypeTmp[0]);
    this[IN_MAIN_PROCESS_KEY] = true;
    updateMainProcessVersion(this);
    let payloads = [payload];
    let batched = false;
    if (payload.batch) {
      batched = true;
      payloads = map(payload.batch, function(item) {
        item = defaults(extend({}, item), payload);
        item.batch = null;
        return item;
      });
    }
    const eventObjBatch = [];
    let eventObj;
    const actionResultBatch = [];
    const nonRefinedEventType = actionInfo2.nonRefinedEventType;
    const isSelectChange = isSelectChangePayload(payload);
    const isHighDown = isHighDownPayload(payload);
    if (isHighDown) {
      allLeaveBlur(this._api);
    }
    each(payloads, (batchItem) => {
      const actionResult = actionInfo2.action(batchItem, ecModel, this._api);
      if (actionInfo2.refineEvent) {
        actionResultBatch.push(actionResult);
      } else {
        eventObj = actionResult;
      }
      eventObj = eventObj || extend({}, batchItem);
      eventObj.type = nonRefinedEventType;
      eventObjBatch.push(eventObj);
      if (isHighDown) {
        const {queryOptionMap, mainTypeSpecified} = preParseFinder(payload);
        const componentMainType = mainTypeSpecified ? queryOptionMap.keys()[0] : "series";
        updateDirectly(this, updateMethod, batchItem, componentMainType);
        markStatusToUpdate(this);
      } else if (isSelectChange) {
        updateDirectly(this, updateMethod, batchItem, "series");
        markStatusToUpdate(this);
      } else if (cptType) {
        updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);
      }
    });
    if (updateMethod !== "none" && !isHighDown && !isSelectChange && !cptType) {
      try {
        if (this[PENDING_UPDATE]) {
          prepare(this);
          updateMethods.update.call(this, payload);
          this[PENDING_UPDATE] = null;
        } else {
          updateMethods[updateMethod].call(this, payload);
        }
      } catch (e2) {
        this[IN_MAIN_PROCESS_KEY] = false;
        throw e2;
      }
    }
    if (batched) {
      eventObj = {
        type: nonRefinedEventType,
        escapeConnect,
        batch: eventObjBatch
      };
    } else {
      eventObj = eventObjBatch[0];
    }
    this[IN_MAIN_PROCESS_KEY] = false;
    if (!silent) {
      let refinedEvent;
      if (actionInfo2.refineEvent) {
        const {eventContent} = actionInfo2.refineEvent(actionResultBatch, payload, ecModel, this._api);
        assert(isObject(eventContent));
        refinedEvent = defaults({type: actionInfo2.refinedEventType}, eventContent);
        refinedEvent.fromAction = payload.type;
        refinedEvent.fromActionPayload = payload;
        refinedEvent.escapeConnect = true;
      }
      const messageCenter = this._messageCenter;
      messageCenter.trigger(eventObj.type, eventObj);
      if (refinedEvent) {
        messageCenter.trigger(refinedEvent.type, refinedEvent);
      }
    }
  };
  flushPendingActions = function(silent) {
    const pendingActions = this._pendingActions;
    while (pendingActions.length) {
      const payload = pendingActions.shift();
      doDispatchAction.call(this, payload, silent);
    }
  };
  triggerUpdatedEvent = function(silent) {
    !silent && this.trigger("updated");
  };
  bindRenderedEvent = function(zr, ecIns) {
    zr.on("rendered", function(params) {
      ecIns.trigger("rendered", params);
      if (zr.animation.isFinished() && !ecIns[PENDING_UPDATE] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length) {
        ecIns.trigger("finished");
      }
    });
  };
  bindMouseEvent = function(zr, ecIns) {
    zr.on("mouseover", function(e2) {
      const el = e2.target;
      const dispatcher = findEventDispatcher(el, isHighDownDispatcher);
      if (dispatcher) {
        handleGlobalMouseOverForHighDown(dispatcher, e2, ecIns._api);
        markStatusToUpdate(ecIns);
      }
    }).on("mouseout", function(e2) {
      const el = e2.target;
      const dispatcher = findEventDispatcher(el, isHighDownDispatcher);
      if (dispatcher) {
        handleGlobalMouseOutForHighDown(dispatcher, e2, ecIns._api);
        markStatusToUpdate(ecIns);
      }
    }).on("click", function(e2) {
      const el = e2.target;
      const dispatcher = findEventDispatcher(el, (target) => getECData(target).dataIndex != null, true);
      if (dispatcher) {
        const actionType = dispatcher.selected ? "unselect" : "select";
        const ecData = getECData(dispatcher);
        ecIns._api.dispatchAction({
          type: actionType,
          dataType: ecData.dataType,
          dataIndexInside: ecData.dataIndex,
          seriesIndex: ecData.seriesIndex,
          isFromClick: true
        });
      }
    });
  };
  function clearColorPalette(ecModel) {
    ecModel.clearColorPalette();
    ecModel.eachSeries(function(seriesModel) {
      seriesModel.clearColorPalette();
    });
  }
  ;
  function allocateZlevels(ecModel) {
    ;
    const componentZLevels = [];
    const seriesZLevels = [];
    let hasSeparateZLevel = false;
    ecModel.eachComponent(function(componentType, componentModel) {
      const zlevel = componentModel.get("zlevel") || 0;
      const z = componentModel.get("z") || 0;
      const zlevelKey = componentModel.getZLevelKey();
      hasSeparateZLevel = hasSeparateZLevel || !!zlevelKey;
      (componentType === "series" ? seriesZLevels : componentZLevels).push({
        zlevel,
        z,
        idx: componentModel.componentIndex,
        type: componentType,
        key: zlevelKey
      });
    });
    if (hasSeparateZLevel) {
      const zLevels = componentZLevels.concat(seriesZLevels);
      let lastSeriesZLevel;
      let lastSeriesKey;
      sort(zLevels, (a, b) => {
        if (a.zlevel === b.zlevel) {
          return a.z - b.z;
        }
        return a.zlevel - b.zlevel;
      });
      each(zLevels, (item) => {
        const componentModel = ecModel.getComponent(item.type, item.idx);
        let zlevel = item.zlevel;
        const key = item.key;
        if (lastSeriesZLevel != null) {
          zlevel = Math.max(lastSeriesZLevel, zlevel);
        }
        if (key) {
          if (zlevel === lastSeriesZLevel && key !== lastSeriesKey) {
            zlevel++;
          }
          lastSeriesKey = key;
        } else if (lastSeriesKey) {
          if (zlevel === lastSeriesZLevel) {
            zlevel++;
          }
          lastSeriesKey = "";
        }
        lastSeriesZLevel = zlevel;
        componentModel.setZLevel(zlevel);
      });
    }
  }
  render = (ecIns, ecModel, api2, payload, updateParams) => {
    allocateZlevels(ecModel);
    renderComponents(ecIns, ecModel, api2, payload, updateParams);
    each(ecIns._chartsViews, function(chart) {
      chart.__alive = false;
    });
    renderSeries(ecIns, ecModel, api2, payload, updateParams);
    each(ecIns._chartsViews, function(chart) {
      if (!chart.__alive) {
        chart.remove(ecModel, api2);
      }
    });
  };
  renderComponents = (ecIns, ecModel, api2, payload, updateParams, dirtyList) => {
    each(dirtyList || ecIns._componentsViews, function(componentView) {
      const componentModel = componentView.__model;
      clearStates(componentModel, componentView);
      componentView.render(componentModel, ecModel, api2, payload);
      updateZ4(componentModel, componentView);
      updateStates(componentModel, componentView);
    });
  };
  renderSeries = (ecIns, ecModel, api2, payload, updateParams, dirtyMap) => {
    const scheduler = ecIns._scheduler;
    updateParams = extend(updateParams || {}, {
      updatedSeries: ecModel.getSeries()
    });
    lifecycle_default.trigger("series:beforeupdate", ecModel, api2, updateParams);
    let unfinished = false;
    ecModel.eachSeries(function(seriesModel) {
      const chartView = ecIns._chartsMap[seriesModel.__viewId];
      chartView.__alive = true;
      const renderTask = chartView.renderTask;
      scheduler.updatePayload(renderTask, payload);
      clearStates(seriesModel, chartView);
      if (dirtyMap && dirtyMap.get(seriesModel.uid)) {
        renderTask.dirty();
      }
      if (renderTask.perform(scheduler.getPerformArgs(renderTask))) {
        unfinished = true;
      }
      chartView.group.silent = !!seriesModel.get("silent");
      updateBlend(seriesModel, chartView);
      updateSeriesElementSelection(seriesModel);
    });
    scheduler.unfinished = unfinished || scheduler.unfinished;
    lifecycle_default.trigger("series:layoutlabels", ecModel, api2, updateParams);
    lifecycle_default.trigger("series:transition", ecModel, api2, updateParams);
    ecModel.eachSeries(function(seriesModel) {
      const chartView = ecIns._chartsMap[seriesModel.__viewId];
      updateZ4(seriesModel, chartView);
      updateStates(seriesModel, chartView);
    });
    updateHoverLayerStatus(ecIns, ecModel);
    lifecycle_default.trigger("series:afterupdate", ecModel, api2, updateParams);
  };
  markStatusToUpdate = function(ecIns) {
    ecIns[STATUS_NEEDS_UPDATE_KEY] = true;
    ecIns.getZr().wakeUp();
  };
  updateMainProcessVersion = function(ecIns) {
    ecIns[MAIN_PROCESS_VERSION_KEY] = (ecIns[MAIN_PROCESS_VERSION_KEY] + 1) % 1e3;
  };
  applyChangedStates = function(ecIns) {
    if (!ecIns[STATUS_NEEDS_UPDATE_KEY]) {
      return;
    }
    ecIns.getZr().storage.traverse(function(el) {
      if (isElementRemoved(el)) {
        return;
      }
      applyElementStates(el);
    });
    ecIns[STATUS_NEEDS_UPDATE_KEY] = false;
  };
  function applyElementStates(el) {
    const newStates = [];
    const oldStates = el.currentStates;
    for (let i = 0; i < oldStates.length; i++) {
      const stateName = oldStates[i];
      if (!(stateName === "emphasis" || stateName === "blur" || stateName === "select")) {
        newStates.push(stateName);
      }
    }
    if (el.selected && el.states.select) {
      newStates.push("select");
    }
    if (el.hoverState === HOVER_STATE_EMPHASIS && el.states.emphasis) {
      newStates.push("emphasis");
    } else if (el.hoverState === HOVER_STATE_BLUR && el.states.blur) {
      newStates.push("blur");
    }
    el.useStates(newStates);
  }
  function updateHoverLayerStatus(ecIns, ecModel) {
    const zr = ecIns._zr;
    const storage2 = zr.storage;
    let elCount = 0;
    storage2.traverse(function(el) {
      if (!el.isGroup) {
        elCount++;
      }
    });
    if (elCount > ecModel.get("hoverLayerThreshold") && !env_default.node && !env_default.worker) {
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.preventUsingHoverLayer) {
          return;
        }
        const chartView = ecIns._chartsMap[seriesModel.__viewId];
        if (chartView.__alive) {
          chartView.eachRendered((el) => {
            if (el.states.emphasis) {
              el.states.emphasis.hoverLayer = true;
            }
          });
        }
      });
    }
  }
  ;
  function updateBlend(seriesModel, chartView) {
    const blendMode = seriesModel.get("blendMode") || null;
    chartView.eachRendered((el) => {
      if (!el.isGroup) {
        el.style.blend = blendMode;
      }
    });
  }
  ;
  function updateZ4(model, view) {
    if (model.preventAutoZ) {
      return;
    }
    const zInfo = retrieveZInfo(model);
    view.eachRendered((el) => {
      traverseUpdateZ(el, zInfo.z, zInfo.zlevel);
      return true;
    });
  }
  ;
  function clearStates(model, view) {
    view.eachRendered(function(el) {
      if (isElementRemoved(el)) {
        return;
      }
      const textContent = el.getTextContent();
      const textGuide = el.getTextGuideLine();
      if (el.stateTransition) {
        el.stateTransition = null;
      }
      if (textContent && textContent.stateTransition) {
        textContent.stateTransition = null;
      }
      if (textGuide && textGuide.stateTransition) {
        textGuide.stateTransition = null;
      }
      if (el.hasState()) {
        el.prevStates = el.currentStates;
        el.clearStates();
      } else if (el.prevStates) {
        el.prevStates = null;
      }
    });
  }
  function updateStates(model, view) {
    const stateAnimationModel = model.getModel("stateAnimation");
    const enableAnimation = model.isAnimationEnabled();
    const duration = stateAnimationModel.get("duration");
    const stateTransition = duration > 0 ? {
      duration,
      delay: stateAnimationModel.get("delay"),
      easing: stateAnimationModel.get("easing")
    } : null;
    view.eachRendered(function(el) {
      if (el.states && el.states.emphasis) {
        if (isElementRemoved(el)) {
          return;
        }
        if (el instanceof Path_default) {
          savePathStates(el);
        }
        if (el.__dirty) {
          const prevStates = el.prevStates;
          if (prevStates) {
            el.useStates(prevStates);
          }
        }
        if (enableAnimation) {
          el.stateTransition = stateTransition;
          const textContent = el.getTextContent();
          const textGuide = el.getTextGuideLine();
          if (textContent) {
            textContent.stateTransition = stateTransition;
          }
          if (textGuide) {
            textGuide.stateTransition = stateTransition;
          }
        }
        if (el.__dirty) {
          applyElementStates(el);
        }
      }
    });
  }
  ;
  createExtensionAPI = function(ecIns) {
    return new class extends ExtensionAPI_default {
      getCoordinateSystems() {
        return ecIns._coordSysMgr.getCoordinateSystems();
      }
      getComponentByElement(el) {
        while (el) {
          const modelInfo = el.__ecComponentInfo;
          if (modelInfo != null) {
            return ecIns._model.getComponent(modelInfo.mainType, modelInfo.index);
          }
          el = el.parent;
        }
      }
      enterEmphasis(el, highlightDigit) {
        enterEmphasis(el, highlightDigit);
        markStatusToUpdate(ecIns);
      }
      leaveEmphasis(el, highlightDigit) {
        leaveEmphasis(el, highlightDigit);
        markStatusToUpdate(ecIns);
      }
      enterBlur(el) {
        enterBlur(el);
        markStatusToUpdate(ecIns);
      }
      leaveBlur(el) {
        leaveBlur(el);
        markStatusToUpdate(ecIns);
      }
      enterSelect(el) {
        enterSelect(el);
        markStatusToUpdate(ecIns);
      }
      leaveSelect(el) {
        leaveSelect(el);
        markStatusToUpdate(ecIns);
      }
      getModel() {
        return ecIns.getModel();
      }
      getViewOfComponentModel(componentModel) {
        return ecIns.getViewOfComponentModel(componentModel);
      }
      getViewOfSeriesModel(seriesModel) {
        return ecIns.getViewOfSeriesModel(seriesModel);
      }
      getMainProcessVersion() {
        return ecIns[MAIN_PROCESS_VERSION_KEY];
      }
    }(ecIns);
  };
  enableConnect = function(chart) {
    function updateConnectedChartsStatus(charts, status) {
      for (let i = 0; i < charts.length; i++) {
        const otherChart = charts[i];
        otherChart[CONNECT_STATUS_KEY] = status;
      }
    }
    each(connectionEventRevertMap, function(_, eventType) {
      chart._messageCenter.on(eventType, function(event) {
        if (connectedGroups[chart.group] && chart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_PENDING) {
          if (event && event.escapeConnect) {
            return;
          }
          const action = chart.makeActionFromEvent(event);
          const otherCharts = [];
          each(instances2, function(otherChart) {
            if (otherChart !== chart && otherChart.group === chart.group) {
              otherCharts.push(otherChart);
            }
          });
          updateConnectedChartsStatus(otherCharts, CONNECT_STATUS_PENDING);
          each(otherCharts, function(otherChart) {
            if (otherChart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_UPDATING) {
              otherChart.dispatchAction(action);
            }
          });
          updateConnectedChartsStatus(otherCharts, CONNECT_STATUS_UPDATED);
        }
      });
    });
  };
}();
var echartsProto = ECharts.prototype;
echartsProto.on = createRegisterEventWithLowercaseECharts("on");
echartsProto.off = createRegisterEventWithLowercaseECharts("off");
echartsProto.one = function(eventName, cb, ctx) {
  const self2 = this;
  deprecateLog("ECharts#one is deprecated.");
  function wrapped(...args2) {
    cb && cb.apply && cb.apply(this, args2);
    self2.off(eventName, wrapped);
  }
  ;
  this.on.call(this, eventName, wrapped, ctx);
};
var MOUSE_EVENT_NAMES = [
  "click",
  "dblclick",
  "mouseover",
  "mouseout",
  "mousemove",
  "mousedown",
  "mouseup",
  "globalout",
  "contextmenu"
];
function disposedWarning(id) {
  if (true) {
    warn("Instance " + id + " has been disposed");
  }
}
var actions = {};
var connectionEventRevertMap = {};
var publicEventTypeMap = {};
var dataProcessorFuncs = [];
var optionPreprocessorFuncs = [];
var visualFuncs = [];
var themeStorage = {};
var loadingEffects = {};
var instances2 = {};
var connectedGroups = {};
var idBase = +new Date() - 0;
var groupIdBase = +new Date() - 0;
var DOM_ATTRIBUTE_KEY = "_echarts_instance_";
function init2(dom, theme2, opts) {
  const isClient = !(opts && opts.ssr);
  if (isClient) {
    if (true) {
      if (!dom) {
        throw new Error("Initialize failed: invalid dom.");
      }
    }
    const existInstance = getInstanceByDom(dom);
    if (existInstance) {
      if (true) {
        warn("There is a chart instance already initialized on the dom.");
      }
      return existInstance;
    }
    if (true) {
      if (isDom(dom) && dom.nodeName.toUpperCase() !== "CANVAS" && (!dom.clientWidth && (!opts || opts.width == null) || !dom.clientHeight && (!opts || opts.height == null))) {
        warn("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload.");
      }
    }
  }
  const chart = new ECharts(dom, theme2, opts);
  chart.id = "ec_" + idBase++;
  instances2[chart.id] = chart;
  isClient && setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id);
  enableConnect(chart);
  lifecycle_default.trigger("afterinit", chart);
  return chart;
}
function connect(groupId) {
  if (isArray(groupId)) {
    const charts = groupId;
    groupId = null;
    each(charts, function(chart) {
      if (chart.group != null) {
        groupId = chart.group;
      }
    });
    groupId = groupId || "g_" + groupIdBase++;
    each(charts, function(chart) {
      chart.group = groupId;
    });
  }
  connectedGroups[groupId] = true;
  return groupId;
}
function disconnect(groupId) {
  connectedGroups[groupId] = false;
}
var disConnect = disconnect;
function dispose2(chart) {
  if (isString(chart)) {
    chart = instances2[chart];
  } else if (!(chart instanceof ECharts)) {
    chart = getInstanceByDom(chart);
  }
  if (chart instanceof ECharts && !chart.isDisposed()) {
    chart.dispose();
  }
}
function getInstanceByDom(dom) {
  return instances2[getAttribute(dom, DOM_ATTRIBUTE_KEY)];
}
function getInstanceById(key) {
  return instances2[key];
}
function registerTheme(name, theme2) {
  themeStorage[name] = theme2;
}
function registerPreprocessor(preprocessorFunc) {
  if (indexOf(optionPreprocessorFuncs, preprocessorFunc) < 0) {
    optionPreprocessorFuncs.push(preprocessorFunc);
  }
}
function registerProcessor(priority, processor) {
  normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_DEFAULT);
}
function registerPostInit(postInitFunc) {
  registerUpdateLifecycle("afterinit", postInitFunc);
}
function registerPostUpdate(postUpdateFunc) {
  registerUpdateLifecycle("afterupdate", postUpdateFunc);
}
function registerUpdateLifecycle(name, cb) {
  lifecycle_default.on(name, cb);
}
function registerAction(arg0, arg1, action) {
  let actionType;
  let publicEventType;
  let refineEvent;
  let update;
  let publishNonRefinedEvent;
  if (isFunction(arg1)) {
    action = arg1;
    arg1 = "";
  }
  if (isObject(arg0)) {
    actionType = arg0.type;
    publicEventType = arg0.event;
    update = arg0.update;
    publishNonRefinedEvent = arg0.publishNonRefinedEvent;
    if (!action) {
      action = arg0.action;
    }
    refineEvent = arg0.refineEvent;
  } else {
    actionType = arg0;
    publicEventType = arg1;
  }
  function createEventType(actionOrEventType) {
    return actionOrEventType.toLowerCase();
  }
  publicEventType = createEventType(publicEventType || actionType);
  const nonRefinedEventType = refineEvent ? createEventType(actionType) : publicEventType;
  if (actions[actionType]) {
    return;
  }
  assert(ACTION_REG.test(actionType) && ACTION_REG.test(publicEventType));
  if (refineEvent) {
    assert(publicEventType !== actionType);
  }
  actions[actionType] = {
    actionType,
    refinedEventType: publicEventType,
    nonRefinedEventType,
    update,
    action,
    refineEvent
  };
  publicEventTypeMap[publicEventType] = 1;
  if (refineEvent && publishNonRefinedEvent) {
    publicEventTypeMap[nonRefinedEventType] = 1;
  }
  if (connectionEventRevertMap[nonRefinedEventType]) {
    error(`${nonRefinedEventType} must not be shared; use "refineEvent" if you intend to share an event name.`);
  }
  connectionEventRevertMap[nonRefinedEventType] = actionType;
}
function registerCoordinateSystem(type, coordSysCreator) {
  CoordinateSystem_default.register(type, coordSysCreator);
}
function getCoordinateSystemDimensions(type) {
  const coordSysCreator = CoordinateSystem_default.get(type);
  if (coordSysCreator) {
    return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();
  }
}
function registerCustomSeries2(seriesType2, renderItem) {
  registerCustomSeries(seriesType2, renderItem);
}
function registerLayout(priority, layoutTask) {
  normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, "layout");
}
function registerVisual(priority, visualTask) {
  normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, "visual");
}
var registeredTasks = [];
function normalizeRegister(targetList, priority, fn, defaultPriority, visualType) {
  if (isFunction(priority) || isObject(priority)) {
    fn = priority;
    priority = defaultPriority;
  }
  if (true) {
    if (isNaN(priority) || priority == null) {
      throw new Error("Illegal priority");
    }
    each(targetList, function(wrap) {
      assert(wrap.__raw !== fn);
    });
  }
  if (indexOf(registeredTasks, fn) >= 0) {
    return;
  }
  registeredTasks.push(fn);
  const stageHandler = Scheduler_default.wrapStageHandler(fn, visualType);
  stageHandler.__prio = priority;
  stageHandler.__raw = fn;
  targetList.push(stageHandler);
}
function registerLoading(name, loadingFx) {
  loadingEffects[name] = loadingFx;
}
function setCanvasCreator(creator) {
  if (true) {
    deprecateLog("setCanvasCreator is deprecated. Use setPlatformAPI({ createCanvas }) instead.");
  }
  setPlatformAPI({
    createCanvas: creator
  });
}
function registerMap(mapName, geoJson, specialAreas) {
  const registerMap3 = getImpl("registerMap");
  registerMap3 && registerMap3(mapName, geoJson, specialAreas);
}
function getMap(mapName) {
  const getMap2 = getImpl("getMap");
  return getMap2 && getMap2(mapName);
}
var registerTransform = registerExternalTransform;
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataColorPaletteTask);
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesSymbolTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataSymbolTask);
registerVisual(PRIORITY_VISUAL_DECAL, decalVisual);
registerPreprocessor(globalBackwardCompat);
registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack);
registerLoading("default", defaultLoading);
registerAction({
  type: HIGHLIGHT_ACTION_TYPE,
  event: HIGHLIGHT_ACTION_TYPE,
  update: HIGHLIGHT_ACTION_TYPE
}, noop);
registerAction({
  type: DOWNPLAY_ACTION_TYPE,
  event: DOWNPLAY_ACTION_TYPE,
  update: DOWNPLAY_ACTION_TYPE
}, noop);
registerAction({
  type: SELECT_ACTION_TYPE,
  event: SELECT_CHANGED_EVENT_TYPE,
  update: SELECT_ACTION_TYPE,
  action: noop,
  refineEvent: makeSelectChangedEvent,
  publishNonRefinedEvent: true
});
registerAction({
  type: UNSELECT_ACTION_TYPE,
  event: SELECT_CHANGED_EVENT_TYPE,
  update: UNSELECT_ACTION_TYPE,
  action: noop,
  refineEvent: makeSelectChangedEvent,
  publishNonRefinedEvent: true
});
registerAction({
  type: TOGGLE_SELECT_ACTION_TYPE,
  event: SELECT_CHANGED_EVENT_TYPE,
  update: TOGGLE_SELECT_ACTION_TYPE,
  action: noop,
  refineEvent: makeSelectChangedEvent,
  publishNonRefinedEvent: true
});
function makeSelectChangedEvent(actionResultBatch, payload, ecModel, api2) {
  return {
    eventContent: {
      selected: getAllSelectedIndices(ecModel),
      isFromClick: payload.isFromClick || false
    }
  };
}
registerTheme("default", {});
registerTheme("dark", dark_default);
var dataTool = {};

// src/extension.ts
var extensions = [];
var extensionRegisters = {
  registerPreprocessor,
  registerProcessor,
  registerPostInit,
  registerPostUpdate,
  registerUpdateLifecycle,
  registerAction,
  registerCoordinateSystem,
  registerLayout,
  registerVisual,
  registerTransform,
  registerLoading,
  registerMap,
  registerImpl,
  PRIORITY,
  ComponentModel: Component_default,
  ComponentView: Component_default2,
  SeriesModel: Series_default,
  ChartView: Chart_default,
  registerComponentModel(ComponentModelClass) {
    Component_default.registerClass(ComponentModelClass);
  },
  registerComponentView(ComponentViewClass) {
    Component_default2.registerClass(ComponentViewClass);
  },
  registerSeriesModel(SeriesModelClass) {
    Series_default.registerClass(SeriesModelClass);
  },
  registerChartView(ChartViewClass) {
    Chart_default.registerClass(ChartViewClass);
  },
  registerCustomSeries(seriesType2, renderItem) {
    registerCustomSeries(seriesType2, renderItem);
  },
  registerSubTypeDefaulter(componentType, defaulter) {
    Component_default.registerSubTypeDefaulter(componentType, defaulter);
  },
  registerPainter(painterType, PainterCtor) {
    registerPainter(painterType, PainterCtor);
  }
};
function use(ext) {
  if (isArray(ext)) {
    each(ext, (singleExt) => {
      use(singleExt);
    });
    return;
  }
  if (indexOf(extensions, ext) >= 0) {
    return;
  }
  extensions.push(ext);
  if (isFunction(ext)) {
    ext = {
      install: ext
    };
  }
  ext.install(extensionRegisters);
}

// src/data/DataDiffer.ts
function dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {
  return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;
}
function defaultKeyGetter(item) {
  return item;
}
var DataDiffer = class {
  constructor(oldArr, newArr, oldKeyGetter, newKeyGetter, context, diffMode) {
    this._old = oldArr;
    this._new = newArr;
    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
    this._newKeyGetter = newKeyGetter || defaultKeyGetter;
    this.context = context;
    this._diffModeMultiple = diffMode === "multiple";
  }
  add(func) {
    this._add = func;
    return this;
  }
  update(func) {
    this._update = func;
    return this;
  }
  updateManyToOne(func) {
    this._updateManyToOne = func;
    return this;
  }
  updateOneToMany(func) {
    this._updateOneToMany = func;
    return this;
  }
  updateManyToMany(func) {
    this._updateManyToMany = func;
    return this;
  }
  remove(func) {
    this._remove = func;
    return this;
  }
  execute() {
    this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
  }
  _executeOneToOne() {
    const oldArr = this._old;
    const newArr = this._new;
    const newDataIndexMap = {};
    const oldDataKeyArr = new Array(oldArr.length);
    const newDataKeyArr = new Array(newArr.length);
    this._initIndexMap(oldArr, null, oldDataKeyArr, "_oldKeyGetter");
    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
    for (let i = 0; i < oldArr.length; i++) {
      const oldKey = oldDataKeyArr[i];
      const newIdxMapVal = newDataIndexMap[oldKey];
      const newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
      if (newIdxMapValLen > 1) {
        const newIdx = newIdxMapVal.shift();
        if (newIdxMapVal.length === 1) {
          newDataIndexMap[oldKey] = newIdxMapVal[0];
        }
        this._update && this._update(newIdx, i);
      } else if (newIdxMapValLen === 1) {
        newDataIndexMap[oldKey] = null;
        this._update && this._update(newIdxMapVal, i);
      } else {
        this._remove && this._remove(i);
      }
    }
    this._performRestAdd(newDataKeyArr, newDataIndexMap);
  }
  _executeMultiple() {
    const oldArr = this._old;
    const newArr = this._new;
    const oldDataIndexMap = {};
    const newDataIndexMap = {};
    const oldDataKeyArr = [];
    const newDataKeyArr = [];
    this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, "_oldKeyGetter");
    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
    for (let i = 0; i < oldDataKeyArr.length; i++) {
      const oldKey = oldDataKeyArr[i];
      const oldIdxMapVal = oldDataIndexMap[oldKey];
      const newIdxMapVal = newDataIndexMap[oldKey];
      const oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);
      const newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
      if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {
        this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {
        this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {
        this._update && this._update(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {
        this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen > 1) {
        for (let i2 = 0; i2 < oldIdxMapValLen; i2++) {
          this._remove && this._remove(oldIdxMapVal[i2]);
        }
      } else {
        this._remove && this._remove(oldIdxMapVal);
      }
    }
    this._performRestAdd(newDataKeyArr, newDataIndexMap);
  }
  _performRestAdd(newDataKeyArr, newDataIndexMap) {
    for (let i = 0; i < newDataKeyArr.length; i++) {
      const newKey = newDataKeyArr[i];
      const newIdxMapVal = newDataIndexMap[newKey];
      const idxMapValLen = dataIndexMapValueLength(newIdxMapVal);
      if (idxMapValLen > 1) {
        for (let j = 0; j < idxMapValLen; j++) {
          this._add && this._add(newIdxMapVal[j]);
        }
      } else if (idxMapValLen === 1) {
        this._add && this._add(newIdxMapVal);
      }
      newDataIndexMap[newKey] = null;
    }
  }
  _initIndexMap(arr, map3, keyArr, keyGetterName) {
    const cbModeMultiple = this._diffModeMultiple;
    for (let i = 0; i < arr.length; i++) {
      const key = "_ec_" + this[keyGetterName](arr[i], i);
      if (!cbModeMultiple) {
        keyArr[i] = key;
      }
      if (!map3) {
        continue;
      }
      const idxMapVal = map3[key];
      const idxMapValLen = dataIndexMapValueLength(idxMapVal);
      if (idxMapValLen === 0) {
        map3[key] = i;
        if (cbModeMultiple) {
          keyArr.push(key);
        }
      } else if (idxMapValLen === 1) {
        map3[key] = [idxMapVal, i];
      } else {
        idxMapVal.push(i);
      }
    }
  }
};
var DataDiffer_default = DataDiffer;

// src/data/helper/dimensionHelper.ts
var DimensionUserOuput = class {
  constructor(encode, dimRequest) {
    this._encode = encode;
    this._schema = dimRequest;
  }
  get() {
    return {
      fullDimensions: this._getFullDimensionNames(),
      encode: this._encode
    };
  }
  _getFullDimensionNames() {
    if (!this._cachedDimNames) {
      this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : [];
    }
    return this._cachedDimNames;
  }
};
function summarizeDimensions(data, schema) {
  const summary = {};
  const encode = summary.encode = {};
  const notExtraCoordDimMap = createHashMap();
  let defaultedLabel = [];
  let defaultedTooltip = [];
  const userOutputEncode = {};
  each(data.dimensions, function(dimName) {
    const dimItem = data.getDimensionInfo(dimName);
    const coordDim = dimItem.coordDim;
    if (coordDim) {
      if (true) {
        assert(VISUAL_DIMENSIONS.get(coordDim) == null);
      }
      const coordDimIndex = dimItem.coordDimIndex;
      getOrCreateEncodeArr(encode, coordDim)[coordDimIndex] = dimName;
      if (!dimItem.isExtraCoord) {
        notExtraCoordDimMap.set(coordDim, 1);
        if (mayLabelDimType(dimItem.type)) {
          defaultedLabel[0] = dimName;
        }
        getOrCreateEncodeArr(userOutputEncode, coordDim)[coordDimIndex] = data.getDimensionIndex(dimItem.name);
      }
      if (dimItem.defaultTooltip) {
        defaultedTooltip.push(dimName);
      }
    }
    VISUAL_DIMENSIONS.each(function(v, otherDim) {
      const encodeArr = getOrCreateEncodeArr(encode, otherDim);
      const dimIndex = dimItem.otherDims[otherDim];
      if (dimIndex != null && dimIndex !== false) {
        encodeArr[dimIndex] = dimItem.name;
      }
    });
  });
  let dataDimsOnCoord = [];
  const encodeFirstDimNotExtra = {};
  notExtraCoordDimMap.each(function(v, coordDim) {
    const dimArr = encode[coordDim];
    encodeFirstDimNotExtra[coordDim] = dimArr[0];
    dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);
  });
  summary.dataDimsOnCoord = dataDimsOnCoord;
  summary.dataDimIndicesOnCoord = map(dataDimsOnCoord, (dimName) => data.getDimensionInfo(dimName).storeDimIndex);
  summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;
  const encodeLabel = encode.label;
  if (encodeLabel && encodeLabel.length) {
    defaultedLabel = encodeLabel.slice();
  }
  const encodeTooltip = encode.tooltip;
  if (encodeTooltip && encodeTooltip.length) {
    defaultedTooltip = encodeTooltip.slice();
  } else if (!defaultedTooltip.length) {
    defaultedTooltip = defaultedLabel.slice();
  }
  encode.defaultedLabel = defaultedLabel;
  encode.defaultedTooltip = defaultedTooltip;
  summary.userOutput = new DimensionUserOuput(userOutputEncode, schema);
  return summary;
}
function getOrCreateEncodeArr(encode, dim) {
  if (!encode.hasOwnProperty(dim)) {
    encode[dim] = [];
  }
  return encode[dim];
}
function getDimensionTypeByAxis(axisType) {
  return axisType === "category" ? "ordinal" : axisType === "time" ? "time" : "float";
}
function mayLabelDimType(dimType) {
  return !(dimType === "ordinal" || dimType === "time");
}

// src/data/SeriesDimensionDefine.ts
var SeriesDimensionDefine = class {
  constructor(opt) {
    this.otherDims = {};
    if (opt != null) {
      extend(this, opt);
    }
  }
};
var SeriesDimensionDefine_default = SeriesDimensionDefine;

// src/data/helper/SeriesDataSchema.ts
var inner5 = makeInner();
var dimTypeShort = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
};
var SeriesDataSchema = class {
  constructor(opt) {
    this.dimensions = opt.dimensions;
    this._dimOmitted = opt.dimensionOmitted;
    this.source = opt.source;
    this._fullDimCount = opt.fullDimensionCount;
    this._updateDimOmitted(opt.dimensionOmitted);
  }
  isDimensionOmitted() {
    return this._dimOmitted;
  }
  _updateDimOmitted(dimensionOmitted) {
    this._dimOmitted = dimensionOmitted;
    if (!dimensionOmitted) {
      return;
    }
    if (!this._dimNameMap) {
      this._dimNameMap = ensureSourceDimNameMap(this.source);
    }
  }
  getSourceDimensionIndex(dimName) {
    return retrieve2(this._dimNameMap.get(dimName), -1);
  }
  getSourceDimension(dimIndex) {
    const dimensionsDefine = this.source.dimensionsDefine;
    if (dimensionsDefine) {
      return dimensionsDefine[dimIndex];
    }
  }
  makeStoreSchema() {
    const dimCount = this._fullDimCount;
    const willRetrieveDataByName = shouldRetrieveDataByName(this.source);
    const makeHashStrict = !shouldOmitUnusedDimensions(dimCount);
    let dimHash = "";
    const dims = [];
    for (let fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < dimCount; fullDimIdx++) {
      let property;
      let type;
      let ordinalMeta;
      const seriesDimDef = this.dimensions[seriesDimIdx];
      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
        property = willRetrieveDataByName ? seriesDimDef.name : null;
        type = seriesDimDef.type;
        ordinalMeta = seriesDimDef.ordinalMeta;
        seriesDimIdx++;
      } else {
        const sourceDimDef = this.getSourceDimension(fullDimIdx);
        if (sourceDimDef) {
          property = willRetrieveDataByName ? sourceDimDef.name : null;
          type = sourceDimDef.type;
        }
      }
      dims.push({property, type, ordinalMeta});
      if (willRetrieveDataByName && property != null && (!seriesDimDef || !seriesDimDef.isCalculationCoord)) {
        dimHash += makeHashStrict ? property.replace(/\`/g, "`1").replace(/\$/g, "`2") : property;
      }
      dimHash += "$";
      dimHash += dimTypeShort[type] || "f";
      if (ordinalMeta) {
        dimHash += ordinalMeta.uid;
      }
      dimHash += "$";
    }
    const source = this.source;
    const hash = [
      source.seriesLayoutBy,
      source.startIndex,
      dimHash
    ].join("$$");
    return {
      dimensions: dims,
      hash
    };
  }
  makeOutputDimensionNames() {
    const result = [];
    for (let fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < this._fullDimCount; fullDimIdx++) {
      let name;
      const seriesDimDef = this.dimensions[seriesDimIdx];
      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
        if (!seriesDimDef.isCalculationCoord) {
          name = seriesDimDef.name;
        }
        seriesDimIdx++;
      } else {
        const sourceDimDef = this.getSourceDimension(fullDimIdx);
        if (sourceDimDef) {
          name = sourceDimDef.name;
        }
      }
      result.push(name);
    }
    return result;
  }
  appendCalculationDimension(dimDef) {
    this.dimensions.push(dimDef);
    dimDef.isCalculationCoord = true;
    this._fullDimCount++;
    this._updateDimOmitted(true);
  }
};
function isSeriesDataSchema(schema) {
  return schema instanceof SeriesDataSchema;
}
function createDimNameMap(dimsDef) {
  const dataDimNameMap = createHashMap();
  for (let i = 0; i < (dimsDef || []).length; i++) {
    const dimDefItemRaw = dimsDef[i];
    const userDimName = isObject(dimDefItemRaw) ? dimDefItemRaw.name : dimDefItemRaw;
    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {
      dataDimNameMap.set(userDimName, i);
    }
  }
  return dataDimNameMap;
}
function ensureSourceDimNameMap(source) {
  const innerSource = inner5(source);
  return innerSource.dimNameMap || (innerSource.dimNameMap = createDimNameMap(source.dimensionsDefine));
}
function shouldOmitUnusedDimensions(dimCount) {
  return dimCount > 30;
}

// src/data/SeriesData.ts
var isObject3 = isObject;
var map2 = map;
var CtorInt32Array2 = typeof Int32Array === "undefined" ? Array : Int32Array;
var ID_PREFIX = "e\0\0";
var INDEX_NOT_FOUND = -1;
var TRANSFERABLE_PROPERTIES = [
  "hasItemOption",
  "_nameList",
  "_idList",
  "_invertedIndicesMap",
  "_dimSummary",
  "userOutput",
  "_rawData",
  "_dimValueGetter",
  "_nameDimIdx",
  "_idDimIdx",
  "_nameRepeatCount"
];
var CLONE_PROPERTIES = [
  "_approximateExtent"
];
var prepareInvertedIndex;
var getId;
var getIdNameFromStore;
var normalizeDimensions;
var transferProperties;
var cloneListForMapAndSample;
var makeIdFromName;
var SeriesData2 = class {
  constructor(dimensionsInput, hostModel) {
    this.type = "list";
    this._dimOmitted = false;
    this._nameList = [];
    this._idList = [];
    this._visual = {};
    this._layout = {};
    this._itemVisuals = [];
    this._itemLayouts = [];
    this._graphicEls = [];
    this._approximateExtent = {};
    this._calculationInfo = {};
    this.hasItemOption = false;
    this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "minmaxDownSample", "lttbDownSample", "map"];
    this.CHANGABLE_METHODS = ["filterSelf", "selectRange"];
    this.DOWNSAMPLE_METHODS = ["downSample", "minmaxDownSample", "lttbDownSample"];
    let dimensions;
    let assignStoreDimIdx = false;
    if (isSeriesDataSchema(dimensionsInput)) {
      dimensions = dimensionsInput.dimensions;
      this._dimOmitted = dimensionsInput.isDimensionOmitted();
      this._schema = dimensionsInput;
    } else {
      assignStoreDimIdx = true;
      dimensions = dimensionsInput;
    }
    dimensions = dimensions || ["x", "y"];
    const dimensionInfos = {};
    const dimensionNames = [];
    const invertedIndicesMap = {};
    let needsHasOwn = false;
    const emptyObj = {};
    for (let i = 0; i < dimensions.length; i++) {
      const dimInfoInput = dimensions[i];
      const dimensionInfo = isString(dimInfoInput) ? new SeriesDimensionDefine_default({name: dimInfoInput}) : !(dimInfoInput instanceof SeriesDimensionDefine_default) ? new SeriesDimensionDefine_default(dimInfoInput) : dimInfoInput;
      const dimensionName = dimensionInfo.name;
      dimensionInfo.type = dimensionInfo.type || "float";
      if (!dimensionInfo.coordDim) {
        dimensionInfo.coordDim = dimensionName;
        dimensionInfo.coordDimIndex = 0;
      }
      const otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};
      dimensionNames.push(dimensionName);
      dimensionInfos[dimensionName] = dimensionInfo;
      if (emptyObj[dimensionName] != null) {
        needsHasOwn = true;
      }
      if (dimensionInfo.createInvertedIndices) {
        invertedIndicesMap[dimensionName] = [];
      }
      let dimIdx = i;
      if (isNumber(dimensionInfo.storeDimIndex)) {
        dimIdx = dimensionInfo.storeDimIndex;
      }
      if (otherDims.itemName === 0) {
        this._nameDimIdx = dimIdx;
      }
      if (otherDims.itemId === 0) {
        this._idDimIdx = dimIdx;
      }
      if (true) {
        assert(assignStoreDimIdx || dimensionInfo.storeDimIndex >= 0);
      }
      if (assignStoreDimIdx) {
        dimensionInfo.storeDimIndex = i;
      }
    }
    this.dimensions = dimensionNames;
    this._dimInfos = dimensionInfos;
    this._initGetDimensionInfo(needsHasOwn);
    this.hostModel = hostModel;
    this._invertedIndicesMap = invertedIndicesMap;
    if (this._dimOmitted) {
      const dimIdxToName = this._dimIdxToName = createHashMap();
      each(dimensionNames, (dimName) => {
        dimIdxToName.set(dimensionInfos[dimName].storeDimIndex, dimName);
      });
    }
  }
  getDimension(dim) {
    let dimIdx = this._recognizeDimIndex(dim);
    if (dimIdx == null) {
      return dim;
    }
    dimIdx = dim;
    if (!this._dimOmitted) {
      return this.dimensions[dimIdx];
    }
    const dimName = this._dimIdxToName.get(dimIdx);
    if (dimName != null) {
      return dimName;
    }
    const sourceDimDef = this._schema.getSourceDimension(dimIdx);
    if (sourceDimDef) {
      return sourceDimDef.name;
    }
  }
  getDimensionIndex(dim) {
    const dimIdx = this._recognizeDimIndex(dim);
    if (dimIdx != null) {
      return dimIdx;
    }
    if (dim == null) {
      return -1;
    }
    const dimInfo = this._getDimInfo(dim);
    return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;
  }
  _recognizeDimIndex(dim) {
    if (isNumber(dim) || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {
      return +dim;
    }
  }
  _getStoreDimIndex(dim) {
    const dimIdx = this.getDimensionIndex(dim);
    if (true) {
      if (dimIdx == null) {
        throw new Error("Unknown dimension " + dim);
      }
    }
    return dimIdx;
  }
  getDimensionInfo(dim) {
    return this._getDimInfo(this.getDimension(dim));
  }
  _initGetDimensionInfo(needsHasOwn) {
    const dimensionInfos = this._dimInfos;
    this._getDimInfo = needsHasOwn ? (dimName) => dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : void 0 : (dimName) => dimensionInfos[dimName];
  }
  getDimensionsOnCoord() {
    return this._dimSummary.dataDimsOnCoord.slice();
  }
  mapDimension(coordDim, idx) {
    const dimensionsSummary = this._dimSummary;
    if (idx == null) {
      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];
    }
    const dims = dimensionsSummary.encode[coordDim];
    return dims ? dims[idx] : null;
  }
  mapDimensionsAll(coordDim) {
    const dimensionsSummary = this._dimSummary;
    const dims = dimensionsSummary.encode[coordDim];
    return (dims || []).slice();
  }
  getStore() {
    return this._store;
  }
  initData(data, nameList, dimValueGetter) {
    let store;
    if (data instanceof DataStore_default) {
      store = data;
    }
    if (!store) {
      const dimensions = this.dimensions;
      const provider = isSourceInstance(data) || isArrayLike(data) ? new DefaultDataProvider(data, dimensions.length) : data;
      store = new DataStore_default();
      const dimensionInfos = map2(dimensions, (dimName) => ({
        type: this._dimInfos[dimName].type,
        property: dimName
      }));
      store.initData(provider, dimensionInfos, dimValueGetter);
    }
    this._store = store;
    this._nameList = (nameList || []).slice();
    this._idList = [];
    this._nameRepeatCount = {};
    this._doInit(0, store.count());
    this._dimSummary = summarizeDimensions(this, this._schema);
    this.userOutput = this._dimSummary.userOutput;
  }
  appendData(data) {
    const range = this._store.appendData(data);
    this._doInit(range[0], range[1]);
  }
  appendValues(values, names) {
    const {start: start2, end: end2} = this._store.appendValues(values, names && names.length);
    const shouldMakeIdFromName = this._shouldMakeIdFromName();
    this._updateOrdinalMeta();
    if (names) {
      for (let idx = start2; idx < end2; idx++) {
        const sourceIdx = idx - start2;
        this._nameList[idx] = names[sourceIdx];
        if (shouldMakeIdFromName) {
          makeIdFromName(this, idx);
        }
      }
    }
  }
  _updateOrdinalMeta() {
    const store = this._store;
    const dimensions = this.dimensions;
    for (let i = 0; i < dimensions.length; i++) {
      const dimInfo = this._dimInfos[dimensions[i]];
      if (dimInfo.ordinalMeta) {
        store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);
      }
    }
  }
  _shouldMakeIdFromName() {
    const provider = this._store.getProvider();
    return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;
  }
  _doInit(start2, end2) {
    if (start2 >= end2) {
      return;
    }
    const store = this._store;
    const provider = store.getProvider();
    this._updateOrdinalMeta();
    const nameList = this._nameList;
    const idList = this._idList;
    const sourceFormat = provider.getSource().sourceFormat;
    const isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL;
    if (isFormatOriginal && !provider.pure) {
      const sharedDataItem = [];
      for (let idx = start2; idx < end2; idx++) {
        const dataItem = provider.getItem(idx, sharedDataItem);
        if (!this.hasItemOption && isDataItemOption(dataItem)) {
          this.hasItemOption = true;
        }
        if (dataItem) {
          const itemName = dataItem.name;
          if (nameList[idx] == null && itemName != null) {
            nameList[idx] = convertOptionIdName(itemName, null);
          }
          const itemId = dataItem.id;
          if (idList[idx] == null && itemId != null) {
            idList[idx] = convertOptionIdName(itemId, null);
          }
        }
      }
    }
    if (this._shouldMakeIdFromName()) {
      for (let idx = start2; idx < end2; idx++) {
        makeIdFromName(this, idx);
      }
    }
    prepareInvertedIndex(this);
  }
  getApproximateExtent(dim) {
    return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));
  }
  setApproximateExtent(extent, dim) {
    dim = this.getDimension(dim);
    this._approximateExtent[dim] = extent.slice();
  }
  getCalculationInfo(key) {
    return this._calculationInfo[key];
  }
  setCalculationInfo(key, value) {
    isObject3(key) ? extend(this._calculationInfo, key) : this._calculationInfo[key] = value;
  }
  getName(idx) {
    const rawIndex = this.getRawIndex(idx);
    let name = this._nameList[rawIndex];
    if (name == null && this._nameDimIdx != null) {
      name = getIdNameFromStore(this, this._nameDimIdx, rawIndex);
    }
    if (name == null) {
      name = "";
    }
    return name;
  }
  _getCategory(dimIdx, idx) {
    const ordinal = this._store.get(dimIdx, idx);
    const ordinalMeta = this._store.getOrdinalMeta(dimIdx);
    if (ordinalMeta) {
      return ordinalMeta.categories[ordinal];
    }
    return ordinal;
  }
  getId(idx) {
    return getId(this, this.getRawIndex(idx));
  }
  count() {
    return this._store.count();
  }
  get(dim, idx) {
    const store = this._store;
    const dimInfo = this._dimInfos[dim];
    if (dimInfo) {
      return store.get(dimInfo.storeDimIndex, idx);
    }
  }
  getByRawIndex(dim, rawIdx) {
    const store = this._store;
    const dimInfo = this._dimInfos[dim];
    if (dimInfo) {
      return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);
    }
  }
  getIndices() {
    return this._store.getIndices();
  }
  getDataExtent(dim) {
    return this._store.getDataExtent(this._getStoreDimIndex(dim));
  }
  getSum(dim) {
    return this._store.getSum(this._getStoreDimIndex(dim));
  }
  getMedian(dim) {
    return this._store.getMedian(this._getStoreDimIndex(dim));
  }
  getValues(dimensions, idx) {
    const store = this._store;
    return isArray(dimensions) ? store.getValues(map2(dimensions, (dim) => this._getStoreDimIndex(dim)), idx) : store.getValues(dimensions);
  }
  hasValue(idx) {
    const dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;
    for (let i = 0, len2 = dataDimIndicesOnCoord.length; i < len2; i++) {
      if (isNaN(this._store.get(dataDimIndicesOnCoord[i], idx))) {
        return false;
      }
    }
    return true;
  }
  indexOfName(name) {
    for (let i = 0, len2 = this._store.count(); i < len2; i++) {
      if (this.getName(i) === name) {
        return i;
      }
    }
    return -1;
  }
  getRawIndex(idx) {
    return this._store.getRawIndex(idx);
  }
  indexOfRawIndex(rawIndex) {
    return this._store.indexOfRawIndex(rawIndex);
  }
  rawIndexOf(dim, value) {
    const invertedIndices = dim && this._invertedIndicesMap[dim];
    if (true) {
      if (!invertedIndices) {
        throw new Error("Do not supported yet");
      }
    }
    const rawIndex = invertedIndices && invertedIndices[value];
    if (rawIndex == null || isNaN(rawIndex)) {
      return INDEX_NOT_FOUND;
    }
    return rawIndex;
  }
  each(dims, cb, ctx) {
    "use strict";
    if (isFunction(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    }
    const fCtx = ctx || this;
    const dimIndices = map2(normalizeDimensions(dims), this._getStoreDimIndex, this);
    this._store.each(dimIndices, fCtx ? bind(cb, fCtx) : cb);
  }
  filterSelf(dims, cb, ctx) {
    "use strict";
    if (isFunction(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    }
    const fCtx = ctx || this;
    const dimIndices = map2(normalizeDimensions(dims), this._getStoreDimIndex, this);
    this._store = this._store.filter(dimIndices, fCtx ? bind(cb, fCtx) : cb);
    return this;
  }
  selectRange(range) {
    "use strict";
    const innerRange = {};
    const dims = keys(range);
    const dimIndices = [];
    each(dims, (dim) => {
      const dimIdx = this._getStoreDimIndex(dim);
      innerRange[dimIdx] = range[dim];
      dimIndices.push(dimIdx);
    });
    this._store = this._store.selectRange(innerRange);
    return this;
  }
  mapArray(dims, cb, ctx) {
    "use strict";
    if (isFunction(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    }
    ctx = ctx || this;
    const result = [];
    this.each(dims, function() {
      result.push(cb && cb.apply(this, arguments));
    }, ctx);
    return result;
  }
  map(dims, cb, ctx, ctxCompat) {
    "use strict";
    const fCtx = ctx || ctxCompat || this;
    const dimIndices = map2(normalizeDimensions(dims), this._getStoreDimIndex, this);
    const list = cloneListForMapAndSample(this);
    list._store = this._store.map(dimIndices, fCtx ? bind(cb, fCtx) : cb);
    return list;
  }
  modify(dims, cb, ctx, ctxCompat) {
    const fCtx = ctx || ctxCompat || this;
    if (true) {
      each(normalizeDimensions(dims), (dim) => {
        const dimInfo = this.getDimensionInfo(dim);
        if (!dimInfo.isCalculationCoord) {
          console.error("Danger: only stack dimension can be modified");
        }
      });
    }
    const dimIndices = map2(normalizeDimensions(dims), this._getStoreDimIndex, this);
    this._store.modify(dimIndices, fCtx ? bind(cb, fCtx) : cb);
  }
  downSample(dimension, rate, sampleValue, sampleIndex) {
    const list = cloneListForMapAndSample(this);
    list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);
    return list;
  }
  minmaxDownSample(valueDimension, rate) {
    const list = cloneListForMapAndSample(this);
    list._store = this._store.minmaxDownSample(this._getStoreDimIndex(valueDimension), rate);
    return list;
  }
  lttbDownSample(valueDimension, rate) {
    const list = cloneListForMapAndSample(this);
    list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);
    return list;
  }
  getRawDataItem(idx) {
    return this._store.getRawDataItem(idx);
  }
  getItemModel(idx) {
    const hostModel = this.hostModel;
    const dataItem = this.getRawDataItem(idx);
    return new Model_default(dataItem, hostModel, hostModel && hostModel.ecModel);
  }
  diff(otherList) {
    const thisList = this;
    return new DataDiffer_default(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function(idx) {
      return getId(otherList, idx);
    }, function(idx) {
      return getId(thisList, idx);
    });
  }
  getVisual(key) {
    const visual = this._visual;
    return visual && visual[key];
  }
  setVisual(kvObj, val) {
    this._visual = this._visual || {};
    if (isObject3(kvObj)) {
      extend(this._visual, kvObj);
    } else {
      this._visual[kvObj] = val;
    }
  }
  getItemVisual(idx, key) {
    const itemVisual = this._itemVisuals[idx];
    const val = itemVisual && itemVisual[key];
    if (val == null) {
      return this.getVisual(key);
    }
    return val;
  }
  hasItemVisual() {
    return this._itemVisuals.length > 0;
  }
  ensureUniqueItemVisual(idx, key) {
    const itemVisuals = this._itemVisuals;
    let itemVisual = itemVisuals[idx];
    if (!itemVisual) {
      itemVisual = itemVisuals[idx] = {};
    }
    let val = itemVisual[key];
    if (val == null) {
      val = this.getVisual(key);
      if (isArray(val)) {
        val = val.slice();
      } else if (isObject3(val)) {
        val = extend({}, val);
      }
      itemVisual[key] = val;
    }
    return val;
  }
  setItemVisual(idx, key, value) {
    const itemVisual = this._itemVisuals[idx] || {};
    this._itemVisuals[idx] = itemVisual;
    if (isObject3(key)) {
      extend(itemVisual, key);
    } else {
      itemVisual[key] = value;
    }
  }
  clearAllVisual() {
    this._visual = {};
    this._itemVisuals = [];
  }
  setLayout(key, val) {
    isObject3(key) ? extend(this._layout, key) : this._layout[key] = val;
  }
  getLayout(key) {
    return this._layout[key];
  }
  getItemLayout(idx) {
    return this._itemLayouts[idx];
  }
  setItemLayout(idx, layout14, merge2) {
    this._itemLayouts[idx] = merge2 ? extend(this._itemLayouts[idx] || {}, layout14) : layout14;
  }
  clearItemLayouts() {
    this._itemLayouts.length = 0;
  }
  setItemGraphicEl(idx, el) {
    const seriesIndex = this.hostModel && this.hostModel.seriesIndex;
    setCommonECData(seriesIndex, this.dataType, idx, el);
    this._graphicEls[idx] = el;
  }
  getItemGraphicEl(idx) {
    return this._graphicEls[idx];
  }
  eachItemGraphicEl(cb, context) {
    each(this._graphicEls, function(el, idx) {
      if (el) {
        cb && cb.call(context, el, idx);
      }
    });
  }
  cloneShallow(list) {
    if (!list) {
      list = new SeriesData2(this._schema ? this._schema : map2(this.dimensions, this._getDimInfo, this), this.hostModel);
    }
    transferProperties(list, this);
    list._store = this._store;
    return list;
  }
  wrapMethod(methodName, injectFunction) {
    const originalMethod = this[methodName];
    if (!isFunction(originalMethod)) {
      return;
    }
    this.__wrappedMethods = this.__wrappedMethods || [];
    this.__wrappedMethods.push(methodName);
    this[methodName] = function() {
      const res = originalMethod.apply(this, arguments);
      return injectFunction.apply(this, [res].concat(slice(arguments)));
    };
  }
};
var SeriesData = SeriesData2;
SeriesData.internalField = function() {
  prepareInvertedIndex = function(data) {
    const invertedIndicesMap = data._invertedIndicesMap;
    each(invertedIndicesMap, function(invertedIndices, dim) {
      const dimInfo = data._dimInfos[dim];
      const ordinalMeta = dimInfo.ordinalMeta;
      const store = data._store;
      if (ordinalMeta) {
        invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array2(ordinalMeta.categories.length);
        for (let i = 0; i < invertedIndices.length; i++) {
          invertedIndices[i] = INDEX_NOT_FOUND;
        }
        for (let i = 0; i < store.count(); i++) {
          invertedIndices[store.get(dimInfo.storeDimIndex, i)] = i;
        }
      }
    });
  };
  getIdNameFromStore = function(data, dimIdx, idx) {
    return convertOptionIdName(data._getCategory(dimIdx, idx), null);
  };
  getId = function(data, rawIndex) {
    let id = data._idList[rawIndex];
    if (id == null && data._idDimIdx != null) {
      id = getIdNameFromStore(data, data._idDimIdx, rawIndex);
    }
    if (id == null) {
      id = ID_PREFIX + rawIndex;
    }
    return id;
  };
  normalizeDimensions = function(dimensions) {
    if (!isArray(dimensions)) {
      dimensions = dimensions != null ? [dimensions] : [];
    }
    return dimensions;
  };
  cloneListForMapAndSample = function(original) {
    const list = new SeriesData2(original._schema ? original._schema : map2(original.dimensions, original._getDimInfo, original), original.hostModel);
    transferProperties(list, original);
    return list;
  };
  transferProperties = function(target, source) {
    each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function(propName) {
      if (source.hasOwnProperty(propName)) {
        target[propName] = source[propName];
      }
    });
    target.__wrappedMethods = source.__wrappedMethods;
    each(CLONE_PROPERTIES, function(propName) {
      target[propName] = clone(source[propName]);
    });
    target._calculationInfo = extend({}, source._calculationInfo);
  };
  makeIdFromName = function(data, idx) {
    const nameList = data._nameList;
    const idList = data._idList;
    const nameDimIdx = data._nameDimIdx;
    const idDimIdx = data._idDimIdx;
    let name = nameList[idx];
    let id = idList[idx];
    if (name == null && nameDimIdx != null) {
      nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx);
    }
    if (id == null && idDimIdx != null) {
      idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);
    }
    if (id == null && name != null) {
      const nameRepeatCount = data._nameRepeatCount;
      const nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;
      id = name;
      if (nmCnt > 1) {
        id += "__ec__" + nmCnt;
      }
      idList[idx] = id;
    }
  };
}();
var SeriesData_default = SeriesData;

// src/export/api/helper.ts
var helper_exports = {};
__export(helper_exports, {
  createDimensions: () => createDimensions,
  createList: () => createList,
  createScale: () => createScale,
  createSymbol: () => createSymbol,
  createTextStyle: () => createTextStyle2,
  dataStack: () => dataStack2,
  enableHoverEmphasis: () => enableHoverEmphasis,
  getECData: () => getECData,
  getLayoutRect: () => getLayoutRect,
  mixinAxisModelCommonMethods: () => mixinAxisModelCommonMethods
});

// src/data/helper/createDimensions.ts
function createDimensions(source, opt) {
  return prepareSeriesDataSchema(source, opt).dimensions;
}
function prepareSeriesDataSchema(source, opt) {
  if (!isSourceInstance(source)) {
    source = createSourceFromSeriesDataOption(source);
  }
  opt = opt || {};
  const sysDims = opt.coordDimensions || [];
  const dimsDef = opt.dimensionsDefine || source.dimensionsDefine || [];
  const coordDimNameMap = createHashMap();
  const resultList = [];
  const dimCount = getDimCount(source, sysDims, dimsDef, opt.dimensionsCount);
  const omitUnusedDimensions = opt.canOmitUnusedDimensions && shouldOmitUnusedDimensions(dimCount);
  const isUsingSourceDimensionsDef = dimsDef === source.dimensionsDefine;
  const dataDimNameMap = isUsingSourceDimensionsDef ? ensureSourceDimNameMap(source) : createDimNameMap(dimsDef);
  let encodeDef = opt.encodeDefine;
  if (!encodeDef && opt.encodeDefaulter) {
    encodeDef = opt.encodeDefaulter(source, dimCount);
  }
  const encodeDefMap = createHashMap(encodeDef);
  const indicesMap = new CtorInt32Array(dimCount);
  for (let i = 0; i < indicesMap.length; i++) {
    indicesMap[i] = -1;
  }
  function getResultItem(dimIdx) {
    const idx = indicesMap[dimIdx];
    if (idx < 0) {
      const dimDefItemRaw = dimsDef[dimIdx];
      const dimDefItem = isObject(dimDefItemRaw) ? dimDefItemRaw : {name: dimDefItemRaw};
      const resultItem = new SeriesDimensionDefine_default();
      const userDimName = dimDefItem.name;
      if (userDimName != null && dataDimNameMap.get(userDimName) != null) {
        resultItem.name = resultItem.displayName = userDimName;
      }
      dimDefItem.type != null && (resultItem.type = dimDefItem.type);
      dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);
      const newIdx = resultList.length;
      indicesMap[dimIdx] = newIdx;
      resultItem.storeDimIndex = dimIdx;
      resultList.push(resultItem);
      return resultItem;
    }
    return resultList[idx];
  }
  if (!omitUnusedDimensions) {
    for (let i = 0; i < dimCount; i++) {
      getResultItem(i);
    }
  }
  encodeDefMap.each(function(dataDimsRaw, coordDim) {
    const dataDims = normalizeToArray(dataDimsRaw).slice();
    if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {
      encodeDefMap.set(coordDim, false);
      return;
    }
    const validDataDims = encodeDefMap.set(coordDim, []);
    each(dataDims, function(resultDimIdxOrName, idx) {
      const resultDimIdx = isString(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;
      if (resultDimIdx != null && resultDimIdx < dimCount) {
        validDataDims[idx] = resultDimIdx;
        applyDim(getResultItem(resultDimIdx), coordDim, idx);
      }
    });
  });
  let availDimIdx = 0;
  each(sysDims, function(sysDimItemRaw) {
    let coordDim;
    let sysDimItemDimsDef;
    let sysDimItemOtherDims;
    let sysDimItem;
    if (isString(sysDimItemRaw)) {
      coordDim = sysDimItemRaw;
      sysDimItem = {};
    } else {
      sysDimItem = sysDimItemRaw;
      coordDim = sysDimItem.name;
      const ordinalMeta = sysDimItem.ordinalMeta;
      sysDimItem.ordinalMeta = null;
      sysDimItem = extend({}, sysDimItem);
      sysDimItem.ordinalMeta = ordinalMeta;
      sysDimItemDimsDef = sysDimItem.dimsDef;
      sysDimItemOtherDims = sysDimItem.otherDims;
      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
    }
    let dataDims = encodeDefMap.get(coordDim);
    if (dataDims === false) {
      return;
    }
    dataDims = normalizeToArray(dataDims);
    if (!dataDims.length) {
      for (let i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {
        while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) {
          availDimIdx++;
        }
        availDimIdx < dimCount && dataDims.push(availDimIdx++);
      }
    }
    each(dataDims, function(resultDimIdx, coordDimIndex) {
      const resultItem = getResultItem(resultDimIdx);
      if (isUsingSourceDimensionsDef && sysDimItem.type != null) {
        resultItem.type = sysDimItem.type;
      }
      applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);
      if (resultItem.name == null && sysDimItemDimsDef) {
        let sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];
        !isObject(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {
          name: sysDimItemDimsDefItem
        });
        resultItem.name = resultItem.displayName = sysDimItemDimsDefItem.name;
        resultItem.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;
      }
      sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);
    });
  });
  function applyDim(resultItem, coordDim, coordDimIndex) {
    if (VISUAL_DIMENSIONS.get(coordDim) != null) {
      resultItem.otherDims[coordDim] = coordDimIndex;
    } else {
      resultItem.coordDim = coordDim;
      resultItem.coordDimIndex = coordDimIndex;
      coordDimNameMap.set(coordDim, true);
    }
  }
  const generateCoord = opt.generateCoord;
  let generateCoordCount = opt.generateCoordCount;
  const fromZero = generateCoordCount != null;
  generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;
  const extra = generateCoord || "value";
  function ifNoNameFillWithCoordName(resultItem) {
    if (resultItem.name == null) {
      resultItem.name = resultItem.coordDim;
    }
  }
  if (!omitUnusedDimensions) {
    for (let resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {
      const resultItem = getResultItem(resultDimIdx);
      const coordDim = resultItem.coordDim;
      if (coordDim == null) {
        resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero);
        resultItem.coordDimIndex = 0;
        if (!generateCoord || generateCoordCount <= 0) {
          resultItem.isExtraCoord = true;
        }
        generateCoordCount--;
      }
      ifNoNameFillWithCoordName(resultItem);
      if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {
        resultItem.type = "ordinal";
      }
    }
  } else {
    each(resultList, (resultItem) => {
      ifNoNameFillWithCoordName(resultItem);
    });
    resultList.sort((item0, item1) => item0.storeDimIndex - item1.storeDimIndex);
  }
  removeDuplication(resultList);
  return new SeriesDataSchema({
    source,
    dimensions: resultList,
    fullDimensionCount: dimCount,
    dimensionOmitted: omitUnusedDimensions
  });
}
function removeDuplication(result) {
  const duplicationMap = createHashMap();
  for (let i = 0; i < result.length; i++) {
    const dim = result[i];
    const dimOriginalName = dim.name;
    let count2 = duplicationMap.get(dimOriginalName) || 0;
    if (count2 > 0) {
      dim.name = dimOriginalName + (count2 - 1);
    }
    count2++;
    duplicationMap.set(dimOriginalName, count2);
  }
}
function getDimCount(source, sysDims, dimsDef, optDimCount) {
  let dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);
  each(sysDims, function(sysDimItem) {
    let sysDimItemDimsDef;
    if (isObject(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {
      dimCount = Math.max(dimCount, sysDimItemDimsDef.length);
    }
  });
  return dimCount;
}
function genCoordDimName(name, map3, fromZero) {
  if (fromZero || map3.hasKey(name)) {
    let i = 0;
    while (map3.hasKey(name + i)) {
      i++;
    }
    name += i;
  }
  map3.set(name, true);
  return name;
}

// src/model/referHelper.ts
var CoordSysInfo = class {
  constructor(coordSysName) {
    this.coordSysDims = [];
    this.axisMap = createHashMap();
    this.categoryAxisMap = createHashMap();
    this.coordSysName = coordSysName;
  }
};
function getCoordSysInfoBySeries(seriesModel) {
  const coordSysName = seriesModel.get("coordinateSystem");
  const result = new CoordSysInfo(coordSysName);
  const fetch = fetchers[coordSysName];
  if (fetch) {
    fetch(seriesModel, result, result.axisMap, result.categoryAxisMap);
    return result;
  }
}
var fetchers = {
  cartesian2d: function(seriesModel, result, axisMap, categoryAxisMap) {
    const xAxisModel = seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
    const yAxisModel = seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
    if (true) {
      if (!xAxisModel) {
        throw new Error('xAxis "' + retrieve(seriesModel.get("xAxisIndex"), seriesModel.get("xAxisId"), 0) + '" not found');
      }
      if (!yAxisModel) {
        throw new Error('yAxis "' + retrieve(seriesModel.get("xAxisIndex"), seriesModel.get("yAxisId"), 0) + '" not found');
      }
    }
    result.coordSysDims = ["x", "y"];
    axisMap.set("x", xAxisModel);
    axisMap.set("y", yAxisModel);
    if (isCategory(xAxisModel)) {
      categoryAxisMap.set("x", xAxisModel);
      result.firstCategoryDimIndex = 0;
    }
    if (isCategory(yAxisModel)) {
      categoryAxisMap.set("y", yAxisModel);
      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
    }
  },
  singleAxis: function(seriesModel, result, axisMap, categoryAxisMap) {
    const singleAxisModel = seriesModel.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
    if (true) {
      if (!singleAxisModel) {
        throw new Error("singleAxis should be specified.");
      }
    }
    result.coordSysDims = ["single"];
    axisMap.set("single", singleAxisModel);
    if (isCategory(singleAxisModel)) {
      categoryAxisMap.set("single", singleAxisModel);
      result.firstCategoryDimIndex = 0;
    }
  },
  polar: function(seriesModel, result, axisMap, categoryAxisMap) {
    const polarModel = seriesModel.getReferringComponents("polar", SINGLE_REFERRING).models[0];
    const radiusAxisModel = polarModel.findAxisModel("radiusAxis");
    const angleAxisModel = polarModel.findAxisModel("angleAxis");
    if (true) {
      if (!angleAxisModel) {
        throw new Error("angleAxis option not found");
      }
      if (!radiusAxisModel) {
        throw new Error("radiusAxis option not found");
      }
    }
    result.coordSysDims = ["radius", "angle"];
    axisMap.set("radius", radiusAxisModel);
    axisMap.set("angle", angleAxisModel);
    if (isCategory(radiusAxisModel)) {
      categoryAxisMap.set("radius", radiusAxisModel);
      result.firstCategoryDimIndex = 0;
    }
    if (isCategory(angleAxisModel)) {
      categoryAxisMap.set("angle", angleAxisModel);
      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
    }
  },
  geo: function(seriesModel, result, axisMap, categoryAxisMap) {
    result.coordSysDims = ["lng", "lat"];
  },
  parallel: function(seriesModel, result, axisMap, categoryAxisMap) {
    const ecModel = seriesModel.ecModel;
    const parallelModel = ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
    const coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();
    each(parallelModel.parallelAxisIndex, function(axisIndex, index) {
      const axisModel = ecModel.getComponent("parallelAxis", axisIndex);
      const axisDim = coordSysDims[index];
      axisMap.set(axisDim, axisModel);
      if (isCategory(axisModel)) {
        categoryAxisMap.set(axisDim, axisModel);
        if (result.firstCategoryDimIndex == null) {
          result.firstCategoryDimIndex = index;
        }
      }
    });
  },
  matrix: function(seriesModel, result, axisMap, categoryAxisMap) {
    const matrixModel = seriesModel.getReferringComponents("matrix", SINGLE_REFERRING).models[0];
    if (true) {
      if (!matrixModel) {
        throw new Error("matrix coordinate system should be specified.");
      }
    }
    result.coordSysDims = ["x", "y"];
    const xModel = matrixModel.getDimensionModel("x");
    const yModel = matrixModel.getDimensionModel("y");
    axisMap.set("x", xModel);
    axisMap.set("y", yModel);
    categoryAxisMap.set("x", xModel);
    categoryAxisMap.set("y", yModel);
  }
};
function isCategory(axisModel) {
  return axisModel.get("type") === "category";
}

// src/data/helper/dataStackHelper.ts
function enableDataStack(seriesModel, dimensionsInput, opt) {
  opt = opt || {};
  let byIndex = opt.byIndex;
  const stackedCoordDimension = opt.stackedCoordDimension;
  let dimensionDefineList;
  let schema;
  let store;
  if (isLegacyDimensionsInput(dimensionsInput)) {
    dimensionDefineList = dimensionsInput;
  } else {
    schema = dimensionsInput.schema;
    dimensionDefineList = schema.dimensions;
    store = dimensionsInput.store;
  }
  const mayStack = !!(seriesModel && seriesModel.get("stack"));
  let stackedByDimInfo;
  let stackedDimInfo;
  let stackResultDimension;
  let stackedOverDimension;
  each(dimensionDefineList, function(dimensionInfo, index) {
    if (isString(dimensionInfo)) {
      dimensionDefineList[index] = dimensionInfo = {
        name: dimensionInfo
      };
    }
    if (mayStack && !dimensionInfo.isExtraCoord) {
      if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {
        stackedByDimInfo = dimensionInfo;
      }
      if (!stackedDimInfo && dimensionInfo.type !== "ordinal" && dimensionInfo.type !== "time" && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {
        stackedDimInfo = dimensionInfo;
      }
    }
  });
  if (stackedDimInfo && !byIndex && !stackedByDimInfo) {
    byIndex = true;
  }
  if (stackedDimInfo) {
    stackResultDimension = "__\0ecstackresult_" + seriesModel.id;
    stackedOverDimension = "__\0ecstackedover_" + seriesModel.id;
    if (stackedByDimInfo) {
      stackedByDimInfo.createInvertedIndices = true;
    }
    const stackedDimCoordDim = stackedDimInfo.coordDim;
    const stackedDimType = stackedDimInfo.type;
    let stackedDimCoordIndex = 0;
    each(dimensionDefineList, function(dimensionInfo) {
      if (dimensionInfo.coordDim === stackedDimCoordDim) {
        stackedDimCoordIndex++;
      }
    });
    const stackedOverDimensionDefine = {
      name: stackResultDimension,
      coordDim: stackedDimCoordDim,
      coordDimIndex: stackedDimCoordIndex,
      type: stackedDimType,
      isExtraCoord: true,
      isCalculationCoord: true,
      storeDimIndex: dimensionDefineList.length
    };
    const stackResultDimensionDefine = {
      name: stackedOverDimension,
      coordDim: stackedOverDimension,
      coordDimIndex: stackedDimCoordIndex + 1,
      type: stackedDimType,
      isExtraCoord: true,
      isCalculationCoord: true,
      storeDimIndex: dimensionDefineList.length + 1
    };
    if (schema) {
      if (store) {
        stackedOverDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackedOverDimension, stackedDimType);
        stackResultDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackResultDimension, stackedDimType);
      }
      schema.appendCalculationDimension(stackedOverDimensionDefine);
      schema.appendCalculationDimension(stackResultDimensionDefine);
    } else {
      dimensionDefineList.push(stackedOverDimensionDefine);
      dimensionDefineList.push(stackResultDimensionDefine);
    }
  }
  return {
    stackedDimension: stackedDimInfo && stackedDimInfo.name,
    stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,
    isStackedByIndex: byIndex,
    stackedOverDimension,
    stackResultDimension
  };
}
function isLegacyDimensionsInput(dimensionsInput) {
  return !isSeriesDataSchema(dimensionsInput.schema);
}
function isDimensionStacked(data, stackedDim) {
  return !!stackedDim && stackedDim === data.getCalculationInfo("stackedDimension");
}
function getStackedDimension(data, targetDim) {
  return isDimensionStacked(data, targetDim) ? data.getCalculationInfo("stackResultDimension") : targetDim;
}

// src/chart/helper/createSeriesData.ts
function getCoordSysDimDefs(seriesModel, coordSysInfo) {
  const coordSysName = seriesModel.get("coordinateSystem");
  const registeredCoordSys = CoordinateSystem_default.get(coordSysName);
  let coordSysDimDefs;
  if (coordSysInfo && coordSysInfo.coordSysDims) {
    coordSysDimDefs = map(coordSysInfo.coordSysDims, function(dim) {
      const dimInfo = {
        name: dim
      };
      const axisModel = coordSysInfo.axisMap.get(dim);
      if (axisModel) {
        const axisType = axisModel.get("type");
        dimInfo.type = getDimensionTypeByAxis(axisType);
      }
      return dimInfo;
    });
  }
  if (!coordSysDimDefs) {
    coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ["x", "y"];
  }
  return coordSysDimDefs;
}
function injectOrdinalMeta(dimInfoList, createInvertedIndices, coordSysInfo) {
  let firstCategoryDimIndex;
  let hasNameEncode;
  coordSysInfo && each(dimInfoList, function(dimInfo, dimIndex) {
    const coordDim = dimInfo.coordDim;
    const categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);
    if (categoryAxisModel) {
      if (firstCategoryDimIndex == null) {
        firstCategoryDimIndex = dimIndex;
      }
      dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();
      if (createInvertedIndices) {
        dimInfo.createInvertedIndices = true;
      }
    }
    if (dimInfo.otherDims.itemName != null) {
      hasNameEncode = true;
    }
  });
  if (!hasNameEncode && firstCategoryDimIndex != null) {
    dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;
  }
  return firstCategoryDimIndex;
}
function createSeriesData(sourceRaw, seriesModel, opt) {
  opt = opt || {};
  const sourceManager = seriesModel.getSourceManager();
  let source;
  let isOriginalSource = false;
  if (sourceRaw) {
    isOriginalSource = true;
    source = createSourceFromSeriesDataOption(sourceRaw);
  } else {
    source = sourceManager.getSource();
    isOriginalSource = source.sourceFormat === SOURCE_FORMAT_ORIGINAL;
  }
  const coordSysInfo = getCoordSysInfoBySeries(seriesModel);
  const coordSysDimDefs = getCoordSysDimDefs(seriesModel, coordSysInfo);
  const useEncodeDefaulter = opt.useEncodeDefaulter;
  const encodeDefaulter = isFunction(useEncodeDefaulter) ? useEncodeDefaulter : useEncodeDefaulter ? curry(makeSeriesEncodeForAxisCoordSys, coordSysDimDefs, seriesModel) : null;
  const createDimensionOptions = {
    coordDimensions: coordSysDimDefs,
    generateCoord: opt.generateCoord,
    encodeDefine: seriesModel.getEncode(),
    encodeDefaulter,
    canOmitUnusedDimensions: !isOriginalSource
  };
  const schema = prepareSeriesDataSchema(source, createDimensionOptions);
  const firstCategoryDimIndex = injectOrdinalMeta(schema.dimensions, opt.createInvertedIndices, coordSysInfo);
  const store = !isOriginalSource ? sourceManager.getSharedDataStore(schema) : null;
  const stackCalculationInfo = enableDataStack(seriesModel, {schema, store});
  const data = new SeriesData_default(schema, seriesModel);
  data.setCalculationInfo(stackCalculationInfo);
  const dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function(itemOpt, dimName, dataIndex, dimIndex) {
    return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);
  } : null;
  data.hasItemOption = false;
  data.initData(isOriginalSource ? source : store, null, dimValueGetter);
  return data;
}
function isNeedCompleteOrdinalData(source) {
  if (source.sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    const sampleItem = firstDataNotNull(source.data || []);
    return !isArray(getDataItemValue(sampleItem));
  }
}
function firstDataNotNull(arr) {
  let i = 0;
  while (i < arr.length && arr[i] == null) {
    i++;
  }
  return arr[i];
}
var createSeriesData_default = createSeriesData;

// src/scale/helper.ts
function isValueNice(val) {
  const exp10 = Math.pow(10, quantityExponent(Math.abs(val)));
  const f = Math.abs(val / exp10);
  return f === 0 || f === 1 || f === 2 || f === 3 || f === 5;
}
function isIntervalOrLogScale(scale4) {
  return scale4.type === "interval" || scale4.type === "log";
}
function intervalScaleNiceTicks(extent, spanWithBreaks, splitNumber, minInterval, maxInterval) {
  const result = {};
  let interval = result.interval = nice(spanWithBreaks / splitNumber, true);
  if (minInterval != null && interval < minInterval) {
    interval = result.interval = minInterval;
  }
  if (maxInterval != null && interval > maxInterval) {
    interval = result.interval = maxInterval;
  }
  const precision = result.intervalPrecision = getIntervalPrecision(interval);
  const niceTickExtent = result.niceTickExtent = [
    round(Math.ceil(extent[0] / interval) * interval, precision),
    round(Math.floor(extent[1] / interval) * interval, precision)
  ];
  fixExtent(niceTickExtent, extent);
  return result;
}
function increaseInterval(interval) {
  const exp10 = Math.pow(10, quantityExponent(interval));
  let f = interval / exp10;
  if (!f) {
    f = 1;
  } else if (f === 2) {
    f = 3;
  } else if (f === 3) {
    f = 5;
  } else {
    f *= 2;
  }
  return round(f * exp10);
}
function getIntervalPrecision(interval) {
  return getPrecision(interval) + 2;
}
function clamp(niceTickExtent, idx, extent) {
  niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);
}
function fixExtent(niceTickExtent, extent) {
  !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);
  !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);
  clamp(niceTickExtent, 0, extent);
  clamp(niceTickExtent, 1, extent);
  if (niceTickExtent[0] > niceTickExtent[1]) {
    niceTickExtent[0] = niceTickExtent[1];
  }
}
function contain2(val, extent) {
  return val >= extent[0] && val <= extent[1];
}
var ScaleCalculator = class {
  constructor() {
    this.normalize = normalize2;
    this.scale = scale3;
  }
  updateMethods(brkCtx) {
    if (brkCtx.hasBreaks()) {
      this.normalize = bind(brkCtx.normalize, brkCtx);
      this.scale = bind(brkCtx.scale, brkCtx);
    } else {
      this.normalize = normalize2;
      this.scale = scale3;
    }
  }
};
function normalize2(val, extent) {
  if (extent[1] === extent[0]) {
    return 0.5;
  }
  return (val - extent[0]) / (extent[1] - extent[0]);
}
function scale3(val, extent) {
  return val * (extent[1] - extent[0]) + extent[0];
}
function logTransform(base2, extent, noClampNegative) {
  const loggedBase = Math.log(base2);
  return [
    Math.log(noClampNegative ? extent[0] : Math.max(0, extent[0])) / loggedBase,
    Math.log(noClampNegative ? extent[1] : Math.max(0, extent[1])) / loggedBase
  ];
}

// src/scale/Scale.ts
var Scale = class {
  constructor(setting) {
    this._calculator = new ScaleCalculator();
    this._setting = setting || {};
    this._extent = [Infinity, -Infinity];
    const scaleBreakHelper = getScaleBreakHelper();
    if (scaleBreakHelper) {
      this._brkCtx = scaleBreakHelper.createScaleBreakContext();
      this._brkCtx.update(this._extent);
    }
  }
  getSetting(name) {
    return this._setting[name];
  }
  _innerUnionExtent(other) {
    const extent = this._extent;
    this._innerSetExtent(other[0] < extent[0] ? other[0] : extent[0], other[1] > extent[1] ? other[1] : extent[1]);
  }
  unionExtentFromData(data, dim) {
    this._innerUnionExtent(data.getApproximateExtent(dim));
  }
  getExtent() {
    return this._extent.slice();
  }
  setExtent(start2, end2) {
    this._innerSetExtent(start2, end2);
  }
  _innerSetExtent(start2, end2) {
    const thisExtent = this._extent;
    if (!isNaN(start2)) {
      thisExtent[0] = start2;
    }
    if (!isNaN(end2)) {
      thisExtent[1] = end2;
    }
    this._brkCtx && this._brkCtx.update(thisExtent);
  }
  setBreaksFromOption(breakOptionList) {
    const scaleBreakHelper = getScaleBreakHelper();
    if (scaleBreakHelper) {
      this._innerSetBreak(scaleBreakHelper.parseAxisBreakOption(breakOptionList, bind(this.parse, this)));
    }
  }
  _innerSetBreak(parsed) {
    if (this._brkCtx) {
      this._brkCtx.setBreaks(parsed);
      this._calculator.updateMethods(this._brkCtx);
      this._brkCtx.update(this._extent);
    }
  }
  _innerGetBreaks() {
    return this._brkCtx ? this._brkCtx.breaks : [];
  }
  hasBreaks() {
    return this._brkCtx ? this._brkCtx.hasBreaks() : false;
  }
  _getExtentSpanWithBreaks() {
    return this._brkCtx && this._brkCtx.hasBreaks() ? this._brkCtx.getExtentSpan() : this._extent[1] - this._extent[0];
  }
  isInExtentRange(value) {
    return this._extent[0] <= value && this._extent[1] >= value;
  }
  isBlank() {
    return this._isBlank;
  }
  setBlank(isBlank) {
    this._isBlank = isBlank;
  }
};
enableClassManagement(Scale);
var Scale_default = Scale;

// src/data/OrdinalMeta.ts
var uidBase = 0;
var OrdinalMeta = class {
  constructor(opt) {
    this.categories = opt.categories || [];
    this._needCollect = opt.needCollect;
    this._deduplication = opt.deduplication;
    this.uid = ++uidBase;
    this._onCollect = opt.onCollect;
  }
  static createByAxisModel(axisModel) {
    const option = axisModel.option;
    const data = option.data;
    const categories = data && map(data, getName);
    return new OrdinalMeta({
      categories,
      needCollect: !categories,
      deduplication: option.dedplication !== false
    });
  }
  getOrdinal(category) {
    return this._getOrCreateMap().get(category);
  }
  parseAndCollect(category) {
    let index;
    const needCollect = this._needCollect;
    if (!isString(category) && !needCollect) {
      return category;
    }
    if (needCollect && !this._deduplication) {
      index = this.categories.length;
      this.categories[index] = category;
      this._onCollect && this._onCollect(category, index);
      return index;
    }
    const map3 = this._getOrCreateMap();
    index = map3.get(category);
    if (index == null) {
      if (needCollect) {
        index = this.categories.length;
        this.categories[index] = category;
        map3.set(category, index);
        this._onCollect && this._onCollect(category, index);
      } else {
        index = NaN;
      }
    }
    return index;
  }
  _getOrCreateMap() {
    return this._map || (this._map = createHashMap(this.categories));
  }
};
function getName(obj) {
  if (isObject(obj) && obj.value != null) {
    return obj.value;
  } else {
    return obj + "";
  }
}
var OrdinalMeta_default = OrdinalMeta;

// src/scale/Ordinal.ts
var OrdinalScale = class extends Scale_default {
  constructor(setting) {
    super(setting);
    this.type = "ordinal";
    let ordinalMeta = this.getSetting("ordinalMeta");
    if (!ordinalMeta) {
      ordinalMeta = new OrdinalMeta_default({});
    }
    if (isArray(ordinalMeta)) {
      ordinalMeta = new OrdinalMeta_default({
        categories: map(ordinalMeta, (item) => isObject(item) ? item.value : item)
      });
    }
    this._ordinalMeta = ordinalMeta;
    this._extent = this.getSetting("extent") || [0, ordinalMeta.categories.length - 1];
  }
  parse(val) {
    if (val == null) {
      return NaN;
    }
    return isString(val) ? this._ordinalMeta.getOrdinal(val) : Math.round(val);
  }
  contain(val) {
    return contain2(val, this._extent) && val >= 0 && val < this._ordinalMeta.categories.length;
  }
  normalize(val) {
    val = this._getTickNumber(val);
    return this._calculator.normalize(val, this._extent);
  }
  scale(val) {
    val = Math.round(this._calculator.scale(val, this._extent));
    return this.getRawOrdinalNumber(val);
  }
  getTicks() {
    const ticks = [];
    const extent = this._extent;
    let rank = extent[0];
    while (rank <= extent[1]) {
      ticks.push({
        value: rank
      });
      rank++;
    }
    return ticks;
  }
  getMinorTicks(splitNumber) {
    return;
  }
  setSortInfo(info) {
    if (info == null) {
      this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
      return;
    }
    const infoOrdinalNumbers = info.ordinalNumbers;
    const ordinalsByTick = this._ordinalNumbersByTick = [];
    const ticksByOrdinal = this._ticksByOrdinalNumber = [];
    let tickNum = 0;
    const allCategoryLen = this._ordinalMeta.categories.length;
    for (const len2 = Math.min(allCategoryLen, infoOrdinalNumbers.length); tickNum < len2; ++tickNum) {
      const ordinalNumber = infoOrdinalNumbers[tickNum];
      ordinalsByTick[tickNum] = ordinalNumber;
      ticksByOrdinal[ordinalNumber] = tickNum;
    }
    let unusedOrdinal = 0;
    for (; tickNum < allCategoryLen; ++tickNum) {
      while (ticksByOrdinal[unusedOrdinal] != null) {
        unusedOrdinal++;
      }
      ;
      ordinalsByTick.push(unusedOrdinal);
      ticksByOrdinal[unusedOrdinal] = tickNum;
    }
  }
  _getTickNumber(ordinal) {
    const ticksByOrdinalNumber = this._ticksByOrdinalNumber;
    return ticksByOrdinalNumber && ordinal >= 0 && ordinal < ticksByOrdinalNumber.length ? ticksByOrdinalNumber[ordinal] : ordinal;
  }
  getRawOrdinalNumber(tickNumber) {
    const ordinalNumbersByTick = this._ordinalNumbersByTick;
    return ordinalNumbersByTick && tickNumber >= 0 && tickNumber < ordinalNumbersByTick.length ? ordinalNumbersByTick[tickNumber] : tickNumber;
  }
  getLabel(tick) {
    if (!this.isBlank()) {
      const ordinalNumber = this.getRawOrdinalNumber(tick.value);
      const cateogry = this._ordinalMeta.categories[ordinalNumber];
      return cateogry == null ? "" : cateogry + "";
    }
  }
  count() {
    return this._extent[1] - this._extent[0] + 1;
  }
  isInExtentRange(value) {
    value = this._getTickNumber(value);
    return this._extent[0] <= value && this._extent[1] >= value;
  }
  getOrdinalMeta() {
    return this._ordinalMeta;
  }
  calcNiceTicks() {
  }
  calcNiceExtent() {
  }
};
OrdinalScale.type = "ordinal";
Scale_default.registerClass(OrdinalScale);
var Ordinal_default = OrdinalScale;

// src/scale/Interval.ts
var roundNumber = round;
var IntervalScale = class extends Scale_default {
  constructor() {
    super(...arguments);
    this.type = "interval";
    this._interval = 0;
    this._intervalPrecision = 2;
  }
  parse(val) {
    return val == null || val === "" ? NaN : Number(val);
  }
  contain(val) {
    return contain2(val, this._extent);
  }
  normalize(val) {
    return this._calculator.normalize(val, this._extent);
  }
  scale(val) {
    return this._calculator.scale(val, this._extent);
  }
  getInterval() {
    return this._interval;
  }
  setInterval(interval) {
    this._interval = interval;
    this._niceExtent = this._extent.slice();
    this._intervalPrecision = getIntervalPrecision(interval);
  }
  getTicks(opt) {
    opt = opt || {};
    const interval = this._interval;
    const extent = this._extent;
    const niceTickExtent = this._niceExtent;
    const intervalPrecision = this._intervalPrecision;
    const scaleBreakHelper = getScaleBreakHelper();
    const ticks = [];
    if (!interval) {
      return ticks;
    }
    if (opt.breakTicks === "only_break" && scaleBreakHelper) {
      scaleBreakHelper.addBreaksToTicks(ticks, this._brkCtx.breaks, this._extent);
      return ticks;
    }
    const safeLimit = 1e4;
    if (extent[0] < niceTickExtent[0]) {
      if (opt.expandToNicedExtent) {
        ticks.push({
          value: roundNumber(niceTickExtent[0] - interval, intervalPrecision)
        });
      } else {
        ticks.push({
          value: extent[0]
        });
      }
    }
    const estimateNiceMultiple = (tickVal, targetTick) => {
      return Math.round((targetTick - tickVal) / interval);
    };
    let tick = niceTickExtent[0];
    while (tick <= niceTickExtent[1]) {
      ticks.push({
        value: tick
      });
      tick = roundNumber(tick + interval, intervalPrecision);
      if (this._brkCtx) {
        const moreMultiple = this._brkCtx.calcNiceTickMultiple(tick, estimateNiceMultiple);
        if (moreMultiple >= 0) {
          tick = roundNumber(tick + moreMultiple * interval, intervalPrecision);
        }
      }
      if (ticks.length > 0 && tick === ticks[ticks.length - 1].value) {
        break;
      }
      if (ticks.length > safeLimit) {
        return [];
      }
    }
    const lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];
    if (extent[1] > lastNiceTick) {
      if (opt.expandToNicedExtent) {
        ticks.push({
          value: roundNumber(lastNiceTick + interval, intervalPrecision)
        });
      } else {
        ticks.push({
          value: extent[1]
        });
      }
    }
    if (scaleBreakHelper) {
      scaleBreakHelper.pruneTicksByBreak(opt.pruneByBreak, ticks, this._brkCtx.breaks, (item) => item.value, this._interval, this._extent);
    }
    if (opt.breakTicks !== "none" && scaleBreakHelper) {
      scaleBreakHelper.addBreaksToTicks(ticks, this._brkCtx.breaks, this._extent);
    }
    return ticks;
  }
  getMinorTicks(splitNumber) {
    const ticks = this.getTicks({
      expandToNicedExtent: true
    });
    const minorTicks = [];
    const extent = this.getExtent();
    for (let i = 1; i < ticks.length; i++) {
      const nextTick = ticks[i];
      const prevTick = ticks[i - 1];
      if (prevTick.break || nextTick.break) {
        continue;
      }
      let count2 = 0;
      const minorTicksGroup = [];
      const interval = nextTick.value - prevTick.value;
      const minorInterval = interval / splitNumber;
      while (count2 < splitNumber - 1) {
        const minorTick = roundNumber(prevTick.value + (count2 + 1) * minorInterval);
        if (minorTick > extent[0] && minorTick < extent[1]) {
          minorTicksGroup.push(minorTick);
        }
        count2++;
      }
      const scaleBreakHelper = getScaleBreakHelper();
      scaleBreakHelper && scaleBreakHelper.pruneTicksByBreak("auto", minorTicksGroup, this._getNonTransBreaks(), (value) => value, this._interval, extent);
      minorTicks.push(minorTicksGroup);
    }
    return minorTicks;
  }
  _getNonTransBreaks() {
    return this._brkCtx ? this._brkCtx.breaks : [];
  }
  getLabel(data, opt) {
    if (data == null) {
      return "";
    }
    let precision = opt && opt.precision;
    if (precision == null) {
      precision = getPrecision(data.value) || 0;
    } else if (precision === "auto") {
      precision = this._intervalPrecision;
    }
    const dataNum = roundNumber(data.value, precision, true);
    return addCommas(dataNum);
  }
  calcNiceTicks(splitNumber, minInterval, maxInterval) {
    splitNumber = splitNumber || 5;
    let extent = this._extent.slice();
    let span = this._getExtentSpanWithBreaks();
    if (!isFinite(span)) {
      return;
    }
    if (span < 0) {
      span = -span;
      extent.reverse();
      this._innerSetExtent(extent[0], extent[1]);
      extent = this._extent.slice();
    }
    const result = intervalScaleNiceTicks(extent, span, splitNumber, minInterval, maxInterval);
    this._intervalPrecision = result.intervalPrecision;
    this._interval = result.interval;
    this._niceExtent = result.niceTickExtent;
  }
  calcNiceExtent(opt) {
    let extent = this._extent.slice();
    if (extent[0] === extent[1]) {
      if (extent[0] !== 0) {
        const expandSize = Math.abs(extent[0]);
        if (!opt.fixMax) {
          extent[1] += expandSize / 2;
          extent[0] -= expandSize / 2;
        } else {
          extent[0] -= expandSize / 2;
        }
      } else {
        extent[1] = 1;
      }
    }
    const span = extent[1] - extent[0];
    if (!isFinite(span)) {
      extent[0] = 0;
      extent[1] = 1;
    }
    this._innerSetExtent(extent[0], extent[1]);
    extent = this._extent.slice();
    this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
    const interval = this._interval;
    if (!opt.fixMin) {
      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);
    }
    if (!opt.fixMax) {
      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);
    }
    this._innerSetExtent(extent[0], extent[1]);
  }
  setNiceExtent(min3, max3) {
    this._niceExtent = [min3, max3];
  }
};
IntervalScale.type = "interval";
Scale_default.registerClass(IntervalScale);
var Interval_default = IntervalScale;

// src/util/vendor.ts
var supportFloat32Array = typeof Float32Array !== "undefined";
var Float32ArrayCtor = !supportFloat32Array ? Array : Float32Array;
function createFloat32Array(arg) {
  if (isArray(arg)) {
    return supportFloat32Array ? new Float32Array(arg) : arg;
  }
  return new Float32ArrayCtor(arg);
}

// src/layout/barGrid.ts
var STACK_PREFIX = "__ec_stack_";
function getSeriesStackId(seriesModel) {
  return seriesModel.get("stack") || STACK_PREFIX + seriesModel.seriesIndex;
}
function getAxisKey(axis) {
  return axis.dim + axis.index;
}
function getLayoutOnAxis(opt) {
  const params = [];
  const baseAxis = opt.axis;
  const axisKey = "axis0";
  if (baseAxis.type !== "category") {
    return;
  }
  const bandWidth = baseAxis.getBandWidth();
  for (let i = 0; i < opt.count || 0; i++) {
    params.push(defaults({
      bandWidth,
      axisKey,
      stackId: STACK_PREFIX + i
    }, opt));
  }
  const widthAndOffsets = doCalBarWidthAndOffset(params);
  const result = [];
  for (let i = 0; i < opt.count; i++) {
    const item = widthAndOffsets[axisKey][STACK_PREFIX + i];
    item.offsetCenter = item.offset + item.width / 2;
    result.push(item);
  }
  return result;
}
function prepareLayoutBarSeries(seriesType2, ecModel) {
  const seriesModels = [];
  ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
    if (isOnCartesian(seriesModel)) {
      seriesModels.push(seriesModel);
    }
  });
  return seriesModels;
}
function getValueAxesMinGaps(barSeries) {
  const axisValues = {};
  each(barSeries, function(seriesModel) {
    const cartesian = seriesModel.coordinateSystem;
    const baseAxis = cartesian.getBaseAxis();
    if (baseAxis.type !== "time" && baseAxis.type !== "value") {
      return;
    }
    const data = seriesModel.getData();
    const key = baseAxis.dim + "_" + baseAxis.index;
    const dimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
    const store = data.getStore();
    for (let i = 0, cnt = store.count(); i < cnt; ++i) {
      const value = store.get(dimIdx, i);
      if (!axisValues[key]) {
        axisValues[key] = [value];
      } else {
        axisValues[key].push(value);
      }
    }
  });
  const axisMinGaps = {};
  for (const key in axisValues) {
    if (axisValues.hasOwnProperty(key)) {
      const valuesInAxis = axisValues[key];
      if (valuesInAxis) {
        valuesInAxis.sort(function(a, b) {
          return a - b;
        });
        let min3 = null;
        for (let j = 1; j < valuesInAxis.length; ++j) {
          const delta = valuesInAxis[j] - valuesInAxis[j - 1];
          if (delta > 0) {
            min3 = min3 === null ? delta : Math.min(min3, delta);
          }
        }
        axisMinGaps[key] = min3;
      }
    }
  }
  return axisMinGaps;
}
function makeColumnLayout(barSeries) {
  const axisMinGaps = getValueAxesMinGaps(barSeries);
  const seriesInfoList = [];
  each(barSeries, function(seriesModel) {
    const cartesian = seriesModel.coordinateSystem;
    const baseAxis = cartesian.getBaseAxis();
    const axisExtent = baseAxis.getExtent();
    let bandWidth;
    if (baseAxis.type === "category") {
      bandWidth = baseAxis.getBandWidth();
    } else if (baseAxis.type === "value" || baseAxis.type === "time") {
      const key = baseAxis.dim + "_" + baseAxis.index;
      const minGap = axisMinGaps[key];
      const extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);
      const scale4 = baseAxis.scale.getExtent();
      const scaleSpan = Math.abs(scale4[1] - scale4[0]);
      bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan;
    } else {
      const data = seriesModel.getData();
      bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
    }
    const barWidth = parsePercent2(seriesModel.get("barWidth"), bandWidth);
    const barMaxWidth = parsePercent2(seriesModel.get("barMaxWidth"), bandWidth);
    const barMinWidth = parsePercent2(seriesModel.get("barMinWidth") || (isInLargeMode(seriesModel) ? 0.5 : 1), bandWidth);
    const barGap = seriesModel.get("barGap");
    const barCategoryGap = seriesModel.get("barCategoryGap");
    const defaultBarGap = seriesModel.get("defaultBarGap");
    seriesInfoList.push({
      bandWidth,
      barWidth,
      barMaxWidth,
      barMinWidth,
      barGap,
      barCategoryGap,
      defaultBarGap,
      axisKey: getAxisKey(baseAxis),
      stackId: getSeriesStackId(seriesModel)
    });
  });
  return doCalBarWidthAndOffset(seriesInfoList);
}
function doCalBarWidthAndOffset(seriesInfoList) {
  const columnsMap = {};
  each(seriesInfoList, function(seriesInfo, idx) {
    const axisKey = seriesInfo.axisKey;
    const bandWidth = seriesInfo.bandWidth;
    const columnsOnAxis = columnsMap[axisKey] || {
      bandWidth,
      remainedWidth: bandWidth,
      autoWidthCount: 0,
      categoryGap: null,
      gap: seriesInfo.defaultBarGap || 0,
      stacks: {}
    };
    const stacks = columnsOnAxis.stacks;
    columnsMap[axisKey] = columnsOnAxis;
    const stackId = seriesInfo.stackId;
    if (!stacks[stackId]) {
      columnsOnAxis.autoWidthCount++;
    }
    stacks[stackId] = stacks[stackId] || {
      width: 0,
      maxWidth: 0
    };
    let barWidth = seriesInfo.barWidth;
    if (barWidth && !stacks[stackId].width) {
      stacks[stackId].width = barWidth;
      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
      columnsOnAxis.remainedWidth -= barWidth;
    }
    const barMaxWidth = seriesInfo.barMaxWidth;
    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
    const barMinWidth = seriesInfo.barMinWidth;
    barMinWidth && (stacks[stackId].minWidth = barMinWidth);
    const barGap = seriesInfo.barGap;
    barGap != null && (columnsOnAxis.gap = barGap);
    const barCategoryGap = seriesInfo.barCategoryGap;
    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
  });
  const result = {};
  each(columnsMap, function(columnsOnAxis, coordSysName) {
    result[coordSysName] = {};
    const stacks = columnsOnAxis.stacks;
    const bandWidth = columnsOnAxis.bandWidth;
    let categoryGapPercent = columnsOnAxis.categoryGap;
    if (categoryGapPercent == null) {
      const columnCount = keys(stacks).length;
      categoryGapPercent = Math.max(35 - columnCount * 4, 15) + "%";
    }
    const categoryGap = parsePercent2(categoryGapPercent, bandWidth);
    const barGapPercent = parsePercent2(columnsOnAxis.gap, 1);
    let remainedWidth = columnsOnAxis.remainedWidth;
    let autoWidthCount = columnsOnAxis.autoWidthCount;
    let autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    each(stacks, function(column) {
      const maxWidth = column.maxWidth;
      const minWidth = column.minWidth;
      if (!column.width) {
        let finalWidth = autoWidth;
        if (maxWidth && maxWidth < finalWidth) {
          finalWidth = Math.min(maxWidth, remainedWidth);
        }
        if (minWidth && minWidth > finalWidth) {
          finalWidth = minWidth;
        }
        if (finalWidth !== autoWidth) {
          column.width = finalWidth;
          remainedWidth -= finalWidth + barGapPercent * finalWidth;
          autoWidthCount--;
        }
      } else {
        let finalWidth = column.width;
        if (maxWidth) {
          finalWidth = Math.min(finalWidth, maxWidth);
        }
        if (minWidth) {
          finalWidth = Math.max(finalWidth, minWidth);
        }
        column.width = finalWidth;
        remainedWidth -= finalWidth + barGapPercent * finalWidth;
        autoWidthCount--;
      }
    });
    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    let widthSum = 0;
    let lastColumn;
    each(stacks, function(column, idx) {
      if (!column.width) {
        column.width = autoWidth;
      }
      lastColumn = column;
      widthSum += column.width * (1 + barGapPercent);
    });
    if (lastColumn) {
      widthSum -= lastColumn.width * barGapPercent;
    }
    let offset = -widthSum / 2;
    each(stacks, function(column, stackId) {
      result[coordSysName][stackId] = result[coordSysName][stackId] || {
        bandWidth,
        offset,
        width: column.width
      };
      offset += column.width * (1 + barGapPercent);
    });
  });
  return result;
}
function retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {
  if (barWidthAndOffset && axis) {
    const result = barWidthAndOffset[getAxisKey(axis)];
    if (result != null && seriesModel != null) {
      return result[getSeriesStackId(seriesModel)];
    }
    return result;
  }
}
function layout2(seriesType2, ecModel) {
  const seriesModels = prepareLayoutBarSeries(seriesType2, ecModel);
  const barWidthAndOffset = makeColumnLayout(seriesModels);
  each(seriesModels, function(seriesModel) {
    const data = seriesModel.getData();
    const cartesian = seriesModel.coordinateSystem;
    const baseAxis = cartesian.getBaseAxis();
    const stackId = getSeriesStackId(seriesModel);
    const columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];
    const columnOffset = columnLayoutInfo.offset;
    const columnWidth = columnLayoutInfo.width;
    data.setLayout({
      bandWidth: columnLayoutInfo.bandWidth,
      offset: columnOffset,
      size: columnWidth
    });
  });
}
function createProgressiveLayout(seriesType2) {
  return {
    seriesType: seriesType2,
    plan: createRenderPlanner(),
    reset: function(seriesModel) {
      if (!isOnCartesian(seriesModel)) {
        return;
      }
      const data = seriesModel.getData();
      const cartesian = seriesModel.coordinateSystem;
      const baseAxis = cartesian.getBaseAxis();
      const valueAxis2 = cartesian.getOtherAxis(baseAxis);
      const valueDimIdx = data.getDimensionIndex(data.mapDimension(valueAxis2.dim));
      const baseDimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
      const drawBackground = seriesModel.get("showBackground", true);
      const valueDim = data.mapDimension(valueAxis2.dim);
      const stackResultDim = data.getCalculationInfo("stackResultDimension");
      const stacked = isDimensionStacked(data, valueDim) && !!data.getCalculationInfo("stackedOnSeries");
      const isValueAxisH = valueAxis2.isHorizontal();
      const valueAxisStart = getValueAxisStart(baseAxis, valueAxis2);
      const isLarge = isInLargeMode(seriesModel);
      const barMinHeight = seriesModel.get("barMinHeight") || 0;
      const stackedDimIdx = stackResultDim && data.getDimensionIndex(stackResultDim);
      const columnWidth = data.getLayout("size");
      const columnOffset = data.getLayout("offset");
      return {
        progress: function(params, data2) {
          const count2 = params.count;
          const largePoints = isLarge && createFloat32Array(count2 * 3);
          const largeBackgroundPoints = isLarge && drawBackground && createFloat32Array(count2 * 3);
          const largeDataIndices = isLarge && createFloat32Array(count2);
          const coordLayout = cartesian.master.getRect();
          const bgSize = isValueAxisH ? coordLayout.width : coordLayout.height;
          let dataIndex;
          const store = data2.getStore();
          let idxOffset = 0;
          while ((dataIndex = params.next()) != null) {
            const value = store.get(stacked ? stackedDimIdx : valueDimIdx, dataIndex);
            const baseValue = store.get(baseDimIdx, dataIndex);
            let baseCoord = valueAxisStart;
            let stackStartValue;
            if (stacked) {
              stackStartValue = +value - store.get(valueDimIdx, dataIndex);
            }
            let x;
            let y;
            let width;
            let height;
            if (isValueAxisH) {
              const coord = cartesian.dataToPoint([value, baseValue]);
              if (stacked) {
                const startCoord = cartesian.dataToPoint([stackStartValue, baseValue]);
                baseCoord = startCoord[0];
              }
              x = baseCoord;
              y = coord[1] + columnOffset;
              width = coord[0] - baseCoord;
              height = columnWidth;
              if (Math.abs(width) < barMinHeight) {
                width = (width < 0 ? -1 : 1) * barMinHeight;
              }
            } else {
              const coord = cartesian.dataToPoint([baseValue, value]);
              if (stacked) {
                const startCoord = cartesian.dataToPoint([baseValue, stackStartValue]);
                baseCoord = startCoord[1];
              }
              x = coord[0] + columnOffset;
              y = baseCoord;
              width = columnWidth;
              height = coord[1] - baseCoord;
              if (Math.abs(height) < barMinHeight) {
                height = (height <= 0 ? -1 : 1) * barMinHeight;
              }
            }
            if (!isLarge) {
              data2.setItemLayout(dataIndex, {x, y, width, height});
            } else {
              largePoints[idxOffset] = x;
              largePoints[idxOffset + 1] = y;
              largePoints[idxOffset + 2] = isValueAxisH ? width : height;
              if (largeBackgroundPoints) {
                largeBackgroundPoints[idxOffset] = isValueAxisH ? coordLayout.x : x;
                largeBackgroundPoints[idxOffset + 1] = isValueAxisH ? y : coordLayout.y;
                largeBackgroundPoints[idxOffset + 2] = bgSize;
              }
              largeDataIndices[dataIndex] = dataIndex;
            }
            idxOffset += 3;
          }
          if (isLarge) {
            data2.setLayout({
              largePoints,
              largeDataIndices,
              largeBackgroundPoints,
              valueAxisHorizontal: isValueAxisH
            });
          }
        }
      };
    }
  };
}
function isOnCartesian(seriesModel) {
  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "cartesian2d";
}
function isInLargeMode(seriesModel) {
  return seriesModel.pipelineContext && seriesModel.pipelineContext.large;
}
function getValueAxisStart(baseAxis, valueAxis2) {
  let startValue = valueAxis2.model.get("startValue");
  if (!startValue) {
    startValue = 0;
  }
  return valueAxis2.toGlobalCoord(valueAxis2.dataToCoord(valueAxis2.type === "log" ? startValue > 0 ? startValue : 1 : startValue));
}

// src/scale/Time.ts
var bisect = function(a, x, lo, hi) {
  while (lo < hi) {
    const mid = lo + hi >>> 1;
    if (a[mid][1] < x) {
      lo = mid + 1;
    } else {
      hi = mid;
    }
  }
  return lo;
};
var TimeScale = class extends Interval_default {
  constructor(settings) {
    super(settings);
    this.type = "time";
  }
  getLabel(tick) {
    const useUTC = this.getSetting("useUTC");
    return format(tick.value, fullLeveledFormatter[getDefaultFormatPrecisionOfInterval(getPrimaryTimeUnit(this._minLevelUnit))] || fullLeveledFormatter.second, useUTC, this.getSetting("locale"));
  }
  getFormattedLabel(tick, idx, labelFormatter) {
    const isUTC = this.getSetting("useUTC");
    const lang = this.getSetting("locale");
    return leveledFormat(tick, idx, labelFormatter, lang, isUTC);
  }
  getTicks(opt) {
    opt = opt || {};
    const interval = this._interval;
    const extent = this._extent;
    const scaleBreakHelper = getScaleBreakHelper();
    let ticks = [];
    if (!interval) {
      return ticks;
    }
    const useUTC = this.getSetting("useUTC");
    if (scaleBreakHelper && opt.breakTicks === "only_break") {
      getScaleBreakHelper().addBreaksToTicks(ticks, this._brkCtx.breaks, this._extent);
      return ticks;
    }
    const extent0Unit = getUnitFromValue(extent[1], useUTC);
    ticks.push({
      value: extent[0],
      time: {
        level: 0,
        upperTimeUnit: extent0Unit,
        lowerTimeUnit: extent0Unit
      }
    });
    const innerTicks = getIntervalTicks(this._minLevelUnit, this._approxInterval, useUTC, extent, this._getExtentSpanWithBreaks(), this._brkCtx);
    ticks = ticks.concat(innerTicks);
    const extent1Unit = getUnitFromValue(extent[1], useUTC);
    ticks.push({
      value: extent[1],
      time: {
        level: 0,
        upperTimeUnit: extent1Unit,
        lowerTimeUnit: extent1Unit
      }
    });
    const isUTC = this.getSetting("useUTC");
    let upperUnitIndex = primaryTimeUnits.length - 1;
    let maxLevel = 0;
    each(ticks, (tick) => {
      upperUnitIndex = Math.min(upperUnitIndex, indexOf(primaryTimeUnits, tick.time.upperTimeUnit));
      maxLevel = Math.max(maxLevel, tick.time.level);
    });
    if (scaleBreakHelper) {
      getScaleBreakHelper().pruneTicksByBreak(opt.pruneByBreak, ticks, this._brkCtx.breaks, (item) => item.value, this._approxInterval, this._extent);
    }
    if (scaleBreakHelper && opt.breakTicks !== "none") {
      getScaleBreakHelper().addBreaksToTicks(ticks, this._brkCtx.breaks, this._extent, (trimmedBrk) => {
        const lowerBrkUnitIndex = Math.max(indexOf(primaryTimeUnits, getUnitFromValue(trimmedBrk.vmin, isUTC)), indexOf(primaryTimeUnits, getUnitFromValue(trimmedBrk.vmax, isUTC)));
        let upperBrkUnitIndex = 0;
        for (let unitIdx = 0; unitIdx < primaryTimeUnits.length; unitIdx++) {
          if (!isPrimaryUnitValueAndGreaterSame(primaryTimeUnits[unitIdx], trimmedBrk.vmin, trimmedBrk.vmax, isUTC)) {
            upperBrkUnitIndex = unitIdx;
            break;
          }
        }
        const upperIdx = Math.min(upperBrkUnitIndex, upperUnitIndex);
        const lowerIdx = Math.max(upperIdx, lowerBrkUnitIndex);
        return {
          level: maxLevel,
          lowerTimeUnit: primaryTimeUnits[lowerIdx],
          upperTimeUnit: primaryTimeUnits[upperIdx]
        };
      });
    }
    return ticks;
  }
  calcNiceExtent(opt) {
    const extent = this.getExtent();
    if (extent[0] === extent[1]) {
      extent[0] -= ONE_DAY;
      extent[1] += ONE_DAY;
    }
    if (extent[1] === -Infinity && extent[0] === Infinity) {
      const d = new Date();
      extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());
      extent[0] = extent[1] - ONE_DAY;
    }
    this._innerSetExtent(extent[0], extent[1]);
    this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
  }
  calcNiceTicks(approxTickNum, minInterval, maxInterval) {
    approxTickNum = approxTickNum || 10;
    const span = this._getExtentSpanWithBreaks();
    this._approxInterval = span / approxTickNum;
    if (minInterval != null && this._approxInterval < minInterval) {
      this._approxInterval = minInterval;
    }
    if (maxInterval != null && this._approxInterval > maxInterval) {
      this._approxInterval = maxInterval;
    }
    const scaleIntervalsLen = scaleIntervals.length;
    const idx = Math.min(bisect(scaleIntervals, this._approxInterval, 0, scaleIntervalsLen), scaleIntervalsLen - 1);
    this._interval = scaleIntervals[idx][1];
    this._minLevelUnit = scaleIntervals[Math.max(idx - 1, 0)][0];
  }
  parse(val) {
    return isNumber(val) ? val : +parseDate(val);
  }
  contain(val) {
    return contain2(val, this._extent);
  }
  normalize(val) {
    return this._calculator.normalize(val, this._extent);
  }
  scale(val) {
    return this._calculator.scale(val, this._extent);
  }
};
TimeScale.type = "time";
var scaleIntervals = [
  ["second", ONE_SECOND],
  ["minute", ONE_MINUTE],
  ["hour", ONE_HOUR],
  ["quarter-day", ONE_HOUR * 6],
  ["half-day", ONE_HOUR * 12],
  ["day", ONE_DAY * 1.2],
  ["half-week", ONE_DAY * 3.5],
  ["week", ONE_DAY * 7],
  ["month", ONE_DAY * 31],
  ["quarter", ONE_DAY * 95],
  ["half-year", ONE_YEAR / 2],
  ["year", ONE_YEAR]
];
function isPrimaryUnitValueAndGreaterSame(unit, valueA, valueB, isUTC) {
  return roundTime(new Date(valueA), unit, isUTC).getTime() === roundTime(new Date(valueB), unit, isUTC).getTime();
}
function getDateInterval(approxInterval, daysInMonth) {
  approxInterval /= ONE_DAY;
  return approxInterval > 16 ? 16 : approxInterval > 7.5 ? 7 : approxInterval > 3.5 ? 4 : approxInterval > 1.5 ? 2 : 1;
}
function getMonthInterval(approxInterval) {
  const APPROX_ONE_MONTH = 30 * ONE_DAY;
  approxInterval /= APPROX_ONE_MONTH;
  return approxInterval > 6 ? 6 : approxInterval > 3 ? 3 : approxInterval > 2 ? 2 : 1;
}
function getHourInterval(approxInterval) {
  approxInterval /= ONE_HOUR;
  return approxInterval > 12 ? 12 : approxInterval > 6 ? 6 : approxInterval > 3.5 ? 4 : approxInterval > 2 ? 2 : 1;
}
function getMinutesAndSecondsInterval(approxInterval, isMinutes) {
  approxInterval /= isMinutes ? ONE_MINUTE : ONE_SECOND;
  return approxInterval > 30 ? 30 : approxInterval > 20 ? 20 : approxInterval > 15 ? 15 : approxInterval > 10 ? 10 : approxInterval > 5 ? 5 : approxInterval > 2 ? 2 : 1;
}
function getMillisecondsInterval(approxInterval) {
  return nice(approxInterval, true);
}
function getFirstTimestampOfUnit(timestamp, unitName, isUTC) {
  const upperUnitIdx = Math.max(0, indexOf(primaryTimeUnits, unitName) - 1);
  return roundTime(new Date(timestamp), primaryTimeUnits[upperUnitIdx], isUTC).getTime();
}
function createEstimateNiceMultiple(setMethodName, dateMethodInterval) {
  const tmpDate = new Date(0);
  tmpDate[setMethodName](1);
  const tmpTime = tmpDate.getTime();
  tmpDate[setMethodName](1 + dateMethodInterval);
  const approxTimeInterval = tmpDate.getTime() - tmpTime;
  return (tickVal, targetValue) => {
    return Math.max(0, Math.round((targetValue - tickVal) / approxTimeInterval));
  };
}
function getIntervalTicks(bottomUnitName, approxInterval, isUTC, extent, extentSpanWithBreaks, brkCtx) {
  const safeLimit = 1e4;
  const unitNames = timeUnits;
  let iter = 0;
  function addTicksInSpan(interval, minTimestamp, maxTimestamp, getMethodName, setMethodName, isDate, out2) {
    const estimateNiceMultiple = createEstimateNiceMultiple(setMethodName, interval);
    let dateTime = minTimestamp;
    const date = new Date(dateTime);
    while (dateTime < maxTimestamp && dateTime <= extent[1]) {
      out2.push({
        value: dateTime
      });
      if (iter++ > safeLimit) {
        if (true) {
          warn("Exceed safe limit in time scale.");
        }
        break;
      }
      date[setMethodName](date[getMethodName]() + interval);
      dateTime = date.getTime();
      if (brkCtx) {
        const moreMultiple = brkCtx.calcNiceTickMultiple(dateTime, estimateNiceMultiple);
        if (moreMultiple > 0) {
          date[setMethodName](date[getMethodName]() + moreMultiple * interval);
          dateTime = date.getTime();
        }
      }
    }
    out2.push({
      value: dateTime,
      notAdd: true
    });
  }
  function addLevelTicks(unitName, lastLevelTicks, levelTicks) {
    const newAddedTicks = [];
    const isFirstLevel = !lastLevelTicks.length;
    if (isPrimaryUnitValueAndGreaterSame(getPrimaryTimeUnit(unitName), extent[0], extent[1], isUTC)) {
      return;
    }
    if (isFirstLevel) {
      lastLevelTicks = [{
        value: getFirstTimestampOfUnit(extent[0], unitName, isUTC)
      }, {
        value: extent[1]
      }];
    }
    for (let i = 0; i < lastLevelTicks.length - 1; i++) {
      const startTick = lastLevelTicks[i].value;
      const endTick = lastLevelTicks[i + 1].value;
      if (startTick === endTick) {
        continue;
      }
      let interval;
      let getterName;
      let setterName;
      let isDate = false;
      switch (unitName) {
        case "year":
          interval = Math.max(1, Math.round(approxInterval / ONE_DAY / 365));
          getterName = fullYearGetterName(isUTC);
          setterName = fullYearSetterName(isUTC);
          break;
        case "half-year":
        case "quarter":
        case "month":
          interval = getMonthInterval(approxInterval);
          getterName = monthGetterName(isUTC);
          setterName = monthSetterName(isUTC);
          break;
        case "week":
        case "half-week":
        case "day":
          interval = getDateInterval(approxInterval, 31);
          getterName = dateGetterName(isUTC);
          setterName = dateSetterName(isUTC);
          isDate = true;
          break;
        case "half-day":
        case "quarter-day":
        case "hour":
          interval = getHourInterval(approxInterval);
          getterName = hoursGetterName(isUTC);
          setterName = hoursSetterName(isUTC);
          break;
        case "minute":
          interval = getMinutesAndSecondsInterval(approxInterval, true);
          getterName = minutesGetterName(isUTC);
          setterName = minutesSetterName(isUTC);
          break;
        case "second":
          interval = getMinutesAndSecondsInterval(approxInterval, false);
          getterName = secondsGetterName(isUTC);
          setterName = secondsSetterName(isUTC);
          break;
        case "millisecond":
          interval = getMillisecondsInterval(approxInterval);
          getterName = millisecondsGetterName(isUTC);
          setterName = millisecondsSetterName(isUTC);
          break;
      }
      if (endTick >= extent[0] && startTick <= extent[1]) {
        addTicksInSpan(interval, startTick, endTick, getterName, setterName, isDate, newAddedTicks);
      }
      if (unitName === "year" && levelTicks.length > 1 && i === 0) {
        levelTicks.unshift({
          value: levelTicks[0].value - interval
        });
      }
    }
    for (let i = 0; i < newAddedTicks.length; i++) {
      levelTicks.push(newAddedTicks[i]);
    }
  }
  const levelsTicks = [];
  let currentLevelTicks = [];
  let tickCount = 0;
  let lastLevelTickCount = 0;
  for (let i = 0; i < unitNames.length; ++i) {
    const primaryTimeUnit = getPrimaryTimeUnit(unitNames[i]);
    if (!isPrimaryTimeUnit(unitNames[i])) {
      continue;
    }
    addLevelTicks(unitNames[i], levelsTicks[levelsTicks.length - 1] || [], currentLevelTicks);
    const nextPrimaryTimeUnit = unitNames[i + 1] ? getPrimaryTimeUnit(unitNames[i + 1]) : null;
    if (primaryTimeUnit !== nextPrimaryTimeUnit) {
      if (currentLevelTicks.length) {
        lastLevelTickCount = tickCount;
        currentLevelTicks.sort((a, b) => a.value - b.value);
        const levelTicksRemoveDuplicated = [];
        for (let i2 = 0; i2 < currentLevelTicks.length; ++i2) {
          const tickValue = currentLevelTicks[i2].value;
          if (i2 === 0 || currentLevelTicks[i2 - 1].value !== tickValue) {
            levelTicksRemoveDuplicated.push(currentLevelTicks[i2]);
            if (tickValue >= extent[0] && tickValue <= extent[1]) {
              tickCount++;
            }
          }
        }
        const targetTickNum = extentSpanWithBreaks / approxInterval;
        if (tickCount > targetTickNum * 1.5 && lastLevelTickCount > targetTickNum / 1.5) {
          break;
        }
        levelsTicks.push(levelTicksRemoveDuplicated);
        if (tickCount > targetTickNum || bottomUnitName === unitNames[i]) {
          break;
        }
      }
      currentLevelTicks = [];
    }
  }
  const levelsTicksInExtent = filter(map(levelsTicks, (levelTicks) => {
    return filter(levelTicks, (tick) => tick.value >= extent[0] && tick.value <= extent[1] && !tick.notAdd);
  }), (levelTicks) => levelTicks.length > 0);
  const ticks = [];
  const maxLevel = levelsTicksInExtent.length - 1;
  for (let i = 0; i < levelsTicksInExtent.length; ++i) {
    const levelTicks = levelsTicksInExtent[i];
    for (let k = 0; k < levelTicks.length; ++k) {
      const unit = getUnitFromValue(levelTicks[k].value, isUTC);
      ticks.push({
        value: levelTicks[k].value,
        time: {
          level: maxLevel - i,
          upperTimeUnit: unit,
          lowerTimeUnit: unit
        }
      });
    }
  }
  ticks.sort((a, b) => a.value - b.value);
  const result = [];
  for (let i = 0; i < ticks.length; ++i) {
    if (i === 0 || ticks[i].value !== ticks[i - 1].value) {
      result.push(ticks[i]);
    }
  }
  return result;
}
Scale_default.registerClass(TimeScale);
var Time_default = TimeScale;

// src/scale/Log.ts
var fixRound = round;
var mathFloor = Math.floor;
var mathCeil = Math.ceil;
var mathPow2 = Math.pow;
var mathLog = Math.log;
var LogScale = class extends Interval_default {
  constructor() {
    super(...arguments);
    this.type = "log";
    this.base = 10;
    this._originalScale = new Interval_default();
  }
  getTicks(opt) {
    opt = opt || {};
    const extent = this._extent.slice();
    const originalExtent = this._originalScale.getExtent();
    const ticks = super.getTicks(opt);
    const base2 = this.base;
    const originalBreaks = this._originalScale._innerGetBreaks();
    const scaleBreakHelper = getScaleBreakHelper();
    return map(ticks, function(tick) {
      const val = tick.value;
      const rawVal = mathPow2(base2, val);
      let roundingCriterion = null;
      function calculatePrecision(value) {
        if (!isFinite(value) || value === 0) {
          return 0;
        }
        const str = value.toString();
        if (str.includes("e")) {
          const [coefficient, exponent] = str.split("e");
          const coefficientDecimals = coefficient.includes(".") ? coefficient.split(".")[1].length : 0;
          const exp = parseInt(exponent, 10);
          return exp < 0 ? Math.abs(exp) + coefficientDecimals : coefficientDecimals;
        }
        const decimalPart = str.split(".")[1];
        return decimalPart ? decimalPart.length : 0;
      }
      const precision = calculatePrecision(rawVal);
      const precisionThreshold = 10;
      let powVal;
      if (precision <= precisionThreshold) {
        powVal = fixRound(rawVal);
      } else {
        const safePrecision = Math.max(precision + 2, 12);
        powVal = parseFloat(fixRound(rawVal, safePrecision, true));
      }
      if (val === extent[0] && this._fixMin) {
        roundingCriterion = originalExtent[0];
      } else if (val === extent[1] && this._fixMax) {
        roundingCriterion = originalExtent[1];
      }
      let vBreak;
      if (scaleBreakHelper) {
        const transformed = scaleBreakHelper.getTicksLogTransformBreak(tick, base2, originalBreaks, fixRoundingError);
        vBreak = transformed.vBreak;
        if (roundingCriterion == null) {
          roundingCriterion = transformed.brkRoundingCriterion;
        }
      }
      if (roundingCriterion != null) {
        powVal = fixRoundingError(powVal, roundingCriterion);
      }
      return {
        value: powVal,
        break: vBreak
      };
    }, this);
  }
  _getNonTransBreaks() {
    return this._originalScale._innerGetBreaks();
  }
  setExtent(start2, end2) {
    this._originalScale.setExtent(start2, end2);
    const loggedExtent = logTransform(this.base, [start2, end2]);
    super.setExtent(loggedExtent[0], loggedExtent[1]);
  }
  getExtent() {
    const base2 = this.base;
    const extent = super.getExtent();
    extent[0] = mathPow2(base2, extent[0]);
    extent[1] = mathPow2(base2, extent[1]);
    const originalExtent = this._originalScale.getExtent();
    this._fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));
    this._fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));
    return extent;
  }
  unionExtentFromData(data, dim) {
    this._originalScale.unionExtentFromData(data, dim);
    const loggedOther = logTransform(this.base, data.getApproximateExtent(dim), true);
    this._innerUnionExtent(loggedOther);
  }
  calcNiceTicks(approxTickNum) {
    approxTickNum = approxTickNum || 10;
    const extent = this._extent.slice();
    const span = this._getExtentSpanWithBreaks();
    if (!isFinite(span) || span <= 0) {
      return;
    }
    let interval = quantity(span);
    const err = approxTickNum / span * interval;
    if (err <= 0.5) {
      interval *= 10;
    }
    while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
      interval *= 10;
    }
    const niceExtent = [
      fixRound(mathCeil(extent[0] / interval) * interval),
      fixRound(mathFloor(extent[1] / interval) * interval)
    ];
    this._interval = interval;
    this._niceExtent = niceExtent;
  }
  calcNiceExtent(opt) {
    super.calcNiceExtent(opt);
    this._fixMin = opt.fixMin;
    this._fixMax = opt.fixMax;
  }
  contain(val) {
    val = mathLog(val) / mathLog(this.base);
    return super.contain(val);
  }
  normalize(val) {
    val = mathLog(val) / mathLog(this.base);
    return super.normalize(val);
  }
  scale(val) {
    val = super.scale(val);
    return mathPow2(this.base, val);
  }
  setBreaksFromOption(breakOptionList) {
    const scaleBreakHelper = getScaleBreakHelper();
    if (!scaleBreakHelper) {
      return;
    }
    const {parsedOriginal, parsedLogged} = scaleBreakHelper.logarithmicParseBreaksFromOption(breakOptionList, this.base, bind(this.parse, this));
    this._originalScale._innerSetBreak(parsedOriginal);
    this._innerSetBreak(parsedLogged);
  }
};
LogScale.type = "log";
function fixRoundingError(val, originalVal) {
  return fixRound(val, getPrecision(originalVal));
}
Scale_default.registerClass(LogScale);
var Log_default = LogScale;

// src/coord/scaleRawExtentInfo.ts
var ScaleRawExtentInfo = class {
  constructor(scale4, model, originalExtent) {
    this._prepareParams(scale4, model, originalExtent);
  }
  _prepareParams(scale4, model, dataExtent) {
    if (dataExtent[1] < dataExtent[0]) {
      dataExtent = [NaN, NaN];
    }
    this._dataMin = dataExtent[0];
    this._dataMax = dataExtent[1];
    const isOrdinal = this._isOrdinal = scale4.type === "ordinal";
    this._needCrossZero = scale4.type === "interval" && model.getNeedCrossZero && model.getNeedCrossZero();
    let axisMinValue = model.get("min", true);
    if (axisMinValue == null) {
      axisMinValue = model.get("startValue", true);
    }
    const modelMinRaw = this._modelMinRaw = axisMinValue;
    if (isFunction(modelMinRaw)) {
      this._modelMinNum = parseAxisModelMinMax(scale4, modelMinRaw({
        min: dataExtent[0],
        max: dataExtent[1]
      }));
    } else if (modelMinRaw !== "dataMin") {
      this._modelMinNum = parseAxisModelMinMax(scale4, modelMinRaw);
    }
    const modelMaxRaw = this._modelMaxRaw = model.get("max", true);
    if (isFunction(modelMaxRaw)) {
      this._modelMaxNum = parseAxisModelMinMax(scale4, modelMaxRaw({
        min: dataExtent[0],
        max: dataExtent[1]
      }));
    } else if (modelMaxRaw !== "dataMax") {
      this._modelMaxNum = parseAxisModelMinMax(scale4, modelMaxRaw);
    }
    if (isOrdinal) {
      this._axisDataLen = model.getCategories().length;
    } else {
      const boundaryGap = model.get("boundaryGap");
      const boundaryGapArr = isArray(boundaryGap) ? boundaryGap : [boundaryGap || 0, boundaryGap || 0];
      if (typeof boundaryGapArr[0] === "boolean" || typeof boundaryGapArr[1] === "boolean") {
        if (true) {
          console.warn('Boolean type for boundaryGap is only allowed for ordinal axis. Please use string in percentage instead, e.g., "20%". Currently, boundaryGap is set to be 0.');
        }
        this._boundaryGapInner = [0, 0];
      } else {
        this._boundaryGapInner = [
          parsePercent(boundaryGapArr[0], 1),
          parsePercent(boundaryGapArr[1], 1)
        ];
      }
    }
  }
  calculate() {
    const isOrdinal = this._isOrdinal;
    const dataMin = this._dataMin;
    const dataMax = this._dataMax;
    const axisDataLen = this._axisDataLen;
    const boundaryGapInner = this._boundaryGapInner;
    const span = !isOrdinal ? dataMax - dataMin || Math.abs(dataMin) : null;
    let min3 = this._modelMinRaw === "dataMin" ? dataMin : this._modelMinNum;
    let max3 = this._modelMaxRaw === "dataMax" ? dataMax : this._modelMaxNum;
    let minFixed = min3 != null;
    let maxFixed = max3 != null;
    if (min3 == null) {
      min3 = isOrdinal ? axisDataLen ? 0 : NaN : dataMin - boundaryGapInner[0] * span;
    }
    if (max3 == null) {
      max3 = isOrdinal ? axisDataLen ? axisDataLen - 1 : NaN : dataMax + boundaryGapInner[1] * span;
    }
    (min3 == null || !isFinite(min3)) && (min3 = NaN);
    (max3 == null || !isFinite(max3)) && (max3 = NaN);
    const isBlank = eqNaN(min3) || eqNaN(max3) || isOrdinal && !axisDataLen;
    if (this._needCrossZero) {
      if (min3 > 0 && max3 > 0 && !minFixed) {
        min3 = 0;
      }
      if (min3 < 0 && max3 < 0 && !maxFixed) {
        max3 = 0;
      }
    }
    const determinedMin = this._determinedMin;
    const determinedMax = this._determinedMax;
    if (determinedMin != null) {
      min3 = determinedMin;
      minFixed = true;
    }
    if (determinedMax != null) {
      max3 = determinedMax;
      maxFixed = true;
    }
    return {
      min: min3,
      max: max3,
      minFixed,
      maxFixed,
      isBlank
    };
  }
  modifyDataMinMax(minMaxName, val) {
    if (true) {
      assert(!this.frozen);
    }
    this[DATA_MIN_MAX_ATTR[minMaxName]] = val;
  }
  setDeterminedMinMax(minMaxName, val) {
    const attr = DETERMINED_MIN_MAX_ATTR[minMaxName];
    if (true) {
      assert(!this.frozen && this[attr] == null);
    }
    this[attr] = val;
  }
  freeze() {
    this.frozen = true;
  }
};
var DETERMINED_MIN_MAX_ATTR = {min: "_determinedMin", max: "_determinedMax"};
var DATA_MIN_MAX_ATTR = {min: "_dataMin", max: "_dataMax"};
function ensureScaleRawExtentInfo(scale4, model, originalExtent) {
  let rawExtentInfo = scale4.rawExtentInfo;
  if (rawExtentInfo) {
    return rawExtentInfo;
  }
  rawExtentInfo = new ScaleRawExtentInfo(scale4, model, originalExtent);
  scale4.rawExtentInfo = rawExtentInfo;
  return rawExtentInfo;
}
function parseAxisModelMinMax(scale4, minMax) {
  return minMax == null ? null : eqNaN(minMax) ? NaN : scale4.parse(minMax);
}

// src/coord/axisHelper.ts
function getScaleExtent(scale4, model) {
  const scaleType = scale4.type;
  const rawExtentResult = ensureScaleRawExtentInfo(scale4, model, scale4.getExtent()).calculate();
  scale4.setBlank(rawExtentResult.isBlank);
  let min3 = rawExtentResult.min;
  let max3 = rawExtentResult.max;
  const ecModel = model.ecModel;
  if (ecModel && scaleType === "time") {
    const barSeriesModels = prepareLayoutBarSeries("bar", ecModel);
    let isBaseAxisAndHasBarSeries = false;
    each(barSeriesModels, function(seriesModel) {
      isBaseAxisAndHasBarSeries = isBaseAxisAndHasBarSeries || seriesModel.getBaseAxis() === model.axis;
    });
    if (isBaseAxisAndHasBarSeries) {
      const barWidthAndOffset = makeColumnLayout(barSeriesModels);
      const adjustedScale = adjustScaleForOverflow(min3, max3, model, barWidthAndOffset);
      min3 = adjustedScale.min;
      max3 = adjustedScale.max;
    }
  }
  return {
    extent: [min3, max3],
    fixMin: rawExtentResult.minFixed,
    fixMax: rawExtentResult.maxFixed
  };
}
function adjustScaleForOverflow(min3, max3, model, barWidthAndOffset) {
  const axisExtent = model.axis.getExtent();
  const axisLength = Math.abs(axisExtent[1] - axisExtent[0]);
  const barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);
  if (barsOnCurrentAxis === void 0) {
    return {min: min3, max: max3};
  }
  let minOverflow = Infinity;
  each(barsOnCurrentAxis, function(item) {
    minOverflow = Math.min(item.offset, minOverflow);
  });
  let maxOverflow = -Infinity;
  each(barsOnCurrentAxis, function(item) {
    maxOverflow = Math.max(item.offset + item.width, maxOverflow);
  });
  minOverflow = Math.abs(minOverflow);
  maxOverflow = Math.abs(maxOverflow);
  const totalOverFlow = minOverflow + maxOverflow;
  const oldRange = max3 - min3;
  const oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;
  const overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;
  max3 += overflowBuffer * (maxOverflow / totalOverFlow);
  min3 -= overflowBuffer * (minOverflow / totalOverFlow);
  return {min: min3, max: max3};
}
function niceScaleExtent(scale4, inModel) {
  const model = inModel;
  const extentInfo = getScaleExtent(scale4, model);
  const extent = extentInfo.extent;
  const splitNumber = model.get("splitNumber");
  if (scale4 instanceof Log_default) {
    scale4.base = model.get("logBase");
  }
  const scaleType = scale4.type;
  const interval = model.get("interval");
  const isIntervalOrTime = scaleType === "interval" || scaleType === "time";
  scale4.setBreaksFromOption(retrieveAxisBreaksOption(model));
  scale4.setExtent(extent[0], extent[1]);
  scale4.calcNiceExtent({
    splitNumber,
    fixMin: extentInfo.fixMin,
    fixMax: extentInfo.fixMax,
    minInterval: isIntervalOrTime ? model.get("minInterval") : null,
    maxInterval: isIntervalOrTime ? model.get("maxInterval") : null
  });
  if (interval != null) {
    scale4.setInterval && scale4.setInterval(interval);
  }
}
function createScaleByModel(model, axisType) {
  axisType = axisType || model.get("type");
  if (axisType) {
    switch (axisType) {
      case "category":
        return new Ordinal_default({
          ordinalMeta: model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(),
          extent: [Infinity, -Infinity]
        });
      case "time":
        return new Time_default({
          locale: model.ecModel.getLocaleModel(),
          useUTC: model.ecModel.get("useUTC")
        });
      default:
        return new (Scale_default.getClass(axisType) || Interval_default)();
    }
  }
}
function ifAxisCrossZero(axis) {
  const dataExtent = axis.scale.getExtent();
  const min3 = dataExtent[0];
  const max3 = dataExtent[1];
  return !(min3 > 0 && max3 > 0 || min3 < 0 && max3 < 0);
}
function makeLabelFormatter(axis) {
  const labelFormatter = axis.getLabelModel().get("formatter");
  if (axis.type === "time") {
    const parsed = parseTimeAxisLabelFormatter(labelFormatter);
    return function(tick, idx) {
      return axis.scale.getFormattedLabel(tick, idx, parsed);
    };
  } else if (isString(labelFormatter)) {
    return function(tick) {
      const label = axis.scale.getLabel(tick);
      const text = labelFormatter.replace("{value}", label != null ? label : "");
      return text;
    };
  } else if (isFunction(labelFormatter)) {
    if (axis.type === "category") {
      return function(tick, idx) {
        return labelFormatter(getAxisRawValue(axis, tick), tick.value - axis.scale.getExtent()[0], null);
      };
    }
    const scaleBreakHelper = getScaleBreakHelper();
    return function(tick, idx) {
      let extra = null;
      if (scaleBreakHelper) {
        extra = scaleBreakHelper.makeAxisLabelFormatterParamBreak(extra, tick.break);
      }
      return labelFormatter(getAxisRawValue(axis, tick), idx, extra);
    };
  } else {
    return function(tick) {
      return axis.scale.getLabel(tick);
    };
  }
}
function getAxisRawValue(axis, tick) {
  return axis.type === "category" ? axis.scale.getLabel(tick) : tick.value;
}
function getOptionCategoryInterval(model) {
  const interval = model.get("interval");
  return interval == null ? "auto" : interval;
}
function shouldShowAllLabels(axis) {
  return axis.type === "category" && getOptionCategoryInterval(axis.getLabelModel()) === 0;
}
function getDataDimensionsOnAxis(data, axisDim) {
  const dataDimMap = {};
  each(data.mapDimensionsAll(axisDim), function(dataDim) {
    dataDimMap[getStackedDimension(data, dataDim)] = true;
  });
  return keys(dataDimMap);
}
function unionAxisExtentFromData(dataExtent, data, axisDim) {
  if (data) {
    each(getDataDimensionsOnAxis(data, axisDim), function(dim) {
      const seriesExtent = data.getApproximateExtent(dim);
      seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);
      seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);
    });
  }
}
function isNameLocationCenter(nameLocation) {
  return nameLocation === "middle" || nameLocation === "center";
}
function shouldAxisShow(axisModel) {
  return axisModel.getShallow("show");
}
function retrieveAxisBreaksOption(model) {
  const option = model.get("breaks", true);
  if (option != null) {
    if (!getScaleBreakHelper()) {
      if (true) {
        error('Must `import {AxisBreak} from "echarts/features"; use(AxisBreak);` first if using breaks option.');
      }
      return void 0;
    }
    if (!isSupportAxisBreak(model.axis)) {
      if (true) {
        error(`Axis '${model.axis.dim}'-'${model.axis.type}' does not support break.`);
      }
      return void 0;
    }
    return option;
  }
}
function isSupportAxisBreak(axis) {
  return (axis.dim === "x" || axis.dim === "y" || axis.dim === "z" || axis.dim === "single") && axis.type !== "category";
}

// src/coord/axisModelCommonMixin.ts
var AxisModelCommonMixin = class {
  getNeedCrossZero() {
    const option = this.option;
    return !option.scale;
  }
  getCoordSysModel() {
    return;
  }
};

// src/export/api/helper.ts
function createList(seriesModel) {
  return createSeriesData_default(null, seriesModel);
}
var dataStack2 = {
  isDimensionStacked,
  enableDataStack,
  getStackedDimension
};
function createScale(dataExtent, option) {
  let axisModel = option;
  if (!(option instanceof Model_default)) {
    axisModel = new Model_default(option);
  }
  const scale4 = createScaleByModel(axisModel);
  scale4.setExtent(dataExtent[0], dataExtent[1]);
  niceScaleExtent(scale4, axisModel);
  return scale4;
}
function mixinAxisModelCommonMethods(Model2) {
  mixin(Model2, AxisModelCommonMixin);
}
function createTextStyle2(textStyleModel, opts) {
  opts = opts || {};
  return createTextStyle(textStyleModel, null, null, opts.state !== "normal");
}

// ../zrender/src/contain/polygon.ts
var EPSILON6 = 1e-8;
function isAroundEqual2(a, b) {
  return Math.abs(a - b) < EPSILON6;
}
function contain3(points4, x, y) {
  let w = 0;
  let p = points4[0];
  if (!p) {
    return false;
  }
  for (let i = 1; i < points4.length; i++) {
    const p2 = points4[i];
    w += windingLine(p[0], p[1], p2[0], p2[1], x, y);
    p = p2;
  }
  const p0 = points4[0];
  if (!isAroundEqual2(p[0], p0[0]) || !isAroundEqual2(p[1], p0[1])) {
    w += windingLine(p[0], p[1], p0[0], p0[1], x, y);
  }
  return w !== 0;
}

// src/coord/geo/Region.ts
var TMP_TRANSFORM = [];
function transformPoints(points4, transform2) {
  for (let p = 0; p < points4.length; p++) {
    applyTransform(points4[p], points4[p], transform2);
  }
}
function updateBBoxFromPoints(points4, min3, max3, projection) {
  for (let i = 0; i < points4.length; i++) {
    let p = points4[i];
    if (projection) {
      p = projection.project(p);
    }
    if (p && isFinite(p[0]) && isFinite(p[1])) {
      min(min3, min3, p);
      max(max3, max3, p);
    }
  }
}
function centroid(points4) {
  let signedArea = 0;
  let cx = 0;
  let cy = 0;
  const len2 = points4.length;
  let x0 = points4[len2 - 1][0];
  let y0 = points4[len2 - 1][1];
  for (let i = 0; i < len2; i++) {
    const x1 = points4[i][0];
    const y1 = points4[i][1];
    const a = x0 * y1 - x1 * y0;
    signedArea += a;
    cx += (x0 + x1) * a;
    cy += (y0 + y1) * a;
    x0 = x1;
    y0 = y1;
  }
  return signedArea ? [cx / signedArea / 3, cy / signedArea / 3, signedArea] : [points4[0][0] || 0, points4[0][1] || 0];
}
var Region = class {
  constructor(name) {
    this.name = name;
  }
  setCenter(center3) {
    this._center = center3;
  }
  getCenter() {
    let center3 = this._center;
    if (!center3) {
      center3 = this._center = this.calcCenter();
    }
    return center3;
  }
};
var GeoJSONPolygonGeometry = class {
  constructor(exterior, interiors) {
    this.type = "polygon";
    this.exterior = exterior;
    this.interiors = interiors;
  }
};
var GeoJSONLineStringGeometry = class {
  constructor(points4) {
    this.type = "linestring";
    this.points = points4;
  }
};
var GeoJSONRegion = class extends Region {
  constructor(name, geometries, cp) {
    super(name);
    this.type = "geoJSON";
    this.geometries = geometries;
    this._center = cp && [cp[0], cp[1]];
  }
  calcCenter() {
    const geometries = this.geometries;
    let largestGeo;
    let largestGeoSize = 0;
    for (let i = 0; i < geometries.length; i++) {
      const geo = geometries[i];
      const exterior = geo.exterior;
      const size = exterior && exterior.length;
      if (size > largestGeoSize) {
        largestGeo = geo;
        largestGeoSize = size;
      }
    }
    if (largestGeo) {
      return centroid(largestGeo.exterior);
    }
    const rect = this.getBoundingRect();
    return [
      rect.x + rect.width / 2,
      rect.y + rect.height / 2
    ];
  }
  getBoundingRect(projection) {
    let rect = this._rect;
    if (rect && !projection) {
      return rect;
    }
    const min3 = [Infinity, Infinity];
    const max3 = [-Infinity, -Infinity];
    const geometries = this.geometries;
    each(geometries, (geo) => {
      if (geo.type === "polygon") {
        updateBBoxFromPoints(geo.exterior, min3, max3, projection);
      } else {
        each(geo.points, (points4) => {
          updateBBoxFromPoints(points4, min3, max3, projection);
        });
      }
    });
    if (!(isFinite(min3[0]) && isFinite(min3[1]) && isFinite(max3[0]) && isFinite(max3[1]))) {
      min3[0] = min3[1] = max3[0] = max3[1] = 0;
    }
    rect = new BoundingRect_default(min3[0], min3[1], max3[0] - min3[0], max3[1] - min3[1]);
    if (!projection) {
      this._rect = rect;
    }
    return rect;
  }
  contain(coord) {
    const rect = this.getBoundingRect();
    const geometries = this.geometries;
    if (!rect.contain(coord[0], coord[1])) {
      return false;
    }
    loopGeo:
      for (let i = 0, len2 = geometries.length; i < len2; i++) {
        const geo = geometries[i];
        if (geo.type !== "polygon") {
          continue;
        }
        const exterior = geo.exterior;
        const interiors = geo.interiors;
        if (contain3(exterior, coord[0], coord[1])) {
          for (let k = 0; k < (interiors ? interiors.length : 0); k++) {
            if (contain3(interiors[k], coord[0], coord[1])) {
              continue loopGeo;
            }
          }
          return true;
        }
      }
    return false;
  }
  transformTo(x, y, width, height) {
    let rect = this.getBoundingRect();
    const aspect = rect.width / rect.height;
    if (!width) {
      width = aspect * height;
    } else if (!height) {
      height = width / aspect;
    }
    const target = new BoundingRect_default(x, y, width, height);
    const transform2 = rect.calculateTransform(target);
    const geometries = this.geometries;
    for (let i = 0; i < geometries.length; i++) {
      const geo = geometries[i];
      if (geo.type === "polygon") {
        transformPoints(geo.exterior, transform2);
        each(geo.interiors, (interior) => {
          transformPoints(interior, transform2);
        });
      } else {
        each(geo.points, (points4) => {
          transformPoints(points4, transform2);
        });
      }
    }
    rect = this._rect;
    rect.copy(target);
    this._center = [
      rect.x + rect.width / 2,
      rect.y + rect.height / 2
    ];
  }
  cloneShallow(name) {
    name == null && (name = this.name);
    const newRegion = new GeoJSONRegion(name, this.geometries, this._center);
    newRegion._rect = this._rect;
    newRegion.transformTo = null;
    return newRegion;
  }
};
var GeoSVGRegion = class extends Region {
  constructor(name, elOnlyForCalculate) {
    super(name);
    this.type = "geoSVG";
    this._elOnlyForCalculate = elOnlyForCalculate;
  }
  calcCenter() {
    const el = this._elOnlyForCalculate;
    const rect = el.getBoundingRect();
    const center3 = [
      rect.x + rect.width / 2,
      rect.y + rect.height / 2
    ];
    const mat = identity(TMP_TRANSFORM);
    let target = el;
    while (target && !target.isGeoSVGGraphicRoot) {
      mul2(mat, target.getLocalTransform(), mat);
      target = target.parent;
    }
    invert(mat, mat);
    applyTransform(center3, center3, mat);
    return center3;
  }
};

// src/coord/geo/parseGeoJson.ts
function decode(json) {
  if (!json.UTF8Encoding) {
    return json;
  }
  const jsonCompressed = json;
  let encodeScale = jsonCompressed.UTF8Scale;
  if (encodeScale == null) {
    encodeScale = 1024;
  }
  const features2 = jsonCompressed.features;
  each(features2, (feature) => {
    const geometry = feature.geometry;
    const encodeOffsets = geometry.encodeOffsets;
    const coordinates = geometry.coordinates;
    if (!encodeOffsets) {
      return;
    }
    switch (geometry.type) {
      case "LineString":
        geometry.coordinates = decodeRing(coordinates, encodeOffsets, encodeScale);
        break;
      case "Polygon":
        decodeRings(coordinates, encodeOffsets, encodeScale);
        break;
      case "MultiLineString":
        decodeRings(coordinates, encodeOffsets, encodeScale);
        break;
      case "MultiPolygon":
        each(coordinates, (rings, idx) => decodeRings(rings, encodeOffsets[idx], encodeScale));
    }
  });
  jsonCompressed.UTF8Encoding = false;
  return jsonCompressed;
}
function decodeRings(rings, encodeOffsets, encodeScale) {
  for (let c = 0; c < rings.length; c++) {
    rings[c] = decodeRing(rings[c], encodeOffsets[c], encodeScale);
  }
}
function decodeRing(coordinate, encodeOffsets, encodeScale) {
  const result = [];
  let prevX = encodeOffsets[0];
  let prevY = encodeOffsets[1];
  for (let i = 0; i < coordinate.length; i += 2) {
    let x = coordinate.charCodeAt(i) - 64;
    let y = coordinate.charCodeAt(i + 1) - 64;
    x = x >> 1 ^ -(x & 1);
    y = y >> 1 ^ -(y & 1);
    x += prevX;
    y += prevY;
    prevX = x;
    prevY = y;
    result.push([x / encodeScale, y / encodeScale]);
  }
  return result;
}
function parseGeoJSON(geoJson, nameProperty) {
  geoJson = decode(geoJson);
  return map(filter(geoJson.features, function(featureObj) {
    return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;
  }), function(featureObj) {
    const properties = featureObj.properties;
    const geo = featureObj.geometry;
    const geometries = [];
    switch (geo.type) {
      case "Polygon":
        const coordinates = geo.coordinates;
        geometries.push(new GeoJSONPolygonGeometry(coordinates[0], coordinates.slice(1)));
        break;
      case "MultiPolygon":
        each(geo.coordinates, function(item) {
          if (item[0]) {
            geometries.push(new GeoJSONPolygonGeometry(item[0], item.slice(1)));
          }
        });
        break;
      case "LineString":
        geometries.push(new GeoJSONLineStringGeometry([geo.coordinates]));
        break;
      case "MultiLineString":
        geometries.push(new GeoJSONLineStringGeometry(geo.coordinates));
    }
    const region = new GeoJSONRegion(properties[nameProperty || "name"], geometries, properties.cp);
    region.properties = properties;
    return region;
  });
}

// src/export/api/number.ts
var number_exports = {};
__export(number_exports, {
  MAX_SAFE_INTEGER: () => MAX_SAFE_INTEGER,
  asc: () => asc,
  getPercentWithPrecision: () => getPercentWithPrecision,
  getPixelPrecision: () => getPixelPrecision,
  getPrecision: () => getPrecision,
  getPrecisionSafe: () => getPrecisionSafe,
  isNumeric: () => isNumeric,
  isRadianAroundZero: () => isRadianAroundZero,
  linearMap: () => linearMap,
  nice: () => nice,
  numericToNumber: () => numericToNumber,
  parseDate: () => parseDate,
  parsePercent: () => parsePercent2,
  quantile: () => quantile,
  quantity: () => quantity,
  quantityExponent: () => quantityExponent,
  reformIntervals: () => reformIntervals,
  remRadian: () => remRadian,
  round: () => round
});

// src/export/api/time.ts
var time_exports = {};
__export(time_exports, {
  format: () => format,
  parse: () => parseDate,
  roundTime: () => roundTime
});

// src/export/api/graphic.ts
var graphic_exports2 = {};
__export(graphic_exports2, {
  Arc: () => Arc_default,
  BezierCurve: () => BezierCurve_default,
  BoundingRect: () => BoundingRect_default,
  Circle: () => Circle_default,
  CompoundPath: () => CompoundPath_default,
  Ellipse: () => Ellipse_default,
  Group: () => Group_default,
  Image: () => Image_default,
  IncrementalDisplayable: () => IncrementalDisplayable_default,
  Line: () => Line_default,
  LinearGradient: () => LinearGradient_default,
  Polygon: () => Polygon_default,
  Polyline: () => Polyline_default,
  RadialGradient: () => RadialGradient_default,
  Rect: () => Rect_default,
  Ring: () => Ring_default,
  Sector: () => Sector_default,
  Text: () => Text_default,
  clipPointsByRect: () => clipPointsByRect,
  clipRectByRect: () => clipRectByRect,
  createIcon: () => createIcon,
  extendPath: () => extendPath,
  extendShape: () => extendShape,
  getShapeClass: () => getShapeClass,
  getTransform: () => getTransform,
  initProps: () => initProps,
  makeImage: () => makeImage,
  makePath: () => makePath,
  mergePath: () => mergePath2,
  registerShape: () => registerShape,
  resizePath: () => resizePath,
  updateProps: () => updateProps
});

// src/export/api/format.ts
var format_exports = {};
__export(format_exports, {
  addCommas: () => addCommas,
  capitalFirst: () => capitalFirst,
  encodeHTML: () => encodeHTML,
  formatTime: () => formatTime,
  formatTpl: () => formatTpl,
  getTextRect: () => getTextRect,
  getTooltipMarker: () => getTooltipMarker,
  normalizeCssArray: () => normalizeCssArray2,
  toCamelCase: () => toCamelCase,
  truncateText: () => truncateText
});

// src/export/api/util.ts
var util_exports2 = {};
__export(util_exports2, {
  bind: () => bind,
  clone: () => clone,
  curry: () => curry,
  defaults: () => defaults,
  each: () => each,
  extend: () => extend,
  filter: () => filter,
  indexOf: () => indexOf,
  inherits: () => inherits,
  isArray: () => isArray,
  isFunction: () => isFunction,
  isObject: () => isObject,
  isString: () => isString,
  map: () => map,
  merge: () => merge,
  reduce: () => reduce
});

// src/coord/axisTickLabelBuilder.ts
var modelInner = makeInner();
var axisInner = makeInner();
var AxisTickLabelComputingKind = {
  estimate: 1,
  determine: 2
};
function createAxisLabelsComputingContext(kind) {
  return {
    out: {
      noPxChangeTryDetermine: []
    },
    kind
  };
}
function tickValuesToNumbers(axis, values) {
  const nums = map(values, (val) => axis.scale.parse(val));
  if (axis.type === "time" && nums.length > 0) {
    nums.sort();
    nums.unshift(nums[0]);
    nums.push(nums[nums.length - 1]);
  }
  return nums;
}
function createAxisLabels(axis, ctx) {
  const custom = axis.getLabelModel().get("customValues");
  if (custom) {
    const labelFormatter = makeLabelFormatter(axis);
    const extent = axis.scale.getExtent();
    const tickNumbers = tickValuesToNumbers(axis, custom);
    const ticks = filter(tickNumbers, (val) => val >= extent[0] && val <= extent[1]);
    return {
      labels: map(ticks, (numval) => {
        const tick = {value: numval};
        return {
          formattedLabel: labelFormatter(tick),
          rawLabel: axis.scale.getLabel(tick),
          tickValue: numval,
          time: void 0,
          break: void 0
        };
      })
    };
  }
  return axis.type === "category" ? makeCategoryLabels(axis, ctx) : makeRealNumberLabels(axis);
}
function createAxisTicks(axis, tickModel, opt) {
  const custom = axis.getTickModel().get("customValues");
  if (custom) {
    const extent = axis.scale.getExtent();
    const tickNumbers = tickValuesToNumbers(axis, custom);
    return {
      ticks: filter(tickNumbers, (val) => val >= extent[0] && val <= extent[1])
    };
  }
  return axis.type === "category" ? makeCategoryTicks(axis, tickModel) : {ticks: map(axis.scale.getTicks(opt), (tick) => tick.value)};
}
function makeCategoryLabels(axis, ctx) {
  const labelModel = axis.getLabelModel();
  const result = makeCategoryLabelsActually(axis, labelModel, ctx);
  return !labelModel.get("show") || axis.scale.isBlank() ? {labels: []} : result;
}
function makeCategoryLabelsActually(axis, labelModel, ctx) {
  const labelsCache = ensureCategoryLabelCache(axis);
  const optionLabelInterval = getOptionCategoryInterval(labelModel);
  const isEstimate = ctx.kind === AxisTickLabelComputingKind.estimate;
  if (!isEstimate) {
    const result2 = axisCacheGet(labelsCache, optionLabelInterval);
    if (result2) {
      return result2;
    }
  }
  let labels;
  let numericLabelInterval;
  if (isFunction(optionLabelInterval)) {
    labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);
  } else {
    numericLabelInterval = optionLabelInterval === "auto" ? makeAutoCategoryInterval(axis, ctx) : optionLabelInterval;
    labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);
  }
  const result = {labels, labelCategoryInterval: numericLabelInterval};
  if (!isEstimate) {
    axisCacheSet(labelsCache, optionLabelInterval, result);
  } else {
    ctx.out.noPxChangeTryDetermine.push(function() {
      axisCacheSet(labelsCache, optionLabelInterval, result);
      return true;
    });
  }
  return result;
}
function makeCategoryTicks(axis, tickModel) {
  const ticksCache = ensureCategoryTickCache(axis);
  const optionTickInterval = getOptionCategoryInterval(tickModel);
  const result = axisCacheGet(ticksCache, optionTickInterval);
  if (result) {
    return result;
  }
  let ticks;
  let tickCategoryInterval;
  if (!tickModel.get("show") || axis.scale.isBlank()) {
    ticks = [];
  }
  if (isFunction(optionTickInterval)) {
    ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);
  } else if (optionTickInterval === "auto") {
    const labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel(), createAxisLabelsComputingContext(AxisTickLabelComputingKind.determine));
    tickCategoryInterval = labelsResult.labelCategoryInterval;
    ticks = map(labelsResult.labels, function(labelItem) {
      return labelItem.tickValue;
    });
  } else {
    tickCategoryInterval = optionTickInterval;
    ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);
  }
  return axisCacheSet(ticksCache, optionTickInterval, {
    ticks,
    tickCategoryInterval
  });
}
function makeRealNumberLabels(axis) {
  const ticks = axis.scale.getTicks();
  const labelFormatter = makeLabelFormatter(axis);
  return {
    labels: map(ticks, function(tick, idx) {
      return {
        formattedLabel: labelFormatter(tick, idx),
        rawLabel: axis.scale.getLabel(tick),
        tickValue: tick.value,
        time: tick.time,
        break: tick.break
      };
    })
  };
}
var ensureCategoryTickCache = initAxisCacheMethod("axisTick");
var ensureCategoryLabelCache = initAxisCacheMethod("axisLabel");
function initAxisCacheMethod(prop) {
  return function ensureCache(axis) {
    return axisInner(axis)[prop] || (axisInner(axis)[prop] = {list: []});
  };
}
function axisCacheGet(cache, key) {
  for (let i = 0; i < cache.list.length; i++) {
    if (cache.list[i].key === key) {
      return cache.list[i].value;
    }
  }
}
function axisCacheSet(cache, key, value) {
  cache.list.push({key, value});
  return value;
}
function makeAutoCategoryInterval(axis, ctx) {
  if (ctx.kind === AxisTickLabelComputingKind.estimate) {
    const result2 = axis.calculateCategoryInterval(ctx);
    ctx.out.noPxChangeTryDetermine.push(function() {
      axisInner(axis).autoInterval = result2;
      return true;
    });
    return result2;
  }
  const result = axisInner(axis).autoInterval;
  return result != null ? result : axisInner(axis).autoInterval = axis.calculateCategoryInterval(ctx);
}
function calculateCategoryInterval(axis, ctx) {
  const kind = ctx.kind;
  const params = fetchAutoCategoryIntervalCalculationParams(axis);
  const labelFormatter = makeLabelFormatter(axis);
  const rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;
  const ordinalScale = axis.scale;
  const ordinalExtent = ordinalScale.getExtent();
  const tickCount = ordinalScale.count();
  if (ordinalExtent[1] - ordinalExtent[0] < 1) {
    return 0;
  }
  let step = 1;
  const maxCount = 40;
  if (tickCount > maxCount) {
    step = Math.max(1, Math.floor(tickCount / maxCount));
  }
  let tickValue = ordinalExtent[0];
  const unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
  const unitW = Math.abs(unitSpan * Math.cos(rotation));
  const unitH = Math.abs(unitSpan * Math.sin(rotation));
  let maxW = 0;
  let maxH = 0;
  for (; tickValue <= ordinalExtent[1]; tickValue += step) {
    let width = 0;
    let height = 0;
    const rect = getBoundingRect(labelFormatter({value: tickValue}), params.font, "center", "top");
    width = rect.width * 1.3;
    height = rect.height * 1.3;
    maxW = Math.max(maxW, width, 7);
    maxH = Math.max(maxH, height, 7);
  }
  let dw = maxW / unitW;
  let dh = maxH / unitH;
  isNaN(dw) && (dw = Infinity);
  isNaN(dh) && (dh = Infinity);
  const interval = Math.max(0, Math.floor(Math.min(dw, dh)));
  if (kind === AxisTickLabelComputingKind.estimate) {
    ctx.out.noPxChangeTryDetermine.push(bind(calculateCategoryIntervalTryDetermine, null, axis, interval, tickCount));
    return interval;
  }
  const lastInterval = calculateCategoryIntervalDealCache(axis, interval, tickCount);
  return lastInterval != null ? lastInterval : interval;
}
function calculateCategoryIntervalTryDetermine(axis, interval, tickCount) {
  return calculateCategoryIntervalDealCache(axis, interval, tickCount) == null;
}
function calculateCategoryIntervalDealCache(axis, interval, tickCount) {
  const cache = modelInner(axis.model);
  const axisExtent = axis.getExtent();
  const lastAutoInterval = cache.lastAutoInterval;
  const lastTickCount = cache.lastTickCount;
  if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval && cache.axisExtent0 === axisExtent[0] && cache.axisExtent1 === axisExtent[1]) {
    return lastAutoInterval;
  } else {
    cache.lastTickCount = tickCount;
    cache.lastAutoInterval = interval;
    cache.axisExtent0 = axisExtent[0];
    cache.axisExtent1 = axisExtent[1];
  }
}
function fetchAutoCategoryIntervalCalculationParams(axis) {
  const labelModel = axis.getLabelModel();
  return {
    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,
    labelRotate: labelModel.get("rotate") || 0,
    font: labelModel.getFont()
  };
}
function makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {
  const labelFormatter = makeLabelFormatter(axis);
  const ordinalScale = axis.scale;
  const ordinalExtent = ordinalScale.getExtent();
  const labelModel = axis.getLabelModel();
  const result = [];
  const step = Math.max((categoryInterval || 0) + 1, 1);
  let startTick = ordinalExtent[0];
  const tickCount = ordinalScale.count();
  if (startTick !== 0 && step > 1 && tickCount / step > 2) {
    startTick = Math.round(Math.ceil(startTick / step) * step);
  }
  const showAllLabel = shouldShowAllLabels(axis);
  const includeMinLabel = labelModel.get("showMinLabel") || showAllLabel;
  const includeMaxLabel = labelModel.get("showMaxLabel") || showAllLabel;
  if (includeMinLabel && startTick !== ordinalExtent[0]) {
    addItem(ordinalExtent[0]);
  }
  let tickValue = startTick;
  for (; tickValue <= ordinalExtent[1]; tickValue += step) {
    addItem(tickValue);
  }
  if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {
    addItem(ordinalExtent[1]);
  }
  function addItem(tickValue2) {
    const tickObj = {value: tickValue2};
    result.push(onlyTick ? tickValue2 : {
      formattedLabel: labelFormatter(tickObj),
      rawLabel: ordinalScale.getLabel(tickObj),
      tickValue: tickValue2,
      time: void 0,
      break: void 0
    });
  }
  return result;
}
function makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {
  const ordinalScale = axis.scale;
  const labelFormatter = makeLabelFormatter(axis);
  const result = [];
  each(ordinalScale.getTicks(), function(tick) {
    const rawLabel = ordinalScale.getLabel(tick);
    const tickValue = tick.value;
    if (categoryInterval(tick.value, rawLabel)) {
      result.push(onlyTick ? tickValue : {
        formattedLabel: labelFormatter(tick),
        rawLabel,
        tickValue,
        time: void 0,
        break: void 0
      });
    }
  });
  return result;
}

// src/coord/Axis.ts
var NORMALIZED_EXTENT = [0, 1];
var Axis = class {
  constructor(dim, scale4, extent) {
    this.onBand = false;
    this.inverse = false;
    this.dim = dim;
    this.scale = scale4;
    this._extent = extent || [0, 0];
  }
  contain(coord) {
    const extent = this._extent;
    const min3 = Math.min(extent[0], extent[1]);
    const max3 = Math.max(extent[0], extent[1]);
    return coord >= min3 && coord <= max3;
  }
  containData(data) {
    return this.scale.contain(this.scale.parse(data));
  }
  getExtent() {
    return this._extent.slice();
  }
  getPixelPrecision(dataExtent) {
    return getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
  }
  setExtent(start2, end2) {
    const extent = this._extent;
    extent[0] = start2;
    extent[1] = end2;
  }
  dataToCoord(data, clamp2) {
    let extent = this._extent;
    const scale4 = this.scale;
    data = scale4.normalize(scale4.parse(data));
    if (this.onBand && scale4.type === "ordinal") {
      extent = extent.slice();
      fixExtentWithBands(extent, scale4.count());
    }
    return linearMap(data, NORMALIZED_EXTENT, extent, clamp2);
  }
  coordToData(coord, clamp2) {
    let extent = this._extent;
    const scale4 = this.scale;
    if (this.onBand && scale4.type === "ordinal") {
      extent = extent.slice();
      fixExtentWithBands(extent, scale4.count());
    }
    const t = linearMap(coord, extent, NORMALIZED_EXTENT, clamp2);
    return this.scale.scale(t);
  }
  pointToData(point, clamp2) {
    return;
  }
  getTicksCoords(opt) {
    opt = opt || {};
    const tickModel = opt.tickModel || this.getTickModel();
    const result = createAxisTicks(this, tickModel, {
      breakTicks: opt.breakTicks,
      pruneByBreak: opt.pruneByBreak
    });
    const ticks = result.ticks;
    const ticksCoords = map(ticks, function(tickVal) {
      return {
        coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(tickVal) : tickVal),
        tickValue: tickVal
      };
    }, this);
    const alignWithLabel = tickModel.get("alignWithLabel");
    fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);
    return ticksCoords;
  }
  getMinorTicksCoords() {
    if (this.scale.type === "ordinal") {
      return [];
    }
    const minorTickModel = this.model.getModel("minorTick");
    let splitNumber = minorTickModel.get("splitNumber");
    if (!(splitNumber > 0 && splitNumber < 100)) {
      splitNumber = 5;
    }
    const minorTicks = this.scale.getMinorTicks(splitNumber);
    const minorTicksCoords = map(minorTicks, function(minorTicksGroup) {
      return map(minorTicksGroup, function(minorTick) {
        return {
          coord: this.dataToCoord(minorTick),
          tickValue: minorTick
        };
      }, this);
    }, this);
    return minorTicksCoords;
  }
  getViewLabels(ctx) {
    ctx = ctx || createAxisLabelsComputingContext(AxisTickLabelComputingKind.determine);
    return createAxisLabels(this, ctx).labels;
  }
  getLabelModel() {
    return this.model.getModel("axisLabel");
  }
  getTickModel() {
    return this.model.getModel("axisTick");
  }
  getBandWidth() {
    const axisExtent = this._extent;
    const dataExtent = this.scale.getExtent();
    let len2 = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);
    len2 === 0 && (len2 = 1);
    const size = Math.abs(axisExtent[1] - axisExtent[0]);
    return Math.abs(size) / len2;
  }
  calculateCategoryInterval(ctx) {
    ctx = ctx || createAxisLabelsComputingContext(AxisTickLabelComputingKind.determine);
    return calculateCategoryInterval(this, ctx);
  }
};
function fixExtentWithBands(extent, nTick) {
  const size = extent[1] - extent[0];
  const len2 = nTick;
  const margin = size / len2 / 2;
  extent[0] += margin;
  extent[1] -= margin;
}
function fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp2) {
  const ticksLen = ticksCoords.length;
  if (!axis.onBand || alignWithLabel || !ticksLen) {
    return;
  }
  const axisExtent = axis.getExtent();
  let last;
  let diffSize;
  if (ticksLen === 1) {
    ticksCoords[0].coord = axisExtent[0];
    ticksCoords[0].onBand = true;
    last = ticksCoords[1] = {coord: axisExtent[1], tickValue: ticksCoords[0].tickValue, onBand: true};
  } else {
    const crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;
    const shift = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;
    each(ticksCoords, function(ticksItem) {
      ticksItem.coord -= shift / 2;
      ticksItem.onBand = true;
    });
    const dataExtent = axis.scale.getExtent();
    diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;
    last = {coord: ticksCoords[ticksLen - 1].coord + shift * diffSize, tickValue: dataExtent[1] + 1, onBand: true};
    ticksCoords.push(last);
  }
  const inverse = axisExtent[0] > axisExtent[1];
  if (littleThan2(ticksCoords[0].coord, axisExtent[0])) {
    clamp2 ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();
  }
  if (clamp2 && littleThan2(axisExtent[0], ticksCoords[0].coord)) {
    ticksCoords.unshift({coord: axisExtent[0], onBand: true});
  }
  if (littleThan2(axisExtent[1], last.coord)) {
    clamp2 ? last.coord = axisExtent[1] : ticksCoords.pop();
  }
  if (clamp2 && littleThan2(last.coord, axisExtent[1])) {
    ticksCoords.push({coord: axisExtent[1], onBand: true});
  }
  function littleThan2(a, b) {
    a = round(a);
    b = round(b);
    return inverse ? a > b : a < b;
  }
}
var Axis_default = Axis;

// src/export/api.ts
function extendComponentModel(proto) {
  const Model2 = Component_default.extend(proto);
  Component_default.registerClass(Model2);
  return Model2;
}
function extendComponentView(proto) {
  const View2 = Component_default2.extend(proto);
  Component_default2.registerClass(View2);
  return View2;
}
function extendSeriesModel(proto) {
  const Model2 = Series_default.extend(proto);
  Series_default.registerClass(Model2);
  return Model2;
}
function extendChartView(proto) {
  const View2 = Chart_default.extend(proto);
  Chart_default.registerClass(View2);
  return View2;
}

// src/label/labelGuideHelper.ts
var PI27 = Math.PI * 2;
var CMD4 = PathProxy_default.CMD;
var DEFAULT_SEARCH_SPACE = ["top", "right", "bottom", "left"];
function getCandidateAnchor(pos, distance2, rect, outPt, outDir) {
  const width = rect.width;
  const height = rect.height;
  switch (pos) {
    case "top":
      outPt.set(rect.x + width / 2, rect.y - distance2);
      outDir.set(0, -1);
      break;
    case "bottom":
      outPt.set(rect.x + width / 2, rect.y + height + distance2);
      outDir.set(0, 1);
      break;
    case "left":
      outPt.set(rect.x - distance2, rect.y + height / 2);
      outDir.set(-1, 0);
      break;
    case "right":
      outPt.set(rect.x + width + distance2, rect.y + height / 2);
      outDir.set(1, 0);
      break;
  }
}
function projectPointToArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y, out2) {
  x -= cx;
  y -= cy;
  const d = Math.sqrt(x * x + y * y);
  x /= d;
  y /= d;
  const ox = x * r + cx;
  const oy = y * r + cy;
  if (Math.abs(startAngle - endAngle) % PI27 < 1e-4) {
    out2[0] = ox;
    out2[1] = oy;
    return d - r;
  }
  if (anticlockwise) {
    const tmp = startAngle;
    startAngle = normalizeRadian(endAngle);
    endAngle = normalizeRadian(tmp);
  } else {
    startAngle = normalizeRadian(startAngle);
    endAngle = normalizeRadian(endAngle);
  }
  if (startAngle > endAngle) {
    endAngle += PI27;
  }
  let angle = Math.atan2(y, x);
  if (angle < 0) {
    angle += PI27;
  }
  if (angle >= startAngle && angle <= endAngle || angle + PI27 >= startAngle && angle + PI27 <= endAngle) {
    out2[0] = ox;
    out2[1] = oy;
    return d - r;
  }
  const x1 = r * Math.cos(startAngle) + cx;
  const y1 = r * Math.sin(startAngle) + cy;
  const x2 = r * Math.cos(endAngle) + cx;
  const y2 = r * Math.sin(endAngle) + cy;
  const d1 = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y);
  const d2 = (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);
  if (d1 < d2) {
    out2[0] = x1;
    out2[1] = y1;
    return Math.sqrt(d1);
  } else {
    out2[0] = x2;
    out2[1] = y2;
    return Math.sqrt(d2);
  }
}
function projectPointToLine(x1, y1, x2, y2, x, y, out2, limitToEnds) {
  const dx = x - x1;
  const dy = y - y1;
  let dx1 = x2 - x1;
  let dy1 = y2 - y1;
  const lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1);
  dx1 /= lineLen;
  dy1 /= lineLen;
  const projectedLen = dx * dx1 + dy * dy1;
  let t = projectedLen / lineLen;
  if (limitToEnds) {
    t = Math.min(Math.max(t, 0), 1);
  }
  t *= lineLen;
  const ox = out2[0] = x1 + t * dx1;
  const oy = out2[1] = y1 + t * dy1;
  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));
}
function projectPointToRect(x1, y1, width, height, x, y, out2) {
  if (width < 0) {
    x1 = x1 + width;
    width = -width;
  }
  if (height < 0) {
    y1 = y1 + height;
    height = -height;
  }
  const x2 = x1 + width;
  const y2 = y1 + height;
  const ox = out2[0] = Math.min(Math.max(x, x1), x2);
  const oy = out2[1] = Math.min(Math.max(y, y1), y2);
  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));
}
var tmpPt = [];
function nearestPointOnRect(pt, rect, out2) {
  const dist3 = projectPointToRect(rect.x, rect.y, rect.width, rect.height, pt.x, pt.y, tmpPt);
  out2.set(tmpPt[0], tmpPt[1]);
  return dist3;
}
function nearestPointOnPath(pt, path, out2) {
  let xi = 0;
  let yi = 0;
  let x0 = 0;
  let y0 = 0;
  let x1;
  let y1;
  let minDist = Infinity;
  const data = path.data;
  const x = pt.x;
  const y = pt.y;
  for (let i = 0; i < data.length; ) {
    const cmd = data[i++];
    if (i === 1) {
      xi = data[i];
      yi = data[i + 1];
      x0 = xi;
      y0 = yi;
    }
    let d = minDist;
    switch (cmd) {
      case CMD4.M:
        x0 = data[i++];
        y0 = data[i++];
        xi = x0;
        yi = y0;
        break;
      case CMD4.L:
        d = projectPointToLine(xi, yi, data[i], data[i + 1], x, y, tmpPt, true);
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD4.C:
        d = cubicProjectPoint(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD4.Q:
        d = quadraticProjectPoint(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD4.A:
        const cx = data[i++];
        const cy = data[i++];
        const rx = data[i++];
        const ry = data[i++];
        const theta = data[i++];
        const dTheta = data[i++];
        i += 1;
        const anticlockwise = !!(1 - data[i++]);
        x1 = Math.cos(theta) * rx + cx;
        y1 = Math.sin(theta) * ry + cy;
        if (i <= 1) {
          x0 = x1;
          y0 = y1;
        }
        const _x = (x - cx) * ry / rx + cx;
        d = projectPointToArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y, tmpPt);
        xi = Math.cos(theta + dTheta) * rx + cx;
        yi = Math.sin(theta + dTheta) * ry + cy;
        break;
      case CMD4.R:
        x0 = xi = data[i++];
        y0 = yi = data[i++];
        const width = data[i++];
        const height = data[i++];
        d = projectPointToRect(x0, y0, width, height, x, y, tmpPt);
        break;
      case CMD4.Z:
        d = projectPointToLine(xi, yi, x0, y0, x, y, tmpPt, true);
        xi = x0;
        yi = y0;
        break;
    }
    if (d < minDist) {
      minDist = d;
      out2.set(tmpPt[0], tmpPt[1]);
    }
  }
  return minDist;
}
var pt0 = new Point_default();
var pt1 = new Point_default();
var pt2 = new Point_default();
var dir = new Point_default();
var dir2 = new Point_default();
function updateLabelLinePoints(target, labelLineModel) {
  if (!target) {
    return;
  }
  const labelLine = target.getTextGuideLine();
  const label = target.getTextContent();
  if (!(label && labelLine)) {
    return;
  }
  const labelGuideConfig = target.textGuideLineConfig || {};
  const points4 = [[0, 0], [0, 0], [0, 0]];
  const searchSpace = labelGuideConfig.candidates || DEFAULT_SEARCH_SPACE;
  const labelRect = label.getBoundingRect().clone();
  labelRect.applyTransform(label.getComputedTransform());
  let minDist = Infinity;
  const anchorPoint = labelGuideConfig.anchor;
  const targetTransform = target.getComputedTransform();
  const targetInversedTransform = targetTransform && invert([], targetTransform);
  const len2 = labelLineModel.get("length2") || 0;
  if (anchorPoint) {
    pt2.copy(anchorPoint);
  }
  for (let i = 0; i < searchSpace.length; i++) {
    const candidate = searchSpace[i];
    getCandidateAnchor(candidate, 0, labelRect, pt0, dir);
    Point_default.scaleAndAdd(pt1, pt0, dir, len2);
    pt1.transform(targetInversedTransform);
    const boundingRect = target.getBoundingRect();
    const dist3 = anchorPoint ? anchorPoint.distance(pt1) : target instanceof Path_default ? nearestPointOnPath(pt1, target.path, pt2) : nearestPointOnRect(pt1, boundingRect, pt2);
    if (dist3 < minDist) {
      minDist = dist3;
      pt1.transform(targetTransform);
      pt2.transform(targetTransform);
      pt2.toArray(points4[0]);
      pt1.toArray(points4[1]);
      pt0.toArray(points4[2]);
    }
  }
  limitTurnAngle(points4, labelLineModel.get("minTurnAngle"));
  labelLine.setShape({points: points4});
}
var tmpArr = [];
var tmpProjPoint = new Point_default();
function limitTurnAngle(linePoints, minTurnAngle) {
  if (!(minTurnAngle <= 180 && minTurnAngle > 0)) {
    return;
  }
  minTurnAngle = minTurnAngle / 180 * Math.PI;
  pt0.fromArray(linePoints[0]);
  pt1.fromArray(linePoints[1]);
  pt2.fromArray(linePoints[2]);
  Point_default.sub(dir, pt0, pt1);
  Point_default.sub(dir2, pt2, pt1);
  const len1 = dir.len();
  const len2 = dir2.len();
  if (len1 < 1e-3 || len2 < 1e-3) {
    return;
  }
  dir.scale(1 / len1);
  dir2.scale(1 / len2);
  const angleCos = dir.dot(dir2);
  const minTurnAngleCos = Math.cos(minTurnAngle);
  if (minTurnAngleCos < angleCos) {
    const d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
    tmpProjPoint.fromArray(tmpArr);
    tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI - minTurnAngle));
    const t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
    if (isNaN(t)) {
      return;
    }
    if (t < 0) {
      Point_default.copy(tmpProjPoint, pt1);
    } else if (t > 1) {
      Point_default.copy(tmpProjPoint, pt2);
    }
    tmpProjPoint.toArray(linePoints[1]);
  }
}
function limitSurfaceAngle(linePoints, surfaceNormal, maxSurfaceAngle) {
  if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) {
    return;
  }
  maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI;
  pt0.fromArray(linePoints[0]);
  pt1.fromArray(linePoints[1]);
  pt2.fromArray(linePoints[2]);
  Point_default.sub(dir, pt1, pt0);
  Point_default.sub(dir2, pt2, pt1);
  const len1 = dir.len();
  const len2 = dir2.len();
  if (len1 < 1e-3 || len2 < 1e-3) {
    return;
  }
  dir.scale(1 / len1);
  dir2.scale(1 / len2);
  const angleCos = dir.dot(surfaceNormal);
  const maxSurfaceAngleCos = Math.cos(maxSurfaceAngle);
  if (angleCos < maxSurfaceAngleCos) {
    const d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
    tmpProjPoint.fromArray(tmpArr);
    const HALF_PI = Math.PI / 2;
    const angle2 = Math.acos(dir2.dot(surfaceNormal));
    const newAngle = HALF_PI + angle2 - maxSurfaceAngle;
    if (newAngle >= HALF_PI) {
      Point_default.copy(tmpProjPoint, pt2);
    } else {
      tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI / 2 - newAngle));
      const t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
      if (isNaN(t)) {
        return;
      }
      if (t < 0) {
        Point_default.copy(tmpProjPoint, pt1);
      } else if (t > 1) {
        Point_default.copy(tmpProjPoint, pt2);
      }
    }
    tmpProjPoint.toArray(linePoints[1]);
  }
}
function setLabelLineState(labelLine, ignore, stateName, stateModel) {
  const isNormal = stateName === "normal";
  const stateObj = isNormal ? labelLine : labelLine.ensureState(stateName);
  stateObj.ignore = ignore;
  let smooth = stateModel.get("smooth");
  if (smooth && smooth === true) {
    smooth = 0.3;
  }
  stateObj.shape = stateObj.shape || {};
  if (smooth > 0) {
    stateObj.shape.smooth = smooth;
  }
  const styleObj = stateModel.getModel("lineStyle").getLineStyle();
  isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj;
}
function buildLabelLinePath(path, shape) {
  const smooth = shape.smooth;
  const points4 = shape.points;
  if (!points4) {
    return;
  }
  path.moveTo(points4[0][0], points4[0][1]);
  if (smooth > 0 && points4.length >= 3) {
    const len1 = dist(points4[0], points4[1]);
    const len2 = dist(points4[1], points4[2]);
    if (!len1 || !len2) {
      path.lineTo(points4[1][0], points4[1][1]);
      path.lineTo(points4[2][0], points4[2][1]);
      return;
    }
    const moveLen = Math.min(len1, len2) * smooth;
    const midPoint0 = lerp([], points4[1], points4[0], moveLen / len1);
    const midPoint2 = lerp([], points4[1], points4[2], moveLen / len2);
    const midPoint1 = lerp([], midPoint0, midPoint2, 0.5);
    path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1]);
    path.bezierCurveTo(midPoint2[0], midPoint2[1], midPoint2[0], midPoint2[1], points4[2][0], points4[2][1]);
  } else {
    for (let i = 1; i < points4.length; i++) {
      path.lineTo(points4[i][0], points4[i][1]);
    }
  }
}
function setLabelLineStyle(targetEl, statesModels, defaultStyle) {
  let labelLine = targetEl.getTextGuideLine();
  const label = targetEl.getTextContent();
  if (!label) {
    if (labelLine) {
      targetEl.removeTextGuideLine();
    }
    return;
  }
  const normalModel = statesModels.normal;
  const showNormal = normalModel.get("show");
  const labelIgnoreNormal = label.ignore;
  for (let i = 0; i < DISPLAY_STATES.length; i++) {
    const stateName = DISPLAY_STATES[i];
    const stateModel = statesModels[stateName];
    const isNormal = stateName === "normal";
    if (stateModel) {
      const stateShow = stateModel.get("show");
      const isLabelIgnored = isNormal ? labelIgnoreNormal : retrieve2(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal);
      if (isLabelIgnored || !retrieve2(stateShow, showNormal)) {
        const stateObj = isNormal ? labelLine : labelLine && labelLine.states[stateName];
        if (stateObj) {
          stateObj.ignore = true;
        }
        if (!!labelLine) {
          setLabelLineState(labelLine, true, stateName, stateModel);
        }
        continue;
      }
      if (!labelLine) {
        labelLine = new Polyline_default();
        targetEl.setTextGuideLine(labelLine);
        if (!isNormal && (labelIgnoreNormal || !showNormal)) {
          setLabelLineState(labelLine, true, "normal", statesModels.normal);
        }
        if (targetEl.stateProxy) {
          labelLine.stateProxy = targetEl.stateProxy;
        }
      }
      setLabelLineState(labelLine, false, stateName, stateModel);
    }
  }
  if (labelLine) {
    defaults(labelLine.style, defaultStyle);
    labelLine.style.fill = null;
    const showAbove = normalModel.get("showAbove");
    const labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {};
    labelLineConfig.showAbove = showAbove || false;
    labelLine.buildPath = buildLabelLinePath;
  }
}
function getLabelLineStatesModels(itemModel, labelLineName) {
  labelLineName = labelLineName || "labelLine";
  const statesModels = {
    normal: itemModel.getModel(labelLineName)
  };
  for (let i = 0; i < SPECIAL_STATES.length; i++) {
    const stateName = SPECIAL_STATES[i];
    statesModels[stateName] = itemModel.getModel([stateName, labelLineName]);
  }
  return statesModels;
}

// src/label/labelLayoutHelper.ts
var LABEL_LAYOUT_INFO_KIND_RAW = 1;
var LABEL_LAYOUT_INFO_KIND_COMPUTED = 2;
function createLabelLayoutList(rawList) {
  const resultList = [];
  each(rawList, (raw) => {
    raw = extend({}, raw);
    const layoutInfo = prepareLabelLayoutInfo(raw);
    if (layoutInfo) {
      resultList.push(layoutInfo);
    }
  });
  return resultList;
}
function prepareLabelLayoutInfo(layoutInfo) {
  if (!layoutInfo || layoutInfo.defaultAttr.ignore) {
    return;
  }
  const label = layoutInfo.label;
  const ignoreMargin = layoutInfo.ignoreMargin;
  const transform2 = label.getComputedTransform();
  let localRect = label.getBoundingRect();
  const axisAligned = isBoundingRectAxisAligned(transform2);
  if (!ignoreMargin) {
    localRect = applyTextMarginToLocalRect(label, localRect);
  }
  const globalRect = localRect.clone();
  globalRect.applyTransform(transform2);
  if (!ignoreMargin && label.style.__marginType === LabelMarginType.minMargin) {
    const halfMinMargin = (label.style.margin || 0) / 2;
    expandOrShrinkRect(globalRect, halfMinMargin, false, false);
  }
  const computed = layoutInfo;
  computed.kind = LABEL_LAYOUT_INFO_KIND_COMPUTED, computed.rect = globalRect;
  computed.localRect = localRect;
  computed.obb = null, computed.axisAligned = axisAligned;
  computed.transform = transform2;
  return computed;
}
function rollbackToLabelLayoutInfoRaw(labelLayoutInfo) {
  if (labelLayoutInfo == null) {
    return;
  }
  const raw = labelLayoutInfo;
  raw.kind = LABEL_LAYOUT_INFO_KIND_RAW;
  return raw;
}
function ensureLabelLayoutInfoComputed(labelLayoutInfo) {
  if (!labelLayoutInfo) {
    return;
  }
  if (labelLayoutInfo.kind !== LABEL_LAYOUT_INFO_KIND_COMPUTED) {
    labelLayoutInfo = prepareLabelLayoutInfo(labelLayoutInfo);
  }
  return labelLayoutInfo;
}
function prepareIntersectionCheckInfo(localRect, transform2) {
  const globalRect = localRect.clone();
  globalRect.applyTransform(transform2);
  return {
    obb: null,
    rect: globalRect,
    localRect,
    axisAligned: isBoundingRectAxisAligned(transform2),
    transform: transform2
  };
}
function createSingleLayoutInfoComputed(el) {
  return ensureLabelLayoutInfoComputed({
    kind: LABEL_LAYOUT_INFO_KIND_RAW,
    label: el,
    priority: el.z2,
    defaultAttr: {ignore: el.ignore}
  });
}
function ensureOBB(layoutInfo) {
  return layoutInfo.obb || (layoutInfo.obb = new OrientedBoundingRect_default(layoutInfo.localRect, layoutInfo.transform));
}
function applyTextMarginToLocalRect(label, localRect) {
  if (label.style.__marginType !== LabelMarginType.textMargin) {
    return localRect;
  }
  const textMargin = normalizeCssArray2(retrieve2(label.style.margin, [0, 0]));
  localRect = localRect.clone();
  expandOrShrinkRect(localRect, textMargin, false, false);
  return localRect;
}
function shiftLayout(list, xyDim, sizeDim, minBound, maxBound, balanceShift) {
  const len2 = list.length;
  if (len2 < 2) {
    return;
  }
  list.sort(function(a, b) {
    return a.rect[xyDim] - b.rect[xyDim];
  });
  let lastPos = 0;
  let delta;
  let adjusted = false;
  const shifts = [];
  let totalShifts = 0;
  for (let i = 0; i < len2; i++) {
    const item = list[i];
    const rect = item.rect;
    delta = rect[xyDim] - lastPos;
    if (delta < 0) {
      rect[xyDim] -= delta;
      item.label[xyDim] -= delta;
      adjusted = true;
    }
    const shift = Math.max(-delta, 0);
    shifts.push(shift);
    totalShifts += shift;
    lastPos = rect[xyDim] + rect[sizeDim];
  }
  if (totalShifts > 0 && balanceShift) {
    shiftList(-totalShifts / len2, 0, len2);
  }
  const first = list[0];
  const last = list[len2 - 1];
  let minGap;
  let maxGap;
  updateMinMaxGap();
  minGap < 0 && squeezeGaps(-minGap, 0.8);
  maxGap < 0 && squeezeGaps(maxGap, 0.8);
  updateMinMaxGap();
  takeBoundsGap(minGap, maxGap, 1);
  takeBoundsGap(maxGap, minGap, -1);
  updateMinMaxGap();
  if (minGap < 0) {
    squeezeWhenBailout(-minGap);
  }
  if (maxGap < 0) {
    squeezeWhenBailout(maxGap);
  }
  function updateMinMaxGap() {
    minGap = first.rect[xyDim] - minBound;
    maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];
  }
  function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {
    if (gapThisBound < 0) {
      const moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);
      if (moveFromMaxGap > 0) {
        shiftList(moveFromMaxGap * moveDir, 0, len2);
        const remained = moveFromMaxGap + gapThisBound;
        if (remained < 0) {
          squeezeGaps(-remained * moveDir, 1);
        }
      } else {
        squeezeGaps(-gapThisBound * moveDir, 1);
      }
    }
  }
  function shiftList(delta2, start2, end2) {
    if (delta2 !== 0) {
      adjusted = true;
    }
    for (let i = start2; i < end2; i++) {
      const item = list[i];
      const rect = item.rect;
      rect[xyDim] += delta2;
      item.label[xyDim] += delta2;
    }
  }
  function squeezeGaps(delta2, maxSqeezePercent) {
    const gaps = [];
    let totalGaps = 0;
    for (let i = 1; i < len2; i++) {
      const prevItemRect = list[i - 1].rect;
      const gap = Math.max(list[i].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);
      gaps.push(gap);
      totalGaps += gap;
    }
    if (!totalGaps) {
      return;
    }
    const squeezePercent = Math.min(Math.abs(delta2) / totalGaps, maxSqeezePercent);
    if (delta2 > 0) {
      for (let i = 0; i < len2 - 1; i++) {
        const movement = gaps[i] * squeezePercent;
        shiftList(movement, 0, i + 1);
      }
    } else {
      for (let i = len2 - 1; i > 0; i--) {
        const movement = gaps[i - 1] * squeezePercent;
        shiftList(-movement, i, len2);
      }
    }
  }
  function squeezeWhenBailout(delta2) {
    const dir3 = delta2 < 0 ? -1 : 1;
    delta2 = Math.abs(delta2);
    const moveForEachLabel = Math.ceil(delta2 / (len2 - 1));
    for (let i = 0; i < len2 - 1; i++) {
      if (dir3 > 0) {
        shiftList(moveForEachLabel, 0, i + 1);
      } else {
        shiftList(-moveForEachLabel, len2 - i - 1, len2);
      }
      delta2 -= moveForEachLabel;
      if (delta2 <= 0) {
        return;
      }
    }
  }
  return adjusted;
}
function shiftLayoutOnX(list, leftBound, rightBound, balanceShift) {
  return shiftLayout(list, "x", "width", leftBound, rightBound, balanceShift);
}
function shiftLayoutOnY(list, topBound, bottomBound, balanceShift) {
  return shiftLayout(list, "y", "height", topBound, bottomBound, balanceShift);
}
function hideOverlap(labelList) {
  const displayedLabels = [];
  labelList.sort(function(a, b) {
    return (b.suggestIgnore ? 1 : 0) - (a.suggestIgnore ? 1 : 0) || b.priority - a.priority;
  });
  function hideEl(el) {
    if (!el.ignore) {
      const emphasisState = el.ensureState("emphasis");
      if (emphasisState.ignore == null) {
        emphasisState.ignore = false;
      }
    }
    el.ignore = true;
  }
  for (let i = 0; i < labelList.length; i++) {
    const labelItem = ensureLabelLayoutInfoComputed(labelList[i]);
    if (!labelItem || labelItem.label.ignore) {
      continue;
    }
    const label = labelItem.label;
    const labelLine = labelItem.labelLine;
    let overlapped = false;
    for (let j = 0; j < displayedLabels.length; j++) {
      if (labelIntersect(labelItem, displayedLabels[j], null, {touchThreshold: 0.05})) {
        overlapped = true;
        break;
      }
    }
    if (overlapped) {
      hideEl(label);
      labelLine && hideEl(labelLine);
    } else {
      label.attr("ignore", labelItem.defaultAttr.ignore);
      labelLine && labelLine.attr("ignore", labelItem.defaultAttr.labelGuideIgnore);
      displayedLabels.push(labelItem);
    }
  }
}
function labelIntersect(baseLayoutInfo, targetLayoutInfo, mtv, intersectOpt) {
  if (!baseLayoutInfo || !targetLayoutInfo) {
    return false;
  }
  if (!baseLayoutInfo.rect.intersect(targetLayoutInfo.rect, mtv, intersectOpt)) {
    return false;
  }
  if (baseLayoutInfo.axisAligned && targetLayoutInfo.axisAligned) {
    return true;
  }
  return ensureOBB(baseLayoutInfo).intersect(ensureOBB(targetLayoutInfo), mtv, intersectOpt);
}

// src/label/LabelManager.ts
function cloneArr(points4) {
  if (points4) {
    const newPoints = [];
    for (let i = 0; i < points4.length; i++) {
      newPoints.push(points4[i].slice());
    }
    return newPoints;
  }
}
function prepareLayoutCallbackParams(labelItem, hostEl) {
  const label = labelItem.label;
  const labelLine = hostEl && hostEl.getTextGuideLine();
  return {
    dataIndex: labelItem.dataIndex,
    dataType: labelItem.dataType,
    seriesIndex: labelItem.seriesModel.seriesIndex,
    text: labelItem.label.style.text,
    rect: labelItem.hostRect,
    labelRect: labelItem.rect,
    align: label.style.align,
    verticalAlign: label.style.verticalAlign,
    labelLinePoints: cloneArr(labelLine && labelLine.shape.points)
  };
}
var LABEL_OPTION_TO_STYLE_KEYS = ["align", "verticalAlign", "width", "height", "fontSize"];
var dummyTransformable = new Transformable_default();
var labelLayoutInnerStore = makeInner();
var labelLineAnimationStore = makeInner();
function extendWithKeys(target, source, keys2) {
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    if (source[key] != null) {
      target[key] = source[key];
    }
  }
}
var LABEL_LAYOUT_PROPS = ["x", "y", "rotation"];
var LabelManager = class {
  constructor() {
    this._labelList = [];
    this._chartViewList = [];
  }
  clearLabels() {
    this._labelList = [];
    this._chartViewList = [];
  }
  _addLabel(dataIndex, dataType, seriesModel, label, layoutOptionOrCb) {
    const labelStyle = label.style;
    const hostEl = label.__hostTarget;
    const textConfig = hostEl.textConfig || {};
    const labelTransform = label.getComputedTransform();
    const labelRect = label.getBoundingRect().plain();
    BoundingRect_default.applyTransform(labelRect, labelRect, labelTransform);
    if (labelTransform) {
      dummyTransformable.setLocalTransform(labelTransform);
    } else {
      dummyTransformable.x = dummyTransformable.y = dummyTransformable.rotation = dummyTransformable.originX = dummyTransformable.originY = 0;
      dummyTransformable.scaleX = dummyTransformable.scaleY = 1;
    }
    dummyTransformable.rotation = normalizeRadian(dummyTransformable.rotation);
    const host = label.__hostTarget;
    let hostRect;
    if (host) {
      hostRect = host.getBoundingRect().plain();
      const transform2 = host.getComputedTransform();
      BoundingRect_default.applyTransform(hostRect, hostRect, transform2);
    }
    const labelGuide = hostRect && host.getTextGuideLine();
    this._labelList.push({
      kind: LABEL_LAYOUT_INFO_KIND_RAW,
      label,
      labelLine: labelGuide,
      seriesModel,
      dataIndex,
      dataType,
      layoutOptionOrCb,
      layoutOption: null,
      rect: labelRect,
      hostRect,
      priority: hostRect ? hostRect.width * hostRect.height : 0,
      defaultAttr: {
        ignore: label.ignore,
        labelGuideIgnore: labelGuide && labelGuide.ignore,
        x: dummyTransformable.x,
        y: dummyTransformable.y,
        scaleX: dummyTransformable.scaleX,
        scaleY: dummyTransformable.scaleY,
        rotation: dummyTransformable.rotation,
        style: {
          x: labelStyle.x,
          y: labelStyle.y,
          align: labelStyle.align,
          verticalAlign: labelStyle.verticalAlign,
          width: labelStyle.width,
          height: labelStyle.height,
          fontSize: labelStyle.fontSize
        },
        cursor: label.cursor,
        attachedPos: textConfig.position,
        attachedRot: textConfig.rotation
      }
    });
  }
  addLabelsOfSeries(chartView) {
    this._chartViewList.push(chartView);
    const seriesModel = chartView.__model;
    const layoutOption = seriesModel.get("labelLayout");
    if (!(isFunction(layoutOption) || keys(layoutOption).length)) {
      return;
    }
    chartView.group.traverse((child) => {
      if (child.ignore) {
        return true;
      }
      const textEl = child.getTextContent();
      const ecData = getECData(child);
      if (textEl && !textEl.disableLabelLayout) {
        this._addLabel(ecData.dataIndex, ecData.dataType, seriesModel, textEl, layoutOption);
      }
    });
  }
  updateLayoutConfig(api2) {
    const width = api2.getWidth();
    const height = api2.getHeight();
    function createDragHandler(el, labelLineModel) {
      return function() {
        updateLabelLinePoints(el, labelLineModel);
      };
    }
    for (let i = 0; i < this._labelList.length; i++) {
      const labelItem = this._labelList[i];
      const label = labelItem.label;
      const hostEl = label.__hostTarget;
      const defaultLabelAttr = labelItem.defaultAttr;
      let layoutOption;
      if (isFunction(labelItem.layoutOptionOrCb)) {
        layoutOption = labelItem.layoutOptionOrCb(prepareLayoutCallbackParams(labelItem, hostEl));
      } else {
        layoutOption = labelItem.layoutOptionOrCb;
      }
      layoutOption = layoutOption || {};
      labelItem.layoutOption = layoutOption;
      const degreeToRadian = Math.PI / 180;
      if (hostEl) {
        hostEl.setTextConfig({
          local: false,
          position: layoutOption.x != null || layoutOption.y != null ? null : defaultLabelAttr.attachedPos,
          rotation: layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.attachedRot,
          offset: [layoutOption.dx || 0, layoutOption.dy || 0]
        });
      }
      let needsUpdateLabelLine = false;
      if (layoutOption.x != null) {
        label.x = parsePercent2(layoutOption.x, width);
        label.setStyle("x", 0);
        needsUpdateLabelLine = true;
      } else {
        label.x = defaultLabelAttr.x;
        label.setStyle("x", defaultLabelAttr.style.x);
      }
      if (layoutOption.y != null) {
        label.y = parsePercent2(layoutOption.y, height);
        label.setStyle("y", 0);
        needsUpdateLabelLine = true;
      } else {
        label.y = defaultLabelAttr.y;
        label.setStyle("y", defaultLabelAttr.style.y);
      }
      if (layoutOption.labelLinePoints) {
        const guideLine = hostEl.getTextGuideLine();
        if (guideLine) {
          guideLine.setShape({points: layoutOption.labelLinePoints});
          needsUpdateLabelLine = false;
        }
      }
      const labelLayoutStore = labelLayoutInnerStore(label);
      labelLayoutStore.needsUpdateLabelLine = needsUpdateLabelLine;
      label.rotation = layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.rotation;
      label.scaleX = defaultLabelAttr.scaleX;
      label.scaleY = defaultLabelAttr.scaleY;
      for (let k = 0; k < LABEL_OPTION_TO_STYLE_KEYS.length; k++) {
        const key = LABEL_OPTION_TO_STYLE_KEYS[k];
        label.setStyle(key, layoutOption[key] != null ? layoutOption[key] : defaultLabelAttr.style[key]);
      }
      if (layoutOption.draggable) {
        label.draggable = true;
        label.cursor = "move";
        if (hostEl) {
          let hostModel = labelItem.seriesModel;
          if (labelItem.dataIndex != null) {
            const data = labelItem.seriesModel.getData(labelItem.dataType);
            hostModel = data.getItemModel(labelItem.dataIndex);
          }
          label.on("drag", createDragHandler(hostEl, hostModel.getModel("labelLine")));
        }
      } else {
        label.off("drag");
        label.cursor = defaultLabelAttr.cursor;
      }
    }
  }
  layout(api2) {
    const width = api2.getWidth();
    const height = api2.getHeight();
    const labelList = createLabelLayoutList(this._labelList);
    const labelsNeedsAdjustOnX = filter(labelList, function(item) {
      return item.layoutOption.moveOverlap === "shiftX";
    });
    const labelsNeedsAdjustOnY = filter(labelList, function(item) {
      return item.layoutOption.moveOverlap === "shiftY";
    });
    shiftLayoutOnX(labelsNeedsAdjustOnX, 0, width);
    shiftLayoutOnY(labelsNeedsAdjustOnY, 0, height);
    const labelsNeedsHideOverlap = filter(labelList, function(item) {
      return item.layoutOption.hideOverlap;
    });
    hideOverlap(labelsNeedsHideOverlap);
  }
  processLabelsOverall() {
    each(this._chartViewList, (chartView) => {
      const seriesModel = chartView.__model;
      const ignoreLabelLineUpdate = chartView.ignoreLabelLineUpdate;
      const animationEnabled = seriesModel.isAnimationEnabled();
      chartView.group.traverse((child) => {
        if (child.ignore && !child.forceLabelAnimation) {
          return true;
        }
        let needsUpdateLabelLine = !ignoreLabelLineUpdate;
        const label = child.getTextContent();
        if (!needsUpdateLabelLine && label) {
          needsUpdateLabelLine = labelLayoutInnerStore(label).needsUpdateLabelLine;
        }
        if (needsUpdateLabelLine) {
          this._updateLabelLine(child, seriesModel);
        }
        if (animationEnabled) {
          this._animateLabels(child, seriesModel);
        }
      });
    });
  }
  _updateLabelLine(el, seriesModel) {
    const textEl = el.getTextContent();
    const ecData = getECData(el);
    const dataIndex = ecData.dataIndex;
    if (textEl && dataIndex != null) {
      const data = seriesModel.getData(ecData.dataType);
      const itemModel = data.getItemModel(dataIndex);
      const defaultStyle = {};
      const visualStyle = data.getItemVisual(dataIndex, "style");
      if (visualStyle) {
        const visualType = data.getVisual("drawType");
        defaultStyle.stroke = visualStyle[visualType];
      }
      const labelLineModel = itemModel.getModel("labelLine");
      setLabelLineStyle(el, getLabelLineStatesModels(itemModel), defaultStyle);
      updateLabelLinePoints(el, labelLineModel);
    }
  }
  _animateLabels(el, seriesModel) {
    const textEl = el.getTextContent();
    const guideLine = el.getTextGuideLine();
    if (textEl && (el.forceLabelAnimation || !textEl.ignore && !textEl.invisible && !el.disableLabelAnimation && !isElementRemoved(el))) {
      const layoutStore = labelLayoutInnerStore(textEl);
      const oldLayout = layoutStore.oldLayout;
      const ecData = getECData(el);
      const dataIndex = ecData.dataIndex;
      const newProps = {
        x: textEl.x,
        y: textEl.y,
        rotation: textEl.rotation
      };
      const data = seriesModel.getData(ecData.dataType);
      if (!oldLayout) {
        textEl.attr(newProps);
        if (!labelInner(textEl).valueAnimation) {
          const oldOpacity = retrieve2(textEl.style.opacity, 1);
          textEl.style.opacity = 0;
          initProps(textEl, {
            style: {opacity: oldOpacity}
          }, seriesModel, dataIndex);
        }
      } else {
        textEl.attr(oldLayout);
        const prevStates = el.prevStates;
        if (prevStates) {
          if (indexOf(prevStates, "select") >= 0) {
            textEl.attr(layoutStore.oldLayoutSelect);
          }
          if (indexOf(prevStates, "emphasis") >= 0) {
            textEl.attr(layoutStore.oldLayoutEmphasis);
          }
        }
        updateProps(textEl, newProps, seriesModel, dataIndex);
      }
      layoutStore.oldLayout = newProps;
      if (textEl.states.select) {
        const layoutSelect = layoutStore.oldLayoutSelect = {};
        extendWithKeys(layoutSelect, newProps, LABEL_LAYOUT_PROPS);
        extendWithKeys(layoutSelect, textEl.states.select, LABEL_LAYOUT_PROPS);
      }
      if (textEl.states.emphasis) {
        const layoutEmphasis = layoutStore.oldLayoutEmphasis = {};
        extendWithKeys(layoutEmphasis, newProps, LABEL_LAYOUT_PROPS);
        extendWithKeys(layoutEmphasis, textEl.states.emphasis, LABEL_LAYOUT_PROPS);
      }
      animateLabelValue(textEl, dataIndex, data, seriesModel, seriesModel);
    }
    if (guideLine && !guideLine.ignore && !guideLine.invisible) {
      const layoutStore = labelLineAnimationStore(guideLine);
      const oldLayout = layoutStore.oldLayout;
      const newLayout = {points: guideLine.shape.points};
      if (!oldLayout) {
        guideLine.setShape(newLayout);
        guideLine.style.strokePercent = 0;
        initProps(guideLine, {
          style: {strokePercent: 1}
        }, seriesModel);
      } else {
        guideLine.attr({shape: oldLayout});
        updateProps(guideLine, {
          shape: newLayout
        }, seriesModel);
      }
      layoutStore.oldLayout = newLayout;
    }
  }
};
var LabelManager_default = LabelManager;

// src/label/installLabelLayout.ts
var getLabelManager = makeInner();
function installLabelLayout(registers) {
  registers.registerUpdateLifecycle("series:beforeupdate", (ecModel, api2, params) => {
    let labelManager = getLabelManager(api2).labelManager;
    if (!labelManager) {
      labelManager = getLabelManager(api2).labelManager = new LabelManager_default();
    }
    labelManager.clearLabels();
  });
  registers.registerUpdateLifecycle("series:layoutlabels", (ecModel, api2, params) => {
    const labelManager = getLabelManager(api2).labelManager;
    params.updatedSeries.forEach((series) => {
      labelManager.addLabelsOfSeries(api2.getViewOfSeriesModel(series));
    });
    labelManager.updateLayoutConfig(api2);
    labelManager.layout(api2);
    labelManager.processLabelsOverall();
  });
}

// src/component/axis/axisAction.ts
var AXIS_BREAK_EXPAND_ACTION_TYPE = "expandAxisBreak";
var AXIS_BREAK_COLLAPSE_ACTION_TYPE = "collapseAxisBreak";
var AXIS_BREAK_TOGGLE_ACTION_TYPE = "toggleAxisBreak";
var AXIS_BREAK_CHANGED_EVENT_TYPE = "axisbreakchanged";
var expandAxisBreakActionInfo = {
  type: AXIS_BREAK_EXPAND_ACTION_TYPE,
  event: AXIS_BREAK_CHANGED_EVENT_TYPE,
  update: "update",
  refineEvent: refineAxisBreakChangeEvent
};
var collapseAxisBreakActionInfo = {
  type: AXIS_BREAK_COLLAPSE_ACTION_TYPE,
  event: AXIS_BREAK_CHANGED_EVENT_TYPE,
  update: "update",
  refineEvent: refineAxisBreakChangeEvent
};
var toggleAxisBreakActionInfo = {
  type: AXIS_BREAK_TOGGLE_ACTION_TYPE,
  event: AXIS_BREAK_CHANGED_EVENT_TYPE,
  update: "update",
  refineEvent: refineAxisBreakChangeEvent
};
function refineAxisBreakChangeEvent(actionResultBatch, payload, ecModel, api2) {
  let breaks = [];
  each(actionResultBatch, (actionResult) => {
    breaks = breaks.concat(actionResult.eventBreaks);
  });
  return {
    eventContent: {breaks}
  };
}
function registerAction2(registers) {
  registers.registerAction(expandAxisBreakActionInfo, actionHandler);
  registers.registerAction(collapseAxisBreakActionInfo, actionHandler);
  registers.registerAction(toggleAxisBreakActionInfo, actionHandler);
  function actionHandler(payload, ecModel) {
    const eventBreaks = [];
    const finderResult = parseFinder(ecModel, payload);
    function dealUpdate(modelProp, indexProp) {
      each(finderResult[modelProp], (axisModel) => {
        const result = axisModel.updateAxisBreaks(payload);
        each(result.breaks, (item) => {
          eventBreaks.push(defaults({[indexProp]: axisModel.componentIndex}, item));
        });
      });
    }
    dealUpdate("xAxisModels", "xAxisIndex");
    dealUpdate("yAxisModels", "yAxisIndex");
    dealUpdate("singleAxisModels", "singleAxisIndex");
    return {eventBreaks};
  }
}

// ../zrender/src/svg/SVGPathRebuilder.ts
var mathSin5 = Math.sin;
var mathCos5 = Math.cos;
var PI6 = Math.PI;
var PI28 = Math.PI * 2;
var degree = 180 / PI6;
var SVGPathRebuilder = class {
  reset(precision) {
    this._start = true;
    this._d = [];
    this._str = "";
    this._p = Math.pow(10, precision || 4);
  }
  moveTo(x, y) {
    this._add("M", x, y);
  }
  lineTo(x, y) {
    this._add("L", x, y);
  }
  bezierCurveTo(x, y, x2, y2, x3, y3) {
    this._add("C", x, y, x2, y2, x3, y3);
  }
  quadraticCurveTo(x, y, x2, y2) {
    this._add("Q", x, y, x2, y2);
  }
  arc(cx, cy, r, startAngle, endAngle, anticlockwise) {
    this.ellipse(cx, cy, r, r, 0, startAngle, endAngle, anticlockwise);
  }
  ellipse(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise) {
    let dTheta = endAngle - startAngle;
    const clockwise = !anticlockwise;
    const dThetaPositive = Math.abs(dTheta);
    const isCircle = isAroundZero2(dThetaPositive - PI28) || (clockwise ? dTheta >= PI28 : -dTheta >= PI28);
    const unifiedTheta = dTheta > 0 ? dTheta % PI28 : dTheta % PI28 + PI28;
    let large = false;
    if (isCircle) {
      large = true;
    } else if (isAroundZero2(dThetaPositive)) {
      large = false;
    } else {
      large = unifiedTheta >= PI6 === !!clockwise;
    }
    const x0 = cx + rx * mathCos5(startAngle);
    const y0 = cy + ry * mathSin5(startAngle);
    if (this._start) {
      this._add("M", x0, y0);
    }
    const xRot = Math.round(psi * degree);
    if (isCircle) {
      const p = 1 / this._p;
      const dTheta2 = (clockwise ? 1 : -1) * (PI28 - p);
      this._add("A", rx, ry, xRot, 1, +clockwise, cx + rx * mathCos5(startAngle + dTheta2), cy + ry * mathSin5(startAngle + dTheta2));
      if (p > 0.01) {
        this._add("A", rx, ry, xRot, 0, +clockwise, x0, y0);
      }
    } else {
      const x = cx + rx * mathCos5(endAngle);
      const y = cy + ry * mathSin5(endAngle);
      this._add("A", rx, ry, xRot, +large, +clockwise, x, y);
    }
  }
  rect(x, y, w, h) {
    this._add("M", x, y);
    this._add("l", w, 0);
    this._add("l", 0, h);
    this._add("l", -w, 0);
    this._add("Z");
  }
  closePath() {
    if (this._d.length > 0) {
      this._add("Z");
    }
  }
  _add(cmd, a, b, c, d, e2, f, g, h) {
    const vals = [];
    const p = this._p;
    for (let i = 1; i < arguments.length; i++) {
      const val = arguments[i];
      if (isNaN(val)) {
        this._invalid = true;
        return;
      }
      vals.push(Math.round(val * p) / p);
    }
    this._d.push(cmd + vals.join(" "));
    this._start = cmd === "Z";
  }
  generateStr() {
    this._str = this._invalid ? "" : this._d.join("");
    this._d = [];
  }
  getStr() {
    return this._str;
  }
};
var SVGPathRebuilder_default = SVGPathRebuilder;

// ../zrender/src/svg/mapStyleToAttrs.ts
var NONE = "none";
var mathRound2 = Math.round;
function pathHasFill(style) {
  const fill = style.fill;
  return fill != null && fill !== NONE;
}
function pathHasStroke(style) {
  const stroke = style.stroke;
  return stroke != null && stroke !== NONE;
}
var strokeProps = ["lineCap", "miterLimit", "lineJoin"];
var svgStrokeProps = map(strokeProps, (prop) => `stroke-${prop.toLowerCase()}`);
function mapStyleToAttrs(updateAttr2, style, el, forceUpdate) {
  const opacity = style.opacity == null ? 1 : style.opacity;
  if (el instanceof Image_default) {
    updateAttr2("opacity", opacity);
    return;
  }
  if (pathHasFill(style)) {
    const fill = normalizeColor(style.fill);
    updateAttr2("fill", fill.color);
    const fillOpacity = style.fillOpacity != null ? style.fillOpacity * fill.opacity * opacity : fill.opacity * opacity;
    if (forceUpdate || fillOpacity < 1) {
      updateAttr2("fill-opacity", fillOpacity);
    }
  } else {
    updateAttr2("fill", NONE);
  }
  if (pathHasStroke(style)) {
    const stroke = normalizeColor(style.stroke);
    updateAttr2("stroke", stroke.color);
    const strokeScale = style.strokeNoScale ? el.getLineScale() : 1;
    const strokeWidth = strokeScale ? (style.lineWidth || 0) / strokeScale : 0;
    const strokeOpacity = style.strokeOpacity != null ? style.strokeOpacity * stroke.opacity * opacity : stroke.opacity * opacity;
    const strokeFirst = style.strokeFirst;
    if (forceUpdate || strokeWidth !== 1) {
      updateAttr2("stroke-width", strokeWidth);
    }
    if (forceUpdate || strokeFirst) {
      updateAttr2("paint-order", strokeFirst ? "stroke" : "fill");
    }
    if (forceUpdate || strokeOpacity < 1) {
      updateAttr2("stroke-opacity", strokeOpacity);
    }
    if (style.lineDash) {
      let [lineDash, lineDashOffset] = getLineDash(el);
      if (lineDash) {
        lineDashOffset = mathRound2(lineDashOffset || 0);
        updateAttr2("stroke-dasharray", lineDash.join(","));
        if (lineDashOffset || forceUpdate) {
          updateAttr2("stroke-dashoffset", lineDashOffset);
        }
      }
    } else if (forceUpdate) {
      updateAttr2("stroke-dasharray", NONE);
    }
    for (let i = 0; i < strokeProps.length; i++) {
      const propName = strokeProps[i];
      if (forceUpdate || style[propName] !== DEFAULT_PATH_STYLE[propName]) {
        const val = style[propName] || DEFAULT_PATH_STYLE[propName];
        val && updateAttr2(svgStrokeProps[i], val);
      }
    }
  } else if (forceUpdate) {
    updateAttr2("stroke", NONE);
  }
}

// ../zrender/src/svg/core.ts
var SVGNS = "http://www.w3.org/2000/svg";
var XLINKNS = "http://www.w3.org/1999/xlink";
var XMLNS = "http://www.w3.org/2000/xmlns/";
var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
var META_DATA_PREFIX = "ecmeta_";
function createElement(name) {
  return document.createElementNS(SVGNS, name);
}
function createVNode(tag, key, attrs, children, text) {
  return {
    tag,
    attrs: attrs || {},
    children,
    text,
    key
  };
}
function createElementOpen(name, attrs) {
  const attrsStr = [];
  if (attrs) {
    for (let key in attrs) {
      const val = attrs[key];
      let part = key;
      if (val === false) {
        continue;
      } else if (val !== true && val != null) {
        part += `="${val}"`;
      }
      attrsStr.push(part);
    }
  }
  return `<${name} ${attrsStr.join(" ")}>`;
}
function createElementClose(name) {
  return `</${name}>`;
}
function vNodeToString(el, opts) {
  opts = opts || {};
  const S = opts.newline ? "\n" : "";
  function convertElToString(el2) {
    const {children, tag, attrs, text} = el2;
    return createElementOpen(tag, attrs) + (tag !== "style" ? encodeHTML(text) : text || "") + (children ? `${S}${map(children, (child) => convertElToString(child)).join(S)}${S}` : "") + createElementClose(tag);
  }
  return convertElToString(el);
}
function getCssString(selectorNodes, animationNodes, opts) {
  opts = opts || {};
  const S = opts.newline ? "\n" : "";
  const bracketBegin = ` {${S}`;
  const bracketEnd = `${S}}`;
  const selectors = map(keys(selectorNodes), (className) => {
    return className + bracketBegin + map(keys(selectorNodes[className]), (attrName) => {
      return `${attrName}:${selectorNodes[className][attrName]};`;
    }).join(S) + bracketEnd;
  }).join(S);
  const animations = map(keys(animationNodes), (animationName) => {
    return `@keyframes ${animationName}${bracketBegin}` + map(keys(animationNodes[animationName]), (percent) => {
      return percent + bracketBegin + map(keys(animationNodes[animationName][percent]), (attrName) => {
        let val = animationNodes[animationName][percent][attrName];
        if (attrName === "d") {
          val = `path("${val}")`;
        }
        return `${attrName}:${val};`;
      }).join(S) + bracketEnd;
    }).join(S) + bracketEnd;
  }).join(S);
  if (!selectors && !animations) {
    return "";
  }
  return ["<![CDATA[", selectors, animations, "]]>"].join(S);
}
function createBrushScope(zrId) {
  return {
    zrId,
    shadowCache: {},
    patternCache: {},
    gradientCache: {},
    clipPathCache: {},
    defs: {},
    cssNodes: {},
    cssAnims: {},
    cssStyleCache: {},
    cssAnimIdx: 0,
    shadowIdx: 0,
    gradientIdx: 0,
    patternIdx: 0,
    clipPathIdx: 0
  };
}
function createSVGVNode(width, height, children, useViewBox) {
  return createVNode("svg", "root", {
    width,
    height,
    xmlns: SVGNS,
    "xmlns:xlink": XLINKNS,
    version: "1.1",
    baseProfile: "full",
    viewBox: useViewBox ? `0 0 ${width} ${height}` : false
  }, children);
}

// ../zrender/src/svg/cssClassId.ts
var cssClassIdx = 0;
function getClassId() {
  return cssClassIdx++;
}

// ../zrender/src/svg/cssAnimation.ts
var EASING_MAP = {
  cubicIn: "0.32,0,0.67,0",
  cubicOut: "0.33,1,0.68,1",
  cubicInOut: "0.65,0,0.35,1",
  quadraticIn: "0.11,0,0.5,0",
  quadraticOut: "0.5,1,0.89,1",
  quadraticInOut: "0.45,0,0.55,1",
  quarticIn: "0.5,0,0.75,0",
  quarticOut: "0.25,1,0.5,1",
  quarticInOut: "0.76,0,0.24,1",
  quinticIn: "0.64,0,0.78,0",
  quinticOut: "0.22,1,0.36,1",
  quinticInOut: "0.83,0,0.17,1",
  sinusoidalIn: "0.12,0,0.39,0",
  sinusoidalOut: "0.61,1,0.88,1",
  sinusoidalInOut: "0.37,0,0.63,1",
  exponentialIn: "0.7,0,0.84,0",
  exponentialOut: "0.16,1,0.3,1",
  exponentialInOut: "0.87,0,0.13,1",
  circularIn: "0.55,0,1,0.45",
  circularOut: "0,0.55,0.45,1",
  circularInOut: "0.85,0,0.15,1"
};
var transformOriginKey = "transform-origin";
function buildPathString(el, kfShape, path) {
  const shape = extend({}, el.shape);
  extend(shape, kfShape);
  el.buildPath(path, shape);
  const svgPathBuilder = new SVGPathRebuilder_default();
  svgPathBuilder.reset(getPathPrecision(el));
  path.rebuildPath(svgPathBuilder, 1);
  svgPathBuilder.generateStr();
  return svgPathBuilder.getStr();
}
function setTransformOrigin(target, transform2) {
  const {originX, originY} = transform2;
  if (originX || originY) {
    target[transformOriginKey] = `${originX}px ${originY}px`;
  }
}
var ANIMATE_STYLE_MAP = {
  fill: "fill",
  opacity: "opacity",
  lineWidth: "stroke-width",
  lineDashOffset: "stroke-dashoffset"
};
function addAnimation(cssAnim, scope) {
  const animationName = scope.zrId + "-ani-" + scope.cssAnimIdx++;
  scope.cssAnims[animationName] = cssAnim;
  return animationName;
}
function createCompoundPathCSSAnimation(el, attrs, scope) {
  const paths = el.shape.paths;
  const composedAnim = {};
  let cssAnimationCfg;
  let cssAnimationName;
  each(paths, (path) => {
    const subScope = createBrushScope(scope.zrId);
    subScope.animation = true;
    createCSSAnimation(path, {}, subScope, true);
    const cssAnims = subScope.cssAnims;
    const cssNodes = subScope.cssNodes;
    const animNames = keys(cssAnims);
    const len2 = animNames.length;
    if (!len2) {
      return;
    }
    cssAnimationName = animNames[len2 - 1];
    const lastAnim = cssAnims[cssAnimationName];
    for (let percent in lastAnim) {
      const kf = lastAnim[percent];
      composedAnim[percent] = composedAnim[percent] || {d: ""};
      composedAnim[percent].d += kf.d || "";
    }
    for (let className in cssNodes) {
      const val = cssNodes[className].animation;
      if (val.indexOf(cssAnimationName) >= 0) {
        cssAnimationCfg = val;
      }
    }
  });
  if (!cssAnimationCfg) {
    return;
  }
  attrs.d = false;
  const animationName = addAnimation(composedAnim, scope);
  return cssAnimationCfg.replace(cssAnimationName, animationName);
}
function getEasingFunc(easing) {
  return isString(easing) ? EASING_MAP[easing] ? `cubic-bezier(${EASING_MAP[easing]})` : createCubicEasingFunc(easing) ? easing : "" : "";
}
function createCSSAnimation(el, attrs, scope, onlyShape) {
  const animators = el.animators;
  const len2 = animators.length;
  const cssAnimations = [];
  if (el instanceof CompoundPath_default) {
    const animationCfg = createCompoundPathCSSAnimation(el, attrs, scope);
    if (animationCfg) {
      cssAnimations.push(animationCfg);
    } else if (!len2) {
      return;
    }
  } else if (!len2) {
    return;
  }
  const groupAnimators = {};
  for (let i = 0; i < len2; i++) {
    const animator = animators[i];
    const cfgArr = [animator.getMaxTime() / 1e3 + "s"];
    const easing = getEasingFunc(animator.getClip().easing);
    const delay = animator.getDelay();
    if (easing) {
      cfgArr.push(easing);
    } else {
      cfgArr.push("linear");
    }
    if (delay) {
      cfgArr.push(delay / 1e3 + "s");
    }
    if (animator.getLoop()) {
      cfgArr.push("infinite");
    }
    const cfg = cfgArr.join(" ");
    groupAnimators[cfg] = groupAnimators[cfg] || [cfg, []];
    groupAnimators[cfg][1].push(animator);
  }
  function createSingleCSSAnimation(groupAnimator) {
    const animators2 = groupAnimator[1];
    const len3 = animators2.length;
    const transformKfs = {};
    const shapeKfs = {};
    const finalKfs = {};
    const animationTimingFunctionAttrName = "animation-timing-function";
    function saveAnimatorTrackToCssKfs(animator, cssKfs, toCssAttrName) {
      const tracks = animator.getTracks();
      const maxTime = animator.getMaxTime();
      for (let k = 0; k < tracks.length; k++) {
        const track = tracks[k];
        if (track.needsAnimate()) {
          const kfs = track.keyframes;
          let attrName = track.propName;
          toCssAttrName && (attrName = toCssAttrName(attrName));
          if (attrName) {
            for (let i = 0; i < kfs.length; i++) {
              const kf = kfs[i];
              const percent = Math.round(kf.time / maxTime * 100) + "%";
              const kfEasing = getEasingFunc(kf.easing);
              const rawValue = kf.rawValue;
              if (isString(rawValue) || isNumber(rawValue)) {
                cssKfs[percent] = cssKfs[percent] || {};
                cssKfs[percent][attrName] = kf.rawValue;
                if (kfEasing) {
                  cssKfs[percent][animationTimingFunctionAttrName] = kfEasing;
                }
              }
            }
          }
        }
      }
    }
    for (let i = 0; i < len3; i++) {
      const animator = animators2[i];
      const targetProp = animator.targetName;
      if (!targetProp) {
        !onlyShape && saveAnimatorTrackToCssKfs(animator, transformKfs);
      } else if (targetProp === "shape") {
        saveAnimatorTrackToCssKfs(animator, shapeKfs);
      }
    }
    for (let percent in transformKfs) {
      const transform2 = {};
      copyTransform(transform2, el);
      extend(transform2, transformKfs[percent]);
      const str = getSRTTransformString(transform2);
      const timingFunction = transformKfs[percent][animationTimingFunctionAttrName];
      finalKfs[percent] = str ? {
        transform: str
      } : {};
      setTransformOrigin(finalKfs[percent], transform2);
      if (timingFunction) {
        finalKfs[percent][animationTimingFunctionAttrName] = timingFunction;
      }
    }
    ;
    let path;
    let canAnimateShape = true;
    for (let percent in shapeKfs) {
      finalKfs[percent] = finalKfs[percent] || {};
      const isFirst = !path;
      const timingFunction = shapeKfs[percent][animationTimingFunctionAttrName];
      if (isFirst) {
        path = new PathProxy_default();
      }
      let len4 = path.len();
      path.reset();
      finalKfs[percent].d = buildPathString(el, shapeKfs[percent], path);
      let newLen = path.len();
      if (!isFirst && len4 !== newLen) {
        canAnimateShape = false;
        break;
      }
      if (timingFunction) {
        finalKfs[percent][animationTimingFunctionAttrName] = timingFunction;
      }
    }
    ;
    if (!canAnimateShape) {
      for (let percent in finalKfs) {
        delete finalKfs[percent].d;
      }
    }
    if (!onlyShape) {
      for (let i = 0; i < len3; i++) {
        const animator = animators2[i];
        const targetProp = animator.targetName;
        if (targetProp === "style") {
          saveAnimatorTrackToCssKfs(animator, finalKfs, (propName) => ANIMATE_STYLE_MAP[propName]);
        }
      }
    }
    const percents = keys(finalKfs);
    let allTransformOriginSame = true;
    let transformOrigin;
    for (let i = 1; i < percents.length; i++) {
      const p0 = percents[i - 1];
      const p1 = percents[i];
      if (finalKfs[p0][transformOriginKey] !== finalKfs[p1][transformOriginKey]) {
        allTransformOriginSame = false;
        break;
      }
      transformOrigin = finalKfs[p0][transformOriginKey];
    }
    if (allTransformOriginSame && transformOrigin) {
      for (const percent in finalKfs) {
        if (finalKfs[percent][transformOriginKey]) {
          delete finalKfs[percent][transformOriginKey];
        }
      }
      attrs[transformOriginKey] = transformOrigin;
    }
    if (filter(percents, (percent) => keys(finalKfs[percent]).length > 0).length) {
      const animationName = addAnimation(finalKfs, scope);
      return `${animationName} ${groupAnimator[0]} both`;
    }
  }
  for (let key in groupAnimators) {
    const animationCfg = createSingleCSSAnimation(groupAnimators[key]);
    if (animationCfg) {
      cssAnimations.push(animationCfg);
    }
  }
  if (cssAnimations.length) {
    const className = scope.zrId + "-cls-" + getClassId();
    scope.cssNodes["." + className] = {
      animation: cssAnimations.join(",")
    };
    attrs.class = className;
  }
}

// ../zrender/src/svg/cssEmphasis.ts
function createCSSEmphasis(el, attrs, scope) {
  if (!el.ignore) {
    if (el.isSilent()) {
      const style = {
        "pointer-events": "none"
      };
      setClassAttribute(style, attrs, scope, true);
    } else {
      const emphasisStyle = el.states.emphasis && el.states.emphasis.style ? el.states.emphasis.style : {};
      let fill = emphasisStyle.fill;
      if (!fill) {
        const normalFill = el.style && el.style.fill;
        const selectFill = el.states.select && el.states.select.style && el.states.select.style.fill;
        const fromFill = el.currentStates.indexOf("select") >= 0 ? selectFill || normalFill : normalFill;
        if (fromFill) {
          fill = liftColor(fromFill);
        }
      }
      let lineWidth = emphasisStyle.lineWidth;
      if (lineWidth) {
        const scaleX = !emphasisStyle.strokeNoScale && el.transform ? el.transform[0] : 1;
        lineWidth = lineWidth / scaleX;
      }
      const style = {
        cursor: "pointer"
      };
      if (fill) {
        style.fill = fill;
      }
      if (emphasisStyle.stroke) {
        style.stroke = emphasisStyle.stroke;
      }
      if (lineWidth) {
        style["stroke-width"] = lineWidth;
      }
      setClassAttribute(style, attrs, scope, true);
    }
  }
}
function setClassAttribute(style, attrs, scope, withHover) {
  const styleKey = JSON.stringify(style);
  let className = scope.cssStyleCache[styleKey];
  if (!className) {
    className = scope.zrId + "-cls-" + getClassId();
    scope.cssStyleCache[styleKey] = className;
    scope.cssNodes["." + className + (withHover ? ":hover" : "")] = style;
  }
  attrs.class = attrs.class ? attrs.class + " " + className : className;
}

// ../zrender/src/svg/graphic.ts
var round5 = Math.round;
function isImageLike2(val) {
  return val && isString(val.src);
}
function isCanvasLike(val) {
  return val && isFunction(val.toDataURL);
}
function setStyleAttrs(attrs, style, el, scope) {
  mapStyleToAttrs((key, val) => {
    const isFillStroke = key === "fill" || key === "stroke";
    if (isFillStroke && isGradient(val)) {
      setGradient(style, attrs, key, scope);
    } else if (isFillStroke && isPattern(val)) {
      setPattern(el, attrs, key, scope);
    } else {
      attrs[key] = val;
    }
    if (isFillStroke && scope.ssr && val === "none") {
      attrs["pointer-events"] = "visible";
    }
  }, style, el, false);
  setShadow(el, attrs, scope);
}
function setMetaData(attrs, el) {
  const metaData = getElementSSRData(el);
  if (metaData) {
    metaData.each((val, key) => {
      val != null && (attrs[(META_DATA_PREFIX + key).toLowerCase()] = val + "");
    });
    if (el.isSilent()) {
      attrs[META_DATA_PREFIX + "silent"] = "true";
    }
  }
}
function noRotateScale(m2) {
  return isAroundZero2(m2[0] - 1) && isAroundZero2(m2[1]) && isAroundZero2(m2[2]) && isAroundZero2(m2[3] - 1);
}
function noTranslate(m2) {
  return isAroundZero2(m2[4]) && isAroundZero2(m2[5]);
}
function setTransform(attrs, m2, compress) {
  if (m2 && !(noTranslate(m2) && noRotateScale(m2))) {
    const mul3 = compress ? 10 : 1e4;
    attrs.transform = noRotateScale(m2) ? `translate(${round5(m2[4] * mul3) / mul3} ${round5(m2[5] * mul3) / mul3})` : getMatrixStr(m2);
  }
}
function convertPolyShape(shape, attrs, mul3) {
  const points4 = shape.points;
  const strArr = [];
  for (let i = 0; i < points4.length; i++) {
    strArr.push(round5(points4[i][0] * mul3) / mul3);
    strArr.push(round5(points4[i][1] * mul3) / mul3);
  }
  attrs.points = strArr.join(" ");
}
function validatePolyShape(shape) {
  return !shape.smooth;
}
function createAttrsConvert(desc) {
  const normalizedDesc = map(desc, (item) => typeof item === "string" ? [item, item] : item);
  return function(shape, attrs, mul3) {
    for (let i = 0; i < normalizedDesc.length; i++) {
      const item = normalizedDesc[i];
      const val = shape[item[0]];
      if (val != null) {
        attrs[item[1]] = round5(val * mul3) / mul3;
      }
    }
  };
}
var builtinShapesDef = {
  circle: [createAttrsConvert(["cx", "cy", "r"])],
  polyline: [convertPolyShape, validatePolyShape],
  polygon: [convertPolyShape, validatePolyShape]
};
function hasShapeAnimation(el) {
  const animators = el.animators;
  for (let i = 0; i < animators.length; i++) {
    if (animators[i].targetName === "shape") {
      return true;
    }
  }
  return false;
}
function brushSVGPath(el, scope) {
  const style = el.style;
  const shape = el.shape;
  const builtinShpDef = builtinShapesDef[el.type];
  const attrs = {};
  const needsAnimate = scope.animation;
  let svgElType = "path";
  const strokePercent = el.style.strokePercent;
  const precision = scope.compress && getPathPrecision(el) || 4;
  if (builtinShpDef && !scope.willUpdate && !(builtinShpDef[1] && !builtinShpDef[1](shape)) && !(needsAnimate && hasShapeAnimation(el)) && !(strokePercent < 1)) {
    svgElType = el.type;
    const mul3 = Math.pow(10, precision);
    builtinShpDef[0](shape, attrs, mul3);
  } else {
    const needBuildPath = !el.path || el.shapeChanged();
    if (!el.path) {
      el.createPathProxy();
    }
    const path = el.path;
    if (needBuildPath) {
      path.beginPath();
      el.buildPath(path, el.shape);
      el.pathUpdated();
    }
    const pathVersion = path.getVersion();
    const elExt = el;
    let svgPathBuilder = elExt.__svgPathBuilder;
    if (elExt.__svgPathVersion !== pathVersion || !svgPathBuilder || strokePercent !== elExt.__svgPathStrokePercent) {
      if (!svgPathBuilder) {
        svgPathBuilder = elExt.__svgPathBuilder = new SVGPathRebuilder_default();
      }
      svgPathBuilder.reset(precision);
      path.rebuildPath(svgPathBuilder, strokePercent);
      svgPathBuilder.generateStr();
      elExt.__svgPathVersion = pathVersion;
      elExt.__svgPathStrokePercent = strokePercent;
    }
    attrs.d = svgPathBuilder.getStr();
  }
  setTransform(attrs, el.transform);
  setStyleAttrs(attrs, style, el, scope);
  setMetaData(attrs, el);
  scope.animation && createCSSAnimation(el, attrs, scope);
  scope.emphasis && createCSSEmphasis(el, attrs, scope);
  return createVNode(svgElType, el.id + "", attrs);
}
function brushSVGImage(el, scope) {
  const style = el.style;
  let image = style.image;
  if (image && !isString(image)) {
    if (isImageLike2(image)) {
      image = image.src;
    } else if (isCanvasLike(image)) {
      image = image.toDataURL();
    }
  }
  if (!image) {
    return;
  }
  const x = style.x || 0;
  const y = style.y || 0;
  const dw = style.width;
  const dh = style.height;
  const attrs = {
    href: image,
    width: dw,
    height: dh
  };
  if (x) {
    attrs.x = x;
  }
  if (y) {
    attrs.y = y;
  }
  setTransform(attrs, el.transform);
  setStyleAttrs(attrs, style, el, scope);
  setMetaData(attrs, el);
  scope.animation && createCSSAnimation(el, attrs, scope);
  return createVNode("image", el.id + "", attrs);
}
function brushSVGTSpan(el, scope) {
  const style = el.style;
  let text = style.text;
  text != null && (text += "");
  if (!text || isNaN(style.x) || isNaN(style.y)) {
    return;
  }
  const font = style.font || DEFAULT_FONT;
  const x = style.x || 0;
  const y = adjustTextY(style.y || 0, getLineHeight(font), style.textBaseline);
  const textAlign = TEXT_ALIGN_TO_ANCHOR[style.textAlign] || style.textAlign;
  const attrs = {
    "dominant-baseline": "central",
    "text-anchor": textAlign
  };
  if (hasSeparateFont(style)) {
    let separatedFontStr = "";
    const fontStyle = style.fontStyle;
    const fontSize = parseFontSize(style.fontSize);
    if (!parseFloat(fontSize)) {
      return;
    }
    const fontFamily = style.fontFamily || DEFAULT_FONT_FAMILY;
    const fontWeight = style.fontWeight;
    separatedFontStr += `font-size:${fontSize};font-family:${fontFamily};`;
    if (fontStyle && fontStyle !== "normal") {
      separatedFontStr += `font-style:${fontStyle};`;
    }
    if (fontWeight && fontWeight !== "normal") {
      separatedFontStr += `font-weight:${fontWeight};`;
    }
    attrs.style = separatedFontStr;
  } else {
    attrs.style = `font: ${font}`;
  }
  if (text.match(/\s/)) {
    attrs["xml:space"] = "preserve";
  }
  if (x) {
    attrs.x = x;
  }
  if (y) {
    attrs.y = y;
  }
  setTransform(attrs, el.transform);
  setStyleAttrs(attrs, style, el, scope);
  setMetaData(attrs, el);
  scope.animation && createCSSAnimation(el, attrs, scope);
  return createVNode("text", el.id + "", attrs, void 0, text);
}
function brush2(el, scope) {
  if (el instanceof Path_default) {
    return brushSVGPath(el, scope);
  } else if (el instanceof Image_default) {
    return brushSVGImage(el, scope);
  } else if (el instanceof TSpan_default) {
    return brushSVGTSpan(el, scope);
  }
}
function setShadow(el, attrs, scope) {
  const style = el.style;
  if (hasShadow(style)) {
    const shadowKey = getShadowKey(el);
    const shadowCache = scope.shadowCache;
    let shadowId = shadowCache[shadowKey];
    if (!shadowId) {
      const globalScale = el.getGlobalScale();
      const scaleX = globalScale[0];
      const scaleY = globalScale[1];
      if (!scaleX || !scaleY) {
        return;
      }
      const offsetX = style.shadowOffsetX || 0;
      const offsetY = style.shadowOffsetY || 0;
      const blur = style.shadowBlur;
      const {opacity, color: color4} = normalizeColor(style.shadowColor);
      const stdDx = blur / 2 / scaleX;
      const stdDy = blur / 2 / scaleY;
      const stdDeviation = stdDx + " " + stdDy;
      shadowId = scope.zrId + "-s" + scope.shadowIdx++;
      scope.defs[shadowId] = createVNode("filter", shadowId, {
        id: shadowId,
        x: "-100%",
        y: "-100%",
        width: "300%",
        height: "300%"
      }, [
        createVNode("feDropShadow", "", {
          dx: offsetX / scaleX,
          dy: offsetY / scaleY,
          stdDeviation,
          "flood-color": color4,
          "flood-opacity": opacity
        })
      ]);
      shadowCache[shadowKey] = shadowId;
    }
    attrs.filter = getIdURL(shadowId);
  }
}
function setGradient(style, attrs, target, scope) {
  const val = style[target];
  let gradientTag;
  let gradientAttrs = {
    gradientUnits: val.global ? "userSpaceOnUse" : "objectBoundingBox"
  };
  if (isLinearGradient(val)) {
    gradientTag = "linearGradient";
    gradientAttrs.x1 = val.x;
    gradientAttrs.y1 = val.y;
    gradientAttrs.x2 = val.x2;
    gradientAttrs.y2 = val.y2;
  } else if (isRadialGradient(val)) {
    gradientTag = "radialGradient";
    gradientAttrs.cx = retrieve2(val.x, 0.5);
    gradientAttrs.cy = retrieve2(val.y, 0.5);
    gradientAttrs.r = retrieve2(val.r, 0.5);
  } else {
    if (true) {
      logError("Illegal gradient type.");
    }
    return;
  }
  const colors = val.colorStops;
  const colorStops = [];
  for (let i = 0, len2 = colors.length; i < len2; ++i) {
    const offset = round4(colors[i].offset) * 100 + "%";
    const stopColor = colors[i].color;
    const {color: color4, opacity} = normalizeColor(stopColor);
    const stopsAttrs = {
      offset
    };
    stopsAttrs["stop-color"] = color4;
    if (opacity < 1) {
      stopsAttrs["stop-opacity"] = opacity;
    }
    colorStops.push(createVNode("stop", i + "", stopsAttrs));
  }
  const gradientVNode = createVNode(gradientTag, "", gradientAttrs, colorStops);
  const gradientKey = vNodeToString(gradientVNode);
  const gradientCache = scope.gradientCache;
  let gradientId = gradientCache[gradientKey];
  if (!gradientId) {
    gradientId = scope.zrId + "-g" + scope.gradientIdx++;
    gradientCache[gradientKey] = gradientId;
    gradientAttrs.id = gradientId;
    scope.defs[gradientId] = createVNode(gradientTag, gradientId, gradientAttrs, colorStops);
  }
  attrs[target] = getIdURL(gradientId);
}
function setPattern(el, attrs, target, scope) {
  const val = el.style[target];
  const boundingRect = el.getBoundingRect();
  const patternAttrs = {};
  const repeat = val.repeat;
  const noRepeat = repeat === "no-repeat";
  const repeatX = repeat === "repeat-x";
  const repeatY = repeat === "repeat-y";
  let child;
  if (isImagePattern(val)) {
    let imageWidth = val.imageWidth;
    let imageHeight = val.imageHeight;
    let imageSrc;
    const patternImage = val.image;
    if (isString(patternImage)) {
      imageSrc = patternImage;
    } else if (isImageLike2(patternImage)) {
      imageSrc = patternImage.src;
    } else if (isCanvasLike(patternImage)) {
      imageSrc = patternImage.toDataURL();
    }
    if (typeof Image === "undefined") {
      const errMsg = "Image width/height must been given explictly in svg-ssr renderer.";
      assert(imageWidth, errMsg);
      assert(imageHeight, errMsg);
    } else if (imageWidth == null || imageHeight == null) {
      const setSizeToVNode = (vNode, img) => {
        if (vNode) {
          const svgEl = vNode.elm;
          let width = imageWidth || img.width;
          let height = imageHeight || img.height;
          if (vNode.tag === "pattern") {
            if (repeatX) {
              height = 1;
              width /= boundingRect.width;
            } else if (repeatY) {
              width = 1;
              height /= boundingRect.height;
            }
          }
          vNode.attrs.width = width;
          vNode.attrs.height = height;
          if (svgEl) {
            svgEl.setAttribute("width", width);
            svgEl.setAttribute("height", height);
          }
        }
      };
      const createdImage = createOrUpdateImage(imageSrc, null, el, (img) => {
        noRepeat || setSizeToVNode(patternVNode, img);
        setSizeToVNode(child, img);
      });
      if (createdImage && createdImage.width && createdImage.height) {
        imageWidth = imageWidth || createdImage.width;
        imageHeight = imageHeight || createdImage.height;
      }
    }
    child = createVNode("image", "img", {
      href: imageSrc,
      width: imageWidth,
      height: imageHeight
    });
    patternAttrs.width = imageWidth;
    patternAttrs.height = imageHeight;
  } else if (val.svgElement) {
    child = clone(val.svgElement);
    patternAttrs.width = val.svgWidth;
    patternAttrs.height = val.svgHeight;
  }
  if (!child) {
    return;
  }
  let patternWidth;
  let patternHeight;
  if (noRepeat) {
    patternWidth = patternHeight = 1;
  } else if (repeatX) {
    patternHeight = 1;
    patternWidth = patternAttrs.width / boundingRect.width;
  } else if (repeatY) {
    patternWidth = 1;
    patternHeight = patternAttrs.height / boundingRect.height;
  } else {
    patternAttrs.patternUnits = "userSpaceOnUse";
  }
  if (patternWidth != null && !isNaN(patternWidth)) {
    patternAttrs.width = patternWidth;
  }
  if (patternHeight != null && !isNaN(patternHeight)) {
    patternAttrs.height = patternHeight;
  }
  const patternTransform = getSRTTransformString(val);
  patternTransform && (patternAttrs.patternTransform = patternTransform);
  let patternVNode = createVNode("pattern", "", patternAttrs, [child]);
  const patternKey = vNodeToString(patternVNode);
  const patternCache = scope.patternCache;
  let patternId = patternCache[patternKey];
  if (!patternId) {
    patternId = scope.zrId + "-p" + scope.patternIdx++;
    patternCache[patternKey] = patternId;
    patternAttrs.id = patternId;
    patternVNode = scope.defs[patternId] = createVNode("pattern", patternId, patternAttrs, [child]);
  }
  attrs[target] = getIdURL(patternId);
}
function setClipPath(clipPath, attrs, scope) {
  const {clipPathCache, defs} = scope;
  let clipPathId = clipPathCache[clipPath.id];
  if (!clipPathId) {
    clipPathId = scope.zrId + "-c" + scope.clipPathIdx++;
    const clipPathAttrs = {
      id: clipPathId
    };
    clipPathCache[clipPath.id] = clipPathId;
    defs[clipPathId] = createVNode("clipPath", clipPathId, clipPathAttrs, [brushSVGPath(clipPath, scope)]);
  }
  attrs["clip-path"] = getIdURL(clipPathId);
}

// ../zrender/src/svg/domapi.ts
function createTextNode(text) {
  return document.createTextNode(text);
}
function insertBefore(parentNode2, newNode, referenceNode) {
  parentNode2.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
  node.removeChild(child);
}
function appendChild(node, child) {
  node.appendChild(child);
}
function parentNode(node) {
  return node.parentNode;
}
function nextSibling(node) {
  return node.nextSibling;
}
function setTextContent(node, text) {
  node.textContent = text;
}

// ../zrender/src/svg/patch.ts
var colonChar = 58;
var xChar = 120;
var emptyNode = createVNode("", "");
function isUndef(s) {
  return s === void 0;
}
function isDef(s) {
  return s !== void 0;
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
  const map3 = {};
  for (let i = beginIdx; i <= endIdx; ++i) {
    const key = children[i].key;
    if (key !== void 0) {
      if (true) {
        if (map3[key] != null) {
          console.error(`Duplicate key ${key}`);
        }
      }
      map3[key] = i;
    }
  }
  return map3;
}
function sameVnode(vnode1, vnode2) {
  const isSameKey = vnode1.key === vnode2.key;
  const isSameTag = vnode1.tag === vnode2.tag;
  return isSameTag && isSameKey;
}
function createElm(vnode) {
  let i;
  const children = vnode.children;
  const tag = vnode.tag;
  if (isDef(tag)) {
    const elm = vnode.elm = createElement(tag);
    updateAttrs(emptyNode, vnode);
    if (isArray(children)) {
      for (i = 0; i < children.length; ++i) {
        const ch = children[i];
        if (ch != null) {
          appendChild(elm, createElm(ch));
        }
      }
    } else if (isDef(vnode.text) && !isObject(vnode.text)) {
      appendChild(elm, createTextNode(vnode.text));
    }
  } else {
    vnode.elm = createTextNode(vnode.text);
  }
  return vnode.elm;
}
function addVnodes(parentElm, before, vnodes, startIdx, endIdx) {
  for (; startIdx <= endIdx; ++startIdx) {
    const ch = vnodes[startIdx];
    if (ch != null) {
      insertBefore(parentElm, createElm(ch), before);
    }
  }
}
function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
  for (; startIdx <= endIdx; ++startIdx) {
    const ch = vnodes[startIdx];
    if (ch != null) {
      if (isDef(ch.tag)) {
        const parent = parentNode(ch.elm);
        removeChild(parent, ch.elm);
      } else {
        removeChild(parentElm, ch.elm);
      }
    }
  }
}
function updateAttrs(oldVnode, vnode) {
  let key;
  const elm = vnode.elm;
  const oldAttrs = oldVnode && oldVnode.attrs || {};
  const attrs = vnode.attrs || {};
  if (oldAttrs === attrs) {
    return;
  }
  for (key in attrs) {
    const cur = attrs[key];
    const old = oldAttrs[key];
    if (old !== cur) {
      if (cur === true) {
        elm.setAttribute(key, "");
      } else if (cur === false) {
        elm.removeAttribute(key);
      } else {
        if (key === "style") {
          elm.style.cssText = cur;
        } else if (key.charCodeAt(0) !== xChar) {
          elm.setAttribute(key, cur);
        } else if (key === "xmlns:xlink" || key === "xmlns") {
          elm.setAttributeNS(XMLNS, key, cur);
        } else if (key.charCodeAt(3) === colonChar) {
          elm.setAttributeNS(XML_NAMESPACE, key, cur);
        } else if (key.charCodeAt(5) === colonChar) {
          elm.setAttributeNS(XLINKNS, key, cur);
        } else {
          elm.setAttribute(key, cur);
        }
      }
    }
  }
  for (key in oldAttrs) {
    if (!(key in attrs)) {
      elm.removeAttribute(key);
    }
  }
}
function updateChildren(parentElm, oldCh, newCh) {
  let oldStartIdx = 0;
  let newStartIdx = 0;
  let oldEndIdx = oldCh.length - 1;
  let oldStartVnode = oldCh[0];
  let oldEndVnode = oldCh[oldEndIdx];
  let newEndIdx = newCh.length - 1;
  let newStartVnode = newCh[0];
  let newEndVnode = newCh[newEndIdx];
  let oldKeyToIdx;
  let idxInOld;
  let elmToMove;
  let before;
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (oldStartVnode == null) {
      oldStartVnode = oldCh[++oldStartIdx];
    } else if (oldEndVnode == null) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (newStartVnode == null) {
      newStartVnode = newCh[++newStartIdx];
    } else if (newEndVnode == null) {
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldStartVnode, newStartVnode)) {
      patchVnode(oldStartVnode, newStartVnode);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (sameVnode(oldEndVnode, newEndVnode)) {
      patchVnode(oldEndVnode, newEndVnode);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldStartVnode, newEndVnode)) {
      patchVnode(oldStartVnode, newEndVnode);
      insertBefore(parentElm, oldStartVnode.elm, nextSibling(oldEndVnode.elm));
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldEndVnode, newStartVnode)) {
      patchVnode(oldEndVnode, newStartVnode);
      insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      if (isUndef(oldKeyToIdx)) {
        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
      }
      idxInOld = oldKeyToIdx[newStartVnode.key];
      if (isUndef(idxInOld)) {
        insertBefore(parentElm, createElm(newStartVnode), oldStartVnode.elm);
      } else {
        elmToMove = oldCh[idxInOld];
        if (elmToMove.tag !== newStartVnode.tag) {
          insertBefore(parentElm, createElm(newStartVnode), oldStartVnode.elm);
        } else {
          patchVnode(elmToMove, newStartVnode);
          oldCh[idxInOld] = void 0;
          insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
        }
      }
      newStartVnode = newCh[++newStartIdx];
    }
  }
  if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
    if (oldStartIdx > oldEndIdx) {
      before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx);
    } else {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }
}
function patchVnode(oldVnode, vnode) {
  const elm = vnode.elm = oldVnode.elm;
  const oldCh = oldVnode.children;
  const ch = vnode.children;
  if (oldVnode === vnode) {
    return;
  }
  updateAttrs(oldVnode, vnode);
  if (isUndef(vnode.text)) {
    if (isDef(oldCh) && isDef(ch)) {
      if (oldCh !== ch) {
        updateChildren(elm, oldCh, ch);
      }
    } else if (isDef(ch)) {
      if (isDef(oldVnode.text)) {
        setTextContent(elm, "");
      }
      addVnodes(elm, null, ch, 0, ch.length - 1);
    } else if (isDef(oldCh)) {
      removeVnodes(elm, oldCh, 0, oldCh.length - 1);
    } else if (isDef(oldVnode.text)) {
      setTextContent(elm, "");
    }
  } else if (oldVnode.text !== vnode.text) {
    if (isDef(oldCh)) {
      removeVnodes(elm, oldCh, 0, oldCh.length - 1);
    }
    setTextContent(elm, vnode.text);
  }
}
function patch(oldVnode, vnode) {
  if (sameVnode(oldVnode, vnode)) {
    patchVnode(oldVnode, vnode);
  } else {
    const elm = oldVnode.elm;
    const parent = parentNode(elm);
    createElm(vnode);
    if (parent !== null) {
      insertBefore(parent, vnode.elm, nextSibling(elm));
      removeVnodes(parent, [oldVnode], 0, 0);
    }
  }
  return vnode;
}

// ../zrender/src/svg/Painter.ts
var svgId = 0;
var SVGPainter = class {
  constructor(root, storage2, opts) {
    this.type = "svg";
    this.refreshHover = createMethodNotSupport("refreshHover");
    this.configLayer = createMethodNotSupport("configLayer");
    this.storage = storage2;
    this._opts = opts = extend({}, opts);
    this.root = root;
    this._id = "zr" + svgId++;
    this._oldVNode = createSVGVNode(opts.width, opts.height);
    if (root && !opts.ssr) {
      const viewport = this._viewport = document.createElement("div");
      viewport.style.cssText = "position:relative;overflow:hidden";
      const svgDom = this._svgDom = this._oldVNode.elm = createElement("svg");
      updateAttrs(null, this._oldVNode);
      viewport.appendChild(svgDom);
      root.appendChild(viewport);
    }
    this.resize(opts.width, opts.height);
  }
  getType() {
    return this.type;
  }
  getViewportRoot() {
    return this._viewport;
  }
  getViewportRootOffset() {
    const viewportRoot = this.getViewportRoot();
    if (viewportRoot) {
      return {
        offsetLeft: viewportRoot.offsetLeft || 0,
        offsetTop: viewportRoot.offsetTop || 0
      };
    }
  }
  getSvgDom() {
    return this._svgDom;
  }
  refresh() {
    if (this.root) {
      const vnode = this.renderToVNode({
        willUpdate: true
      });
      vnode.attrs.style = "position:absolute;left:0;top:0;user-select:none";
      patch(this._oldVNode, vnode);
      this._oldVNode = vnode;
    }
  }
  renderOneToVNode(el) {
    return brush2(el, createBrushScope(this._id));
  }
  renderToVNode(opts) {
    opts = opts || {};
    const list = this.storage.getDisplayList(true);
    const width = this._width;
    const height = this._height;
    const scope = createBrushScope(this._id);
    scope.animation = opts.animation;
    scope.willUpdate = opts.willUpdate;
    scope.compress = opts.compress;
    scope.emphasis = opts.emphasis;
    scope.ssr = this._opts.ssr;
    const children = [];
    const bgVNode = this._bgVNode = createBackgroundVNode(width, height, this._backgroundColor, scope);
    bgVNode && children.push(bgVNode);
    const mainVNode = !opts.compress ? this._mainVNode = createVNode("g", "main", {}, []) : null;
    this._paintList(list, scope, mainVNode ? mainVNode.children : children);
    mainVNode && children.push(mainVNode);
    const defs = map(keys(scope.defs), (id) => scope.defs[id]);
    if (defs.length) {
      children.push(createVNode("defs", "defs", {}, defs));
    }
    if (opts.animation) {
      const animationCssStr = getCssString(scope.cssNodes, scope.cssAnims, {newline: true});
      if (animationCssStr) {
        const styleNode = createVNode("style", "stl", {}, [], animationCssStr);
        children.push(styleNode);
      }
    }
    return createSVGVNode(width, height, children, opts.useViewBox);
  }
  renderToString(opts) {
    opts = opts || {};
    return vNodeToString(this.renderToVNode({
      animation: retrieve2(opts.cssAnimation, true),
      emphasis: retrieve2(opts.cssEmphasis, true),
      willUpdate: false,
      compress: true,
      useViewBox: retrieve2(opts.useViewBox, true)
    }), {newline: true});
  }
  setBackgroundColor(backgroundColor2) {
    this._backgroundColor = backgroundColor2;
  }
  getSvgRoot() {
    return this._mainVNode && this._mainVNode.elm;
  }
  _paintList(list, scope, out2) {
    const listLen = list.length;
    const clipPathsGroupsStack = [];
    let clipPathsGroupsStackDepth = 0;
    let currentClipPathGroup;
    let prevClipPaths;
    let clipGroupNodeIdx = 0;
    for (let i = 0; i < listLen; i++) {
      const displayable = list[i];
      if (!displayable.invisible) {
        const clipPaths = displayable.__clipPaths;
        const len2 = clipPaths && clipPaths.length || 0;
        const prevLen = prevClipPaths && prevClipPaths.length || 0;
        let lca;
        for (lca = Math.max(len2 - 1, prevLen - 1); lca >= 0; lca--) {
          if (clipPaths && prevClipPaths && clipPaths[lca] === prevClipPaths[lca]) {
            break;
          }
        }
        for (let i2 = prevLen - 1; i2 > lca; i2--) {
          clipPathsGroupsStackDepth--;
          currentClipPathGroup = clipPathsGroupsStack[clipPathsGroupsStackDepth - 1];
        }
        for (let i2 = lca + 1; i2 < len2; i2++) {
          const groupAttrs = {};
          setClipPath(clipPaths[i2], groupAttrs, scope);
          const g = createVNode("g", "clip-g-" + clipGroupNodeIdx++, groupAttrs, []);
          (currentClipPathGroup ? currentClipPathGroup.children : out2).push(g);
          clipPathsGroupsStack[clipPathsGroupsStackDepth++] = g;
          currentClipPathGroup = g;
        }
        prevClipPaths = clipPaths;
        const ret = brush2(displayable, scope);
        if (ret) {
          (currentClipPathGroup ? currentClipPathGroup.children : out2).push(ret);
        }
      }
    }
  }
  resize(width, height) {
    const opts = this._opts;
    const root = this.root;
    const viewport = this._viewport;
    width != null && (opts.width = width);
    height != null && (opts.height = height);
    if (root && viewport) {
      viewport.style.display = "none";
      width = getSize(root, 0, opts);
      height = getSize(root, 1, opts);
      viewport.style.display = "";
    }
    if (this._width !== width || this._height !== height) {
      this._width = width;
      this._height = height;
      if (viewport) {
        const viewportStyle = viewport.style;
        viewportStyle.width = width + "px";
        viewportStyle.height = height + "px";
      }
      if (!isPattern(this._backgroundColor)) {
        const svgDom = this._svgDom;
        if (svgDom) {
          svgDom.setAttribute("width", width);
          svgDom.setAttribute("height", height);
        }
        const bgEl = this._bgVNode && this._bgVNode.elm;
        if (bgEl) {
          bgEl.setAttribute("width", width);
          bgEl.setAttribute("height", height);
        }
      } else {
        this.refresh();
      }
    }
  }
  getWidth() {
    return this._width;
  }
  getHeight() {
    return this._height;
  }
  dispose() {
    if (this.root) {
      this.root.innerHTML = "";
    }
    this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
  }
  clear() {
    if (this._svgDom) {
      this._svgDom.innerHTML = null;
    }
    this._oldVNode = null;
  }
  toDataURL(base64) {
    let str = this.renderToString();
    const prefix = "data:image/svg+xml;";
    if (base64) {
      str = encodeBase64(str);
      return str && prefix + "base64," + str;
    }
    return prefix + "charset=UTF-8," + encodeURIComponent(str);
  }
};
function createMethodNotSupport(method) {
  return function() {
    if (true) {
      logError('In SVG mode painter not support method "' + method + '"');
    }
  };
}
function createBackgroundVNode(width, height, backgroundColor2, scope) {
  let bgVNode;
  if (backgroundColor2 && backgroundColor2 !== "none") {
    bgVNode = createVNode("rect", "bg", {
      width,
      height,
      x: "0",
      y: "0"
    });
    if (isGradient(backgroundColor2)) {
      setGradient({fill: backgroundColor2}, bgVNode.attrs, "fill", scope);
    } else if (isPattern(backgroundColor2)) {
      setPattern({
        style: {
          fill: backgroundColor2
        },
        dirty: noop,
        getBoundingRect: () => ({width, height})
      }, bgVNode.attrs, "fill", scope);
    } else {
      const {color: color4, opacity} = normalizeColor(backgroundColor2);
      bgVNode.attrs.fill = color4;
      opacity < 1 && (bgVNode.attrs["fill-opacity"] = opacity);
    }
  }
  return bgVNode;
}
var Painter_default = SVGPainter;

// src/renderer/installSVGRenderer.ts
function install(registers) {
  registers.registerPainter("svg", Painter_default);
}

// ../zrender/src/canvas/Layer.ts
function createDom(id, painter, dpr2) {
  const newDom = platformApi.createCanvas();
  const width = painter.getWidth();
  const height = painter.getHeight();
  const newDomStyle = newDom.style;
  if (newDomStyle) {
    newDomStyle.position = "absolute";
    newDomStyle.left = "0";
    newDomStyle.top = "0";
    newDomStyle.width = width + "px";
    newDomStyle.height = height + "px";
    newDom.setAttribute("data-zr-dom-id", id);
  }
  newDom.width = width * dpr2;
  newDom.height = height * dpr2;
  return newDom;
}
var Layer = class extends Eventful_default {
  constructor(id, painter, dpr2) {
    super();
    this.motionBlur = false;
    this.lastFrameAlpha = 0.7;
    this.dpr = 1;
    this.virtual = false;
    this.config = {};
    this.incremental = false;
    this.zlevel = 0;
    this.maxRepaintRectCount = 5;
    this.__dirty = true;
    this.__firstTimePaint = true;
    this.__used = false;
    this.__drawIndex = 0;
    this.__startIndex = 0;
    this.__endIndex = 0;
    this.__prevStartIndex = null;
    this.__prevEndIndex = null;
    let dom;
    dpr2 = dpr2 || devicePixelRatio;
    if (typeof id === "string") {
      dom = createDom(id, painter, dpr2);
    } else if (isObject(id)) {
      dom = id;
      id = dom.id;
    }
    this.id = id;
    this.dom = dom;
    const domStyle = dom.style;
    if (domStyle) {
      disableUserSelect(dom);
      dom.onselectstart = () => false;
      domStyle.padding = "0";
      domStyle.margin = "0";
      domStyle.borderWidth = "0";
    }
    this.painter = painter;
    this.dpr = dpr2;
  }
  getElementCount() {
    return this.__endIndex - this.__startIndex;
  }
  afterBrush() {
    this.__prevStartIndex = this.__startIndex;
    this.__prevEndIndex = this.__endIndex;
  }
  initContext() {
    this.ctx = this.dom.getContext("2d");
    this.ctx.dpr = this.dpr;
  }
  setUnpainted() {
    this.__firstTimePaint = true;
  }
  createBackBuffer() {
    const dpr2 = this.dpr;
    this.domBack = createDom("back-" + this.id, this.painter, dpr2);
    this.ctxBack = this.domBack.getContext("2d");
    if (dpr2 !== 1) {
      this.ctxBack.scale(dpr2, dpr2);
    }
  }
  createRepaintRects(displayList, prevList, viewWidth, viewHeight) {
    if (this.__firstTimePaint) {
      this.__firstTimePaint = false;
      return null;
    }
    const mergedRepaintRects = [];
    const maxRepaintRectCount = this.maxRepaintRectCount;
    let full = false;
    const pendingRect = new BoundingRect_default(0, 0, 0, 0);
    function addRectToMergePool(rect) {
      if (!rect.isFinite() || rect.isZero()) {
        return;
      }
      if (mergedRepaintRects.length === 0) {
        const boundingRect = new BoundingRect_default(0, 0, 0, 0);
        boundingRect.copy(rect);
        mergedRepaintRects.push(boundingRect);
      } else {
        let isMerged = false;
        let minDeltaArea = Infinity;
        let bestRectToMergeIdx = 0;
        for (let i = 0; i < mergedRepaintRects.length; ++i) {
          const mergedRect = mergedRepaintRects[i];
          if (mergedRect.intersect(rect)) {
            const pendingRect2 = new BoundingRect_default(0, 0, 0, 0);
            pendingRect2.copy(mergedRect);
            pendingRect2.union(rect);
            mergedRepaintRects[i] = pendingRect2;
            isMerged = true;
            break;
          } else if (full) {
            pendingRect.copy(rect);
            pendingRect.union(mergedRect);
            const aArea = rect.width * rect.height;
            const bArea = mergedRect.width * mergedRect.height;
            const pendingArea = pendingRect.width * pendingRect.height;
            const deltaArea = pendingArea - aArea - bArea;
            if (deltaArea < minDeltaArea) {
              minDeltaArea = deltaArea;
              bestRectToMergeIdx = i;
            }
          }
        }
        if (full) {
          mergedRepaintRects[bestRectToMergeIdx].union(rect);
          isMerged = true;
        }
        if (!isMerged) {
          const boundingRect = new BoundingRect_default(0, 0, 0, 0);
          boundingRect.copy(rect);
          mergedRepaintRects.push(boundingRect);
        }
        if (!full) {
          full = mergedRepaintRects.length >= maxRepaintRectCount;
        }
      }
    }
    for (let i = this.__startIndex; i < this.__endIndex; ++i) {
      const el = displayList[i];
      if (el) {
        const shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true);
        const prevRect = el.__isRendered && (el.__dirty & REDRAW_BIT || !shouldPaint) ? el.getPrevPaintRect() : null;
        if (prevRect) {
          addRectToMergePool(prevRect);
        }
        const curRect = shouldPaint && (el.__dirty & REDRAW_BIT || !el.__isRendered) ? el.getPaintRect() : null;
        if (curRect) {
          addRectToMergePool(curRect);
        }
      }
    }
    for (let i = this.__prevStartIndex; i < this.__prevEndIndex; ++i) {
      const el = prevList[i];
      const shouldPaint = el && el.shouldBePainted(viewWidth, viewHeight, true, true);
      if (el && (!shouldPaint || !el.__zr) && el.__isRendered) {
        const prevRect = el.getPrevPaintRect();
        if (prevRect) {
          addRectToMergePool(prevRect);
        }
      }
    }
    let hasIntersections;
    do {
      hasIntersections = false;
      for (let i = 0; i < mergedRepaintRects.length; ) {
        if (mergedRepaintRects[i].isZero()) {
          mergedRepaintRects.splice(i, 1);
          continue;
        }
        for (let j = i + 1; j < mergedRepaintRects.length; ) {
          if (mergedRepaintRects[i].intersect(mergedRepaintRects[j])) {
            hasIntersections = true;
            mergedRepaintRects[i].union(mergedRepaintRects[j]);
            mergedRepaintRects.splice(j, 1);
          } else {
            j++;
          }
        }
        i++;
      }
    } while (hasIntersections);
    this._paintRects = mergedRepaintRects;
    return mergedRepaintRects;
  }
  debugGetPaintRects() {
    return (this._paintRects || []).slice();
  }
  resize(width, height) {
    const dpr2 = this.dpr;
    const dom = this.dom;
    const domStyle = dom.style;
    const domBack = this.domBack;
    if (domStyle) {
      domStyle.width = width + "px";
      domStyle.height = height + "px";
    }
    dom.width = width * dpr2;
    dom.height = height * dpr2;
    if (domBack) {
      domBack.width = width * dpr2;
      domBack.height = height * dpr2;
      if (dpr2 !== 1) {
        this.ctxBack.scale(dpr2, dpr2);
      }
    }
  }
  clear(clearAll, clearColor, repaintRects) {
    const dom = this.dom;
    const ctx = this.ctx;
    const width = dom.width;
    const height = dom.height;
    clearColor = clearColor || this.clearColor;
    const haveMotionBLur = this.motionBlur && !clearAll;
    const lastFrameAlpha = this.lastFrameAlpha;
    const dpr2 = this.dpr;
    const self2 = this;
    if (haveMotionBLur) {
      if (!this.domBack) {
        this.createBackBuffer();
      }
      this.ctxBack.globalCompositeOperation = "copy";
      this.ctxBack.drawImage(dom, 0, 0, width / dpr2, height / dpr2);
    }
    const domBack = this.domBack;
    function doClear(x, y, width2, height2) {
      ctx.clearRect(x, y, width2, height2);
      if (clearColor && clearColor !== "transparent") {
        let clearColorGradientOrPattern;
        if (isGradientObject(clearColor)) {
          const shouldCache = clearColor.global || clearColor.__width === width2 && clearColor.__height === height2;
          clearColorGradientOrPattern = shouldCache && clearColor.__canvasGradient || getCanvasGradient(ctx, clearColor, {
            x: 0,
            y: 0,
            width: width2,
            height: height2
          });
          clearColor.__canvasGradient = clearColorGradientOrPattern;
          clearColor.__width = width2;
          clearColor.__height = height2;
        } else if (isImagePatternObject(clearColor)) {
          clearColor.scaleX = clearColor.scaleX || dpr2;
          clearColor.scaleY = clearColor.scaleY || dpr2;
          clearColorGradientOrPattern = createCanvasPattern(ctx, clearColor, {
            dirty() {
              self2.setUnpainted();
              self2.painter.refresh();
            }
          });
        }
        ctx.save();
        ctx.fillStyle = clearColorGradientOrPattern || clearColor;
        ctx.fillRect(x, y, width2, height2);
        ctx.restore();
      }
      if (haveMotionBLur) {
        ctx.save();
        ctx.globalAlpha = lastFrameAlpha;
        ctx.drawImage(domBack, x, y, width2, height2);
        ctx.restore();
      }
    }
    ;
    if (!repaintRects || haveMotionBLur) {
      doClear(0, 0, width, height);
    } else if (repaintRects.length) {
      each(repaintRects, (rect) => {
        doClear(rect.x * dpr2, rect.y * dpr2, rect.width * dpr2, rect.height * dpr2);
      });
    }
  }
};
var Layer_default = Layer;

// ../zrender/src/canvas/Painter.ts
var HOVER_LAYER_ZLEVEL = 1e5;
var CANVAS_ZLEVEL = 314159;
var EL_AFTER_INCREMENTAL_INC = 0.01;
var INCREMENTAL_INC = 1e-3;
function isLayerValid(layer) {
  if (!layer) {
    return false;
  }
  if (layer.__builtin__) {
    return true;
  }
  if (typeof layer.resize !== "function" || typeof layer.refresh !== "function") {
    return false;
  }
  return true;
}
function createRoot(width, height) {
  const domRoot = document.createElement("div");
  domRoot.style.cssText = [
    "position:relative",
    "width:" + width + "px",
    "height:" + height + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";";
  return domRoot;
}
var CanvasPainter = class {
  constructor(root, storage2, opts, id) {
    this.type = "canvas";
    this._zlevelList = [];
    this._prevDisplayList = [];
    this._layers = {};
    this._layerConfig = {};
    this._needsManuallyCompositing = false;
    this.type = "canvas";
    const singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === "CANVAS";
    this._opts = opts = extend({}, opts || {});
    this.dpr = opts.devicePixelRatio || devicePixelRatio;
    this._singleCanvas = singleCanvas;
    this.root = root;
    const rootStyle = root.style;
    if (rootStyle) {
      disableUserSelect(root);
      root.innerHTML = "";
    }
    this.storage = storage2;
    const zlevelList = this._zlevelList;
    this._prevDisplayList = [];
    const layers = this._layers;
    if (!singleCanvas) {
      this._width = getSize(root, 0, opts);
      this._height = getSize(root, 1, opts);
      const domRoot = this._domRoot = createRoot(this._width, this._height);
      root.appendChild(domRoot);
    } else {
      const rootCanvas = root;
      let width = rootCanvas.width;
      let height = rootCanvas.height;
      if (opts.width != null) {
        width = opts.width;
      }
      if (opts.height != null) {
        height = opts.height;
      }
      this.dpr = opts.devicePixelRatio || 1;
      rootCanvas.width = width * this.dpr;
      rootCanvas.height = height * this.dpr;
      this._width = width;
      this._height = height;
      const mainLayer = new Layer_default(rootCanvas, this, this.dpr);
      mainLayer.__builtin__ = true;
      mainLayer.initContext();
      layers[CANVAS_ZLEVEL] = mainLayer;
      mainLayer.zlevel = CANVAS_ZLEVEL;
      zlevelList.push(CANVAS_ZLEVEL);
      this._domRoot = root;
    }
  }
  getType() {
    return "canvas";
  }
  isSingleCanvas() {
    return this._singleCanvas;
  }
  getViewportRoot() {
    return this._domRoot;
  }
  getViewportRootOffset() {
    const viewportRoot = this.getViewportRoot();
    if (viewportRoot) {
      return {
        offsetLeft: viewportRoot.offsetLeft || 0,
        offsetTop: viewportRoot.offsetTop || 0
      };
    }
  }
  refresh(paintAll) {
    const list = this.storage.getDisplayList(true);
    const prevList = this._prevDisplayList;
    const zlevelList = this._zlevelList;
    this._redrawId = Math.random();
    this._paintList(list, prevList, paintAll, this._redrawId);
    for (let i = 0; i < zlevelList.length; i++) {
      const z = zlevelList[i];
      const layer = this._layers[z];
      if (!layer.__builtin__ && layer.refresh) {
        const clearColor = i === 0 ? this._backgroundColor : null;
        layer.refresh(clearColor);
      }
    }
    if (this._opts.useDirtyRect) {
      this._prevDisplayList = list.slice();
    }
    return this;
  }
  refreshHover() {
    this._paintHoverList(this.storage.getDisplayList(false));
  }
  _paintHoverList(list) {
    let len2 = list.length;
    let hoverLayer = this._hoverlayer;
    hoverLayer && hoverLayer.clear();
    if (!len2) {
      return;
    }
    const scope = {
      inHover: true,
      viewWidth: this._width,
      viewHeight: this._height
    };
    let ctx;
    for (let i = 0; i < len2; i++) {
      const el = list[i];
      if (el.__inHover) {
        if (!hoverLayer) {
          hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);
        }
        if (!ctx) {
          ctx = hoverLayer.ctx;
          ctx.save();
        }
        brush(ctx, el, scope, i === len2 - 1);
      }
    }
    if (ctx) {
      ctx.restore();
    }
  }
  getHoverLayer() {
    return this.getLayer(HOVER_LAYER_ZLEVEL);
  }
  paintOne(ctx, el) {
    brushSingle(ctx, el);
  }
  _paintList(list, prevList, paintAll, redrawId) {
    if (this._redrawId !== redrawId) {
      return;
    }
    paintAll = paintAll || false;
    this._updateLayerStatus(list);
    const {finished, needsRefreshHover} = this._doPaintList(list, prevList, paintAll);
    if (this._needsManuallyCompositing) {
      this._compositeManually();
    }
    if (needsRefreshHover) {
      this._paintHoverList(list);
    }
    if (!finished) {
      const self2 = this;
      requestAnimationFrame_default(function() {
        self2._paintList(list, prevList, paintAll, redrawId);
      });
    } else {
      this.eachLayer((layer) => {
        layer.afterBrush && layer.afterBrush();
      });
    }
  }
  _compositeManually() {
    const ctx = this.getLayer(CANVAS_ZLEVEL).ctx;
    const width = this._domRoot.width;
    const height = this._domRoot.height;
    ctx.clearRect(0, 0, width, height);
    this.eachBuiltinLayer(function(layer) {
      if (layer.virtual) {
        ctx.drawImage(layer.dom, 0, 0, width, height);
      }
    });
  }
  _doPaintList(list, prevList, paintAll) {
    const layerList = [];
    const useDirtyRect = this._opts.useDirtyRect;
    for (let zi = 0; zi < this._zlevelList.length; zi++) {
      const zlevel = this._zlevelList[zi];
      const layer = this._layers[zlevel];
      if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {
        layerList.push(layer);
      }
    }
    let finished = true;
    let needsRefreshHover = false;
    for (let k = 0; k < layerList.length; k++) {
      const layer = layerList[k];
      const ctx = layer.ctx;
      const repaintRects = useDirtyRect && layer.createRepaintRects(list, prevList, this._width, this._height);
      let start2 = paintAll ? layer.__startIndex : layer.__drawIndex;
      const useTimer = !paintAll && layer.incremental && Date.now;
      const startTime = useTimer && Date.now();
      const clearColor = layer.zlevel === this._zlevelList[0] ? this._backgroundColor : null;
      if (layer.__startIndex === layer.__endIndex) {
        layer.clear(false, clearColor, repaintRects);
      } else if (start2 === layer.__startIndex) {
        const firstEl = list[start2];
        if (!firstEl.incremental || !firstEl.notClear || paintAll) {
          layer.clear(false, clearColor, repaintRects);
        }
      }
      if (start2 === -1) {
        console.error("For some unknown reason. drawIndex is -1");
        start2 = layer.__startIndex;
      }
      let i;
      const repaint = (repaintRect) => {
        const scope = {
          inHover: false,
          allClipped: false,
          prevEl: null,
          viewWidth: this._width,
          viewHeight: this._height
        };
        for (i = start2; i < layer.__endIndex; i++) {
          const el = list[i];
          if (el.__inHover) {
            needsRefreshHover = true;
          }
          this._doPaintEl(el, layer, useDirtyRect, repaintRect, scope, i === layer.__endIndex - 1);
          if (useTimer) {
            const dTime = Date.now() - startTime;
            if (dTime > 15) {
              break;
            }
          }
        }
        if (scope.prevElClipPaths) {
          ctx.restore();
        }
      };
      if (repaintRects) {
        if (repaintRects.length === 0) {
          i = layer.__endIndex;
        } else {
          const dpr2 = this.dpr;
          for (var r = 0; r < repaintRects.length; ++r) {
            const rect = repaintRects[r];
            ctx.save();
            ctx.beginPath();
            ctx.rect(rect.x * dpr2, rect.y * dpr2, rect.width * dpr2, rect.height * dpr2);
            ctx.clip();
            repaint(rect);
            ctx.restore();
          }
        }
      } else {
        ctx.save();
        repaint();
        ctx.restore();
      }
      layer.__drawIndex = i;
      if (layer.__drawIndex < layer.__endIndex) {
        finished = false;
      }
    }
    if (env_default.wxa) {
      each(this._layers, function(layer) {
        if (layer && layer.ctx && layer.ctx.draw) {
          layer.ctx.draw();
        }
      });
    }
    return {
      finished,
      needsRefreshHover
    };
  }
  _doPaintEl(el, currentLayer, useDirtyRect, repaintRect, scope, isLast) {
    const ctx = currentLayer.ctx;
    if (useDirtyRect) {
      const paintRect = el.getPaintRect();
      if (!repaintRect || paintRect && paintRect.intersect(repaintRect)) {
        brush(ctx, el, scope, isLast);
        el.setPrevPaintRect(paintRect);
      }
    } else {
      brush(ctx, el, scope, isLast);
    }
  }
  getLayer(zlevel, virtual) {
    if (this._singleCanvas && !this._needsManuallyCompositing) {
      zlevel = CANVAS_ZLEVEL;
    }
    let layer = this._layers[zlevel];
    if (!layer) {
      layer = new Layer_default("zr_" + zlevel, this, this.dpr);
      layer.zlevel = zlevel;
      layer.__builtin__ = true;
      if (this._layerConfig[zlevel]) {
        merge(layer, this._layerConfig[zlevel], true);
      } else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {
        merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);
      }
      if (virtual) {
        layer.virtual = virtual;
      }
      this.insertLayer(zlevel, layer);
      layer.initContext();
    }
    return layer;
  }
  insertLayer(zlevel, layer) {
    const layersMap = this._layers;
    const zlevelList = this._zlevelList;
    const len2 = zlevelList.length;
    const domRoot = this._domRoot;
    let prevLayer = null;
    let i = -1;
    if (layersMap[zlevel]) {
      if (true) {
        logError("ZLevel " + zlevel + " has been used already");
      }
      return;
    }
    if (!isLayerValid(layer)) {
      if (true) {
        logError("Layer of zlevel " + zlevel + " is not valid");
      }
      return;
    }
    if (len2 > 0 && zlevel > zlevelList[0]) {
      for (i = 0; i < len2 - 1; i++) {
        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
          break;
        }
      }
      prevLayer = layersMap[zlevelList[i]];
    }
    zlevelList.splice(i + 1, 0, zlevel);
    layersMap[zlevel] = layer;
    if (!layer.virtual) {
      if (prevLayer) {
        const prevDom = prevLayer.dom;
        if (prevDom.nextSibling) {
          domRoot.insertBefore(layer.dom, prevDom.nextSibling);
        } else {
          domRoot.appendChild(layer.dom);
        }
      } else {
        if (domRoot.firstChild) {
          domRoot.insertBefore(layer.dom, domRoot.firstChild);
        } else {
          domRoot.appendChild(layer.dom);
        }
      }
    }
    layer.painter || (layer.painter = this);
  }
  eachLayer(cb, context) {
    const zlevelList = this._zlevelList;
    for (let i = 0; i < zlevelList.length; i++) {
      const z = zlevelList[i];
      cb.call(context, this._layers[z], z);
    }
  }
  eachBuiltinLayer(cb, context) {
    const zlevelList = this._zlevelList;
    for (let i = 0; i < zlevelList.length; i++) {
      const z = zlevelList[i];
      const layer = this._layers[z];
      if (layer.__builtin__) {
        cb.call(context, layer, z);
      }
    }
  }
  eachOtherLayer(cb, context) {
    const zlevelList = this._zlevelList;
    for (let i = 0; i < zlevelList.length; i++) {
      const z = zlevelList[i];
      const layer = this._layers[z];
      if (!layer.__builtin__) {
        cb.call(context, layer, z);
      }
    }
  }
  getLayers() {
    return this._layers;
  }
  _updateLayerStatus(list) {
    this.eachBuiltinLayer(function(layer, z) {
      layer.__dirty = layer.__used = false;
    });
    function updatePrevLayer(idx) {
      if (prevLayer) {
        if (prevLayer.__endIndex !== idx) {
          prevLayer.__dirty = true;
        }
        prevLayer.__endIndex = idx;
      }
    }
    if (this._singleCanvas) {
      for (let i2 = 1; i2 < list.length; i2++) {
        const el = list[i2];
        if (el.zlevel !== list[i2 - 1].zlevel || el.incremental) {
          this._needsManuallyCompositing = true;
          break;
        }
      }
    }
    let prevLayer = null;
    let incrementalLayerCount = 0;
    let prevZlevel;
    let i;
    for (i = 0; i < list.length; i++) {
      const el = list[i];
      const zlevel = el.zlevel;
      let layer;
      if (prevZlevel !== zlevel) {
        prevZlevel = zlevel;
        incrementalLayerCount = 0;
      }
      if (el.incremental) {
        layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);
        layer.incremental = true;
        incrementalLayerCount = 1;
      } else {
        layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);
      }
      if (!layer.__builtin__) {
        logError("ZLevel " + zlevel + " has been used by unkown layer " + layer.id);
      }
      if (layer !== prevLayer) {
        layer.__used = true;
        if (layer.__startIndex !== i) {
          layer.__dirty = true;
        }
        layer.__startIndex = i;
        if (!layer.incremental) {
          layer.__drawIndex = i;
        } else {
          layer.__drawIndex = -1;
        }
        updatePrevLayer(i);
        prevLayer = layer;
      }
      if (el.__dirty & REDRAW_BIT && !el.__inHover) {
        layer.__dirty = true;
        if (layer.incremental && layer.__drawIndex < 0) {
          layer.__drawIndex = i;
        }
      }
    }
    updatePrevLayer(i);
    this.eachBuiltinLayer(function(layer, z) {
      if (!layer.__used && layer.getElementCount() > 0) {
        layer.__dirty = true;
        layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0;
      }
      if (layer.__dirty && layer.__drawIndex < 0) {
        layer.__drawIndex = layer.__startIndex;
      }
    });
  }
  clear() {
    this.eachBuiltinLayer(this._clearLayer);
    return this;
  }
  _clearLayer(layer) {
    layer.clear();
  }
  setBackgroundColor(backgroundColor2) {
    this._backgroundColor = backgroundColor2;
    each(this._layers, (layer) => {
      layer.setUnpainted();
    });
  }
  configLayer(zlevel, config) {
    if (config) {
      const layerConfig = this._layerConfig;
      if (!layerConfig[zlevel]) {
        layerConfig[zlevel] = config;
      } else {
        merge(layerConfig[zlevel], config, true);
      }
      for (let i = 0; i < this._zlevelList.length; i++) {
        const _zlevel = this._zlevelList[i];
        if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {
          const layer = this._layers[_zlevel];
          merge(layer, layerConfig[zlevel], true);
        }
      }
    }
  }
  delLayer(zlevel) {
    const layers = this._layers;
    const zlevelList = this._zlevelList;
    const layer = layers[zlevel];
    if (!layer) {
      return;
    }
    layer.dom.parentNode.removeChild(layer.dom);
    delete layers[zlevel];
    zlevelList.splice(indexOf(zlevelList, zlevel), 1);
  }
  resize(width, height) {
    if (!this._domRoot.style) {
      if (width == null || height == null) {
        return;
      }
      this._width = width;
      this._height = height;
      this.getLayer(CANVAS_ZLEVEL).resize(width, height);
    } else {
      const domRoot = this._domRoot;
      domRoot.style.display = "none";
      const opts = this._opts;
      const root = this.root;
      width != null && (opts.width = width);
      height != null && (opts.height = height);
      width = getSize(root, 0, opts);
      height = getSize(root, 1, opts);
      domRoot.style.display = "";
      if (this._width !== width || height !== this._height) {
        domRoot.style.width = width + "px";
        domRoot.style.height = height + "px";
        for (let id in this._layers) {
          if (this._layers.hasOwnProperty(id)) {
            this._layers[id].resize(width, height);
          }
        }
        this.refresh(true);
      }
      this._width = width;
      this._height = height;
    }
    return this;
  }
  clearLayer(zlevel) {
    const layer = this._layers[zlevel];
    if (layer) {
      layer.clear();
    }
  }
  dispose() {
    this.root.innerHTML = "";
    this.root = this.storage = this._domRoot = this._layers = null;
  }
  getRenderedCanvas(opts) {
    opts = opts || {};
    if (this._singleCanvas && !this._compositeManually) {
      return this._layers[CANVAS_ZLEVEL].dom;
    }
    const imageLayer = new Layer_default("image", this, opts.pixelRatio || this.dpr);
    imageLayer.initContext();
    imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);
    const ctx = imageLayer.ctx;
    if (opts.pixelRatio <= this.dpr) {
      this.refresh();
      const width = imageLayer.dom.width;
      const height = imageLayer.dom.height;
      this.eachLayer(function(layer) {
        if (layer.__builtin__) {
          ctx.drawImage(layer.dom, 0, 0, width, height);
        } else if (layer.renderToCanvas) {
          ctx.save();
          layer.renderToCanvas(ctx);
          ctx.restore();
        }
      });
    } else {
      const scope = {
        inHover: false,
        viewWidth: this._width,
        viewHeight: this._height
      };
      const displayList = this.storage.getDisplayList(true);
      for (let i = 0, len2 = displayList.length; i < len2; i++) {
        const el = displayList[i];
        brush(ctx, el, scope, i === len2 - 1);
      }
    }
    return imageLayer.dom;
  }
  getWidth() {
    return this._width;
  }
  getHeight() {
    return this._height;
  }
};
var Painter_default2 = CanvasPainter;

// src/renderer/installCanvasRenderer.ts
function install2(registers) {
  registers.registerPainter("canvas", Painter_default2);
}

// src/chart/line/LineSeries.ts
var LineSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = LineSeriesModel2.type;
    this.hasSymbolVisual = true;
  }
  getInitialData(option) {
    if (true) {
      const coordSys = option.coordinateSystem;
      if (coordSys !== "polar" && coordSys !== "cartesian2d") {
        throw new Error("Line not support coordinateSystem besides cartesian and polar");
      }
    }
    return createSeriesData_default(null, this, {
      useEncodeDefaulter: true
    });
  }
  getLegendIcon(opt) {
    const group = new Group_default();
    const line2 = createSymbol("line", 0, opt.itemHeight / 2, opt.itemWidth, 0, opt.lineStyle.stroke, false);
    group.add(line2);
    line2.setStyle(opt.lineStyle);
    const visualType = this.getData().getVisual("symbol");
    const visualRotate = this.getData().getVisual("symbolRotate");
    const symbolType = visualType === "none" ? "circle" : visualType;
    const size = opt.itemHeight * 0.8;
    const symbol = createSymbol(symbolType, (opt.itemWidth - size) / 2, (opt.itemHeight - size) / 2, size, size, opt.itemStyle.fill);
    group.add(symbol);
    symbol.setStyle(opt.itemStyle);
    const symbolRotate = opt.iconRotate === "inherit" ? visualRotate : opt.iconRotate || 0;
    symbol.rotation = symbolRotate * Math.PI / 180;
    symbol.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);
    if (symbolType.indexOf("empty") > -1) {
      symbol.style.stroke = symbol.style.fill;
      symbol.style.fill = tokens_default.color.neutral00;
      symbol.style.lineWidth = 2;
    }
    return group;
  }
};
var LineSeriesModel = LineSeriesModel2;
LineSeriesModel.type = "series.line";
LineSeriesModel.dependencies = ["grid", "polar"];
LineSeriesModel.defaultOption = {
  z: 3,
  coordinateSystem: "cartesian2d",
  legendHoverLink: true,
  clip: true,
  label: {
    position: "top"
  },
  endLabel: {
    show: false,
    valueAnimation: true,
    distance: 8
  },
  lineStyle: {
    width: 2,
    type: "solid"
  },
  emphasis: {
    scale: true
  },
  step: false,
  smooth: false,
  smoothMonotone: null,
  symbol: "emptyCircle",
  symbolSize: 6,
  symbolRotate: null,
  showSymbol: true,
  showAllSymbol: "auto",
  connectNulls: false,
  sampling: "none",
  animationEasing: "linear",
  progressive: 0,
  hoverLayerThreshold: Infinity,
  universalTransition: {
    divideShape: "clone"
  },
  triggerLineEvent: false
};
var LineSeries_default = LineSeriesModel;

// src/chart/helper/labelHelper.ts
function getDefaultLabel(data, dataIndex) {
  const labelDims = data.mapDimensionsAll("defaultedLabel");
  const len2 = labelDims.length;
  if (len2 === 1) {
    const rawVal = retrieveRawValue(data, dataIndex, labelDims[0]);
    return rawVal != null ? rawVal + "" : null;
  } else if (len2) {
    const vals = [];
    for (let i = 0; i < labelDims.length; i++) {
      vals.push(retrieveRawValue(data, dataIndex, labelDims[i]));
    }
    return vals.join(" ");
  }
}
function getDefaultInterpolatedLabel(data, interpolatedValue) {
  const labelDims = data.mapDimensionsAll("defaultedLabel");
  if (!isArray(interpolatedValue)) {
    return interpolatedValue + "";
  }
  const vals = [];
  for (let i = 0; i < labelDims.length; i++) {
    const dimIndex = data.getDimensionIndex(labelDims[i]);
    if (dimIndex >= 0) {
      vals.push(interpolatedValue[dimIndex]);
    }
  }
  return vals.join(" ");
}

// src/chart/helper/Symbol.ts
var Symbol = class extends Group_default {
  constructor(data, idx, seriesScope, opts) {
    super();
    this.updateData(data, idx, seriesScope, opts);
  }
  _createSymbol(symbolType, data, idx, symbolSize, z2, keepAspect) {
    this.removeAll();
    const symbolPath = createSymbol(symbolType, -1, -1, 2, 2, null, keepAspect);
    symbolPath.attr({
      z2: retrieve2(z2, 100),
      culling: true,
      scaleX: symbolSize[0] / 2,
      scaleY: symbolSize[1] / 2
    });
    symbolPath.drift = driftSymbol;
    this._symbolType = symbolType;
    this.add(symbolPath);
  }
  stopSymbolAnimation(toLastFrame) {
    this.childAt(0).stopAnimation(null, toLastFrame);
  }
  getSymbolType() {
    return this._symbolType;
  }
  getSymbolPath() {
    return this.childAt(0);
  }
  highlight() {
    enterEmphasis(this.childAt(0));
  }
  downplay() {
    leaveEmphasis(this.childAt(0));
  }
  setZ(zlevel, z) {
    const symbolPath = this.childAt(0);
    symbolPath.zlevel = zlevel;
    symbolPath.z = z;
  }
  setDraggable(draggable, hasCursorOption) {
    const symbolPath = this.childAt(0);
    symbolPath.draggable = draggable;
    symbolPath.cursor = !hasCursorOption && draggable ? "move" : symbolPath.cursor;
  }
  updateData(data, idx, seriesScope, opts) {
    this.silent = false;
    const symbolType = data.getItemVisual(idx, "symbol") || "circle";
    const seriesModel = data.hostModel;
    const symbolSize = Symbol.getSymbolSize(data, idx);
    const z2 = Symbol.getSymbolZ2(data, idx);
    const isInit = symbolType !== this._symbolType;
    const disableAnimation = opts && opts.disableAnimation;
    if (isInit) {
      const keepAspect = data.getItemVisual(idx, "symbolKeepAspect");
      this._createSymbol(symbolType, data, idx, symbolSize, z2, keepAspect);
    } else {
      const symbolPath = this.childAt(0);
      symbolPath.silent = false;
      const target = {
        scaleX: symbolSize[0] / 2,
        scaleY: symbolSize[1] / 2
      };
      disableAnimation ? symbolPath.attr(target) : updateProps(symbolPath, target, seriesModel, idx);
      saveOldStyle(symbolPath);
    }
    this._updateCommon(data, idx, symbolSize, seriesScope, opts);
    if (isInit) {
      const symbolPath = this.childAt(0);
      if (!disableAnimation) {
        const target = {
          scaleX: this._sizeX,
          scaleY: this._sizeY,
          style: {
            opacity: symbolPath.style.opacity
          }
        };
        symbolPath.scaleX = symbolPath.scaleY = 0;
        symbolPath.style.opacity = 0;
        initProps(symbolPath, target, seriesModel, idx);
      }
    }
    if (disableAnimation) {
      this.childAt(0).stopAnimation("leave");
    }
  }
  _updateCommon(data, idx, symbolSize, seriesScope, opts) {
    const symbolPath = this.childAt(0);
    const seriesModel = data.hostModel;
    let emphasisItemStyle;
    let blurItemStyle;
    let selectItemStyle;
    let focus;
    let blurScope;
    let emphasisDisabled;
    let labelStatesModels;
    let hoverScale;
    let cursorStyle;
    if (seriesScope) {
      emphasisItemStyle = seriesScope.emphasisItemStyle;
      blurItemStyle = seriesScope.blurItemStyle;
      selectItemStyle = seriesScope.selectItemStyle;
      focus = seriesScope.focus;
      blurScope = seriesScope.blurScope;
      labelStatesModels = seriesScope.labelStatesModels;
      hoverScale = seriesScope.hoverScale;
      cursorStyle = seriesScope.cursorStyle;
      emphasisDisabled = seriesScope.emphasisDisabled;
    }
    if (!seriesScope || data.hasItemOption) {
      const itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx);
      const emphasisModel = itemModel.getModel("emphasis");
      emphasisItemStyle = emphasisModel.getModel("itemStyle").getItemStyle();
      selectItemStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
      blurItemStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
      focus = emphasisModel.get("focus");
      blurScope = emphasisModel.get("blurScope");
      emphasisDisabled = emphasisModel.get("disabled");
      labelStatesModels = getLabelStatesModels(itemModel);
      hoverScale = emphasisModel.getShallow("scale");
      cursorStyle = itemModel.getShallow("cursor");
    }
    const symbolRotate = data.getItemVisual(idx, "symbolRotate");
    symbolPath.attr("rotation", (symbolRotate || 0) * Math.PI / 180 || 0);
    const symbolOffset = normalizeSymbolOffset(data.getItemVisual(idx, "symbolOffset"), symbolSize);
    if (symbolOffset) {
      symbolPath.x = symbolOffset[0];
      symbolPath.y = symbolOffset[1];
    }
    cursorStyle && symbolPath.attr("cursor", cursorStyle);
    const symbolStyle = data.getItemVisual(idx, "style");
    const visualColor = symbolStyle.fill;
    if (symbolPath instanceof Image_default) {
      const pathStyle = symbolPath.style;
      symbolPath.useStyle(extend({
        image: pathStyle.image,
        x: pathStyle.x,
        y: pathStyle.y,
        width: pathStyle.width,
        height: pathStyle.height
      }, symbolStyle));
    } else {
      if (symbolPath.__isEmptyBrush) {
        symbolPath.useStyle(extend({}, symbolStyle));
      } else {
        symbolPath.useStyle(symbolStyle);
      }
      symbolPath.style.decal = null;
      symbolPath.setColor(visualColor, opts && opts.symbolInnerColor);
      symbolPath.style.strokeNoScale = true;
    }
    const liftZ = data.getItemVisual(idx, "liftZ");
    const z2Origin = this._z2;
    if (liftZ != null) {
      if (z2Origin == null) {
        this._z2 = symbolPath.z2;
        symbolPath.z2 += liftZ;
      }
    } else if (z2Origin != null) {
      symbolPath.z2 = z2Origin;
      this._z2 = null;
    }
    const useNameLabel = opts && opts.useNameLabel;
    setLabelStyle(symbolPath, labelStatesModels, {
      labelFetcher: seriesModel,
      labelDataIndex: idx,
      defaultText: getLabelDefaultText,
      inheritColor: visualColor,
      defaultOpacity: symbolStyle.opacity
    });
    function getLabelDefaultText(idx2) {
      return useNameLabel ? data.getName(idx2) : getDefaultLabel(data, idx2);
    }
    this._sizeX = symbolSize[0] / 2;
    this._sizeY = symbolSize[1] / 2;
    const emphasisState = symbolPath.ensureState("emphasis");
    emphasisState.style = emphasisItemStyle;
    symbolPath.ensureState("select").style = selectItemStyle;
    symbolPath.ensureState("blur").style = blurItemStyle;
    const scaleRatio = hoverScale == null || hoverScale === true ? Math.max(1.1, 3 / this._sizeY) : isFinite(hoverScale) && hoverScale > 0 ? +hoverScale : 1;
    emphasisState.scaleX = this._sizeX * scaleRatio;
    emphasisState.scaleY = this._sizeY * scaleRatio;
    this.setSymbolScale(1);
    toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
  }
  setSymbolScale(scale4) {
    this.scaleX = this.scaleY = scale4;
  }
  fadeOut(cb, seriesModel, opt) {
    const symbolPath = this.childAt(0);
    const dataIndex = getECData(this).dataIndex;
    const animationOpt = opt && opt.animation;
    this.silent = symbolPath.silent = true;
    if (opt && opt.fadeLabel) {
      const textContent = symbolPath.getTextContent();
      if (textContent) {
        removeElement(textContent, {
          style: {
            opacity: 0
          }
        }, seriesModel, {
          dataIndex,
          removeOpt: animationOpt,
          cb() {
            symbolPath.removeTextContent();
          }
        });
      }
    } else {
      symbolPath.removeTextContent();
    }
    removeElement(symbolPath, {
      style: {
        opacity: 0
      },
      scaleX: 0,
      scaleY: 0
    }, seriesModel, {dataIndex, cb, removeOpt: animationOpt});
  }
  static getSymbolSize(data, idx) {
    return normalizeSymbolSize(data.getItemVisual(idx, "symbolSize"));
  }
  static getSymbolZ2(data, idx) {
    return data.getItemVisual(idx, "z2");
  }
};
function driftSymbol(dx, dy) {
  this.parent.drift(dx, dy);
}
var Symbol_default = Symbol;

// src/chart/helper/SymbolDraw.ts
function symbolNeedsDraw(data, point, idx, opt) {
  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, "symbol") !== "none";
}
function normalizeUpdateOpt(opt) {
  if (opt != null && !isObject(opt)) {
    opt = {isIgnore: opt};
  }
  return opt || {};
}
function makeSeriesScope(data) {
  const seriesModel = data.hostModel;
  const emphasisModel = seriesModel.getModel("emphasis");
  return {
    emphasisItemStyle: emphasisModel.getModel("itemStyle").getItemStyle(),
    blurItemStyle: seriesModel.getModel(["blur", "itemStyle"]).getItemStyle(),
    selectItemStyle: seriesModel.getModel(["select", "itemStyle"]).getItemStyle(),
    focus: emphasisModel.get("focus"),
    blurScope: emphasisModel.get("blurScope"),
    emphasisDisabled: emphasisModel.get("disabled"),
    hoverScale: emphasisModel.get("scale"),
    labelStatesModels: getLabelStatesModels(seriesModel),
    cursorStyle: seriesModel.get("cursor")
  };
}
var SymbolDraw = class {
  constructor(SymbolCtor) {
    this.group = new Group_default();
    this._SymbolCtor = SymbolCtor || Symbol_default;
  }
  updateData(data, opt) {
    this._progressiveEls = null;
    opt = normalizeUpdateOpt(opt);
    const group = this.group;
    const seriesModel = data.hostModel;
    const oldData = this._data;
    const SymbolCtor = this._SymbolCtor;
    const disableAnimation = opt.disableAnimation;
    const seriesScope = makeSeriesScope(data);
    const symbolUpdateOpt = {disableAnimation};
    const getSymbolPoint = opt.getSymbolPoint || function(idx) {
      return data.getItemLayout(idx);
    };
    if (!oldData) {
      group.removeAll();
    }
    data.diff(oldData).add(function(newIdx) {
      const point = getSymbolPoint(newIdx);
      if (symbolNeedsDraw(data, point, newIdx, opt)) {
        const symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
        symbolEl.setPosition(point);
        data.setItemGraphicEl(newIdx, symbolEl);
        group.add(symbolEl);
      }
    }).update(function(newIdx, oldIdx) {
      let symbolEl = oldData.getItemGraphicEl(oldIdx);
      const point = getSymbolPoint(newIdx);
      if (!symbolNeedsDraw(data, point, newIdx, opt)) {
        group.remove(symbolEl);
        return;
      }
      const newSymbolType = data.getItemVisual(newIdx, "symbol") || "circle";
      const oldSymbolType = symbolEl && symbolEl.getSymbolType && symbolEl.getSymbolType();
      if (!symbolEl || oldSymbolType && oldSymbolType !== newSymbolType) {
        group.remove(symbolEl);
        symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
        symbolEl.setPosition(point);
      } else {
        symbolEl.updateData(data, newIdx, seriesScope, symbolUpdateOpt);
        const target = {
          x: point[0],
          y: point[1]
        };
        disableAnimation ? symbolEl.attr(target) : updateProps(symbolEl, target, seriesModel);
      }
      group.add(symbolEl);
      data.setItemGraphicEl(newIdx, symbolEl);
    }).remove(function(oldIdx) {
      const el = oldData.getItemGraphicEl(oldIdx);
      el && el.fadeOut(function() {
        group.remove(el);
      }, seriesModel);
    }).execute();
    this._getSymbolPoint = getSymbolPoint;
    this._data = data;
  }
  updateLayout() {
    const data = this._data;
    if (data) {
      data.eachItemGraphicEl((el, idx) => {
        const point = this._getSymbolPoint(idx);
        el.setPosition(point);
        el.markRedraw();
      });
    }
  }
  incrementalPrepareUpdate(data) {
    this._seriesScope = makeSeriesScope(data);
    this._data = null;
    this.group.removeAll();
  }
  incrementalUpdate(taskParams, data, opt) {
    this._progressiveEls = [];
    opt = normalizeUpdateOpt(opt);
    function updateIncrementalAndHover(el) {
      if (!el.isGroup) {
        el.incremental = true;
        el.ensureState("emphasis").hoverLayer = true;
      }
    }
    for (let idx = taskParams.start; idx < taskParams.end; idx++) {
      const point = data.getItemLayout(idx);
      if (symbolNeedsDraw(data, point, idx, opt)) {
        const el = new this._SymbolCtor(data, idx, this._seriesScope);
        el.traverse(updateIncrementalAndHover);
        el.setPosition(point);
        this.group.add(el);
        data.setItemGraphicEl(idx, el);
        this._progressiveEls.push(el);
      }
    }
  }
  eachRendered(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  }
  remove(enableAnimation) {
    const group = this.group;
    const data = this._data;
    if (data && enableAnimation) {
      data.eachItemGraphicEl(function(el) {
        el.fadeOut(function() {
          group.remove(el);
        }, data.hostModel);
      });
    } else {
      group.removeAll();
    }
  }
};
var SymbolDraw_default = SymbolDraw;

// src/chart/line/helper.ts
function prepareDataCoordInfo(coordSys, data, valueOrigin) {
  const baseAxis = coordSys.getBaseAxis();
  const valueAxis2 = coordSys.getOtherAxis(baseAxis);
  const valueStart = getValueStart(valueAxis2, valueOrigin);
  const baseAxisDim = baseAxis.dim;
  const valueAxisDim = valueAxis2.dim;
  const valueDim = data.mapDimension(valueAxisDim);
  const baseDim = data.mapDimension(baseAxisDim);
  const baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
  const dims = map(coordSys.dimensions, function(coordDim) {
    return data.mapDimension(coordDim);
  });
  let stacked = false;
  const stackResultDim = data.getCalculationInfo("stackResultDimension");
  if (isDimensionStacked(data, dims[0])) {
    stacked = true;
    dims[0] = stackResultDim;
  }
  if (isDimensionStacked(data, dims[1])) {
    stacked = true;
    dims[1] = stackResultDim;
  }
  return {
    dataDimsForPoint: dims,
    valueStart,
    valueAxisDim,
    baseAxisDim,
    stacked: !!stacked,
    valueDim,
    baseDim,
    baseDataOffset,
    stackedOverDimension: data.getCalculationInfo("stackedOverDimension")
  };
}
function getValueStart(valueAxis2, valueOrigin) {
  let valueStart = 0;
  const extent = valueAxis2.scale.getExtent();
  if (valueOrigin === "start") {
    valueStart = extent[0];
  } else if (valueOrigin === "end") {
    valueStart = extent[1];
  } else if (isNumber(valueOrigin) && !isNaN(valueOrigin)) {
    valueStart = valueOrigin;
  } else {
    if (extent[0] > 0) {
      valueStart = extent[0];
    } else if (extent[1] < 0) {
      valueStart = extent[1];
    }
  }
  return valueStart;
}
function getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {
  let value = NaN;
  if (dataCoordInfo.stacked) {
    value = data.get(data.getCalculationInfo("stackedOverDimension"), idx);
  }
  if (isNaN(value)) {
    value = dataCoordInfo.valueStart;
  }
  const baseDataOffset = dataCoordInfo.baseDataOffset;
  const stackedData = [];
  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);
  stackedData[1 - baseDataOffset] = value;
  return coordSys.dataToPoint(stackedData);
}

// src/chart/line/lineAnimationDiff.ts
function diffData(oldData, newData) {
  const diffResult = [];
  newData.diff(oldData).add(function(idx) {
    diffResult.push({cmd: "+", idx});
  }).update(function(newIdx, oldIdx) {
    diffResult.push({cmd: "=", idx: oldIdx, idx1: newIdx});
  }).remove(function(idx) {
    diffResult.push({cmd: "-", idx});
  }).execute();
  return diffResult;
}
function lineAnimationDiff(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
  const diff = diffData(oldData, newData);
  const currPoints = [];
  const nextPoints = [];
  const currStackedPoints = [];
  const nextStackedPoints = [];
  const status = [];
  const sortedIndices = [];
  const rawIndices = [];
  const newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);
  const oldPoints = oldData.getLayout("points") || [];
  const newPoints = newData.getLayout("points") || [];
  for (let i = 0; i < diff.length; i++) {
    const diffItem = diff[i];
    let pointAdded = true;
    let oldIdx2;
    let newIdx2;
    switch (diffItem.cmd) {
      case "=":
        oldIdx2 = diffItem.idx * 2;
        newIdx2 = diffItem.idx1 * 2;
        let currentX = oldPoints[oldIdx2];
        let currentY = oldPoints[oldIdx2 + 1];
        const nextX = newPoints[newIdx2];
        const nextY = newPoints[newIdx2 + 1];
        if (isNaN(currentX) || isNaN(currentY)) {
          currentX = nextX;
          currentY = nextY;
        }
        currPoints.push(currentX, currentY);
        nextPoints.push(nextX, nextY);
        currStackedPoints.push(oldStackedOnPoints[oldIdx2], oldStackedOnPoints[oldIdx2 + 1]);
        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
        rawIndices.push(newData.getRawIndex(diffItem.idx1));
        break;
      case "+":
        const newIdx = diffItem.idx;
        const newDataDimsForPoint = newDataOldCoordInfo.dataDimsForPoint;
        const oldPt = oldCoordSys.dataToPoint([
          newData.get(newDataDimsForPoint[0], newIdx),
          newData.get(newDataDimsForPoint[1], newIdx)
        ]);
        newIdx2 = newIdx * 2;
        currPoints.push(oldPt[0], oldPt[1]);
        nextPoints.push(newPoints[newIdx2], newPoints[newIdx2 + 1]);
        const stackedOnPoint = getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, newIdx);
        currStackedPoints.push(stackedOnPoint[0], stackedOnPoint[1]);
        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
        rawIndices.push(newData.getRawIndex(newIdx));
        break;
      case "-":
        pointAdded = false;
    }
    if (pointAdded) {
      status.push(diffItem);
      sortedIndices.push(sortedIndices.length);
    }
  }
  sortedIndices.sort(function(a, b) {
    return rawIndices[a] - rawIndices[b];
  });
  const len2 = currPoints.length;
  const sortedCurrPoints = createFloat32Array(len2);
  const sortedNextPoints = createFloat32Array(len2);
  const sortedCurrStackedPoints = createFloat32Array(len2);
  const sortedNextStackedPoints = createFloat32Array(len2);
  const sortedStatus = [];
  for (let i = 0; i < sortedIndices.length; i++) {
    const idx = sortedIndices[i];
    const i2 = i * 2;
    const idx2 = idx * 2;
    sortedCurrPoints[i2] = currPoints[idx2];
    sortedCurrPoints[i2 + 1] = currPoints[idx2 + 1];
    sortedNextPoints[i2] = nextPoints[idx2];
    sortedNextPoints[i2 + 1] = nextPoints[idx2 + 1];
    sortedCurrStackedPoints[i2] = currStackedPoints[idx2];
    sortedCurrStackedPoints[i2 + 1] = currStackedPoints[idx2 + 1];
    sortedNextStackedPoints[i2] = nextStackedPoints[idx2];
    sortedNextStackedPoints[i2 + 1] = nextStackedPoints[idx2 + 1];
    sortedStatus[i] = status[idx];
  }
  return {
    current: sortedCurrPoints,
    next: sortedNextPoints,
    stackedOnCurrent: sortedCurrStackedPoints,
    stackedOnNext: sortedNextStackedPoints,
    status: sortedStatus
  };
}

// src/chart/line/poly.ts
var mathMin7 = Math.min;
var mathMax7 = Math.max;
function isPointNull(x, y) {
  return isNaN(x) || isNaN(y);
}
function drawSegment(ctx, points4, start2, segLen, allLen, dir3, smooth, smoothMonotone, connectNulls) {
  let prevX;
  let prevY;
  let cpx0;
  let cpy0;
  let cpx1;
  let cpy1;
  let idx = start2;
  let k = 0;
  for (; k < segLen; k++) {
    let x = points4[idx * 2];
    let y = points4[idx * 2 + 1];
    if (idx >= allLen || idx < 0) {
      break;
    }
    if (isPointNull(x, y)) {
      if (connectNulls) {
        idx += dir3;
        continue;
      }
      break;
    }
    if (idx === start2) {
      ctx[dir3 > 0 ? "moveTo" : "lineTo"](x, y);
      cpx0 = x;
      cpy0 = y;
    } else {
      let dx = x - prevX;
      let dy = y - prevY;
      if (dx * dx + dy * dy < 0.5) {
        idx += dir3;
        continue;
      }
      if (smooth > 0) {
        let nextIdx = idx + dir3;
        let nextX = points4[nextIdx * 2];
        let nextY = points4[nextIdx * 2 + 1];
        while (nextX === x && nextY === y && k < segLen) {
          k++;
          nextIdx += dir3;
          idx += dir3;
          nextX = points4[nextIdx * 2];
          nextY = points4[nextIdx * 2 + 1];
          x = points4[idx * 2];
          y = points4[idx * 2 + 1];
          dx = x - prevX;
          dy = y - prevY;
        }
        let tmpK = k + 1;
        if (connectNulls) {
          while (isPointNull(nextX, nextY) && tmpK < segLen) {
            tmpK++;
            nextIdx += dir3;
            nextX = points4[nextIdx * 2];
            nextY = points4[nextIdx * 2 + 1];
          }
        }
        let ratioNextSeg = 0.5;
        let vx = 0;
        let vy = 0;
        let nextCpx0;
        let nextCpy0;
        if (tmpK >= segLen || isPointNull(nextX, nextY)) {
          cpx1 = x;
          cpy1 = y;
        } else {
          vx = nextX - prevX;
          vy = nextY - prevY;
          const dx0 = x - prevX;
          const dx1 = nextX - x;
          const dy0 = y - prevY;
          const dy1 = nextY - y;
          let lenPrevSeg;
          let lenNextSeg;
          if (smoothMonotone === "x") {
            lenPrevSeg = Math.abs(dx0);
            lenNextSeg = Math.abs(dx1);
            const dir4 = vx > 0 ? 1 : -1;
            cpx1 = x - dir4 * lenPrevSeg * smooth;
            cpy1 = y;
            nextCpx0 = x + dir4 * lenNextSeg * smooth;
            nextCpy0 = y;
          } else if (smoothMonotone === "y") {
            lenPrevSeg = Math.abs(dy0);
            lenNextSeg = Math.abs(dy1);
            const dir4 = vy > 0 ? 1 : -1;
            cpx1 = x;
            cpy1 = y - dir4 * lenPrevSeg * smooth;
            nextCpx0 = x;
            nextCpy0 = y + dir4 * lenNextSeg * smooth;
          } else {
            lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);
            lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
            cpx1 = x - vx * smooth * (1 - ratioNextSeg);
            cpy1 = y - vy * smooth * (1 - ratioNextSeg);
            nextCpx0 = x + vx * smooth * ratioNextSeg;
            nextCpy0 = y + vy * smooth * ratioNextSeg;
            nextCpx0 = mathMin7(nextCpx0, mathMax7(nextX, x));
            nextCpy0 = mathMin7(nextCpy0, mathMax7(nextY, y));
            nextCpx0 = mathMax7(nextCpx0, mathMin7(nextX, x));
            nextCpy0 = mathMax7(nextCpy0, mathMin7(nextY, y));
            vx = nextCpx0 - x;
            vy = nextCpy0 - y;
            cpx1 = x - vx * lenPrevSeg / lenNextSeg;
            cpy1 = y - vy * lenPrevSeg / lenNextSeg;
            cpx1 = mathMin7(cpx1, mathMax7(prevX, x));
            cpy1 = mathMin7(cpy1, mathMax7(prevY, y));
            cpx1 = mathMax7(cpx1, mathMin7(prevX, x));
            cpy1 = mathMax7(cpy1, mathMin7(prevY, y));
            vx = x - cpx1;
            vy = y - cpy1;
            nextCpx0 = x + vx * lenNextSeg / lenPrevSeg;
            nextCpy0 = y + vy * lenNextSeg / lenPrevSeg;
          }
        }
        ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x, y);
        cpx0 = nextCpx0;
        cpy0 = nextCpy0;
      } else {
        ctx.lineTo(x, y);
      }
    }
    prevX = x;
    prevY = y;
    idx += dir3;
  }
  return k;
}
var ECPolylineShape = class {
  constructor() {
    this.smooth = 0;
    this.smoothConstraint = true;
  }
};
var ECPolyline = class extends Path_default {
  constructor(opts) {
    super(opts);
    this.type = "ec-polyline";
  }
  getDefaultStyle() {
    return {
      stroke: tokens_default.color.neutral99,
      fill: null
    };
  }
  getDefaultShape() {
    return new ECPolylineShape();
  }
  buildPath(ctx, shape) {
    const points4 = shape.points;
    let i = 0;
    let len2 = points4.length / 2;
    if (shape.connectNulls) {
      for (; len2 > 0; len2--) {
        if (!isPointNull(points4[len2 * 2 - 2], points4[len2 * 2 - 1])) {
          break;
        }
      }
      for (; i < len2; i++) {
        if (!isPointNull(points4[i * 2], points4[i * 2 + 1])) {
          break;
        }
      }
    }
    while (i < len2) {
      i += drawSegment(ctx, points4, i, len2, len2, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
    }
  }
  getPointOn(xOrY, dim) {
    if (!this.path) {
      this.createPathProxy();
      this.buildPath(this.path, this.shape);
    }
    const path = this.path;
    const data = path.data;
    const CMD6 = PathProxy_default.CMD;
    let x0;
    let y0;
    const isDimX = dim === "x";
    const roots2 = [];
    for (let i = 0; i < data.length; ) {
      const cmd = data[i++];
      let x;
      let y;
      let x2;
      let y2;
      let x3;
      let y3;
      let t;
      switch (cmd) {
        case CMD6.M:
          x0 = data[i++];
          y0 = data[i++];
          break;
        case CMD6.L:
          x = data[i++];
          y = data[i++];
          t = isDimX ? (xOrY - x0) / (x - x0) : (xOrY - y0) / (y - y0);
          if (t <= 1 && t >= 0) {
            const val = isDimX ? (y - y0) * t + y0 : (x - x0) * t + x0;
            return isDimX ? [xOrY, val] : [val, xOrY];
          }
          x0 = x;
          y0 = y;
          break;
        case CMD6.C:
          x = data[i++];
          y = data[i++];
          x2 = data[i++];
          y2 = data[i++];
          x3 = data[i++];
          y3 = data[i++];
          const nRoot = isDimX ? cubicRootAt(x0, x, x2, x3, xOrY, roots2) : cubicRootAt(y0, y, y2, y3, xOrY, roots2);
          if (nRoot > 0) {
            for (let i2 = 0; i2 < nRoot; i2++) {
              const t2 = roots2[i2];
              if (t2 <= 1 && t2 >= 0) {
                const val = isDimX ? cubicAt(y0, y, y2, y3, t2) : cubicAt(x0, x, x2, x3, t2);
                return isDimX ? [xOrY, val] : [val, xOrY];
              }
            }
          }
          x0 = x3;
          y0 = y3;
          break;
      }
    }
  }
};
var ECPolygonShape = class extends ECPolylineShape {
};
var ECPolygon = class extends Path_default {
  constructor(opts) {
    super(opts);
    this.type = "ec-polygon";
  }
  getDefaultShape() {
    return new ECPolygonShape();
  }
  buildPath(ctx, shape) {
    const points4 = shape.points;
    const stackedOnPoints = shape.stackedOnPoints;
    let i = 0;
    let len2 = points4.length / 2;
    const smoothMonotone = shape.smoothMonotone;
    if (shape.connectNulls) {
      for (; len2 > 0; len2--) {
        if (!isPointNull(points4[len2 * 2 - 2], points4[len2 * 2 - 1])) {
          break;
        }
      }
      for (; i < len2; i++) {
        if (!isPointNull(points4[i * 2], points4[i * 2 + 1])) {
          break;
        }
      }
    }
    while (i < len2) {
      const k = drawSegment(ctx, points4, i, len2, len2, 1, shape.smooth, smoothMonotone, shape.connectNulls);
      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len2, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
      i += k + 1;
      ctx.closePath();
    }
  }
};

// src/chart/helper/createClipPathFromCoordSys.ts
function createGridClipPath(cartesian, hasAnimation, seriesModel, done, during) {
  const rect = cartesian.getArea();
  let x = rect.x;
  let y = rect.y;
  let width = rect.width;
  let height = rect.height;
  const lineWidth = seriesModel.get(["lineStyle", "width"]) || 0;
  x -= lineWidth / 2;
  y -= lineWidth / 2;
  width += lineWidth;
  height += lineWidth;
  width = Math.ceil(width);
  if (x !== Math.floor(x)) {
    x = Math.floor(x);
    width++;
  }
  const clipPath = new Rect_default({
    shape: {
      x,
      y,
      width,
      height
    }
  });
  if (hasAnimation) {
    const baseAxis = cartesian.getBaseAxis();
    const isHorizontal = baseAxis.isHorizontal();
    const isAxisInversed = baseAxis.inverse;
    if (isHorizontal) {
      if (isAxisInversed) {
        clipPath.shape.x += width;
      }
      clipPath.shape.width = 0;
    } else {
      if (!isAxisInversed) {
        clipPath.shape.y += height;
      }
      clipPath.shape.height = 0;
    }
    const duringCb = isFunction(during) ? (percent) => {
      during(percent, clipPath);
    } : null;
    initProps(clipPath, {
      shape: {
        width,
        height,
        x,
        y
      }
    }, seriesModel, null, done, duringCb);
  }
  return clipPath;
}
function createPolarClipPath(polar, hasAnimation, seriesModel) {
  const sectorArea = polar.getArea();
  const r0 = round(sectorArea.r0, 1);
  const r = round(sectorArea.r, 1);
  const clipPath = new Sector_default({
    shape: {
      cx: round(polar.cx, 1),
      cy: round(polar.cy, 1),
      r0,
      r,
      startAngle: sectorArea.startAngle,
      endAngle: sectorArea.endAngle,
      clockwise: sectorArea.clockwise
    }
  });
  if (hasAnimation) {
    const isRadial = polar.getBaseAxis().dim === "angle";
    if (isRadial) {
      clipPath.shape.endAngle = sectorArea.startAngle;
    } else {
      clipPath.shape.r = r0;
    }
    initProps(clipPath, {
      shape: {
        endAngle: sectorArea.endAngle,
        r
      }
    }, seriesModel);
  }
  return clipPath;
}
function createClipPath(coordSys, hasAnimation, seriesModel, done, during) {
  if (!coordSys) {
    return null;
  } else if (coordSys.type === "polar") {
    return createPolarClipPath(coordSys, hasAnimation, seriesModel);
  } else if (coordSys.type === "cartesian2d") {
    return createGridClipPath(coordSys, hasAnimation, seriesModel, done, during);
  }
  return null;
}

// src/coord/CoordinateSystem.ts
function isCoordinateSystemType(coordSys, type) {
  return coordSys.type === type;
}

// src/chart/line/LineView.ts
function isPointsSame(points1, points22) {
  if (points1.length !== points22.length) {
    return;
  }
  for (let i = 0; i < points1.length; i++) {
    if (points1[i] !== points22[i]) {
      return;
    }
  }
  return true;
}
function bboxFromPoints(points4) {
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  for (let i = 0; i < points4.length; ) {
    const x = points4[i++];
    const y = points4[i++];
    if (!isNaN(x)) {
      minX = Math.min(x, minX);
      maxX = Math.max(x, maxX);
    }
    if (!isNaN(y)) {
      minY = Math.min(y, minY);
      maxY = Math.max(y, maxY);
    }
  }
  return [
    [minX, minY],
    [maxX, maxY]
  ];
}
function getBoundingDiff(points1, points22) {
  const [min1, max1] = bboxFromPoints(points1);
  const [min23, max23] = bboxFromPoints(points22);
  return Math.max(Math.abs(min1[0] - min23[0]), Math.abs(min1[1] - min23[1]), Math.abs(max1[0] - max23[0]), Math.abs(max1[1] - max23[1]));
}
function getSmooth(smooth) {
  return isNumber(smooth) ? smooth : smooth ? 0.5 : 0;
}
function getStackedOnPoints(coordSys, data, dataCoordInfo) {
  if (!dataCoordInfo.valueDim) {
    return [];
  }
  const len2 = data.count();
  const points4 = createFloat32Array(len2 * 2);
  for (let idx = 0; idx < len2; idx++) {
    const pt = getStackedOnPoint(dataCoordInfo, coordSys, data, idx);
    points4[idx * 2] = pt[0];
    points4[idx * 2 + 1] = pt[1];
  }
  return points4;
}
function turnPointsIntoStep(points4, basePoints, coordSys, stepTurnAt, connectNulls) {
  const baseAxis = coordSys.getBaseAxis();
  const baseIndex = baseAxis.dim === "x" || baseAxis.dim === "radius" ? 0 : 1;
  const stepPoints = [];
  let i = 0;
  const stepPt = [];
  const pt = [];
  const nextPt = [];
  const filteredPoints = [];
  if (connectNulls) {
    for (i = 0; i < points4.length; i += 2) {
      const reference = basePoints || points4;
      if (!isNaN(reference[i]) && !isNaN(reference[i + 1])) {
        filteredPoints.push(points4[i], points4[i + 1]);
      }
    }
    points4 = filteredPoints;
  }
  for (i = 0; i < points4.length - 2; i += 2) {
    nextPt[0] = points4[i + 2];
    nextPt[1] = points4[i + 3];
    pt[0] = points4[i];
    pt[1] = points4[i + 1];
    stepPoints.push(pt[0], pt[1]);
    switch (stepTurnAt) {
      case "end":
        stepPt[baseIndex] = nextPt[baseIndex];
        stepPt[1 - baseIndex] = pt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
        break;
      case "middle":
        const middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
        const stepPt2 = [];
        stepPt[baseIndex] = stepPt2[baseIndex] = middle;
        stepPt[1 - baseIndex] = pt[1 - baseIndex];
        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
        stepPoints.push(stepPt2[0], stepPt2[1]);
        break;
      default:
        stepPt[baseIndex] = pt[baseIndex];
        stepPt[1 - baseIndex] = nextPt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
    }
  }
  stepPoints.push(points4[i++], points4[i++]);
  return stepPoints;
}
function clipColorStops(colorStops, maxSize) {
  const newColorStops = [];
  const len2 = colorStops.length;
  let prevOutOfRangeColorStop;
  let prevInRangeColorStop;
  function lerpStop(stop0, stop1, clippedCoord) {
    const coord0 = stop0.coord;
    const p = (clippedCoord - coord0) / (stop1.coord - coord0);
    const color4 = lerp2(p, [stop0.color, stop1.color]);
    return {coord: clippedCoord, color: color4};
  }
  for (let i = 0; i < len2; i++) {
    const stop2 = colorStops[i];
    const coord = stop2.coord;
    if (coord < 0) {
      prevOutOfRangeColorStop = stop2;
    } else if (coord > maxSize) {
      if (prevInRangeColorStop) {
        newColorStops.push(lerpStop(prevInRangeColorStop, stop2, maxSize));
      } else if (prevOutOfRangeColorStop) {
        newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop2, 0), lerpStop(prevOutOfRangeColorStop, stop2, maxSize));
      }
      break;
    } else {
      if (prevOutOfRangeColorStop) {
        newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop2, 0));
        prevOutOfRangeColorStop = null;
      }
      newColorStops.push(stop2);
      prevInRangeColorStop = stop2;
    }
  }
  return newColorStops;
}
function getVisualGradient(data, coordSys, api2) {
  const visualMetaList = data.getVisual("visualMeta");
  if (!visualMetaList || !visualMetaList.length || !data.count()) {
    return;
  }
  if (coordSys.type !== "cartesian2d") {
    if (true) {
      console.warn("Visual map on line style is only supported on cartesian2d.");
    }
    return;
  }
  let coordDim;
  let visualMeta;
  for (let i = visualMetaList.length - 1; i >= 0; i--) {
    const dimInfo = data.getDimensionInfo(visualMetaList[i].dimension);
    coordDim = dimInfo && dimInfo.coordDim;
    if (coordDim === "x" || coordDim === "y") {
      visualMeta = visualMetaList[i];
      break;
    }
  }
  if (!visualMeta) {
    if (true) {
      console.warn("Visual map on line style only support x or y dimension.");
    }
    return;
  }
  const axis = coordSys.getAxis(coordDim);
  const colorStops = map(visualMeta.stops, function(stop2) {
    return {
      coord: axis.toGlobalCoord(axis.dataToCoord(stop2.value)),
      color: stop2.color
    };
  });
  const stopLen = colorStops.length;
  const outerColors = visualMeta.outerColors.slice();
  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
    colorStops.reverse();
    outerColors.reverse();
  }
  const colorStopsInRange = clipColorStops(colorStops, coordDim === "x" ? api2.getWidth() : api2.getHeight());
  const inRangeStopLen = colorStopsInRange.length;
  if (!inRangeStopLen && stopLen) {
    return colorStops[0].coord < 0 ? outerColors[1] ? outerColors[1] : colorStops[stopLen - 1].color : outerColors[0] ? outerColors[0] : colorStops[0].color;
  }
  const tinyExtent = 10;
  const minCoord = colorStopsInRange[0].coord - tinyExtent;
  const maxCoord = colorStopsInRange[inRangeStopLen - 1].coord + tinyExtent;
  const coordSpan = maxCoord - minCoord;
  if (coordSpan < 1e-3) {
    return "transparent";
  }
  each(colorStopsInRange, function(stop2) {
    stop2.offset = (stop2.coord - minCoord) / coordSpan;
  });
  colorStopsInRange.push({
    offset: inRangeStopLen ? colorStopsInRange[inRangeStopLen - 1].offset : 0.5,
    color: outerColors[1] || "transparent"
  });
  colorStopsInRange.unshift({
    offset: inRangeStopLen ? colorStopsInRange[0].offset : 0.5,
    color: outerColors[0] || "transparent"
  });
  const gradient = new LinearGradient_default(0, 0, 0, 0, colorStopsInRange, true);
  gradient[coordDim] = minCoord;
  gradient[coordDim + "2"] = maxCoord;
  return gradient;
}
function getIsIgnoreFunc(seriesModel, data, coordSys) {
  const showAllSymbol = seriesModel.get("showAllSymbol");
  const isAuto = showAllSymbol === "auto";
  if (showAllSymbol && !isAuto) {
    return;
  }
  const categoryAxis2 = coordSys.getAxesByScale("ordinal")[0];
  if (!categoryAxis2) {
    return;
  }
  if (isAuto && canShowAllSymbolForCategory(categoryAxis2, data)) {
    return;
  }
  const categoryDataDim = data.mapDimension(categoryAxis2.dim);
  const labelMap = {};
  each(categoryAxis2.getViewLabels(), function(labelItem) {
    const ordinalNumber = categoryAxis2.scale.getRawOrdinalNumber(labelItem.tickValue);
    labelMap[ordinalNumber] = 1;
  });
  return function(dataIndex) {
    return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));
  };
}
function canShowAllSymbolForCategory(categoryAxis2, data) {
  const axisExtent = categoryAxis2.getExtent();
  let availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis2.scale.count();
  isNaN(availSize) && (availSize = 0);
  const dataLen = data.count();
  const step = Math.max(1, Math.round(dataLen / 5));
  for (let dataIndex = 0; dataIndex < dataLen; dataIndex += step) {
    if (Symbol_default.getSymbolSize(data, dataIndex)[categoryAxis2.isHorizontal() ? 1 : 0] * 1.5 > availSize) {
      return false;
    }
  }
  return true;
}
function isPointNull2(x, y) {
  return isNaN(x) || isNaN(y);
}
function getLastIndexNotNull(points4) {
  let len2 = points4.length / 2;
  for (; len2 > 0; len2--) {
    if (!isPointNull2(points4[len2 * 2 - 2], points4[len2 * 2 - 1])) {
      break;
    }
  }
  return len2 - 1;
}
function getPointAtIndex(points4, idx) {
  return [points4[idx * 2], points4[idx * 2 + 1]];
}
function getIndexRange(points4, xOrY, dim) {
  const len2 = points4.length / 2;
  const dimIdx = dim === "x" ? 0 : 1;
  let a;
  let b;
  let prevIndex = 0;
  let nextIndex = -1;
  for (let i = 0; i < len2; i++) {
    b = points4[i * 2 + dimIdx];
    if (isNaN(b) || isNaN(points4[i * 2 + 1 - dimIdx])) {
      continue;
    }
    if (i === 0) {
      a = b;
      continue;
    }
    if (a <= xOrY && b >= xOrY || a >= xOrY && b <= xOrY) {
      nextIndex = i;
      break;
    }
    prevIndex = i;
    a = b;
  }
  return {
    range: [prevIndex, nextIndex],
    t: (xOrY - a) / (b - a)
  };
}
function anyStateShowEndLabel(seriesModel) {
  if (seriesModel.get(["endLabel", "show"])) {
    return true;
  }
  for (let i = 0; i < SPECIAL_STATES.length; i++) {
    if (seriesModel.get([SPECIAL_STATES[i], "endLabel", "show"])) {
      return true;
    }
  }
  return false;
}
function createLineClipPath(lineView, coordSys, hasAnimation, seriesModel) {
  if (isCoordinateSystemType(coordSys, "cartesian2d")) {
    const endLabelModel = seriesModel.getModel("endLabel");
    const valueAnimation = endLabelModel.get("valueAnimation");
    const data = seriesModel.getData();
    const labelAnimationRecord = {lastFrameIndex: 0};
    const during = anyStateShowEndLabel(seriesModel) ? (percent, clipRect) => {
      lineView._endLabelOnDuring(percent, clipRect, data, labelAnimationRecord, valueAnimation, endLabelModel, coordSys);
    } : null;
    const isHorizontal = coordSys.getBaseAxis().isHorizontal();
    const clipPath = createGridClipPath(coordSys, hasAnimation, seriesModel, () => {
      const endLabel = lineView._endLabel;
      if (endLabel && hasAnimation) {
        if (labelAnimationRecord.originalX != null) {
          endLabel.attr({
            x: labelAnimationRecord.originalX,
            y: labelAnimationRecord.originalY
          });
        }
      }
    }, during);
    if (!seriesModel.get("clip", true)) {
      const rectShape = clipPath.shape;
      const expandSize = Math.max(rectShape.width, rectShape.height);
      if (isHorizontal) {
        rectShape.y -= expandSize;
        rectShape.height += expandSize * 2;
      } else {
        rectShape.x -= expandSize;
        rectShape.width += expandSize * 2;
      }
    }
    if (during) {
      during(1, clipPath);
    }
    return clipPath;
  } else {
    if (true) {
      if (seriesModel.get(["endLabel", "show"])) {
        console.warn("endLabel is not supported for lines in polar systems.");
      }
    }
    return createPolarClipPath(coordSys, hasAnimation, seriesModel);
  }
}
function getEndLabelStateSpecified(endLabelModel, coordSys) {
  const baseAxis = coordSys.getBaseAxis();
  const isHorizontal = baseAxis.isHorizontal();
  const isBaseInversed = baseAxis.inverse;
  const align = isHorizontal ? isBaseInversed ? "right" : "left" : "center";
  const verticalAlign = isHorizontal ? "middle" : isBaseInversed ? "top" : "bottom";
  return {
    normal: {
      align: endLabelModel.get("align") || align,
      verticalAlign: endLabelModel.get("verticalAlign") || verticalAlign
    }
  };
}
var LineView = class extends Chart_default {
  init() {
    const lineGroup = new Group_default();
    const symbolDraw = new SymbolDraw_default();
    this.group.add(symbolDraw.group);
    this._symbolDraw = symbolDraw;
    this._lineGroup = lineGroup;
    this._changePolyState = bind(this._changePolyState, this);
  }
  render(seriesModel, ecModel, api2) {
    const coordSys = seriesModel.coordinateSystem;
    const group = this.group;
    const data = seriesModel.getData();
    const lineStyleModel = seriesModel.getModel("lineStyle");
    const areaStyleModel = seriesModel.getModel("areaStyle");
    let points4 = data.getLayout("points") || [];
    const isCoordSysPolar = coordSys.type === "polar";
    const prevCoordSys = this._coordSys;
    const symbolDraw = this._symbolDraw;
    let polyline = this._polyline;
    let polygon = this._polygon;
    const lineGroup = this._lineGroup;
    const hasAnimation = !ecModel.ssr && seriesModel.get("animation");
    const isAreaChart = !areaStyleModel.isEmpty();
    const valueOrigin = areaStyleModel.get("origin");
    const dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);
    let stackedOnPoints = isAreaChart && getStackedOnPoints(coordSys, data, dataCoordInfo);
    const showSymbol = seriesModel.get("showSymbol");
    const connectNulls = seriesModel.get("connectNulls");
    const isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys);
    const oldData = this._data;
    oldData && oldData.eachItemGraphicEl(function(el, idx) {
      if (el.__temp) {
        group.remove(el);
        oldData.setItemGraphicEl(idx, null);
      }
    });
    if (!showSymbol) {
      symbolDraw.remove();
    }
    group.add(lineGroup);
    const step = !isCoordSysPolar ? seriesModel.get("step") : false;
    let clipShapeForSymbol;
    if (coordSys && coordSys.getArea && seriesModel.get("clip", true)) {
      clipShapeForSymbol = coordSys.getArea();
      if (clipShapeForSymbol.width != null) {
        clipShapeForSymbol.x -= 0.1;
        clipShapeForSymbol.y -= 0.1;
        clipShapeForSymbol.width += 0.2;
        clipShapeForSymbol.height += 0.2;
      } else if (clipShapeForSymbol.r0) {
        clipShapeForSymbol.r0 -= 0.5;
        clipShapeForSymbol.r += 0.5;
      }
    }
    this._clipShapeForSymbol = clipShapeForSymbol;
    const visualColor = getVisualGradient(data, coordSys, api2) || data.getVisual("style")[data.getVisual("drawType")];
    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
      showSymbol && symbolDraw.updateData(data, {
        isIgnore: isIgnoreFunc,
        clipShape: clipShapeForSymbol,
        disableAnimation: true,
        getSymbolPoint(idx) {
          return [points4[idx * 2], points4[idx * 2 + 1]];
        }
      });
      hasAnimation && this._initSymbolLabelAnimation(data, coordSys, clipShapeForSymbol);
      if (step) {
        if (stackedOnPoints) {
          stackedOnPoints = turnPointsIntoStep(stackedOnPoints, points4, coordSys, step, connectNulls);
        }
        points4 = turnPointsIntoStep(points4, null, coordSys, step, connectNulls);
      }
      polyline = this._newPolyline(points4);
      if (isAreaChart) {
        polygon = this._newPolygon(points4, stackedOnPoints);
      } else if (polygon) {
        lineGroup.remove(polygon);
        polygon = this._polygon = null;
      }
      if (!isCoordSysPolar) {
        this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
      }
      lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
    } else {
      if (isAreaChart && !polygon) {
        polygon = this._newPolygon(points4, stackedOnPoints);
      } else if (polygon && !isAreaChart) {
        lineGroup.remove(polygon);
        polygon = this._polygon = null;
      }
      if (!isCoordSysPolar) {
        this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
      }
      const oldClipPath = lineGroup.getClipPath();
      if (oldClipPath) {
        const newClipPath = createLineClipPath(this, coordSys, false, seriesModel);
        initProps(oldClipPath, {
          shape: newClipPath.shape
        }, seriesModel);
      } else {
        lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
      }
      showSymbol && symbolDraw.updateData(data, {
        isIgnore: isIgnoreFunc,
        clipShape: clipShapeForSymbol,
        disableAnimation: true,
        getSymbolPoint(idx) {
          return [points4[idx * 2], points4[idx * 2 + 1]];
        }
      });
      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points4)) {
        if (hasAnimation) {
          this._doUpdateAnimation(data, stackedOnPoints, coordSys, api2, step, valueOrigin, connectNulls);
        } else {
          if (step) {
            if (stackedOnPoints) {
              stackedOnPoints = turnPointsIntoStep(stackedOnPoints, points4, coordSys, step, connectNulls);
            }
            points4 = turnPointsIntoStep(points4, null, coordSys, step, connectNulls);
          }
          polyline.setShape({
            points: points4
          });
          polygon && polygon.setShape({
            points: points4,
            stackedOnPoints
          });
        }
      }
    }
    const emphasisModel = seriesModel.getModel("emphasis");
    const focus = emphasisModel.get("focus");
    const blurScope = emphasisModel.get("blurScope");
    const emphasisDisabled = emphasisModel.get("disabled");
    polyline.useStyle(defaults(lineStyleModel.getLineStyle(), {
      fill: "none",
      stroke: visualColor,
      lineJoin: "bevel"
    }));
    setStatesStylesFromModel(polyline, seriesModel, "lineStyle");
    if (polyline.style.lineWidth > 0 && seriesModel.get(["emphasis", "lineStyle", "width"]) === "bolder") {
      const emphasisLineStyle = polyline.getState("emphasis").style;
      emphasisLineStyle.lineWidth = +polyline.style.lineWidth + 1;
    }
    getECData(polyline).seriesIndex = seriesModel.seriesIndex;
    toggleHoverEmphasis(polyline, focus, blurScope, emphasisDisabled);
    const smooth = getSmooth(seriesModel.get("smooth"));
    const smoothMonotone = seriesModel.get("smoothMonotone");
    polyline.setShape({
      smooth,
      smoothMonotone,
      connectNulls
    });
    if (polygon) {
      const stackedOnSeries = data.getCalculationInfo("stackedOnSeries");
      let stackedOnSmooth = 0;
      polygon.useStyle(defaults(areaStyleModel.getAreaStyle(), {
        fill: visualColor,
        opacity: 0.7,
        lineJoin: "bevel",
        decal: data.getVisual("style").decal
      }));
      if (stackedOnSeries) {
        stackedOnSmooth = getSmooth(stackedOnSeries.get("smooth"));
      }
      polygon.setShape({
        smooth,
        stackedOnSmooth,
        smoothMonotone,
        connectNulls
      });
      setStatesStylesFromModel(polygon, seriesModel, "areaStyle");
      getECData(polygon).seriesIndex = seriesModel.seriesIndex;
      toggleHoverEmphasis(polygon, focus, blurScope, emphasisDisabled);
    }
    const changePolyState = this._changePolyState;
    data.eachItemGraphicEl(function(el) {
      el && (el.onHoverStateChange = changePolyState);
    });
    this._polyline.onHoverStateChange = changePolyState;
    this._data = data;
    this._coordSys = coordSys;
    this._stackedOnPoints = stackedOnPoints;
    this._points = points4;
    this._step = step;
    this._valueOrigin = valueOrigin;
    if (seriesModel.get("triggerLineEvent")) {
      this.packEventData(seriesModel, polyline);
      polygon && this.packEventData(seriesModel, polygon);
    }
  }
  packEventData(seriesModel, el) {
    getECData(el).eventData = {
      componentType: "series",
      componentSubType: "line",
      componentIndex: seriesModel.componentIndex,
      seriesIndex: seriesModel.seriesIndex,
      seriesName: seriesModel.name,
      seriesType: "line"
    };
  }
  highlight(seriesModel, ecModel, api2, payload) {
    const data = seriesModel.getData();
    const dataIndex = queryDataIndex(data, payload);
    this._changePolyState("emphasis");
    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
      const points4 = data.getLayout("points");
      let symbol = data.getItemGraphicEl(dataIndex);
      if (!symbol) {
        const x = points4[dataIndex * 2];
        const y = points4[dataIndex * 2 + 1];
        if (isNaN(x) || isNaN(y)) {
          return;
        }
        if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(x, y)) {
          return;
        }
        const zlevel = seriesModel.get("zlevel") || 0;
        const z = seriesModel.get("z") || 0;
        symbol = new Symbol_default(data, dataIndex);
        symbol.x = x;
        symbol.y = y;
        symbol.setZ(zlevel, z);
        const symbolLabel = symbol.getSymbolPath().getTextContent();
        if (symbolLabel) {
          symbolLabel.zlevel = zlevel;
          symbolLabel.z = z;
          symbolLabel.z2 = this._polyline.z2 + 1;
        }
        symbol.__temp = true;
        data.setItemGraphicEl(dataIndex, symbol);
        symbol.stopSymbolAnimation(true);
        this.group.add(symbol);
      }
      symbol.highlight();
    } else {
      Chart_default.prototype.highlight.call(this, seriesModel, ecModel, api2, payload);
    }
  }
  downplay(seriesModel, ecModel, api2, payload) {
    const data = seriesModel.getData();
    const dataIndex = queryDataIndex(data, payload);
    this._changePolyState("normal");
    if (dataIndex != null && dataIndex >= 0) {
      const symbol = data.getItemGraphicEl(dataIndex);
      if (symbol) {
        if (symbol.__temp) {
          data.setItemGraphicEl(dataIndex, null);
          this.group.remove(symbol);
        } else {
          symbol.downplay();
        }
      }
    } else {
      Chart_default.prototype.downplay.call(this, seriesModel, ecModel, api2, payload);
    }
  }
  _changePolyState(toState) {
    const polygon = this._polygon;
    setStatesFlag(this._polyline, toState);
    polygon && setStatesFlag(polygon, toState);
  }
  _newPolyline(points4) {
    let polyline = this._polyline;
    if (polyline) {
      this._lineGroup.remove(polyline);
    }
    polyline = new ECPolyline({
      shape: {
        points: points4
      },
      segmentIgnoreThreshold: 2,
      z2: 10
    });
    this._lineGroup.add(polyline);
    this._polyline = polyline;
    return polyline;
  }
  _newPolygon(points4, stackedOnPoints) {
    let polygon = this._polygon;
    if (polygon) {
      this._lineGroup.remove(polygon);
    }
    polygon = new ECPolygon({
      shape: {
        points: points4,
        stackedOnPoints
      },
      segmentIgnoreThreshold: 2
    });
    this._lineGroup.add(polygon);
    this._polygon = polygon;
    return polygon;
  }
  _initSymbolLabelAnimation(data, coordSys, clipShape) {
    let isHorizontalOrRadial;
    let isCoordSysPolar;
    const baseAxis = coordSys.getBaseAxis();
    const isAxisInverse = baseAxis.inverse;
    if (coordSys.type === "cartesian2d") {
      isHorizontalOrRadial = baseAxis.isHorizontal();
      isCoordSysPolar = false;
    } else if (coordSys.type === "polar") {
      isHorizontalOrRadial = baseAxis.dim === "angle";
      isCoordSysPolar = true;
    }
    const seriesModel = data.hostModel;
    let seriesDuration = seriesModel.get("animationDuration");
    if (isFunction(seriesDuration)) {
      seriesDuration = seriesDuration(null);
    }
    const seriesDelay = seriesModel.get("animationDelay") || 0;
    const seriesDelayValue = isFunction(seriesDelay) ? seriesDelay(null) : seriesDelay;
    data.eachItemGraphicEl(function(symbol, idx) {
      const el = symbol;
      if (el) {
        const point = [symbol.x, symbol.y];
        let start2;
        let end2;
        let current;
        if (clipShape) {
          if (isCoordSysPolar) {
            const polarClip = clipShape;
            const coord = coordSys.pointToCoord(point);
            if (isHorizontalOrRadial) {
              start2 = polarClip.startAngle;
              end2 = polarClip.endAngle;
              current = -coord[1] / 180 * Math.PI;
            } else {
              start2 = polarClip.r0;
              end2 = polarClip.r;
              current = coord[0];
            }
          } else {
            const gridClip = clipShape;
            if (isHorizontalOrRadial) {
              start2 = gridClip.x;
              end2 = gridClip.x + gridClip.width;
              current = symbol.x;
            } else {
              start2 = gridClip.y + gridClip.height;
              end2 = gridClip.y;
              current = symbol.y;
            }
          }
        }
        let ratio = end2 === start2 ? 0 : (current - start2) / (end2 - start2);
        if (isAxisInverse) {
          ratio = 1 - ratio;
        }
        const delay = isFunction(seriesDelay) ? seriesDelay(idx) : seriesDuration * ratio + seriesDelayValue;
        const symbolPath = el.getSymbolPath();
        const text = symbolPath.getTextContent();
        el.attr({scaleX: 0, scaleY: 0});
        el.animateTo({
          scaleX: 1,
          scaleY: 1
        }, {
          duration: 200,
          setToFinal: true,
          delay
        });
        if (text) {
          text.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay
          });
        }
        symbolPath.disableLabelAnimation = true;
      }
    });
  }
  _initOrUpdateEndLabel(seriesModel, coordSys, inheritColor) {
    const endLabelModel = seriesModel.getModel("endLabel");
    if (anyStateShowEndLabel(seriesModel)) {
      const data = seriesModel.getData();
      const polyline = this._polyline;
      const points4 = data.getLayout("points");
      if (!points4) {
        polyline.removeTextContent();
        this._endLabel = null;
        return;
      }
      let endLabel = this._endLabel;
      if (!endLabel) {
        endLabel = this._endLabel = new Text_default({
          z2: 200
        });
        endLabel.ignoreClip = true;
        polyline.setTextContent(this._endLabel);
        polyline.disableLabelAnimation = true;
      }
      const dataIndex = getLastIndexNotNull(points4);
      if (dataIndex >= 0) {
        setLabelStyle(polyline, getLabelStatesModels(seriesModel, "endLabel"), {
          inheritColor,
          labelFetcher: seriesModel,
          labelDataIndex: dataIndex,
          defaultText(dataIndex2, opt, interpolatedValue) {
            return interpolatedValue != null ? getDefaultInterpolatedLabel(data, interpolatedValue) : getDefaultLabel(data, dataIndex2);
          },
          enableTextSetter: true
        }, getEndLabelStateSpecified(endLabelModel, coordSys));
        polyline.textConfig.position = null;
      }
    } else if (this._endLabel) {
      this._polyline.removeTextContent();
      this._endLabel = null;
    }
  }
  _endLabelOnDuring(percent, clipRect, data, animationRecord, valueAnimation, endLabelModel, coordSys) {
    const endLabel = this._endLabel;
    const polyline = this._polyline;
    if (endLabel) {
      if (percent < 1 && animationRecord.originalX == null) {
        animationRecord.originalX = endLabel.x;
        animationRecord.originalY = endLabel.y;
      }
      const points4 = data.getLayout("points");
      const seriesModel = data.hostModel;
      const connectNulls = seriesModel.get("connectNulls");
      const precision = endLabelModel.get("precision");
      const distance2 = endLabelModel.get("distance") || 0;
      const baseAxis = coordSys.getBaseAxis();
      const isHorizontal = baseAxis.isHorizontal();
      const isBaseInversed = baseAxis.inverse;
      const clipShape = clipRect.shape;
      const xOrY = isBaseInversed ? isHorizontal ? clipShape.x : clipShape.y + clipShape.height : isHorizontal ? clipShape.x + clipShape.width : clipShape.y;
      const distanceX = (isHorizontal ? distance2 : 0) * (isBaseInversed ? -1 : 1);
      const distanceY = (isHorizontal ? 0 : -distance2) * (isBaseInversed ? -1 : 1);
      const dim = isHorizontal ? "x" : "y";
      const dataIndexRange = getIndexRange(points4, xOrY, dim);
      const indices = dataIndexRange.range;
      const diff = indices[1] - indices[0];
      let value;
      if (diff >= 1) {
        if (diff > 1 && !connectNulls) {
          const pt = getPointAtIndex(points4, indices[0]);
          endLabel.attr({
            x: pt[0] + distanceX,
            y: pt[1] + distanceY
          });
          valueAnimation && (value = seriesModel.getRawValue(indices[0]));
        } else {
          const pt = polyline.getPointOn(xOrY, dim);
          pt && endLabel.attr({
            x: pt[0] + distanceX,
            y: pt[1] + distanceY
          });
          const startValue = seriesModel.getRawValue(indices[0]);
          const endValue = seriesModel.getRawValue(indices[1]);
          valueAnimation && (value = interpolateRawValues(data, precision, startValue, endValue, dataIndexRange.t));
        }
        animationRecord.lastFrameIndex = indices[0];
      } else {
        const idx = percent === 1 || animationRecord.lastFrameIndex > 0 ? indices[0] : 0;
        const pt = getPointAtIndex(points4, idx);
        valueAnimation && (value = seriesModel.getRawValue(idx));
        endLabel.attr({
          x: pt[0] + distanceX,
          y: pt[1] + distanceY
        });
      }
      if (valueAnimation) {
        const inner25 = labelInner(endLabel);
        if (typeof inner25.setLabelText === "function") {
          inner25.setLabelText(value);
        }
      }
    }
  }
  _doUpdateAnimation(data, stackedOnPoints, coordSys, api2, step, valueOrigin, connectNulls) {
    const polyline = this._polyline;
    const polygon = this._polygon;
    const seriesModel = data.hostModel;
    const diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);
    let current = diff.current;
    let stackedOnCurrent = diff.stackedOnCurrent;
    let next = diff.next;
    let stackedOnNext = diff.stackedOnNext;
    if (step) {
      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, diff.current, coordSys, step, connectNulls);
      current = turnPointsIntoStep(diff.current, null, coordSys, step, connectNulls);
      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, diff.next, coordSys, step, connectNulls);
      next = turnPointsIntoStep(diff.next, null, coordSys, step, connectNulls);
    }
    if (getBoundingDiff(current, next) > 3e3 || polygon && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3e3) {
      polyline.stopAnimation();
      polyline.setShape({
        points: next
      });
      if (polygon) {
        polygon.stopAnimation();
        polygon.setShape({
          points: next,
          stackedOnPoints: stackedOnNext
        });
      }
      return;
    }
    polyline.shape.__points = diff.current;
    polyline.shape.points = current;
    const target = {
      shape: {
        points: next
      }
    };
    if (diff.current !== current) {
      target.shape.__points = diff.next;
    }
    polyline.stopAnimation();
    updateProps(polyline, target, seriesModel);
    if (polygon) {
      polygon.setShape({
        points: current,
        stackedOnPoints: stackedOnCurrent
      });
      polygon.stopAnimation();
      updateProps(polygon, {
        shape: {
          stackedOnPoints: stackedOnNext
        }
      }, seriesModel);
      if (polyline.shape.points !== polygon.shape.points) {
        polygon.shape.points = polyline.shape.points;
      }
    }
    const updatedDataInfo = [];
    const diffStatus = diff.status;
    for (let i = 0; i < diffStatus.length; i++) {
      const cmd = diffStatus[i].cmd;
      if (cmd === "=") {
        const el = data.getItemGraphicEl(diffStatus[i].idx1);
        if (el) {
          updatedDataInfo.push({
            el,
            ptIdx: i
          });
        }
      }
    }
    if (polyline.animators && polyline.animators.length) {
      polyline.animators[0].during(function() {
        polygon && polygon.dirtyShape();
        const points4 = polyline.shape.__points;
        for (let i = 0; i < updatedDataInfo.length; i++) {
          const el = updatedDataInfo[i].el;
          const offset = updatedDataInfo[i].ptIdx * 2;
          el.x = points4[offset];
          el.y = points4[offset + 1];
          el.markRedraw();
        }
      });
    }
  }
  remove(ecModel) {
    const group = this.group;
    const oldData = this._data;
    this._lineGroup.removeAll();
    this._symbolDraw.remove(true);
    oldData && oldData.eachItemGraphicEl(function(el, idx) {
      if (el.__temp) {
        group.remove(el);
        oldData.setItemGraphicEl(idx, null);
      }
    });
    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
  }
};
LineView.type = "line";
var LineView_default = LineView;

// src/layout/points.ts
function pointsLayout(seriesType2, forceStoreInTypedArray) {
  return {
    seriesType: seriesType2,
    plan: createRenderPlanner(),
    reset: function(seriesModel) {
      const data = seriesModel.getData();
      const coordSys = seriesModel.coordinateSystem;
      const pipelineContext = seriesModel.pipelineContext;
      const useTypedArray = forceStoreInTypedArray || pipelineContext.large;
      if (!coordSys) {
        return;
      }
      const dims = map(coordSys.dimensions, function(dim) {
        return data.mapDimension(dim);
      }).slice(0, 2);
      const dimLen = dims.length;
      const stackResultDim = data.getCalculationInfo("stackResultDimension");
      if (isDimensionStacked(data, dims[0])) {
        dims[0] = stackResultDim;
      }
      if (isDimensionStacked(data, dims[1])) {
        dims[1] = stackResultDim;
      }
      const store = data.getStore();
      const dimIdx0 = data.getDimensionIndex(dims[0]);
      const dimIdx1 = data.getDimensionIndex(dims[1]);
      return dimLen && {
        progress(params, data2) {
          const segCount = params.end - params.start;
          const points4 = useTypedArray && createFloat32Array(segCount * dimLen);
          const tmpIn = [];
          const tmpOut = [];
          for (let i = params.start, offset = 0; i < params.end; i++) {
            let point;
            if (dimLen === 1) {
              const x = store.get(dimIdx0, i);
              point = coordSys.dataToPoint(x, null, tmpOut);
            } else {
              tmpIn[0] = store.get(dimIdx0, i);
              tmpIn[1] = store.get(dimIdx1, i);
              point = coordSys.dataToPoint(tmpIn, null, tmpOut);
            }
            if (useTypedArray) {
              points4[offset++] = point[0];
              points4[offset++] = point[1];
            } else {
              data2.setItemLayout(i, point.slice());
            }
          }
          useTypedArray && data2.setLayout("points", points4);
        }
      };
    }
  };
}

// src/processor/dataSample.ts
var samplers = {
  average: function(frame) {
    let sum2 = 0;
    let count2 = 0;
    for (let i = 0; i < frame.length; i++) {
      if (!isNaN(frame[i])) {
        sum2 += frame[i];
        count2++;
      }
    }
    return count2 === 0 ? NaN : sum2 / count2;
  },
  sum: function(frame) {
    let sum2 = 0;
    for (let i = 0; i < frame.length; i++) {
      sum2 += frame[i] || 0;
    }
    return sum2;
  },
  max: function(frame) {
    let max3 = -Infinity;
    for (let i = 0; i < frame.length; i++) {
      frame[i] > max3 && (max3 = frame[i]);
    }
    return isFinite(max3) ? max3 : NaN;
  },
  min: function(frame) {
    let min3 = Infinity;
    for (let i = 0; i < frame.length; i++) {
      frame[i] < min3 && (min3 = frame[i]);
    }
    return isFinite(min3) ? min3 : NaN;
  },
  nearest: function(frame) {
    return frame[0];
  }
};
var indexSampler = function(frame) {
  return Math.round(frame.length / 2);
};
function dataSample(seriesType2) {
  return {
    seriesType: seriesType2,
    reset: function(seriesModel, ecModel, api2) {
      const data = seriesModel.getData();
      const sampling = seriesModel.get("sampling");
      const coordSys = seriesModel.coordinateSystem;
      const count2 = data.count();
      if (count2 > 10 && coordSys.type === "cartesian2d" && sampling) {
        const baseAxis = coordSys.getBaseAxis();
        const valueAxis2 = coordSys.getOtherAxis(baseAxis);
        const extent = baseAxis.getExtent();
        const dpr2 = api2.getDevicePixelRatio();
        const size = Math.abs(extent[1] - extent[0]) * (dpr2 || 1);
        const rate = Math.round(count2 / size);
        if (isFinite(rate) && rate > 1) {
          if (sampling === "lttb") {
            seriesModel.setData(data.lttbDownSample(data.mapDimension(valueAxis2.dim), 1 / rate));
          } else if (sampling === "minmax") {
            seriesModel.setData(data.minmaxDownSample(data.mapDimension(valueAxis2.dim), 1 / rate));
          }
          let sampler;
          if (isString(sampling)) {
            sampler = samplers[sampling];
          } else if (isFunction(sampling)) {
            sampler = sampling;
          }
          if (sampler) {
            seriesModel.setData(data.downSample(data.mapDimension(valueAxis2.dim), 1 / rate, sampler, indexSampler));
          }
        }
      }
    }
  };
}

// src/chart/line/install.ts
function install3(registers) {
  registers.registerChartView(LineView_default);
  registers.registerSeriesModel(LineSeries_default);
  registers.registerLayout(pointsLayout("line", true));
  registers.registerVisual({
    seriesType: "line",
    reset: function(seriesModel) {
      const data = seriesModel.getData();
      const lineStyle = seriesModel.getModel("lineStyle").getLineStyle();
      if (lineStyle && !lineStyle.stroke) {
        lineStyle.stroke = data.getVisual("style").fill;
      }
      data.setVisual("legendLineStyle", lineStyle);
    }
  });
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample("line"));
}

// src/chart/bar/BaseBarSeries.ts
var BaseBarSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = BaseBarSeriesModel2.type;
  }
  getInitialData(option, ecModel) {
    return createSeriesData_default(null, this, {useEncodeDefaulter: true});
  }
  getMarkerPosition(value, dims, startingAtTick) {
    const coordSys = this.coordinateSystem;
    if (coordSys && coordSys.clampData) {
      const clampData = coordSys.clampData(value);
      const pt = coordSys.dataToPoint(clampData);
      if (startingAtTick) {
        each(coordSys.getAxes(), function(axis, idx) {
          if (axis.type === "category" && dims != null) {
            const tickCoords = axis.getTicksCoords();
            const alignTicksWithLabel = axis.getTickModel().get("alignWithLabel");
            let targetTickId = clampData[idx];
            const isEnd = dims[idx] === "x1" || dims[idx] === "y1";
            if (isEnd && !alignTicksWithLabel) {
              targetTickId += 1;
            }
            if (tickCoords.length < 2) {
              return;
            } else if (tickCoords.length === 2) {
              pt[idx] = axis.toGlobalCoord(axis.getExtent()[isEnd ? 1 : 0]);
              return;
            }
            let leftCoord;
            let coord;
            let stepTickValue = 1;
            for (let i = 0; i < tickCoords.length; i++) {
              const tickCoord = tickCoords[i].coord;
              const tickValue = i === tickCoords.length - 1 ? tickCoords[i - 1].tickValue + stepTickValue : tickCoords[i].tickValue;
              if (tickValue === targetTickId) {
                coord = tickCoord;
                break;
              } else if (tickValue < targetTickId) {
                leftCoord = tickCoord;
              } else if (leftCoord != null && tickValue > targetTickId) {
                coord = (tickCoord + leftCoord) / 2;
                break;
              }
              if (i === 1) {
                stepTickValue = tickValue - tickCoords[0].tickValue;
              }
            }
            if (coord == null) {
              if (!leftCoord) {
                coord = tickCoords[0].coord;
              } else if (leftCoord) {
                coord = tickCoords[tickCoords.length - 1].coord;
              }
            }
            pt[idx] = axis.toGlobalCoord(coord);
          }
        });
      } else {
        const data = this.getData();
        const offset = data.getLayout("offset");
        const size = data.getLayout("size");
        const offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
        pt[offsetIndex] += offset + size / 2;
      }
      return pt;
    }
    return [NaN, NaN];
  }
};
var BaseBarSeriesModel = BaseBarSeriesModel2;
BaseBarSeriesModel.type = "series.__base_bar__";
BaseBarSeriesModel.defaultOption = {
  z: 2,
  coordinateSystem: "cartesian2d",
  legendHoverLink: true,
  barMinHeight: 0,
  barMinAngle: 0,
  large: false,
  largeThreshold: 400,
  progressive: 3e3,
  progressiveChunkMode: "mod",
  defaultBarGap: "10%"
};
Series_default.registerClass(BaseBarSeriesModel);
var BaseBarSeries_default = BaseBarSeriesModel;

// src/chart/bar/BarSeries.ts
var BarSeriesModel2 = class extends BaseBarSeries_default {
  constructor() {
    super(...arguments);
    this.type = BarSeriesModel2.type;
  }
  getInitialData() {
    return createSeriesData_default(null, this, {
      useEncodeDefaulter: true,
      createInvertedIndices: !!this.get("realtimeSort", true) || null
    });
  }
  getProgressive() {
    return this.get("large") ? this.get("progressive") : false;
  }
  getProgressiveThreshold() {
    let progressiveThreshold = this.get("progressiveThreshold");
    const largeThreshold = this.get("largeThreshold");
    if (largeThreshold > progressiveThreshold) {
      progressiveThreshold = largeThreshold;
    }
    return progressiveThreshold;
  }
  brushSelector(dataIndex, data, selectors) {
    return selectors.rect(data.getItemLayout(dataIndex));
  }
};
var BarSeriesModel = BarSeriesModel2;
BarSeriesModel.type = "series.bar";
BarSeriesModel.dependencies = ["grid", "polar"];
BarSeriesModel.defaultOption = inheritDefaultOption(BaseBarSeries_default.defaultOption, {
  clip: true,
  roundCap: false,
  showBackground: false,
  backgroundStyle: {
    color: "rgba(180, 180, 180, 0.2)",
    borderColor: null,
    borderWidth: 0,
    borderType: "solid",
    borderRadius: 0,
    shadowBlur: 0,
    shadowColor: null,
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    opacity: 1
  },
  select: {
    itemStyle: {
      borderColor: tokens_default.color.primary,
      borderWidth: 2
    }
  },
  realtimeSort: false
});
var BarSeries_default = BarSeriesModel;

// src/util/shape/sausage.ts
var SausageShape = class {
  constructor() {
    this.cx = 0;
    this.cy = 0;
    this.r0 = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
  }
};
var SausagePath = class extends Path_default {
  constructor(opts) {
    super(opts);
    this.type = "sausage";
  }
  getDefaultShape() {
    return new SausageShape();
  }
  buildPath(ctx, shape) {
    const cx = shape.cx;
    const cy = shape.cy;
    const r0 = Math.max(shape.r0 || 0, 0);
    const r = Math.max(shape.r, 0);
    const dr = (r - r0) * 0.5;
    const rCenter = r0 + dr;
    let startAngle = shape.startAngle;
    const endAngle = shape.endAngle;
    const clockwise = shape.clockwise;
    const PI210 = Math.PI * 2;
    const lessThanCircle = clockwise ? endAngle - startAngle < PI210 : startAngle - endAngle < PI210;
    if (!lessThanCircle) {
      startAngle = endAngle - (clockwise ? PI210 : -PI210);
    }
    const unitStartX = Math.cos(startAngle);
    const unitStartY = Math.sin(startAngle);
    const unitEndX = Math.cos(endAngle);
    const unitEndY = Math.sin(endAngle);
    if (lessThanCircle) {
      ctx.moveTo(unitStartX * r0 + cx, unitStartY * r0 + cy);
      ctx.arc(unitStartX * rCenter + cx, unitStartY * rCenter + cy, dr, -Math.PI + startAngle, startAngle, !clockwise);
    } else {
      ctx.moveTo(unitStartX * r + cx, unitStartY * r + cy);
    }
    ctx.arc(cx, cy, r, startAngle, endAngle, !clockwise);
    ctx.arc(unitEndX * rCenter + cx, unitEndY * rCenter + cy, dr, endAngle - Math.PI * 2, endAngle - Math.PI, !clockwise);
    if (r0 !== 0) {
      ctx.arc(cx, cy, r0, endAngle, startAngle, clockwise);
    }
  }
};
var sausage_default = SausagePath;

// src/label/sectorLabel.ts
function createSectorCalculateTextPosition(positionMapping, opts) {
  opts = opts || {};
  const isRoundCap = opts.isRoundCap;
  return function(out2, opts2, boundingRect) {
    const textPosition = opts2.position;
    if (!textPosition || textPosition instanceof Array) {
      return calculateTextPosition(out2, opts2, boundingRect);
    }
    const mappedSectorPosition = positionMapping(textPosition);
    const distance2 = opts2.distance != null ? opts2.distance : 5;
    const sector = this.shape;
    const cx = sector.cx;
    const cy = sector.cy;
    const r = sector.r;
    const r0 = sector.r0;
    const middleR = (r + r0) / 2;
    const startAngle = sector.startAngle;
    const endAngle = sector.endAngle;
    const middleAngle = (startAngle + endAngle) / 2;
    const extraDist = isRoundCap ? Math.abs(r - r0) / 2 : 0;
    const mathCos6 = Math.cos;
    const mathSin6 = Math.sin;
    let x = cx + r * mathCos6(startAngle);
    let y = cy + r * mathSin6(startAngle);
    let textAlign = "left";
    let textVerticalAlign = "top";
    switch (mappedSectorPosition) {
      case "startArc":
        x = cx + (r0 - distance2) * mathCos6(middleAngle);
        y = cy + (r0 - distance2) * mathSin6(middleAngle);
        textAlign = "center";
        textVerticalAlign = "top";
        break;
      case "insideStartArc":
        x = cx + (r0 + distance2) * mathCos6(middleAngle);
        y = cy + (r0 + distance2) * mathSin6(middleAngle);
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "startAngle":
        x = cx + middleR * mathCos6(startAngle) + adjustAngleDistanceX(startAngle, distance2 + extraDist, false);
        y = cy + middleR * mathSin6(startAngle) + adjustAngleDistanceY(startAngle, distance2 + extraDist, false);
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      case "insideStartAngle":
        x = cx + middleR * mathCos6(startAngle) + adjustAngleDistanceX(startAngle, -distance2 + extraDist, false);
        y = cy + middleR * mathSin6(startAngle) + adjustAngleDistanceY(startAngle, -distance2 + extraDist, false);
        textAlign = "left";
        textVerticalAlign = "middle";
        break;
      case "middle":
        x = cx + middleR * mathCos6(middleAngle);
        y = cy + middleR * mathSin6(middleAngle);
        textAlign = "center";
        textVerticalAlign = "middle";
        break;
      case "endArc":
        x = cx + (r + distance2) * mathCos6(middleAngle);
        y = cy + (r + distance2) * mathSin6(middleAngle);
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "insideEndArc":
        x = cx + (r - distance2) * mathCos6(middleAngle);
        y = cy + (r - distance2) * mathSin6(middleAngle);
        textAlign = "center";
        textVerticalAlign = "top";
        break;
      case "endAngle":
        x = cx + middleR * mathCos6(endAngle) + adjustAngleDistanceX(endAngle, distance2 + extraDist, true);
        y = cy + middleR * mathSin6(endAngle) + adjustAngleDistanceY(endAngle, distance2 + extraDist, true);
        textAlign = "left";
        textVerticalAlign = "middle";
        break;
      case "insideEndAngle":
        x = cx + middleR * mathCos6(endAngle) + adjustAngleDistanceX(endAngle, -distance2 + extraDist, true);
        y = cy + middleR * mathSin6(endAngle) + adjustAngleDistanceY(endAngle, -distance2 + extraDist, true);
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      default:
        return calculateTextPosition(out2, opts2, boundingRect);
    }
    out2 = out2 || {};
    out2.x = x;
    out2.y = y;
    out2.align = textAlign;
    out2.verticalAlign = textVerticalAlign;
    return out2;
  };
}
function setSectorTextRotation(sector, textPosition, positionMapping, rotateType) {
  if (isNumber(rotateType)) {
    sector.setTextConfig({
      rotation: rotateType
    });
    return;
  } else if (isArray(textPosition)) {
    sector.setTextConfig({
      rotation: 0
    });
    return;
  }
  const shape = sector.shape;
  const startAngle = shape.clockwise ? shape.startAngle : shape.endAngle;
  const endAngle = shape.clockwise ? shape.endAngle : shape.startAngle;
  const middleAngle = (startAngle + endAngle) / 2;
  let anchorAngle;
  const mappedSectorPosition = positionMapping(textPosition);
  switch (mappedSectorPosition) {
    case "startArc":
    case "insideStartArc":
    case "middle":
    case "insideEndArc":
    case "endArc":
      anchorAngle = middleAngle;
      break;
    case "startAngle":
    case "insideStartAngle":
      anchorAngle = startAngle;
      break;
    case "endAngle":
    case "insideEndAngle":
      anchorAngle = endAngle;
      break;
    default:
      sector.setTextConfig({
        rotation: 0
      });
      return;
  }
  let rotate2 = Math.PI * 1.5 - anchorAngle;
  if (mappedSectorPosition === "middle" && rotate2 > Math.PI / 2 && rotate2 < Math.PI * 1.5) {
    rotate2 -= Math.PI;
  }
  sector.setTextConfig({
    rotation: rotate2
  });
}
function adjustAngleDistanceX(angle, distance2, isEnd) {
  return distance2 * Math.sin(angle) * (isEnd ? -1 : 1);
}
function adjustAngleDistanceY(angle, distance2, isEnd) {
  return distance2 * Math.cos(angle) * (isEnd ? 1 : -1);
}

// src/chart/helper/sectorHelper.ts
function getSectorCornerRadius(model, shape, zeroIfNull) {
  let cornerRadius = model.get("borderRadius");
  if (cornerRadius == null) {
    return zeroIfNull ? {cornerRadius: 0} : null;
  }
  if (!isArray(cornerRadius)) {
    cornerRadius = [cornerRadius, cornerRadius, cornerRadius, cornerRadius];
  }
  const dr = Math.abs(shape.r || 0 - shape.r0 || 0);
  return {
    cornerRadius: map(cornerRadius, (cr) => parsePercent(cr, dr))
  };
}

// src/chart/bar/BarView.ts
var mathMax8 = Math.max;
var mathMin8 = Math.min;
function getClipArea(coord, data) {
  const coordSysClipArea = coord.getArea && coord.getArea();
  if (isCoordinateSystemType(coord, "cartesian2d")) {
    const baseAxis = coord.getBaseAxis();
    if (baseAxis.type !== "category" || !baseAxis.onBand) {
      const expandWidth = data.getLayout("bandWidth");
      if (baseAxis.isHorizontal()) {
        coordSysClipArea.x -= expandWidth;
        coordSysClipArea.width += expandWidth * 2;
      } else {
        coordSysClipArea.y -= expandWidth;
        coordSysClipArea.height += expandWidth * 2;
      }
    }
  }
  return coordSysClipArea;
}
var BarView2 = class extends Chart_default {
  constructor() {
    super();
    this.type = BarView2.type;
    this._isFirstFrame = true;
  }
  render(seriesModel, ecModel, api2, payload) {
    this._model = seriesModel;
    this._removeOnRenderedListener(api2);
    this._updateDrawMode(seriesModel);
    const coordinateSystemType = seriesModel.get("coordinateSystem");
    if (coordinateSystemType === "cartesian2d" || coordinateSystemType === "polar") {
      this._progressiveEls = null;
      this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api2) : this._renderNormal(seriesModel, ecModel, api2, payload);
    } else if (true) {
      warn("Only cartesian2d and polar supported for bar.");
    }
  }
  incrementalPrepareRender(seriesModel) {
    this._clear();
    this._updateDrawMode(seriesModel);
    this._updateLargeClip(seriesModel);
  }
  incrementalRender(params, seriesModel) {
    this._progressiveEls = [];
    this._incrementalRenderLarge(params, seriesModel);
  }
  eachRendered(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  }
  _updateDrawMode(seriesModel) {
    const isLargeDraw = seriesModel.pipelineContext.large;
    if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {
      this._isLargeDraw = isLargeDraw;
      this._clear();
    }
  }
  _renderNormal(seriesModel, ecModel, api2, payload) {
    const group = this.group;
    const data = seriesModel.getData();
    const oldData = this._data;
    const coord = seriesModel.coordinateSystem;
    const baseAxis = coord.getBaseAxis();
    let isHorizontalOrRadial;
    if (coord.type === "cartesian2d") {
      isHorizontalOrRadial = baseAxis.isHorizontal();
    } else if (coord.type === "polar") {
      isHorizontalOrRadial = baseAxis.dim === "angle";
    }
    const animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;
    const realtimeSortCfg = shouldRealtimeSort(seriesModel, coord);
    if (realtimeSortCfg) {
      this._enableRealtimeSort(realtimeSortCfg, data, api2);
    }
    const needsClip = seriesModel.get("clip", true) || realtimeSortCfg;
    const coordSysClipArea = getClipArea(coord, data);
    group.removeClipPath();
    const roundCap = seriesModel.get("roundCap", true);
    const drawBackground = seriesModel.get("showBackground", true);
    const backgroundModel = seriesModel.getModel("backgroundStyle");
    const barBorderRadius = backgroundModel.get("borderRadius") || 0;
    const bgEls = [];
    const oldBgEls = this._backgroundEls;
    const isInitSort = payload && payload.isInitSort;
    const isChangeOrder = payload && payload.type === "changeAxisOrder";
    function createBackground(dataIndex) {
      const bgLayout = getLayout[coord.type](data, dataIndex);
      if (!bgLayout) {
        return null;
      }
      const bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);
      bgEl.useStyle(backgroundModel.getItemStyle());
      if (coord.type === "cartesian2d") {
        bgEl.setShape("r", barBorderRadius);
      } else {
        bgEl.setShape("cornerRadius", barBorderRadius);
      }
      bgEls[dataIndex] = bgEl;
      return bgEl;
    }
    ;
    data.diff(oldData).add(function(dataIndex) {
      const itemModel = data.getItemModel(dataIndex);
      const layout14 = getLayout[coord.type](data, dataIndex, itemModel);
      if (!layout14) {
        return;
      }
      if (drawBackground) {
        createBackground(dataIndex);
      }
      if (!data.hasValue(dataIndex) || !isValidLayout[coord.type](layout14)) {
        return;
      }
      let isClipped = false;
      if (needsClip) {
        isClipped = clip[coord.type](coordSysClipArea, layout14);
      }
      const el = elementCreator[coord.type](seriesModel, data, dataIndex, layout14, isHorizontalOrRadial, animationModel, baseAxis.model, false, roundCap);
      if (realtimeSortCfg) {
        el.forceLabelAnimation = true;
      }
      updateStyle(el, data, dataIndex, itemModel, layout14, seriesModel, isHorizontalOrRadial, coord.type === "polar");
      if (isInitSort) {
        el.attr({shape: layout14});
      } else if (realtimeSortCfg) {
        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout14, dataIndex, isHorizontalOrRadial, false, false);
      } else {
        initProps(el, {shape: layout14}, seriesModel, dataIndex);
      }
      data.setItemGraphicEl(dataIndex, el);
      group.add(el);
      el.ignore = isClipped;
    }).update(function(newIndex, oldIndex) {
      const itemModel = data.getItemModel(newIndex);
      const layout14 = getLayout[coord.type](data, newIndex, itemModel);
      if (!layout14) {
        return;
      }
      if (drawBackground) {
        let bgEl;
        if (oldBgEls.length === 0) {
          bgEl = createBackground(oldIndex);
        } else {
          bgEl = oldBgEls[oldIndex];
          bgEl.useStyle(backgroundModel.getItemStyle());
          if (coord.type === "cartesian2d") {
            bgEl.setShape("r", barBorderRadius);
          } else {
            bgEl.setShape("cornerRadius", barBorderRadius);
          }
          bgEls[newIndex] = bgEl;
        }
        const bgLayout = getLayout[coord.type](data, newIndex);
        const shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);
        updateProps(bgEl, {shape}, animationModel, newIndex);
      }
      let el = oldData.getItemGraphicEl(oldIndex);
      if (!data.hasValue(newIndex) || !isValidLayout[coord.type](layout14)) {
        group.remove(el);
        return;
      }
      let isClipped = false;
      if (needsClip) {
        isClipped = clip[coord.type](coordSysClipArea, layout14);
        if (isClipped) {
          group.remove(el);
        }
      }
      const roundCapChanged = el && (el.type === "sector" && roundCap || el.type === "sausage" && !roundCap);
      if (roundCapChanged) {
        el && removeElementWithFadeOut(el, seriesModel, oldIndex);
        el = null;
      }
      if (!el) {
        el = elementCreator[coord.type](seriesModel, data, newIndex, layout14, isHorizontalOrRadial, animationModel, baseAxis.model, true, roundCap);
      } else {
        saveOldStyle(el);
      }
      if (realtimeSortCfg) {
        el.forceLabelAnimation = true;
      }
      if (isChangeOrder) {
        const textEl = el.getTextContent();
        if (textEl) {
          const labelInnerStore = labelInner(textEl);
          if (labelInnerStore.prevValue != null) {
            labelInnerStore.prevValue = labelInnerStore.value;
          }
        }
      } else {
        updateStyle(el, data, newIndex, itemModel, layout14, seriesModel, isHorizontalOrRadial, coord.type === "polar");
      }
      if (isInitSort) {
        el.attr({shape: layout14});
      } else if (realtimeSortCfg) {
        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout14, newIndex, isHorizontalOrRadial, true, isChangeOrder);
      } else {
        updateProps(el, {
          shape: layout14
        }, seriesModel, newIndex, null);
      }
      data.setItemGraphicEl(newIndex, el);
      el.ignore = isClipped;
      group.add(el);
    }).remove(function(dataIndex) {
      const el = oldData.getItemGraphicEl(dataIndex);
      el && removeElementWithFadeOut(el, seriesModel, dataIndex);
    }).execute();
    const bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group_default());
    bgGroup.removeAll();
    for (let i = 0; i < bgEls.length; ++i) {
      bgGroup.add(bgEls[i]);
    }
    group.add(bgGroup);
    this._backgroundEls = bgEls;
    this._data = data;
  }
  _renderLarge(seriesModel, ecModel, api2) {
    this._clear();
    createLarge(seriesModel, this.group);
    this._updateLargeClip(seriesModel);
  }
  _incrementalRenderLarge(params, seriesModel) {
    this._removeBackground();
    createLarge(seriesModel, this.group, this._progressiveEls, true);
  }
  _updateLargeClip(seriesModel) {
    const clipPath = seriesModel.get("clip", true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);
    const group = this.group;
    if (clipPath) {
      group.setClipPath(clipPath);
    } else {
      group.removeClipPath();
    }
  }
  _enableRealtimeSort(realtimeSortCfg, data, api2) {
    if (!data.count()) {
      return;
    }
    const baseAxis = realtimeSortCfg.baseAxis;
    if (this._isFirstFrame) {
      this._dispatchInitSort(data, realtimeSortCfg, api2);
      this._isFirstFrame = false;
    } else {
      const orderMapping = (idx) => {
        const el = data.getItemGraphicEl(idx);
        const shape = el && el.shape;
        return shape && Math.abs(baseAxis.isHorizontal() ? shape.height : shape.width) || 0;
      };
      this._onRendered = () => {
        this._updateSortWithinSameData(data, orderMapping, baseAxis, api2);
      };
      api2.getZr().on("rendered", this._onRendered);
    }
  }
  _dataSort(data, baseAxis, orderMapping) {
    const info = [];
    data.each(data.mapDimension(baseAxis.dim), (ordinalNumber, dataIdx) => {
      let mappedValue = orderMapping(dataIdx);
      mappedValue = mappedValue == null ? NaN : mappedValue;
      info.push({
        dataIndex: dataIdx,
        mappedValue,
        ordinalNumber
      });
    });
    info.sort((a, b) => {
      return b.mappedValue - a.mappedValue;
    });
    return {
      ordinalNumbers: map(info, (item) => item.ordinalNumber)
    };
  }
  _isOrderChangedWithinSameData(data, orderMapping, baseAxis) {
    const scale4 = baseAxis.scale;
    const ordinalDataDim = data.mapDimension(baseAxis.dim);
    let lastValue = Number.MAX_VALUE;
    for (let tickNum = 0, len2 = scale4.getOrdinalMeta().categories.length; tickNum < len2; ++tickNum) {
      const rawIdx = data.rawIndexOf(ordinalDataDim, scale4.getRawOrdinalNumber(tickNum));
      const value = rawIdx < 0 ? Number.MIN_VALUE : orderMapping(data.indexOfRawIndex(rawIdx));
      if (value > lastValue) {
        return true;
      }
      lastValue = value;
    }
    return false;
  }
  _isOrderDifferentInView(orderInfo, baseAxis) {
    const scale4 = baseAxis.scale;
    const extent = scale4.getExtent();
    let tickNum = Math.max(0, extent[0]);
    const tickMax = Math.min(extent[1], scale4.getOrdinalMeta().categories.length - 1);
    for (; tickNum <= tickMax; ++tickNum) {
      if (orderInfo.ordinalNumbers[tickNum] !== scale4.getRawOrdinalNumber(tickNum)) {
        return true;
      }
    }
  }
  _updateSortWithinSameData(data, orderMapping, baseAxis, api2) {
    if (!this._isOrderChangedWithinSameData(data, orderMapping, baseAxis)) {
      return;
    }
    const sortInfo = this._dataSort(data, baseAxis, orderMapping);
    if (this._isOrderDifferentInView(sortInfo, baseAxis)) {
      this._removeOnRenderedListener(api2);
      api2.dispatchAction({
        type: "changeAxisOrder",
        componentType: baseAxis.dim + "Axis",
        axisId: baseAxis.index,
        sortInfo
      });
    }
  }
  _dispatchInitSort(data, realtimeSortCfg, api2) {
    const baseAxis = realtimeSortCfg.baseAxis;
    const sortResult = this._dataSort(data, baseAxis, (dataIdx) => data.get(data.mapDimension(realtimeSortCfg.otherAxis.dim), dataIdx));
    api2.dispatchAction({
      type: "changeAxisOrder",
      componentType: baseAxis.dim + "Axis",
      isInitSort: true,
      axisId: baseAxis.index,
      sortInfo: sortResult
    });
  }
  remove(ecModel, api2) {
    this._clear(this._model);
    this._removeOnRenderedListener(api2);
  }
  dispose(ecModel, api2) {
    this._removeOnRenderedListener(api2);
  }
  _removeOnRenderedListener(api2) {
    if (this._onRendered) {
      api2.getZr().off("rendered", this._onRendered);
      this._onRendered = null;
    }
  }
  _clear(model) {
    const group = this.group;
    const data = this._data;
    if (model && model.isAnimationEnabled() && data && !this._isLargeDraw) {
      this._removeBackground();
      this._backgroundEls = [];
      data.eachItemGraphicEl(function(el) {
        removeElementWithFadeOut(el, model, getECData(el).dataIndex);
      });
    } else {
      group.removeAll();
    }
    this._data = null;
    this._isFirstFrame = true;
  }
  _removeBackground() {
    this.group.remove(this._backgroundGroup);
    this._backgroundGroup = null;
  }
};
var BarView = BarView2;
BarView.type = "bar";
var clip = {
  cartesian2d(coordSysBoundingRect, layout14) {
    const signWidth = layout14.width < 0 ? -1 : 1;
    const signHeight = layout14.height < 0 ? -1 : 1;
    if (signWidth < 0) {
      layout14.x += layout14.width;
      layout14.width = -layout14.width;
    }
    if (signHeight < 0) {
      layout14.y += layout14.height;
      layout14.height = -layout14.height;
    }
    const coordSysX2 = coordSysBoundingRect.x + coordSysBoundingRect.width;
    const coordSysY2 = coordSysBoundingRect.y + coordSysBoundingRect.height;
    const x = mathMax8(layout14.x, coordSysBoundingRect.x);
    const x2 = mathMin8(layout14.x + layout14.width, coordSysX2);
    const y = mathMax8(layout14.y, coordSysBoundingRect.y);
    const y2 = mathMin8(layout14.y + layout14.height, coordSysY2);
    const xClipped = x2 < x;
    const yClipped = y2 < y;
    layout14.x = xClipped && x > coordSysX2 ? x2 : x;
    layout14.y = yClipped && y > coordSysY2 ? y2 : y;
    layout14.width = xClipped ? 0 : x2 - x;
    layout14.height = yClipped ? 0 : y2 - y;
    if (signWidth < 0) {
      layout14.x += layout14.width;
      layout14.width = -layout14.width;
    }
    if (signHeight < 0) {
      layout14.y += layout14.height;
      layout14.height = -layout14.height;
    }
    return xClipped || yClipped;
  },
  polar(coordSysClipArea, layout14) {
    const signR = layout14.r0 <= layout14.r ? 1 : -1;
    if (signR < 0) {
      const tmp = layout14.r;
      layout14.r = layout14.r0;
      layout14.r0 = tmp;
    }
    const r = mathMin8(layout14.r, coordSysClipArea.r);
    const r0 = mathMax8(layout14.r0, coordSysClipArea.r0);
    layout14.r = r;
    layout14.r0 = r0;
    const clipped = r - r0 < 0;
    if (signR < 0) {
      const tmp = layout14.r;
      layout14.r = layout14.r0;
      layout14.r0 = tmp;
    }
    return clipped;
  }
};
var elementCreator = {
  cartesian2d(seriesModel, data, newIndex, layout14, isHorizontal, animationModel, axisModel, isUpdate, roundCap) {
    const rect = new Rect_default({
      shape: extend({}, layout14),
      z2: 1
    });
    rect.__dataIndex = newIndex;
    rect.name = "item";
    if (animationModel) {
      const rectShape = rect.shape;
      const animateProperty = isHorizontal ? "height" : "width";
      rectShape[animateProperty] = 0;
    }
    return rect;
  },
  polar(seriesModel, data, newIndex, layout14, isRadial, animationModel, axisModel, isUpdate, roundCap) {
    const ShapeClass = !isRadial && roundCap ? sausage_default : Sector_default;
    const sector = new ShapeClass({
      shape: layout14,
      z2: 1
    });
    sector.name = "item";
    const positionMap = createPolarPositionMapping(isRadial);
    sector.calculateTextPosition = createSectorCalculateTextPosition(positionMap, {
      isRoundCap: ShapeClass === sausage_default
    });
    if (animationModel) {
      const sectorShape = sector.shape;
      const animateProperty = isRadial ? "r" : "endAngle";
      const animateTarget = {};
      sectorShape[animateProperty] = isRadial ? layout14.r0 : layout14.startAngle;
      animateTarget[animateProperty] = layout14[animateProperty];
      (isUpdate ? updateProps : initProps)(sector, {
        shape: animateTarget
      }, animationModel);
    }
    return sector;
  }
};
function shouldRealtimeSort(seriesModel, coordSys) {
  const realtimeSortOption = seriesModel.get("realtimeSort", true);
  const baseAxis = coordSys.getBaseAxis();
  if (true) {
    if (realtimeSortOption) {
      if (baseAxis.type !== "category") {
        warn("`realtimeSort` will not work because this bar series is not based on a category axis.");
      }
      if (coordSys.type !== "cartesian2d") {
        warn("`realtimeSort` will not work because this bar series is not on cartesian2d.");
      }
    }
  }
  if (realtimeSortOption && baseAxis.type === "category" && coordSys.type === "cartesian2d") {
    return {
      baseAxis,
      otherAxis: coordSys.getOtherAxis(baseAxis)
    };
  }
}
function updateRealtimeAnimation(realtimeSortCfg, seriesAnimationModel, el, layout14, newIndex, isHorizontal, isUpdate, isChangeOrder) {
  let seriesTarget;
  let axisTarget;
  if (isHorizontal) {
    axisTarget = {
      x: layout14.x,
      width: layout14.width
    };
    seriesTarget = {
      y: layout14.y,
      height: layout14.height
    };
  } else {
    axisTarget = {
      y: layout14.y,
      height: layout14.height
    };
    seriesTarget = {
      x: layout14.x,
      width: layout14.width
    };
  }
  if (!isChangeOrder) {
    (isUpdate ? updateProps : initProps)(el, {
      shape: seriesTarget
    }, seriesAnimationModel, newIndex, null);
  }
  const axisAnimationModel = seriesAnimationModel ? realtimeSortCfg.baseAxis.model : null;
  (isUpdate ? updateProps : initProps)(el, {
    shape: axisTarget
  }, axisAnimationModel, newIndex);
}
function checkPropertiesNotValid(obj, props) {
  for (let i = 0; i < props.length; i++) {
    if (!isFinite(obj[props[i]])) {
      return true;
    }
  }
  return false;
}
var rectPropties = ["x", "y", "width", "height"];
var polarPropties = ["cx", "cy", "r", "startAngle", "endAngle"];
var isValidLayout = {
  cartesian2d(layout14) {
    return !checkPropertiesNotValid(layout14, rectPropties);
  },
  polar(layout14) {
    return !checkPropertiesNotValid(layout14, polarPropties);
  }
};
var getLayout = {
  cartesian2d(data, dataIndex, itemModel) {
    const layout14 = data.getItemLayout(dataIndex);
    if (!layout14) {
      return null;
    }
    const fixedLineWidth = itemModel ? getLineWidth(itemModel, layout14) : 0;
    const signX = layout14.width > 0 ? 1 : -1;
    const signY = layout14.height > 0 ? 1 : -1;
    return {
      x: layout14.x + signX * fixedLineWidth / 2,
      y: layout14.y + signY * fixedLineWidth / 2,
      width: layout14.width - signX * fixedLineWidth,
      height: layout14.height - signY * fixedLineWidth
    };
  },
  polar(data, dataIndex, itemModel) {
    const layout14 = data.getItemLayout(dataIndex);
    return {
      cx: layout14.cx,
      cy: layout14.cy,
      r0: layout14.r0,
      r: layout14.r,
      startAngle: layout14.startAngle,
      endAngle: layout14.endAngle,
      clockwise: layout14.clockwise
    };
  }
};
function isZeroOnPolar(layout14) {
  return layout14.startAngle != null && layout14.endAngle != null && layout14.startAngle === layout14.endAngle;
}
function createPolarPositionMapping(isRadial) {
  return ((isRadial2) => {
    const arcOrAngle = isRadial2 ? "Arc" : "Angle";
    return (position2) => {
      switch (position2) {
        case "start":
        case "insideStart":
        case "end":
        case "insideEnd":
          return position2 + arcOrAngle;
        default:
          return position2;
      }
    };
  })(isRadial);
}
function updateStyle(el, data, dataIndex, itemModel, layout14, seriesModel, isHorizontalOrRadial, isPolar) {
  const style = data.getItemVisual(dataIndex, "style");
  if (!isPolar) {
    const borderRadius = itemModel.get(["itemStyle", "borderRadius"]) || 0;
    el.setShape("r", borderRadius);
  } else if (!seriesModel.get("roundCap")) {
    const sectorShape = el.shape;
    const cornerRadius = getSectorCornerRadius(itemModel.getModel("itemStyle"), sectorShape, true);
    extend(sectorShape, cornerRadius);
    el.setShape(sectorShape);
  }
  el.useStyle(style);
  const cursorStyle = itemModel.getShallow("cursor");
  cursorStyle && el.attr("cursor", cursorStyle);
  const labelPositionOutside = isPolar ? isHorizontalOrRadial ? layout14.r >= layout14.r0 ? "endArc" : "startArc" : layout14.endAngle >= layout14.startAngle ? "endAngle" : "startAngle" : isHorizontalOrRadial ? layout14.height >= 0 ? "bottom" : "top" : layout14.width >= 0 ? "right" : "left";
  const labelStatesModels = getLabelStatesModels(itemModel);
  setLabelStyle(el, labelStatesModels, {
    labelFetcher: seriesModel,
    labelDataIndex: dataIndex,
    defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),
    inheritColor: style.fill,
    defaultOpacity: style.opacity,
    defaultOutsidePosition: labelPositionOutside
  });
  const label = el.getTextContent();
  if (isPolar && label) {
    const position2 = itemModel.get(["label", "position"]);
    el.textConfig.inside = position2 === "middle" ? true : null;
    setSectorTextRotation(el, position2 === "outside" ? labelPositionOutside : position2, createPolarPositionMapping(isHorizontalOrRadial), itemModel.get(["label", "rotate"]));
  }
  setLabelValueAnimation(label, labelStatesModels, seriesModel.getRawValue(dataIndex), (value) => getDefaultInterpolatedLabel(data, value));
  const emphasisModel = itemModel.getModel(["emphasis"]);
  toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  setStatesStylesFromModel(el, itemModel);
  if (isZeroOnPolar(layout14)) {
    el.style.fill = "none";
    el.style.stroke = "none";
    each(el.states, (state) => {
      if (state.style) {
        state.style.fill = state.style.stroke = "none";
      }
    });
  }
}
function getLineWidth(itemModel, rawLayout) {
  const borderColor = itemModel.get(["itemStyle", "borderColor"]);
  if (!borderColor || borderColor === "none") {
    return 0;
  }
  const lineWidth = itemModel.get(["itemStyle", "borderWidth"]) || 0;
  const width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);
  const height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);
  return Math.min(lineWidth, width, height);
}
var LagePathShape = class {
};
var LargePath = class extends Path_default {
  constructor(opts) {
    super(opts);
    this.type = "largeBar";
  }
  getDefaultShape() {
    return new LagePathShape();
  }
  buildPath(ctx, shape) {
    const points4 = shape.points;
    const baseDimIdx = this.baseDimIdx;
    const valueDimIdx = 1 - this.baseDimIdx;
    const startPoint = [];
    const size = [];
    const barWidth = this.barWidth;
    for (let i = 0; i < points4.length; i += 3) {
      size[baseDimIdx] = barWidth;
      size[valueDimIdx] = points4[i + 2];
      startPoint[baseDimIdx] = points4[i + baseDimIdx];
      startPoint[valueDimIdx] = points4[i + valueDimIdx];
      ctx.rect(startPoint[0], startPoint[1], size[0], size[1]);
    }
  }
};
function createLarge(seriesModel, group, progressiveEls, incremental) {
  const data = seriesModel.getData();
  const baseDimIdx = data.getLayout("valueAxisHorizontal") ? 1 : 0;
  const largeDataIndices = data.getLayout("largeDataIndices");
  const barWidth = data.getLayout("size");
  const backgroundModel = seriesModel.getModel("backgroundStyle");
  const bgPoints = data.getLayout("largeBackgroundPoints");
  if (bgPoints) {
    const bgEl = new LargePath({
      shape: {
        points: bgPoints
      },
      incremental: !!incremental,
      silent: true,
      z2: 0
    });
    bgEl.baseDimIdx = baseDimIdx;
    bgEl.largeDataIndices = largeDataIndices;
    bgEl.barWidth = barWidth;
    bgEl.useStyle(backgroundModel.getItemStyle());
    group.add(bgEl);
    progressiveEls && progressiveEls.push(bgEl);
  }
  const el = new LargePath({
    shape: {points: data.getLayout("largePoints")},
    incremental: !!incremental,
    ignoreCoarsePointer: true,
    z2: 1
  });
  el.baseDimIdx = baseDimIdx;
  el.largeDataIndices = largeDataIndices;
  el.barWidth = barWidth;
  group.add(el);
  el.useStyle(data.getVisual("style"));
  el.style.stroke = null;
  getECData(el).seriesIndex = seriesModel.seriesIndex;
  if (!seriesModel.get("silent")) {
    el.on("mousedown", largePathUpdateDataIndex);
    el.on("mousemove", largePathUpdateDataIndex);
  }
  progressiveEls && progressiveEls.push(el);
}
var largePathUpdateDataIndex = throttle(function(event) {
  const largePath = this;
  const dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);
  getECData(largePath).dataIndex = dataIndex >= 0 ? dataIndex : null;
}, 30, false);
function largePathFindDataIndex(largePath, x, y) {
  const baseDimIdx = largePath.baseDimIdx;
  const valueDimIdx = 1 - baseDimIdx;
  const points4 = largePath.shape.points;
  const largeDataIndices = largePath.largeDataIndices;
  const startPoint = [];
  const size = [];
  const barWidth = largePath.barWidth;
  for (let i = 0, len2 = points4.length / 3; i < len2; i++) {
    const ii = i * 3;
    size[baseDimIdx] = barWidth;
    size[valueDimIdx] = points4[ii + 2];
    startPoint[baseDimIdx] = points4[ii + baseDimIdx];
    startPoint[valueDimIdx] = points4[ii + valueDimIdx];
    if (size[valueDimIdx] < 0) {
      startPoint[valueDimIdx] += size[valueDimIdx];
      size[valueDimIdx] = -size[valueDimIdx];
    }
    if (x >= startPoint[0] && x <= startPoint[0] + size[0] && y >= startPoint[1] && y <= startPoint[1] + size[1]) {
      return largeDataIndices[i];
    }
  }
  return -1;
}
function createBackgroundShape(isHorizontalOrRadial, layout14, coord) {
  if (isCoordinateSystemType(coord, "cartesian2d")) {
    const rectShape = layout14;
    const coordLayout = coord.getArea();
    return {
      x: isHorizontalOrRadial ? rectShape.x : coordLayout.x,
      y: isHorizontalOrRadial ? coordLayout.y : rectShape.y,
      width: isHorizontalOrRadial ? rectShape.width : coordLayout.width,
      height: isHorizontalOrRadial ? coordLayout.height : rectShape.height
    };
  } else {
    const coordLayout = coord.getArea();
    const sectorShape = layout14;
    return {
      cx: coordLayout.cx,
      cy: coordLayout.cy,
      r0: isHorizontalOrRadial ? coordLayout.r0 : sectorShape.r0,
      r: isHorizontalOrRadial ? coordLayout.r : sectorShape.r,
      startAngle: isHorizontalOrRadial ? sectorShape.startAngle : 0,
      endAngle: isHorizontalOrRadial ? sectorShape.endAngle : Math.PI * 2
    };
  }
}
function createBackgroundEl(coord, isHorizontalOrRadial, layout14) {
  const ElementClz = coord.type === "polar" ? Sector_default : Rect_default;
  return new ElementClz({
    shape: createBackgroundShape(isHorizontalOrRadial, layout14, coord),
    silent: true,
    z2: 0
  });
}
var BarView_default = BarView;

// src/chart/bar/install.ts
function install4(registers) {
  registers.registerChartView(BarView_default);
  registers.registerSeriesModel(BarSeries_default);
  registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, curry(layout2, "bar"));
  registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("bar"));
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample("bar"));
  registers.registerAction({
    type: "changeAxisOrder",
    event: "changeAxisOrder",
    update: "update"
  }, function(payload, ecModel) {
    const componentType = payload.componentType || "series";
    ecModel.eachComponent({mainType: componentType, query: payload}, function(componentModel) {
      if (payload.sortInfo) {
        componentModel.axis.setCategorySortInfo(payload.sortInfo);
      }
    });
  });
}

// src/chart/pie/pieLayout.ts
var PI29 = Math.PI * 2;
var RADIAN = Math.PI / 180;
function pieLayout(seriesType2, ecModel, api2) {
  ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
    const data = seriesModel.getData();
    const valueDim = data.mapDimension("value");
    const {cx, cy, r, r0, viewRect: viewRect2} = getCircleLayout(seriesModel, api2);
    let startAngle = -seriesModel.get("startAngle") * RADIAN;
    let endAngle = seriesModel.get("endAngle");
    const padAngle = seriesModel.get("padAngle") * RADIAN;
    endAngle = endAngle === "auto" ? startAngle - PI29 : -endAngle * RADIAN;
    const minAngle = seriesModel.get("minAngle") * RADIAN;
    const minAndPadAngle = minAngle + padAngle;
    let validDataCount = 0;
    data.each(valueDim, function(value) {
      !isNaN(value) && validDataCount++;
    });
    const sum2 = data.getSum(valueDim);
    let unitRadian = Math.PI / (sum2 || validDataCount) * 2;
    const clockwise = seriesModel.get("clockwise");
    const roseType = seriesModel.get("roseType");
    const stillShowZeroSum = seriesModel.get("stillShowZeroSum");
    const extent = data.getDataExtent(valueDim);
    extent[0] = 0;
    const dir3 = clockwise ? 1 : -1;
    const angles = [startAngle, endAngle];
    const halfPadAngle = dir3 * padAngle / 2;
    normalizeArcAngles(angles, !clockwise);
    [startAngle, endAngle] = angles;
    const layoutData = getSeriesLayoutData(seriesModel);
    layoutData.startAngle = startAngle;
    layoutData.endAngle = endAngle;
    layoutData.clockwise = clockwise;
    layoutData.cx = cx;
    layoutData.cy = cy;
    layoutData.r = r;
    layoutData.r0 = r0;
    const angleRange = Math.abs(endAngle - startAngle);
    let restAngle = angleRange;
    let valueSumLargerThanMinAngle = 0;
    let currentAngle = startAngle;
    data.setLayout({viewRect: viewRect2, r});
    data.each(valueDim, function(value, idx) {
      let angle;
      if (isNaN(value)) {
        data.setItemLayout(idx, {
          angle: NaN,
          startAngle: NaN,
          endAngle: NaN,
          clockwise,
          cx,
          cy,
          r0,
          r: roseType ? NaN : r
        });
        return;
      }
      if (roseType !== "area") {
        angle = sum2 === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
      } else {
        angle = angleRange / validDataCount;
      }
      if (angle < minAndPadAngle) {
        angle = minAndPadAngle;
        restAngle -= minAndPadAngle;
      } else {
        valueSumLargerThanMinAngle += value;
      }
      const endAngle2 = currentAngle + dir3 * angle;
      let actualStartAngle = 0;
      let actualEndAngle = 0;
      if (padAngle > angle) {
        actualStartAngle = currentAngle + dir3 * angle / 2;
        actualEndAngle = actualStartAngle;
      } else {
        actualStartAngle = currentAngle + halfPadAngle;
        actualEndAngle = endAngle2 - halfPadAngle;
      }
      data.setItemLayout(idx, {
        angle,
        startAngle: actualStartAngle,
        endAngle: actualEndAngle,
        clockwise,
        cx,
        cy,
        r0,
        r: roseType ? linearMap(value, extent, [r0, r]) : r
      });
      currentAngle = endAngle2;
    });
    if (restAngle < PI29 && validDataCount) {
      if (restAngle <= 1e-3) {
        const angle = angleRange / validDataCount;
        data.each(valueDim, function(value, idx) {
          if (!isNaN(value)) {
            const layout14 = data.getItemLayout(idx);
            layout14.angle = angle;
            let actualStartAngle = 0;
            let actualEndAngle = 0;
            if (angle < padAngle) {
              actualStartAngle = startAngle + dir3 * (idx + 1 / 2) * angle;
              actualEndAngle = actualStartAngle;
            } else {
              actualStartAngle = startAngle + dir3 * idx * angle + halfPadAngle;
              actualEndAngle = startAngle + dir3 * (idx + 1) * angle - halfPadAngle;
            }
            layout14.startAngle = actualStartAngle;
            layout14.endAngle = actualEndAngle;
          }
        });
      } else {
        unitRadian = restAngle / valueSumLargerThanMinAngle;
        currentAngle = startAngle;
        data.each(valueDim, function(value, idx) {
          if (!isNaN(value)) {
            const layout14 = data.getItemLayout(idx);
            const angle = layout14.angle === minAndPadAngle ? minAndPadAngle : value * unitRadian;
            let actualStartAngle = 0;
            let actualEndAngle = 0;
            if (angle < padAngle) {
              actualStartAngle = currentAngle + dir3 * angle / 2;
              actualEndAngle = actualStartAngle;
            } else {
              actualStartAngle = currentAngle + halfPadAngle;
              actualEndAngle = currentAngle + dir3 * angle - halfPadAngle;
            }
            layout14.startAngle = actualStartAngle;
            layout14.endAngle = actualEndAngle;
            currentAngle += dir3 * angle;
          }
        });
      }
    }
  });
}
var getSeriesLayoutData = makeInner();

// src/processor/dataFilter.ts
function dataFilter(seriesType2) {
  return {
    seriesType: seriesType2,
    reset: function(seriesModel, ecModel) {
      const legendModels = ecModel.findComponents({
        mainType: "legend"
      });
      if (!legendModels || !legendModels.length) {
        return;
      }
      const data = seriesModel.getData();
      data.filterSelf(function(idx) {
        const name = data.getName(idx);
        for (let i = 0; i < legendModels.length; i++) {
          if (!legendModels[i].isSelected(name)) {
            return false;
          }
        }
        return true;
      });
    }
  };
}

// src/chart/pie/labelLayout.ts
var RADIAN2 = Math.PI / 180;
function adjustSingleSide(list, cx, cy, r, dir3, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {
  if (list.length < 2) {
    return;
  }
  ;
  function recalculateXOnSemiToAlignOnEllipseCurve(semi) {
    const rB = semi.rB;
    const rB2 = rB * rB;
    for (let i = 0; i < semi.list.length; i++) {
      const item = semi.list[i];
      const dy = Math.abs(item.label.y - cy);
      const rA = r + item.len;
      const rA2 = rA * rA;
      const dx = Math.sqrt(Math.abs((1 - dy * dy / rB2) * rA2));
      const newX = cx + (dx + item.len2) * dir3;
      const deltaX = newX - item.label.x;
      const newTargetWidth = item.targetTextWidth - deltaX * dir3;
      constrainTextWidth(item, newTargetWidth, true);
      item.label.x = newX;
    }
  }
  function recalculateX(items) {
    const topSemi = {list: [], maxY: 0};
    const bottomSemi = {list: [], maxY: 0};
    for (let i = 0; i < items.length; i++) {
      if (items[i].labelAlignTo !== "none") {
        continue;
      }
      const item = items[i];
      const semi = item.label.y > cy ? bottomSemi : topSemi;
      const dy = Math.abs(item.label.y - cy);
      if (dy >= semi.maxY) {
        const dx = item.label.x - cx - item.len2 * dir3;
        const rA = r + item.len;
        const rB = Math.abs(dx) < rA ? Math.sqrt(dy * dy / (1 - dx * dx / rA / rA)) : rA;
        semi.rB = rB;
        semi.maxY = dy;
      }
      semi.list.push(item);
    }
    recalculateXOnSemiToAlignOnEllipseCurve(topSemi);
    recalculateXOnSemiToAlignOnEllipseCurve(bottomSemi);
  }
  const len2 = list.length;
  for (let i = 0; i < len2; i++) {
    if (list[i].position === "outer" && list[i].labelAlignTo === "labelLine") {
      const dx = list[i].label.x - farthestX;
      list[i].linePoints[1][0] += dx;
      list[i].label.x = farthestX;
    }
  }
  if (shiftLayoutOnY(list, viewTop, viewTop + viewHeight)) {
    recalculateX(list);
  }
}
function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop) {
  const leftList = [];
  const rightList = [];
  let leftmostX = Number.MAX_VALUE;
  let rightmostX = -Number.MAX_VALUE;
  for (let i = 0; i < labelLayoutList.length; i++) {
    const label = labelLayoutList[i].label;
    if (isPositionCenter(labelLayoutList[i])) {
      continue;
    }
    if (label.x < cx) {
      leftmostX = Math.min(leftmostX, label.x);
      leftList.push(labelLayoutList[i]);
    } else {
      rightmostX = Math.max(rightmostX, label.x);
      rightList.push(labelLayoutList[i]);
    }
  }
  for (let i = 0; i < labelLayoutList.length; i++) {
    const layout14 = labelLayoutList[i];
    if (!isPositionCenter(layout14) && layout14.linePoints) {
      if (layout14.labelStyleWidth != null) {
        continue;
      }
      const label = layout14.label;
      const linePoints = layout14.linePoints;
      let targetTextWidth;
      if (layout14.labelAlignTo === "edge") {
        if (label.x < cx) {
          targetTextWidth = linePoints[2][0] - layout14.labelDistance - viewLeft - layout14.edgeDistance;
        } else {
          targetTextWidth = viewLeft + viewWidth - layout14.edgeDistance - linePoints[2][0] - layout14.labelDistance;
        }
      } else if (layout14.labelAlignTo === "labelLine") {
        if (label.x < cx) {
          targetTextWidth = leftmostX - viewLeft - layout14.bleedMargin;
        } else {
          targetTextWidth = viewLeft + viewWidth - rightmostX - layout14.bleedMargin;
        }
      } else {
        if (label.x < cx) {
          targetTextWidth = label.x - viewLeft - layout14.bleedMargin;
        } else {
          targetTextWidth = viewLeft + viewWidth - label.x - layout14.bleedMargin;
        }
      }
      layout14.targetTextWidth = targetTextWidth;
      constrainTextWidth(layout14, targetTextWidth);
    }
  }
  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);
  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);
  for (let i = 0; i < labelLayoutList.length; i++) {
    const layout14 = labelLayoutList[i];
    if (!isPositionCenter(layout14) && layout14.linePoints) {
      const label = layout14.label;
      const linePoints = layout14.linePoints;
      const isAlignToEdge = layout14.labelAlignTo === "edge";
      const padding = label.style.padding;
      const paddingH = padding ? padding[1] + padding[3] : 0;
      const extraPaddingH = label.style.backgroundColor ? 0 : paddingH;
      const realTextWidth = layout14.rect.width + extraPaddingH;
      const dist3 = linePoints[1][0] - linePoints[2][0];
      if (isAlignToEdge) {
        if (label.x < cx) {
          linePoints[2][0] = viewLeft + layout14.edgeDistance + realTextWidth + layout14.labelDistance;
        } else {
          linePoints[2][0] = viewLeft + viewWidth - layout14.edgeDistance - realTextWidth - layout14.labelDistance;
        }
      } else {
        if (label.x < cx) {
          linePoints[2][0] = label.x + layout14.labelDistance;
        } else {
          linePoints[2][0] = label.x - layout14.labelDistance;
        }
        linePoints[1][0] = linePoints[2][0] + dist3;
      }
      linePoints[1][1] = linePoints[2][1] = label.y;
    }
  }
}
function constrainTextWidth(layout14, availableWidth, forceRecalculate = false) {
  if (layout14.labelStyleWidth != null) {
    return;
  }
  const label = layout14.label;
  const style = label.style;
  const textRect = layout14.rect;
  const bgColor = style.backgroundColor;
  const padding = style.padding;
  const paddingH = padding ? padding[1] + padding[3] : 0;
  const overflow = style.overflow;
  const oldOuterWidth = textRect.width + (bgColor ? 0 : paddingH);
  if (availableWidth < oldOuterWidth || forceRecalculate) {
    const oldHeight = textRect.height;
    if (overflow && overflow.match("break")) {
      label.setStyle("backgroundColor", null);
      label.setStyle("width", availableWidth - paddingH);
      const innerRect = label.getBoundingRect();
      label.setStyle("width", Math.ceil(innerRect.width));
      label.setStyle("backgroundColor", bgColor);
    } else {
      const availableInnerWidth = availableWidth - paddingH;
      const newWidth = availableWidth < oldOuterWidth ? availableInnerWidth : forceRecalculate ? availableInnerWidth > layout14.unconstrainedWidth ? null : availableInnerWidth : null;
      label.setStyle("width", newWidth);
    }
    const newRect = label.getBoundingRect();
    textRect.width = newRect.width;
    const margin = (label.style.margin || 0) + 2.1;
    textRect.height = newRect.height + margin;
    textRect.y -= (textRect.height - oldHeight) / 2;
  }
}
function isPositionCenter(sectorShape) {
  return sectorShape.position === "center";
}
function pieLabelLayout(seriesModel) {
  const data = seriesModel.getData();
  const labelLayoutList = [];
  let cx;
  let cy;
  let hasLabelRotate = false;
  const minShowLabelRadian = (seriesModel.get("minShowLabelAngle") || 0) * RADIAN2;
  const viewRect2 = data.getLayout("viewRect");
  const r = data.getLayout("r");
  const viewWidth = viewRect2.width;
  const viewLeft = viewRect2.x;
  const viewTop = viewRect2.y;
  const viewHeight = viewRect2.height;
  function setNotShow(el) {
    el.ignore = true;
  }
  function isLabelShown(label) {
    if (!label.ignore) {
      return true;
    }
    for (const key in label.states) {
      if (label.states[key].ignore === false) {
        return true;
      }
    }
    return false;
  }
  data.each(function(idx) {
    const sector = data.getItemGraphicEl(idx);
    const sectorShape = sector.shape;
    const label = sector.getTextContent();
    const labelLine = sector.getTextGuideLine();
    const itemModel = data.getItemModel(idx);
    const labelModel = itemModel.getModel("label");
    const labelPosition = labelModel.get("position") || itemModel.get(["emphasis", "label", "position"]);
    const labelDistance = labelModel.get("distanceToLabelLine");
    const labelAlignTo = labelModel.get("alignTo");
    const edgeDistance = parsePercent2(labelModel.get("edgeDistance"), viewWidth);
    let bleedMargin = labelModel.get("bleedMargin");
    if (bleedMargin == null) {
      bleedMargin = Math.min(viewWidth, viewHeight) > 200 ? 10 : 2;
    }
    const labelLineModel = itemModel.getModel("labelLine");
    let labelLineLen = labelLineModel.get("length");
    labelLineLen = parsePercent2(labelLineLen, viewWidth);
    let labelLineLen2 = labelLineModel.get("length2");
    labelLineLen2 = parsePercent2(labelLineLen2, viewWidth);
    if (Math.abs(sectorShape.endAngle - sectorShape.startAngle) < minShowLabelRadian) {
      each(label.states, setNotShow);
      label.ignore = true;
      if (labelLine) {
        each(labelLine.states, setNotShow);
        labelLine.ignore = true;
      }
      return;
    }
    if (!isLabelShown(label)) {
      return;
    }
    const midAngle = (sectorShape.startAngle + sectorShape.endAngle) / 2;
    const nx = Math.cos(midAngle);
    const ny = Math.sin(midAngle);
    let textX;
    let textY;
    let linePoints;
    let textAlign;
    cx = sectorShape.cx;
    cy = sectorShape.cy;
    const isLabelInside = labelPosition === "inside" || labelPosition === "inner";
    if (labelPosition === "center") {
      textX = sectorShape.cx;
      textY = sectorShape.cy;
      textAlign = "center";
    } else {
      const x1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * nx : sectorShape.r * nx) + cx;
      const y1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * ny : sectorShape.r * ny) + cy;
      textX = x1 + nx * 3;
      textY = y1 + ny * 3;
      if (!isLabelInside) {
        const x2 = x1 + nx * (labelLineLen + r - sectorShape.r);
        const y2 = y1 + ny * (labelLineLen + r - sectorShape.r);
        const x3 = x2 + (nx < 0 ? -1 : 1) * labelLineLen2;
        const y3 = y2;
        if (labelAlignTo === "edge") {
          textX = nx < 0 ? viewLeft + edgeDistance : viewLeft + viewWidth - edgeDistance;
        } else {
          textX = x3 + (nx < 0 ? -labelDistance : labelDistance);
        }
        textY = y3;
        linePoints = [[x1, y1], [x2, y2], [x3, y3]];
      }
      textAlign = isLabelInside ? "center" : labelAlignTo === "edge" ? nx > 0 ? "right" : "left" : nx > 0 ? "left" : "right";
    }
    const PI11 = Math.PI;
    let labelRotate = 0;
    const rotate2 = labelModel.get("rotate");
    if (isNumber(rotate2)) {
      labelRotate = rotate2 * (PI11 / 180);
    } else if (labelPosition === "center") {
      labelRotate = 0;
    } else if (rotate2 === "radial" || rotate2 === true) {
      const radialAngle = nx < 0 ? -midAngle + PI11 : -midAngle;
      labelRotate = radialAngle;
    } else if (rotate2 === "tangential" && labelPosition !== "outside" && labelPosition !== "outer") {
      let rad = Math.atan2(nx, ny);
      if (rad < 0) {
        rad = PI11 * 2 + rad;
      }
      const isDown = ny > 0;
      if (isDown) {
        rad = PI11 + rad;
      }
      labelRotate = rad - PI11;
    }
    hasLabelRotate = !!labelRotate;
    label.x = textX;
    label.y = textY;
    label.rotation = labelRotate;
    label.setStyle({
      verticalAlign: "middle"
    });
    if (!isLabelInside) {
      const textRect = label.getBoundingRect().clone();
      textRect.applyTransform(label.getComputedTransform());
      const margin = (label.style.margin || 0) + 2.1;
      textRect.y -= margin / 2;
      textRect.height += margin;
      labelLayoutList.push({
        label,
        labelLine,
        position: labelPosition,
        len: labelLineLen,
        len2: labelLineLen2,
        minTurnAngle: labelLineModel.get("minTurnAngle"),
        maxSurfaceAngle: labelLineModel.get("maxSurfaceAngle"),
        surfaceNormal: new Point_default(nx, ny),
        linePoints,
        textAlign,
        labelDistance,
        labelAlignTo,
        edgeDistance,
        bleedMargin,
        rect: textRect,
        unconstrainedWidth: textRect.width,
        labelStyleWidth: label.style.width
      });
    } else {
      label.setStyle({
        align: textAlign
      });
      const selectState = label.states.select;
      if (selectState) {
        selectState.x += label.x;
        selectState.y += label.y;
      }
    }
    sector.setTextConfig({
      inside: isLabelInside
    });
  });
  if (!hasLabelRotate && seriesModel.get("avoidLabelOverlap")) {
    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop);
  }
  for (let i = 0; i < labelLayoutList.length; i++) {
    const layout14 = labelLayoutList[i];
    const label = layout14.label;
    const labelLine = layout14.labelLine;
    const notShowLabel = isNaN(label.x) || isNaN(label.y);
    if (label) {
      label.setStyle({
        align: layout14.textAlign
      });
      if (notShowLabel) {
        each(label.states, setNotShow);
        label.ignore = true;
      }
      const selectState = label.states.select;
      if (selectState) {
        selectState.x += label.x;
        selectState.y += label.y;
      }
    }
    if (labelLine) {
      const linePoints = layout14.linePoints;
      if (notShowLabel || !linePoints) {
        each(labelLine.states, setNotShow);
        labelLine.ignore = true;
      } else {
        limitTurnAngle(linePoints, layout14.minTurnAngle);
        limitSurfaceAngle(linePoints, layout14.surfaceNormal, layout14.maxSurfaceAngle);
        labelLine.setShape({points: linePoints});
        label.__hostTarget.textGuideLineConfig = {
          anchor: new Point_default(linePoints[0][0], linePoints[0][1])
        };
      }
    }
  }
}

// src/chart/pie/PieView.ts
var PiePiece = class extends Sector_default {
  constructor(data, idx, startAngle) {
    super();
    this.z2 = 2;
    const text = new Text_default();
    this.setTextContent(text);
    this.updateData(data, idx, startAngle, true);
  }
  updateData(data, idx, startAngle, firstCreate) {
    const sector = this;
    const seriesModel = data.hostModel;
    const itemModel = data.getItemModel(idx);
    const emphasisModel = itemModel.getModel("emphasis");
    const layout14 = data.getItemLayout(idx);
    const sectorShape = extend(getSectorCornerRadius(itemModel.getModel("itemStyle"), layout14, true), layout14);
    if (isNaN(sectorShape.startAngle)) {
      sector.setShape(sectorShape);
      return;
    }
    if (firstCreate) {
      sector.setShape(sectorShape);
      const animationType = seriesModel.getShallow("animationType");
      if (seriesModel.ecModel.ssr) {
        initProps(sector, {
          scaleX: 0,
          scaleY: 0
        }, seriesModel, {dataIndex: idx, isFrom: true});
        sector.originX = sectorShape.cx;
        sector.originY = sectorShape.cy;
      } else if (animationType === "scale") {
        sector.shape.r = layout14.r0;
        initProps(sector, {
          shape: {
            r: layout14.r
          }
        }, seriesModel, idx);
      } else {
        if (startAngle != null) {
          sector.setShape({startAngle, endAngle: startAngle});
          initProps(sector, {
            shape: {
              startAngle: layout14.startAngle,
              endAngle: layout14.endAngle
            }
          }, seriesModel, idx);
        } else {
          sector.shape.endAngle = layout14.startAngle;
          updateProps(sector, {
            shape: {
              endAngle: layout14.endAngle
            }
          }, seriesModel, idx);
        }
      }
    } else {
      saveOldStyle(sector);
      updateProps(sector, {
        shape: sectorShape
      }, seriesModel, idx);
    }
    sector.useStyle(data.getItemVisual(idx, "style"));
    setStatesStylesFromModel(sector, itemModel);
    const midAngle = (layout14.startAngle + layout14.endAngle) / 2;
    const offset = seriesModel.get("selectedOffset");
    const dx = Math.cos(midAngle) * offset;
    const dy = Math.sin(midAngle) * offset;
    const cursorStyle = itemModel.getShallow("cursor");
    cursorStyle && sector.attr("cursor", cursorStyle);
    this._updateLabel(seriesModel, data, idx);
    sector.ensureState("emphasis").shape = extend({
      r: layout14.r + (emphasisModel.get("scale") ? emphasisModel.get("scaleSize") || 0 : 0)
    }, getSectorCornerRadius(emphasisModel.getModel("itemStyle"), layout14));
    extend(sector.ensureState("select"), {
      x: dx,
      y: dy,
      shape: getSectorCornerRadius(itemModel.getModel(["select", "itemStyle"]), layout14)
    });
    extend(sector.ensureState("blur"), {
      shape: getSectorCornerRadius(itemModel.getModel(["blur", "itemStyle"]), layout14)
    });
    const labelLine = sector.getTextGuideLine();
    const labelText = sector.getTextContent();
    labelLine && extend(labelLine.ensureState("select"), {
      x: dx,
      y: dy
    });
    extend(labelText.ensureState("select"), {
      x: dx,
      y: dy
    });
    toggleHoverEmphasis(this, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  }
  _updateLabel(seriesModel, data, idx) {
    const sector = this;
    const itemModel = data.getItemModel(idx);
    const labelLineModel = itemModel.getModel("labelLine");
    const style = data.getItemVisual(idx, "style");
    const visualColor = style && style.fill;
    const visualOpacity = style && style.opacity;
    setLabelStyle(sector, getLabelStatesModels(itemModel), {
      labelFetcher: data.hostModel,
      labelDataIndex: idx,
      inheritColor: visualColor,
      defaultOpacity: visualOpacity,
      defaultText: seriesModel.getFormattedLabel(idx, "normal") || data.getName(idx)
    });
    const labelText = sector.getTextContent();
    sector.setTextConfig({
      position: null,
      rotation: null
    });
    labelText.attr({
      z2: 10
    });
    const labelPosition = itemModel.get(["label", "position"]);
    if (labelPosition !== "outside" && labelPosition !== "outer") {
      sector.removeTextGuideLine();
    } else {
      let polyline = this.getTextGuideLine();
      if (!polyline) {
        polyline = new Polyline_default();
        this.setTextGuideLine(polyline);
      }
      setLabelLineStyle(this, getLabelLineStatesModels(itemModel), {
        stroke: visualColor,
        opacity: retrieve3(labelLineModel.get(["lineStyle", "opacity"]), visualOpacity, 1)
      });
    }
  }
};
var PieView = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.ignoreLabelLineUpdate = true;
  }
  render(seriesModel, ecModel, api2, payload) {
    const data = seriesModel.getData();
    const oldData = this._data;
    const group = this.group;
    let startAngle;
    if (!oldData && data.count() > 0) {
      let shape = data.getItemLayout(0);
      for (let s = 1; isNaN(shape && shape.startAngle) && s < data.count(); ++s) {
        shape = data.getItemLayout(s);
      }
      if (shape) {
        startAngle = shape.startAngle;
      }
    }
    if (this._emptyCircleSector) {
      group.remove(this._emptyCircleSector);
    }
    if (data.count() === 0 && seriesModel.get("showEmptyCircle")) {
      const layoutData = getSeriesLayoutData(seriesModel);
      const sector = new Sector_default({
        shape: clone(layoutData)
      });
      sector.useStyle(seriesModel.getModel("emptyCircleStyle").getItemStyle());
      this._emptyCircleSector = sector;
      group.add(sector);
    }
    data.diff(oldData).add(function(idx) {
      const piePiece = new PiePiece(data, idx, startAngle);
      data.setItemGraphicEl(idx, piePiece);
      group.add(piePiece);
    }).update(function(newIdx, oldIdx) {
      const piePiece = oldData.getItemGraphicEl(oldIdx);
      piePiece.updateData(data, newIdx, startAngle);
      piePiece.off("click");
      group.add(piePiece);
      data.setItemGraphicEl(newIdx, piePiece);
    }).remove(function(idx) {
      const piePiece = oldData.getItemGraphicEl(idx);
      removeElementWithFadeOut(piePiece, seriesModel, idx);
    }).execute();
    pieLabelLayout(seriesModel);
    if (seriesModel.get("animationTypeUpdate") !== "expansion") {
      this._data = data;
    }
  }
  dispose() {
  }
  containPoint(point, seriesModel) {
    const data = seriesModel.getData();
    const itemLayout = data.getItemLayout(0);
    if (itemLayout) {
      const dx = point[0] - itemLayout.cx;
      const dy = point[1] - itemLayout.cy;
      const radius = Math.sqrt(dx * dx + dy * dy);
      return radius <= itemLayout.r && radius >= itemLayout.r0;
    }
  }
};
PieView.type = "pie";
var PieView_default = PieView;

// src/chart/helper/createSeriesDataSimply.ts
function createSeriesDataSimply(seriesModel, opt, nameList) {
  opt = isArray(opt) && {
    coordDimensions: opt
  } || extend({
    encodeDefine: seriesModel.getEncode()
  }, opt);
  const source = seriesModel.getSource();
  const {dimensions} = prepareSeriesDataSchema(source, opt);
  const list = new SeriesData_default(dimensions, seriesModel);
  list.initData(source, nameList);
  return list;
}

// src/visual/LegendVisualProvider.ts
var LegendVisualProvider = class {
  constructor(getDataWithEncodedVisual, getRawData2) {
    this._getDataWithEncodedVisual = getDataWithEncodedVisual;
    this._getRawData = getRawData2;
  }
  getAllNames() {
    const rawData = this._getRawData();
    return rawData.mapArray(rawData.getName);
  }
  containName(name) {
    const rawData = this._getRawData();
    return rawData.indexOfName(name) >= 0;
  }
  indexOfName(name) {
    const dataWithEncodedVisual = this._getDataWithEncodedVisual();
    return dataWithEncodedVisual.indexOfName(name);
  }
  getItemVisual(dataIndex, key) {
    const dataWithEncodedVisual = this._getDataWithEncodedVisual();
    return dataWithEncodedVisual.getItemVisual(dataIndex, key);
  }
};
var LegendVisualProvider_default = LegendVisualProvider;

// src/chart/pie/PieSeries.ts
var innerData = makeInner();
var PieSeriesModel = class extends Series_default {
  init(option) {
    super.init.apply(this, arguments);
    this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this));
    this._defaultLabelLine(option);
  }
  mergeOption() {
    super.mergeOption.apply(this, arguments);
  }
  getInitialData() {
    return createSeriesDataSimply(this, {
      coordDimensions: ["value"],
      encodeDefaulter: curry(makeSeriesEncodeForNameBased, this)
    });
  }
  getDataParams(dataIndex) {
    const data = this.getData();
    const dataInner = innerData(data);
    let seats = dataInner.seats;
    if (!seats) {
      const valueList = [];
      data.each(data.mapDimension("value"), function(value) {
        valueList.push(value);
      });
      seats = dataInner.seats = getPercentSeats(valueList, data.hostModel.get("percentPrecision"));
    }
    const params = super.getDataParams(dataIndex);
    params.percent = seats[dataIndex] || 0;
    params.$vars.push("percent");
    return params;
  }
  _defaultLabelLine(option) {
    defaultEmphasis(option, "labelLine", ["show"]);
    const labelLineNormalOpt = option.labelLine;
    const labelLineEmphasisOpt = option.emphasis.labelLine;
    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
  }
};
PieSeriesModel.type = "series.pie";
PieSeriesModel.defaultOption = {
  z: 2,
  legendHoverLink: true,
  colorBy: "data",
  center: ["50%", "50%"],
  radius: [0, "50%"],
  clockwise: true,
  startAngle: 90,
  endAngle: "auto",
  padAngle: 0,
  minAngle: 0,
  minShowLabelAngle: 0,
  selectedOffset: 10,
  percentPrecision: 2,
  stillShowZeroSum: true,
  coordinateSystemUsage: "box",
  left: 0,
  top: 0,
  right: 0,
  bottom: 0,
  width: null,
  height: null,
  label: {
    rotate: 0,
    show: true,
    overflow: "truncate",
    position: "outer",
    alignTo: "none",
    edgeDistance: "25%",
    distanceToLabelLine: 5
  },
  labelLine: {
    show: true,
    length: 15,
    length2: 30,
    smooth: false,
    minTurnAngle: 90,
    maxSurfaceAngle: 90,
    lineStyle: {
      width: 1,
      type: "solid"
    }
  },
  itemStyle: {
    borderWidth: 1,
    borderJoin: "round"
  },
  showEmptyCircle: true,
  emptyCircleStyle: {
    color: "lightgray",
    opacity: 1
  },
  labelLayout: {
    hideOverlap: true
  },
  emphasis: {
    scale: true,
    scaleSize: 5
  },
  avoidLabelOverlap: true,
  animationType: "expansion",
  animationDuration: 1e3,
  animationTypeUpdate: "transition",
  animationEasingUpdate: "cubicInOut",
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut"
};
registerLayOutOnCoordSysUsage({
  fullType: PieSeriesModel.type,
  getCoord2(model) {
    return model.getShallow("center");
  }
});
var PieSeries_default = PieSeriesModel;

// src/processor/negativeDataFilter.ts
function negativeDataFilter(seriesType2) {
  return {
    seriesType: seriesType2,
    reset: function(seriesModel, ecModel) {
      const data = seriesModel.getData();
      data.filterSelf(function(idx) {
        const valueDim = data.mapDimension("value");
        const curValue = data.get(valueDim, idx);
        if (isNumber(curValue) && !isNaN(curValue) && curValue < 0) {
          return false;
        }
        return true;
      });
    }
  };
}

// src/chart/pie/install.ts
function install5(registers) {
  registers.registerChartView(PieView_default);
  registers.registerSeriesModel(PieSeries_default);
  createLegacyDataSelectAction("pie", registers.registerAction);
  registers.registerLayout(curry(pieLayout, "pie"));
  registers.registerProcessor(dataFilter("pie"));
  registers.registerProcessor(negativeDataFilter("pie"));
}

// src/chart/scatter/ScatterSeries.ts
var ScatterSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = ScatterSeriesModel2.type;
    this.hasSymbolVisual = true;
  }
  getInitialData(option, ecModel) {
    return createSeriesData_default(null, this, {
      useEncodeDefaulter: true
    });
  }
  getProgressive() {
    const progressive = this.option.progressive;
    if (progressive == null) {
      return this.option.large ? 5e3 : this.get("progressive");
    }
    return progressive;
  }
  getProgressiveThreshold() {
    const progressiveThreshold = this.option.progressiveThreshold;
    if (progressiveThreshold == null) {
      return this.option.large ? 1e4 : this.get("progressiveThreshold");
    }
    return progressiveThreshold;
  }
  brushSelector(dataIndex, data, selectors) {
    return selectors.point(data.getItemLayout(dataIndex));
  }
  getZLevelKey() {
    return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
  }
};
var ScatterSeriesModel = ScatterSeriesModel2;
ScatterSeriesModel.type = "series.scatter";
ScatterSeriesModel.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar", "matrix"];
ScatterSeriesModel.defaultOption = {
  coordinateSystem: "cartesian2d",
  z: 2,
  legendHoverLink: true,
  symbolSize: 10,
  large: false,
  largeThreshold: 2e3,
  itemStyle: {
    opacity: 0.8
  },
  emphasis: {
    scale: true
  },
  clip: true,
  select: {
    itemStyle: {
      borderColor: tokens_default.color.primary
    }
  },
  universalTransition: {
    divideShape: "clone"
  }
};
var ScatterSeries_default = ScatterSeriesModel;

// src/chart/helper/LargeSymbolDraw.ts
var BOOST_SIZE_THRESHOLD = 4;
var LargeSymbolPathShape = class {
};
var LargeSymbolPath = class extends Path_default {
  constructor(opts) {
    super(opts);
    this._off = 0;
    this.hoverDataIdx = -1;
  }
  getDefaultShape() {
    return new LargeSymbolPathShape();
  }
  reset() {
    this.notClear = false;
    this._off = 0;
  }
  buildPath(path, shape) {
    const points4 = shape.points;
    const size = shape.size;
    const symbolProxy = this.symbolProxy;
    const symbolProxyShape = symbolProxy.shape;
    const ctx = path.getContext ? path.getContext() : path;
    const canBoost = ctx && size[0] < BOOST_SIZE_THRESHOLD;
    const softClipShape = this.softClipShape;
    let i;
    if (canBoost) {
      this._ctx = ctx;
      return;
    }
    this._ctx = null;
    for (i = this._off; i < points4.length; ) {
      const x = points4[i++];
      const y = points4[i++];
      if (isNaN(x) || isNaN(y)) {
        continue;
      }
      if (softClipShape && !softClipShape.contain(x, y)) {
        continue;
      }
      symbolProxyShape.x = x - size[0] / 2;
      symbolProxyShape.y = y - size[1] / 2;
      symbolProxyShape.width = size[0];
      symbolProxyShape.height = size[1];
      symbolProxy.buildPath(path, symbolProxyShape, true);
    }
    if (this.incremental) {
      this._off = i;
      this.notClear = true;
    }
  }
  afterBrush() {
    const shape = this.shape;
    const points4 = shape.points;
    const size = shape.size;
    const ctx = this._ctx;
    const softClipShape = this.softClipShape;
    let i;
    if (!ctx) {
      return;
    }
    for (i = this._off; i < points4.length; ) {
      const x = points4[i++];
      const y = points4[i++];
      if (isNaN(x) || isNaN(y)) {
        continue;
      }
      if (softClipShape && !softClipShape.contain(x, y)) {
        continue;
      }
      ctx.fillRect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]);
    }
    if (this.incremental) {
      this._off = i;
      this.notClear = true;
    }
  }
  findDataIndex(x, y) {
    const shape = this.shape;
    const points4 = shape.points;
    const size = shape.size;
    const w = Math.max(size[0], 4);
    const h = Math.max(size[1], 4);
    for (let idx = points4.length / 2 - 1; idx >= 0; idx--) {
      const i = idx * 2;
      const x0 = points4[i] - w / 2;
      const y0 = points4[i + 1] - h / 2;
      if (x >= x0 && y >= y0 && x <= x0 + w && y <= y0 + h) {
        return idx;
      }
    }
    return -1;
  }
  contain(x, y) {
    const localPos = this.transformCoordToLocal(x, y);
    const rect = this.getBoundingRect();
    x = localPos[0];
    y = localPos[1];
    if (rect.contain(x, y)) {
      const dataIdx = this.hoverDataIdx = this.findDataIndex(x, y);
      return dataIdx >= 0;
    }
    this.hoverDataIdx = -1;
    return false;
  }
  getBoundingRect() {
    let rect = this._rect;
    if (!rect) {
      const shape = this.shape;
      const points4 = shape.points;
      const size = shape.size;
      const w = size[0];
      const h = size[1];
      let minX = Infinity;
      let minY = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      for (let i = 0; i < points4.length; ) {
        const x = points4[i++];
        const y = points4[i++];
        minX = Math.min(x, minX);
        maxX = Math.max(x, maxX);
        minY = Math.min(y, minY);
        maxY = Math.max(y, maxY);
      }
      rect = this._rect = new BoundingRect_default(minX - w / 2, minY - h / 2, maxX - minX + w, maxY - minY + h);
    }
    return rect;
  }
};
var LargeSymbolDraw = class {
  constructor() {
    this.group = new Group_default();
  }
  updateData(data, opt) {
    this._clear();
    const symbolEl = this._create();
    symbolEl.setShape({
      points: data.getLayout("points")
    });
    this._setCommon(symbolEl, data, opt);
  }
  updateLayout(data) {
    let points4 = data.getLayout("points");
    this.group.eachChild(function(child) {
      if (child.startIndex != null) {
        const len2 = (child.endIndex - child.startIndex) * 2;
        const byteOffset = child.startIndex * 4 * 2;
        points4 = new Float32Array(points4.buffer, byteOffset, len2);
      }
      child.setShape("points", points4);
      child.reset();
    });
  }
  incrementalPrepareUpdate(data) {
    this._clear();
  }
  incrementalUpdate(taskParams, data, opt) {
    const lastAdded = this._newAdded[0];
    const points4 = data.getLayout("points");
    const oldPoints = lastAdded && lastAdded.shape.points;
    if (oldPoints && oldPoints.length < 2e4) {
      const oldLen = oldPoints.length;
      const newPoints = new Float32Array(oldLen + points4.length);
      newPoints.set(oldPoints);
      newPoints.set(points4, oldLen);
      lastAdded.endIndex = taskParams.end;
      lastAdded.setShape({points: newPoints});
    } else {
      this._newAdded = [];
      const symbolEl = this._create();
      symbolEl.startIndex = taskParams.start;
      symbolEl.endIndex = taskParams.end;
      symbolEl.incremental = true;
      symbolEl.setShape({
        points: points4
      });
      this._setCommon(symbolEl, data, opt);
    }
  }
  eachRendered(cb) {
    this._newAdded[0] && cb(this._newAdded[0]);
  }
  _create() {
    const symbolEl = new LargeSymbolPath({
      cursor: "default"
    });
    symbolEl.ignoreCoarsePointer = true;
    this.group.add(symbolEl);
    this._newAdded.push(symbolEl);
    return symbolEl;
  }
  _setCommon(symbolEl, data, opt) {
    const hostModel = data.hostModel;
    opt = opt || {};
    const size = data.getVisual("symbolSize");
    symbolEl.setShape("size", size instanceof Array ? size : [size, size]);
    symbolEl.softClipShape = opt.clipShape || null;
    symbolEl.symbolProxy = createSymbol(data.getVisual("symbol"), 0, 0, 0, 0);
    symbolEl.setColor = symbolEl.symbolProxy.setColor;
    const extrudeShadow = symbolEl.shape.size[0] < BOOST_SIZE_THRESHOLD;
    symbolEl.useStyle(hostModel.getModel("itemStyle").getItemStyle(extrudeShadow ? ["color", "shadowBlur", "shadowColor"] : ["color"]));
    const globalStyle = data.getVisual("style");
    const visualColor = globalStyle && globalStyle.fill;
    if (visualColor) {
      symbolEl.setColor(visualColor);
    }
    const ecData = getECData(symbolEl);
    ecData.seriesIndex = hostModel.seriesIndex;
    symbolEl.on("mousemove", function(e2) {
      ecData.dataIndex = null;
      const dataIndex = symbolEl.hoverDataIdx;
      if (dataIndex >= 0) {
        ecData.dataIndex = dataIndex + (symbolEl.startIndex || 0);
      }
    });
  }
  remove() {
    this._clear();
  }
  _clear() {
    this._newAdded = [];
    this.group.removeAll();
  }
};
var LargeSymbolDraw_default = LargeSymbolDraw;

// src/chart/scatter/ScatterView.ts
var ScatterView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = ScatterView2.type;
  }
  render(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    const symbolDraw = this._updateSymbolDraw(data, seriesModel);
    symbolDraw.updateData(data, {
      clipShape: this._getClipShape(seriesModel)
    });
    this._finished = true;
  }
  incrementalPrepareRender(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    const symbolDraw = this._updateSymbolDraw(data, seriesModel);
    symbolDraw.incrementalPrepareUpdate(data);
    this._finished = false;
  }
  incrementalRender(taskParams, seriesModel, ecModel) {
    this._symbolDraw.incrementalUpdate(taskParams, seriesModel.getData(), {
      clipShape: this._getClipShape(seriesModel)
    });
    this._finished = taskParams.end === seriesModel.getData().count();
  }
  updateTransform(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    this.group.dirty();
    if (!this._finished || data.count() > 1e4) {
      return {
        update: true
      };
    } else {
      const res = pointsLayout("").reset(seriesModel, ecModel, api2);
      if (res.progress) {
        res.progress({start: 0, end: data.count(), count: data.count()}, data);
      }
      this._symbolDraw.updateLayout(data);
    }
  }
  eachRendered(cb) {
    this._symbolDraw && this._symbolDraw.eachRendered(cb);
  }
  _getClipShape(seriesModel) {
    if (!seriesModel.get("clip", true)) {
      return;
    }
    const coordSys = seriesModel.coordinateSystem;
    return coordSys && coordSys.getArea && coordSys.getArea(0.1);
  }
  _updateSymbolDraw(data, seriesModel) {
    let symbolDraw = this._symbolDraw;
    const pipelineContext = seriesModel.pipelineContext;
    const isLargeDraw = pipelineContext.large;
    if (!symbolDraw || isLargeDraw !== this._isLargeDraw) {
      symbolDraw && symbolDraw.remove();
      symbolDraw = this._symbolDraw = isLargeDraw ? new LargeSymbolDraw_default() : new SymbolDraw_default();
      this._isLargeDraw = isLargeDraw;
      this.group.removeAll();
    }
    this.group.add(symbolDraw.group);
    return symbolDraw;
  }
  remove(ecModel, api2) {
    this._symbolDraw && this._symbolDraw.remove(true);
    this._symbolDraw = null;
  }
  dispose() {
  }
};
var ScatterView = ScatterView2;
ScatterView.type = "scatter";
var ScatterView_default = ScatterView;

// src/coord/cartesian/GridModel.ts
var OUTER_BOUNDS_DEFAULT = {left: 0, right: 0, top: 0, bottom: 0};
var OUTER_BOUNDS_CLAMP_DEFAULT = ["25%", "25%"];
var GridModel = class extends Component_default {
  mergeDefaultAndTheme(option, ecModel) {
    const outerBoundsCp = getLayoutParams(option.outerBounds);
    super.mergeDefaultAndTheme.apply(this, arguments);
    if (outerBoundsCp && option.outerBounds) {
      mergeLayoutParam(option.outerBounds, outerBoundsCp);
    }
  }
  mergeOption(newOption, ecModel) {
    super.mergeOption.apply(this, arguments);
    if (this.option.outerBounds && newOption.outerBounds) {
      mergeLayoutParam(this.option.outerBounds, newOption.outerBounds);
    }
  }
};
GridModel.type = "grid";
GridModel.dependencies = ["xAxis", "yAxis"];
GridModel.layoutMode = "box";
GridModel.defaultOption = {
  show: false,
  z: 0,
  left: "15%",
  top: 65,
  right: "10%",
  bottom: 80,
  containLabel: false,
  outerBoundsMode: "auto",
  outerBounds: OUTER_BOUNDS_DEFAULT,
  outerBoundsContain: "all",
  outerBoundsClampWidth: OUTER_BOUNDS_CLAMP_DEFAULT[0],
  outerBoundsClampHeight: OUTER_BOUNDS_CLAMP_DEFAULT[1],
  backgroundColor: tokens_default.color.transparent,
  borderWidth: 1,
  borderColor: tokens_default.color.neutral30
};
var GridModel_default = GridModel;

// src/coord/cartesian/AxisModel.ts
var CartesianAxisModel = class extends Component_default {
  getCoordSysModel() {
    return this.getReferringComponents("grid", SINGLE_REFERRING).models[0];
  }
};
CartesianAxisModel.type = "cartesian2dAxis";
mixin(CartesianAxisModel, AxisModelCommonMixin);

// src/coord/axisDefault.ts
var defaultOption = {
  show: true,
  z: 0,
  inverse: false,
  name: "",
  nameLocation: "end",
  nameRotate: null,
  nameTruncate: {
    maxWidth: null,
    ellipsis: "...",
    placeholder: "."
  },
  nameTextStyle: {},
  nameGap: 15,
  silent: false,
  triggerEvent: false,
  tooltip: {
    show: false
  },
  axisPointer: {},
  axisLine: {
    show: true,
    onZero: true,
    onZeroAxisIndex: null,
    lineStyle: {
      color: tokens_default.color.axisLine,
      width: 1,
      type: "solid"
    },
    symbol: ["none", "none"],
    symbolSize: [10, 15],
    breakLine: true
  },
  axisTick: {
    show: true,
    inside: false,
    length: 5,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: true,
    inside: false,
    rotate: 0,
    showMinLabel: null,
    showMaxLabel: null,
    margin: 8,
    fontSize: 12,
    color: tokens_default.color.axisLabel,
    textMargin: [0, 3]
  },
  splitLine: {
    show: true,
    showMinLine: true,
    showMaxLine: true,
    lineStyle: {
      color: tokens_default.color.axisSplitLine,
      width: 1,
      type: "solid"
    }
  },
  splitArea: {
    show: false,
    areaStyle: {
      color: [
        tokens_default.color.backgroundTint,
        tokens_default.color.backgroundTransparent
      ]
    }
  },
  breakArea: {
    show: true,
    itemStyle: {
      color: tokens_default.color.neutral00,
      borderColor: tokens_default.color.border,
      borderWidth: 1,
      borderType: [3, 3],
      opacity: 0.6
    },
    zigzagAmplitude: 4,
    zigzagMinSpan: 4,
    zigzagMaxSpan: 20,
    zigzagZ: 100,
    expandOnClick: true
  },
  breakLabelLayout: {
    moveOverlap: "auto"
  }
};
var categoryAxis = merge({
  boundaryGap: true,
  deduplication: null,
  jitter: 0,
  jitterOverlap: true,
  jitterMargin: 2,
  splitLine: {
    show: false
  },
  axisTick: {
    alignWithLabel: false,
    interval: "auto",
    show: "auto"
  },
  axisLabel: {
    interval: "auto"
  }
}, defaultOption);
var valueAxis = merge({
  boundaryGap: [0, 0],
  axisLine: {
    show: "auto"
  },
  axisTick: {
    show: "auto"
  },
  splitNumber: 5,
  minorTick: {
    show: false,
    splitNumber: 5,
    length: 3,
    lineStyle: {}
  },
  minorSplitLine: {
    show: false,
    lineStyle: {
      color: tokens_default.color.axisMinorSplitLine,
      width: 1
    }
  }
}, defaultOption);
var timeAxis = merge({
  splitNumber: 6,
  axisLabel: {
    showMinLabel: false,
    showMaxLabel: false,
    rich: {
      primary: {
        fontWeight: "bold"
      }
    }
  },
  splitLine: {
    show: false
  }
}, valueAxis);
var logAxis = defaults({
  logBase: 10
}, valueAxis);
var axisDefault_default = {
  category: categoryAxis,
  value: valueAxis,
  time: timeAxis,
  log: logAxis
};

// src/coord/axisCommonTypes.ts
var AXIS_TYPES = {value: 1, category: 1, time: 1, log: 1};

// src/component/axis/axisBreakHelper.ts
var _impl2 = null;
function registerAxisBreakHelperImpl(impl) {
  if (!_impl2) {
    _impl2 = impl;
  }
}
function getAxisBreakHelper() {
  return _impl2;
}

// src/coord/axisModelCreator.ts
function axisModelCreator(registers, axisName, BaseAxisModelClass, extraDefaultOption) {
  each(AXIS_TYPES, function(v, axisType) {
    const defaultOption3 = merge(merge({}, axisDefault_default[axisType], true), extraDefaultOption, true);
    class AxisModel extends BaseAxisModelClass {
      constructor() {
        super(...arguments);
        this.type = axisName + "Axis." + axisType;
      }
      mergeDefaultAndTheme(option, ecModel) {
        const layoutMode = fetchLayoutMode(this);
        const inputPositionParams = layoutMode ? getLayoutParams(option) : {};
        const themeModel = ecModel.getTheme();
        merge(option, themeModel.get(axisType + "Axis"));
        merge(option, this.getDefaultOption());
        option.type = getAxisType(option);
        if (layoutMode) {
          mergeLayoutParam(option, inputPositionParams, layoutMode);
        }
      }
      optionUpdated() {
        const thisOption = this.option;
        if (thisOption.type === "category") {
          this.__ordinalMeta = OrdinalMeta_default.createByAxisModel(this);
        }
      }
      getCategories(rawData) {
        const option = this.option;
        if (option.type === "category") {
          if (rawData) {
            return option.data;
          }
          return this.__ordinalMeta.categories;
        }
      }
      getOrdinalMeta() {
        return this.__ordinalMeta;
      }
      updateAxisBreaks(payload) {
        const axisBreakHelper = getAxisBreakHelper();
        return axisBreakHelper ? axisBreakHelper.updateModelAxisBreak(this, payload) : {breaks: []};
      }
    }
    AxisModel.type = axisName + "Axis." + axisType;
    AxisModel.defaultOption = defaultOption3;
    registers.registerComponentModel(AxisModel);
  });
  registers.registerSubTypeDefaulter(axisName + "Axis", getAxisType);
}
function getAxisType(option) {
  return option.type || (option.data ? "category" : "value");
}

// src/coord/cartesian/Cartesian.ts
var Cartesian = class {
  constructor(name) {
    this.type = "cartesian";
    this._dimList = [];
    this._axes = {};
    this.name = name || "";
  }
  getAxis(dim) {
    return this._axes[dim];
  }
  getAxes() {
    return map(this._dimList, function(dim) {
      return this._axes[dim];
    }, this);
  }
  getAxesByScale(scaleType) {
    scaleType = scaleType.toLowerCase();
    return filter(this.getAxes(), function(axis) {
      return axis.scale.type === scaleType;
    });
  }
  addAxis(axis) {
    const dim = axis.dim;
    this._axes[dim] = axis;
    this._dimList.push(dim);
  }
};
var Cartesian_default = Cartesian;

// src/coord/cartesian/Cartesian2D.ts
var cartesian2DDimensions = ["x", "y"];
function canCalculateAffineTransform(scale4) {
  return (scale4.type === "interval" || scale4.type === "time") && !scale4.hasBreaks();
}
var Cartesian2D = class extends Cartesian_default {
  constructor() {
    super(...arguments);
    this.type = "cartesian2d";
    this.dimensions = cartesian2DDimensions;
  }
  calcAffineTransform() {
    this._transform = this._invTransform = null;
    const xAxisScale = this.getAxis("x").scale;
    const yAxisScale = this.getAxis("y").scale;
    if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {
      return;
    }
    const xScaleExtent = xAxisScale.getExtent();
    const yScaleExtent = yAxisScale.getExtent();
    const start2 = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);
    const end2 = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);
    const xScaleSpan = xScaleExtent[1] - xScaleExtent[0];
    const yScaleSpan = yScaleExtent[1] - yScaleExtent[0];
    if (!xScaleSpan || !yScaleSpan) {
      return;
    }
    const scaleX = (end2[0] - start2[0]) / xScaleSpan;
    const scaleY = (end2[1] - start2[1]) / yScaleSpan;
    const translateX = start2[0] - xScaleExtent[0] * scaleX;
    const translateY = start2[1] - yScaleExtent[0] * scaleY;
    const m2 = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY];
    this._invTransform = invert([], m2);
  }
  getBaseAxis() {
    return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
  }
  containPoint(point) {
    const axisX = this.getAxis("x");
    const axisY = this.getAxis("y");
    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
  }
  containData(data) {
    return this.getAxis("x").containData(data[0]) && this.getAxis("y").containData(data[1]);
  }
  containZone(data1, data2) {
    const zoneDiag1 = this.dataToPoint(data1);
    const zoneDiag2 = this.dataToPoint(data2);
    const area = this.getArea();
    const zone = new BoundingRect_default(zoneDiag1[0], zoneDiag1[1], zoneDiag2[0] - zoneDiag1[0], zoneDiag2[1] - zoneDiag1[1]);
    return area.intersect(zone);
  }
  dataToPoint(data, clamp2, out2) {
    out2 = out2 || [];
    const xVal = data[0];
    const yVal = data[1];
    if (this._transform && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {
      return applyTransform(out2, data, this._transform);
    }
    const xAxis = this.getAxis("x");
    const yAxis = this.getAxis("y");
    out2[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal, clamp2));
    out2[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal, clamp2));
    return out2;
  }
  clampData(data, out2) {
    const xScale = this.getAxis("x").scale;
    const yScale = this.getAxis("y").scale;
    const xAxisExtent = xScale.getExtent();
    const yAxisExtent = yScale.getExtent();
    const x = xScale.parse(data[0]);
    const y = yScale.parse(data[1]);
    out2 = out2 || [];
    out2[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));
    out2[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));
    return out2;
  }
  pointToData(point, clamp2, out2) {
    out2 = out2 || [];
    if (this._invTransform) {
      return applyTransform(out2, point, this._invTransform);
    }
    const xAxis = this.getAxis("x");
    const yAxis = this.getAxis("y");
    out2[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp2);
    out2[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp2);
    return out2;
  }
  getOtherAxis(axis) {
    return this.getAxis(axis.dim === "x" ? "y" : "x");
  }
  getArea(tolerance) {
    tolerance = tolerance || 0;
    const xExtent = this.getAxis("x").getGlobalExtent();
    const yExtent = this.getAxis("y").getGlobalExtent();
    const x = Math.min(xExtent[0], xExtent[1]) - tolerance;
    const y = Math.min(yExtent[0], yExtent[1]) - tolerance;
    const width = Math.max(xExtent[0], xExtent[1]) - x + tolerance;
    const height = Math.max(yExtent[0], yExtent[1]) - y + tolerance;
    return new BoundingRect_default(x, y, width, height);
  }
};
var Cartesian2D_default = Cartesian2D;

// src/coord/cartesian/Axis2D.ts
var Axis2D = class extends Axis_default {
  constructor(dim, scale4, coordExtent, axisType, position2) {
    super(dim, scale4, coordExtent);
    this.index = 0;
    this.type = axisType || "value";
    this.position = position2 || "bottom";
  }
  isHorizontal() {
    const position2 = this.position;
    return position2 === "top" || position2 === "bottom";
  }
  getGlobalExtent(asc4) {
    const ret = this.getExtent();
    ret[0] = this.toGlobalCoord(ret[0]);
    ret[1] = this.toGlobalCoord(ret[1]);
    asc4 && ret[0] > ret[1] && ret.reverse();
    return ret;
  }
  pointToData(point, clamp2) {
    return this.coordToData(this.toLocalCoord(point[this.dim === "x" ? 0 : 1]), clamp2);
  }
  setCategorySortInfo(info) {
    if (this.type !== "category") {
      return false;
    }
    this.model.option.categorySortInfo = info;
    this.scale.setSortInfo(info);
  }
};
var Axis2D_default = Axis2D;

// src/component/axis/AxisBuilder.ts
var PI7 = Math.PI;
var DEFAULT_CENTER_NAME_MARGIN_LEVELS = [[1, 2], [5, 3], [8, 3]];
var DEFAULT_ENDS_NAME_MARGIN_LEVELS = [[0, 1], [0, 3], [0, 3]];
var getLabelInner = makeInner();
var getTickInner = makeInner();
var AxisBuilderSharedContext = class {
  constructor(resolveAxisNameOverlap) {
    this.recordMap = {};
    this.resolveAxisNameOverlap = resolveAxisNameOverlap;
  }
  ensureRecord(axisModel) {
    const dim = axisModel.axis.dim;
    const idx = axisModel.componentIndex;
    const recordMap = this.recordMap;
    const records = recordMap[dim] || (recordMap[dim] = []);
    return records[idx] || (records[idx] = {ready: {}});
  }
};
function resetOverlapRecordToShared(cfg, shared, axisModel, labelLayoutInfoList) {
  const axis = axisModel.axis;
  const record = shared.ensureRecord(axisModel);
  const labelInfoList = [];
  let stOccupiedRect;
  const useStOccupiedRect = hasAxisName(cfg.axisName) && isNameLocationCenter(cfg.nameLocation);
  each(labelLayoutInfoList, (layout14) => {
    const layoutInfo = ensureLabelLayoutInfoComputed(layout14);
    if (!layoutInfo || layoutInfo.label.ignore) {
      return;
    }
    labelInfoList.push(layoutInfo);
    const transGroup = record.transGroup;
    if (useStOccupiedRect) {
      transGroup.transform ? invert(_stTransTmp, transGroup.transform) : identity(_stTransTmp);
      if (layoutInfo.transform) {
        mul2(_stTransTmp, _stTransTmp, layoutInfo.transform);
      }
      BoundingRect_default.copy(_stLabelRectTmp, layoutInfo.localRect);
      _stLabelRectTmp.applyTransform(_stTransTmp);
      stOccupiedRect ? stOccupiedRect.union(_stLabelRectTmp) : BoundingRect_default.copy(stOccupiedRect = new BoundingRect_default(0, 0, 0, 0), _stLabelRectTmp);
    }
  });
  const sortByDim = Math.abs(record.dirVec.x) > 0.1 ? "x" : "y";
  const sortByValue = record.transGroup[sortByDim];
  labelInfoList.sort((info1, info2) => Math.abs(info1.label[sortByDim] - sortByValue) - Math.abs(info2.label[sortByDim] - sortByValue));
  if (useStOccupiedRect && stOccupiedRect) {
    const extent = axis.getExtent();
    const axisLineX = Math.min(extent[0], extent[1]);
    const axisLineWidth = Math.max(extent[0], extent[1]) - axisLineX;
    stOccupiedRect.union(new BoundingRect_default(axisLineX, 0, axisLineWidth, 1));
  }
  record.stOccupiedRect = stOccupiedRect;
  record.labelInfoList = labelInfoList;
}
var _stTransTmp = create2();
var _stLabelRectTmp = new BoundingRect_default(0, 0, 0, 0);
var resolveAxisNameOverlapDefault = (cfg, ctx, axisModel, nameLayoutInfo, nameMoveDirVec, thisRecord) => {
  if (isNameLocationCenter(cfg.nameLocation)) {
    const stOccupiedRect = thisRecord.stOccupiedRect;
    if (stOccupiedRect) {
      moveIfOverlap(prepareIntersectionCheckInfo(stOccupiedRect, thisRecord.transGroup.transform), nameLayoutInfo, nameMoveDirVec);
    }
  } else {
    moveIfOverlapByLinearLabels(thisRecord.labelInfoList, thisRecord.dirVec, nameLayoutInfo, nameMoveDirVec);
  }
};
function moveIfOverlap(basedLayoutInfo, movableLayoutInfo, moveDirVec) {
  const mtv = new Point_default();
  if (labelIntersect(basedLayoutInfo, movableLayoutInfo, mtv, {
    direction: Math.atan2(moveDirVec.y, moveDirVec.x),
    bidirectional: false,
    touchThreshold: 0.05
  })) {
    Point_default.add(movableLayoutInfo.label, movableLayoutInfo.label, mtv);
    ensureLabelLayoutInfoComputed(rollbackToLabelLayoutInfoRaw(movableLayoutInfo));
  }
}
function moveIfOverlapByLinearLabels(baseLayoutInfoList, baseDirVec, movableLayoutInfo, moveDirVec) {
  const sameDir = Point_default.dot(moveDirVec, baseDirVec) >= 0;
  for (let idx = 0, len2 = baseLayoutInfoList.length; idx < len2; idx++) {
    const labelInfo = baseLayoutInfoList[sameDir ? idx : len2 - 1 - idx];
    if (!labelInfo.label.ignore) {
      moveIfOverlap(labelInfo, movableLayoutInfo, moveDirVec);
    }
  }
}
var AxisBuilder = class {
  constructor(axisModel, api2, opt, shared) {
    this.group = new Group_default();
    this._axisModel = axisModel;
    this._api = api2;
    this._local = {};
    this._shared = shared || new AxisBuilderSharedContext(resolveAxisNameOverlapDefault);
    this._resetCfgDetermined(opt);
  }
  updateCfg(opt) {
    if (true) {
      const ready = this._shared.ensureRecord(this._axisModel).ready;
      assert(!ready.axisLine && !ready.axisTickLabelDetermine);
      ready.axisName = ready.axisTickLabelEstimate = false;
    }
    const raw = this._cfg.raw;
    raw.position = opt.position;
    raw.labelOffset = opt.labelOffset;
    this._resetCfgDetermined(raw);
  }
  __getRawCfg() {
    return this._cfg.raw;
  }
  _resetCfgDetermined(raw) {
    const axisModel = this._axisModel;
    const axisModelDefaultOption = axisModel.getDefaultOption ? axisModel.getDefaultOption() : {};
    const axisName = retrieve2(raw.axisName, axisModel.get("name"));
    let nameMoveOverlapOption = axisModel.get("nameMoveOverlap");
    if (nameMoveOverlapOption == null || nameMoveOverlapOption === "auto") {
      nameMoveOverlapOption = retrieve2(raw.defaultNameMoveOverlap, true);
    }
    const cfg = {
      raw,
      position: raw.position,
      rotation: raw.rotation,
      nameDirection: retrieve2(raw.nameDirection, 1),
      tickDirection: retrieve2(raw.tickDirection, 1),
      labelDirection: retrieve2(raw.labelDirection, 1),
      labelOffset: retrieve2(raw.labelOffset, 0),
      silent: retrieve2(raw.silent, true),
      axisName,
      nameLocation: retrieve3(axisModel.get("nameLocation"), axisModelDefaultOption.nameLocation, "end"),
      shouldNameMoveOverlap: hasAxisName(axisName) && nameMoveOverlapOption,
      optionHideOverlap: axisModel.get(["axisLabel", "hideOverlap"]),
      showMinorTicks: axisModel.get(["minorTick", "show"])
    };
    if (true) {
      assert(cfg.position != null);
      assert(cfg.rotation != null);
    }
    this._cfg = cfg;
    const transformGroup = new Group_default({
      x: cfg.position[0],
      y: cfg.position[1],
      rotation: cfg.rotation
    });
    transformGroup.updateTransform();
    this._transformGroup = transformGroup;
    const record = this._shared.ensureRecord(axisModel);
    record.transGroup = this._transformGroup;
    record.dirVec = new Point_default(Math.cos(-cfg.rotation), Math.sin(-cfg.rotation));
  }
  build(axisPartNameMap, extraParams) {
    if (!axisPartNameMap) {
      axisPartNameMap = {
        axisLine: true,
        axisTickLabelEstimate: false,
        axisTickLabelDetermine: true,
        axisName: true
      };
    }
    each(AXIS_BUILDER_AXIS_PART_NAMES, (partName) => {
      if (axisPartNameMap[partName]) {
        builders[partName](this._cfg, this._local, this._shared, this._axisModel, this.group, this._transformGroup, this._api, extraParams || {});
      }
    });
    return this;
  }
  static innerTextLayout(axisRotation, textRotation, direction) {
    const rotationDiff = remRadian(textRotation - axisRotation);
    let textAlign;
    let textVerticalAlign;
    if (isRadianAroundZero(rotationDiff)) {
      textVerticalAlign = direction > 0 ? "top" : "bottom";
      textAlign = "center";
    } else if (isRadianAroundZero(rotationDiff - PI7)) {
      textVerticalAlign = direction > 0 ? "bottom" : "top";
      textAlign = "center";
    } else {
      textVerticalAlign = "middle";
      if (rotationDiff > 0 && rotationDiff < PI7) {
        textAlign = direction > 0 ? "right" : "left";
      } else {
        textAlign = direction > 0 ? "left" : "right";
      }
    }
    return {
      rotation: rotationDiff,
      textAlign,
      textVerticalAlign
    };
  }
  static makeAxisEventDataBase(axisModel) {
    const eventData = {
      componentType: axisModel.mainType,
      componentIndex: axisModel.componentIndex
    };
    eventData[axisModel.mainType + "Index"] = axisModel.componentIndex;
    return eventData;
  }
  static isLabelSilent(axisModel) {
    const tooltipOpt = axisModel.get("tooltip");
    return axisModel.get("silent") || !(axisModel.get("triggerEvent") || tooltipOpt && tooltipOpt.show);
  }
};
var AXIS_BUILDER_AXIS_PART_NAMES = [
  "axisLine",
  "axisTickLabelEstimate",
  "axisTickLabelDetermine",
  "axisName"
];
var builders = {
  axisLine(cfg, local, shared, axisModel, group, transformGroup, api2) {
    if (true) {
      const ready = shared.ensureRecord(axisModel).ready;
      assert(!ready.axisLine);
      ready.axisLine = true;
    }
    let shown = axisModel.get(["axisLine", "show"]);
    if (shown === "auto") {
      shown = true;
      if (cfg.raw.axisLineAutoShow != null) {
        shown = !!cfg.raw.axisLineAutoShow;
      }
    }
    if (!shown) {
      return;
    }
    const extent = axisModel.axis.getExtent();
    const matrix14 = transformGroup.transform;
    const pt12 = [extent[0], 0];
    const pt22 = [extent[1], 0];
    const inverse = pt12[0] > pt22[0];
    if (matrix14) {
      applyTransform(pt12, pt12, matrix14);
      applyTransform(pt22, pt22, matrix14);
    }
    const lineStyle = extend({
      lineCap: "round"
    }, axisModel.getModel(["axisLine", "lineStyle"]).getLineStyle());
    const pathBaseProp = {
      strokeContainThreshold: cfg.raw.strokeContainThreshold || 5,
      silent: true,
      z2: 1,
      style: lineStyle
    };
    if (axisModel.get(["axisLine", "breakLine"]) && axisModel.axis.scale.hasBreaks()) {
      getAxisBreakHelper().buildAxisBreakLine(axisModel, group, transformGroup, pathBaseProp);
    } else {
      const line2 = new Line_default(extend({
        shape: {
          x1: pt12[0],
          y1: pt12[1],
          x2: pt22[0],
          y2: pt22[1]
        }
      }, pathBaseProp));
      subPixelOptimizeLine2(line2.shape, line2.style.lineWidth);
      line2.anid = "line";
      group.add(line2);
    }
    let arrows = axisModel.get(["axisLine", "symbol"]);
    if (arrows != null) {
      let arrowSize = axisModel.get(["axisLine", "symbolSize"]);
      if (isString(arrows)) {
        arrows = [arrows, arrows];
      }
      if (isString(arrowSize) || isNumber(arrowSize)) {
        arrowSize = [arrowSize, arrowSize];
      }
      const arrowOffset = normalizeSymbolOffset(axisModel.get(["axisLine", "symbolOffset"]) || 0, arrowSize);
      const symbolWidth = arrowSize[0];
      const symbolHeight = arrowSize[1];
      each([{
        rotate: cfg.rotation + Math.PI / 2,
        offset: arrowOffset[0],
        r: 0
      }, {
        rotate: cfg.rotation - Math.PI / 2,
        offset: arrowOffset[1],
        r: Math.sqrt((pt12[0] - pt22[0]) * (pt12[0] - pt22[0]) + (pt12[1] - pt22[1]) * (pt12[1] - pt22[1]))
      }], function(point, index) {
        if (arrows[index] !== "none" && arrows[index] != null) {
          const symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true);
          const r = point.r + point.offset;
          const pt = inverse ? pt22 : pt12;
          symbol.attr({
            rotation: point.rotate,
            x: pt[0] + r * Math.cos(cfg.rotation),
            y: pt[1] - r * Math.sin(cfg.rotation),
            silent: true,
            z2: 11
          });
          group.add(symbol);
        }
      });
    }
  },
  axisTickLabelEstimate(cfg, local, shared, axisModel, group, transformGroup, api2, extraParams) {
    if (true) {
      const ready = shared.ensureRecord(axisModel).ready;
      assert(!ready.axisTickLabelDetermine);
      ready.axisTickLabelEstimate = true;
    }
    const needCallLayout = dealLastTickLabelResultReusable(local, group, extraParams);
    if (needCallLayout) {
      axisTickLabelLayout(cfg, local, shared, axisModel, group, transformGroup, api2, AxisTickLabelComputingKind.estimate);
    }
  },
  axisTickLabelDetermine(cfg, local, shared, axisModel, group, transformGroup, api2, extraParams) {
    if (true) {
      const ready = shared.ensureRecord(axisModel).ready;
      ready.axisTickLabelDetermine = true;
    }
    const needCallLayout = dealLastTickLabelResultReusable(local, group, extraParams);
    if (needCallLayout) {
      axisTickLabelLayout(cfg, local, shared, axisModel, group, transformGroup, api2, AxisTickLabelComputingKind.determine);
    }
    const ticksEls = buildAxisMajorTicks(cfg, group, transformGroup, axisModel);
    syncLabelIgnoreToMajorTicks(cfg, local.labelLayoutList, ticksEls);
    buildAxisMinorTicks(cfg, group, transformGroup, axisModel, cfg.tickDirection);
  },
  axisName(cfg, local, shared, axisModel, group, transformGroup, api2, extraParams) {
    const sharedRecord = shared.ensureRecord(axisModel);
    if (true) {
      const ready = sharedRecord.ready;
      assert(ready.axisTickLabelEstimate || ready.axisTickLabelDetermine);
      ready.axisName = true;
    }
    if (local.nameEl) {
      group.remove(local.nameEl);
      local.nameEl = sharedRecord.nameLayout = sharedRecord.nameLocation = null;
    }
    const name = cfg.axisName;
    if (!hasAxisName(name)) {
      return;
    }
    const nameLocation = cfg.nameLocation;
    const nameDirection = cfg.nameDirection;
    const textStyleModel = axisModel.getModel("nameTextStyle");
    const gap = axisModel.get("nameGap") || 0;
    const extent = axisModel.axis.getExtent();
    const gapStartEndSignal = axisModel.axis.inverse ? -1 : 1;
    const pos = new Point_default(0, 0);
    const nameMoveDirVec = new Point_default(0, 0);
    if (nameLocation === "start") {
      pos.x = extent[0] - gapStartEndSignal * gap;
      nameMoveDirVec.x = -gapStartEndSignal;
    } else if (nameLocation === "end") {
      pos.x = extent[1] + gapStartEndSignal * gap;
      nameMoveDirVec.x = gapStartEndSignal;
    } else {
      pos.x = (extent[0] + extent[1]) / 2;
      pos.y = cfg.labelOffset + nameDirection * gap;
      nameMoveDirVec.y = nameDirection;
    }
    const mt = create2();
    nameMoveDirVec.transform(rotate(mt, mt, cfg.rotation));
    let nameRotation = axisModel.get("nameRotate");
    if (nameRotation != null) {
      nameRotation = nameRotation * PI7 / 180;
    }
    let labelLayout2;
    let axisNameAvailableWidth;
    if (isNameLocationCenter(nameLocation)) {
      labelLayout2 = AxisBuilder.innerTextLayout(cfg.rotation, nameRotation != null ? nameRotation : cfg.rotation, nameDirection);
    } else {
      labelLayout2 = endTextLayout(cfg.rotation, nameLocation, nameRotation || 0, extent);
      axisNameAvailableWidth = cfg.raw.axisNameAvailableWidth;
      if (axisNameAvailableWidth != null) {
        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout2.rotation));
        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
      }
    }
    const textFont = textStyleModel.getFont();
    const truncateOpt = axisModel.get("nameTruncate", true) || {};
    const ellipsis = truncateOpt.ellipsis;
    const maxWidth = retrieve(cfg.raw.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);
    const nameMarginLevel = extraParams.nameMarginLevel || 0;
    const textEl = new Text_default({
      x: pos.x,
      y: pos.y,
      rotation: labelLayout2.rotation,
      silent: AxisBuilder.isLabelSilent(axisModel),
      style: createTextStyle(textStyleModel, {
        text: name,
        font: textFont,
        overflow: "truncate",
        width: maxWidth,
        ellipsis,
        fill: textStyleModel.getTextColor() || axisModel.get(["axisLine", "lineStyle", "color"]),
        align: textStyleModel.get("align") || labelLayout2.textAlign,
        verticalAlign: textStyleModel.get("verticalAlign") || labelLayout2.textVerticalAlign
      }, {
        defaultTextMargin: isNameLocationCenter(nameLocation) ? DEFAULT_CENTER_NAME_MARGIN_LEVELS[nameMarginLevel] : DEFAULT_ENDS_NAME_MARGIN_LEVELS[nameMarginLevel]
      }),
      z2: 1
    });
    setTooltipConfig({
      el: textEl,
      componentModel: axisModel,
      itemName: name
    });
    textEl.__fullText = name;
    textEl.anid = "name";
    if (axisModel.get("triggerEvent")) {
      const eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
      eventData.targetType = "axisName";
      eventData.name = name;
      getECData(textEl).eventData = eventData;
    }
    transformGroup.add(textEl);
    textEl.updateTransform();
    local.nameEl = textEl;
    const nameLayout = sharedRecord.nameLayout = createSingleLayoutInfoComputed(textEl);
    sharedRecord.nameLocation = nameLocation;
    group.add(textEl);
    textEl.decomposeTransform();
    if (cfg.shouldNameMoveOverlap && nameLayout) {
      const record = shared.ensureRecord(axisModel);
      if (true) {
        assert(record.labelInfoList);
      }
      shared.resolveAxisNameOverlap(cfg, shared, axisModel, nameLayout, nameMoveDirVec, record);
    }
  }
};
function axisTickLabelLayout(cfg, local, shared, axisModel, group, transformGroup, api2, kind) {
  if (!axisLabelBuildResultExists(local)) {
    buildAxisLabel(cfg, local, group, kind, axisModel, api2);
  }
  const labelLayoutList = local.labelLayoutList;
  updateAxisLabelChangableProps(cfg, axisModel, labelLayoutList, transformGroup);
  adjustBreakLabels(axisModel, cfg.rotation, labelLayoutList);
  const optionHideOverlap = cfg.optionHideOverlap;
  fixMinMaxLabelShow(axisModel, labelLayoutList, optionHideOverlap);
  if (optionHideOverlap) {
    hideOverlap(filter(labelLayoutList, (layout14) => layout14 && !layout14.label.ignore));
  }
  resetOverlapRecordToShared(cfg, shared, axisModel, labelLayoutList);
}
function endTextLayout(rotation, textPosition, textRotate, extent) {
  const rotationDiff = remRadian(textRotate - rotation);
  let textAlign;
  let textVerticalAlign;
  const inverse = extent[0] > extent[1];
  const onLeft = textPosition === "start" && !inverse || textPosition !== "start" && inverse;
  if (isRadianAroundZero(rotationDiff - PI7 / 2)) {
    textVerticalAlign = onLeft ? "bottom" : "top";
    textAlign = "center";
  } else if (isRadianAroundZero(rotationDiff - PI7 * 1.5)) {
    textVerticalAlign = onLeft ? "top" : "bottom";
    textAlign = "center";
  } else {
    textVerticalAlign = "middle";
    if (rotationDiff < PI7 * 1.5 && rotationDiff > PI7 / 2) {
      textAlign = onLeft ? "left" : "right";
    } else {
      textAlign = onLeft ? "right" : "left";
    }
  }
  return {
    rotation: rotationDiff,
    textAlign,
    textVerticalAlign
  };
}
function fixMinMaxLabelShow(axisModel, labelLayoutList, optionHideOverlap) {
  if (shouldShowAllLabels(axisModel.axis)) {
    return;
  }
  function deal(showMinMaxLabel, outmostLabelIdx, innerLabelIdx) {
    let outmostLabelLayout = labelLayoutList[outmostLabelIdx];
    let innerLabelLayout = labelLayoutList[innerLabelIdx];
    if (!outmostLabelLayout || !innerLabelLayout) {
      return;
    }
    if (showMinMaxLabel === false) {
      ignoreEl(outmostLabelLayout.label);
    } else {
      const touchThreshold = 0.1;
      const ignoreMargin = !optionHideOverlap;
      if (ignoreMargin) {
        outmostLabelLayout = rollbackToLabelLayoutInfoRaw(defaults({ignoreMargin}, outmostLabelLayout));
        innerLabelLayout = rollbackToLabelLayoutInfoRaw(defaults({ignoreMargin}, innerLabelLayout));
      }
      let anyIgnored = false;
      if (outmostLabelLayout.suggestIgnore) {
        ignoreEl(outmostLabelLayout.label);
        anyIgnored = true;
      }
      if (innerLabelLayout.suggestIgnore) {
        ignoreEl(innerLabelLayout.label);
        anyIgnored = true;
      }
      if (!anyIgnored && labelIntersect(ensureLabelLayoutInfoComputed(outmostLabelLayout), ensureLabelLayoutInfoComputed(innerLabelLayout), null, {touchThreshold})) {
        if (showMinMaxLabel) {
          ignoreEl(innerLabelLayout.label);
        } else {
          ignoreEl(outmostLabelLayout.label);
        }
      }
    }
  }
  const showMinLabel = axisModel.get(["axisLabel", "showMinLabel"]);
  const showMaxLabel = axisModel.get(["axisLabel", "showMaxLabel"]);
  const labelsLen = labelLayoutList.length;
  deal(showMinLabel, 0, 1);
  deal(showMaxLabel, labelsLen - 1, labelsLen - 2);
}
function syncLabelIgnoreToMajorTicks(cfg, labelLayoutList, tickEls) {
  if (cfg.showMinorTicks) {
    return;
  }
  each(labelLayoutList, (labelLayout2) => {
    if (labelLayout2 && labelLayout2.label.ignore) {
      for (let idx = 0; idx < tickEls.length; idx++) {
        const tickEl = tickEls[idx];
        const tickInner = getTickInner(tickEl);
        const labelInner2 = getLabelInner(labelLayout2.label);
        if (tickInner.tickValue != null && !tickInner.onBand && tickInner.tickValue === labelInner2.tickValue) {
          ignoreEl(tickEl);
          return;
        }
      }
    }
  });
}
function ignoreEl(el) {
  el && (el.ignore = true);
}
function createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {
  const tickEls = [];
  const pt12 = [];
  const pt22 = [];
  for (let i = 0; i < ticksCoords.length; i++) {
    const tickCoord = ticksCoords[i].coord;
    pt12[0] = tickCoord;
    pt12[1] = 0;
    pt22[0] = tickCoord;
    pt22[1] = tickEndCoord;
    if (tickTransform) {
      applyTransform(pt12, pt12, tickTransform);
      applyTransform(pt22, pt22, tickTransform);
    }
    const tickEl = new Line_default({
      shape: {
        x1: pt12[0],
        y1: pt12[1],
        x2: pt22[0],
        y2: pt22[1]
      },
      style: tickLineStyle,
      z2: 2,
      autoBatch: true,
      silent: true
    });
    subPixelOptimizeLine2(tickEl.shape, tickEl.style.lineWidth);
    tickEl.anid = anidPrefix + "_" + ticksCoords[i].tickValue;
    tickEls.push(tickEl);
    const inner25 = getTickInner(tickEl);
    inner25.onBand = !!ticksCoords[i].onBand;
    inner25.tickValue = ticksCoords[i].tickValue;
  }
  return tickEls;
}
function buildAxisMajorTicks(cfg, group, transformGroup, axisModel) {
  const axis = axisModel.axis;
  const tickModel = axisModel.getModel("axisTick");
  let shown = tickModel.get("show");
  if (shown === "auto") {
    shown = true;
    if (cfg.raw.axisTickAutoShow != null) {
      shown = !!cfg.raw.axisTickAutoShow;
    }
  }
  if (!shown || axis.scale.isBlank()) {
    return [];
  }
  const lineStyleModel = tickModel.getModel("lineStyle");
  const tickEndCoord = cfg.tickDirection * tickModel.get("length");
  const ticksCoords = axis.getTicksCoords();
  const ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, defaults(lineStyleModel.getLineStyle(), {
    stroke: axisModel.get(["axisLine", "lineStyle", "color"])
  }), "ticks");
  for (let i = 0; i < ticksEls.length; i++) {
    group.add(ticksEls[i]);
  }
  return ticksEls;
}
function buildAxisMinorTicks(cfg, group, transformGroup, axisModel, tickDirection) {
  const axis = axisModel.axis;
  const minorTickModel = axisModel.getModel("minorTick");
  if (!cfg.showMinorTicks || axis.scale.isBlank()) {
    return;
  }
  const minorTicksCoords = axis.getMinorTicksCoords();
  if (!minorTicksCoords.length) {
    return;
  }
  const lineStyleModel = minorTickModel.getModel("lineStyle");
  const tickEndCoord = tickDirection * minorTickModel.get("length");
  const minorTickLineStyle = defaults(lineStyleModel.getLineStyle(), defaults(axisModel.getModel("axisTick").getLineStyle(), {
    stroke: axisModel.get(["axisLine", "lineStyle", "color"])
  }));
  for (let i = 0; i < minorTicksCoords.length; i++) {
    const minorTicksEls = createTicks(minorTicksCoords[i], transformGroup.transform, tickEndCoord, minorTickLineStyle, "minorticks_" + i);
    for (let k = 0; k < minorTicksEls.length; k++) {
      group.add(minorTicksEls[k]);
    }
  }
}
function dealLastTickLabelResultReusable(local, group, extraParams) {
  if (axisLabelBuildResultExists(local)) {
    const axisLabelsCreationContext = local.axisLabelsCreationContext;
    if (true) {
      assert(local.labelGroup && axisLabelsCreationContext);
    }
    const noPxChangeTryDetermine = axisLabelsCreationContext.out.noPxChangeTryDetermine;
    if (extraParams.noPxChange) {
      let canDetermine = true;
      for (let idx = 0; idx < noPxChangeTryDetermine.length; idx++) {
        canDetermine = canDetermine && noPxChangeTryDetermine[idx]();
      }
      if (canDetermine) {
        return false;
      }
    }
    if (noPxChangeTryDetermine.length) {
      group.remove(local.labelGroup);
      axisLabelBuildResultSet(local, null, null, null);
    }
  }
  return true;
}
function buildAxisLabel(cfg, local, group, kind, axisModel, api2) {
  const axis = axisModel.axis;
  const show = retrieve(cfg.raw.axisLabelShow, axisModel.get(["axisLabel", "show"]));
  const labelGroup = new Group_default();
  group.add(labelGroup);
  const axisLabelCreationCtx = createAxisLabelsComputingContext(kind);
  if (!show || axis.scale.isBlank()) {
    axisLabelBuildResultSet(local, [], labelGroup, axisLabelCreationCtx);
    return;
  }
  const labelModel = axisModel.getModel("axisLabel");
  const labels = axis.getViewLabels(axisLabelCreationCtx);
  const labelRotation = (retrieve(cfg.raw.labelRotate, labelModel.get("rotate")) || 0) * PI7 / 180;
  const labelLayout2 = AxisBuilder.innerTextLayout(cfg.rotation, labelRotation, cfg.labelDirection);
  const rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);
  const labelEls = [];
  const triggerEvent = axisModel.get("triggerEvent");
  let z2Min = Infinity;
  let z2Max = -Infinity;
  each(labels, function(labelItem, index) {
    const tickValue = axis.scale.type === "ordinal" ? axis.scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;
    const formattedLabel = labelItem.formattedLabel;
    const rawLabel = labelItem.rawLabel;
    let itemLabelModel = labelModel;
    if (rawCategoryData && rawCategoryData[tickValue]) {
      const rawCategoryItem = rawCategoryData[tickValue];
      if (isObject(rawCategoryItem) && rawCategoryItem.textStyle) {
        itemLabelModel = new Model_default(rawCategoryItem.textStyle, labelModel, axisModel.ecModel);
      }
    }
    const textColor = itemLabelModel.getTextColor() || axisModel.get(["axisLine", "lineStyle", "color"]);
    const align = itemLabelModel.getShallow("align", true) || labelLayout2.textAlign;
    const alignMin = retrieve2(itemLabelModel.getShallow("alignMinLabel", true), align);
    const alignMax = retrieve2(itemLabelModel.getShallow("alignMaxLabel", true), align);
    const verticalAlign = itemLabelModel.getShallow("verticalAlign", true) || itemLabelModel.getShallow("baseline", true) || labelLayout2.textVerticalAlign;
    const verticalAlignMin = retrieve2(itemLabelModel.getShallow("verticalAlignMinLabel", true), verticalAlign);
    const verticalAlignMax = retrieve2(itemLabelModel.getShallow("verticalAlignMaxLabel", true), verticalAlign);
    const z2 = 10 + (labelItem.time?.level || 0);
    z2Min = Math.min(z2Min, z2);
    z2Max = Math.max(z2Max, z2);
    const textEl = new Text_default({
      x: 0,
      y: 0,
      rotation: 0,
      silent: AxisBuilder.isLabelSilent(axisModel),
      z2,
      style: createTextStyle(itemLabelModel, {
        text: formattedLabel,
        align: index === 0 ? alignMin : index === labels.length - 1 ? alignMax : align,
        verticalAlign: index === 0 ? verticalAlignMin : index === labels.length - 1 ? verticalAlignMax : verticalAlign,
        fill: isFunction(textColor) ? textColor(axis.type === "category" ? rawLabel : axis.type === "value" ? tickValue + "" : tickValue, index) : textColor
      })
    });
    textEl.anid = "label_" + tickValue;
    const inner25 = getLabelInner(textEl);
    inner25.break = labelItem.break;
    inner25.tickValue = tickValue;
    inner25.layoutRotation = labelLayout2.rotation;
    setTooltipConfig({
      el: textEl,
      componentModel: axisModel,
      itemName: formattedLabel,
      formatterParamsExtra: {
        isTruncated: () => textEl.isTruncated,
        value: rawLabel,
        tickIndex: index
      }
    });
    if (triggerEvent) {
      const eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
      eventData.targetType = "axisLabel";
      eventData.value = rawLabel;
      eventData.tickIndex = index;
      if (labelItem.break) {
        eventData.break = {
          start: labelItem.break.parsedBreak.vmin,
          end: labelItem.break.parsedBreak.vmax
        };
      }
      if (axis.type === "category") {
        eventData.dataIndex = tickValue;
      }
      getECData(textEl).eventData = eventData;
      if (labelItem.break) {
        addBreakEventHandler(axisModel, api2, textEl, labelItem.break);
      }
    }
    labelEls.push(textEl);
    labelGroup.add(textEl);
  });
  const labelLayoutList = map(labelEls, (label) => ({
    kind: LABEL_LAYOUT_INFO_KIND_RAW,
    label,
    priority: getLabelInner(label).break ? label.z2 + (z2Max - z2Min + 1) : label.z2,
    defaultAttr: {
      ignore: label.ignore
    }
  }));
  axisLabelBuildResultSet(local, labelLayoutList, labelGroup, axisLabelCreationCtx);
}
function axisLabelBuildResultExists(local) {
  return !!local.labelLayoutList;
}
function axisLabelBuildResultSet(local, labelLayoutList, labelGroup, axisLabelsCreationContext) {
  local.labelLayoutList = labelLayoutList;
  local.labelGroup = labelGroup;
  local.axisLabelsCreationContext = axisLabelsCreationContext;
}
function updateAxisLabelChangableProps(cfg, axisModel, labelLayoutList, transformGroup) {
  const labelMargin = axisModel.get(["axisLabel", "margin"]);
  each(labelLayoutList, (layoutInfo, idx) => {
    if (!layoutInfo) {
      return;
    }
    const labelEl = layoutInfo.label;
    const inner25 = getLabelInner(labelEl);
    layoutInfo.suggestIgnore = labelEl.ignore;
    labelEl.ignore = false;
    copyTransform(_tmpLayoutEl, _tmpLayoutElReset);
    _tmpLayoutEl.x = axisModel.axis.dataToCoord(inner25.tickValue);
    _tmpLayoutEl.y = cfg.labelOffset + cfg.labelDirection * labelMargin;
    _tmpLayoutEl.rotation = inner25.layoutRotation;
    transformGroup.add(_tmpLayoutEl);
    _tmpLayoutEl.updateTransform();
    transformGroup.remove(_tmpLayoutEl);
    _tmpLayoutEl.decomposeTransform();
    copyTransform(labelEl, _tmpLayoutEl);
    labelEl.markRedraw();
    if (layoutInfo.kind === LABEL_LAYOUT_INFO_KIND_COMPUTED) {
      rollbackToLabelLayoutInfoRaw(layoutInfo);
    }
  });
}
var _tmpLayoutEl = new Rect_default();
var _tmpLayoutElReset = new Rect_default();
function hasAxisName(axisName) {
  return !!axisName;
}
function addBreakEventHandler(axisModel, api2, textEl, visualBreak) {
  textEl.on("click", (params) => {
    const payload = {
      type: AXIS_BREAK_EXPAND_ACTION_TYPE,
      breaks: [{
        start: visualBreak.parsedBreak.breakOption.start,
        end: visualBreak.parsedBreak.breakOption.end
      }]
    };
    payload[`${axisModel.axis.dim}AxisIndex`] = axisModel.componentIndex;
    api2.dispatchAction(payload);
  });
}
function adjustBreakLabels(axisModel, axisRotation, labelLayoutList) {
  const scaleBreakHelper = getScaleBreakHelper();
  if (!scaleBreakHelper) {
    return;
  }
  const breakLabelIndexPairs = scaleBreakHelper.retrieveAxisBreakPairs(labelLayoutList, (layoutInfo) => layoutInfo && getLabelInner(layoutInfo.label).break, true);
  const moveOverlap = axisModel.get(["breakLabelLayout", "moveOverlap"], true);
  if (moveOverlap === true || moveOverlap === "auto") {
    each(breakLabelIndexPairs, (idxPair) => {
      getAxisBreakHelper().adjustBreakLabelPair(axisModel.axis.inverse, axisRotation, [
        ensureLabelLayoutInfoComputed(labelLayoutList[idxPair[0]]),
        ensureLabelLayoutInfoComputed(labelLayoutList[idxPair[1]])
      ]);
    });
  }
}
var AxisBuilder_default = AxisBuilder;

// src/coord/cartesian/cartesianAxisHelper.ts
function layout3(rect, axisModel, opt) {
  opt = opt || {};
  const axis = axisModel.axis;
  const layout14 = {};
  const otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];
  const rawAxisPosition = axis.position;
  const axisPosition = otherAxisOnZeroOf ? "onZero" : rawAxisPosition;
  const axisDim = axis.dim;
  const rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
  const idx = {left: 0, right: 1, top: 0, bottom: 1, onZero: 2};
  const axisOffset = axisModel.get("offset") || 0;
  const posBound = axisDim === "x" ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];
  if (otherAxisOnZeroOf) {
    const onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));
    posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
  }
  layout14.position = [
    axisDim === "y" ? posBound[idx[axisPosition]] : rectBound[0],
    axisDim === "x" ? posBound[idx[axisPosition]] : rectBound[3]
  ];
  layout14.rotation = Math.PI / 2 * (axisDim === "x" ? 0 : 1);
  const dirMap = {top: -1, bottom: 1, left: -1, right: 1};
  layout14.labelDirection = layout14.tickDirection = layout14.nameDirection = dirMap[rawAxisPosition];
  layout14.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0;
  if (axisModel.get(["axisTick", "inside"])) {
    layout14.tickDirection = -layout14.tickDirection;
  }
  if (retrieve(opt.labelInside, axisModel.get(["axisLabel", "inside"]))) {
    layout14.labelDirection = -layout14.labelDirection;
  }
  const labelRotate = axisModel.get(["axisLabel", "rotate"]);
  layout14.labelRotate = axisPosition === "top" ? -labelRotate : labelRotate;
  layout14.z2 = 1;
  return layout14;
}
function isCartesian2DInjectedAsDataCoordSys(seriesModel) {
  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "cartesian2d";
}
function findAxisModels(seriesModel) {
  const axisModelMap = {
    xAxisModel: null,
    yAxisModel: null
  };
  each(axisModelMap, function(v, key) {
    const axisType = key.replace(/Model$/, "");
    const axisModel = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0];
    if (true) {
      if (!axisModel) {
        throw new Error(axisType + ' "' + retrieve3(seriesModel.get(axisType + "Index"), seriesModel.get(axisType + "Id"), 0) + '" not found');
      }
    }
    axisModelMap[key] = axisModel;
  });
  return axisModelMap;
}
function createCartesianAxisViewCommonPartBuilder(gridRect, cartesians, axisModel, api2, ctx, defaultNameMoveOverlap) {
  const layoutResult = layout3(gridRect, axisModel);
  let axisLineAutoShow = false;
  let axisTickAutoShow = false;
  for (let i = 0; i < cartesians.length; i++) {
    if (isIntervalOrLogScale(cartesians[i].getOtherAxis(axisModel.axis).scale)) {
      axisLineAutoShow = axisTickAutoShow = true;
      if (axisModel.axis.type === "category" && axisModel.axis.onBand) {
        axisTickAutoShow = false;
      }
    }
  }
  layoutResult.axisLineAutoShow = axisLineAutoShow;
  layoutResult.axisTickAutoShow = axisTickAutoShow;
  layoutResult.defaultNameMoveOverlap = defaultNameMoveOverlap;
  return new AxisBuilder_default(axisModel, api2, layoutResult, ctx);
}
function updateCartesianAxisViewCommonPartBuilder(axisBuilder, gridRect, axisModel) {
  const newRaw = layout3(gridRect, axisModel);
  if (true) {
    const oldRaw = axisBuilder.__getRawCfg();
    each(keys(newRaw), (prop) => {
      if (prop !== "position" && prop !== "labelOffset") {
        assert(newRaw[prop] === oldRaw[prop]);
      }
    });
  }
  axisBuilder.updateCfg(newRaw);
}

// src/coord/axisAlignTicks.ts
function alignScaleTicks(scale4, axisModel, alignToScale) {
  const intervalScaleProto = Interval_default.prototype;
  const alignToTicks = intervalScaleProto.getTicks.call(alignToScale);
  const alignToNicedTicks = intervalScaleProto.getTicks.call(alignToScale, {expandToNicedExtent: true});
  const alignToSplitNumber = alignToTicks.length - 1;
  const alignToInterval = intervalScaleProto.getInterval.call(alignToScale);
  const scaleExtent = getScaleExtent(scale4, axisModel);
  let rawExtent = scaleExtent.extent;
  const isMinFixed = scaleExtent.fixMin;
  const isMaxFixed = scaleExtent.fixMax;
  if (scale4.type === "log") {
    rawExtent = logTransform(scale4.base, rawExtent, true);
  }
  scale4.setBreaksFromOption(retrieveAxisBreaksOption(axisModel));
  scale4.setExtent(rawExtent[0], rawExtent[1]);
  scale4.calcNiceExtent({
    splitNumber: alignToSplitNumber,
    fixMin: isMinFixed,
    fixMax: isMaxFixed
  });
  const extent = intervalScaleProto.getExtent.call(scale4);
  if (isMinFixed) {
    rawExtent[0] = extent[0];
  }
  if (isMaxFixed) {
    rawExtent[1] = extent[1];
  }
  let interval = intervalScaleProto.getInterval.call(scale4);
  let min3 = rawExtent[0];
  let max3 = rawExtent[1];
  if (isMinFixed && isMaxFixed) {
    interval = (max3 - min3) / alignToSplitNumber;
  } else if (isMinFixed) {
    max3 = rawExtent[0] + interval * alignToSplitNumber;
    while (max3 < rawExtent[1] && isFinite(max3) && isFinite(rawExtent[1])) {
      interval = increaseInterval(interval);
      max3 = rawExtent[0] + interval * alignToSplitNumber;
    }
  } else if (isMaxFixed) {
    min3 = rawExtent[1] - interval * alignToSplitNumber;
    while (min3 > rawExtent[0] && isFinite(min3) && isFinite(rawExtent[0])) {
      interval = increaseInterval(interval);
      min3 = rawExtent[1] - interval * alignToSplitNumber;
    }
  } else {
    const nicedSplitNumber = scale4.getTicks().length - 1;
    if (nicedSplitNumber > alignToSplitNumber) {
      interval = increaseInterval(interval);
    }
    const range = interval * alignToSplitNumber;
    max3 = Math.ceil(rawExtent[1] / interval) * interval;
    min3 = round(max3 - range);
    if (min3 < 0 && rawExtent[0] >= 0) {
      min3 = 0;
      max3 = round(range);
    } else if (max3 > 0 && rawExtent[1] <= 0) {
      max3 = 0;
      min3 = -round(range);
    }
  }
  const t0 = (alignToTicks[0].value - alignToNicedTicks[0].value) / alignToInterval;
  const t1 = (alignToTicks[alignToSplitNumber].value - alignToNicedTicks[alignToSplitNumber].value) / alignToInterval;
  intervalScaleProto.setExtent.call(scale4, min3 + interval * t0, max3 + interval * t1);
  intervalScaleProto.setInterval.call(scale4, interval);
  if (t0 || t1) {
    intervalScaleProto.setNiceExtent.call(scale4, min3 + interval, max3 - interval);
  }
  if (true) {
    const ticks = intervalScaleProto.getTicks.call(scale4);
    if (ticks[1] && (!isValueNice(interval) || getPrecisionSafe(ticks[1].value) > getPrecisionSafe(interval))) {
      warn(`The ticks may be not readable when set min: ${axisModel.get("min")}, max: ${axisModel.get("max")} and alignTicks: true. (${axisModel.axis?.dim}AxisIndex: ${axisModel.componentIndex})`, true);
    }
  }
}

// src/coord/cartesian/Grid.ts
var XY_TO_MARGIN_IDX = [
  [3, 1],
  [0, 2]
];
var Grid2 = class {
  constructor(gridModel, ecModel, api2) {
    this.type = "grid";
    this._coordsMap = {};
    this._coordsList = [];
    this._axesMap = {};
    this._axesList = [];
    this.axisPointerEnabled = true;
    this.dimensions = cartesian2DDimensions;
    this._initCartesian(gridModel, ecModel, api2);
    this.model = gridModel;
  }
  getRect() {
    return this._rect;
  }
  update(ecModel, api2) {
    const axesMap = this._axesMap;
    this._updateScale(ecModel, this.model);
    function updateAxisTicks(axes) {
      let alignTo;
      const axesIndices = keys(axes);
      const len2 = axesIndices.length;
      if (!len2) {
        return;
      }
      const axisNeedsAlign = [];
      for (let i = len2 - 1; i >= 0; i--) {
        const idx = +axesIndices[i];
        const axis = axes[idx];
        const model = axis.model;
        const scale4 = axis.scale;
        if (isIntervalOrLogScale(scale4) && model.get("alignTicks") && model.get("interval") == null) {
          axisNeedsAlign.push(axis);
        } else {
          niceScaleExtent(scale4, model);
          if (isIntervalOrLogScale(scale4)) {
            alignTo = axis;
          }
        }
      }
      ;
      if (axisNeedsAlign.length) {
        if (!alignTo) {
          alignTo = axisNeedsAlign.pop();
          niceScaleExtent(alignTo.scale, alignTo.model);
        }
        each(axisNeedsAlign, (axis) => {
          alignScaleTicks(axis.scale, axis.model, alignTo.scale);
        });
      }
    }
    updateAxisTicks(axesMap.x);
    updateAxisTicks(axesMap.y);
    const onZeroRecords = {};
    each(axesMap.x, function(xAxis) {
      fixAxisOnZero(axesMap, "y", xAxis, onZeroRecords);
    });
    each(axesMap.y, function(yAxis) {
      fixAxisOnZero(axesMap, "x", yAxis, onZeroRecords);
    });
    this.resize(this.model, api2);
  }
  resize(gridModel, api2, beforeDataProcessing) {
    const layoutRef = createBoxLayoutReference(gridModel, api2);
    const gridRect = this._rect = getLayoutRect(gridModel.getBoxLayoutParams(), layoutRef.refContainer);
    const axesMap = this._axesMap;
    const coordsList = this._coordsList;
    const optionContainLabel = gridModel.get("containLabel");
    updateAllAxisExtentTransByGridRect(axesMap, gridRect);
    if (!beforeDataProcessing) {
      const axisBuilderSharedCtx = createAxisBiulders(gridRect, coordsList, axesMap, optionContainLabel, api2);
      let noPxChange;
      if (optionContainLabel) {
        if (legacyLayOutGridByContainLabel) {
          legacyLayOutGridByContainLabel(this._axesList, gridRect);
          updateAllAxisExtentTransByGridRect(axesMap, gridRect);
        } else {
          if (true) {
            log("Specified `grid.containLabel` but no `use(LegacyGridContainLabel)`;use `grid.outerBounds` instead.", true);
          }
          noPxChange = layOutGridByOuterBounds(gridRect.clone(), "axisLabel", null, gridRect, axesMap, axisBuilderSharedCtx, layoutRef);
        }
      } else {
        const {outerBoundsRect, parsedOuterBoundsContain, outerBoundsClamp} = prepareOuterBounds(gridModel, gridRect, layoutRef);
        if (outerBoundsRect) {
          noPxChange = layOutGridByOuterBounds(outerBoundsRect, parsedOuterBoundsContain, outerBoundsClamp, gridRect, axesMap, axisBuilderSharedCtx, layoutRef);
        }
      }
      createOrUpdateAxesView(gridRect, axesMap, AxisTickLabelComputingKind.determine, null, noPxChange, layoutRef);
    }
    each(this._coordsList, function(coord) {
      coord.calcAffineTransform();
    });
  }
  getAxis(dim, axisIndex) {
    const axesMapOnDim = this._axesMap[dim];
    if (axesMapOnDim != null) {
      return axesMapOnDim[axisIndex || 0];
    }
  }
  getAxes() {
    return this._axesList.slice();
  }
  getCartesian(xAxisIndex, yAxisIndex) {
    if (xAxisIndex != null && yAxisIndex != null) {
      const key = "x" + xAxisIndex + "y" + yAxisIndex;
      return this._coordsMap[key];
    }
    if (isObject(xAxisIndex)) {
      yAxisIndex = xAxisIndex.yAxisIndex;
      xAxisIndex = xAxisIndex.xAxisIndex;
    }
    for (let i = 0, coordList = this._coordsList; i < coordList.length; i++) {
      if (coordList[i].getAxis("x").index === xAxisIndex || coordList[i].getAxis("y").index === yAxisIndex) {
        return coordList[i];
      }
    }
  }
  getCartesians() {
    return this._coordsList.slice();
  }
  convertToPixel(ecModel, finder, value) {
    const target = this._findConvertTarget(finder);
    return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
  }
  convertFromPixel(ecModel, finder, value) {
    const target = this._findConvertTarget(finder);
    return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
  }
  _findConvertTarget(finder) {
    const seriesModel = finder.seriesModel;
    const xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
    const yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
    const gridModel = finder.gridModel;
    const coordsList = this._coordsList;
    let cartesian;
    let axis;
    if (seriesModel) {
      cartesian = seriesModel.coordinateSystem;
      indexOf(coordsList, cartesian) < 0 && (cartesian = null);
    } else if (xAxisModel && yAxisModel) {
      cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    } else if (xAxisModel) {
      axis = this.getAxis("x", xAxisModel.componentIndex);
    } else if (yAxisModel) {
      axis = this.getAxis("y", yAxisModel.componentIndex);
    } else if (gridModel) {
      const grid = gridModel.coordinateSystem;
      if (grid === this) {
        cartesian = this._coordsList[0];
      }
    }
    return {cartesian, axis};
  }
  containPoint(point) {
    const coord = this._coordsList[0];
    if (coord) {
      return coord.containPoint(point);
    }
  }
  _initCartesian(gridModel, ecModel, api2) {
    const grid = this;
    const axisPositionUsed = {
      left: false,
      right: false,
      top: false,
      bottom: false
    };
    const axesMap = {
      x: {},
      y: {}
    };
    const axesCount = {
      x: 0,
      y: 0
    };
    ecModel.eachComponent("xAxis", createAxisCreator("x"), this);
    ecModel.eachComponent("yAxis", createAxisCreator("y"), this);
    if (!axesCount.x || !axesCount.y) {
      this._axesMap = {};
      this._axesList = [];
      return;
    }
    this._axesMap = axesMap;
    each(axesMap.x, (xAxis, xAxisIndex) => {
      each(axesMap.y, (yAxis, yAxisIndex) => {
        const key = "x" + xAxisIndex + "y" + yAxisIndex;
        const cartesian = new Cartesian2D_default(key);
        cartesian.master = this;
        cartesian.model = gridModel;
        this._coordsMap[key] = cartesian;
        this._coordsList.push(cartesian);
        cartesian.addAxis(xAxis);
        cartesian.addAxis(yAxis);
      });
    });
    function createAxisCreator(dimName) {
      return function(axisModel, idx) {
        if (!isAxisUsedInTheGrid(axisModel, gridModel)) {
          return;
        }
        let axisPosition = axisModel.get("position");
        if (dimName === "x") {
          if (axisPosition !== "top" && axisPosition !== "bottom") {
            axisPosition = axisPositionUsed.bottom ? "top" : "bottom";
          }
        } else {
          if (axisPosition !== "left" && axisPosition !== "right") {
            axisPosition = axisPositionUsed.left ? "right" : "left";
          }
        }
        axisPositionUsed[axisPosition] = true;
        const axis = new Axis2D_default(dimName, createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisPosition);
        const isCategory2 = axis.type === "category";
        axis.onBand = isCategory2 && axisModel.get("boundaryGap");
        axis.inverse = axisModel.get("inverse");
        axisModel.axis = axis;
        axis.model = axisModel;
        axis.grid = grid;
        axis.index = idx;
        grid._axesList.push(axis);
        axesMap[dimName][idx] = axis;
        axesCount[dimName]++;
      };
    }
  }
  _updateScale(ecModel, gridModel) {
    each(this._axesList, function(axis) {
      axis.scale.setExtent(Infinity, -Infinity);
      if (axis.type === "category") {
        const categorySortInfo = axis.model.get("categorySortInfo");
        axis.scale.setSortInfo(categorySortInfo);
      }
    });
    ecModel.eachSeries(function(seriesModel) {
      if (isCartesian2DInjectedAsDataCoordSys(seriesModel)) {
        const axesModelMap = findAxisModels(seriesModel);
        const xAxisModel = axesModelMap.xAxisModel;
        const yAxisModel = axesModelMap.yAxisModel;
        if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {
          return;
        }
        const cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
        const data = seriesModel.getData();
        const xAxis = cartesian.getAxis("x");
        const yAxis = cartesian.getAxis("y");
        unionExtent(data, xAxis);
        unionExtent(data, yAxis);
      }
    }, this);
    function unionExtent(data, axis) {
      each(getDataDimensionsOnAxis(data, axis.dim), function(dim) {
        axis.scale.unionExtentFromData(data, dim);
      });
    }
  }
  getTooltipAxes(dim) {
    const baseAxes = [];
    const otherAxes = [];
    each(this.getCartesians(), function(cartesian) {
      const baseAxis = dim != null && dim !== "auto" ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
      const otherAxis = cartesian.getOtherAxis(baseAxis);
      indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
      indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
    });
    return {baseAxes, otherAxes};
  }
  static create(ecModel, api2) {
    const grids = [];
    ecModel.eachComponent("grid", function(gridModel, idx) {
      const grid = new Grid2(gridModel, ecModel, api2);
      grid.name = "grid_" + idx;
      grid.resize(gridModel, api2, true);
      gridModel.coordinateSystem = grid;
      grids.push(grid);
    });
    ecModel.eachSeries(function(seriesModel) {
      injectCoordSysByOption({
        targetModel: seriesModel,
        coordSysType: "cartesian2d",
        coordSysProvider
      });
      function coordSysProvider() {
        const axesModelMap = findAxisModels(seriesModel);
        const xAxisModel = axesModelMap.xAxisModel;
        const yAxisModel = axesModelMap.yAxisModel;
        const gridModel = xAxisModel.getCoordSysModel();
        if (true) {
          if (!gridModel) {
            throw new Error('Grid "' + retrieve3(xAxisModel.get("gridIndex"), xAxisModel.get("gridId"), 0) + '" not found');
          }
          if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {
            throw new Error("xAxis and yAxis must use the same grid");
          }
        }
        const grid = gridModel.coordinateSystem;
        return grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
      }
    });
    return grids;
  }
};
var Grid = Grid2;
Grid.dimensions = cartesian2DDimensions;
function isAxisUsedInTheGrid(axisModel, gridModel) {
  return axisModel.getCoordSysModel() === gridModel;
}
function fixAxisOnZero(axesMap, otherAxisDim, axis, onZeroRecords) {
  axis.getAxesOnZeroOf = function() {
    return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];
  };
  const otherAxes = axesMap[otherAxisDim];
  let otherAxisOnZeroOf;
  const axisModel = axis.model;
  const onZero = axisModel.get(["axisLine", "onZero"]);
  const onZeroAxisIndex = axisModel.get(["axisLine", "onZeroAxisIndex"]);
  if (!onZero) {
    return;
  }
  if (onZeroAxisIndex != null) {
    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {
      otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];
    }
  } else {
    for (const idx in otherAxes) {
      if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
        otherAxisOnZeroOf = otherAxes[idx];
        break;
      }
    }
  }
  if (otherAxisOnZeroOf) {
    onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;
  }
  function getOnZeroRecordKey(axis2) {
    return axis2.dim + "_" + axis2.index;
  }
}
function canOnZeroToAxis(axis) {
  return axis && axis.type !== "category" && axis.type !== "time" && ifAxisCrossZero(axis);
}
function updateAxisTransform(axis, coordBase) {
  const axisExtent = axis.getExtent();
  const axisExtentSum = axisExtent[0] + axisExtent[1];
  axis.toGlobalCoord = axis.dim === "x" ? function(coord) {
    return coord + coordBase;
  } : function(coord) {
    return axisExtentSum - coord + coordBase;
  };
  axis.toLocalCoord = axis.dim === "x" ? function(coord) {
    return coord - coordBase;
  } : function(coord) {
    return axisExtentSum - coord + coordBase;
  };
}
function updateAllAxisExtentTransByGridRect(axesMap, gridRect) {
  each(axesMap.x, (axis) => updateAxisExtentTransByGridRect(axis, gridRect.x, gridRect.width));
  each(axesMap.y, (axis) => updateAxisExtentTransByGridRect(axis, gridRect.y, gridRect.height));
}
function updateAxisExtentTransByGridRect(axis, gridXY, gridWH) {
  const extent = [0, gridWH];
  const idx = axis.inverse ? 1 : 0;
  axis.setExtent(extent[idx], extent[1 - idx]);
  updateAxisTransform(axis, gridXY);
}
var legacyLayOutGridByContainLabel;
function registerLegacyGridContainLabelImpl(impl) {
  legacyLayOutGridByContainLabel = impl;
}
function layOutGridByOuterBounds(outerBoundsRect, outerBoundsContain, outerBoundsClamp, gridRect, axesMap, axisBuilderSharedCtx, layoutRef) {
  if (true) {
    assert(outerBoundsContain === "all" || outerBoundsContain === "axisLabel");
  }
  createOrUpdateAxesView(gridRect, axesMap, AxisTickLabelComputingKind.estimate, outerBoundsContain, false, layoutRef);
  const margin = [0, 0, 0, 0];
  fillLabelNameOverflowOnOneDimension(0);
  fillLabelNameOverflowOnOneDimension(1);
  fillMarginOnOneDimension(gridRect, 0, NaN);
  fillMarginOnOneDimension(gridRect, 1, NaN);
  const noPxChange = find(margin, (item) => item > 0) == null;
  expandOrShrinkRect(gridRect, margin, true, true, outerBoundsClamp);
  updateAllAxisExtentTransByGridRect(axesMap, gridRect);
  return noPxChange;
  function fillLabelNameOverflowOnOneDimension(xyIdx) {
    each(axesMap[XY2[xyIdx]], (axis) => {
      if (!shouldAxisShow(axis.model)) {
        return;
      }
      const sharedRecord = axisBuilderSharedCtx.ensureRecord(axis.model);
      const labelInfoList = sharedRecord.labelInfoList;
      if (labelInfoList) {
        for (let idx = 0; idx < labelInfoList.length; idx++) {
          const labelInfo = labelInfoList[idx];
          let proportion = axis.scale.normalize(getLabelInner(labelInfo.label).tickValue);
          proportion = xyIdx === 1 ? 1 - proportion : proportion;
          fillMarginOnOneDimension(labelInfo.rect, xyIdx, proportion);
          fillMarginOnOneDimension(labelInfo.rect, 1 - xyIdx, NaN);
        }
      }
      const nameLayout = sharedRecord.nameLayout;
      if (nameLayout) {
        const proportion = isNameLocationCenter(sharedRecord.nameLocation) ? 0.5 : NaN;
        fillMarginOnOneDimension(nameLayout.rect, xyIdx, proportion);
        fillMarginOnOneDimension(nameLayout.rect, 1 - xyIdx, NaN);
      }
    });
  }
  function fillMarginOnOneDimension(itemRect, xyIdx, proportion) {
    let overflow1 = outerBoundsRect[XY2[xyIdx]] - itemRect[XY2[xyIdx]];
    let overflow2 = itemRect[WH2[xyIdx]] + itemRect[XY2[xyIdx]] - (outerBoundsRect[WH2[xyIdx]] + outerBoundsRect[XY2[xyIdx]]);
    overflow1 = applyProportion(overflow1, 1 - proportion);
    overflow2 = applyProportion(overflow2, proportion);
    const minIdx = XY_TO_MARGIN_IDX[xyIdx][0];
    const maxIdx = XY_TO_MARGIN_IDX[xyIdx][1];
    margin[minIdx] = mathMax2(margin[minIdx], overflow1);
    margin[maxIdx] = mathMax2(margin[maxIdx], overflow2);
  }
  function applyProportion(overflow, proportion) {
    if (overflow > 0 && !eqNaN(proportion) && proportion > 1e-4) {
      overflow /= proportion;
    }
    return overflow;
  }
}
function createAxisBiulders(gridRect, cartesians, axesMap, optionContainLabel, api2) {
  const axisBuilderSharedCtx = new AxisBuilderSharedContext(resolveAxisNameOverlapForGrid);
  each(axesMap, (axisList) => each(axisList, (axis) => {
    if (shouldAxisShow(axis.model)) {
      const defaultNameMoveOverlap = !optionContainLabel;
      axis.axisBuilder = createCartesianAxisViewCommonPartBuilder(gridRect, cartesians, axis.model, api2, axisBuilderSharedCtx, defaultNameMoveOverlap);
    }
  }));
  return axisBuilderSharedCtx;
}
function createOrUpdateAxesView(gridRect, axesMap, kind, outerBoundsContain, noPxChange, layoutRef) {
  const isDetermine = kind === AxisTickLabelComputingKind.determine;
  each(axesMap, (axisList) => each(axisList, (axis) => {
    if (shouldAxisShow(axis.model)) {
      updateCartesianAxisViewCommonPartBuilder(axis.axisBuilder, gridRect, axis.model);
      axis.axisBuilder.build(isDetermine ? {axisTickLabelDetermine: true} : {axisTickLabelEstimate: true}, {noPxChange});
    }
  }));
  const nameMarginLevelMap = {x: 0, y: 0};
  calcNameMarginLevel(0);
  calcNameMarginLevel(1);
  function calcNameMarginLevel(xyIdx) {
    nameMarginLevelMap[XY2[1 - xyIdx]] = gridRect[WH2[xyIdx]] <= layoutRef.refContainer[WH2[xyIdx]] * 0.5 ? 0 : 1 - xyIdx === 1 ? 2 : 1;
  }
  each(axesMap, (axisList, xy) => each(axisList, (axis) => {
    if (shouldAxisShow(axis.model)) {
      if (outerBoundsContain === "all" || isDetermine) {
        axis.axisBuilder.build({axisName: true}, {nameMarginLevel: nameMarginLevelMap[xy]});
      }
      if (isDetermine) {
        axis.axisBuilder.build({axisLine: true});
      }
    }
  }));
}
function prepareOuterBounds(gridModel, rawRridRect, layoutRef) {
  let outerBoundsRect;
  const optionOuterBoundsMode = gridModel.get("outerBoundsMode", true);
  if (optionOuterBoundsMode === "same") {
    outerBoundsRect = rawRridRect.clone();
  } else if (optionOuterBoundsMode == null || optionOuterBoundsMode === "auto") {
    outerBoundsRect = getLayoutRect(gridModel.get("outerBounds", true) || OUTER_BOUNDS_DEFAULT, layoutRef.refContainer);
  } else if (optionOuterBoundsMode !== "none") {
    if (true) {
      error(`Invalid grid[${gridModel.componentIndex}].outerBoundsMode.`);
    }
  }
  const optionOuterBoundsContain = gridModel.get("outerBoundsContain", true);
  let parsedOuterBoundsContain;
  if (optionOuterBoundsContain == null || optionOuterBoundsContain === "auto") {
    parsedOuterBoundsContain = "all";
  } else if (indexOf(["all", "axisLabel"], optionOuterBoundsContain) < 0) {
    if (true) {
      error(`Invalid grid[${gridModel.componentIndex}].outerBoundsContain.`);
    }
    parsedOuterBoundsContain = "all";
  } else {
    parsedOuterBoundsContain = optionOuterBoundsContain;
  }
  const outerBoundsClamp = [
    parsePositionSizeOption(retrieve2(gridModel.get("outerBoundsClampWidth", true), OUTER_BOUNDS_CLAMP_DEFAULT[0]), rawRridRect.width),
    parsePositionSizeOption(retrieve2(gridModel.get("outerBoundsClampHeight", true), OUTER_BOUNDS_CLAMP_DEFAULT[1]), rawRridRect.height)
  ];
  return {outerBoundsRect, parsedOuterBoundsContain, outerBoundsClamp};
}
var resolveAxisNameOverlapForGrid = (cfg, ctx, axisModel, nameLayoutInfo, nameMoveDirVec, thisRecord) => {
  const perpendicularDim = axisModel.axis.dim === "x" ? "y" : "x";
  resolveAxisNameOverlapDefault(cfg, ctx, axisModel, nameLayoutInfo, nameMoveDirVec, thisRecord);
  if (!isNameLocationCenter(cfg.nameLocation)) {
    each(ctx.recordMap[perpendicularDim], (perpenRecord) => {
      if (perpenRecord && perpenRecord.labelInfoList && perpenRecord.dirVec) {
        moveIfOverlapByLinearLabels(perpenRecord.labelInfoList, perpenRecord.dirVec, nameLayoutInfo, nameMoveDirVec);
      }
    });
  }
};
var Grid_default = Grid;

// src/component/axisPointer/modelHelper.ts
function collect(ecModel, api2) {
  const result = {
    axesInfo: {},
    seriesInvolved: false,
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  collectAxesInfo(result, ecModel, api2);
  result.seriesInvolved && collectSeriesInfo(result, ecModel);
  return result;
}
function collectAxesInfo(result, ecModel, api2) {
  const globalTooltipModel = ecModel.getComponent("tooltip");
  const globalAxisPointerModel = ecModel.getComponent("axisPointer");
  const linksOption = globalAxisPointerModel.get("link", true) || [];
  const linkGroups = [];
  each(api2.getCoordinateSystems(), function(coordSys) {
    if (!coordSys.axisPointerEnabled) {
      return;
    }
    const coordSysKey = makeKey(coordSys.model);
    const axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
    result.coordSysMap[coordSysKey] = coordSys;
    const coordSysModel = coordSys.model;
    const baseTooltipModel = coordSysModel.getModel("tooltip", globalTooltipModel);
    each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null));
    if (coordSys.getTooltipAxes && globalTooltipModel && baseTooltipModel.get("show")) {
      const triggerAxis = baseTooltipModel.get("trigger") === "axis";
      const cross = baseTooltipModel.get(["axisPointer", "type"]) === "cross";
      const tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get(["axisPointer", "axis"]));
      if (triggerAxis || cross) {
        each(tooltipAxes.baseAxes, curry(saveTooltipAxisInfo, cross ? "cross" : true, triggerAxis));
      }
      if (cross) {
        each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, "cross", false));
      }
    }
    function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
      let axisPointerModel = axis.model.getModel("axisPointer", globalAxisPointerModel);
      const axisPointerShow = axisPointerModel.get("show");
      if (!axisPointerShow || axisPointerShow === "auto" && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
        return;
      }
      if (triggerTooltip == null) {
        triggerTooltip = axisPointerModel.get("triggerTooltip");
      }
      axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
      const snap = axisPointerModel.get("snap");
      const triggerEmphasis = axisPointerModel.get("triggerEmphasis");
      const axisKey = makeKey(axis.model);
      const involveSeries = triggerTooltip || snap || axis.type === "category";
      const axisInfo = result.axesInfo[axisKey] = {
        key: axisKey,
        axis,
        coordSys,
        axisPointerModel,
        triggerTooltip,
        triggerEmphasis,
        involveSeries,
        snap,
        useHandle: isHandleTrigger(axisPointerModel),
        seriesModels: [],
        linkGroup: null
      };
      axesInfoInCoordSys[axisKey] = axisInfo;
      result.seriesInvolved = result.seriesInvolved || involveSeries;
      const groupIndex = getLinkGroupIndex(linksOption, axis);
      if (groupIndex != null) {
        const linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {axesInfo: {}});
        linkGroup.axesInfo[axisKey] = axisInfo;
        linkGroup.mapper = linksOption[groupIndex].mapper;
        axisInfo.linkGroup = linkGroup;
      }
    }
  });
}
function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
  const tooltipAxisPointerModel = baseTooltipModel.getModel("axisPointer");
  const fields = [
    "type",
    "snap",
    "lineStyle",
    "shadowStyle",
    "label",
    "animation",
    "animationDurationUpdate",
    "animationEasingUpdate",
    "z"
  ];
  const volatileOption = {};
  each(fields, function(field) {
    volatileOption[field] = clone(tooltipAxisPointerModel.get(field));
  });
  volatileOption.snap = axis.type !== "category" && !!triggerTooltip;
  if (tooltipAxisPointerModel.get("type") === "cross") {
    volatileOption.type = "line";
  }
  const labelOption = volatileOption.label || (volatileOption.label = {});
  labelOption.show == null && (labelOption.show = false);
  if (fromTooltip === "cross") {
    const tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get(["label", "show"]);
    labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true;
    if (!triggerTooltip) {
      const crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get("crossStyle");
      crossStyle && defaults(labelOption, crossStyle.textStyle);
    }
  }
  return axis.model.getModel("axisPointer", new Model_default(volatileOption, globalAxisPointerModel, ecModel));
}
function collectSeriesInfo(result, ecModel) {
  ecModel.eachSeries(function(seriesModel) {
    const coordSys = seriesModel.coordinateSystem;
    const seriesTooltipTrigger = seriesModel.get(["tooltip", "trigger"], true);
    const seriesTooltipShow = seriesModel.get(["tooltip", "show"], true);
    if (!coordSys || !coordSys.model || seriesTooltipTrigger === "none" || seriesTooltipTrigger === false || seriesTooltipTrigger === "item" || seriesTooltipShow === false || seriesModel.get(["axisPointer", "show"], true) === false) {
      return;
    }
    each(result.coordSysAxesInfo[makeKey(coordSys.model)], function(axisInfo) {
      const axis = axisInfo.axis;
      if (coordSys.getAxis(axis.dim) === axis) {
        axisInfo.seriesModels.push(seriesModel);
        axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
        axisInfo.seriesDataCount += seriesModel.getData().count();
      }
    });
  });
}
function getLinkGroupIndex(linksOption, axis) {
  const axisModel = axis.model;
  const dim = axis.dim;
  for (let i = 0; i < linksOption.length; i++) {
    const linkOption = linksOption[i] || {};
    if (checkPropInLink(linkOption[dim + "AxisId"], axisModel.id) || checkPropInLink(linkOption[dim + "AxisIndex"], axisModel.componentIndex) || checkPropInLink(linkOption[dim + "AxisName"], axisModel.name)) {
      return i;
    }
  }
}
function checkPropInLink(linkPropValue, axisPropValue) {
  return linkPropValue === "all" || isArray(linkPropValue) && indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
}
function fixValue(axisModel) {
  const axisInfo = getAxisInfo(axisModel);
  if (!axisInfo) {
    return;
  }
  const axisPointerModel = axisInfo.axisPointerModel;
  const scale4 = axisInfo.axis.scale;
  const option = axisPointerModel.option;
  const status = axisPointerModel.get("status");
  let value = axisPointerModel.get("value");
  if (value != null) {
    value = scale4.parse(value);
  }
  const useHandle = isHandleTrigger(axisPointerModel);
  if (status == null) {
    option.status = useHandle ? "show" : "hide";
  }
  const extent = scale4.getExtent().slice();
  extent[0] > extent[1] && extent.reverse();
  if (value == null || value > extent[1]) {
    value = extent[1];
  }
  if (value < extent[0]) {
    value = extent[0];
  }
  option.value = value;
  if (useHandle) {
    option.status = axisInfo.axis.scale.isBlank() ? "hide" : "show";
  }
}
function getAxisInfo(axisModel) {
  const coordSysAxesInfo = (axisModel.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
}
function getAxisPointerModel(axisModel) {
  const axisInfo = getAxisInfo(axisModel);
  return axisInfo && axisInfo.axisPointerModel;
}
function isHandleTrigger(axisPointerModel) {
  return !!axisPointerModel.get(["handle", "show"]);
}
function makeKey(model) {
  return model.type + "||" + model.id;
}

// src/component/axis/AxisView.ts
var axisPointerClazz = {};
var AxisView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = AxisView2.type;
  }
  render(axisModel, ecModel, api2, payload) {
    this.axisPointerClass && fixValue(axisModel);
    super.render.apply(this, arguments);
    this._doUpdateAxisPointerClass(axisModel, api2, true);
  }
  updateAxisPointer(axisModel, ecModel, api2, payload) {
    this._doUpdateAxisPointerClass(axisModel, api2, false);
  }
  remove(ecModel, api2) {
    const axisPointer = this._axisPointer;
    axisPointer && axisPointer.remove(api2);
  }
  dispose(ecModel, api2) {
    this._disposeAxisPointer(api2);
    super.dispose.apply(this, arguments);
  }
  _doUpdateAxisPointerClass(axisModel, api2, forceRender) {
    const Clazz = AxisView2.getAxisPointerClass(this.axisPointerClass);
    if (!Clazz) {
      return;
    }
    const axisPointerModel = getAxisPointerModel(axisModel);
    axisPointerModel ? (this._axisPointer || (this._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api2, forceRender) : this._disposeAxisPointer(api2);
  }
  _disposeAxisPointer(api2) {
    this._axisPointer && this._axisPointer.dispose(api2);
    this._axisPointer = null;
  }
  static registerAxisPointerClass(type, clazz) {
    if (true) {
      if (axisPointerClazz[type]) {
        throw new Error("axisPointer " + type + " exists");
      }
    }
    axisPointerClazz[type] = clazz;
  }
  static getAxisPointerClass(type) {
    return type && axisPointerClazz[type];
  }
};
var AxisView = AxisView2;
AxisView.type = "axis";
var AxisView_default = AxisView;

// src/component/axis/axisSplitHelper.ts
var inner6 = makeInner();
function rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {
  const axis = axisModel.axis;
  if (axis.scale.isBlank()) {
    return;
  }
  const splitAreaModel = axisModel.getModel("splitArea");
  const areaStyleModel = splitAreaModel.getModel("areaStyle");
  let areaColors = areaStyleModel.get("color");
  const gridRect = gridModel.coordinateSystem.getRect();
  const ticksCoords = axis.getTicksCoords({
    tickModel: splitAreaModel,
    clamp: true,
    breakTicks: "none",
    pruneByBreak: "preserve_extent_bound"
  });
  if (!ticksCoords.length) {
    return;
  }
  const areaColorsLen = areaColors.length;
  const lastSplitAreaColors = inner6(axisView).splitAreaColors;
  const newSplitAreaColors = createHashMap();
  let colorIndex = 0;
  if (lastSplitAreaColors) {
    for (let i = 0; i < ticksCoords.length; i++) {
      const cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);
      if (cIndex != null) {
        colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;
        break;
      }
    }
  }
  let prev = axis.toGlobalCoord(ticksCoords[0].coord);
  const areaStyle = areaStyleModel.getAreaStyle();
  areaColors = isArray(areaColors) ? areaColors : [areaColors];
  for (let i = 1; i < ticksCoords.length; i++) {
    const tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
    let x;
    let y;
    let width;
    let height;
    if (axis.isHorizontal()) {
      x = prev;
      y = gridRect.y;
      width = tickCoord - x;
      height = gridRect.height;
      prev = x + width;
    } else {
      x = gridRect.x;
      y = prev;
      width = gridRect.width;
      height = tickCoord - y;
      prev = y + height;
    }
    const tickValue = ticksCoords[i - 1].tickValue;
    tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);
    axisGroup.add(new Rect_default({
      anid: tickValue != null ? "area_" + tickValue : null,
      shape: {
        x,
        y,
        width,
        height
      },
      style: defaults({
        fill: areaColors[colorIndex]
      }, areaStyle),
      autoBatch: true,
      silent: true
    }));
    colorIndex = (colorIndex + 1) % areaColorsLen;
  }
  inner6(axisView).splitAreaColors = newSplitAreaColors;
}
function rectCoordAxisHandleRemove(axisView) {
  inner6(axisView).splitAreaColors = null;
}

// src/component/axis/CartesianAxisView.ts
var selfBuilderAttrs = [
  "splitArea",
  "splitLine",
  "minorSplitLine",
  "breakArea"
];
var CartesianAxisView2 = class extends AxisView_default {
  constructor() {
    super(...arguments);
    this.type = CartesianAxisView2.type;
    this.axisPointerClass = "CartesianAxisPointer";
  }
  render(axisModel, ecModel, api2, payload) {
    this.group.removeAll();
    const oldAxisGroup = this._axisGroup;
    this._axisGroup = new Group_default();
    this.group.add(this._axisGroup);
    if (!shouldAxisShow(axisModel)) {
      return;
    }
    this._axisGroup.add(axisModel.axis.axisBuilder.group);
    each(selfBuilderAttrs, function(name) {
      if (axisModel.get([name, "show"])) {
        axisElementBuilders[name](this, this._axisGroup, axisModel, axisModel.getCoordSysModel(), api2);
      }
    }, this);
    const isInitialSortFromBarRacing = payload && payload.type === "changeAxisOrder" && payload.isInitSort;
    if (!isInitialSortFromBarRacing) {
      groupTransition(oldAxisGroup, this._axisGroup, axisModel);
    }
    super.render(axisModel, ecModel, api2, payload);
  }
  remove() {
    rectCoordAxisHandleRemove(this);
  }
};
var CartesianAxisView = CartesianAxisView2;
CartesianAxisView.type = "cartesianAxis";
var axisElementBuilders = {
  splitLine(axisView, axisGroup, axisModel, gridModel, api2) {
    const axis = axisModel.axis;
    if (axis.scale.isBlank()) {
      return;
    }
    const splitLineModel = axisModel.getModel("splitLine");
    const lineStyleModel = splitLineModel.getModel("lineStyle");
    let lineColors = lineStyleModel.get("color");
    const showMinLine = splitLineModel.get("showMinLine") !== false;
    const showMaxLine = splitLineModel.get("showMaxLine") !== false;
    lineColors = isArray(lineColors) ? lineColors : [lineColors];
    const gridRect = gridModel.coordinateSystem.getRect();
    const isHorizontal = axis.isHorizontal();
    let lineCount = 0;
    const ticksCoords = axis.getTicksCoords({
      tickModel: splitLineModel,
      breakTicks: "none",
      pruneByBreak: "preserve_extent_bound"
    });
    const p1 = [];
    const p2 = [];
    const lineStyle = lineStyleModel.getLineStyle();
    for (let i = 0; i < ticksCoords.length; i++) {
      const tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
      if (i === 0 && !showMinLine || i === ticksCoords.length - 1 && !showMaxLine) {
        continue;
      }
      const tickValue = ticksCoords[i].tickValue;
      if (isHorizontal) {
        p1[0] = tickCoord;
        p1[1] = gridRect.y;
        p2[0] = tickCoord;
        p2[1] = gridRect.y + gridRect.height;
      } else {
        p1[0] = gridRect.x;
        p1[1] = tickCoord;
        p2[0] = gridRect.x + gridRect.width;
        p2[1] = tickCoord;
      }
      const colorIndex = lineCount++ % lineColors.length;
      const line2 = new Line_default({
        anid: tickValue != null ? "line_" + tickValue : null,
        autoBatch: true,
        shape: {
          x1: p1[0],
          y1: p1[1],
          x2: p2[0],
          y2: p2[1]
        },
        style: defaults({
          stroke: lineColors[colorIndex]
        }, lineStyle),
        silent: true
      });
      subPixelOptimizeLine2(line2.shape, lineStyle.lineWidth);
      axisGroup.add(line2);
    }
  },
  minorSplitLine(axisView, axisGroup, axisModel, gridModel, api2) {
    const axis = axisModel.axis;
    const minorSplitLineModel = axisModel.getModel("minorSplitLine");
    const lineStyleModel = minorSplitLineModel.getModel("lineStyle");
    const gridRect = gridModel.coordinateSystem.getRect();
    const isHorizontal = axis.isHorizontal();
    const minorTicksCoords = axis.getMinorTicksCoords();
    if (!minorTicksCoords.length) {
      return;
    }
    const p1 = [];
    const p2 = [];
    const lineStyle = lineStyleModel.getLineStyle();
    for (let i = 0; i < minorTicksCoords.length; i++) {
      for (let k = 0; k < minorTicksCoords[i].length; k++) {
        const tickCoord = axis.toGlobalCoord(minorTicksCoords[i][k].coord);
        if (isHorizontal) {
          p1[0] = tickCoord;
          p1[1] = gridRect.y;
          p2[0] = tickCoord;
          p2[1] = gridRect.y + gridRect.height;
        } else {
          p1[0] = gridRect.x;
          p1[1] = tickCoord;
          p2[0] = gridRect.x + gridRect.width;
          p2[1] = tickCoord;
        }
        const line2 = new Line_default({
          anid: "minor_line_" + minorTicksCoords[i][k].tickValue,
          autoBatch: true,
          shape: {
            x1: p1[0],
            y1: p1[1],
            x2: p2[0],
            y2: p2[1]
          },
          style: lineStyle,
          silent: true
        });
        subPixelOptimizeLine2(line2.shape, lineStyle.lineWidth);
        axisGroup.add(line2);
      }
    }
  },
  splitArea(axisView, axisGroup, axisModel, gridModel, api2) {
    rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel);
  },
  breakArea(axisView, axisGroup, axisModel, gridModel, api2) {
    const axisBreakHelper = getAxisBreakHelper();
    const scale4 = axisModel.axis.scale;
    if (axisBreakHelper && scale4.type !== "ordinal") {
      axisBreakHelper.rectCoordBuildBreakAxis(axisGroup, axisView, axisModel, gridModel.coordinateSystem.getRect(), api2);
    }
  }
};
var CartesianXAxisView2 = class extends CartesianAxisView {
  constructor() {
    super(...arguments);
    this.type = CartesianXAxisView2.type;
  }
};
var CartesianXAxisView = CartesianXAxisView2;
CartesianXAxisView.type = "xAxis";
var CartesianYAxisView = class extends CartesianAxisView {
  constructor() {
    super(...arguments);
    this.type = CartesianXAxisView.type;
  }
};
CartesianYAxisView.type = "yAxis";

// src/component/grid/installSimple.ts
var GridView = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = "grid";
  }
  render(gridModel, ecModel) {
    this.group.removeAll();
    if (gridModel.get("show")) {
      this.group.add(new Rect_default({
        shape: gridModel.coordinateSystem.getRect(),
        style: defaults({
          fill: gridModel.get("backgroundColor")
        }, gridModel.getItemStyle()),
        silent: true,
        z2: -1
      }));
    }
  }
};
GridView.type = "grid";
var extraOption = {
  offset: 0
};
function install6(registers) {
  registers.registerComponentView(GridView);
  registers.registerComponentModel(GridModel_default);
  registers.registerCoordinateSystem("cartesian2d", Grid_default);
  axisModelCreator(registers, "x", CartesianAxisModel, extraOption);
  axisModelCreator(registers, "y", CartesianAxisModel, extraOption);
  registers.registerComponentView(CartesianXAxisView);
  registers.registerComponentView(CartesianYAxisView);
  registers.registerPreprocessor(function(option) {
    if (option.xAxis && option.yAxis && !option.grid) {
      option.grid = {};
    }
  });
}

// src/util/jitter.ts
function needFixJitter(seriesModel, axis) {
  const coordinateSystem = seriesModel.coordinateSystem;
  const coordType = coordinateSystem && coordinateSystem.type;
  const baseAxis = coordinateSystem && coordinateSystem.getBaseAxis && coordinateSystem.getBaseAxis();
  const scaleType = baseAxis && baseAxis.scale && baseAxis.scale.type;
  const seriesValid = coordType === "cartesian2d" && scaleType === "ordinal" || coordType === "single";
  const axisValid = axis.model.get("jitter") > 0;
  return seriesValid && axisValid;
}
var inner7 = makeInner();
function fixJitter(fixedAxis, fixedCoord, floatCoord, radius) {
  if (fixedAxis instanceof Axis2D_default) {
    const scaleType = fixedAxis.scale.type;
    if (scaleType !== "category" && scaleType !== "ordinal") {
      return floatCoord;
    }
  }
  const axisModel = fixedAxis.model;
  const jitter = axisModel.get("jitter");
  const jitterOverlap = axisModel.get("jitterOverlap");
  const jitterMargin = axisModel.get("jitterMargin") || 0;
  const bandWidth = fixedAxis.scale.type === "ordinal" ? fixedAxis.getBandWidth() : null;
  if (jitter > 0) {
    if (jitterOverlap) {
      return fixJitterIgnoreOverlaps(floatCoord, jitter, bandWidth, radius);
    } else {
      return fixJitterAvoidOverlaps(fixedAxis, fixedCoord, floatCoord, radius, jitter, jitterMargin);
    }
  }
  return floatCoord;
}
function fixJitterIgnoreOverlaps(floatCoord, jitter, bandWidth, radius) {
  if (bandWidth === null) {
    return floatCoord + (Math.random() - 0.5) * jitter;
  }
  const maxJitter = bandWidth - radius * 2;
  const actualJitter = Math.min(Math.max(0, jitter), maxJitter);
  return floatCoord + (Math.random() - 0.5) * actualJitter;
}
function fixJitterAvoidOverlaps(fixedAxis, fixedCoord, floatCoord, radius, jitter, margin) {
  const store = inner7(fixedAxis);
  if (!store.items) {
    store.items = {
      fixedCoord: -1,
      floatCoord: -1,
      r: -1,
      next: null,
      prev: null
    };
    store.items.next = store.items;
    store.items.prev = store.items;
  }
  const items = store.items;
  const overlapA = placeJitterOnDirection(items, fixedCoord, floatCoord, radius, jitter, margin, 1);
  const overlapB = placeJitterOnDirection(items, fixedCoord, floatCoord, radius, jitter, margin, -1);
  const overlapResult = Math.abs(overlapA.resultCoord - floatCoord) < Math.abs(overlapB.resultCoord - floatCoord) ? overlapA : overlapB;
  let minFloat = overlapResult.resultCoord;
  const bandWidth = fixedAxis.scale.type === "ordinal" ? fixedAxis.getBandWidth() : null;
  const distance2 = Math.abs(minFloat - floatCoord);
  if (distance2 > jitter / 2 || bandWidth && distance2 > bandWidth / 2 - radius) {
    minFloat = fixJitterIgnoreOverlaps(floatCoord, jitter, bandWidth, radius);
  }
  const insertBy = overlapResult.insertBy;
  const resultDirection = overlapResult.direction;
  const pointer1 = resultDirection > 0 ? "next" : "prev";
  const pointer2 = resultDirection > 0 ? "prev" : "next";
  const newItem = {
    fixedCoord,
    floatCoord: overlapResult.resultCoord,
    r: radius,
    next: null,
    prev: null
  };
  newItem[pointer1] = insertBy[pointer1];
  newItem[pointer2] = insertBy;
  insertBy[pointer1][pointer2] = newItem;
  insertBy[pointer1] = newItem;
  return minFloat;
}
function placeJitterOnDirection(items, fixedCoord, floatCoord, radius, jitter, margin, direction) {
  let y = floatCoord;
  const pointer1 = direction > 0 ? "next" : "prev";
  let insertBy = items;
  let item = items[pointer1];
  while (item !== items) {
    const dx = fixedCoord - item.fixedCoord;
    const dy = y - item.floatCoord;
    const d2 = dx * dx + dy * dy;
    const r = radius + item.r + margin;
    if (d2 < r * r) {
      y = item.floatCoord + Math.sqrt(r * r - dx * dx) * direction;
      insertBy = item;
      if (Math.abs(y - floatCoord) > jitter / 2) {
        return {resultCoord: Number.MAX_VALUE, insertBy, direction};
      }
    }
    item = item[pointer1];
  }
  return {resultCoord: y, insertBy, direction};
}

// src/chart/scatter/jitterLayout.ts
function jitterLayout(ecModel) {
  ecModel.eachSeriesByType("scatter", function(seriesModel) {
    const coordSys = seriesModel.coordinateSystem;
    if (coordSys && (coordSys.type === "cartesian2d" || coordSys.type === "single")) {
      const baseAxis = coordSys.getBaseAxis ? coordSys.getBaseAxis() : null;
      const hasJitter = baseAxis && needFixJitter(seriesModel, baseAxis);
      if (hasJitter) {
        const data = seriesModel.getData();
        data.each(function(idx) {
          const dim = baseAxis.dim;
          const orient = baseAxis.orient;
          const isSingleY = orient === "horizontal" && baseAxis.type !== "category" || orient === "vertical" && baseAxis.type === "category";
          const layout14 = data.getItemLayout(idx);
          const rawSize = data.getItemVisual(idx, "symbolSize");
          const size = rawSize instanceof Array ? (rawSize[1] + rawSize[0]) / 2 : rawSize;
          if (dim === "y" || dim === "single" && isSingleY) {
            const jittered = fixJitter(baseAxis, layout14[0], layout14[1], size / 2);
            data.setItemLayout(idx, [layout14[0], jittered]);
          } else if (dim === "x" || dim === "single" && !isSingleY) {
            const jittered = fixJitter(baseAxis, layout14[1], layout14[0], size / 2);
            data.setItemLayout(idx, [jittered, layout14[1]]);
          }
        });
      }
    }
  });
}

// src/chart/scatter/install.ts
function install7(registers) {
  use(install6);
  registers.registerSeriesModel(ScatterSeries_default);
  registers.registerChartView(ScatterView_default);
  registers.registerLayout(pointsLayout("scatter"));
}
function installScatterJitter(registers) {
  registers.registerLayout(registers.PRIORITY.VISUAL.POST_CHART_LAYOUT, jitterLayout);
}

// src/chart/radar/radarLayout.ts
function radarLayout(ecModel) {
  ecModel.eachSeriesByType("radar", function(seriesModel) {
    const data = seriesModel.getData();
    const points4 = [];
    const coordSys = seriesModel.coordinateSystem;
    if (!coordSys) {
      return;
    }
    const axes = coordSys.getIndicatorAxes();
    each(axes, function(axis, axisIndex) {
      data.each(data.mapDimension(axes[axisIndex].dim), function(val, dataIndex) {
        points4[dataIndex] = points4[dataIndex] || [];
        const point = coordSys.dataToPoint(val, axisIndex);
        points4[dataIndex][axisIndex] = isValidPoint(point) ? point : getValueMissingPoint(coordSys);
      });
    });
    data.each(function(idx) {
      const firstPoint = find(points4[idx], function(point) {
        return isValidPoint(point);
      }) || getValueMissingPoint(coordSys);
      points4[idx].push(firstPoint.slice());
      data.setItemLayout(idx, points4[idx]);
    });
  });
}
function isValidPoint(point) {
  return !isNaN(point[0]) && !isNaN(point[1]);
}
function getValueMissingPoint(coordSys) {
  return [coordSys.cx, coordSys.cy];
}

// src/chart/radar/backwardCompat.ts
function radarBackwardCompat(option) {
  let polarOptArr = option.polar;
  if (polarOptArr) {
    if (!isArray(polarOptArr)) {
      polarOptArr = [polarOptArr];
    }
    const polarNotRadar = [];
    each(polarOptArr, function(polarOpt, idx) {
      if (polarOpt.indicator) {
        if (polarOpt.type && !polarOpt.shape) {
          polarOpt.shape = polarOpt.type;
        }
        option.radar = option.radar || [];
        if (!isArray(option.radar)) {
          option.radar = [option.radar];
        }
        option.radar.push(polarOpt);
      } else {
        polarNotRadar.push(polarOpt);
      }
    });
    option.polar = polarNotRadar;
  }
  each(option.series, function(seriesOpt) {
    if (seriesOpt && seriesOpt.type === "radar" && seriesOpt.polarIndex) {
      seriesOpt.radarIndex = seriesOpt.polarIndex;
    }
  });
}

// src/chart/radar/RadarView.ts
var RadarView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = RadarView2.type;
  }
  render(seriesModel, ecModel, api2) {
    const polar = seriesModel.coordinateSystem;
    const group = this.group;
    const data = seriesModel.getData();
    const oldData = this._data;
    function createSymbol3(data2, idx) {
      const symbolType = data2.getItemVisual(idx, "symbol") || "circle";
      if (symbolType === "none") {
        return;
      }
      const symbolSize = normalizeSymbolSize(data2.getItemVisual(idx, "symbolSize"));
      const symbolPath = createSymbol(symbolType, -1, -1, 2, 2);
      const symbolRotate = data2.getItemVisual(idx, "symbolRotate") || 0;
      symbolPath.attr({
        style: {
          strokeNoScale: true
        },
        z2: 100,
        scaleX: symbolSize[0] / 2,
        scaleY: symbolSize[1] / 2,
        rotation: symbolRotate * Math.PI / 180 || 0
      });
      return symbolPath;
    }
    function updateSymbols(oldPoints, newPoints, symbolGroup, data2, idx, isInit) {
      symbolGroup.removeAll();
      for (let i = 0; i < newPoints.length - 1; i++) {
        const symbolPath = createSymbol3(data2, idx);
        if (symbolPath) {
          symbolPath.__dimIdx = i;
          if (oldPoints[i]) {
            symbolPath.setPosition(oldPoints[i]);
            graphic_exports[isInit ? "initProps" : "updateProps"](symbolPath, {
              x: newPoints[i][0],
              y: newPoints[i][1]
            }, seriesModel, idx);
          } else {
            symbolPath.setPosition(newPoints[i]);
          }
          symbolGroup.add(symbolPath);
        }
      }
    }
    function getInitialPoints(points4) {
      return map(points4, function(pt) {
        return [polar.cx, polar.cy];
      });
    }
    data.diff(oldData).add(function(idx) {
      const points4 = data.getItemLayout(idx);
      if (!points4) {
        return;
      }
      const polygon = new Polygon_default();
      const polyline = new Polyline_default();
      const target = {
        shape: {
          points: points4
        }
      };
      polygon.shape.points = getInitialPoints(points4);
      polyline.shape.points = getInitialPoints(points4);
      initProps(polygon, target, seriesModel, idx);
      initProps(polyline, target, seriesModel, idx);
      const itemGroup = new Group_default();
      const symbolGroup = new Group_default();
      itemGroup.add(polyline);
      itemGroup.add(polygon);
      itemGroup.add(symbolGroup);
      updateSymbols(polyline.shape.points, points4, symbolGroup, data, idx, true);
      data.setItemGraphicEl(idx, itemGroup);
    }).update(function(newIdx, oldIdx) {
      const itemGroup = oldData.getItemGraphicEl(oldIdx);
      const polyline = itemGroup.childAt(0);
      const polygon = itemGroup.childAt(1);
      const symbolGroup = itemGroup.childAt(2);
      const target = {
        shape: {
          points: data.getItemLayout(newIdx)
        }
      };
      if (!target.shape.points) {
        return;
      }
      updateSymbols(polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false);
      saveOldStyle(polygon);
      saveOldStyle(polyline);
      updateProps(polyline, target, seriesModel);
      updateProps(polygon, target, seriesModel);
      data.setItemGraphicEl(newIdx, itemGroup);
    }).remove(function(idx) {
      group.remove(oldData.getItemGraphicEl(idx));
    }).execute();
    data.eachItemGraphicEl(function(itemGroup, idx) {
      const itemModel = data.getItemModel(idx);
      const polyline = itemGroup.childAt(0);
      const polygon = itemGroup.childAt(1);
      const symbolGroup = itemGroup.childAt(2);
      const itemStyle = data.getItemVisual(idx, "style");
      const color4 = itemStyle.fill;
      group.add(itemGroup);
      polyline.useStyle(defaults(itemModel.getModel("lineStyle").getLineStyle(), {
        fill: "none",
        stroke: color4
      }));
      setStatesStylesFromModel(polyline, itemModel, "lineStyle");
      setStatesStylesFromModel(polygon, itemModel, "areaStyle");
      const areaStyleModel = itemModel.getModel("areaStyle");
      const polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();
      polygon.ignore = polygonIgnore;
      each(["emphasis", "select", "blur"], function(stateName) {
        const stateModel = itemModel.getModel([stateName, "areaStyle"]);
        const stateIgnore = stateModel.isEmpty() && stateModel.parentModel.isEmpty();
        polygon.ensureState(stateName).ignore = stateIgnore && polygonIgnore;
      });
      polygon.useStyle(defaults(areaStyleModel.getAreaStyle(), {
        fill: color4,
        opacity: 0.7,
        decal: itemStyle.decal
      }));
      const emphasisModel = itemModel.getModel("emphasis");
      const itemHoverStyle = emphasisModel.getModel("itemStyle").getItemStyle();
      symbolGroup.eachChild(function(symbolPath) {
        if (symbolPath instanceof Image_default) {
          const pathStyle = symbolPath.style;
          symbolPath.useStyle(extend({
            image: pathStyle.image,
            x: pathStyle.x,
            y: pathStyle.y,
            width: pathStyle.width,
            height: pathStyle.height
          }, itemStyle));
        } else {
          symbolPath.useStyle(itemStyle);
          symbolPath.setColor(color4);
          symbolPath.style.strokeNoScale = true;
        }
        const pathEmphasisState = symbolPath.ensureState("emphasis");
        pathEmphasisState.style = clone(itemHoverStyle);
        let defaultText = data.getStore().get(data.getDimensionIndex(symbolPath.__dimIdx), idx);
        (defaultText == null || isNaN(defaultText)) && (defaultText = "");
        setLabelStyle(symbolPath, getLabelStatesModels(itemModel), {
          labelFetcher: data.hostModel,
          labelDataIndex: idx,
          labelDimIndex: symbolPath.__dimIdx,
          defaultText,
          inheritColor: color4,
          defaultOpacity: itemStyle.opacity
        });
      });
      toggleHoverEmphasis(itemGroup, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    });
    this._data = data;
  }
  remove() {
    this.group.removeAll();
    this._data = null;
  }
};
var RadarView = RadarView2;
RadarView.type = "radar";
var RadarView_default = RadarView;

// src/chart/radar/RadarSeries.ts
var RadarSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = RadarSeriesModel2.type;
    this.hasSymbolVisual = true;
  }
  init(option) {
    super.init.apply(this, arguments);
    this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this));
  }
  getInitialData(option, ecModel) {
    return createSeriesDataSimply(this, {
      generateCoord: "indicator_",
      generateCoordCount: Infinity
    });
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    const data = this.getData();
    const coordSys = this.coordinateSystem;
    const indicatorAxes = coordSys.getIndicatorAxes();
    const name = this.getData().getName(dataIndex);
    const nameToDisplay = name === "" ? this.name : name;
    const markerColor = retrieveVisualColorForTooltipMarker(this, dataIndex);
    return createTooltipMarkup("section", {
      header: nameToDisplay,
      sortBlocks: true,
      blocks: map(indicatorAxes, (axis) => {
        const val = data.get(data.mapDimension(axis.dim), dataIndex);
        return createTooltipMarkup("nameValue", {
          markerType: "subItem",
          markerColor,
          name: axis.name,
          value: val,
          sortParam: val
        });
      })
    });
  }
  getTooltipPosition(dataIndex) {
    if (dataIndex != null) {
      const data = this.getData();
      const coordSys = this.coordinateSystem;
      const values = data.getValues(map(coordSys.dimensions, function(dim) {
        return data.mapDimension(dim);
      }), dataIndex);
      for (let i = 0, len2 = values.length; i < len2; i++) {
        if (!isNaN(values[i])) {
          const indicatorAxes = coordSys.getIndicatorAxes();
          return coordSys.coordToPoint(indicatorAxes[i].dataToCoord(values[i]), i);
        }
      }
    }
  }
};
var RadarSeriesModel = RadarSeriesModel2;
RadarSeriesModel.type = "series.radar";
RadarSeriesModel.dependencies = ["radar"];
RadarSeriesModel.defaultOption = {
  z: 2,
  colorBy: "data",
  coordinateSystem: "radar",
  legendHoverLink: true,
  radarIndex: 0,
  lineStyle: {
    width: 2,
    type: "solid",
    join: "round"
  },
  label: {
    position: "top"
  },
  symbolSize: 8
};
var RadarSeries_default = RadarSeriesModel;

// src/coord/radar/RadarModel.ts
var valueAxisDefault = axisDefault_default.value;
function defaultsShow(opt, show) {
  return defaults({
    show
  }, opt);
}
var RadarModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = RadarModel2.type;
  }
  optionUpdated() {
    const boundaryGap = this.get("boundaryGap");
    const splitNumber = this.get("splitNumber");
    const scale4 = this.get("scale");
    const axisLine = this.get("axisLine");
    const axisTick = this.get("axisTick");
    const axisLabel = this.get("axisLabel");
    const nameTextStyle = this.get("axisName");
    const showName = this.get(["axisName", "show"]);
    const nameFormatter = this.get(["axisName", "formatter"]);
    const nameGap = this.get("axisNameGap");
    const triggerEvent = this.get("triggerEvent");
    const indicatorModels = map(this.get("indicator") || [], function(indicatorOpt) {
      if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {
        indicatorOpt.min = 0;
      } else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {
        indicatorOpt.max = 0;
      }
      let iNameTextStyle = nameTextStyle;
      if (indicatorOpt.color != null) {
        iNameTextStyle = defaults({
          color: indicatorOpt.color
        }, nameTextStyle);
      }
      const innerIndicatorOpt = merge(clone(indicatorOpt), {
        boundaryGap,
        splitNumber,
        scale: scale4,
        axisLine,
        axisTick,
        axisLabel,
        name: indicatorOpt.text,
        showName,
        nameLocation: "end",
        nameGap,
        nameTextStyle: iNameTextStyle,
        triggerEvent
      }, false);
      if (isString(nameFormatter)) {
        const indName = innerIndicatorOpt.name;
        innerIndicatorOpt.name = nameFormatter.replace("{value}", indName != null ? indName : "");
      } else if (isFunction(nameFormatter)) {
        innerIndicatorOpt.name = nameFormatter(innerIndicatorOpt.name, innerIndicatorOpt);
      }
      const model = new Model_default(innerIndicatorOpt, null, this.ecModel);
      mixin(model, AxisModelCommonMixin.prototype);
      model.mainType = "radar";
      model.componentIndex = this.componentIndex;
      return model;
    }, this);
    this._indicatorModels = indicatorModels;
  }
  getIndicatorModels() {
    return this._indicatorModels;
  }
};
var RadarModel = RadarModel2;
RadarModel.type = "radar";
RadarModel.defaultOption = {
  z: 0,
  center: ["50%", "50%"],
  radius: "50%",
  startAngle: 90,
  axisName: {
    show: true,
    color: tokens_default.color.axisLabel
  },
  boundaryGap: [0, 0],
  splitNumber: 5,
  axisNameGap: 15,
  scale: false,
  shape: "polygon",
  axisLine: merge({
    lineStyle: {
      color: tokens_default.color.neutral20
    }
  }, valueAxisDefault.axisLine),
  axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),
  axisTick: defaultsShow(valueAxisDefault.axisTick, false),
  splitLine: defaultsShow(valueAxisDefault.splitLine, true),
  splitArea: defaultsShow(valueAxisDefault.splitArea, true),
  indicator: []
};
var RadarModel_default = RadarModel;

// src/component/radar/RadarView.ts
var RadarView4 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = RadarView4.type;
  }
  render(radarModel, ecModel, api2) {
    const group = this.group;
    group.removeAll();
    this._buildAxes(radarModel, api2);
    this._buildSplitLineAndArea(radarModel);
  }
  _buildAxes(radarModel, api2) {
    const radar = radarModel.coordinateSystem;
    const indicatorAxes = radar.getIndicatorAxes();
    const axisBuilders = map(indicatorAxes, function(indicatorAxis) {
      const axisName = indicatorAxis.model.get("showName") ? indicatorAxis.name : "";
      const axisBuilder = new AxisBuilder_default(indicatorAxis.model, api2, {
        axisName,
        position: [radar.cx, radar.cy],
        rotation: indicatorAxis.angle,
        labelDirection: -1,
        tickDirection: -1,
        nameDirection: 1
      });
      return axisBuilder;
    });
    each(axisBuilders, function(axisBuilder) {
      axisBuilder.build();
      this.group.add(axisBuilder.group);
    }, this);
  }
  _buildSplitLineAndArea(radarModel) {
    const radar = radarModel.coordinateSystem;
    const indicatorAxes = radar.getIndicatorAxes();
    if (!indicatorAxes.length) {
      return;
    }
    const shape = radarModel.get("shape");
    const splitLineModel = radarModel.getModel("splitLine");
    const splitAreaModel = radarModel.getModel("splitArea");
    const lineStyleModel = splitLineModel.getModel("lineStyle");
    const areaStyleModel = splitAreaModel.getModel("areaStyle");
    const showSplitLine = splitLineModel.get("show");
    const showSplitArea = splitAreaModel.get("show");
    const splitLineColors = lineStyleModel.get("color");
    const splitAreaColors = areaStyleModel.get("color");
    const splitLineColorsArr = isArray(splitLineColors) ? splitLineColors : [splitLineColors];
    const splitAreaColorsArr = isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];
    const splitLines = [];
    const splitAreas = [];
    function getColorIndex(areaOrLine, areaOrLineColorList, idx) {
      const colorIndex = idx % areaOrLineColorList.length;
      areaOrLine[colorIndex] = areaOrLine[colorIndex] || [];
      return colorIndex;
    }
    if (shape === "circle") {
      const ticksRadius = indicatorAxes[0].getTicksCoords();
      const cx = radar.cx;
      const cy = radar.cy;
      for (let i = 0; i < ticksRadius.length; i++) {
        if (showSplitLine) {
          const colorIndex = getColorIndex(splitLines, splitLineColorsArr, i);
          splitLines[colorIndex].push(new Circle_default({
            shape: {
              cx,
              cy,
              r: ticksRadius[i].coord
            }
          }));
        }
        if (showSplitArea && i < ticksRadius.length - 1) {
          const colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i);
          splitAreas[colorIndex].push(new Ring_default({
            shape: {
              cx,
              cy,
              r0: ticksRadius[i].coord,
              r: ticksRadius[i + 1].coord
            }
          }));
        }
      }
    } else {
      let realSplitNumber;
      const axesTicksPoints = map(indicatorAxes, function(indicatorAxis, idx) {
        const ticksCoords = indicatorAxis.getTicksCoords();
        realSplitNumber = realSplitNumber == null ? ticksCoords.length - 1 : Math.min(ticksCoords.length - 1, realSplitNumber);
        return map(ticksCoords, function(tickCoord) {
          return radar.coordToPoint(tickCoord.coord, idx);
        });
      });
      let prevPoints = [];
      for (let i = 0; i <= realSplitNumber; i++) {
        const points4 = [];
        for (let j = 0; j < indicatorAxes.length; j++) {
          points4.push(axesTicksPoints[j][i]);
        }
        if (points4[0]) {
          points4.push(points4[0].slice());
        } else {
          if (true) {
            console.error("Can't draw value axis " + i);
          }
        }
        if (showSplitLine) {
          const colorIndex = getColorIndex(splitLines, splitLineColorsArr, i);
          splitLines[colorIndex].push(new Polyline_default({
            shape: {
              points: points4
            }
          }));
        }
        if (showSplitArea && prevPoints) {
          const colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i - 1);
          splitAreas[colorIndex].push(new Polygon_default({
            shape: {
              points: points4.concat(prevPoints)
            }
          }));
        }
        prevPoints = points4.slice().reverse();
      }
    }
    const lineStyle = lineStyleModel.getLineStyle();
    const areaStyle = areaStyleModel.getAreaStyle();
    each(splitAreas, function(splitAreas2, idx) {
      this.group.add(mergePath2(splitAreas2, {
        style: defaults({
          stroke: "none",
          fill: splitAreaColorsArr[idx % splitAreaColorsArr.length]
        }, areaStyle),
        silent: true
      }));
    }, this);
    each(splitLines, function(splitLines2, idx) {
      this.group.add(mergePath2(splitLines2, {
        style: defaults({
          fill: "none",
          stroke: splitLineColorsArr[idx % splitLineColorsArr.length]
        }, lineStyle),
        silent: true
      }));
    }, this);
  }
};
var RadarView3 = RadarView4;
RadarView3.type = "radar";
var RadarView_default2 = RadarView3;

// src/coord/radar/IndicatorAxis.ts
var IndicatorAxis = class extends Axis_default {
  constructor(dim, scale4, radiusExtent) {
    super(dim, scale4, radiusExtent);
    this.type = "value";
    this.angle = 0;
    this.name = "";
  }
};
var IndicatorAxis_default = IndicatorAxis;

// src/coord/radar/Radar.ts
var Radar2 = class {
  constructor(radarModel, ecModel, api2) {
    this.dimensions = [];
    this._model = radarModel;
    this._indicatorAxes = map(radarModel.getIndicatorModels(), function(indicatorModel, idx) {
      const dim = "indicator_" + idx;
      const indicatorAxis = new IndicatorAxis_default(dim, new Interval_default());
      indicatorAxis.name = indicatorModel.get("name");
      indicatorAxis.model = indicatorModel;
      indicatorModel.axis = indicatorAxis;
      this.dimensions.push(dim);
      return indicatorAxis;
    }, this);
    this.resize(radarModel, api2);
  }
  getIndicatorAxes() {
    return this._indicatorAxes;
  }
  dataToPoint(value, indicatorIndex) {
    const indicatorAxis = this._indicatorAxes[indicatorIndex];
    return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);
  }
  coordToPoint(coord, indicatorIndex) {
    const indicatorAxis = this._indicatorAxes[indicatorIndex];
    const angle = indicatorAxis.angle;
    const x = this.cx + coord * Math.cos(angle);
    const y = this.cy - coord * Math.sin(angle);
    return [x, y];
  }
  pointToData(pt) {
    let dx = pt[0] - this.cx;
    let dy = pt[1] - this.cy;
    const radius = Math.sqrt(dx * dx + dy * dy);
    dx /= radius;
    dy /= radius;
    const radian = Math.atan2(-dy, dx);
    let minRadianDiff = Infinity;
    let closestAxis;
    let closestAxisIdx = -1;
    for (let i = 0; i < this._indicatorAxes.length; i++) {
      const indicatorAxis = this._indicatorAxes[i];
      const diff = Math.abs(radian - indicatorAxis.angle);
      if (diff < minRadianDiff) {
        closestAxis = indicatorAxis;
        closestAxisIdx = i;
        minRadianDiff = diff;
      }
    }
    return [closestAxisIdx, +(closestAxis && closestAxis.coordToData(radius))];
  }
  resize(radarModel, api2) {
    const refContainer = createBoxLayoutReference(radarModel, api2).refContainer;
    const center3 = radarModel.get("center");
    const viewSize = Math.min(refContainer.width, refContainer.height) / 2;
    this.cx = parsePercent2(center3[0], refContainer.width) + refContainer.x;
    this.cy = parsePercent2(center3[1], refContainer.height) + refContainer.y;
    this.startAngle = radarModel.get("startAngle") * Math.PI / 180;
    let radius = radarModel.get("radius");
    if (isString(radius) || isNumber(radius)) {
      radius = [0, radius];
    }
    this.r0 = parsePercent2(radius[0], viewSize);
    this.r = parsePercent2(radius[1], viewSize);
    each(this._indicatorAxes, function(indicatorAxis, idx) {
      indicatorAxis.setExtent(this.r0, this.r);
      let angle = this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length;
      angle = Math.atan2(Math.sin(angle), Math.cos(angle));
      indicatorAxis.angle = angle;
    }, this);
  }
  update(ecModel, api2) {
    const indicatorAxes = this._indicatorAxes;
    const radarModel = this._model;
    each(indicatorAxes, function(indicatorAxis) {
      indicatorAxis.scale.setExtent(Infinity, -Infinity);
    });
    ecModel.eachSeriesByType("radar", function(radarSeries, idx) {
      if (radarSeries.get("coordinateSystem") !== "radar" || ecModel.getComponent("radar", radarSeries.get("radarIndex")) !== radarModel) {
        return;
      }
      const data = radarSeries.getData();
      each(indicatorAxes, function(indicatorAxis) {
        indicatorAxis.scale.unionExtentFromData(data, data.mapDimension(indicatorAxis.dim));
      });
    }, this);
    const splitNumber = radarModel.get("splitNumber");
    const dummyScale = new Interval_default();
    dummyScale.setExtent(0, splitNumber);
    dummyScale.setInterval(1);
    each(indicatorAxes, function(indicatorAxis, idx) {
      alignScaleTicks(indicatorAxis.scale, indicatorAxis.model, dummyScale);
    });
  }
  convertToPixel(ecModel, finder, value) {
    console.warn("Not implemented.");
    return null;
  }
  convertFromPixel(ecModel, finder, pixel) {
    console.warn("Not implemented.");
    return null;
  }
  containPoint(point) {
    console.warn("Not implemented.");
    return false;
  }
  static create(ecModel, api2) {
    const radarList = [];
    ecModel.eachComponent("radar", function(radarModel) {
      const radar = new Radar2(radarModel, ecModel, api2);
      radarList.push(radar);
      radarModel.coordinateSystem = radar;
    });
    ecModel.eachSeriesByType("radar", function(radarSeries) {
      if (radarSeries.get("coordinateSystem") === "radar") {
        radarSeries.coordinateSystem = radarList[radarSeries.get("radarIndex") || 0];
      }
    });
    return radarList;
  }
};
var Radar = Radar2;
Radar.dimensions = [];
var Radar_default = Radar;

// src/component/radar/install.ts
function install8(registers) {
  registers.registerCoordinateSystem("radar", Radar_default);
  registers.registerComponentModel(RadarModel_default);
  registers.registerComponentView(RadarView_default2);
  registers.registerVisual({
    seriesType: "radar",
    reset: function(seriesModel) {
      const data = seriesModel.getData();
      data.each(function(idx) {
        data.setItemVisual(idx, "legendIcon", "roundRect");
      });
      data.setVisual("legendIcon", "roundRect");
    }
  });
}

// src/chart/radar/install.ts
function install9(registers) {
  use(install8);
  registers.registerChartView(RadarView_default);
  registers.registerSeriesModel(RadarSeries_default);
  registers.registerLayout(radarLayout);
  registers.registerProcessor(dataFilter("radar"));
  registers.registerPreprocessor(radarBackwardCompat);
}

// src/component/helper/interactionMutex.ts
var inner8 = makeInner();
function take(zr, resourceKey, userKey) {
  inner8(zr)[resourceKey] = userKey;
}
function release(zr, resourceKey, userKey) {
  const store = inner8(zr);
  const uKey = store[resourceKey];
  if (uKey === userKey) {
    store[resourceKey] = null;
  }
}
function isTaken(zr, resourceKey) {
  return !!inner8(zr)[resourceKey];
}
registerAction({type: "takeGlobalCursor", event: "globalCursorTaken", update: "update"}, noop);

// src/component/helper/cursorHelper.ts
var IRRELEVANT_EXCLUDES = {axisPointer: 1, tooltip: 1, brush: 1};
function onIrrelevantElement(e2, api2, targetComponent) {
  const eventElComponent = api2.getComponentByElement(e2.topTarget);
  if (!eventElComponent || eventElComponent === targetComponent || IRRELEVANT_EXCLUDES.hasOwnProperty(eventElComponent.mainType)) {
    return false;
  }
  const eventElCoordSys = eventElComponent.coordinateSystem;
  if (!eventElCoordSys || eventElCoordSys.model === targetComponent) {
    return false;
  }
  const eventElCmptZInfo = retrieveZInfo(eventElComponent);
  const targetCmptZInfo = retrieveZInfo(targetComponent);
  if ((eventElCmptZInfo.zlevel - targetCmptZInfo.zlevel || eventElCmptZInfo.z - targetCmptZInfo.z) <= 0) {
    return false;
  }
  return true;
}

// src/component/helper/RoamController.ts
var RoamController = class extends Eventful_default {
  constructor(zr) {
    super();
    this._zr = zr;
    const mousedownHandler = bind(this._mousedownHandler, this);
    const mousemoveHandler = bind(this._mousemoveHandler, this);
    const mouseupHandler = bind(this._mouseupHandler, this);
    const mousewheelHandler = bind(this._mousewheelHandler, this);
    const pinchHandler = bind(this._pinchHandler, this);
    this.enable = function(controlType, rawOpt) {
      const zInfo = rawOpt.zInfo;
      const {z, zlevel} = retrieveZInfo(zInfo.component);
      const zInfoParsed = {
        component: zInfo.component,
        z,
        zlevel,
        z2: retrieve2(zInfo.z2, -Infinity)
      };
      const triggerInfo = extend({}, rawOpt.triggerInfo);
      this._opt = defaults(extend({}, rawOpt), {
        zoomOnMouseWheel: true,
        moveOnMouseMove: true,
        moveOnMouseWheel: false,
        preventDefaultMouseMove: true,
        zInfoParsed,
        triggerInfo
      });
      if (controlType == null) {
        controlType = true;
      }
      if (!this._enabled || this._controlType !== controlType) {
        this._enabled = true;
        this.disable();
        if (controlType === true || (controlType === "move" || controlType === "pan")) {
          addRoamZrListener(zr, "mousedown", mousedownHandler, zInfoParsed);
          addRoamZrListener(zr, "mousemove", mousemoveHandler, zInfoParsed);
          addRoamZrListener(zr, "mouseup", mouseupHandler, zInfoParsed);
        }
        if (controlType === true || (controlType === "scale" || controlType === "zoom")) {
          addRoamZrListener(zr, "mousewheel", mousewheelHandler, zInfoParsed);
          addRoamZrListener(zr, "pinch", pinchHandler, zInfoParsed);
        }
      }
    };
    this.disable = function() {
      this._enabled = false;
      removeRoamZrListener(zr, "mousedown", mousedownHandler);
      removeRoamZrListener(zr, "mousemove", mousemoveHandler);
      removeRoamZrListener(zr, "mouseup", mouseupHandler);
      removeRoamZrListener(zr, "mousewheel", mousewheelHandler);
      removeRoamZrListener(zr, "pinch", pinchHandler);
    };
  }
  isDragging() {
    return this._dragging;
  }
  isPinching() {
    return this._pinching;
  }
  _checkPointer(e2, x, y) {
    const opt = this._opt;
    const zInfoParsed = opt.zInfoParsed;
    if (onIrrelevantElement(e2, opt.api, zInfoParsed.component)) {
      return false;
    }
    ;
    const triggerInfo = opt.triggerInfo;
    const roamTrigger = triggerInfo.roamTrigger;
    let inArea = false;
    if (roamTrigger === "global") {
      inArea = true;
    }
    if (!inArea) {
      inArea = triggerInfo.isInSelf(e2, x, y);
    }
    if (inArea && triggerInfo.isInClip && !triggerInfo.isInClip(e2, x, y)) {
      inArea = false;
    }
    return inArea;
  }
  _decideCursorStyle(e2, x, y, forReverse) {
    const target = e2.target;
    if (!target && this._checkPointer(e2, x, y)) {
      return "grab";
    }
    if (forReverse) {
      return target && target.cursor || "default";
    }
  }
  dispose() {
    this.disable();
  }
  _mousedownHandler(e2) {
    if (isMiddleOrRightButtonOnMouseUpDown(e2) || eventConsumed(e2)) {
      return;
    }
    let el = e2.target;
    while (el) {
      if (el.draggable) {
        return;
      }
      el = el.__hostTarget || el.parent;
    }
    const x = e2.offsetX;
    const y = e2.offsetY;
    if (this._checkPointer(e2, x, y)) {
      this._x = x;
      this._y = y;
      this._dragging = true;
    }
  }
  _mousemoveHandler(e2) {
    const zr = this._zr;
    if (e2.gestureEvent === "pinch" || isTaken(zr, "globalPan") || eventConsumed(e2)) {
      return;
    }
    const x = e2.offsetX;
    const y = e2.offsetY;
    if (!this._dragging || !isAvailableBehavior("moveOnMouseMove", e2, this._opt)) {
      const cursorStyle = this._decideCursorStyle(e2, x, y, false);
      if (cursorStyle) {
        zr.setCursorStyle(cursorStyle);
      }
      return;
    }
    zr.setCursorStyle("grabbing");
    const oldX = this._x;
    const oldY = this._y;
    const dx = x - oldX;
    const dy = y - oldY;
    this._x = x;
    this._y = y;
    if (this._opt.preventDefaultMouseMove) {
      stop(e2.event);
    }
    e2.__ecRoamConsumed = true;
    trigger(this, "pan", "moveOnMouseMove", e2, {
      dx,
      dy,
      oldX,
      oldY,
      newX: x,
      newY: y,
      isAvailableBehavior: null
    });
  }
  _mouseupHandler(e2) {
    if (eventConsumed(e2)) {
      return;
    }
    const zr = this._zr;
    if (!isMiddleOrRightButtonOnMouseUpDown(e2)) {
      this._dragging = false;
      const cursorStyle = this._decideCursorStyle(e2, e2.offsetX, e2.offsetY, true);
      if (cursorStyle) {
        zr.setCursorStyle(cursorStyle);
      }
    }
  }
  _mousewheelHandler(e2) {
    if (eventConsumed(e2)) {
      return;
    }
    const shouldZoom = isAvailableBehavior("zoomOnMouseWheel", e2, this._opt);
    const shouldMove = isAvailableBehavior("moveOnMouseWheel", e2, this._opt);
    const wheelDelta = e2.wheelDelta;
    const absWheelDeltaDelta = Math.abs(wheelDelta);
    const originX = e2.offsetX;
    const originY = e2.offsetY;
    if (wheelDelta === 0 || !shouldZoom && !shouldMove) {
      return;
    }
    if (shouldZoom) {
      const factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1;
      const scale4 = wheelDelta > 0 ? factor : 1 / factor;
      this._checkTriggerMoveZoom(this, "zoom", "zoomOnMouseWheel", e2, {
        scale: scale4,
        originX,
        originY,
        isAvailableBehavior: null
      });
    }
    if (shouldMove) {
      const absDelta = Math.abs(wheelDelta);
      const scrollDelta = (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? 0.4 : absDelta > 1 ? 0.15 : 0.05);
      this._checkTriggerMoveZoom(this, "scrollMove", "moveOnMouseWheel", e2, {
        scrollDelta,
        originX,
        originY,
        isAvailableBehavior: null
      });
    }
  }
  _pinchHandler(e2) {
    if (isTaken(this._zr, "globalPan") || eventConsumed(e2)) {
      return;
    }
    const scale4 = e2.pinchScale > 1 ? 1.1 : 1 / 1.1;
    this._checkTriggerMoveZoom(this, "zoom", null, e2, {
      scale: scale4,
      originX: e2.pinchX,
      originY: e2.pinchY,
      isAvailableBehavior: null
    });
  }
  _checkTriggerMoveZoom(controller, eventName, behaviorToCheck, e2, contollerEvent) {
    if (controller._checkPointer(e2, contollerEvent.originX, contollerEvent.originY)) {
      stop(e2.event);
      e2.__ecRoamConsumed = true;
      trigger(controller, eventName, behaviorToCheck, e2, contollerEvent);
    }
  }
};
function eventConsumed(e2) {
  return e2.__ecRoamConsumed;
}
var innerZrStore = makeInner();
function ensureZrStore(zr) {
  const store = innerZrStore(zr);
  store.roam = store.roam || {};
  store.uniform = store.uniform || {};
  return store;
}
function addRoamZrListener(zr, eventType, listener, zInfoParsed) {
  const store = ensureZrStore(zr);
  const roam = store.roam;
  const listenerList = roam[eventType] = roam[eventType] || [];
  let idx = 0;
  for (; idx < listenerList.length; idx++) {
    const currZInfo = listenerList[idx].zInfoParsed;
    if ((currZInfo.zlevel - zInfoParsed.zlevel || currZInfo.z - zInfoParsed.z || currZInfo.z2 - zInfoParsed.z2) <= 0) {
      break;
    }
  }
  listenerList.splice(idx, 0, {listener, zInfoParsed});
  ensureUniformListener(zr, eventType);
}
function removeRoamZrListener(zr, eventType, listener) {
  const store = ensureZrStore(zr);
  const listenerList = store.roam[eventType] || [];
  for (let idx = 0; idx < listenerList.length; idx++) {
    if (listenerList[idx].listener === listener) {
      listenerList.splice(idx, 1);
      if (!listenerList.length) {
        removeUniformListener(zr, eventType);
      }
      return;
    }
  }
}
function ensureUniformListener(zr, eventType) {
  const store = ensureZrStore(zr);
  if (!store.uniform[eventType]) {
    zr.on(eventType, store.uniform[eventType] = function(event) {
      const listenerList = store.roam[eventType];
      if (listenerList) {
        for (let i = 0; i < listenerList.length; i++) {
          listenerList[i].listener(event);
        }
      }
    });
  }
}
function removeUniformListener(zr, eventType) {
  const store = ensureZrStore(zr);
  const uniform = store.uniform;
  if (uniform[eventType]) {
    zr.off(eventType, uniform[eventType]);
    uniform[eventType] = null;
  }
}
function trigger(controller, eventName, behaviorToCheck, e2, contollerEvent) {
  contollerEvent.isAvailableBehavior = bind(isAvailableBehavior, null, behaviorToCheck, e2);
  controller.trigger(eventName, contollerEvent);
}
function isAvailableBehavior(behaviorToCheck, e2, settings) {
  const setting = settings[behaviorToCheck];
  return !behaviorToCheck || setting && (!isString(setting) || e2.event[setting + "Key"]);
}
var RoamController_default = RoamController;

// src/component/helper/roamHelper.ts
function updateViewOnPan(controllerHost, dx, dy) {
  const target = controllerHost.target;
  target.x += dx;
  target.y += dy;
  target.dirty();
}
function updateViewOnZoom(controllerHost, zoomDelta, zoomX, zoomY) {
  const target = controllerHost.target;
  const zoomLimit = controllerHost.zoomLimit;
  let newZoom = controllerHost.zoom = controllerHost.zoom || 1;
  newZoom *= zoomDelta;
  newZoom = clampByZoomLimit(newZoom, zoomLimit);
  const zoomScale = newZoom / controllerHost.zoom;
  controllerHost.zoom = newZoom;
  zoomTransformableByOrigin(target, zoomX, zoomY, zoomScale);
  target.dirty();
}
function updateController(seriesModel, api2, pointerCheckerEl, controller, controllerHost, clipRect) {
  const tmpRect3 = new BoundingRect_default(0, 0, 0, 0);
  controller.enable(seriesModel.get("roam"), {
    api: api2,
    zInfo: {component: seriesModel},
    triggerInfo: {
      roamTrigger: seriesModel.get("roamTrigger"),
      isInSelf: function(e2, x, y) {
        tmpRect3.copy(pointerCheckerEl.getBoundingRect());
        tmpRect3.applyTransform(pointerCheckerEl.getComputedTransform());
        return tmpRect3.contain(x, y);
      },
      isInClip: function(e2, x, y) {
        return !clipRect || clipRect.contain(x, y);
      }
    }
  });
  controllerHost.zoomLimit = seriesModel.get("scaleLimit");
  const coordinate = seriesModel.coordinateSystem;
  controllerHost.zoom = coordinate ? coordinate.getZoom() : 1;
  const type = seriesModel.subType + "Roam";
  controller.off("pan").off("zoom").on("pan", (e2) => {
    updateViewOnPan(controllerHost, e2.dx, e2.dy);
    api2.dispatchAction({
      seriesId: seriesModel.id,
      type,
      dx: e2.dx,
      dy: e2.dy
    });
  }).on("zoom", (e2) => {
    updateViewOnZoom(controllerHost, e2.scale, e2.originX, e2.originY);
    api2.dispatchAction({
      seriesId: seriesModel.id,
      type,
      zoom: e2.scale,
      originX: e2.originX,
      originY: e2.originY
    });
    api2.updateLabelLayout();
  });
}
function getCenterCoord(view, point) {
  return view.pointToProjected ? view.pointToProjected(point) : view.pointToData(point);
}
function updateCenterAndZoomInAction(view, payload, zoomLimit) {
  const previousZoom = view.getZoom();
  const center3 = view.getCenter();
  let deltaZoom = payload.zoom;
  const point = view.projectedToPoint ? view.projectedToPoint(center3) : view.dataToPoint(center3);
  if (payload.dx != null && payload.dy != null) {
    point[0] -= payload.dx;
    point[1] -= payload.dy;
    view.setCenter(getCenterCoord(view, point));
  }
  if (deltaZoom != null) {
    deltaZoom = clampByZoomLimit(previousZoom * deltaZoom, zoomLimit) / previousZoom;
    zoomTransformableByOrigin(view, payload.originX, payload.originY, deltaZoom);
    view.updateTransform();
    view.setCenter(getCenterCoord(view, point));
    view.setZoom(deltaZoom * previousZoom);
  }
  return {
    center: view.getCenter(),
    zoom: view.getZoom()
  };
}
function zoomTransformableByOrigin(target, originX, originY, deltaZoom) {
  target.x -= (originX - target.x) * (deltaZoom - 1);
  target.y -= (originY - target.y) * (deltaZoom - 1);
  target.scaleX *= deltaZoom;
  target.scaleY *= deltaZoom;
}
function clampByZoomLimit(zoom, zoomLimit) {
  if (zoomLimit) {
    const zoomMin = zoomLimit.min || 0;
    const zoomMax = zoomLimit.max || Infinity;
    zoom = Math.max(Math.min(zoomMax, zoom), zoomMin);
  }
  return zoom;
}

// ../zrender/src/tool/parseXML.ts
function parseXML(svg) {
  if (isString(svg)) {
    const parser = new DOMParser();
    svg = parser.parseFromString(svg, "text/xml");
  }
  let svgNode = svg;
  if (svgNode.nodeType === 9) {
    svgNode = svgNode.firstChild;
  }
  while (svgNode.nodeName.toLowerCase() !== "svg" || svgNode.nodeType !== 1) {
    svgNode = svgNode.nextSibling;
  }
  return svgNode;
}

// ../zrender/src/tool/parseSVG.ts
var nodeParsers;
var INHERITABLE_STYLE_ATTRIBUTES_MAP = {
  fill: "fill",
  stroke: "stroke",
  "stroke-width": "lineWidth",
  opacity: "opacity",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-miterlimit": "miterLimit",
  "font-family": "fontFamily",
  "font-size": "fontSize",
  "font-style": "fontStyle",
  "font-weight": "fontWeight",
  "text-anchor": "textAlign",
  visibility: "visibility",
  display: "display"
};
var INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS = keys(INHERITABLE_STYLE_ATTRIBUTES_MAP);
var SELF_STYLE_ATTRIBUTES_MAP = {
  "alignment-baseline": "textBaseline",
  "stop-color": "stopColor"
};
var SELF_STYLE_ATTRIBUTES_MAP_KEYS = keys(SELF_STYLE_ATTRIBUTES_MAP);
var SVGParser = class {
  constructor() {
    this._defs = {};
    this._root = null;
  }
  parse(xml, opt) {
    opt = opt || {};
    const svg = parseXML(xml);
    if (true) {
      if (!svg) {
        throw new Error("Illegal svg");
      }
    }
    this._defsUsePending = [];
    let root = new Group_default();
    this._root = root;
    const named = [];
    const viewBox = svg.getAttribute("viewBox") || "";
    let width = parseFloat(svg.getAttribute("width") || opt.width);
    let height = parseFloat(svg.getAttribute("height") || opt.height);
    isNaN(width) && (width = null);
    isNaN(height) && (height = null);
    parseAttributes(svg, root, null, true, false);
    let child = svg.firstChild;
    while (child) {
      this._parseNode(child, root, named, null, false, false);
      child = child.nextSibling;
    }
    applyDefs(this._defs, this._defsUsePending);
    this._defsUsePending = [];
    let viewBoxRect;
    let viewBoxTransform;
    if (viewBox) {
      const viewBoxArr = splitNumberSequence(viewBox);
      if (viewBoxArr.length >= 4) {
        viewBoxRect = {
          x: parseFloat(viewBoxArr[0] || 0),
          y: parseFloat(viewBoxArr[1] || 0),
          width: parseFloat(viewBoxArr[2]),
          height: parseFloat(viewBoxArr[3])
        };
      }
    }
    if (viewBoxRect && width != null && height != null) {
      viewBoxTransform = makeViewBoxTransform(viewBoxRect, {x: 0, y: 0, width, height});
      if (!opt.ignoreViewBox) {
        const elRoot = root;
        root = new Group_default();
        root.add(elRoot);
        elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;
        elRoot.x = viewBoxTransform.x;
        elRoot.y = viewBoxTransform.y;
      }
    }
    if (!opt.ignoreRootClip && width != null && height != null) {
      root.setClipPath(new Rect_default({
        shape: {x: 0, y: 0, width, height}
      }));
    }
    return {
      root,
      width,
      height,
      viewBoxRect,
      viewBoxTransform,
      named
    };
  }
  _parseNode(xmlNode, parentGroup, named, namedFrom, isInDefs, isInText) {
    const nodeName = xmlNode.nodeName.toLowerCase();
    let el;
    let namedFromForSub = namedFrom;
    if (nodeName === "defs") {
      isInDefs = true;
    }
    if (nodeName === "text") {
      isInText = true;
    }
    if (nodeName === "defs" || nodeName === "switch") {
      el = parentGroup;
    } else {
      if (!isInDefs) {
        const parser2 = nodeParsers[nodeName];
        if (parser2 && hasOwn(nodeParsers, nodeName)) {
          el = parser2.call(this, xmlNode, parentGroup);
          const nameAttr = xmlNode.getAttribute("name");
          if (nameAttr) {
            const newNamed = {
              name: nameAttr,
              namedFrom: null,
              svgNodeTagLower: nodeName,
              el
            };
            named.push(newNamed);
            if (nodeName === "g") {
              namedFromForSub = newNamed;
            }
          } else if (namedFrom) {
            named.push({
              name: namedFrom.name,
              namedFrom,
              svgNodeTagLower: nodeName,
              el
            });
          }
          parentGroup.add(el);
        }
      }
      const parser = paintServerParsers[nodeName];
      if (parser && hasOwn(paintServerParsers, nodeName)) {
        const def = parser.call(this, xmlNode);
        const id = xmlNode.getAttribute("id");
        if (id) {
          this._defs[id] = def;
        }
      }
    }
    if (el && el.isGroup) {
      let child = xmlNode.firstChild;
      while (child) {
        if (child.nodeType === 1) {
          this._parseNode(child, el, named, namedFromForSub, isInDefs, isInText);
        } else if (child.nodeType === 3 && isInText) {
          this._parseText(child, el);
        }
        child = child.nextSibling;
      }
    }
  }
  _parseText(xmlNode, parentGroup) {
    const text = new TSpan_default({
      style: {
        text: xmlNode.textContent
      },
      silent: true,
      x: this._textX || 0,
      y: this._textY || 0
    });
    inheritStyle(parentGroup, text);
    parseAttributes(xmlNode, text, this._defsUsePending, false, false);
    applyTextAlignment(text, parentGroup);
    const textStyle = text.style;
    const fontSize = textStyle.fontSize;
    if (fontSize && fontSize < 9) {
      textStyle.fontSize = 9;
      text.scaleX *= fontSize / 9;
      text.scaleY *= fontSize / 9;
    }
    const font = (textStyle.fontSize || textStyle.fontFamily) && [
      textStyle.fontStyle,
      textStyle.fontWeight,
      (textStyle.fontSize || 12) + "px",
      textStyle.fontFamily || "sans-serif"
    ].join(" ");
    textStyle.font = font;
    const rect = text.getBoundingRect();
    this._textX += rect.width;
    parentGroup.add(text);
    return text;
  }
};
SVGParser.internalField = function() {
  nodeParsers = {
    g: function(xmlNode, parentGroup) {
      const g = new Group_default();
      inheritStyle(parentGroup, g);
      parseAttributes(xmlNode, g, this._defsUsePending, false, false);
      return g;
    },
    rect: function(xmlNode, parentGroup) {
      const rect = new Rect_default();
      inheritStyle(parentGroup, rect);
      parseAttributes(xmlNode, rect, this._defsUsePending, false, false);
      rect.setShape({
        x: parseFloat(xmlNode.getAttribute("x") || "0"),
        y: parseFloat(xmlNode.getAttribute("y") || "0"),
        width: parseFloat(xmlNode.getAttribute("width") || "0"),
        height: parseFloat(xmlNode.getAttribute("height") || "0")
      });
      rect.silent = true;
      return rect;
    },
    circle: function(xmlNode, parentGroup) {
      const circle = new Circle_default();
      inheritStyle(parentGroup, circle);
      parseAttributes(xmlNode, circle, this._defsUsePending, false, false);
      circle.setShape({
        cx: parseFloat(xmlNode.getAttribute("cx") || "0"),
        cy: parseFloat(xmlNode.getAttribute("cy") || "0"),
        r: parseFloat(xmlNode.getAttribute("r") || "0")
      });
      circle.silent = true;
      return circle;
    },
    line: function(xmlNode, parentGroup) {
      const line2 = new Line_default();
      inheritStyle(parentGroup, line2);
      parseAttributes(xmlNode, line2, this._defsUsePending, false, false);
      line2.setShape({
        x1: parseFloat(xmlNode.getAttribute("x1") || "0"),
        y1: parseFloat(xmlNode.getAttribute("y1") || "0"),
        x2: parseFloat(xmlNode.getAttribute("x2") || "0"),
        y2: parseFloat(xmlNode.getAttribute("y2") || "0")
      });
      line2.silent = true;
      return line2;
    },
    ellipse: function(xmlNode, parentGroup) {
      const ellipse = new Ellipse_default();
      inheritStyle(parentGroup, ellipse);
      parseAttributes(xmlNode, ellipse, this._defsUsePending, false, false);
      ellipse.setShape({
        cx: parseFloat(xmlNode.getAttribute("cx") || "0"),
        cy: parseFloat(xmlNode.getAttribute("cy") || "0"),
        rx: parseFloat(xmlNode.getAttribute("rx") || "0"),
        ry: parseFloat(xmlNode.getAttribute("ry") || "0")
      });
      ellipse.silent = true;
      return ellipse;
    },
    polygon: function(xmlNode, parentGroup) {
      const pointsStr = xmlNode.getAttribute("points");
      let pointsArr;
      if (pointsStr) {
        pointsArr = parsePoints(pointsStr);
      }
      const polygon = new Polygon_default({
        shape: {
          points: pointsArr || []
        },
        silent: true
      });
      inheritStyle(parentGroup, polygon);
      parseAttributes(xmlNode, polygon, this._defsUsePending, false, false);
      return polygon;
    },
    polyline: function(xmlNode, parentGroup) {
      const pointsStr = xmlNode.getAttribute("points");
      let pointsArr;
      if (pointsStr) {
        pointsArr = parsePoints(pointsStr);
      }
      const polyline = new Polyline_default({
        shape: {
          points: pointsArr || []
        },
        silent: true
      });
      inheritStyle(parentGroup, polyline);
      parseAttributes(xmlNode, polyline, this._defsUsePending, false, false);
      return polyline;
    },
    image: function(xmlNode, parentGroup) {
      const img = new Image_default();
      inheritStyle(parentGroup, img);
      parseAttributes(xmlNode, img, this._defsUsePending, false, false);
      img.setStyle({
        image: xmlNode.getAttribute("xlink:href") || xmlNode.getAttribute("href"),
        x: +xmlNode.getAttribute("x"),
        y: +xmlNode.getAttribute("y"),
        width: +xmlNode.getAttribute("width"),
        height: +xmlNode.getAttribute("height")
      });
      img.silent = true;
      return img;
    },
    text: function(xmlNode, parentGroup) {
      const x = xmlNode.getAttribute("x") || "0";
      const y = xmlNode.getAttribute("y") || "0";
      const dx = xmlNode.getAttribute("dx") || "0";
      const dy = xmlNode.getAttribute("dy") || "0";
      this._textX = parseFloat(x) + parseFloat(dx);
      this._textY = parseFloat(y) + parseFloat(dy);
      const g = new Group_default();
      inheritStyle(parentGroup, g);
      parseAttributes(xmlNode, g, this._defsUsePending, false, true);
      return g;
    },
    tspan: function(xmlNode, parentGroup) {
      const x = xmlNode.getAttribute("x");
      const y = xmlNode.getAttribute("y");
      if (x != null) {
        this._textX = parseFloat(x);
      }
      if (y != null) {
        this._textY = parseFloat(y);
      }
      const dx = xmlNode.getAttribute("dx") || "0";
      const dy = xmlNode.getAttribute("dy") || "0";
      const g = new Group_default();
      inheritStyle(parentGroup, g);
      parseAttributes(xmlNode, g, this._defsUsePending, false, true);
      this._textX += parseFloat(dx);
      this._textY += parseFloat(dy);
      return g;
    },
    path: function(xmlNode, parentGroup) {
      const d = xmlNode.getAttribute("d") || "";
      const path = createFromString(d);
      inheritStyle(parentGroup, path);
      parseAttributes(xmlNode, path, this._defsUsePending, false, false);
      path.silent = true;
      return path;
    }
  };
}();
var paintServerParsers = {
  lineargradient: function(xmlNode) {
    const x1 = parseInt(xmlNode.getAttribute("x1") || "0", 10);
    const y1 = parseInt(xmlNode.getAttribute("y1") || "0", 10);
    const x2 = parseInt(xmlNode.getAttribute("x2") || "10", 10);
    const y2 = parseInt(xmlNode.getAttribute("y2") || "0", 10);
    const gradient = new LinearGradient_default(x1, y1, x2, y2);
    parsePaintServerUnit(xmlNode, gradient);
    parseGradientColorStops(xmlNode, gradient);
    return gradient;
  },
  radialgradient: function(xmlNode) {
    const cx = parseInt(xmlNode.getAttribute("cx") || "0", 10);
    const cy = parseInt(xmlNode.getAttribute("cy") || "0", 10);
    const r = parseInt(xmlNode.getAttribute("r") || "0", 10);
    const gradient = new RadialGradient_default(cx, cy, r);
    parsePaintServerUnit(xmlNode, gradient);
    parseGradientColorStops(xmlNode, gradient);
    return gradient;
  }
};
function parsePaintServerUnit(xmlNode, gradient) {
  const gradientUnits = xmlNode.getAttribute("gradientUnits");
  if (gradientUnits === "userSpaceOnUse") {
    gradient.global = true;
  }
}
function parseGradientColorStops(xmlNode, gradient) {
  let stop2 = xmlNode.firstChild;
  while (stop2) {
    if (stop2.nodeType === 1 && stop2.nodeName.toLocaleLowerCase() === "stop") {
      const offsetStr = stop2.getAttribute("offset");
      let offset;
      if (offsetStr && offsetStr.indexOf("%") > 0) {
        offset = parseInt(offsetStr, 10) / 100;
      } else if (offsetStr) {
        offset = parseFloat(offsetStr);
      } else {
        offset = 0;
      }
      const styleVals = {};
      parseInlineStyle(stop2, styleVals, styleVals);
      let stopColor = styleVals.stopColor || stop2.getAttribute("stop-color") || "#000000";
      const stopOpacity = styleVals.stopOpacity || stop2.getAttribute("stop-opacity");
      if (stopOpacity) {
        const rgba = parse(stopColor);
        const stopColorOpacity = rgba && rgba[3];
        if (stopColorOpacity) {
          rgba[3] *= parseCssFloat(stopOpacity);
          stopColor = stringify(rgba, "rgba");
        }
      }
      gradient.colorStops.push({
        offset,
        color: stopColor
      });
    }
    stop2 = stop2.nextSibling;
  }
}
function inheritStyle(parent, child) {
  if (parent && parent.__inheritedStyle) {
    if (!child.__inheritedStyle) {
      child.__inheritedStyle = {};
    }
    defaults(child.__inheritedStyle, parent.__inheritedStyle);
  }
}
function parsePoints(pointsString) {
  const list = splitNumberSequence(pointsString);
  const points4 = [];
  for (let i = 0; i < list.length; i += 2) {
    const x = parseFloat(list[i]);
    const y = parseFloat(list[i + 1]);
    points4.push([x, y]);
  }
  return points4;
}
function parseAttributes(xmlNode, el, defsUsePending, onlyInlineStyle, isTextGroup) {
  const disp = el;
  const inheritedStyle = disp.__inheritedStyle = disp.__inheritedStyle || {};
  const selfStyle = {};
  if (xmlNode.nodeType === 1) {
    parseTransformAttribute(xmlNode, el);
    parseInlineStyle(xmlNode, inheritedStyle, selfStyle);
    if (!onlyInlineStyle) {
      parseAttributeStyle(xmlNode, inheritedStyle, selfStyle);
    }
  }
  disp.style = disp.style || {};
  if (inheritedStyle.fill != null) {
    disp.style.fill = getFillStrokeStyle(disp, "fill", inheritedStyle.fill, defsUsePending);
  }
  if (inheritedStyle.stroke != null) {
    disp.style.stroke = getFillStrokeStyle(disp, "stroke", inheritedStyle.stroke, defsUsePending);
  }
  each([
    "lineWidth",
    "opacity",
    "fillOpacity",
    "strokeOpacity",
    "miterLimit",
    "fontSize"
  ], function(propName) {
    if (inheritedStyle[propName] != null) {
      disp.style[propName] = parseFloat(inheritedStyle[propName]);
    }
  });
  each([
    "lineDashOffset",
    "lineCap",
    "lineJoin",
    "fontWeight",
    "fontFamily",
    "fontStyle",
    "textAlign"
  ], function(propName) {
    if (inheritedStyle[propName] != null) {
      disp.style[propName] = inheritedStyle[propName];
    }
  });
  if (isTextGroup) {
    disp.__selfStyle = selfStyle;
  }
  if (inheritedStyle.lineDash) {
    disp.style.lineDash = map(splitNumberSequence(inheritedStyle.lineDash), function(str) {
      return parseFloat(str);
    });
  }
  if (inheritedStyle.visibility === "hidden" || inheritedStyle.visibility === "collapse") {
    disp.invisible = true;
  }
  if (inheritedStyle.display === "none") {
    disp.ignore = true;
  }
}
function applyTextAlignment(text, parentGroup) {
  const parentSelfStyle = parentGroup.__selfStyle;
  if (parentSelfStyle) {
    const textBaseline = parentSelfStyle.textBaseline;
    let zrTextBaseline = textBaseline;
    if (!textBaseline || textBaseline === "auto") {
      zrTextBaseline = "alphabetic";
    } else if (textBaseline === "baseline") {
      zrTextBaseline = "alphabetic";
    } else if (textBaseline === "before-edge" || textBaseline === "text-before-edge") {
      zrTextBaseline = "top";
    } else if (textBaseline === "after-edge" || textBaseline === "text-after-edge") {
      zrTextBaseline = "bottom";
    } else if (textBaseline === "central" || textBaseline === "mathematical") {
      zrTextBaseline = "middle";
    }
    text.style.textBaseline = zrTextBaseline;
  }
  const parentInheritedStyle = parentGroup.__inheritedStyle;
  if (parentInheritedStyle) {
    const textAlign = parentInheritedStyle.textAlign;
    let zrTextAlign = textAlign;
    if (textAlign) {
      if (textAlign === "middle") {
        zrTextAlign = "center";
      }
      text.style.textAlign = zrTextAlign;
    }
  }
}
var urlRegex = /^url\(\s*#(.*?)\)/;
function getFillStrokeStyle(el, method, str, defsUsePending) {
  const urlMatch = str && str.match(urlRegex);
  if (urlMatch) {
    const url = trim(urlMatch[1]);
    defsUsePending.push([el, method, url]);
    return;
  }
  if (str === "none") {
    str = null;
  }
  return str;
}
function applyDefs(defs, defsUsePending) {
  for (let i = 0; i < defsUsePending.length; i++) {
    const item = defsUsePending[i];
    item[0].style[item[1]] = defs[item[2]];
  }
}
var numberReg2 = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function splitNumberSequence(rawStr) {
  return rawStr.match(numberReg2) || [];
}
var transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g;
var DEGREE_TO_ANGLE = Math.PI / 180;
function parseTransformAttribute(xmlNode, node) {
  let transform2 = xmlNode.getAttribute("transform");
  if (transform2) {
    transform2 = transform2.replace(/,/g, " ");
    const transformOps = [];
    let mt = null;
    transform2.replace(transformRegex, function(str, type, value) {
      transformOps.push(type, value);
      return "";
    });
    for (let i = transformOps.length - 1; i > 0; i -= 2) {
      const value = transformOps[i];
      const type = transformOps[i - 1];
      const valueArr = splitNumberSequence(value);
      mt = mt || create2();
      switch (type) {
        case "translate":
          translate(mt, mt, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || "0")]);
          break;
        case "scale":
          scale2(mt, mt, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || valueArr[0])]);
          break;
        case "rotate":
          rotate(mt, mt, -parseFloat(valueArr[0]) * DEGREE_TO_ANGLE, [
            parseFloat(valueArr[1] || "0"),
            parseFloat(valueArr[2] || "0")
          ]);
          break;
        case "skewX":
          const sx = Math.tan(parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);
          mul2(mt, [1, 0, sx, 1, 0, 0], mt);
          break;
        case "skewY":
          const sy = Math.tan(parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);
          mul2(mt, [1, sy, 0, 1, 0, 0], mt);
          break;
        case "matrix":
          mt[0] = parseFloat(valueArr[0]);
          mt[1] = parseFloat(valueArr[1]);
          mt[2] = parseFloat(valueArr[2]);
          mt[3] = parseFloat(valueArr[3]);
          mt[4] = parseFloat(valueArr[4]);
          mt[5] = parseFloat(valueArr[5]);
          break;
      }
    }
    node.setLocalTransform(mt);
  }
}
var styleRegex = /([^\s:;]+)\s*:\s*([^:;]+)/g;
function parseInlineStyle(xmlNode, inheritableStyleResult, selfStyleResult) {
  const style = xmlNode.getAttribute("style");
  if (!style) {
    return;
  }
  styleRegex.lastIndex = 0;
  let styleRegResult;
  while ((styleRegResult = styleRegex.exec(style)) != null) {
    const svgStlAttr = styleRegResult[1];
    const zrInheritableStlAttr = hasOwn(INHERITABLE_STYLE_ATTRIBUTES_MAP, svgStlAttr) ? INHERITABLE_STYLE_ATTRIBUTES_MAP[svgStlAttr] : null;
    if (zrInheritableStlAttr) {
      inheritableStyleResult[zrInheritableStlAttr] = styleRegResult[2];
    }
    const zrSelfStlAttr = hasOwn(SELF_STYLE_ATTRIBUTES_MAP, svgStlAttr) ? SELF_STYLE_ATTRIBUTES_MAP[svgStlAttr] : null;
    if (zrSelfStlAttr) {
      selfStyleResult[zrSelfStlAttr] = styleRegResult[2];
    }
  }
}
function parseAttributeStyle(xmlNode, inheritableStyleResult, selfStyleResult) {
  for (let i = 0; i < INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS.length; i++) {
    const svgAttrName = INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS[i];
    const attrValue = xmlNode.getAttribute(svgAttrName);
    if (attrValue != null) {
      inheritableStyleResult[INHERITABLE_STYLE_ATTRIBUTES_MAP[svgAttrName]] = attrValue;
    }
  }
  for (let i = 0; i < SELF_STYLE_ATTRIBUTES_MAP_KEYS.length; i++) {
    const svgAttrName = SELF_STYLE_ATTRIBUTES_MAP_KEYS[i];
    const attrValue = xmlNode.getAttribute(svgAttrName);
    if (attrValue != null) {
      selfStyleResult[SELF_STYLE_ATTRIBUTES_MAP[svgAttrName]] = attrValue;
    }
  }
}
function makeViewBoxTransform(viewBoxRect, boundingRect) {
  const scaleX = boundingRect.width / viewBoxRect.width;
  const scaleY = boundingRect.height / viewBoxRect.height;
  const scale4 = Math.min(scaleX, scaleY);
  return {
    scale: scale4,
    x: -(viewBoxRect.x + viewBoxRect.width / 2) * scale4 + (boundingRect.x + boundingRect.width / 2),
    y: -(viewBoxRect.y + viewBoxRect.height / 2) * scale4 + (boundingRect.y + boundingRect.height / 2)
  };
}
function parseSVG(xml, opt) {
  const parser = new SVGParser();
  return parser.parse(xml, opt);
}

// src/coord/geo/GeoSVGResource.ts
var REGION_AVAILABLE_SVG_TAG_MAP = createHashMap([
  "rect",
  "circle",
  "line",
  "ellipse",
  "polygon",
  "polyline",
  "path",
  "text",
  "tspan",
  "g"
]);
var GeoSVGResource = class {
  constructor(mapName, svg) {
    this.type = "geoSVG";
    this._usedGraphicMap = createHashMap();
    this._freedGraphics = [];
    this._mapName = mapName;
    this._parsedXML = parseXML(svg);
  }
  load() {
    let firstGraphic = this._firstGraphic;
    if (!firstGraphic) {
      firstGraphic = this._firstGraphic = this._buildGraphic(this._parsedXML);
      this._freedGraphics.push(firstGraphic);
      this._boundingRect = this._firstGraphic.boundingRect.clone();
      const {regions, regionsMap} = createRegions(firstGraphic.named);
      this._regions = regions;
      this._regionsMap = regionsMap;
    }
    return {
      boundingRect: this._boundingRect,
      regions: this._regions,
      regionsMap: this._regionsMap
    };
  }
  _buildGraphic(svgXML) {
    let result;
    let rootFromParse;
    try {
      result = svgXML && parseSVG(svgXML, {
        ignoreViewBox: true,
        ignoreRootClip: true
      }) || {};
      rootFromParse = result.root;
      assert(rootFromParse != null);
    } catch (e2) {
      throw new Error("Invalid svg format\n" + e2.message);
    }
    const root = new Group_default();
    root.add(rootFromParse);
    root.isGeoSVGGraphicRoot = true;
    const svgWidth = result.width;
    const svgHeight = result.height;
    const viewBoxRect = result.viewBoxRect;
    let boundingRect = this._boundingRect;
    if (!boundingRect) {
      let bRectX;
      let bRectY;
      let bRectWidth;
      let bRectHeight;
      if (svgWidth != null) {
        bRectX = 0;
        bRectWidth = svgWidth;
      } else if (viewBoxRect) {
        bRectX = viewBoxRect.x;
        bRectWidth = viewBoxRect.width;
      }
      if (svgHeight != null) {
        bRectY = 0;
        bRectHeight = svgHeight;
      } else if (viewBoxRect) {
        bRectY = viewBoxRect.y;
        bRectHeight = viewBoxRect.height;
      }
      if (bRectX == null || bRectY == null) {
        const calculatedBoundingRect = rootFromParse.getBoundingRect();
        if (bRectX == null) {
          bRectX = calculatedBoundingRect.x;
          bRectWidth = calculatedBoundingRect.width;
        }
        if (bRectY == null) {
          bRectY = calculatedBoundingRect.y;
          bRectHeight = calculatedBoundingRect.height;
        }
      }
      boundingRect = this._boundingRect = new BoundingRect_default(bRectX, bRectY, bRectWidth, bRectHeight);
    }
    if (viewBoxRect) {
      const viewBoxTransform = makeViewBoxTransform(viewBoxRect, boundingRect);
      rootFromParse.scaleX = rootFromParse.scaleY = viewBoxTransform.scale;
      rootFromParse.x = viewBoxTransform.x;
      rootFromParse.y = viewBoxTransform.y;
    }
    root.setClipPath(new Rect_default({
      shape: boundingRect.plain()
    }));
    const named = [];
    each(result.named, (namedItem) => {
      if (REGION_AVAILABLE_SVG_TAG_MAP.get(namedItem.svgNodeTagLower) != null) {
        named.push(namedItem);
        setSilent(namedItem.el);
      }
    });
    return {root, boundingRect, named};
  }
  useGraphic(hostKey) {
    const usedRootMap = this._usedGraphicMap;
    let svgGraphic = usedRootMap.get(hostKey);
    if (svgGraphic) {
      return svgGraphic;
    }
    svgGraphic = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML);
    usedRootMap.set(hostKey, svgGraphic);
    return svgGraphic;
  }
  freeGraphic(hostKey) {
    const usedRootMap = this._usedGraphicMap;
    const svgGraphic = usedRootMap.get(hostKey);
    if (svgGraphic) {
      usedRootMap.removeKey(hostKey);
      this._freedGraphics.push(svgGraphic);
    }
  }
};
function setSilent(el) {
  el.silent = false;
  if (el.isGroup) {
    el.traverse((child) => {
      child.silent = false;
    });
  }
}
function createRegions(named) {
  const regions = [];
  const regionsMap = createHashMap();
  each(named, (namedItem) => {
    if (namedItem.namedFrom != null) {
      return;
    }
    const region = new GeoSVGRegion(namedItem.name, namedItem.el);
    regions.push(region);
    regionsMap.set(namedItem.name, region);
  });
  return {regions, regionsMap};
}

// src/coord/geo/fix/nanhai.ts
var geoCoord = [126, 25];
var nanhaiName = "\u5357\u6D77\u8BF8\u5C9B";
var points2 = [
  [
    [0, 3.5],
    [7, 11.2],
    [15, 11.9],
    [30, 7],
    [42, 0.7],
    [52, 0.7],
    [56, 7.7],
    [59, 0.7],
    [64, 0.7],
    [64, 0],
    [5, 0],
    [0, 3.5]
  ],
  [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]],
  [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]],
  [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]],
  [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]],
  [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]],
  [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]],
  [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]],
  [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]],
  [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]],
  [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]],
  [
    [0, 3.5],
    [0, 93.1],
    [64, 93.1],
    [64, 0],
    [63, 0],
    [63, 92.4],
    [1, 92.4],
    [1, 3.5],
    [0, 3.5]
  ]
];
for (let i = 0; i < points2.length; i++) {
  for (let k = 0; k < points2[i].length; k++) {
    points2[i][k][0] /= 10.5;
    points2[i][k][1] /= -10.5 / 0.75;
    points2[i][k][0] += geoCoord[0];
    points2[i][k][1] += geoCoord[1];
  }
}
function fixNanhai(mapType, regions) {
  if (mapType === "china") {
    for (let i = 0; i < regions.length; i++) {
      if (regions[i].name === nanhaiName) {
        return;
      }
    }
    regions.push(new GeoJSONRegion(nanhaiName, map(points2, function(exterior) {
      return {
        type: "polygon",
        exterior
      };
    }), geoCoord));
  }
}

// src/coord/geo/fix/textCoord.ts
var coordsOffsetMap = {
  \u5357\u6D77\u8BF8\u5C9B: [32, 80],
  \u5E7F\u4E1C: [0, -10],
  \u9999\u6E2F: [10, 5],
  \u6FB3\u95E8: [-10, 10],
  \u5929\u6D25: [5, 5]
};
function fixTextCoords(mapType, region) {
  if (mapType === "china") {
    const coordFix = coordsOffsetMap[region.name];
    if (coordFix) {
      const cp = region.getCenter();
      cp[0] += coordFix[0] / 10.5;
      cp[1] += -coordFix[1] / (10.5 / 0.75);
      region.setCenter(cp);
    }
  }
}

// src/coord/geo/fix/diaoyuIsland.ts
var points3 = [
  [
    [123.45165252685547, 25.73527164402261],
    [123.49731445312499, 25.73527164402261],
    [123.49731445312499, 25.750734064600884],
    [123.45165252685547, 25.750734064600884],
    [123.45165252685547, 25.73527164402261]
  ]
];
function fixDiaoyuIsland(mapType, region) {
  if (mapType === "china" && region.name === "\u53F0\u6E7E") {
    region.geometries.push({
      type: "polygon",
      exterior: points3[0]
    });
  }
}

// src/coord/geo/GeoJSONResource.ts
var DEFAULT_NAME_PROPERTY = "name";
var GeoJSONResource = class {
  constructor(mapName, geoJSON, specialAreas) {
    this.type = "geoJSON";
    this._parsedMap = createHashMap();
    this._mapName = mapName;
    this._specialAreas = specialAreas;
    this._geoJSON = parseInput(geoJSON);
  }
  load(nameMap, nameProperty) {
    nameProperty = nameProperty || DEFAULT_NAME_PROPERTY;
    let parsed = this._parsedMap.get(nameProperty);
    if (!parsed) {
      const rawRegions = this._parseToRegions(nameProperty);
      parsed = this._parsedMap.set(nameProperty, {
        regions: rawRegions,
        boundingRect: calculateBoundingRect(rawRegions)
      });
    }
    const regionsMap = createHashMap();
    const finalRegions = [];
    each(parsed.regions, function(region) {
      let regionName = region.name;
      if (nameMap && hasOwn(nameMap, regionName)) {
        region = region.cloneShallow(regionName = nameMap[regionName]);
      }
      finalRegions.push(region);
      regionsMap.set(regionName, region);
    });
    return {
      regions: finalRegions,
      boundingRect: parsed.boundingRect || new BoundingRect_default(0, 0, 0, 0),
      regionsMap
    };
  }
  _parseToRegions(nameProperty) {
    const mapName = this._mapName;
    const geoJSON = this._geoJSON;
    let rawRegions;
    try {
      rawRegions = geoJSON ? parseGeoJSON(geoJSON, nameProperty) : [];
    } catch (e2) {
      throw new Error("Invalid geoJson format\n" + e2.message);
    }
    fixNanhai(mapName, rawRegions);
    each(rawRegions, function(region) {
      const regionName = region.name;
      fixTextCoords(mapName, region);
      fixDiaoyuIsland(mapName, region);
      const specialArea = this._specialAreas && this._specialAreas[regionName];
      if (specialArea) {
        region.transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);
      }
    }, this);
    return rawRegions;
  }
  getMapForUser() {
    return {
      geoJson: this._geoJSON,
      geoJSON: this._geoJSON,
      specialAreas: this._specialAreas
    };
  }
};
function calculateBoundingRect(regions) {
  let rect;
  for (let i = 0; i < regions.length; i++) {
    const regionRect = regions[i].getBoundingRect();
    rect = rect || regionRect.clone();
    rect.union(regionRect);
  }
  return rect;
}
function parseInput(source) {
  return !isString(source) ? source : typeof JSON !== "undefined" && JSON.parse ? JSON.parse(source) : new Function("return (" + source + ");")();
}

// src/coord/geo/geoSourceManager.ts
var storage = createHashMap();
var geoSourceManager_default = {
  registerMap: function(mapName, rawDef, rawSpecialAreas) {
    if (rawDef.svg) {
      const resource = new GeoSVGResource(mapName, rawDef.svg);
      storage.set(mapName, resource);
    } else {
      let geoJSON = rawDef.geoJson || rawDef.geoJSON;
      if (geoJSON && !rawDef.features) {
        rawSpecialAreas = rawDef.specialAreas;
      } else {
        geoJSON = rawDef;
      }
      const resource = new GeoJSONResource(mapName, geoJSON, rawSpecialAreas);
      storage.set(mapName, resource);
    }
  },
  getGeoResource(mapName) {
    return storage.get(mapName);
  },
  getMapForUser: function(mapName) {
    const resource = storage.get(mapName);
    return resource && resource.type === "geoJSON" && resource.getMapForUser();
  },
  load: function(mapName, nameMap, nameProperty) {
    const resource = storage.get(mapName);
    if (!resource) {
      if (true) {
        console.error("Map " + mapName + " not exists. The GeoJSON of the map must be provided.");
      }
      return;
    }
    return resource.load(nameMap, nameProperty);
  }
};

// src/component/helper/MapDraw.ts
var OPTION_STYLE_ENABLED_TAGS = [
  "rect",
  "circle",
  "line",
  "ellipse",
  "polygon",
  "polyline",
  "path"
];
var OPTION_STYLE_ENABLED_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS);
var STATE_TRIGGER_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(["g"]));
var LABEL_HOST_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(["g"]));
var mapLabelRaw = makeInner();
function getFixedItemStyle(model) {
  const itemStyle = model.getItemStyle();
  const areaColor = model.get("areaColor");
  if (areaColor != null) {
    itemStyle.fill = areaColor;
  }
  return itemStyle;
}
function fixLineStyle(styleHost) {
  const style = styleHost.style;
  if (style) {
    style.stroke = style.stroke || style.fill;
    style.fill = null;
  }
}
var MapDraw = class {
  constructor(api2) {
    const group = this.group = new Group_default();
    const transformGroup = this._transformGroup = new Group_default();
    group.add(transformGroup);
    this.uid = getUID("ec_map_draw");
    this._controller = new RoamController_default(api2.getZr());
    this._controllerHost = {target: transformGroup};
    transformGroup.add(this._regionsGroup = new Group_default());
    transformGroup.add(this._svgGroup = new Group_default());
  }
  draw(mapOrGeoModel, ecModel, api2, fromView, payload) {
    const isGeo = mapOrGeoModel.mainType === "geo";
    let data = mapOrGeoModel.getData && mapOrGeoModel.getData();
    isGeo && ecModel.eachComponent({mainType: "series", subType: "map"}, function(mapSeries) {
      if (!data && mapSeries.getHostGeoModel() === mapOrGeoModel) {
        data = mapSeries.getData();
      }
    });
    const geo = mapOrGeoModel.coordinateSystem;
    const regionsGroup = this._regionsGroup;
    const transformGroup = this._transformGroup;
    const transformInfo = geo.getTransformInfo();
    const transformInfoRaw = transformInfo.raw;
    const transformInfoRoam = transformInfo.roam;
    const isFirstDraw = !regionsGroup.childAt(0) || payload;
    const clip2 = mapOrGeoModel.getShallow("clip", true);
    let clipRect;
    if (clip2) {
      clipRect = geo.getViewRect().clone();
      this.group.setClipPath(new Rect_default({shape: clipRect.clone()}));
    } else {
      this.group.removeClipPath();
    }
    if (isFirstDraw) {
      transformGroup.x = transformInfoRoam.x;
      transformGroup.y = transformInfoRoam.y;
      transformGroup.scaleX = transformInfoRoam.scaleX;
      transformGroup.scaleY = transformInfoRoam.scaleY;
      transformGroup.dirty();
    } else {
      updateProps(transformGroup, transformInfoRoam, mapOrGeoModel);
    }
    const isVisualEncodedByVisualMap = data && data.getVisual("visualMeta") && data.getVisual("visualMeta").length > 0;
    const viewBuildCtx = {
      api: api2,
      geo,
      mapOrGeoModel,
      data,
      isVisualEncodedByVisualMap,
      isGeo,
      transformInfoRaw
    };
    if (geo.resourceType === "geoJSON") {
      this._buildGeoJSON(viewBuildCtx);
    } else if (geo.resourceType === "geoSVG") {
      this._buildSVG(viewBuildCtx);
    }
    this._updateController(mapOrGeoModel, clipRect, ecModel, api2);
    this._updateMapSelectHandler(mapOrGeoModel, regionsGroup, api2, fromView);
  }
  _buildGeoJSON(viewBuildCtx) {
    const regionsGroupByName = this._regionsGroupByName = createHashMap();
    const regionsInfoByName = createHashMap();
    const regionsGroup = this._regionsGroup;
    const transformInfoRaw = viewBuildCtx.transformInfoRaw;
    const mapOrGeoModel = viewBuildCtx.mapOrGeoModel;
    const data = viewBuildCtx.data;
    const projection = viewBuildCtx.geo.projection;
    const projectionStream = projection && projection.stream;
    function transformPoint(point, project) {
      if (project) {
        point = project(point);
      }
      return point && [
        point[0] * transformInfoRaw.scaleX + transformInfoRaw.x,
        point[1] * transformInfoRaw.scaleY + transformInfoRaw.y
      ];
    }
    ;
    function transformPolygonPoints(inPoints) {
      const outPoints = [];
      const project = !projectionStream && projection && projection.project;
      for (let i = 0; i < inPoints.length; ++i) {
        const newPt = transformPoint(inPoints[i], project);
        newPt && outPoints.push(newPt);
      }
      return outPoints;
    }
    function getPolyShape(points4) {
      return {
        shape: {
          points: transformPolygonPoints(points4)
        }
      };
    }
    regionsGroup.removeAll();
    each(viewBuildCtx.geo.regions, function(region) {
      const regionName = region.name;
      let regionGroup = regionsGroupByName.get(regionName);
      let {dataIdx, regionModel} = regionsInfoByName.get(regionName) || {};
      if (!regionGroup) {
        regionGroup = regionsGroupByName.set(regionName, new Group_default());
        regionsGroup.add(regionGroup);
        dataIdx = data ? data.indexOfName(regionName) : null;
        regionModel = viewBuildCtx.isGeo ? mapOrGeoModel.getRegionModel(regionName) : data ? data.getItemModel(dataIdx) : null;
        const silent = regionModel.get("silent", true);
        silent != null && (regionGroup.silent = silent);
        regionsInfoByName.set(regionName, {dataIdx, regionModel});
      }
      const polygonSubpaths = [];
      const polylineSubpaths = [];
      each(region.geometries, function(geometry) {
        if (geometry.type === "polygon") {
          let polys = [geometry.exterior].concat(geometry.interiors || []);
          if (projectionStream) {
            polys = projectPolys(polys, projectionStream);
          }
          each(polys, (poly) => {
            polygonSubpaths.push(new Polygon_default(getPolyShape(poly)));
          });
        } else {
          let points4 = geometry.points;
          if (projectionStream) {
            points4 = projectPolys(points4, projectionStream, true);
          }
          each(points4, (points5) => {
            polylineSubpaths.push(new Polyline_default(getPolyShape(points5)));
          });
        }
      });
      const centerPt = transformPoint(region.getCenter(), projection && projection.project);
      function createCompoundPath(subpaths, isLine) {
        if (!subpaths.length) {
          return;
        }
        const compoundPath = new CompoundPath_default({
          culling: true,
          segmentIgnoreThreshold: 1,
          shape: {
            paths: subpaths
          }
        });
        regionGroup.add(compoundPath);
        applyOptionStyleForRegion(viewBuildCtx, compoundPath, dataIdx, regionModel);
        resetLabelForRegion(viewBuildCtx, compoundPath, regionName, regionModel, mapOrGeoModel, dataIdx, centerPt);
        if (isLine) {
          fixLineStyle(compoundPath);
          each(compoundPath.states, fixLineStyle);
        }
      }
      createCompoundPath(polygonSubpaths);
      createCompoundPath(polylineSubpaths, true);
    });
    regionsGroupByName.each(function(regionGroup, regionName) {
      const {dataIdx, regionModel} = regionsInfoByName.get(regionName);
      resetEventTriggerForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel, dataIdx);
      resetTooltipForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel);
      resetStateTriggerForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel);
    }, this);
  }
  _buildSVG(viewBuildCtx) {
    const mapName = viewBuildCtx.geo.map;
    const transformInfoRaw = viewBuildCtx.transformInfoRaw;
    this._svgGroup.x = transformInfoRaw.x;
    this._svgGroup.y = transformInfoRaw.y;
    this._svgGroup.scaleX = transformInfoRaw.scaleX;
    this._svgGroup.scaleY = transformInfoRaw.scaleY;
    if (this._svgResourceChanged(mapName)) {
      this._freeSVG();
      this._useSVG(mapName);
    }
    const svgDispatcherMap = this._svgDispatcherMap = createHashMap();
    let focusSelf = false;
    each(this._svgGraphicRecord.named, function(namedItem) {
      const regionName = namedItem.name;
      const mapOrGeoModel = viewBuildCtx.mapOrGeoModel;
      const data = viewBuildCtx.data;
      const svgNodeTagLower = namedItem.svgNodeTagLower;
      const el = namedItem.el;
      const dataIdx = data ? data.indexOfName(regionName) : null;
      const regionModel = mapOrGeoModel.getRegionModel(regionName);
      if (OPTION_STYLE_ENABLED_TAG_MAP.get(svgNodeTagLower) != null && el instanceof Displayable_default) {
        applyOptionStyleForRegion(viewBuildCtx, el, dataIdx, regionModel);
      }
      if (el instanceof Displayable_default) {
        el.culling = true;
      }
      const silent = regionModel.get("silent", true);
      silent != null && (el.silent = silent);
      el.z2EmphasisLift = 0;
      if (!namedItem.namedFrom) {
        if (LABEL_HOST_MAP.get(svgNodeTagLower) != null) {
          resetLabelForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx, null);
        }
        resetEventTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx);
        resetTooltipForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel);
        if (STATE_TRIGGER_TAG_MAP.get(svgNodeTagLower) != null) {
          const focus = resetStateTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel);
          if (focus === "self") {
            focusSelf = true;
          }
          const els = svgDispatcherMap.get(regionName) || svgDispatcherMap.set(regionName, []);
          els.push(el);
        }
      }
    }, this);
    this._enableBlurEntireSVG(focusSelf, viewBuildCtx);
  }
  _enableBlurEntireSVG(focusSelf, viewBuildCtx) {
    if (focusSelf && viewBuildCtx.isGeo) {
      const blurStyle = viewBuildCtx.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle();
      const opacity = blurStyle.opacity;
      this._svgGraphicRecord.root.traverse((el) => {
        if (!el.isGroup) {
          setDefaultStateProxy(el);
          const style = el.ensureState("blur").style || {};
          if (style.opacity == null && opacity != null) {
            style.opacity = opacity;
          }
          el.ensureState("emphasis");
        }
      });
    }
  }
  remove() {
    this._regionsGroup.removeAll();
    this._regionsGroupByName = null;
    this._svgGroup.removeAll();
    this._freeSVG();
    this._controller.dispose();
    this._controllerHost = null;
  }
  findHighDownDispatchers(name, geoModel) {
    if (name == null) {
      return [];
    }
    const geo = geoModel.coordinateSystem;
    if (geo.resourceType === "geoJSON") {
      const regionsGroupByName = this._regionsGroupByName;
      if (regionsGroupByName) {
        const regionGroup = regionsGroupByName.get(name);
        return regionGroup ? [regionGroup] : [];
      }
    } else if (geo.resourceType === "geoSVG") {
      return this._svgDispatcherMap && this._svgDispatcherMap.get(name) || [];
    }
  }
  _svgResourceChanged(mapName) {
    return this._svgMapName !== mapName;
  }
  _useSVG(mapName) {
    const resource = geoSourceManager_default.getGeoResource(mapName);
    if (resource && resource.type === "geoSVG") {
      const svgGraphic = resource.useGraphic(this.uid);
      this._svgGroup.add(svgGraphic.root);
      this._svgGraphicRecord = svgGraphic;
      this._svgMapName = mapName;
    }
  }
  _freeSVG() {
    const mapName = this._svgMapName;
    if (mapName == null) {
      return;
    }
    const resource = geoSourceManager_default.getGeoResource(mapName);
    if (resource && resource.type === "geoSVG") {
      resource.freeGraphic(this.uid);
    }
    this._svgGraphicRecord = null;
    this._svgDispatcherMap = null;
    this._svgGroup.removeAll();
    this._svgMapName = null;
  }
  _updateController(mapOrGeoModel, clipRect, ecModel, api2) {
    const geo = mapOrGeoModel.coordinateSystem;
    const controller = this._controller;
    const controllerHost = this._controllerHost;
    controllerHost.zoomLimit = mapOrGeoModel.get("scaleLimit");
    controllerHost.zoom = geo.getZoom();
    controller.enable(mapOrGeoModel.get("roam") || false, {
      api: api2,
      zInfo: {component: mapOrGeoModel},
      triggerInfo: {
        roamTrigger: mapOrGeoModel.get("roamTrigger"),
        isInSelf: (e2, x, y) => geo.containPoint([x, y]),
        isInClip: (e2, x, y) => !clipRect || clipRect.contain(x, y)
      }
    });
    const mainType = mapOrGeoModel.mainType;
    function makeActionBase() {
      const action = {
        type: "geoRoam",
        componentType: mainType
      };
      action[mainType + "Id"] = mapOrGeoModel.id;
      return action;
    }
    controller.off("pan").on("pan", function(e2) {
      this._mouseDownFlag = false;
      updateViewOnPan(controllerHost, e2.dx, e2.dy);
      api2.dispatchAction(extend(makeActionBase(), {
        dx: e2.dx,
        dy: e2.dy,
        animation: {
          duration: 0
        }
      }));
    }, this);
    controller.off("zoom").on("zoom", function(e2) {
      this._mouseDownFlag = false;
      updateViewOnZoom(controllerHost, e2.scale, e2.originX, e2.originY);
      api2.dispatchAction(extend(makeActionBase(), {
        totalZoom: controllerHost.zoom,
        zoom: e2.scale,
        originX: e2.originX,
        originY: e2.originY,
        animation: {
          duration: 0
        }
      }));
    }, this);
  }
  resetForLabelLayout() {
    this.group.traverse((el) => {
      const label = el.getTextContent();
      if (label) {
        label.ignore = mapLabelRaw(label).ignore;
      }
    });
  }
  _updateMapSelectHandler(mapOrGeoModel, regionsGroup, api2, fromView) {
    const mapDraw = this;
    regionsGroup.off("mousedown");
    regionsGroup.off("click");
    if (mapOrGeoModel.get("selectedMode")) {
      regionsGroup.on("mousedown", function() {
        mapDraw._mouseDownFlag = true;
      });
      regionsGroup.on("click", function(e2) {
        if (!mapDraw._mouseDownFlag) {
          return;
        }
        mapDraw._mouseDownFlag = false;
      });
    }
  }
};
function applyOptionStyleForRegion(viewBuildCtx, el, dataIndex, regionModel) {
  const normalStyleModel = regionModel.getModel("itemStyle");
  const emphasisStyleModel = regionModel.getModel(["emphasis", "itemStyle"]);
  const blurStyleModel = regionModel.getModel(["blur", "itemStyle"]);
  const selectStyleModel = regionModel.getModel(["select", "itemStyle"]);
  const normalStyle = getFixedItemStyle(normalStyleModel);
  const emphasisStyle = getFixedItemStyle(emphasisStyleModel);
  const selectStyle = getFixedItemStyle(selectStyleModel);
  const blurStyle = getFixedItemStyle(blurStyleModel);
  const data = viewBuildCtx.data;
  if (data) {
    const style = data.getItemVisual(dataIndex, "style");
    const decal = data.getItemVisual(dataIndex, "decal");
    if (viewBuildCtx.isVisualEncodedByVisualMap && style.fill) {
      normalStyle.fill = style.fill;
    }
    if (decal) {
      normalStyle.decal = createOrUpdatePatternFromDecal(decal, viewBuildCtx.api);
    }
  }
  el.setStyle(normalStyle);
  el.style.strokeNoScale = true;
  el.ensureState("emphasis").style = emphasisStyle;
  el.ensureState("select").style = selectStyle;
  el.ensureState("blur").style = blurStyle;
  setDefaultStateProxy(el);
}
function resetLabelForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx, labelXY) {
  const data = viewBuildCtx.data;
  const isGeo = viewBuildCtx.isGeo;
  const isDataNaN = data && isNaN(data.get(data.mapDimension("value"), dataIdx));
  const itemLayout = data && data.getItemLayout(dataIdx);
  if (isGeo || isDataNaN || itemLayout && itemLayout.showLabel) {
    const query = !isGeo ? dataIdx : regionName;
    let labelFetcher;
    if (!data || dataIdx >= 0) {
      labelFetcher = mapOrGeoModel;
    }
    const specifiedTextOpt = labelXY ? {
      normal: {
        align: "center",
        verticalAlign: "middle"
      }
    } : null;
    setLabelStyle(el, getLabelStatesModels(regionModel), {
      labelFetcher,
      labelDataIndex: query,
      defaultText: regionName
    }, specifiedTextOpt);
    const textEl = el.getTextContent();
    if (textEl) {
      mapLabelRaw(textEl).ignore = textEl.ignore;
      if (el.textConfig && labelXY) {
        const rect = el.getBoundingRect().clone();
        el.textConfig.layoutRect = rect;
        el.textConfig.position = [
          (labelXY[0] - rect.x) / rect.width * 100 + "%",
          (labelXY[1] - rect.y) / rect.height * 100 + "%"
        ];
      }
    }
    el.disableLabelAnimation = true;
  } else {
    el.removeTextContent();
    el.removeTextConfig();
    el.disableLabelAnimation = null;
  }
}
function resetEventTriggerForRegion(viewBuildCtx, eventTrigger, regionName, regionModel, mapOrGeoModel, dataIdx) {
  if (viewBuildCtx.data) {
    viewBuildCtx.data.setItemGraphicEl(dataIdx, eventTrigger);
  } else {
    getECData(eventTrigger).eventData = {
      componentType: "geo",
      componentIndex: mapOrGeoModel.componentIndex,
      geoIndex: mapOrGeoModel.componentIndex,
      name: regionName,
      region: regionModel && regionModel.option || {}
    };
  }
}
function resetTooltipForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel) {
  if (!viewBuildCtx.data) {
    setTooltipConfig({
      el,
      componentModel: mapOrGeoModel,
      itemName: regionName,
      itemTooltipOption: regionModel.get("tooltip")
    });
  }
}
function resetStateTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel) {
  el.highDownSilentOnTouch = !!mapOrGeoModel.get("selectedMode");
  const emphasisModel = regionModel.getModel("emphasis");
  const focus = emphasisModel.get("focus");
  toggleHoverEmphasis(el, focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  if (viewBuildCtx.isGeo) {
    enableComponentHighDownFeatures(el, mapOrGeoModel, regionName);
  }
  return focus;
}
function projectPolys(rings, createStream, isLine) {
  const polygons = [];
  let curPoly;
  function startPolygon() {
    curPoly = [];
  }
  function endPolygon() {
    if (curPoly.length) {
      polygons.push(curPoly);
      curPoly = [];
    }
  }
  const stream = createStream({
    polygonStart: startPolygon,
    polygonEnd: endPolygon,
    lineStart: startPolygon,
    lineEnd: endPolygon,
    point(x, y) {
      if (isFinite(x) && isFinite(y)) {
        curPoly.push([x, y]);
      }
    },
    sphere() {
    }
  });
  !isLine && stream.polygonStart();
  each(rings, (ring) => {
    stream.lineStart();
    for (let i = 0; i < ring.length; i++) {
      stream.point(ring[i][0], ring[i][1]);
    }
    stream.lineEnd();
  });
  !isLine && stream.polygonEnd();
  return polygons;
}
var MapDraw_default = MapDraw;

// src/chart/map/MapView.ts
var MapView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = MapView2.type;
  }
  render(mapModel, ecModel, api2, payload) {
    if (payload && payload.type === "mapToggleSelect" && payload.from === this.uid) {
      return;
    }
    const group = this.group;
    group.removeAll();
    if (mapModel.getHostGeoModel()) {
      return;
    }
    if (this._mapDraw && payload && payload.type === "geoRoam") {
      this._mapDraw.resetForLabelLayout();
    }
    if (!(payload && payload.type === "geoRoam" && payload.componentType === "series" && payload.seriesId === mapModel.id)) {
      if (mapModel.needsDrawMap) {
        const mapDraw = this._mapDraw || new MapDraw_default(api2);
        group.add(mapDraw.group);
        mapDraw.draw(mapModel, ecModel, api2, this, payload);
        this._mapDraw = mapDraw;
      } else {
        this._mapDraw && this._mapDraw.remove();
        this._mapDraw = null;
      }
    } else {
      const mapDraw = this._mapDraw;
      mapDraw && group.add(mapDraw.group);
    }
    mapModel.get("showLegendSymbol") && ecModel.getComponent("legend") && this._renderSymbols(mapModel, ecModel, api2);
  }
  remove() {
    this._mapDraw && this._mapDraw.remove();
    this._mapDraw = null;
    this.group.removeAll();
  }
  dispose() {
    this._mapDraw && this._mapDraw.remove();
    this._mapDraw = null;
  }
  _renderSymbols(mapModel, ecModel, api2) {
    const originalData = mapModel.originalData;
    const group = this.group;
    originalData.each(originalData.mapDimension("value"), function(value, originalDataIndex) {
      if (isNaN(value)) {
        return;
      }
      const layout14 = originalData.getItemLayout(originalDataIndex);
      if (!layout14 || !layout14.point) {
        return;
      }
      const point = layout14.point;
      const offset = layout14.offset;
      const circle = new Circle_default({
        style: {
          fill: mapModel.getData().getVisual("style").fill
        },
        shape: {
          cx: point[0] + offset * 9,
          cy: point[1],
          r: 3
        },
        silent: true,
        z2: 8 + (!offset ? Z2_EMPHASIS_LIFT + 1 : 0)
      });
      if (!offset) {
        const fullData = mapModel.mainSeries.getData();
        const name = originalData.getName(originalDataIndex);
        const fullIndex = fullData.indexOfName(name);
        const itemModel = originalData.getItemModel(originalDataIndex);
        const labelModel = itemModel.getModel("label");
        const regionGroup = fullData.getItemGraphicEl(fullIndex);
        setLabelStyle(circle, getLabelStatesModels(itemModel), {
          labelFetcher: {
            getFormattedLabel(idx, state) {
              return mapModel.getFormattedLabel(fullIndex, state);
            }
          },
          defaultText: name
        });
        circle.disableLabelAnimation = true;
        if (!labelModel.get("position")) {
          circle.setTextConfig({
            position: "bottom"
          });
        }
        regionGroup.onHoverStateChange = function(toState) {
          setStatesFlag(circle, toState);
        };
      }
      group.add(circle);
    });
  }
};
var MapView = MapView2;
MapView.type = "map";
var MapView_default = MapView;

// src/chart/map/MapSeries.ts
var MapSeries2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = MapSeries2.type;
    this.needsDrawMap = false;
    this.seriesGroup = [];
    this.getTooltipPosition = function(dataIndex) {
      if (dataIndex != null) {
        const name = this.getData().getName(dataIndex);
        const geo = this.coordinateSystem;
        const region = geo.getRegion(name);
        return region && geo.dataToPoint(region.getCenter());
      }
    };
  }
  getInitialData(option) {
    const data = createSeriesDataSimply(this, {
      coordDimensions: ["value"],
      encodeDefaulter: curry(makeSeriesEncodeForNameBased, this)
    });
    const dataNameIndexMap = createHashMap();
    const toAppendItems = [];
    for (let i = 0, len2 = data.count(); i < len2; i++) {
      const name = data.getName(i);
      dataNameIndexMap.set(name, i);
    }
    const geoSource = geoSourceManager_default.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
    each(geoSource.regions, function(region) {
      const name = region.name;
      const dataNameIdx = dataNameIndexMap.get(name);
      const specifiedGeoJSONRegionStyle = region.properties && region.properties.echartsStyle;
      let dataItem;
      if (dataNameIdx == null) {
        dataItem = {name};
        toAppendItems.push(dataItem);
      } else {
        dataItem = data.getRawDataItem(dataNameIdx);
      }
      specifiedGeoJSONRegionStyle && merge(dataItem, specifiedGeoJSONRegionStyle);
    });
    data.appendData(toAppendItems);
    return data;
  }
  getHostGeoModel() {
    if (decideCoordSysUsageKind(this).kind === CoordinateSystemUsageKind.boxCoordSys) {
      return;
    }
    return this.getReferringComponents("geo", {useDefault: false, enableAll: false, enableNone: false}).models[0];
  }
  getMapType() {
    return (this.getHostGeoModel() || this).option.map;
  }
  getRawValue(dataIndex) {
    const data = this.getData();
    return data.get(data.mapDimension("value"), dataIndex);
  }
  getRegionModel(regionName) {
    const data = this.getData();
    return data.getItemModel(data.indexOfName(regionName));
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    const data = this.getData();
    const value = this.getRawValue(dataIndex);
    const name = data.getName(dataIndex);
    const seriesGroup = this.seriesGroup;
    const seriesNames = [];
    for (let i = 0; i < seriesGroup.length; i++) {
      const otherIndex = seriesGroup[i].originalData.indexOfName(name);
      const valueDim = data.mapDimension("value");
      if (!isNaN(seriesGroup[i].originalData.get(valueDim, otherIndex))) {
        seriesNames.push(seriesGroup[i].name);
      }
    }
    return createTooltipMarkup("section", {
      header: seriesNames.join(", "),
      noHeader: !seriesNames.length,
      blocks: [createTooltipMarkup("nameValue", {
        name,
        value
      })]
    });
  }
  setZoom(zoom) {
    this.option.zoom = zoom;
  }
  setCenter(center3) {
    this.option.center = center3;
  }
  getLegendIcon(opt) {
    const iconType = opt.icon || "roundRect";
    const icon = createSymbol(iconType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill);
    icon.setStyle(opt.itemStyle);
    icon.style.stroke = "none";
    if (iconType.indexOf("empty") > -1) {
      icon.style.stroke = icon.style.fill;
      icon.style.fill = tokens_default.color.neutral00;
      icon.style.lineWidth = 2;
    }
    return icon;
  }
};
var MapSeries = MapSeries2;
MapSeries.type = "series.map";
MapSeries.dependencies = ["geo"];
MapSeries.layoutMode = "box";
MapSeries.defaultOption = {
  z: 2,
  coordinateSystem: "geo",
  map: "",
  left: "center",
  top: "center",
  aspectScale: null,
  showLegendSymbol: true,
  boundingCoords: null,
  center: null,
  zoom: 1,
  scaleLimit: null,
  selectedMode: true,
  label: {
    show: false,
    color: tokens_default.color.tertiary
  },
  itemStyle: {
    borderWidth: 0.5,
    borderColor: tokens_default.color.border,
    areaColor: tokens_default.color.background
  },
  emphasis: {
    label: {
      show: true,
      color: tokens_default.color.primary
    },
    itemStyle: {
      areaColor: tokens_default.color.highlight
    }
  },
  select: {
    label: {
      show: true,
      color: tokens_default.color.primary
    },
    itemStyle: {
      color: tokens_default.color.highlight
    }
  },
  nameProperty: "name"
};
var MapSeries_default = MapSeries;

// src/chart/map/mapDataStatistic.ts
function dataStatistics(datas, statisticType) {
  const dataNameMap = {};
  each(datas, function(data) {
    data.each(data.mapDimension("value"), function(value, idx) {
      const mapKey = "ec-" + data.getName(idx);
      dataNameMap[mapKey] = dataNameMap[mapKey] || [];
      if (!isNaN(value)) {
        dataNameMap[mapKey].push(value);
      }
    });
  });
  return datas[0].map(datas[0].mapDimension("value"), function(value, idx) {
    const mapKey = "ec-" + datas[0].getName(idx);
    let sum2 = 0;
    let min3 = Infinity;
    let max3 = -Infinity;
    const len2 = dataNameMap[mapKey].length;
    for (let i = 0; i < len2; i++) {
      min3 = Math.min(min3, dataNameMap[mapKey][i]);
      max3 = Math.max(max3, dataNameMap[mapKey][i]);
      sum2 += dataNameMap[mapKey][i];
    }
    let result;
    if (statisticType === "min") {
      result = min3;
    } else if (statisticType === "max") {
      result = max3;
    } else if (statisticType === "average") {
      result = sum2 / len2;
    } else {
      result = sum2;
    }
    return len2 === 0 ? NaN : result;
  });
}
function mapDataStatistic(ecModel) {
  const seriesGroups = {};
  ecModel.eachSeriesByType("map", function(seriesModel) {
    const hostGeoModel = seriesModel.getHostGeoModel();
    const key = hostGeoModel ? "o" + hostGeoModel.id : "i" + seriesModel.getMapType();
    (seriesGroups[key] = seriesGroups[key] || []).push(seriesModel);
  });
  each(seriesGroups, function(seriesList, key) {
    const data = dataStatistics(map(seriesList, function(seriesModel) {
      return seriesModel.getData();
    }), seriesList[0].get("mapValueCalculation"));
    for (let i = 0; i < seriesList.length; i++) {
      seriesList[i].originalData = seriesList[i].getData();
    }
    for (let i = 0; i < seriesList.length; i++) {
      seriesList[i].seriesGroup = seriesList;
      seriesList[i].needsDrawMap = i === 0 && !seriesList[i].getHostGeoModel();
      seriesList[i].setData(data.cloneShallow());
      seriesList[i].mainSeries = seriesList[0];
    }
  });
}

// src/chart/map/mapSymbolLayout.ts
function mapSymbolLayout(ecModel) {
  const processedMapType = {};
  ecModel.eachSeriesByType("map", function(mapSeries) {
    const mapType = mapSeries.getMapType();
    if (mapSeries.getHostGeoModel() || processedMapType[mapType]) {
      return;
    }
    const mapSymbolOffsets = {};
    each(mapSeries.seriesGroup, function(subMapSeries) {
      const geo = subMapSeries.coordinateSystem;
      const data2 = subMapSeries.originalData;
      if (subMapSeries.get("showLegendSymbol") && ecModel.getComponent("legend")) {
        data2.each(data2.mapDimension("value"), function(value, idx) {
          const name = data2.getName(idx);
          const region = geo.getRegion(name);
          if (!region || isNaN(value)) {
            return;
          }
          const offset = mapSymbolOffsets[name] || 0;
          const point = geo.dataToPoint(region.getCenter());
          mapSymbolOffsets[name] = offset + 1;
          data2.setItemLayout(idx, {
            point,
            offset
          });
        });
      }
    });
    const data = mapSeries.getData();
    data.each(function(idx) {
      const name = data.getName(idx);
      const layout14 = data.getItemLayout(idx) || {};
      layout14.showLabel = !mapSymbolOffsets[name];
      data.setItemLayout(idx, layout14);
    });
    processedMapType[mapType] = true;
  });
}

// src/coord/View.ts
var v2ApplyTransform = applyTransform;
var View = class extends Transformable_default {
  constructor(name, opt) {
    super();
    this.type = "view";
    this.dimensions = ["x", "y"];
    this._roamTransformable = new Transformable_default();
    this._rawTransformable = new Transformable_default();
    this.name = name;
    this._opt = opt;
  }
  setBoundingRect(x, y, width, height) {
    this._rect = new BoundingRect_default(x, y, width, height);
    this._updateCenterAndZoom();
    return this._rect;
  }
  getBoundingRect() {
    return this._rect;
  }
  setViewRect(x, y, width, height) {
    this._transformTo(x, y, width, height);
    this._viewRect = new BoundingRect_default(x, y, width, height);
  }
  _transformTo(x, y, width, height) {
    const rect = this.getBoundingRect();
    const rawTransform = this._rawTransformable;
    rawTransform.transform = rect.calculateTransform(new BoundingRect_default(x, y, width, height));
    const rawParent = rawTransform.parent;
    rawTransform.parent = null;
    rawTransform.decomposeTransform();
    rawTransform.parent = rawParent;
    this._updateTransform();
  }
  setCenter(centerCoord) {
    const opt = this._opt;
    if (opt && opt.api && opt.ecModel && opt.ecModel.getShallow("legacyViewCoordSysCenterBase") && centerCoord) {
      centerCoord = [
        parsePercent2(centerCoord[0], opt.api.getWidth()),
        parsePercent2(centerCoord[1], opt.api.getWidth())
      ];
    }
    this._centerOption = clone(centerCoord);
    this._updateCenterAndZoom();
  }
  setZoom(zoom) {
    this._zoom = clampByZoomLimit(zoom || 1, this.zoomLimit);
    this._updateCenterAndZoom();
  }
  getDefaultCenter() {
    const rawRect = this.getBoundingRect();
    const cx = rawRect.x + rawRect.width / 2;
    const cy = rawRect.y + rawRect.height / 2;
    return [cx, cy];
  }
  getCenter() {
    return this._center || this.getDefaultCenter();
  }
  getZoom() {
    return this._zoom || 1;
  }
  getRoamTransform() {
    return this._roamTransformable.getLocalTransform();
  }
  _updateCenterAndZoom() {
    const centerOption = this._centerOption;
    const rect = this._rect;
    if (centerOption && rect) {
      this._center = [
        parsePercent2(centerOption[0], rect.width, rect.x),
        parsePercent2(centerOption[1], rect.height, rect.y)
      ];
    }
    const rawTransformMatrix = this._rawTransformable.getLocalTransform();
    const roamTransform = this._roamTransformable;
    let defaultCenter = this.getDefaultCenter();
    let center3 = this.getCenter();
    const zoom = this.getZoom();
    center3 = applyTransform([], center3, rawTransformMatrix);
    defaultCenter = applyTransform([], defaultCenter, rawTransformMatrix);
    roamTransform.originX = center3[0];
    roamTransform.originY = center3[1];
    roamTransform.x = defaultCenter[0] - center3[0];
    roamTransform.y = defaultCenter[1] - center3[1];
    roamTransform.scaleX = roamTransform.scaleY = zoom;
    this._updateTransform();
  }
  _updateTransform() {
    const roamTransformable = this._roamTransformable;
    const rawTransformable = this._rawTransformable;
    rawTransformable.parent = roamTransformable;
    roamTransformable.updateTransform();
    rawTransformable.updateTransform();
    copy2(this.transform || (this.transform = []), rawTransformable.transform || create2());
    this._rawTransform = rawTransformable.getLocalTransform();
    this.invTransform = this.invTransform || [];
    invert(this.invTransform, this.transform);
    this.decomposeTransform();
  }
  getTransformInfo() {
    const rawTransformable = this._rawTransformable;
    const roamTransformable = this._roamTransformable;
    const dummyTransformable2 = new Transformable_default();
    dummyTransformable2.transform = roamTransformable.transform;
    dummyTransformable2.decomposeTransform();
    return {
      roam: {
        x: dummyTransformable2.x,
        y: dummyTransformable2.y,
        scaleX: dummyTransformable2.scaleX,
        scaleY: dummyTransformable2.scaleY
      },
      raw: {
        x: rawTransformable.x,
        y: rawTransformable.y,
        scaleX: rawTransformable.scaleX,
        scaleY: rawTransformable.scaleY
      }
    };
  }
  getViewRect() {
    return this._viewRect;
  }
  getViewRectAfterRoam() {
    const rect = this.getBoundingRect().clone();
    rect.applyTransform(this.transform);
    return rect;
  }
  dataToPoint(data, noRoam, out2) {
    const transform2 = noRoam ? this._rawTransform : this.transform;
    out2 = out2 || [];
    return transform2 ? v2ApplyTransform(out2, data, transform2) : copy(out2, data);
  }
  pointToData(point, reserved, out2) {
    out2 = out2 || [];
    const invTransform = this.invTransform;
    return invTransform ? v2ApplyTransform(out2, point, invTransform) : (out2[0] = point[0], out2[1] = point[1], out2);
  }
  convertToPixel(ecModel, finder, value) {
    const coordSys = getCoordSys(finder);
    return coordSys === this ? coordSys.dataToPoint(value) : null;
  }
  convertFromPixel(ecModel, finder, pixel) {
    const coordSys = getCoordSys(finder);
    return coordSys === this ? coordSys.pointToData(pixel) : null;
  }
  containPoint(point) {
    return this.getViewRectAfterRoam().contain(point[0], point[1]);
  }
};
View.dimensions = ["x", "y"];
function getCoordSys(finder) {
  const seriesModel = finder.seriesModel;
  return seriesModel ? seriesModel.coordinateSystem : null;
}
var View_default = View;

// src/coord/geo/Geo.ts
var GEO_DEFAULT_PARAMS = {
  geoJSON: {
    aspectScale: 0.75,
    invertLongitute: true
  },
  geoSVG: {
    aspectScale: 1,
    invertLongitute: false
  }
};
var geo2DDimensions = ["lng", "lat"];
var Geo = class extends View_default {
  constructor(name, map3, opt) {
    super(name, {api: opt.api, ecModel: opt.ecModel});
    this.dimensions = geo2DDimensions;
    this.type = "geo";
    this._nameCoordMap = createHashMap();
    this.map = map3;
    let projection = opt.projection;
    const source = geoSourceManager_default.load(map3, opt.nameMap, opt.nameProperty);
    const resource = geoSourceManager_default.getGeoResource(map3);
    const resourceType = this.resourceType = resource ? resource.type : null;
    const regions = this.regions = source.regions;
    const defaultParams = GEO_DEFAULT_PARAMS[resource.type];
    this._regionsMap = source.regionsMap;
    this.regions = source.regions;
    if (projection) {
      if (resourceType === "geoSVG") {
        if (true) {
          warn(`Map ${map3} with SVG source can't use projection. Only GeoJSON source supports projection.`);
        }
        projection = null;
      }
      if (!(projection.project && projection.unproject)) {
        if (true) {
          warn("project and unproject must be both provided in the projeciton.");
        }
        projection = null;
      }
    }
    this.projection = projection;
    let boundingRect;
    if (projection) {
      for (let i = 0; i < regions.length; i++) {
        const regionRect = regions[i].getBoundingRect(projection);
        boundingRect = boundingRect || regionRect.clone();
        boundingRect.union(regionRect);
      }
    } else {
      boundingRect = source.boundingRect;
    }
    this.setBoundingRect(boundingRect.x, boundingRect.y, boundingRect.width, boundingRect.height);
    this.aspectScale = projection ? 1 : retrieve2(opt.aspectScale, defaultParams.aspectScale);
    this._invertLongitute = projection ? false : defaultParams.invertLongitute;
  }
  _transformTo(x, y, width, height) {
    let rect = this.getBoundingRect();
    const invertLongitute = this._invertLongitute;
    rect = rect.clone();
    if (invertLongitute) {
      rect.y = -rect.y - rect.height;
    }
    const rawTransformable = this._rawTransformable;
    rawTransformable.transform = rect.calculateTransform(new BoundingRect_default(x, y, width, height));
    const rawParent = rawTransformable.parent;
    rawTransformable.parent = null;
    rawTransformable.decomposeTransform();
    rawTransformable.parent = rawParent;
    if (invertLongitute) {
      rawTransformable.scaleY = -rawTransformable.scaleY;
    }
    this._updateTransform();
  }
  getRegion(name) {
    return this._regionsMap.get(name);
  }
  getRegionByCoord(coord) {
    const regions = this.regions;
    for (let i = 0; i < regions.length; i++) {
      const region = regions[i];
      if (region.type === "geoJSON" && region.contain(coord)) {
        return regions[i];
      }
    }
  }
  addGeoCoord(name, geoCoord2) {
    this._nameCoordMap.set(name, geoCoord2);
  }
  getGeoCoord(name) {
    const region = this._regionsMap.get(name);
    return this._nameCoordMap.get(name) || region && region.getCenter();
  }
  dataToPoint(data, noRoam, out2) {
    if (isString(data)) {
      data = this.getGeoCoord(data);
    }
    if (data) {
      const projection = this.projection;
      if (projection) {
        data = projection.project(data);
      }
      return data && this.projectedToPoint(data, noRoam, out2);
    }
  }
  pointToData(point, reserved, out2) {
    const projection = this.projection;
    if (projection) {
      point = projection.unproject(point);
    }
    return point && this.pointToProjected(point, out2);
  }
  pointToProjected(point, out2) {
    return super.pointToData(point, 0, out2);
  }
  projectedToPoint(projected, noRoam, out2) {
    return super.dataToPoint(projected, noRoam, out2);
  }
  convertToPixel(ecModel, finder, value) {
    const coordSys = getCoordSys2(finder);
    return coordSys === this ? coordSys.dataToPoint(value) : null;
  }
  convertFromPixel(ecModel, finder, pixel) {
    const coordSys = getCoordSys2(finder);
    return coordSys === this ? coordSys.pointToData(pixel) : null;
  }
};
mixin(Geo, View_default);
function getCoordSys2(finder) {
  const geoModel = finder.geoModel;
  const seriesModel = finder.seriesModel;
  return geoModel ? geoModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem || (seriesModel.getReferringComponents("geo", SINGLE_REFERRING).models[0] || {}).coordinateSystem : null;
}
var Geo_default = Geo;

// src/coord/geo/geoCreator.ts
function resizeGeo(geoModel, api2) {
  const boundingCoords = geoModel.get("boundingCoords");
  if (boundingCoords != null) {
    let leftTop = boundingCoords[0];
    let rightBottom = boundingCoords[1];
    if (!(isFinite(leftTop[0]) && isFinite(leftTop[1]) && isFinite(rightBottom[0]) && isFinite(rightBottom[1]))) {
      if (true) {
        console.error("Invalid boundingCoords");
      }
    } else {
      const projection = this.projection;
      if (projection) {
        const xMin = leftTop[0];
        const yMin = leftTop[1];
        const xMax = rightBottom[0];
        const yMax = rightBottom[1];
        leftTop = [Infinity, Infinity];
        rightBottom = [-Infinity, -Infinity];
        const sampleLine = (x0, y0, x1, y1) => {
          const dx = x1 - x0;
          const dy = y1 - y0;
          for (let i = 0; i <= 100; i++) {
            const p = i / 100;
            const pt = projection.project([x0 + dx * p, y0 + dy * p]);
            min(leftTop, leftTop, pt);
            max(rightBottom, rightBottom, pt);
          }
        };
        sampleLine(xMin, yMin, xMax, yMin);
        sampleLine(xMax, yMin, xMax, yMax);
        sampleLine(xMax, yMax, xMin, yMax);
        sampleLine(xMin, yMax, xMax, yMin);
      }
      this.setBoundingRect(leftTop[0], leftTop[1], rightBottom[0] - leftTop[0], rightBottom[1] - leftTop[1]);
    }
  }
  const rect = this.getBoundingRect();
  const centerOption = geoModel.get("layoutCenter");
  const sizeOption = geoModel.get("layoutSize");
  const {refContainer} = createBoxLayoutReference(geoModel, api2);
  const aspect = rect.width / rect.height * this.aspectScale;
  let useCenterAndSize = false;
  let center3;
  let size;
  if (centerOption && sizeOption) {
    center3 = [
      parsePercent2(centerOption[0], refContainer.width) + refContainer.x,
      parsePercent2(centerOption[1], refContainer.height) + refContainer.y
    ];
    size = parsePercent2(sizeOption, Math.min(refContainer.width, refContainer.height));
    if (!isNaN(center3[0]) && !isNaN(center3[1]) && !isNaN(size)) {
      useCenterAndSize = true;
    } else {
      if (true) {
        console.warn("Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead.");
      }
    }
  }
  let viewRect2;
  if (useCenterAndSize) {
    viewRect2 = {};
    if (aspect > 1) {
      viewRect2.width = size;
      viewRect2.height = size / aspect;
    } else {
      viewRect2.height = size;
      viewRect2.width = size * aspect;
    }
    viewRect2.y = center3[1] - viewRect2.height / 2;
    viewRect2.x = center3[0] - viewRect2.width / 2;
  } else {
    const boxLayoutOption = geoModel.getBoxLayoutParams();
    boxLayoutOption.aspect = aspect;
    viewRect2 = getLayoutRect(boxLayoutOption, refContainer);
    viewRect2 = applyPreserveAspect(geoModel, viewRect2, aspect);
  }
  this.setViewRect(viewRect2.x, viewRect2.y, viewRect2.width, viewRect2.height);
  this.setCenter(geoModel.get("center"));
  this.setZoom(geoModel.get("zoom"));
}
function setGeoCoords(geo, model) {
  each(model.get("geoCoord"), function(geoCoord2, name) {
    geo.addGeoCoord(name, geoCoord2);
  });
}
var GeoCreator = class {
  constructor() {
    this.dimensions = geo2DDimensions;
  }
  create(ecModel, api2) {
    const geoList = [];
    function getCommonGeoProperties(model) {
      return {
        nameProperty: model.get("nameProperty"),
        aspectScale: model.get("aspectScale"),
        projection: model.get("projection")
      };
    }
    ecModel.eachComponent("geo", function(geoModel, idx) {
      const mapName = geoModel.get("map");
      const geo = new Geo_default(mapName + idx, mapName, extend({
        nameMap: geoModel.get("nameMap"),
        api: api2,
        ecModel
      }, getCommonGeoProperties(geoModel)));
      geo.zoomLimit = geoModel.get("scaleLimit");
      geoList.push(geo);
      geoModel.coordinateSystem = geo;
      geo.model = geoModel;
      geo.resize = resizeGeo;
      geo.resize(geoModel, api2);
    });
    ecModel.eachSeries(function(seriesModel) {
      injectCoordSysByOption({
        targetModel: seriesModel,
        coordSysType: "geo",
        coordSysProvider() {
          const geoModel = seriesModel.subType === "map" ? seriesModel.getHostGeoModel() : seriesModel.getReferringComponents("geo", SINGLE_REFERRING).models[0];
          return geoModel && geoModel.coordinateSystem;
        },
        allowNotFound: true
      });
    });
    const mapModelGroupBySeries = {};
    ecModel.eachSeriesByType("map", function(seriesModel) {
      if (!seriesModel.getHostGeoModel()) {
        const mapType = seriesModel.getMapType();
        mapModelGroupBySeries[mapType] = mapModelGroupBySeries[mapType] || [];
        mapModelGroupBySeries[mapType].push(seriesModel);
      }
    });
    each(mapModelGroupBySeries, function(mapSeries, mapType) {
      const nameMapList = map(mapSeries, function(singleMapSeries) {
        return singleMapSeries.get("nameMap");
      });
      const geo = new Geo_default(mapType, mapType, extend({
        nameMap: mergeAll(nameMapList),
        api: api2,
        ecModel
      }, getCommonGeoProperties(mapSeries[0])));
      geo.zoomLimit = retrieve.apply(null, map(mapSeries, function(singleMapSeries) {
        return singleMapSeries.get("scaleLimit");
      }));
      geoList.push(geo);
      geo.resize = resizeGeo;
      geo.resize(mapSeries[0], api2);
      each(mapSeries, function(singleMapSeries) {
        singleMapSeries.coordinateSystem = geo;
        setGeoCoords(geo, singleMapSeries);
      });
    });
    return geoList;
  }
  getFilledRegions(originRegionArr, mapName, nameMap, nameProperty) {
    const regionsArr = (originRegionArr || []).slice();
    const dataNameMap = createHashMap();
    for (let i = 0; i < regionsArr.length; i++) {
      dataNameMap.set(regionsArr[i].name, regionsArr[i]);
    }
    const source = geoSourceManager_default.load(mapName, nameMap, nameProperty);
    each(source.regions, function(region) {
      const name = region.name;
      let regionOption = dataNameMap.get(name);
      const specifiedGeoJSONRegionStyle = region.properties && region.properties.echartsStyle;
      if (!regionOption) {
        regionOption = {
          name
        };
        regionsArr.push(regionOption);
      }
      specifiedGeoJSONRegionStyle && merge(regionOption, specifiedGeoJSONRegionStyle);
    });
    return regionsArr;
  }
};
var geoCreator = new GeoCreator();
var geoCreator_default = geoCreator;

// src/coord/geo/GeoModel.ts
var GeoModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = GeoModel2.type;
  }
  init(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
    const source = geoSourceManager_default.getGeoResource(option.map);
    if (source && source.type === "geoJSON") {
      const itemStyle = option.itemStyle = option.itemStyle || {};
      if (!("color" in itemStyle)) {
        itemStyle.color = option.defaultItemStyleColor || tokens_default.color.backgroundTint;
      }
    }
    defaultEmphasis(option, "label", ["show"]);
  }
  optionUpdated() {
    const option = this.option;
    option.regions = geoCreator_default.getFilledRegions(option.regions, option.map, option.nameMap, option.nameProperty);
    const selectedMap = {};
    this._optionModelMap = reduce(option.regions || [], (optionModelMap, regionOpt) => {
      const regionName = regionOpt.name;
      if (regionName) {
        optionModelMap.set(regionName, new Model_default(regionOpt, this, this.ecModel));
        if (regionOpt.selected) {
          selectedMap[regionName] = true;
        }
      }
      return optionModelMap;
    }, createHashMap());
    if (!option.selectedMap) {
      option.selectedMap = selectedMap;
    }
  }
  getRegionModel(name) {
    return this._optionModelMap.get(name) || new Model_default(null, this, this.ecModel);
  }
  getFormattedLabel(name, status) {
    const regionModel = this.getRegionModel(name);
    const formatter = status === "normal" ? regionModel.get(["label", "formatter"]) : regionModel.get(["emphasis", "label", "formatter"]);
    const params = {
      name
    };
    if (isFunction(formatter)) {
      params.status = status;
      return formatter(params);
    } else if (isString(formatter)) {
      return formatter.replace("{a}", name != null ? name : "");
    }
  }
  setZoom(zoom) {
    this.option.zoom = zoom;
  }
  setCenter(center3) {
    this.option.center = center3;
  }
  select(name) {
    const option = this.option;
    const selectedMode = option.selectedMode;
    if (!selectedMode) {
      return;
    }
    if (selectedMode !== "multiple") {
      option.selectedMap = null;
    }
    const selectedMap = option.selectedMap || (option.selectedMap = {});
    selectedMap[name] = true;
  }
  unSelect(name) {
    const selectedMap = this.option.selectedMap;
    if (selectedMap) {
      selectedMap[name] = false;
    }
  }
  toggleSelected(name) {
    this[this.isSelected(name) ? "unSelect" : "select"](name);
  }
  isSelected(name) {
    const selectedMap = this.option.selectedMap;
    return !!(selectedMap && selectedMap[name]);
  }
};
var GeoModel = GeoModel2;
GeoModel.type = "geo";
GeoModel.layoutMode = "box";
GeoModel.defaultOption = {
  z: 0,
  show: true,
  left: "center",
  top: "center",
  aspectScale: null,
  silent: false,
  map: "",
  boundingCoords: null,
  center: null,
  zoom: 1,
  scaleLimit: null,
  label: {
    show: false,
    color: tokens_default.color.tertiary
  },
  itemStyle: {
    borderWidth: 0.5,
    borderColor: tokens_default.color.border
  },
  emphasis: {
    label: {
      show: true,
      color: tokens_default.color.primary
    },
    itemStyle: {
      color: tokens_default.color.highlight
    }
  },
  select: {
    label: {
      show: true,
      color: tokens_default.color.primary
    },
    itemStyle: {
      color: tokens_default.color.highlight
    }
  },
  regions: []
};
var GeoModel_default = GeoModel;

// src/component/geo/GeoView.ts
var GeoView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = GeoView2.type;
    this.focusBlurEnabled = true;
  }
  init(ecModel, api2) {
    this._api = api2;
  }
  render(geoModel, ecModel, api2, payload) {
    this._model = geoModel;
    if (!geoModel.get("show")) {
      this._mapDraw && this._mapDraw.remove();
      this._mapDraw = null;
      return;
    }
    if (!this._mapDraw) {
      this._mapDraw = new MapDraw_default(api2);
    }
    const mapDraw = this._mapDraw;
    mapDraw.draw(geoModel, ecModel, api2, this, payload);
    mapDraw.group.on("click", this._handleRegionClick, this);
    mapDraw.group.silent = geoModel.get("silent");
    this.group.add(mapDraw.group);
    this.updateSelectStatus(geoModel, ecModel, api2);
  }
  _handleRegionClick(e2) {
    let eventData;
    findEventDispatcher(e2.target, (current) => {
      return (eventData = getECData(current).eventData) != null;
    }, true);
    if (eventData) {
      this._api.dispatchAction({
        type: "geoToggleSelect",
        geoId: this._model.id,
        name: eventData.name
      });
    }
  }
  updateSelectStatus(model, ecModel, api2) {
    this._mapDraw.group.traverse((node) => {
      const eventData = getECData(node).eventData;
      if (eventData) {
        this._model.isSelected(eventData.name) ? api2.enterSelect(node) : api2.leaveSelect(node);
        return true;
      }
    });
  }
  findHighDownDispatchers(name) {
    return this._mapDraw && this._mapDraw.findHighDownDispatchers(name, this._model);
  }
  dispose() {
    this._mapDraw && this._mapDraw.remove();
  }
};
var GeoView = GeoView2;
GeoView.type = "geo";
var GeoView_default = GeoView;

// src/component/geo/install.ts
function registerMap2(mapName, geoJson, specialAreas) {
  geoSourceManager_default.registerMap(mapName, geoJson, specialAreas);
}
function install10(registers) {
  registers.registerCoordinateSystem("geo", geoCreator_default);
  registers.registerComponentModel(GeoModel_default);
  registers.registerComponentView(GeoView_default);
  registers.registerImpl("registerMap", registerMap2);
  registers.registerImpl("getMap", (mapName) => geoSourceManager_default.getMapForUser(mapName));
  function makeAction(method, actionInfo2) {
    actionInfo2.update = "geo:updateSelectStatus";
    registers.registerAction(actionInfo2, function(payload, ecModel) {
      const selected = {};
      const allSelected = [];
      ecModel.eachComponent({mainType: "geo", query: payload}, function(geoModel) {
        geoModel[method](payload.name);
        const geo = geoModel.coordinateSystem;
        each(geo.regions, function(region) {
          selected[region.name] = geoModel.isSelected(region.name) || false;
        });
        const names = [];
        each(selected, function(v, name) {
          selected[name] && names.push(name);
        });
        allSelected.push({
          geoIndex: geoModel.componentIndex,
          name: names
        });
      });
      return {
        selected,
        allSelected,
        name: payload.name
      };
    });
  }
  makeAction("toggleSelected", {
    type: "geoToggleSelect",
    event: "geoselectchanged"
  });
  makeAction("select", {
    type: "geoSelect",
    event: "geoselected"
  });
  makeAction("unSelect", {
    type: "geoUnSelect",
    event: "geounselected"
  });
  registers.registerAction({
    type: "geoRoam",
    event: "geoRoam",
    update: "updateTransform"
  }, function(payload, ecModel, api2) {
    let componentType = payload.componentType;
    if (!componentType) {
      if (payload.geoId != null) {
        componentType = "geo";
      } else if (payload.seriesId != null) {
        componentType = "series";
      }
    }
    if (!componentType) {
      componentType = "series";
    }
    ecModel.eachComponent({mainType: componentType, query: payload}, function(componentModel) {
      const geo = componentModel.coordinateSystem;
      if (geo.type !== "geo") {
        return;
      }
      const res = updateCenterAndZoomInAction(geo, payload, componentModel.get("scaleLimit"));
      componentModel.setCenter && componentModel.setCenter(res.center);
      componentModel.setZoom && componentModel.setZoom(res.zoom);
      if (componentType === "series") {
        each(componentModel.seriesGroup, function(seriesModel) {
          seriesModel.setCenter(res.center);
          seriesModel.setZoom(res.zoom);
        });
      }
    });
  });
}

// src/chart/map/install.ts
function install11(registers) {
  use(install10);
  registers.registerChartView(MapView_default);
  registers.registerSeriesModel(MapSeries_default);
  registers.registerLayout(mapSymbolLayout);
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, mapDataStatistic);
  createLegacyDataSelectAction("map", registers.registerAction);
}

// src/chart/tree/layoutHelper.ts
function init3(inRoot) {
  const root = inRoot;
  root.hierNode = {
    defaultAncestor: null,
    ancestor: root,
    prelim: 0,
    modifier: 0,
    change: 0,
    shift: 0,
    i: 0,
    thread: null
  };
  const nodes = [root];
  let node;
  let children;
  while (node = nodes.pop()) {
    children = node.children;
    if (node.isExpand && children.length) {
      const n = children.length;
      for (let i = n - 1; i >= 0; i--) {
        const child = children[i];
        child.hierNode = {
          defaultAncestor: null,
          ancestor: child,
          prelim: 0,
          modifier: 0,
          change: 0,
          shift: 0,
          i,
          thread: null
        };
        nodes.push(child);
      }
    }
  }
}
function firstWalk(node, separation2) {
  const children = node.isExpand ? node.children : [];
  const siblings = node.parentNode.children;
  const subtreeW = node.hierNode.i ? siblings[node.hierNode.i - 1] : null;
  if (children.length) {
    executeShifts(node);
    const midPoint = (children[0].hierNode.prelim + children[children.length - 1].hierNode.prelim) / 2;
    if (subtreeW) {
      node.hierNode.prelim = subtreeW.hierNode.prelim + separation2(node, subtreeW);
      node.hierNode.modifier = node.hierNode.prelim - midPoint;
    } else {
      node.hierNode.prelim = midPoint;
    }
  } else if (subtreeW) {
    node.hierNode.prelim = subtreeW.hierNode.prelim + separation2(node, subtreeW);
  }
  node.parentNode.hierNode.defaultAncestor = apportion(node, subtreeW, node.parentNode.hierNode.defaultAncestor || siblings[0], separation2);
}
function secondWalk(node) {
  const nodeX = node.hierNode.prelim + node.parentNode.hierNode.modifier;
  node.setLayout({x: nodeX}, true);
  node.hierNode.modifier += node.parentNode.hierNode.modifier;
}
function separation(cb) {
  return arguments.length ? cb : defaultSeparation;
}
function radialCoordinate(rad, r) {
  rad -= Math.PI / 2;
  return {
    x: r * Math.cos(rad),
    y: r * Math.sin(rad)
  };
}
function executeShifts(node) {
  const children = node.children;
  let n = children.length;
  let shift = 0;
  let change = 0;
  while (--n >= 0) {
    const child = children[n];
    child.hierNode.prelim += shift;
    child.hierNode.modifier += shift;
    change += child.hierNode.change;
    shift += child.hierNode.shift + change;
  }
}
function apportion(subtreeV, subtreeW, ancestor, separation2) {
  if (subtreeW) {
    let nodeOutRight = subtreeV;
    let nodeInRight = subtreeV;
    let nodeOutLeft = nodeInRight.parentNode.children[0];
    let nodeInLeft = subtreeW;
    let sumOutRight = nodeOutRight.hierNode.modifier;
    let sumInRight = nodeInRight.hierNode.modifier;
    let sumOutLeft = nodeOutLeft.hierNode.modifier;
    let sumInLeft = nodeInLeft.hierNode.modifier;
    while (nodeInLeft = nextRight(nodeInLeft), nodeInRight = nextLeft(nodeInRight), nodeInLeft && nodeInRight) {
      nodeOutRight = nextRight(nodeOutRight);
      nodeOutLeft = nextLeft(nodeOutLeft);
      nodeOutRight.hierNode.ancestor = subtreeV;
      const shift = nodeInLeft.hierNode.prelim + sumInLeft - nodeInRight.hierNode.prelim - sumInRight + separation2(nodeInLeft, nodeInRight);
      if (shift > 0) {
        moveSubtree(nextAncestor(nodeInLeft, subtreeV, ancestor), subtreeV, shift);
        sumInRight += shift;
        sumOutRight += shift;
      }
      sumInLeft += nodeInLeft.hierNode.modifier;
      sumInRight += nodeInRight.hierNode.modifier;
      sumOutRight += nodeOutRight.hierNode.modifier;
      sumOutLeft += nodeOutLeft.hierNode.modifier;
    }
    if (nodeInLeft && !nextRight(nodeOutRight)) {
      nodeOutRight.hierNode.thread = nodeInLeft;
      nodeOutRight.hierNode.modifier += sumInLeft - sumOutRight;
    }
    if (nodeInRight && !nextLeft(nodeOutLeft)) {
      nodeOutLeft.hierNode.thread = nodeInRight;
      nodeOutLeft.hierNode.modifier += sumInRight - sumOutLeft;
      ancestor = subtreeV;
    }
  }
  return ancestor;
}
function nextRight(node) {
  const children = node.children;
  return children.length && node.isExpand ? children[children.length - 1] : node.hierNode.thread;
}
function nextLeft(node) {
  const children = node.children;
  return children.length && node.isExpand ? children[0] : node.hierNode.thread;
}
function nextAncestor(nodeInLeft, node, ancestor) {
  return nodeInLeft.hierNode.ancestor.parentNode === node.parentNode ? nodeInLeft.hierNode.ancestor : ancestor;
}
function moveSubtree(wl, wr, shift) {
  const change = shift / (wr.hierNode.i - wl.hierNode.i);
  wr.hierNode.change -= change;
  wr.hierNode.shift += shift;
  wr.hierNode.modifier += shift;
  wr.hierNode.prelim += shift;
  wl.hierNode.change += change;
}
function defaultSeparation(node1, node2) {
  return node1.parentNode === node2.parentNode ? 1 : 2;
}

// src/chart/tree/TreeView.ts
var TreeEdgeShape = class {
  constructor() {
    this.parentPoint = [];
    this.childPoints = [];
  }
};
var TreePath = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultStyle() {
    return {
      stroke: tokens_default.color.neutral99,
      fill: null
    };
  }
  getDefaultShape() {
    return new TreeEdgeShape();
  }
  buildPath(ctx, shape) {
    const childPoints = shape.childPoints;
    const childLen = childPoints.length;
    const parentPoint = shape.parentPoint;
    const firstChildPos = childPoints[0];
    const lastChildPos = childPoints[childLen - 1];
    if (childLen === 1) {
      ctx.moveTo(parentPoint[0], parentPoint[1]);
      ctx.lineTo(firstChildPos[0], firstChildPos[1]);
      return;
    }
    const orient = shape.orient;
    const forkDim = orient === "TB" || orient === "BT" ? 0 : 1;
    const otherDim = 1 - forkDim;
    const forkPosition = parsePercent2(shape.forkPosition, 1);
    const tmpPoint = [];
    tmpPoint[forkDim] = parentPoint[forkDim];
    tmpPoint[otherDim] = parentPoint[otherDim] + (lastChildPos[otherDim] - parentPoint[otherDim]) * forkPosition;
    ctx.moveTo(parentPoint[0], parentPoint[1]);
    ctx.lineTo(tmpPoint[0], tmpPoint[1]);
    ctx.moveTo(firstChildPos[0], firstChildPos[1]);
    tmpPoint[forkDim] = firstChildPos[forkDim];
    ctx.lineTo(tmpPoint[0], tmpPoint[1]);
    tmpPoint[forkDim] = lastChildPos[forkDim];
    ctx.lineTo(tmpPoint[0], tmpPoint[1]);
    ctx.lineTo(lastChildPos[0], lastChildPos[1]);
    for (let i = 1; i < childLen - 1; i++) {
      const point = childPoints[i];
      ctx.moveTo(point[0], point[1]);
      tmpPoint[forkDim] = point[forkDim];
      ctx.lineTo(tmpPoint[0], tmpPoint[1]);
    }
  }
};
var TreeView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = TreeView2.type;
    this._mainGroup = new Group_default();
  }
  init(ecModel, api2) {
    this._controller = new RoamController_default(api2.getZr());
    this._controllerHost = {
      target: this.group
    };
    this.group.add(this._mainGroup);
  }
  render(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    const layoutInfo = seriesModel.layoutInfo;
    const group = this._mainGroup;
    const layout14 = seriesModel.get("layout");
    if (layout14 === "radial") {
      group.x = layoutInfo.x + layoutInfo.width / 2;
      group.y = layoutInfo.y + layoutInfo.height / 2;
    } else {
      group.x = layoutInfo.x;
      group.y = layoutInfo.y;
    }
    this._updateViewCoordSys(seriesModel, api2);
    this._updateController(seriesModel, null, ecModel, api2);
    const oldData = this._data;
    data.diff(oldData).add(function(newIdx) {
      if (symbolNeedsDraw2(data, newIdx)) {
        updateNode(data, newIdx, null, group, seriesModel);
      }
    }).update(function(newIdx, oldIdx) {
      const symbolEl = oldData.getItemGraphicEl(oldIdx);
      if (!symbolNeedsDraw2(data, newIdx)) {
        symbolEl && removeNode(oldData, oldIdx, symbolEl, group, seriesModel);
        return;
      }
      updateNode(data, newIdx, symbolEl, group, seriesModel);
    }).remove(function(oldIdx) {
      const symbolEl = oldData.getItemGraphicEl(oldIdx);
      if (symbolEl) {
        removeNode(oldData, oldIdx, symbolEl, group, seriesModel);
      }
    }).execute();
    this._nodeScaleRatio = seriesModel.get("nodeScaleRatio");
    this._updateNodeAndLinkScale(seriesModel);
    if (seriesModel.get("expandAndCollapse") === true) {
      data.eachItemGraphicEl(function(el, dataIndex) {
        el.off("click").on("click", function() {
          api2.dispatchAction({
            type: "treeExpandAndCollapse",
            seriesId: seriesModel.id,
            dataIndex
          });
        });
      });
    }
    this._data = data;
  }
  _updateViewCoordSys(seriesModel, api2) {
    const data = seriesModel.getData();
    const points4 = [];
    data.each(function(idx) {
      const layout14 = data.getItemLayout(idx);
      if (layout14 && !isNaN(layout14.x) && !isNaN(layout14.y)) {
        points4.push([+layout14.x, +layout14.y]);
      }
    });
    const min3 = [];
    const max3 = [];
    fromPoints(points4, min3, max3);
    const oldMin = this._min;
    const oldMax = this._max;
    if (max3[0] - min3[0] === 0) {
      min3[0] = oldMin ? oldMin[0] : min3[0] - 1;
      max3[0] = oldMax ? oldMax[0] : max3[0] + 1;
    }
    if (max3[1] - min3[1] === 0) {
      min3[1] = oldMin ? oldMin[1] : min3[1] - 1;
      max3[1] = oldMax ? oldMax[1] : max3[1] + 1;
    }
    const viewCoordSys = seriesModel.coordinateSystem = new View_default(null, {api: api2, ecModel: seriesModel.ecModel});
    viewCoordSys.zoomLimit = seriesModel.get("scaleLimit");
    viewCoordSys.setBoundingRect(min3[0], min3[1], max3[0] - min3[0], max3[1] - min3[1]);
    viewCoordSys.setCenter(seriesModel.get("center"));
    viewCoordSys.setZoom(seriesModel.get("zoom"));
    this.group.attr({
      x: viewCoordSys.x,
      y: viewCoordSys.y,
      scaleX: viewCoordSys.scaleX,
      scaleY: viewCoordSys.scaleY
    });
    this._min = min3;
    this._max = max3;
  }
  _updateController(seriesModel, clipRect, ecModel, api2) {
    updateController(seriesModel, api2, this.group, this._controller, this._controllerHost, clipRect);
    this._controller.on("zoom", (e2) => {
      this._updateNodeAndLinkScale(seriesModel);
    });
  }
  _updateNodeAndLinkScale(seriesModel) {
    const data = seriesModel.getData();
    const nodeScale = this._getNodeGlobalScale(seriesModel);
    data.eachItemGraphicEl(function(el, idx) {
      el.setSymbolScale(nodeScale);
    });
  }
  _getNodeGlobalScale(seriesModel) {
    const coordSys = seriesModel.coordinateSystem;
    if (coordSys.type !== "view") {
      return 1;
    }
    const nodeScaleRatio = this._nodeScaleRatio;
    const groupZoom = coordSys.scaleX || 1;
    const roamZoom = coordSys.getZoom();
    const nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;
    return nodeScale / groupZoom;
  }
  dispose() {
    this._controller && this._controller.dispose();
    this._controllerHost = null;
  }
  remove() {
    this._mainGroup.removeAll();
    this._data = null;
  }
};
var TreeView = TreeView2;
TreeView.type = "tree";
function symbolNeedsDraw2(data, dataIndex) {
  const layout14 = data.getItemLayout(dataIndex);
  return layout14 && !isNaN(layout14.x) && !isNaN(layout14.y);
}
function updateNode(data, dataIndex, symbolEl, group, seriesModel) {
  const isInit = !symbolEl;
  const node = data.tree.getNodeByDataIndex(dataIndex);
  const itemModel = node.getModel();
  const visualColor = node.getVisual("style").fill;
  const symbolInnerColor = node.isExpand === false && node.children.length !== 0 ? visualColor : tokens_default.color.neutral00;
  const virtualRoot = data.tree.root;
  const source = node.parentNode === virtualRoot ? node : node.parentNode || node;
  const sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);
  const sourceLayout = source.getLayout();
  const sourceOldLayout = sourceSymbolEl ? {
    x: sourceSymbolEl.__oldX,
    y: sourceSymbolEl.__oldY,
    rawX: sourceSymbolEl.__radialOldRawX,
    rawY: sourceSymbolEl.__radialOldRawY
  } : sourceLayout;
  const targetLayout = node.getLayout();
  if (isInit) {
    symbolEl = new Symbol_default(data, dataIndex, null, {
      symbolInnerColor,
      useNameLabel: true
    });
    symbolEl.x = sourceOldLayout.x;
    symbolEl.y = sourceOldLayout.y;
  } else {
    symbolEl.updateData(data, dataIndex, null, {
      symbolInnerColor,
      useNameLabel: true
    });
  }
  symbolEl.__radialOldRawX = symbolEl.__radialRawX;
  symbolEl.__radialOldRawY = symbolEl.__radialRawY;
  symbolEl.__radialRawX = targetLayout.rawX;
  symbolEl.__radialRawY = targetLayout.rawY;
  group.add(symbolEl);
  data.setItemGraphicEl(dataIndex, symbolEl);
  symbolEl.__oldX = symbolEl.x;
  symbolEl.__oldY = symbolEl.y;
  updateProps(symbolEl, {
    x: targetLayout.x,
    y: targetLayout.y
  }, seriesModel);
  const symbolPath = symbolEl.getSymbolPath();
  if (seriesModel.get("layout") === "radial") {
    const realRoot = virtualRoot.children[0];
    const rootLayout = realRoot.getLayout();
    const length2 = realRoot.children.length;
    let rad;
    let isLeft;
    if (targetLayout.x === rootLayout.x && node.isExpand === true && realRoot.children.length) {
      const center3 = {
        x: (realRoot.children[0].getLayout().x + realRoot.children[length2 - 1].getLayout().x) / 2,
        y: (realRoot.children[0].getLayout().y + realRoot.children[length2 - 1].getLayout().y) / 2
      };
      rad = Math.atan2(center3.y - rootLayout.y, center3.x - rootLayout.x);
      if (rad < 0) {
        rad = Math.PI * 2 + rad;
      }
      isLeft = center3.x < rootLayout.x;
      if (isLeft) {
        rad = rad - Math.PI;
      }
    } else {
      rad = Math.atan2(targetLayout.y - rootLayout.y, targetLayout.x - rootLayout.x);
      if (rad < 0) {
        rad = Math.PI * 2 + rad;
      }
      if (node.children.length === 0 || node.children.length !== 0 && node.isExpand === false) {
        isLeft = targetLayout.x < rootLayout.x;
        if (isLeft) {
          rad = rad - Math.PI;
        }
      } else {
        isLeft = targetLayout.x > rootLayout.x;
        if (!isLeft) {
          rad = rad - Math.PI;
        }
      }
    }
    const textPosition = isLeft ? "left" : "right";
    const normalLabelModel = itemModel.getModel("label");
    const rotate2 = normalLabelModel.get("rotate");
    const labelRotateRadian = rotate2 * (Math.PI / 180);
    const textContent = symbolPath.getTextContent();
    if (textContent) {
      symbolPath.setTextConfig({
        position: normalLabelModel.get("position") || textPosition,
        rotation: rotate2 == null ? -rad : labelRotateRadian,
        origin: "center"
      });
      textContent.setStyle("verticalAlign", "middle");
    }
  }
  const focus = itemModel.get(["emphasis", "focus"]);
  const focusDataIndices = focus === "relative" ? concatArray(node.getAncestorsIndices(), node.getDescendantIndices()) : focus === "ancestor" ? node.getAncestorsIndices() : focus === "descendant" ? node.getDescendantIndices() : null;
  if (focusDataIndices) {
    getECData(symbolEl).focus = focusDataIndices;
  }
  drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group);
  if (symbolEl.__edge) {
    symbolEl.onHoverStateChange = function(toState) {
      if (toState !== "blur") {
        const parentEl = node.parentNode && data.getItemGraphicEl(node.parentNode.dataIndex);
        if (!(parentEl && parentEl.hoverState === HOVER_STATE_BLUR)) {
          setStatesFlag(symbolEl.__edge, toState);
        }
      }
    };
  }
}
function drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group) {
  const itemModel = node.getModel();
  const edgeShape = seriesModel.get("edgeShape");
  const layout14 = seriesModel.get("layout");
  const orient = seriesModel.getOrient();
  const curvature = seriesModel.get(["lineStyle", "curveness"]);
  const edgeForkPosition = seriesModel.get("edgeForkPosition");
  const lineStyle = itemModel.getModel("lineStyle").getLineStyle();
  let edge = symbolEl.__edge;
  if (edgeShape === "curve") {
    if (node.parentNode && node.parentNode !== virtualRoot) {
      if (!edge) {
        edge = symbolEl.__edge = new BezierCurve_default({
          shape: getEdgeShape(layout14, orient, curvature, sourceOldLayout, sourceOldLayout)
        });
      }
      updateProps(edge, {
        shape: getEdgeShape(layout14, orient, curvature, sourceLayout, targetLayout)
      }, seriesModel);
    }
  } else if (edgeShape === "polyline") {
    if (layout14 === "orthogonal") {
      if (node !== virtualRoot && node.children && node.children.length !== 0 && node.isExpand === true) {
        const children = node.children;
        const childPoints = [];
        for (let i = 0; i < children.length; i++) {
          const childLayout = children[i].getLayout();
          childPoints.push([childLayout.x, childLayout.y]);
        }
        if (!edge) {
          edge = symbolEl.__edge = new TreePath({
            shape: {
              parentPoint: [targetLayout.x, targetLayout.y],
              childPoints: [[targetLayout.x, targetLayout.y]],
              orient,
              forkPosition: edgeForkPosition
            }
          });
        }
        updateProps(edge, {
          shape: {
            parentPoint: [targetLayout.x, targetLayout.y],
            childPoints
          }
        }, seriesModel);
      }
    } else {
      if (true) {
        throw new Error("The polyline edgeShape can only be used in orthogonal layout");
      }
    }
  }
  if (edge && !(edgeShape === "polyline" && !node.isExpand)) {
    edge.useStyle(defaults({
      strokeNoScale: true,
      fill: null
    }, lineStyle));
    setStatesStylesFromModel(edge, itemModel, "lineStyle");
    setDefaultStateProxy(edge);
    group.add(edge);
  }
}
function removeNodeEdge(node, data, group, seriesModel, removeAnimationOpt) {
  const virtualRoot = data.tree.root;
  const {source, sourceLayout} = getSourceNode(virtualRoot, node);
  const symbolEl = data.getItemGraphicEl(node.dataIndex);
  if (!symbolEl) {
    return;
  }
  const sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);
  const sourceEdge = sourceSymbolEl.__edge;
  const edge = symbolEl.__edge || (source.isExpand === false || source.children.length === 1 ? sourceEdge : void 0);
  const edgeShape = seriesModel.get("edgeShape");
  const layoutOpt = seriesModel.get("layout");
  const orient = seriesModel.get("orient");
  const curvature = seriesModel.get(["lineStyle", "curveness"]);
  if (edge) {
    if (edgeShape === "curve") {
      removeElement(edge, {
        shape: getEdgeShape(layoutOpt, orient, curvature, sourceLayout, sourceLayout),
        style: {
          opacity: 0
        }
      }, seriesModel, {
        cb() {
          group.remove(edge);
        },
        removeOpt: removeAnimationOpt
      });
    } else if (edgeShape === "polyline" && seriesModel.get("layout") === "orthogonal") {
      removeElement(edge, {
        shape: {
          parentPoint: [sourceLayout.x, sourceLayout.y],
          childPoints: [[sourceLayout.x, sourceLayout.y]]
        },
        style: {
          opacity: 0
        }
      }, seriesModel, {
        cb() {
          group.remove(edge);
        },
        removeOpt: removeAnimationOpt
      });
    }
  }
}
function getSourceNode(virtualRoot, node) {
  let source = node.parentNode === virtualRoot ? node : node.parentNode || node;
  let sourceLayout;
  while (sourceLayout = source.getLayout(), sourceLayout == null) {
    source = source.parentNode === virtualRoot ? source : source.parentNode || source;
  }
  return {
    source,
    sourceLayout
  };
}
function removeNode(data, dataIndex, symbolEl, group, seriesModel) {
  const node = data.tree.getNodeByDataIndex(dataIndex);
  const virtualRoot = data.tree.root;
  const {sourceLayout} = getSourceNode(virtualRoot, node);
  const removeAnimationOpt = {
    duration: seriesModel.get("animationDurationUpdate"),
    easing: seriesModel.get("animationEasingUpdate")
  };
  removeElement(symbolEl, {
    x: sourceLayout.x + 1,
    y: sourceLayout.y + 1
  }, seriesModel, {
    cb() {
      group.remove(symbolEl);
      data.setItemGraphicEl(dataIndex, null);
    },
    removeOpt: removeAnimationOpt
  });
  symbolEl.fadeOut(null, data.hostModel, {
    fadeLabel: true,
    animation: removeAnimationOpt
  });
  node.children.forEach((childNode) => {
    removeNodeEdge(childNode, data, group, seriesModel, removeAnimationOpt);
  });
  removeNodeEdge(node, data, group, seriesModel, removeAnimationOpt);
}
function getEdgeShape(layoutOpt, orient, curvature, sourceLayout, targetLayout) {
  let cpx1;
  let cpy1;
  let cpx2;
  let cpy2;
  let x1;
  let x2;
  let y1;
  let y2;
  if (layoutOpt === "radial") {
    x1 = sourceLayout.rawX;
    y1 = sourceLayout.rawY;
    x2 = targetLayout.rawX;
    y2 = targetLayout.rawY;
    const radialCoor1 = radialCoordinate(x1, y1);
    const radialCoor2 = radialCoordinate(x1, y1 + (y2 - y1) * curvature);
    const radialCoor3 = radialCoordinate(x2, y2 + (y1 - y2) * curvature);
    const radialCoor4 = radialCoordinate(x2, y2);
    return {
      x1: radialCoor1.x || 0,
      y1: radialCoor1.y || 0,
      x2: radialCoor4.x || 0,
      y2: radialCoor4.y || 0,
      cpx1: radialCoor2.x || 0,
      cpy1: radialCoor2.y || 0,
      cpx2: radialCoor3.x || 0,
      cpy2: radialCoor3.y || 0
    };
  } else {
    x1 = sourceLayout.x;
    y1 = sourceLayout.y;
    x2 = targetLayout.x;
    y2 = targetLayout.y;
    if (orient === "LR" || orient === "RL") {
      cpx1 = x1 + (x2 - x1) * curvature;
      cpy1 = y1;
      cpx2 = x2 + (x1 - x2) * curvature;
      cpy2 = y2;
    }
    if (orient === "TB" || orient === "BT") {
      cpx1 = x1;
      cpy1 = y1 + (y2 - y1) * curvature;
      cpx2 = x2;
      cpy2 = y2 + (y1 - y2) * curvature;
    }
  }
  return {
    x1,
    y1,
    x2,
    y2,
    cpx1,
    cpy1,
    cpx2,
    cpy2
  };
}
var TreeView_default = TreeView;

// src/data/helper/linkSeriesData.ts
var inner9 = makeInner();
function linkSeriesData(opt) {
  const mainData = opt.mainData;
  let datas = opt.datas;
  if (!datas) {
    datas = {main: mainData};
    opt.datasAttr = {main: "data"};
  }
  opt.datas = opt.mainData = null;
  linkAll(mainData, datas, opt);
  each(datas, function(data) {
    each(mainData.TRANSFERABLE_METHODS, function(methodName) {
      data.wrapMethod(methodName, curry(transferInjection, opt));
    });
  });
  mainData.wrapMethod("cloneShallow", curry(cloneShallowInjection, opt));
  each(mainData.CHANGABLE_METHODS, function(methodName) {
    mainData.wrapMethod(methodName, curry(changeInjection, opt));
  });
  assert(datas[mainData.dataType] === mainData);
}
function transferInjection(opt, res) {
  if (isMainData(this)) {
    const datas = extend({}, inner9(this).datas);
    datas[this.dataType] = res;
    linkAll(res, datas, opt);
  } else {
    linkSingle(res, this.dataType, inner9(this).mainData, opt);
  }
  return res;
}
function changeInjection(opt, res) {
  opt.struct && opt.struct.update();
  return res;
}
function cloneShallowInjection(opt, res) {
  each(inner9(res).datas, function(data, dataType) {
    data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);
  });
  return res;
}
function getLinkedData(dataType) {
  const mainData = inner9(this).mainData;
  return dataType == null || mainData == null ? mainData : inner9(mainData).datas[dataType];
}
function getLinkedDataAll() {
  const mainData = inner9(this).mainData;
  return mainData == null ? [{data: mainData}] : map(keys(inner9(mainData).datas), function(type) {
    return {
      type,
      data: inner9(mainData).datas[type]
    };
  });
}
function isMainData(data) {
  return inner9(data).mainData === data;
}
function linkAll(mainData, datas, opt) {
  inner9(mainData).datas = {};
  each(datas, function(data, dataType) {
    linkSingle(data, dataType, mainData, opt);
  });
}
function linkSingle(data, dataType, mainData, opt) {
  inner9(mainData).datas[dataType] = data;
  inner9(data).mainData = mainData;
  data.dataType = dataType;
  if (opt.struct) {
    data[opt.structAttr] = opt.struct;
    opt.struct[opt.datasAttr[dataType]] = data;
  }
  data.getLinkedData = getLinkedData;
  data.getLinkedDataAll = getLinkedDataAll;
}
var linkSeriesData_default = linkSeriesData;

// src/data/Tree.ts
var TreeNode = class {
  constructor(name, hostTree) {
    this.depth = 0;
    this.height = 0;
    this.dataIndex = -1;
    this.children = [];
    this.viewChildren = [];
    this.isExpand = false;
    this.name = name || "";
    this.hostTree = hostTree;
  }
  isRemoved() {
    return this.dataIndex < 0;
  }
  eachNode(options, cb, context) {
    if (isFunction(options)) {
      context = cb;
      cb = options;
      options = null;
    }
    options = options || {};
    if (isString(options)) {
      options = {order: options};
    }
    const order = options.order || "preorder";
    const children = this[options.attr || "children"];
    let suppressVisitSub;
    order === "preorder" && (suppressVisitSub = cb.call(context, this));
    for (let i = 0; !suppressVisitSub && i < children.length; i++) {
      children[i].eachNode(options, cb, context);
    }
    order === "postorder" && cb.call(context, this);
  }
  updateDepthAndHeight(depth) {
    let height = 0;
    this.depth = depth;
    for (let i = 0; i < this.children.length; i++) {
      const child = this.children[i];
      child.updateDepthAndHeight(depth + 1);
      if (child.height > height) {
        height = child.height;
      }
    }
    this.height = height + 1;
  }
  getNodeById(id) {
    if (this.getId() === id) {
      return this;
    }
    for (let i = 0, children = this.children, len2 = children.length; i < len2; i++) {
      const res = children[i].getNodeById(id);
      if (res) {
        return res;
      }
    }
  }
  contains(node) {
    if (node === this) {
      return true;
    }
    for (let i = 0, children = this.children, len2 = children.length; i < len2; i++) {
      const res = children[i].contains(node);
      if (res) {
        return res;
      }
    }
  }
  getAncestors(includeSelf) {
    const ancestors = [];
    let node = includeSelf ? this : this.parentNode;
    while (node) {
      ancestors.push(node);
      node = node.parentNode;
    }
    ancestors.reverse();
    return ancestors;
  }
  getAncestorsIndices() {
    const indices = [];
    let currNode = this;
    while (currNode) {
      indices.push(currNode.dataIndex);
      currNode = currNode.parentNode;
    }
    indices.reverse();
    return indices;
  }
  getDescendantIndices() {
    const indices = [];
    this.eachNode((childNode) => {
      indices.push(childNode.dataIndex);
    });
    return indices;
  }
  getValue(dimension) {
    const data = this.hostTree.data;
    return data.getStore().get(data.getDimensionIndex(dimension || "value"), this.dataIndex);
  }
  setLayout(layout14, merge2) {
    this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout14, merge2);
  }
  getLayout() {
    return this.hostTree.data.getItemLayout(this.dataIndex);
  }
  getModel(path) {
    if (this.dataIndex < 0) {
      return;
    }
    const hostTree = this.hostTree;
    const itemModel = hostTree.data.getItemModel(this.dataIndex);
    return itemModel.getModel(path);
  }
  getLevelModel() {
    return (this.hostTree.levelModels || [])[this.depth];
  }
  setVisual(key, value) {
    this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value);
  }
  getVisual(key) {
    return this.hostTree.data.getItemVisual(this.dataIndex, key);
  }
  getRawIndex() {
    return this.hostTree.data.getRawIndex(this.dataIndex);
  }
  getId() {
    return this.hostTree.data.getId(this.dataIndex);
  }
  getChildIndex() {
    if (this.parentNode) {
      const children = this.parentNode.children;
      for (let i = 0; i < children.length; ++i) {
        if (children[i] === this) {
          return i;
        }
      }
      return -1;
    }
    return -1;
  }
  isAncestorOf(node) {
    let parent = node.parentNode;
    while (parent) {
      if (parent === this) {
        return true;
      }
      parent = parent.parentNode;
    }
    return false;
  }
  isDescendantOf(node) {
    return node !== this && node.isAncestorOf(this);
  }
};
var Tree = class {
  constructor(hostModel) {
    this.type = "tree";
    this._nodes = [];
    this.hostModel = hostModel;
  }
  eachNode(options, cb, context) {
    this.root.eachNode(options, cb, context);
  }
  getNodeByDataIndex(dataIndex) {
    const rawIndex = this.data.getRawIndex(dataIndex);
    return this._nodes[rawIndex];
  }
  getNodeById(name) {
    return this.root.getNodeById(name);
  }
  update() {
    const data = this.data;
    const nodes = this._nodes;
    for (let i = 0, len2 = nodes.length; i < len2; i++) {
      nodes[i].dataIndex = -1;
    }
    for (let i = 0, len2 = data.count(); i < len2; i++) {
      nodes[data.getRawIndex(i)].dataIndex = i;
    }
  }
  clearLayouts() {
    this.data.clearItemLayouts();
  }
  static createTree(dataRoot, hostModel, beforeLink) {
    const tree = new Tree(hostModel);
    const listData = [];
    let dimMax = 1;
    buildHierarchy(dataRoot);
    function buildHierarchy(dataNode, parentNode2) {
      const value = dataNode.value;
      dimMax = Math.max(dimMax, isArray(value) ? value.length : 1);
      listData.push(dataNode);
      const node = new TreeNode(convertOptionIdName(dataNode.name, ""), tree);
      parentNode2 ? addChild(node, parentNode2) : tree.root = node;
      tree._nodes.push(node);
      const children = dataNode.children;
      if (children) {
        for (let i = 0; i < children.length; i++) {
          buildHierarchy(children[i], node);
        }
      }
    }
    tree.root.updateDepthAndHeight(0);
    const {dimensions} = prepareSeriesDataSchema(listData, {
      coordDimensions: ["value"],
      dimensionsCount: dimMax
    });
    const list = new SeriesData_default(dimensions, hostModel);
    list.initData(listData);
    beforeLink && beforeLink(list);
    linkSeriesData_default({
      mainData: list,
      struct: tree,
      structAttr: "tree"
    });
    tree.update();
    return tree;
  }
};
function addChild(child, node) {
  const children = node.children;
  if (child.parentNode === node) {
    return;
  }
  children.push(child);
  child.parentNode = node;
}
var Tree_default = Tree;

// src/chart/helper/treeHelper.ts
function retrieveTargetInfo(payload, validPayloadTypes, seriesModel) {
  if (payload && indexOf(validPayloadTypes, payload.type) >= 0) {
    const root = seriesModel.getData().tree.root;
    let targetNode = payload.targetNode;
    if (isString(targetNode)) {
      targetNode = root.getNodeById(targetNode);
    }
    if (targetNode && root.contains(targetNode)) {
      return {
        node: targetNode
      };
    }
    const targetNodeId = payload.targetNodeId;
    if (targetNodeId != null && (targetNode = root.getNodeById(targetNodeId))) {
      return {
        node: targetNode
      };
    }
  }
}
function getPathToRoot(node) {
  const path = [];
  while (node) {
    node = node.parentNode;
    node && path.push(node);
  }
  return path.reverse();
}
function aboveViewRoot(viewRoot, node) {
  const viewPath = getPathToRoot(viewRoot);
  return indexOf(viewPath, node) >= 0;
}
function wrapTreePathInfo(node, seriesModel) {
  const treePathInfo = [];
  while (node) {
    const nodeDataIndex = node.dataIndex;
    treePathInfo.push({
      name: node.name,
      dataIndex: nodeDataIndex,
      value: seriesModel.getRawValue(nodeDataIndex)
    });
    node = node.parentNode;
  }
  treePathInfo.reverse();
  return treePathInfo;
}

// src/chart/tree/TreeSeries.ts
var TreeSeriesModel = class extends Series_default {
  constructor() {
    super(...arguments);
    this.hasSymbolVisual = true;
    this.ignoreStyleOnData = true;
  }
  getInitialData(option) {
    const root = {
      name: option.name,
      children: option.data
    };
    const leaves = option.leaves || {};
    const leavesModel = new Model_default(leaves, this, this.ecModel);
    const tree = Tree_default.createTree(root, this, beforeLink);
    function beforeLink(nodeData) {
      nodeData.wrapMethod("getItemModel", function(model, idx) {
        const node = tree.getNodeByDataIndex(idx);
        if (!(node && node.children.length && node.isExpand)) {
          model.parentModel = leavesModel;
        }
        return model;
      });
    }
    let treeDepth = 0;
    tree.eachNode("preorder", function(node) {
      if (node.depth > treeDepth) {
        treeDepth = node.depth;
      }
    });
    const expandAndCollapse = option.expandAndCollapse;
    const expandTreeDepth = expandAndCollapse && option.initialTreeDepth >= 0 ? option.initialTreeDepth : treeDepth;
    tree.root.eachNode("preorder", function(node) {
      const item = node.hostTree.data.getRawDataItem(node.dataIndex);
      node.isExpand = item && item.collapsed != null ? !item.collapsed : node.depth <= expandTreeDepth;
    });
    return tree.data;
  }
  getOrient() {
    let orient = this.get("orient");
    if (orient === "horizontal") {
      orient = "LR";
    } else if (orient === "vertical") {
      orient = "TB";
    }
    return orient;
  }
  setZoom(zoom) {
    this.option.zoom = zoom;
  }
  setCenter(center3) {
    this.option.center = center3;
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    const tree = this.getData().tree;
    const realRoot = tree.root.children[0];
    let node = tree.getNodeByDataIndex(dataIndex);
    const value = node.getValue();
    let name = node.name;
    while (node && node !== realRoot) {
      name = node.parentNode.name + "." + name;
      node = node.parentNode;
    }
    return createTooltipMarkup("nameValue", {
      name,
      value,
      noValue: isNaN(value) || value == null
    });
  }
  getDataParams(dataIndex) {
    const params = super.getDataParams.apply(this, arguments);
    const node = this.getData().tree.getNodeByDataIndex(dataIndex);
    params.treeAncestors = wrapTreePathInfo(node, this);
    params.collapsed = !node.isExpand;
    return params;
  }
};
TreeSeriesModel.type = "series.tree";
TreeSeriesModel.layoutMode = "box";
TreeSeriesModel.defaultOption = {
  z: 2,
  coordinateSystemUsage: "box",
  left: "12%",
  top: "12%",
  right: "12%",
  bottom: "12%",
  layout: "orthogonal",
  edgeShape: "curve",
  edgeForkPosition: "50%",
  roam: false,
  roamTrigger: "global",
  nodeScaleRatio: 0.4,
  center: null,
  zoom: 1,
  orient: "LR",
  symbol: "emptyCircle",
  symbolSize: 7,
  expandAndCollapse: true,
  initialTreeDepth: 2,
  lineStyle: {
    color: tokens_default.color.borderTint,
    width: 1.5,
    curveness: 0.5
  },
  itemStyle: {
    color: "lightsteelblue",
    borderWidth: 1.5
  },
  label: {
    show: true
  },
  animationEasing: "linear",
  animationDuration: 700,
  animationDurationUpdate: 500
};
var TreeSeries_default = TreeSeriesModel;

// src/chart/tree/traversalHelper.ts
function eachAfter(root, callback, separation2) {
  const nodes = [root];
  const next = [];
  let node;
  while (node = nodes.pop()) {
    next.push(node);
    if (node.isExpand) {
      const children = node.children;
      if (children.length) {
        for (let i = 0; i < children.length; i++) {
          nodes.push(children[i]);
        }
      }
    }
  }
  while (node = next.pop()) {
    callback(node, separation2);
  }
}
function eachBefore(root, callback) {
  const nodes = [root];
  let node;
  while (node = nodes.pop()) {
    callback(node);
    if (node.isExpand) {
      const children = node.children;
      if (children.length) {
        for (let i = children.length - 1; i >= 0; i--) {
          nodes.push(children[i]);
        }
      }
    }
  }
}

// src/chart/tree/treeLayout.ts
function treeLayout(ecModel, api2) {
  ecModel.eachSeriesByType("tree", function(seriesModel) {
    commonLayout(seriesModel, api2);
  });
}
function commonLayout(seriesModel, api2) {
  const refContainer = createBoxLayoutReference(seriesModel, api2).refContainer;
  const layoutInfo = getLayoutRect(seriesModel.getBoxLayoutParams(), refContainer);
  seriesModel.layoutInfo = layoutInfo;
  const layout14 = seriesModel.get("layout");
  let width = 0;
  let height = 0;
  let separation2 = null;
  if (layout14 === "radial") {
    width = 2 * Math.PI;
    height = Math.min(layoutInfo.height, layoutInfo.width) / 2;
    separation2 = separation(function(node1, node2) {
      return (node1.parentNode === node2.parentNode ? 1 : 2) / node1.depth;
    });
  } else {
    width = layoutInfo.width;
    height = layoutInfo.height;
    separation2 = separation();
  }
  const virtualRoot = seriesModel.getData().tree.root;
  const realRoot = virtualRoot.children[0];
  if (realRoot) {
    init3(virtualRoot);
    eachAfter(realRoot, firstWalk, separation2);
    virtualRoot.hierNode.modifier = -realRoot.hierNode.prelim;
    eachBefore(realRoot, secondWalk);
    let left = realRoot;
    let right = realRoot;
    let bottom = realRoot;
    eachBefore(realRoot, function(node) {
      const x = node.getLayout().x;
      if (x < left.getLayout().x) {
        left = node;
      }
      if (x > right.getLayout().x) {
        right = node;
      }
      if (node.depth > bottom.depth) {
        bottom = node;
      }
    });
    const delta = left === right ? 1 : separation2(left, right) / 2;
    const tx = delta - left.getLayout().x;
    let kx = 0;
    let ky = 0;
    let coorX = 0;
    let coorY = 0;
    if (layout14 === "radial") {
      kx = width / (right.getLayout().x + delta + tx);
      ky = height / (bottom.depth - 1 || 1);
      eachBefore(realRoot, function(node) {
        coorX = (node.getLayout().x + tx) * kx;
        coorY = (node.depth - 1) * ky;
        const finalCoor = radialCoordinate(coorX, coorY);
        node.setLayout({x: finalCoor.x, y: finalCoor.y, rawX: coorX, rawY: coorY}, true);
      });
    } else {
      const orient = seriesModel.getOrient();
      if (orient === "RL" || orient === "LR") {
        ky = height / (right.getLayout().x + delta + tx);
        kx = width / (bottom.depth - 1 || 1);
        eachBefore(realRoot, function(node) {
          coorY = (node.getLayout().x + tx) * ky;
          coorX = orient === "LR" ? (node.depth - 1) * kx : width - (node.depth - 1) * kx;
          node.setLayout({x: coorX, y: coorY}, true);
        });
      } else if (orient === "TB" || orient === "BT") {
        kx = width / (right.getLayout().x + delta + tx);
        ky = height / (bottom.depth - 1 || 1);
        eachBefore(realRoot, function(node) {
          coorX = (node.getLayout().x + tx) * kx;
          coorY = orient === "TB" ? (node.depth - 1) * ky : height - (node.depth - 1) * ky;
          node.setLayout({x: coorX, y: coorY}, true);
        });
      }
    }
  }
}

// src/chart/tree/treeVisual.ts
function treeVisual(ecModel) {
  ecModel.eachSeriesByType("tree", function(seriesModel) {
    const data = seriesModel.getData();
    const tree = data.tree;
    tree.eachNode(function(node) {
      const model = node.getModel();
      const style = model.getModel("itemStyle").getItemStyle();
      const existsStyle = data.ensureUniqueItemVisual(node.dataIndex, "style");
      extend(existsStyle, style);
    });
  });
}

// src/chart/tree/treeAction.ts
function installTreeAction(registers) {
  registers.registerAction({
    type: "treeExpandAndCollapse",
    event: "treeExpandAndCollapse",
    update: "update"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "tree",
      query: payload
    }, function(seriesModel) {
      const dataIndex = payload.dataIndex;
      const tree = seriesModel.getData().tree;
      const node = tree.getNodeByDataIndex(dataIndex);
      node.isExpand = !node.isExpand;
    });
  });
  registers.registerAction({
    type: "treeRoam",
    event: "treeRoam",
    update: "none"
  }, function(payload, ecModel, api2) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "tree",
      query: payload
    }, function(seriesModel) {
      const coordSys = seriesModel.coordinateSystem;
      const res = updateCenterAndZoomInAction(coordSys, payload, seriesModel.get("scaleLimit"));
      seriesModel.setCenter(res.center);
      seriesModel.setZoom(res.zoom);
    });
  });
}

// src/chart/tree/install.ts
function install12(registers) {
  registers.registerChartView(TreeView_default);
  registers.registerSeriesModel(TreeSeries_default);
  registers.registerLayout(treeLayout);
  registers.registerVisual(treeVisual);
  installTreeAction(registers);
}

// src/chart/treemap/treemapAction.ts
var actionTypes = [
  "treemapZoomToNode",
  "treemapRender",
  "treemapMove"
];
function installTreemapAction(registers) {
  for (let i = 0; i < actionTypes.length; i++) {
    registers.registerAction({
      type: actionTypes[i],
      update: "updateView"
    }, noop);
  }
  registers.registerAction({type: "treemapRootToNode", update: "updateView"}, function(payload, ecModel) {
    ecModel.eachComponent({mainType: "series", subType: "treemap", query: payload}, handleRootToNode);
    function handleRootToNode(model, index) {
      const types = ["treemapZoomToNode", "treemapRootToNode"];
      const targetInfo = retrieveTargetInfo(payload, types, model);
      if (targetInfo) {
        const originViewRoot = model.getViewRoot();
        if (originViewRoot) {
          payload.direction = aboveViewRoot(originViewRoot, targetInfo.node) ? "rollUp" : "drillDown";
        }
        model.resetViewRoot(targetInfo.node);
      }
    }
  });
}

// src/chart/helper/enableAriaDecalForTree.ts
function enableAriaDecalForTree(seriesModel) {
  const data = seriesModel.getData();
  const tree = data.tree;
  const decalPaletteScope2 = {};
  tree.eachNode((node) => {
    let current = node;
    while (current && current.depth > 1) {
      current = current.parentNode;
    }
    const decal = getDecalFromPalette(seriesModel.ecModel, current.name || current.dataIndex + "", decalPaletteScope2);
    node.setVisual("decal", decal);
  });
}

// src/chart/treemap/TreemapSeries.ts
var TreemapSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = TreemapSeriesModel2.type;
    this.preventUsingHoverLayer = true;
  }
  getInitialData(option, ecModel) {
    const root = {
      name: option.name,
      children: option.data
    };
    completeTreeValue(root);
    let levels = option.levels || [];
    const designatedVisualItemStyle = this.designatedVisualItemStyle = {};
    const designatedVisualModel = new Model_default({itemStyle: designatedVisualItemStyle}, this, ecModel);
    levels = option.levels = setDefault(levels, ecModel);
    const levelModels = map(levels || [], function(levelDefine) {
      return new Model_default(levelDefine, designatedVisualModel, ecModel);
    }, this);
    const tree = Tree_default.createTree(root, this, beforeLink);
    function beforeLink(nodeData) {
      nodeData.wrapMethod("getItemModel", function(model, idx) {
        const node = tree.getNodeByDataIndex(idx);
        const levelModel = node ? levelModels[node.depth] : null;
        model.parentModel = levelModel || designatedVisualModel;
        return model;
      });
    }
    return tree.data;
  }
  optionUpdated() {
    this.resetViewRoot();
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    const data = this.getData();
    const value = this.getRawValue(dataIndex);
    const name = data.getName(dataIndex);
    return createTooltipMarkup("nameValue", {name, value});
  }
  getDataParams(dataIndex) {
    const params = super.getDataParams.apply(this, arguments);
    const node = this.getData().tree.getNodeByDataIndex(dataIndex);
    params.treeAncestors = wrapTreePathInfo(node, this);
    params.treePathInfo = params.treeAncestors;
    return params;
  }
  setLayoutInfo(layoutInfo) {
    this.layoutInfo = this.layoutInfo || {};
    extend(this.layoutInfo, layoutInfo);
  }
  mapIdToIndex(id) {
    let idIndexMap = this._idIndexMap;
    if (!idIndexMap) {
      idIndexMap = this._idIndexMap = createHashMap();
      this._idIndexMapCount = 0;
    }
    let index = idIndexMap.get(id);
    if (index == null) {
      idIndexMap.set(id, index = this._idIndexMapCount++);
    }
    return index;
  }
  getViewRoot() {
    return this._viewRoot;
  }
  resetViewRoot(viewRoot) {
    viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
    const root = this.getRawData().tree.root;
    if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {
      this._viewRoot = root;
    }
  }
  enableAriaDecal() {
    enableAriaDecalForTree(this);
  }
};
var TreemapSeriesModel = TreemapSeriesModel2;
TreemapSeriesModel.type = "series.treemap";
TreemapSeriesModel.layoutMode = "box";
TreemapSeriesModel.defaultOption = {
  progressive: 0,
  coordinateSystemUsage: "box",
  left: tokens_default.size.l,
  top: tokens_default.size.xxxl,
  right: tokens_default.size.l,
  bottom: tokens_default.size.xxxl,
  sort: true,
  clipWindow: "origin",
  squareRatio: 0.5 * (1 + Math.sqrt(5)),
  leafDepth: null,
  drillDownIcon: "\u25B6",
  zoomToNodeRatio: 0.32 * 0.32,
  scaleLimit: {
    max: 5,
    min: 0.2
  },
  roam: true,
  roamTrigger: "global",
  nodeClick: "zoomToNode",
  animation: true,
  animationDurationUpdate: 900,
  animationEasing: "quinticInOut",
  breadcrumb: {
    show: true,
    height: 22,
    left: "center",
    bottom: tokens_default.size.m,
    emptyItemWidth: 25,
    itemStyle: {
      color: tokens_default.color.backgroundShade,
      textStyle: {
        color: tokens_default.color.secondary
      }
    },
    emphasis: {
      itemStyle: {
        color: tokens_default.color.background
      }
    }
  },
  label: {
    show: true,
    distance: 0,
    padding: 5,
    position: "inside",
    color: tokens_default.color.neutral00,
    overflow: "truncate"
  },
  upperLabel: {
    show: false,
    position: [0, "50%"],
    height: 20,
    overflow: "truncate",
    verticalAlign: "middle"
  },
  itemStyle: {
    color: null,
    colorAlpha: null,
    colorSaturation: null,
    borderWidth: 0,
    gapWidth: 0,
    borderColor: tokens_default.color.neutral00,
    borderColorSaturation: null
  },
  emphasis: {
    upperLabel: {
      show: true,
      position: [0, "50%"],
      overflow: "truncate",
      verticalAlign: "middle"
    }
  },
  visualDimension: 0,
  visualMin: null,
  visualMax: null,
  color: [],
  colorAlpha: null,
  colorSaturation: null,
  colorMappingBy: "index",
  visibleMin: 10,
  childrenVisibleMin: null,
  levels: []
};
function completeTreeValue(dataNode) {
  let sum2 = 0;
  each(dataNode.children, function(child) {
    completeTreeValue(child);
    let childValue = child.value;
    isArray(childValue) && (childValue = childValue[0]);
    sum2 += childValue;
  });
  let thisValue = dataNode.value;
  if (isArray(thisValue)) {
    thisValue = thisValue[0];
  }
  if (thisValue == null || isNaN(thisValue)) {
    thisValue = sum2;
  }
  if (thisValue < 0) {
    thisValue = 0;
  }
  isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
}
function setDefault(levels, ecModel) {
  const globalColorList = normalizeToArray(ecModel.get("color"));
  const globalDecalList = normalizeToArray(ecModel.get(["aria", "decal", "decals"]));
  if (!globalColorList) {
    return;
  }
  levels = levels || [];
  let hasColorDefine;
  let hasDecalDefine;
  each(levels, function(levelDefine) {
    const model = new Model_default(levelDefine);
    const modelColor = model.get("color");
    const modelDecal = model.get("decal");
    if (model.get(["itemStyle", "color"]) || modelColor && modelColor !== "none") {
      hasColorDefine = true;
    }
    if (model.get(["itemStyle", "decal"]) || modelDecal && modelDecal !== "none") {
      hasDecalDefine = true;
    }
  });
  const level0 = levels[0] || (levels[0] = {});
  if (!hasColorDefine) {
    level0.color = globalColorList.slice();
  }
  if (!hasDecalDefine && globalDecalList) {
    level0.decal = globalDecalList.slice();
  }
  return levels;
}
var TreemapSeries_default = TreemapSeriesModel;

// src/chart/treemap/Breadcrumb.ts
var TEXT_PADDING = 8;
var ITEM_GAP = 8;
var ARRAY_LENGTH = 5;
var Breadcrumb = class {
  constructor(containerGroup) {
    this.group = new Group_default();
    containerGroup.add(this.group);
  }
  render(seriesModel, api2, targetNode, onSelect) {
    const model = seriesModel.getModel("breadcrumb");
    const thisGroup = this.group;
    thisGroup.removeAll();
    if (!model.get("show") || !targetNode) {
      return;
    }
    const normalStyleModel = model.getModel("itemStyle");
    const emphasisModel = model.getModel("emphasis");
    const textStyleModel = normalStyleModel.getModel("textStyle");
    const emphasisTextStyleModel = emphasisModel.getModel(["itemStyle", "textStyle"]);
    const refContainer = createBoxLayoutReference(seriesModel, api2).refContainer;
    const boxLayoutParams = {
      left: model.get("left"),
      right: model.get("right"),
      top: model.get("top"),
      bottom: model.get("bottom")
    };
    const layoutParam = {
      emptyItemWidth: model.get("emptyItemWidth"),
      totalWidth: 0,
      renderList: []
    };
    const availableSize = getLayoutRect(boxLayoutParams, refContainer);
    this._prepare(targetNode, layoutParam, textStyleModel);
    this._renderContent(seriesModel, layoutParam, availableSize, normalStyleModel, emphasisModel, textStyleModel, emphasisTextStyleModel, onSelect);
    positionElement(thisGroup, boxLayoutParams, refContainer);
  }
  _prepare(targetNode, layoutParam, textStyleModel) {
    for (let node = targetNode; node; node = node.parentNode) {
      const text = convertOptionIdName(node.getModel().get("name"), "");
      const textRect = textStyleModel.getTextRect(text);
      const itemWidth = Math.max(textRect.width + TEXT_PADDING * 2, layoutParam.emptyItemWidth);
      layoutParam.totalWidth += itemWidth + ITEM_GAP;
      layoutParam.renderList.push({
        node,
        text,
        width: itemWidth
      });
    }
  }
  _renderContent(seriesModel, layoutParam, availableSize, normalStyleModel, emphasisModel, textStyleModel, emphasisTextStyleModel, onSelect) {
    let lastX = 0;
    const emptyItemWidth = layoutParam.emptyItemWidth;
    const height = seriesModel.get(["breadcrumb", "height"]);
    let totalWidth = layoutParam.totalWidth;
    const renderList = layoutParam.renderList;
    const emphasisItemStyle = emphasisModel.getModel("itemStyle").getItemStyle();
    for (let i = renderList.length - 1; i >= 0; i--) {
      const item = renderList[i];
      const itemNode = item.node;
      let itemWidth = item.width;
      let text = item.text;
      if (totalWidth > availableSize.width) {
        totalWidth -= itemWidth - emptyItemWidth;
        itemWidth = emptyItemWidth;
        text = null;
      }
      const el = new Polygon_default({
        shape: {
          points: makeItemPoints(lastX, 0, itemWidth, height, i === renderList.length - 1, i === 0)
        },
        style: defaults(normalStyleModel.getItemStyle(), {
          lineJoin: "bevel"
        }),
        textContent: new Text_default({
          style: createTextStyle(textStyleModel, {text})
        }),
        textConfig: {
          position: "inside"
        },
        z2: Z2_EMPHASIS_LIFT * 1e4,
        onclick: curry(onSelect, itemNode)
      });
      el.disableLabelAnimation = true;
      el.getTextContent().ensureState("emphasis").style = createTextStyle(emphasisTextStyleModel, {text});
      el.ensureState("emphasis").style = emphasisItemStyle;
      toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
      this.group.add(el);
      packEventData(el, seriesModel, itemNode);
      lastX += itemWidth + ITEM_GAP;
    }
  }
  remove() {
    this.group.removeAll();
  }
};
function makeItemPoints(x, y, itemWidth, itemHeight, head, tail) {
  const points4 = [
    [head ? x : x - ARRAY_LENGTH, y],
    [x + itemWidth, y],
    [x + itemWidth, y + itemHeight],
    [head ? x : x - ARRAY_LENGTH, y + itemHeight]
  ];
  !tail && points4.splice(2, 0, [x + itemWidth + ARRAY_LENGTH, y + itemHeight / 2]);
  !head && points4.push([x, y + itemHeight / 2]);
  return points4;
}
function packEventData(el, seriesModel, itemNode) {
  getECData(el).eventData = {
    componentType: "series",
    componentSubType: "treemap",
    componentIndex: seriesModel.componentIndex,
    seriesIndex: seriesModel.seriesIndex,
    seriesName: seriesModel.name,
    seriesType: "treemap",
    selfType: "breadcrumb",
    nodeData: {
      dataIndex: itemNode && itemNode.dataIndex,
      name: itemNode && itemNode.name
    },
    treePathInfo: itemNode && wrapTreePathInfo(itemNode, seriesModel)
  };
}
var Breadcrumb_default = Breadcrumb;

// src/util/animation.ts
var AnimationWrap = class {
  constructor() {
    this._storage = [];
    this._elExistsMap = {};
  }
  add(el, target, duration, delay, easing) {
    if (this._elExistsMap[el.id]) {
      return false;
    }
    this._elExistsMap[el.id] = true;
    this._storage.push({
      el,
      target,
      duration,
      delay,
      easing
    });
    return true;
  }
  finished(callback) {
    this._finishedCallback = callback;
    return this;
  }
  start() {
    let count2 = this._storage.length;
    const checkTerminate = () => {
      count2--;
      if (count2 <= 0) {
        this._storage.length = 0;
        this._elExistsMap = {};
        this._finishedCallback && this._finishedCallback();
      }
    };
    for (let i = 0, len2 = this._storage.length; i < len2; i++) {
      const item = this._storage[i];
      item.el.animateTo(item.target, {
        duration: item.duration,
        delay: item.delay,
        easing: item.easing,
        setToFinal: true,
        done: checkTerminate,
        aborted: checkTerminate
      });
    }
    return this;
  }
};
function createWrap() {
  return new AnimationWrap();
}

// src/chart/treemap/TreemapView.ts
var Group2 = Group_default;
var Rect2 = Rect_default;
var DRAG_THRESHOLD = 3;
var PATH_LABEL_NOAMAL = "label";
var PATH_UPPERLABEL_NORMAL = "upperLabel";
var Z2_BASE = Z2_EMPHASIS_LIFT * 10;
var Z2_BG = Z2_EMPHASIS_LIFT * 2;
var Z2_CONTENT = Z2_EMPHASIS_LIFT * 3;
var getStateItemStyle = makeStyleMapper([
  ["fill", "color"],
  ["stroke", "strokeColor"],
  ["lineWidth", "strokeWidth"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"]
]);
var getItemStyleNormal = function(model) {
  const itemStyle = getStateItemStyle(model);
  itemStyle.stroke = itemStyle.fill = itemStyle.lineWidth = null;
  return itemStyle;
};
var inner10 = makeInner();
var TreemapView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = TreemapView2.type;
    this._state = "ready";
    this._storage = createStorage();
  }
  render(seriesModel, ecModel, api2, payload) {
    const models = ecModel.findComponents({
      mainType: "series",
      subType: "treemap",
      query: payload
    });
    if (indexOf(models, seriesModel) < 0) {
      return;
    }
    this.seriesModel = seriesModel;
    this.api = api2;
    this.ecModel = ecModel;
    const types = ["treemapZoomToNode", "treemapRootToNode"];
    const targetInfo = retrieveTargetInfo(payload, types, seriesModel);
    const payloadType = payload && payload.type;
    const layoutInfo = seriesModel.layoutInfo;
    const isInit = !this._oldTree;
    const thisStorage = this._storage;
    const reRoot = payloadType === "treemapRootToNode" && targetInfo && thisStorage ? {
      rootNodeGroup: thisStorage.nodeGroup[targetInfo.node.getRawIndex()],
      direction: payload.direction
    } : null;
    const containerGroup = this._giveContainerGroup(layoutInfo);
    const hasAnimation = seriesModel.get("animation");
    const renderResult = this._doRender(containerGroup, seriesModel, reRoot);
    hasAnimation && !isInit && (!payloadType || payloadType === "treemapZoomToNode" || payloadType === "treemapRootToNode") ? this._doAnimation(containerGroup, renderResult, seriesModel, reRoot) : renderResult.renderFinally();
    this._resetController(api2);
    this._renderBreadcrumb(seriesModel, api2, targetInfo);
  }
  _giveContainerGroup(layoutInfo) {
    let containerGroup = this._containerGroup;
    if (!containerGroup) {
      containerGroup = this._containerGroup = new Group2();
      this._initEvents(containerGroup);
      this.group.add(containerGroup);
    }
    containerGroup.x = layoutInfo.x;
    containerGroup.y = layoutInfo.y;
    return containerGroup;
  }
  _doRender(containerGroup, seriesModel, reRoot) {
    const thisTree = seriesModel.getData().tree;
    const oldTree = this._oldTree;
    const lastsForAnimation = createStorage();
    const thisStorage = createStorage();
    const oldStorage = this._storage;
    const willInvisibleEls = [];
    function doRenderNode(thisNode, oldNode, parentGroup, depth) {
      return renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth);
    }
    dualTravel(thisTree.root ? [thisTree.root] : [], oldTree && oldTree.root ? [oldTree.root] : [], containerGroup, thisTree === oldTree || !oldTree, 0);
    const willDeleteEls = clearStorage(oldStorage);
    this._oldTree = thisTree;
    this._storage = thisStorage;
    if (this._controllerHost) {
      const _oldRootLayout = this.seriesModel.layoutInfo;
      const rootLayout = thisTree.root.getLayout();
      if (rootLayout.width === _oldRootLayout.width && rootLayout.height === _oldRootLayout.height) {
        this._controllerHost.zoom = 1;
      }
    }
    return {
      lastsForAnimation,
      willDeleteEls,
      renderFinally
    };
    function dualTravel(thisViewChildren, oldViewChildren, parentGroup, sameTree, depth) {
      if (sameTree) {
        oldViewChildren = thisViewChildren;
        each(thisViewChildren, function(child, index) {
          !child.isRemoved() && processNode(index, index);
        });
      } else {
        new DataDiffer_default(oldViewChildren, thisViewChildren, getKey2, getKey2).add(processNode).update(processNode).remove(curry(processNode, null)).execute();
      }
      function getKey2(node) {
        return node.getId();
      }
      function processNode(newIndex, oldIndex) {
        const thisNode = newIndex != null ? thisViewChildren[newIndex] : null;
        const oldNode = oldIndex != null ? oldViewChildren[oldIndex] : null;
        const group = doRenderNode(thisNode, oldNode, parentGroup, depth);
        group && dualTravel(thisNode && thisNode.viewChildren || [], oldNode && oldNode.viewChildren || [], group, sameTree, depth + 1);
      }
    }
    function clearStorage(storage2) {
      const willDeleteEls2 = createStorage();
      storage2 && each(storage2, function(store, storageName) {
        const delEls = willDeleteEls2[storageName];
        each(store, function(el) {
          el && (delEls.push(el), inner10(el).willDelete = true);
        });
      });
      return willDeleteEls2;
    }
    function renderFinally() {
      each(willDeleteEls, function(els) {
        each(els, function(el) {
          el.parent && el.parent.remove(el);
        });
      });
      each(willInvisibleEls, function(el) {
        el.invisible = true;
        el.dirty();
      });
    }
  }
  _doAnimation(containerGroup, renderResult, seriesModel, reRoot) {
    const durationOption = seriesModel.get("animationDurationUpdate");
    const easingOption = seriesModel.get("animationEasing");
    const duration = (isFunction(durationOption) ? 0 : durationOption) || 0;
    const easing = (isFunction(easingOption) ? null : easingOption) || "cubicOut";
    const animationWrap = createWrap();
    each(renderResult.willDeleteEls, function(store, storageName) {
      each(store, function(el, rawIndex) {
        if (el.invisible) {
          return;
        }
        const parent = el.parent;
        let target;
        const innerStore = inner10(parent);
        if (reRoot && reRoot.direction === "drillDown") {
          target = parent === reRoot.rootNodeGroup ? {
            shape: {
              x: 0,
              y: 0,
              width: innerStore.nodeWidth,
              height: innerStore.nodeHeight
            },
            style: {
              opacity: 0
            }
          } : {style: {opacity: 0}};
        } else {
          let targetX = 0;
          let targetY = 0;
          if (!innerStore.willDelete) {
            targetX = innerStore.nodeWidth / 2;
            targetY = innerStore.nodeHeight / 2;
          }
          target = storageName === "nodeGroup" ? {x: targetX, y: targetY, style: {opacity: 0}} : {
            shape: {x: targetX, y: targetY, width: 0, height: 0},
            style: {opacity: 0}
          };
        }
        target && animationWrap.add(el, target, duration, 0, easing);
      });
    });
    each(this._storage, function(store, storageName) {
      each(store, function(el, rawIndex) {
        const last = renderResult.lastsForAnimation[storageName][rawIndex];
        const target = {};
        if (!last) {
          return;
        }
        if (el instanceof Group_default) {
          if (last.oldX != null) {
            target.x = el.x;
            target.y = el.y;
            el.x = last.oldX;
            el.y = last.oldY;
          }
        } else {
          if (last.oldShape) {
            target.shape = extend({}, el.shape);
            el.setShape(last.oldShape);
          }
          if (last.fadein) {
            el.setStyle("opacity", 0);
            target.style = {opacity: 1};
          } else if (el.style.opacity !== 1) {
            target.style = {opacity: 1};
          }
        }
        animationWrap.add(el, target, duration, 0, easing);
      });
    }, this);
    this._state = "animating";
    animationWrap.finished(bind(function() {
      this._state = "ready";
      renderResult.renderFinally();
    }, this)).start();
  }
  _resetController(api2) {
    let controller = this._controller;
    let controllerHost = this._controllerHost;
    if (!controllerHost) {
      this._controllerHost = {
        target: this.group
      };
      controllerHost = this._controllerHost;
    }
    const seriesModel = this.seriesModel;
    if (!controller) {
      controller = this._controller = new RoamController_default(api2.getZr());
      controller.on("pan", bind(this._onPan, this));
      controller.on("zoom", bind(this._onZoom, this));
    }
    controller.enable(seriesModel.get("roam"), {
      api: api2,
      zInfo: {component: seriesModel},
      triggerInfo: {
        roamTrigger: seriesModel.get("roamTrigger"),
        isInSelf: (e2, x, y) => {
          const containerGroup = this._containerGroup;
          return containerGroup ? containerGroup.getBoundingRect().contain(x - containerGroup.x, y - containerGroup.y) : false;
        }
      }
    });
    controllerHost.zoomLimit = seriesModel.get("scaleLimit");
    controllerHost.zoom = seriesModel.get("zoom");
  }
  _clearController() {
    let controller = this._controller;
    this._controllerHost = null;
    if (controller) {
      controller.dispose();
      controller = null;
    }
  }
  _onPan(e2) {
    if (this._state !== "animating" && (Math.abs(e2.dx) > DRAG_THRESHOLD || Math.abs(e2.dy) > DRAG_THRESHOLD)) {
      const root = this.seriesModel.getData().tree.root;
      if (!root) {
        return;
      }
      const rootLayout = root.getLayout();
      if (!rootLayout) {
        return;
      }
      this.api.dispatchAction({
        type: "treemapMove",
        from: this.uid,
        seriesId: this.seriesModel.id,
        rootRect: {
          x: rootLayout.x + e2.dx,
          y: rootLayout.y + e2.dy,
          width: rootLayout.width,
          height: rootLayout.height
        }
      });
    }
  }
  _onZoom(e2) {
    let mouseX = e2.originX;
    let mouseY = e2.originY;
    const zoomDelta = e2.scale;
    if (this._state !== "animating") {
      const root = this.seriesModel.getData().tree.root;
      if (!root) {
        return;
      }
      const rootLayout = root.getLayout();
      if (!rootLayout) {
        return;
      }
      const rect = new BoundingRect_default(rootLayout.x, rootLayout.y, rootLayout.width, rootLayout.height);
      let zoomLimit = null;
      const _controllerHost = this._controllerHost;
      zoomLimit = _controllerHost.zoomLimit;
      let newZoom = _controllerHost.zoom = _controllerHost.zoom || 1;
      newZoom *= zoomDelta;
      if (zoomLimit) {
        const zoomMin = zoomLimit.min || 0;
        const zoomMax = zoomLimit.max || Infinity;
        newZoom = Math.max(Math.min(zoomMax, newZoom), zoomMin);
      }
      const zoomScale = newZoom / _controllerHost.zoom;
      _controllerHost.zoom = newZoom;
      const layoutInfo = this.seriesModel.layoutInfo;
      mouseX -= layoutInfo.x;
      mouseY -= layoutInfo.y;
      const m2 = create2();
      translate(m2, m2, [-mouseX, -mouseY]);
      scale2(m2, m2, [zoomScale, zoomScale]);
      translate(m2, m2, [mouseX, mouseY]);
      rect.applyTransform(m2);
      this.api.dispatchAction({
        type: "treemapRender",
        from: this.uid,
        seriesId: this.seriesModel.id,
        rootRect: {
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height
        }
      });
    }
  }
  _initEvents(containerGroup) {
    containerGroup.on("click", (e2) => {
      if (this._state !== "ready") {
        return;
      }
      const nodeClick = this.seriesModel.get("nodeClick", true);
      if (!nodeClick) {
        return;
      }
      const targetInfo = this.findTarget(e2.offsetX, e2.offsetY);
      if (!targetInfo) {
        return;
      }
      const node = targetInfo.node;
      if (node.getLayout().isLeafRoot) {
        this._rootToNode(targetInfo);
      } else {
        if (nodeClick === "zoomToNode") {
          this._zoomToNode(targetInfo);
        } else if (nodeClick === "link") {
          const itemModel = node.hostTree.data.getItemModel(node.dataIndex);
          const link = itemModel.get("link", true);
          const linkTarget = itemModel.get("target", true) || "blank";
          link && windowOpen(link, linkTarget);
        }
      }
    }, this);
  }
  _renderBreadcrumb(seriesModel, api2, targetInfo) {
    if (!targetInfo) {
      targetInfo = seriesModel.get("leafDepth", true) != null ? {node: seriesModel.getViewRoot()} : this.findTarget(api2.getWidth() / 2, api2.getHeight() / 2);
      if (!targetInfo) {
        targetInfo = {node: seriesModel.getData().tree.root};
      }
    }
    (this._breadcrumb || (this._breadcrumb = new Breadcrumb_default(this.group))).render(seriesModel, api2, targetInfo.node, (node) => {
      if (this._state !== "animating") {
        aboveViewRoot(seriesModel.getViewRoot(), node) ? this._rootToNode({node}) : this._zoomToNode({node});
      }
    });
  }
  remove() {
    this._clearController();
    this._containerGroup && this._containerGroup.removeAll();
    this._storage = createStorage();
    this._state = "ready";
    this._breadcrumb && this._breadcrumb.remove();
  }
  dispose() {
    this._clearController();
  }
  _zoomToNode(targetInfo) {
    this.api.dispatchAction({
      type: "treemapZoomToNode",
      from: this.uid,
      seriesId: this.seriesModel.id,
      targetNode: targetInfo.node
    });
  }
  _rootToNode(targetInfo) {
    this.api.dispatchAction({
      type: "treemapRootToNode",
      from: this.uid,
      seriesId: this.seriesModel.id,
      targetNode: targetInfo.node
    });
  }
  findTarget(x, y) {
    let targetInfo;
    const viewRoot = this.seriesModel.getViewRoot();
    viewRoot.eachNode({attr: "viewChildren", order: "preorder"}, function(node) {
      const bgEl = this._storage.background[node.getRawIndex()];
      if (bgEl) {
        const point = bgEl.transformCoordToLocal(x, y);
        const shape = bgEl.shape;
        if (shape.x <= point[0] && point[0] <= shape.x + shape.width && shape.y <= point[1] && point[1] <= shape.y + shape.height) {
          targetInfo = {
            node,
            offsetX: point[0],
            offsetY: point[1]
          };
        } else {
          return false;
        }
      }
    }, this);
    return targetInfo;
  }
};
var TreemapView = TreemapView2;
TreemapView.type = "treemap";
function createStorage() {
  return {
    nodeGroup: [],
    background: [],
    content: []
  };
}
function renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth) {
  if (!thisNode) {
    return;
  }
  const thisLayout = thisNode.getLayout();
  const data = seriesModel.getData();
  const nodeModel = thisNode.getModel();
  data.setItemGraphicEl(thisNode.dataIndex, null);
  if (!thisLayout || !thisLayout.isInView) {
    return;
  }
  const thisWidth = thisLayout.width;
  const thisHeight = thisLayout.height;
  const borderWidth = thisLayout.borderWidth;
  const thisInvisible = thisLayout.invisible;
  const thisRawIndex = thisNode.getRawIndex();
  const oldRawIndex = oldNode && oldNode.getRawIndex();
  const thisViewChildren = thisNode.viewChildren;
  const upperHeight = thisLayout.upperHeight;
  const isParent = thisViewChildren && thisViewChildren.length;
  const itemStyleNormalModel = nodeModel.getModel("itemStyle");
  const itemStyleEmphasisModel = nodeModel.getModel(["emphasis", "itemStyle"]);
  const itemStyleBlurModel = nodeModel.getModel(["blur", "itemStyle"]);
  const itemStyleSelectModel = nodeModel.getModel(["select", "itemStyle"]);
  const borderRadius = itemStyleNormalModel.get("borderRadius") || 0;
  const group = giveGraphic("nodeGroup", Group2);
  if (!group) {
    return;
  }
  parentGroup.add(group);
  group.x = thisLayout.x || 0;
  group.y = thisLayout.y || 0;
  group.markRedraw();
  inner10(group).nodeWidth = thisWidth;
  inner10(group).nodeHeight = thisHeight;
  if (thisLayout.isAboveViewRoot) {
    return group;
  }
  const bg = giveGraphic("background", Rect2, depth, Z2_BG);
  bg && renderBackground(group, bg, isParent && thisLayout.upperLabelHeight);
  const emphasisModel = nodeModel.getModel("emphasis");
  const focus = emphasisModel.get("focus");
  const blurScope = emphasisModel.get("blurScope");
  const isDisabled = emphasisModel.get("disabled");
  const focusOrIndices = focus === "ancestor" ? thisNode.getAncestorsIndices() : focus === "descendant" ? thisNode.getDescendantIndices() : focus;
  if (isParent) {
    if (isHighDownDispatcher(group)) {
      setAsHighDownDispatcher(group, false);
    }
    if (bg) {
      setAsHighDownDispatcher(bg, !isDisabled);
      data.setItemGraphicEl(thisNode.dataIndex, bg);
      enableHoverFocus(bg, focusOrIndices, blurScope);
    }
  } else {
    const content = giveGraphic("content", Rect2, depth, Z2_CONTENT);
    content && renderContent(group, content);
    bg.disableMorphing = true;
    if (bg && isHighDownDispatcher(bg)) {
      setAsHighDownDispatcher(bg, false);
    }
    setAsHighDownDispatcher(group, !isDisabled);
    data.setItemGraphicEl(thisNode.dataIndex, group);
    const cursorStyle = nodeModel.getShallow("cursor");
    cursorStyle && content.attr("cursor", cursorStyle);
    enableHoverFocus(group, focusOrIndices, blurScope);
  }
  return group;
  function renderBackground(group2, bg2, useUpperLabel) {
    const ecData = getECData(bg2);
    ecData.dataIndex = thisNode.dataIndex;
    ecData.seriesIndex = seriesModel.seriesIndex;
    bg2.setShape({x: 0, y: 0, width: thisWidth, height: thisHeight, r: borderRadius});
    if (thisInvisible) {
      processInvisible(bg2);
    } else {
      bg2.invisible = false;
      const style = thisNode.getVisual("style");
      const visualBorderColor = style.stroke;
      const normalStyle = getItemStyleNormal(itemStyleNormalModel);
      normalStyle.fill = visualBorderColor;
      const emphasisStyle = getStateItemStyle(itemStyleEmphasisModel);
      emphasisStyle.fill = itemStyleEmphasisModel.get("borderColor");
      const blurStyle = getStateItemStyle(itemStyleBlurModel);
      blurStyle.fill = itemStyleBlurModel.get("borderColor");
      const selectStyle = getStateItemStyle(itemStyleSelectModel);
      selectStyle.fill = itemStyleSelectModel.get("borderColor");
      if (useUpperLabel) {
        const upperLabelWidth = thisWidth - 2 * borderWidth;
        prepareText(bg2, visualBorderColor, style.opacity, {x: borderWidth, y: 0, width: upperLabelWidth, height: upperHeight});
      } else {
        bg2.removeTextContent();
      }
      bg2.setStyle(normalStyle);
      bg2.ensureState("emphasis").style = emphasisStyle;
      bg2.ensureState("blur").style = blurStyle;
      bg2.ensureState("select").style = selectStyle;
      setDefaultStateProxy(bg2);
    }
    group2.add(bg2);
  }
  function renderContent(group2, content) {
    const ecData = getECData(content);
    ecData.dataIndex = thisNode.dataIndex;
    ecData.seriesIndex = seriesModel.seriesIndex;
    const contentWidth = Math.max(thisWidth - 2 * borderWidth, 0);
    const contentHeight = Math.max(thisHeight - 2 * borderWidth, 0);
    content.culling = true;
    content.setShape({
      x: borderWidth,
      y: borderWidth,
      width: contentWidth,
      height: contentHeight,
      r: borderRadius
    });
    if (thisInvisible) {
      processInvisible(content);
    } else {
      content.invisible = false;
      const nodeStyle = thisNode.getVisual("style");
      const visualColor = nodeStyle.fill;
      const normalStyle = getItemStyleNormal(itemStyleNormalModel);
      normalStyle.fill = visualColor;
      normalStyle.decal = nodeStyle.decal;
      const emphasisStyle = getStateItemStyle(itemStyleEmphasisModel);
      const blurStyle = getStateItemStyle(itemStyleBlurModel);
      const selectStyle = getStateItemStyle(itemStyleSelectModel);
      prepareText(content, visualColor, nodeStyle.opacity, null);
      content.setStyle(normalStyle);
      content.ensureState("emphasis").style = emphasisStyle;
      content.ensureState("blur").style = blurStyle;
      content.ensureState("select").style = selectStyle;
      setDefaultStateProxy(content);
    }
    group2.add(content);
  }
  function processInvisible(element) {
    !element.invisible && willInvisibleEls.push(element);
  }
  function prepareText(rectEl, visualColor, visualOpacity, upperLabelRect) {
    const normalLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL);
    const defaultText = convertOptionIdName(nodeModel.get("name"), null);
    const isShow = normalLabelModel.getShallow("show");
    setLabelStyle(rectEl, getLabelStatesModels(nodeModel, upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL), {
      defaultText: isShow ? defaultText : null,
      inheritColor: visualColor,
      defaultOpacity: visualOpacity,
      labelFetcher: seriesModel,
      labelDataIndex: thisNode.dataIndex
    });
    const textEl = rectEl.getTextContent();
    if (!textEl) {
      return;
    }
    const textStyle = textEl.style;
    const textPadding = normalizeCssArray(textStyle.padding || 0);
    if (upperLabelRect) {
      rectEl.setTextConfig({
        layoutRect: upperLabelRect
      });
      textEl.disableLabelLayout = true;
    }
    textEl.beforeUpdate = function() {
      const width = Math.max((upperLabelRect ? upperLabelRect.width : rectEl.shape.width) - textPadding[1] - textPadding[3], 0);
      const height = Math.max((upperLabelRect ? upperLabelRect.height : rectEl.shape.height) - textPadding[0] - textPadding[2], 0);
      if (textStyle.width !== width || textStyle.height !== height) {
        textEl.setStyle({
          width,
          height
        });
      }
    };
    textStyle.truncateMinChar = 2;
    textStyle.lineOverflow = "truncate";
    addDrillDownIcon(textStyle, upperLabelRect, thisLayout);
    const textEmphasisState = textEl.getState("emphasis");
    addDrillDownIcon(textEmphasisState ? textEmphasisState.style : null, upperLabelRect, thisLayout);
  }
  function addDrillDownIcon(style, upperLabelRect, thisLayout2) {
    const text = style ? style.text : null;
    if (!upperLabelRect && thisLayout2.isLeafRoot && text != null) {
      const iconChar = seriesModel.get("drillDownIcon", true);
      style.text = iconChar ? iconChar + " " + text : text;
    }
  }
  function giveGraphic(storageName, Ctor, depth2, z) {
    let element = oldRawIndex != null && oldStorage[storageName][oldRawIndex];
    const lasts = lastsForAnimation[storageName];
    if (element) {
      oldStorage[storageName][oldRawIndex] = null;
      prepareAnimationWhenHasOld(lasts, element);
    } else if (!thisInvisible) {
      element = new Ctor();
      if (element instanceof Displayable_default) {
        element.z2 = calculateZ2(depth2, z);
      }
      prepareAnimationWhenNoOld(lasts, element);
    }
    return thisStorage[storageName][thisRawIndex] = element;
  }
  function prepareAnimationWhenHasOld(lasts, element) {
    const lastCfg = lasts[thisRawIndex] = {};
    if (element instanceof Group2) {
      lastCfg.oldX = element.x;
      lastCfg.oldY = element.y;
    } else {
      lastCfg.oldShape = extend({}, element.shape);
    }
  }
  function prepareAnimationWhenNoOld(lasts, element) {
    const lastCfg = lasts[thisRawIndex] = {};
    const parentNode2 = thisNode.parentNode;
    const isGroup = element instanceof Group_default;
    if (parentNode2 && (!reRoot || reRoot.direction === "drillDown")) {
      let parentOldX = 0;
      let parentOldY = 0;
      const parentOldBg = lastsForAnimation.background[parentNode2.getRawIndex()];
      if (!reRoot && parentOldBg && parentOldBg.oldShape) {
        parentOldX = parentOldBg.oldShape.width;
        parentOldY = parentOldBg.oldShape.height;
      }
      if (isGroup) {
        lastCfg.oldX = 0;
        lastCfg.oldY = parentOldY;
      } else {
        lastCfg.oldShape = {x: parentOldX, y: parentOldY, width: 0, height: 0};
      }
    }
    lastCfg.fadein = !isGroup;
  }
}
function calculateZ2(depth, z2InLevel) {
  return depth * Z2_BASE + z2InLevel;
}
var TreemapView_default = TreemapView;

// src/visual/VisualMapping.ts
var each4 = each;
var isObject4 = isObject;
var CATEGORY_DEFAULT_VISUAL_INDEX = -1;
var VisualMapping2 = class {
  constructor(option) {
    const mappingMethod = option.mappingMethod;
    const visualType = option.type;
    const thisOption = this.option = clone(option);
    this.type = visualType;
    this.mappingMethod = mappingMethod;
    this._normalizeData = normalizers[mappingMethod];
    const visualHandler = VisualMapping2.visualHandlers[visualType];
    this.applyVisual = visualHandler.applyVisual;
    this.getColorMapper = visualHandler.getColorMapper;
    this._normalizedToVisual = visualHandler._normalizedToVisual[mappingMethod];
    if (mappingMethod === "piecewise") {
      normalizeVisualRange(thisOption);
      preprocessForPiecewise(thisOption);
    } else if (mappingMethod === "category") {
      thisOption.categories ? preprocessForSpecifiedCategory(thisOption) : normalizeVisualRange(thisOption, true);
    } else {
      assert(mappingMethod !== "linear" || thisOption.dataExtent);
      normalizeVisualRange(thisOption);
    }
  }
  mapValueToVisual(value) {
    const normalized = this._normalizeData(value);
    return this._normalizedToVisual(normalized, value);
  }
  getNormalizer() {
    return bind(this._normalizeData, this);
  }
  static listVisualTypes() {
    return keys(VisualMapping2.visualHandlers);
  }
  static isValidType(visualType) {
    return VisualMapping2.visualHandlers.hasOwnProperty(visualType);
  }
  static eachVisual(visual, callback, context) {
    if (isObject(visual)) {
      each(visual, callback, context);
    } else {
      callback.call(context, visual);
    }
  }
  static mapVisual(visual, callback, context) {
    let isPrimary;
    let newVisual = isArray(visual) ? [] : isObject(visual) ? {} : (isPrimary = true, null);
    VisualMapping2.eachVisual(visual, function(v, key) {
      const newVal = callback.call(context, v, key);
      isPrimary ? newVisual = newVal : newVisual[key] = newVal;
    });
    return newVisual;
  }
  static retrieveVisuals(obj) {
    const ret = {};
    let hasVisual;
    obj && each4(VisualMapping2.visualHandlers, function(h, visualType) {
      if (obj.hasOwnProperty(visualType)) {
        ret[visualType] = obj[visualType];
        hasVisual = true;
      }
    });
    return hasVisual ? ret : null;
  }
  static prepareVisualTypes(visualTypes) {
    if (isArray(visualTypes)) {
      visualTypes = visualTypes.slice();
    } else if (isObject4(visualTypes)) {
      const types = [];
      each4(visualTypes, function(item, type) {
        types.push(type);
      });
      visualTypes = types;
    } else {
      return [];
    }
    visualTypes.sort(function(type1, type2) {
      return type2 === "color" && type1 !== "color" && type1.indexOf("color") === 0 ? 1 : -1;
    });
    return visualTypes;
  }
  static dependsOn(visualType1, visualType2) {
    return visualType2 === "color" ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;
  }
  static findPieceIndex(value, pieceList, findClosestWhenOutside) {
    let possibleI;
    let abs2 = Infinity;
    for (let i = 0, len2 = pieceList.length; i < len2; i++) {
      const pieceValue = pieceList[i].value;
      if (pieceValue != null) {
        if (pieceValue === value || isString(pieceValue) && pieceValue === value + "") {
          return i;
        }
        findClosestWhenOutside && updatePossible(pieceValue, i);
      }
    }
    for (let i = 0, len2 = pieceList.length; i < len2; i++) {
      const piece = pieceList[i];
      const interval = piece.interval;
      const close = piece.close;
      if (interval) {
        if (interval[0] === -Infinity) {
          if (littleThan(close[1], value, interval[1])) {
            return i;
          }
        } else if (interval[1] === Infinity) {
          if (littleThan(close[0], interval[0], value)) {
            return i;
          }
        } else if (littleThan(close[0], interval[0], value) && littleThan(close[1], value, interval[1])) {
          return i;
        }
        findClosestWhenOutside && updatePossible(interval[0], i);
        findClosestWhenOutside && updatePossible(interval[1], i);
      }
    }
    if (findClosestWhenOutside) {
      return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;
    }
    function updatePossible(val, index) {
      const newAbs = Math.abs(val - value);
      if (newAbs < abs2) {
        abs2 = newAbs;
        possibleI = index;
      }
    }
  }
};
var VisualMapping = VisualMapping2;
VisualMapping.visualHandlers = {
  color: {
    applyVisual: makeApplyVisual("color"),
    getColorMapper: function() {
      const thisOption = this.option;
      return bind(thisOption.mappingMethod === "category" ? function(value, isNormalized) {
        !isNormalized && (value = this._normalizeData(value));
        return doMapCategory.call(this, value);
      } : function(value, isNormalized, out2) {
        const returnRGBArray = !!out2;
        !isNormalized && (value = this._normalizeData(value));
        out2 = fastLerp(value, thisOption.parsedVisual, out2);
        return returnRGBArray ? out2 : stringify(out2, "rgba");
      }, this);
    },
    _normalizedToVisual: {
      linear: function(normalized) {
        return stringify(fastLerp(normalized, this.option.parsedVisual), "rgba");
      },
      category: doMapCategory,
      piecewise: function(normalized, value) {
        let result = getSpecifiedVisual.call(this, value);
        if (result == null) {
          result = stringify(fastLerp(normalized, this.option.parsedVisual), "rgba");
        }
        return result;
      },
      fixed: doMapFixed
    }
  },
  colorHue: makePartialColorVisualHandler(function(color4, value) {
    return modifyHSL(color4, value);
  }),
  colorSaturation: makePartialColorVisualHandler(function(color4, value) {
    return modifyHSL(color4, null, value);
  }),
  colorLightness: makePartialColorVisualHandler(function(color4, value) {
    return modifyHSL(color4, null, null, value);
  }),
  colorAlpha: makePartialColorVisualHandler(function(color4, value) {
    return modifyAlpha(color4, value);
  }),
  decal: {
    applyVisual: makeApplyVisual("decal"),
    _normalizedToVisual: {
      linear: null,
      category: doMapCategory,
      piecewise: null,
      fixed: null
    }
  },
  opacity: {
    applyVisual: makeApplyVisual("opacity"),
    _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
  },
  liftZ: {
    applyVisual: makeApplyVisual("liftZ"),
    _normalizedToVisual: {
      linear: doMapFixed,
      category: doMapFixed,
      piecewise: doMapFixed,
      fixed: doMapFixed
    }
  },
  symbol: {
    applyVisual: function(value, getter, setter) {
      const symbolCfg = this.mapValueToVisual(value);
      setter("symbol", symbolCfg);
    },
    _normalizedToVisual: {
      linear: doMapToArray,
      category: doMapCategory,
      piecewise: function(normalized, value) {
        let result = getSpecifiedVisual.call(this, value);
        if (result == null) {
          result = doMapToArray.call(this, normalized);
        }
        return result;
      },
      fixed: doMapFixed
    }
  },
  symbolSize: {
    applyVisual: makeApplyVisual("symbolSize"),
    _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
  }
};
function preprocessForPiecewise(thisOption) {
  const pieceList = thisOption.pieceList;
  thisOption.hasSpecialVisual = false;
  each(pieceList, function(piece, index) {
    piece.originIndex = index;
    if (piece.visual != null) {
      thisOption.hasSpecialVisual = true;
    }
  });
}
function preprocessForSpecifiedCategory(thisOption) {
  const categories = thisOption.categories;
  const categoryMap = thisOption.categoryMap = {};
  let visual = thisOption.visual;
  each4(categories, function(cate, index) {
    categoryMap[cate] = index;
  });
  if (!isArray(visual)) {
    const visualArr = [];
    if (isObject(visual)) {
      each4(visual, function(v, cate) {
        const index = categoryMap[cate];
        visualArr[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;
      });
    } else {
      visualArr[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;
    }
    visual = setVisualToOption(thisOption, visualArr);
  }
  for (let i = categories.length - 1; i >= 0; i--) {
    if (visual[i] == null) {
      delete categoryMap[categories[i]];
      categories.pop();
    }
  }
}
function normalizeVisualRange(thisOption, isCategory2) {
  const visual = thisOption.visual;
  const visualArr = [];
  if (isObject(visual)) {
    each4(visual, function(v) {
      visualArr.push(v);
    });
  } else if (visual != null) {
    visualArr.push(visual);
  }
  const doNotNeedPair = {color: 1, symbol: 1};
  if (!isCategory2 && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {
    visualArr[1] = visualArr[0];
  }
  setVisualToOption(thisOption, visualArr);
}
function makePartialColorVisualHandler(applyValue) {
  return {
    applyVisual: function(value, getter, setter) {
      const colorChannel = this.mapValueToVisual(value);
      setter("color", applyValue(getter("color"), colorChannel));
    },
    _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
  };
}
function doMapToArray(normalized) {
  const visual = this.option.visual;
  return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {};
}
function makeApplyVisual(visualType) {
  return function(value, getter, setter) {
    setter(visualType, this.mapValueToVisual(value));
  };
}
function doMapCategory(normalized) {
  const visual = this.option.visual;
  return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];
}
function doMapFixed() {
  return this.option.visual[0];
}
function createNormalizedToNumericVisual(sourceExtent) {
  return {
    linear: function(normalized) {
      return linearMap(normalized, sourceExtent, this.option.visual, true);
    },
    category: doMapCategory,
    piecewise: function(normalized, value) {
      let result = getSpecifiedVisual.call(this, value);
      if (result == null) {
        result = linearMap(normalized, sourceExtent, this.option.visual, true);
      }
      return result;
    },
    fixed: doMapFixed
  };
}
function getSpecifiedVisual(value) {
  const thisOption = this.option;
  const pieceList = thisOption.pieceList;
  if (thisOption.hasSpecialVisual) {
    const pieceIndex = VisualMapping.findPieceIndex(value, pieceList);
    const piece = pieceList[pieceIndex];
    if (piece && piece.visual) {
      return piece.visual[this.type];
    }
  }
}
function setVisualToOption(thisOption, visualArr) {
  thisOption.visual = visualArr;
  if (thisOption.type === "color") {
    thisOption.parsedVisual = map(visualArr, function(item) {
      const color4 = parse(item);
      if (!color4 && true) {
        warn(`'${item}' is an illegal color, fallback to '#000000'`, true);
      }
      return color4 || [0, 0, 0, 1];
    });
  }
  return visualArr;
}
var normalizers = {
  linear: function(value) {
    return linearMap(value, this.option.dataExtent, [0, 1], true);
  },
  piecewise: function(value) {
    const pieceList = this.option.pieceList;
    const pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);
    if (pieceIndex != null) {
      return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);
    }
  },
  category: function(value) {
    const index = this.option.categories ? this.option.categoryMap[value] : value;
    return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;
  },
  fixed: noop
};
function littleThan(close, a, b) {
  return close ? a <= b : a < b;
}
var VisualMapping_default = VisualMapping;

// src/chart/treemap/treemapVisual.ts
var ITEM_STYLE_NORMAL = "itemStyle";
var inner11 = makeInner();
var treemapVisual_default = {
  seriesType: "treemap",
  reset(seriesModel) {
    const tree = seriesModel.getData().tree;
    const root = tree.root;
    if (root.isRemoved()) {
      return;
    }
    travelTree(root, {}, seriesModel.getViewRoot().getAncestors(), seriesModel);
  }
};
function travelTree(node, designatedVisual, viewRootAncestors, seriesModel) {
  const nodeModel = node.getModel();
  const nodeLayout = node.getLayout();
  const data = node.hostTree.data;
  if (!nodeLayout || nodeLayout.invisible || !nodeLayout.isInView) {
    return;
  }
  const nodeItemStyleModel = nodeModel.getModel(ITEM_STYLE_NORMAL);
  const visuals = buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel);
  const existsStyle = data.ensureUniqueItemVisual(node.dataIndex, "style");
  let borderColor = nodeItemStyleModel.get("borderColor");
  const borderColorSaturation = nodeItemStyleModel.get("borderColorSaturation");
  let thisNodeColor;
  if (borderColorSaturation != null) {
    thisNodeColor = calculateColor(visuals);
    borderColor = calculateBorderColor(borderColorSaturation, thisNodeColor);
  }
  existsStyle.stroke = borderColor;
  const viewChildren = node.viewChildren;
  if (!viewChildren || !viewChildren.length) {
    thisNodeColor = calculateColor(visuals);
    existsStyle.fill = thisNodeColor;
  } else {
    const mapping = buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren);
    each(viewChildren, function(child, index) {
      if (child.depth >= viewRootAncestors.length || child === viewRootAncestors[child.depth]) {
        const childVisual = mapVisual(nodeModel, visuals, child, index, mapping, seriesModel);
        travelTree(child, childVisual, viewRootAncestors, seriesModel);
      }
    });
  }
}
function buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel) {
  const visuals = extend({}, designatedVisual);
  const designatedVisualItemStyle = seriesModel.designatedVisualItemStyle;
  each(["color", "colorAlpha", "colorSaturation"], function(visualName) {
    designatedVisualItemStyle[visualName] = designatedVisual[visualName];
    const val = nodeItemStyleModel.get(visualName);
    designatedVisualItemStyle[visualName] = null;
    val != null && (visuals[visualName] = val);
  });
  return visuals;
}
function calculateColor(visuals) {
  let color4 = getValueVisualDefine(visuals, "color");
  if (color4) {
    const colorAlpha = getValueVisualDefine(visuals, "colorAlpha");
    const colorSaturation = getValueVisualDefine(visuals, "colorSaturation");
    if (colorSaturation) {
      color4 = modifyHSL(color4, null, null, colorSaturation);
    }
    if (colorAlpha) {
      color4 = modifyAlpha(color4, colorAlpha);
    }
    return color4;
  }
}
function calculateBorderColor(borderColorSaturation, thisNodeColor) {
  return thisNodeColor != null ? modifyHSL(thisNodeColor, null, null, borderColorSaturation) : null;
}
function getValueVisualDefine(visuals, name) {
  const value = visuals[name];
  if (value != null && value !== "none") {
    return value;
  }
}
function buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren) {
  if (!viewChildren || !viewChildren.length) {
    return;
  }
  const rangeVisual = getRangeVisual(nodeModel, "color") || visuals.color != null && visuals.color !== "none" && (getRangeVisual(nodeModel, "colorAlpha") || getRangeVisual(nodeModel, "colorSaturation"));
  if (!rangeVisual) {
    return;
  }
  const visualMin = nodeModel.get("visualMin");
  const visualMax = nodeModel.get("visualMax");
  const dataExtent = nodeLayout.dataExtent.slice();
  visualMin != null && visualMin < dataExtent[0] && (dataExtent[0] = visualMin);
  visualMax != null && visualMax > dataExtent[1] && (dataExtent[1] = visualMax);
  const colorMappingBy = nodeModel.get("colorMappingBy");
  const opt = {
    type: rangeVisual.name,
    dataExtent,
    visual: rangeVisual.range
  };
  if (opt.type === "color" && (colorMappingBy === "index" || colorMappingBy === "id")) {
    opt.mappingMethod = "category";
    opt.loop = true;
  } else {
    opt.mappingMethod = "linear";
  }
  const mapping = new VisualMapping_default(opt);
  inner11(mapping).drColorMappingBy = colorMappingBy;
  return mapping;
}
function getRangeVisual(nodeModel, name) {
  const range = nodeModel.get(name);
  return isArray(range) && range.length ? {
    name,
    range
  } : null;
}
function mapVisual(nodeModel, visuals, child, index, mapping, seriesModel) {
  const childVisuals = extend({}, visuals);
  if (mapping) {
    const mappingType = mapping.type;
    const colorMappingBy = mappingType === "color" && inner11(mapping).drColorMappingBy;
    const value = colorMappingBy === "index" ? index : colorMappingBy === "id" ? seriesModel.mapIdToIndex(child.getId()) : child.getValue(nodeModel.get("visualDimension"));
    childVisuals[mappingType] = mapping.mapValueToVisual(value);
  }
  return childVisuals;
}

// src/chart/treemap/treemapLayout.ts
var mathMax9 = Math.max;
var mathMin9 = Math.min;
var retrieveValue = retrieve;
var each5 = each;
var PATH_BORDER_WIDTH = ["itemStyle", "borderWidth"];
var PATH_GAP_WIDTH = ["itemStyle", "gapWidth"];
var PATH_UPPER_LABEL_SHOW = ["upperLabel", "show"];
var PATH_UPPER_LABEL_HEIGHT = ["upperLabel", "height"];
var treemapLayout_default = {
  seriesType: "treemap",
  reset: function(seriesModel, ecModel, api2, payload) {
    const seriesOption = seriesModel.option;
    const refContainer = createBoxLayoutReference(seriesModel, api2).refContainer;
    const layoutInfo = getLayoutRect(seriesModel.getBoxLayoutParams(), refContainer);
    const size = seriesOption.size || [];
    const containerWidth = parsePercent2(retrieveValue(layoutInfo.width, size[0]), refContainer.width);
    const containerHeight = parsePercent2(retrieveValue(layoutInfo.height, size[1]), refContainer.height);
    const payloadType = payload && payload.type;
    const types = ["treemapZoomToNode", "treemapRootToNode"];
    const targetInfo = retrieveTargetInfo(payload, types, seriesModel);
    const rootRect = payloadType === "treemapRender" || payloadType === "treemapMove" ? payload.rootRect : null;
    const viewRoot = seriesModel.getViewRoot();
    const viewAbovePath = getPathToRoot(viewRoot);
    if (payloadType !== "treemapMove") {
      const rootSize = payloadType === "treemapZoomToNode" ? estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) : rootRect ? [rootRect.width, rootRect.height] : [containerWidth, containerHeight];
      let sort4 = seriesOption.sort;
      if (sort4 && sort4 !== "asc" && sort4 !== "desc") {
        sort4 = "desc";
      }
      const options = {
        squareRatio: seriesOption.squareRatio,
        sort: sort4,
        leafDepth: seriesOption.leafDepth
      };
      viewRoot.hostTree.clearLayouts();
      let viewRootLayout = {
        x: 0,
        y: 0,
        width: rootSize[0],
        height: rootSize[1],
        area: rootSize[0] * rootSize[1]
      };
      viewRoot.setLayout(viewRootLayout);
      squarify(viewRoot, options, false, 0);
      viewRootLayout = viewRoot.getLayout();
      each5(viewAbovePath, function(node, index) {
        const childValue = (viewAbovePath[index + 1] || viewRoot).getValue();
        node.setLayout(extend({
          dataExtent: [childValue, childValue],
          borderWidth: 0,
          upperHeight: 0
        }, viewRootLayout));
      });
    }
    const treeRoot = seriesModel.getData().tree.root;
    treeRoot.setLayout(calculateRootPosition(layoutInfo, rootRect, targetInfo), true);
    seriesModel.setLayoutInfo(layoutInfo);
    prunning(treeRoot, new BoundingRect_default(-layoutInfo.x, -layoutInfo.y, api2.getWidth(), api2.getHeight()), viewAbovePath, viewRoot, 0);
  }
};
function squarify(node, options, hideChildren, depth) {
  let width;
  let height;
  if (node.isRemoved()) {
    return;
  }
  const thisLayout = node.getLayout();
  width = thisLayout.width;
  height = thisLayout.height;
  const nodeModel = node.getModel();
  const borderWidth = nodeModel.get(PATH_BORDER_WIDTH);
  const halfGapWidth = nodeModel.get(PATH_GAP_WIDTH) / 2;
  const upperLabelHeight = getUpperLabelHeight(nodeModel);
  const upperHeight = Math.max(borderWidth, upperLabelHeight);
  const layoutOffset = borderWidth - halfGapWidth;
  const layoutOffsetUpper = upperHeight - halfGapWidth;
  node.setLayout({
    borderWidth,
    upperHeight,
    upperLabelHeight
  }, true);
  width = mathMax9(width - 2 * layoutOffset, 0);
  height = mathMax9(height - layoutOffset - layoutOffsetUpper, 0);
  const totalArea = width * height;
  const viewChildren = initChildren(node, nodeModel, totalArea, options, hideChildren, depth);
  if (!viewChildren.length) {
    return;
  }
  const rect = {x: layoutOffset, y: layoutOffsetUpper, width, height};
  let rowFixedLength = mathMin9(width, height);
  let best = Infinity;
  const row = [];
  row.area = 0;
  for (let i = 0, len2 = viewChildren.length; i < len2; ) {
    const child = viewChildren[i];
    row.push(child);
    row.area += child.getLayout().area;
    const score = worst(row, rowFixedLength, options.squareRatio);
    if (score <= best) {
      i++;
      best = score;
    } else {
      row.area -= row.pop().getLayout().area;
      position(row, rowFixedLength, rect, halfGapWidth, false);
      rowFixedLength = mathMin9(rect.width, rect.height);
      row.length = row.area = 0;
      best = Infinity;
    }
  }
  if (row.length) {
    position(row, rowFixedLength, rect, halfGapWidth, true);
  }
  if (!hideChildren) {
    const childrenVisibleMin = nodeModel.get("childrenVisibleMin");
    if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {
      hideChildren = true;
    }
  }
  for (let i = 0, len2 = viewChildren.length; i < len2; i++) {
    squarify(viewChildren[i], options, hideChildren, depth + 1);
  }
}
function initChildren(node, nodeModel, totalArea, options, hideChildren, depth) {
  let viewChildren = node.children || [];
  let orderBy = options.sort;
  orderBy !== "asc" && orderBy !== "desc" && (orderBy = null);
  const overLeafDepth = options.leafDepth != null && options.leafDepth <= depth;
  if (hideChildren && !overLeafDepth) {
    return node.viewChildren = [];
  }
  viewChildren = filter(viewChildren, function(child) {
    return !child.isRemoved();
  });
  sort2(viewChildren, orderBy);
  const info = statistic(nodeModel, viewChildren, orderBy);
  if (info.sum === 0) {
    return node.viewChildren = [];
  }
  info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);
  if (info.sum === 0) {
    return node.viewChildren = [];
  }
  for (let i = 0, len2 = viewChildren.length; i < len2; i++) {
    const area = viewChildren[i].getValue() / info.sum * totalArea;
    viewChildren[i].setLayout({
      area
    });
  }
  if (overLeafDepth) {
    viewChildren.length && node.setLayout({
      isLeafRoot: true
    }, true);
    viewChildren.length = 0;
  }
  node.viewChildren = viewChildren;
  node.setLayout({
    dataExtent: info.dataExtent
  }, true);
  return viewChildren;
}
function filterByThreshold(nodeModel, totalArea, sum2, orderBy, orderedChildren) {
  if (!orderBy) {
    return sum2;
  }
  const visibleMin = nodeModel.get("visibleMin");
  const len2 = orderedChildren.length;
  let deletePoint = len2;
  for (let i = len2 - 1; i >= 0; i--) {
    const value = orderedChildren[orderBy === "asc" ? len2 - i - 1 : i].getValue();
    if (value / sum2 * totalArea < visibleMin) {
      deletePoint = i;
      sum2 -= value;
    }
  }
  orderBy === "asc" ? orderedChildren.splice(0, len2 - deletePoint) : orderedChildren.splice(deletePoint, len2 - deletePoint);
  return sum2;
}
function sort2(viewChildren, orderBy) {
  if (orderBy) {
    viewChildren.sort(function(a, b) {
      const diff = orderBy === "asc" ? a.getValue() - b.getValue() : b.getValue() - a.getValue();
      return diff === 0 ? orderBy === "asc" ? a.dataIndex - b.dataIndex : b.dataIndex - a.dataIndex : diff;
    });
  }
  return viewChildren;
}
function statistic(nodeModel, children, orderBy) {
  let sum2 = 0;
  for (let i = 0, len2 = children.length; i < len2; i++) {
    sum2 += children[i].getValue();
  }
  const dimension = nodeModel.get("visualDimension");
  let dataExtent;
  if (!children || !children.length) {
    dataExtent = [NaN, NaN];
  } else if (dimension === "value" && orderBy) {
    dataExtent = [
      children[children.length - 1].getValue(),
      children[0].getValue()
    ];
    orderBy === "asc" && dataExtent.reverse();
  } else {
    dataExtent = [Infinity, -Infinity];
    each5(children, function(child) {
      const value = child.getValue(dimension);
      value < dataExtent[0] && (dataExtent[0] = value);
      value > dataExtent[1] && (dataExtent[1] = value);
    });
  }
  return {sum: sum2, dataExtent};
}
function worst(row, rowFixedLength, ratio) {
  let areaMax = 0;
  let areaMin = Infinity;
  for (let i = 0, area, len2 = row.length; i < len2; i++) {
    area = row[i].getLayout().area;
    if (area) {
      area < areaMin && (areaMin = area);
      area > areaMax && (areaMax = area);
    }
  }
  const squareArea = row.area * row.area;
  const f = rowFixedLength * rowFixedLength * ratio;
  return squareArea ? mathMax9(f * areaMax / squareArea, squareArea / (f * areaMin)) : Infinity;
}
function position(row, rowFixedLength, rect, halfGapWidth, flush) {
  const idx0WhenH = rowFixedLength === rect.width ? 0 : 1;
  const idx1WhenH = 1 - idx0WhenH;
  const xy = ["x", "y"];
  const wh = ["width", "height"];
  let last = rect[xy[idx0WhenH]];
  let rowOtherLength = rowFixedLength ? row.area / rowFixedLength : 0;
  if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {
    rowOtherLength = rect[wh[idx1WhenH]];
  }
  for (let i = 0, rowLen = row.length; i < rowLen; i++) {
    const node = row[i];
    const nodeLayout = {};
    const step = rowOtherLength ? node.getLayout().area / rowOtherLength : 0;
    const wh1 = nodeLayout[wh[idx1WhenH]] = mathMax9(rowOtherLength - 2 * halfGapWidth, 0);
    const remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;
    const modWH = i === rowLen - 1 || remain < step ? remain : step;
    const wh0 = nodeLayout[wh[idx0WhenH]] = mathMax9(modWH - 2 * halfGapWidth, 0);
    nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin9(halfGapWidth, wh1 / 2);
    nodeLayout[xy[idx0WhenH]] = last + mathMin9(halfGapWidth, wh0 / 2);
    last += modWH;
    node.setLayout(nodeLayout, true);
  }
  rect[xy[idx1WhenH]] += rowOtherLength;
  rect[wh[idx1WhenH]] -= rowOtherLength;
}
function estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {
  let currNode = (targetInfo || {}).node;
  const defaultSize = [containerWidth, containerHeight];
  if (!currNode || currNode === viewRoot) {
    return defaultSize;
  }
  let parent;
  const viewArea = containerWidth * containerHeight;
  let area = viewArea * seriesModel.option.zoomToNodeRatio;
  while (parent = currNode.parentNode) {
    let sum2 = 0;
    const siblings = parent.children;
    for (let i = 0, len2 = siblings.length; i < len2; i++) {
      sum2 += siblings[i].getValue();
    }
    const currNodeValue = currNode.getValue();
    if (currNodeValue === 0) {
      return defaultSize;
    }
    area *= sum2 / currNodeValue;
    const parentModel = parent.getModel();
    const borderWidth = parentModel.get(PATH_BORDER_WIDTH);
    const upperHeight = Math.max(borderWidth, getUpperLabelHeight(parentModel));
    area += 4 * borderWidth * borderWidth + (3 * borderWidth + upperHeight) * Math.pow(area, 0.5);
    area > MAX_SAFE_INTEGER && (area = MAX_SAFE_INTEGER);
    currNode = parent;
  }
  area < viewArea && (area = viewArea);
  const scale4 = Math.pow(area / viewArea, 0.5);
  return [containerWidth * scale4, containerHeight * scale4];
}
function calculateRootPosition(layoutInfo, rootRect, targetInfo) {
  if (rootRect) {
    return {x: rootRect.x, y: rootRect.y};
  }
  const defaultPosition = {x: 0, y: 0};
  if (!targetInfo) {
    return defaultPosition;
  }
  const targetNode = targetInfo.node;
  const layout14 = targetNode.getLayout();
  if (!layout14) {
    return defaultPosition;
  }
  const targetCenter = [layout14.width / 2, layout14.height / 2];
  let node = targetNode;
  while (node) {
    const nodeLayout = node.getLayout();
    targetCenter[0] += nodeLayout.x;
    targetCenter[1] += nodeLayout.y;
    node = node.parentNode;
  }
  return {
    x: layoutInfo.width / 2 - targetCenter[0],
    y: layoutInfo.height / 2 - targetCenter[1]
  };
}
function prunning(node, clipRect, viewAbovePath, viewRoot, depth) {
  const nodeLayout = node.getLayout();
  const nodeInViewAbovePath = viewAbovePath[depth];
  const isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node;
  if (nodeInViewAbovePath && !isAboveViewRoot || depth === viewAbovePath.length && node !== viewRoot) {
    return;
  }
  node.setLayout({
    isInView: true,
    invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),
    isAboveViewRoot
  }, true);
  const childClipRect = new BoundingRect_default(clipRect.x - nodeLayout.x, clipRect.y - nodeLayout.y, clipRect.width, clipRect.height);
  each5(node.viewChildren || [], function(child) {
    prunning(child, childClipRect, viewAbovePath, viewRoot, depth + 1);
  });
}
function getUpperLabelHeight(model) {
  return model.get(PATH_UPPER_LABEL_SHOW) ? model.get(PATH_UPPER_LABEL_HEIGHT) : 0;
}

// src/chart/treemap/install.ts
function install13(registers) {
  registers.registerSeriesModel(TreemapSeries_default);
  registers.registerChartView(TreemapView_default);
  registers.registerVisual(treemapVisual_default);
  registers.registerLayout(treemapLayout_default);
  installTreemapAction(registers);
}

// src/chart/graph/categoryFilter.ts
function categoryFilter(ecModel) {
  const legendModels = ecModel.findComponents({
    mainType: "legend"
  });
  if (!legendModels || !legendModels.length) {
    return;
  }
  ecModel.eachSeriesByType("graph", function(graphSeries) {
    const categoriesData = graphSeries.getCategoriesData();
    const graph = graphSeries.getGraph();
    const data = graph.data;
    const categoryNames = categoriesData.mapArray(categoriesData.getName);
    data.filterSelf(function(idx) {
      const model = data.getItemModel(idx);
      let category = model.getShallow("category");
      if (category != null) {
        if (isNumber(category)) {
          category = categoryNames[category];
        }
        for (let i = 0; i < legendModels.length; i++) {
          if (!legendModels[i].isSelected(category)) {
            return false;
          }
        }
      }
      return true;
    });
  });
}

// src/chart/graph/categoryVisual.ts
function categoryVisual(ecModel) {
  const paletteScope = {};
  ecModel.eachSeriesByType("graph", function(seriesModel) {
    const categoriesData = seriesModel.getCategoriesData();
    const data = seriesModel.getData();
    const categoryNameIdxMap = {};
    categoriesData.each(function(idx) {
      const name = categoriesData.getName(idx);
      categoryNameIdxMap["ec-" + name] = idx;
      const itemModel = categoriesData.getItemModel(idx);
      const style = itemModel.getModel("itemStyle").getItemStyle();
      if (!style.fill) {
        style.fill = seriesModel.getColorFromPalette(name, paletteScope);
      }
      categoriesData.setItemVisual(idx, "style", style);
      const symbolVisualList = ["symbol", "symbolSize", "symbolKeepAspect"];
      for (let i = 0; i < symbolVisualList.length; i++) {
        const symbolVisual = itemModel.getShallow(symbolVisualList[i], true);
        if (symbolVisual != null) {
          categoriesData.setItemVisual(idx, symbolVisualList[i], symbolVisual);
        }
      }
    });
    if (categoriesData.count()) {
      data.each(function(idx) {
        const model = data.getItemModel(idx);
        let categoryIdx = model.getShallow("category");
        if (categoryIdx != null) {
          if (isString(categoryIdx)) {
            categoryIdx = categoryNameIdxMap["ec-" + categoryIdx];
          }
          const categoryStyle = categoriesData.getItemVisual(categoryIdx, "style");
          const style = data.ensureUniqueItemVisual(idx, "style");
          extend(style, categoryStyle);
          const visualList = ["symbol", "symbolSize", "symbolKeepAspect"];
          for (let i = 0; i < visualList.length; i++) {
            data.setItemVisual(idx, visualList[i], categoriesData.getItemVisual(categoryIdx, visualList[i]));
          }
        }
      });
    }
  });
}

// src/chart/graph/edgeVisual.ts
function normalize3(a) {
  if (!(a instanceof Array)) {
    a = [a, a];
  }
  return a;
}
function graphEdgeVisual(ecModel) {
  ecModel.eachSeriesByType("graph", function(seriesModel) {
    const graph = seriesModel.getGraph();
    const edgeData = seriesModel.getEdgeData();
    const symbolType = normalize3(seriesModel.get("edgeSymbol"));
    const symbolSize = normalize3(seriesModel.get("edgeSymbolSize"));
    edgeData.setVisual("fromSymbol", symbolType && symbolType[0]);
    edgeData.setVisual("toSymbol", symbolType && symbolType[1]);
    edgeData.setVisual("fromSymbolSize", symbolSize && symbolSize[0]);
    edgeData.setVisual("toSymbolSize", symbolSize && symbolSize[1]);
    edgeData.setVisual("style", seriesModel.getModel("lineStyle").getLineStyle());
    edgeData.each(function(idx) {
      const itemModel = edgeData.getItemModel(idx);
      const edge = graph.getEdgeByIndex(idx);
      const symbolType2 = normalize3(itemModel.getShallow("symbol", true));
      const symbolSize2 = normalize3(itemModel.getShallow("symbolSize", true));
      const style = itemModel.getModel("lineStyle").getLineStyle();
      const existsStyle = edgeData.ensureUniqueItemVisual(idx, "style");
      extend(existsStyle, style);
      switch (existsStyle.stroke) {
        case "source": {
          const nodeStyle = edge.node1.getVisual("style");
          existsStyle.stroke = nodeStyle && nodeStyle.fill;
          break;
        }
        case "target": {
          const nodeStyle = edge.node2.getVisual("style");
          existsStyle.stroke = nodeStyle && nodeStyle.fill;
          break;
        }
      }
      symbolType2[0] && edge.setVisual("fromSymbol", symbolType2[0]);
      symbolType2[1] && edge.setVisual("toSymbol", symbolType2[1]);
      symbolSize2[0] && edge.setVisual("fromSymbolSize", symbolSize2[0]);
      symbolSize2[1] && edge.setVisual("toSymbolSize", symbolSize2[1]);
    });
  });
}

// src/chart/helper/multipleGraphEdgeHelper.ts
var KEY_DELIMITER = "-->";
var getAutoCurvenessParams = function(seriesModel) {
  return seriesModel.get("autoCurveness") || null;
};
var createCurveness = function(seriesModel, appendLength) {
  const autoCurvenessParmas = getAutoCurvenessParams(seriesModel);
  let length2 = 20;
  let curvenessList = [];
  if (isNumber(autoCurvenessParmas)) {
    length2 = autoCurvenessParmas;
  } else if (isArray(autoCurvenessParmas)) {
    seriesModel.__curvenessList = autoCurvenessParmas;
    return;
  }
  if (appendLength > length2) {
    length2 = appendLength;
  }
  const len2 = length2 % 2 ? length2 + 2 : length2 + 3;
  curvenessList = [];
  for (let i = 0; i < len2; i++) {
    curvenessList.push((i % 2 ? i + 1 : i) / 10 * (i % 2 ? -1 : 1));
  }
  seriesModel.__curvenessList = curvenessList;
};
var getKeyOfEdges = function(n1, n2, seriesModel) {
  const source = [n1.id, n1.dataIndex].join(".");
  const target = [n2.id, n2.dataIndex].join(".");
  return [seriesModel.uid, source, target].join(KEY_DELIMITER);
};
var getOppositeKey = function(key) {
  const keys2 = key.split(KEY_DELIMITER);
  return [keys2[0], keys2[2], keys2[1]].join(KEY_DELIMITER);
};
var getEdgeFromMap = function(edge, seriesModel) {
  const key = getKeyOfEdges(edge.node1, edge.node2, seriesModel);
  return seriesModel.__edgeMap[key];
};
var getTotalLengthBetweenNodes = function(edge, seriesModel) {
  const len2 = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node1, edge.node2, seriesModel), seriesModel);
  const lenV = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node2, edge.node1, seriesModel), seriesModel);
  return len2 + lenV;
};
var getEdgeMapLengthWithKey = function(key, seriesModel) {
  const edgeMap = seriesModel.__edgeMap;
  return edgeMap[key] ? edgeMap[key].length : 0;
};
function initCurvenessList(seriesModel) {
  if (!getAutoCurvenessParams(seriesModel)) {
    return;
  }
  seriesModel.__curvenessList = [];
  seriesModel.__edgeMap = {};
  createCurveness(seriesModel);
}
function createEdgeMapForCurveness(n1, n2, seriesModel, index) {
  if (!getAutoCurvenessParams(seriesModel)) {
    return;
  }
  const key = getKeyOfEdges(n1, n2, seriesModel);
  const edgeMap = seriesModel.__edgeMap;
  const oppositeEdges = edgeMap[getOppositeKey(key)];
  if (edgeMap[key] && !oppositeEdges) {
    edgeMap[key].isForward = true;
  } else if (oppositeEdges && edgeMap[key]) {
    oppositeEdges.isForward = true;
    edgeMap[key].isForward = false;
  }
  edgeMap[key] = edgeMap[key] || [];
  edgeMap[key].push(index);
}
function getCurvenessForEdge(edge, seriesModel, index, needReverse) {
  const autoCurvenessParams = getAutoCurvenessParams(seriesModel);
  const isArrayParam = isArray(autoCurvenessParams);
  if (!autoCurvenessParams) {
    return null;
  }
  const edgeArray = getEdgeFromMap(edge, seriesModel);
  if (!edgeArray) {
    return null;
  }
  let edgeIndex = -1;
  for (let i = 0; i < edgeArray.length; i++) {
    if (edgeArray[i] === index) {
      edgeIndex = i;
      break;
    }
  }
  const totalLen = getTotalLengthBetweenNodes(edge, seriesModel);
  createCurveness(seriesModel, totalLen);
  edge.lineStyle = edge.lineStyle || {};
  const curKey = getKeyOfEdges(edge.node1, edge.node2, seriesModel);
  const curvenessList = seriesModel.__curvenessList;
  const parityCorrection = isArrayParam ? 0 : totalLen % 2 ? 0 : 1;
  if (!edgeArray.isForward) {
    const oppositeKey = getOppositeKey(curKey);
    const len2 = getEdgeMapLengthWithKey(oppositeKey, seriesModel);
    const resValue = curvenessList[edgeIndex + len2 + parityCorrection];
    if (needReverse) {
      if (isArrayParam) {
        if (autoCurvenessParams && autoCurvenessParams[0] === 0) {
          return (len2 + parityCorrection) % 2 ? resValue : -resValue;
        } else {
          return ((len2 % 2 ? 0 : 1) + parityCorrection) % 2 ? resValue : -resValue;
        }
      } else {
        return (len2 + parityCorrection) % 2 ? resValue : -resValue;
      }
    } else {
      return curvenessList[edgeIndex + len2 + parityCorrection];
    }
  } else {
    return curvenessList[parityCorrection + edgeIndex];
  }
}

// src/chart/graph/simpleLayoutHelper.ts
function simpleLayout(seriesModel) {
  const coordSys = seriesModel.coordinateSystem;
  if (coordSys && coordSys.type !== "view") {
    return;
  }
  const graph = seriesModel.getGraph();
  graph.eachNode(function(node) {
    const model = node.getModel();
    node.setLayout([+model.get("x"), +model.get("y")]);
  });
  simpleLayoutEdge(graph, seriesModel);
}
function simpleLayoutEdge(graph, seriesModel) {
  graph.eachEdge(function(edge, index) {
    const curveness = retrieve3(edge.getModel().get(["lineStyle", "curveness"]), -getCurvenessForEdge(edge, seriesModel, index, true), 0);
    const p1 = clone2(edge.node1.getLayout());
    const p2 = clone2(edge.node2.getLayout());
    const points4 = [p1, p2];
    if (+curveness) {
      points4.push([
        (p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * curveness,
        (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * curveness
      ]);
    }
    edge.setLayout(points4);
  });
}

// src/chart/graph/simpleLayout.ts
function graphSimpleLayout(ecModel, api2) {
  ecModel.eachSeriesByType("graph", function(seriesModel) {
    const layout14 = seriesModel.get("layout");
    const coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.type !== "view") {
      const data = seriesModel.getData();
      let dimensions = [];
      each(coordSys.dimensions, function(coordDim) {
        dimensions = dimensions.concat(data.mapDimensionsAll(coordDim));
      });
      for (let dataIndex = 0; dataIndex < data.count(); dataIndex++) {
        const value = [];
        let hasValue = false;
        for (let i = 0; i < dimensions.length; i++) {
          const val = data.get(dimensions[i], dataIndex);
          if (!isNaN(val)) {
            hasValue = true;
          }
          value.push(val);
        }
        if (hasValue) {
          data.setItemLayout(dataIndex, coordSys.dataToPoint(value));
        } else {
          data.setItemLayout(dataIndex, [NaN, NaN]);
        }
      }
      simpleLayoutEdge(data.graph, seriesModel);
    } else if (!layout14 || layout14 === "none") {
      simpleLayout(seriesModel);
    }
  });
}

// src/chart/graph/graphHelper.ts
function getNodeGlobalScale(seriesModel) {
  const coordSys = seriesModel.coordinateSystem;
  if (coordSys.type !== "view") {
    return 1;
  }
  const nodeScaleRatio = seriesModel.option.nodeScaleRatio;
  const groupZoom = coordSys.scaleX;
  const roamZoom = coordSys.getZoom();
  const nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;
  return nodeScale / groupZoom;
}
function getSymbolSize(node) {
  let symbolSize = node.getVisual("symbolSize");
  if (symbolSize instanceof Array) {
    symbolSize = (symbolSize[0] + symbolSize[1]) / 2;
  }
  return +symbolSize;
}

// src/chart/graph/circularLayoutHelper.ts
var PI8 = Math.PI;
var _symbolRadiansHalf = [];
function circularLayout(seriesModel, basedOn, draggingNode, pointer) {
  const coordSys = seriesModel.coordinateSystem;
  if (coordSys && coordSys.type !== "view") {
    return;
  }
  const rect = coordSys.getBoundingRect();
  const nodeData = seriesModel.getData();
  const graph = nodeData.graph;
  const cx = rect.width / 2 + rect.x;
  const cy = rect.height / 2 + rect.y;
  const r = Math.min(rect.width, rect.height) / 2;
  const count2 = nodeData.count();
  nodeData.setLayout({
    cx,
    cy
  });
  if (!count2) {
    return;
  }
  if (draggingNode) {
    const [tempX, tempY] = coordSys.pointToData(pointer);
    const v = [tempX - cx, tempY - cy];
    normalize(v, v);
    scale(v, v, r);
    draggingNode.setLayout([cx + v[0], cy + v[1]], true);
    const circularRotateLabel = seriesModel.get(["circular", "rotateLabel"]);
    rotateNodeLabel(draggingNode, circularRotateLabel, cx, cy);
  }
  _layoutNodesBasedOn[basedOn](seriesModel, graph, nodeData, r, cx, cy, count2);
  graph.eachEdge(function(edge, index) {
    let curveness = retrieve3(edge.getModel().get(["lineStyle", "curveness"]), getCurvenessForEdge(edge, seriesModel, index), 0);
    const p1 = clone2(edge.node1.getLayout());
    const p2 = clone2(edge.node2.getLayout());
    let cp1;
    const x12 = (p1[0] + p2[0]) / 2;
    const y12 = (p1[1] + p2[1]) / 2;
    if (+curveness) {
      curveness *= 3;
      cp1 = [
        cx * curveness + x12 * (1 - curveness),
        cy * curveness + y12 * (1 - curveness)
      ];
    }
    edge.setLayout([p1, p2, cp1]);
  });
}
var _layoutNodesBasedOn = {
  value(seriesModel, graph, nodeData, r, cx, cy, count2) {
    let angle = 0;
    const sum2 = nodeData.getSum("value");
    const unitAngle = Math.PI * 2 / (sum2 || count2);
    graph.eachNode(function(node) {
      const value = node.getValue("value");
      const radianHalf = unitAngle * (sum2 ? value : 1) / 2;
      angle += radianHalf;
      node.setLayout([
        r * Math.cos(angle) + cx,
        r * Math.sin(angle) + cy
      ]);
      angle += radianHalf;
    });
  },
  symbolSize(seriesModel, graph, nodeData, r, cx, cy, count2) {
    let sumRadian = 0;
    _symbolRadiansHalf.length = count2;
    const nodeScale = getNodeGlobalScale(seriesModel);
    graph.eachNode(function(node) {
      let symbolSize = getSymbolSize(node);
      isNaN(symbolSize) && (symbolSize = 2);
      symbolSize < 0 && (symbolSize = 0);
      symbolSize *= nodeScale;
      let symbolRadianHalf = Math.asin(symbolSize / 2 / r);
      isNaN(symbolRadianHalf) && (symbolRadianHalf = PI8 / 2);
      _symbolRadiansHalf[node.dataIndex] = symbolRadianHalf;
      sumRadian += symbolRadianHalf * 2;
    });
    const halfRemainRadian = (2 * PI8 - sumRadian) / count2 / 2;
    let angle = 0;
    graph.eachNode(function(node) {
      const radianHalf = halfRemainRadian + _symbolRadiansHalf[node.dataIndex];
      angle += radianHalf;
      (!node.getLayout() || !node.getLayout().fixed) && node.setLayout([
        r * Math.cos(angle) + cx,
        r * Math.sin(angle) + cy
      ]);
      angle += radianHalf;
    });
  }
};
function rotateNodeLabel(node, circularRotateLabel, cx, cy) {
  const el = node.getGraphicEl();
  if (!el) {
    return;
  }
  const nodeModel = node.getModel();
  let labelRotate = nodeModel.get(["label", "rotate"]) || 0;
  const symbolPath = el.getSymbolPath();
  if (circularRotateLabel) {
    const pos = node.getLayout();
    let rad = Math.atan2(pos[1] - cy, pos[0] - cx);
    if (rad < 0) {
      rad = Math.PI * 2 + rad;
    }
    const isLeft = pos[0] < cx;
    if (isLeft) {
      rad = rad - Math.PI;
    }
    const textPosition = isLeft ? "left" : "right";
    symbolPath.setTextConfig({
      rotation: -rad,
      position: textPosition,
      origin: "center"
    });
    const emphasisState = symbolPath.ensureState("emphasis");
    extend(emphasisState.textConfig || (emphasisState.textConfig = {}), {
      position: textPosition
    });
  } else {
    symbolPath.setTextConfig({
      rotation: labelRotate *= Math.PI / 180
    });
  }
}

// src/chart/graph/circularLayout.ts
function graphCircularLayout(ecModel) {
  ecModel.eachSeriesByType("graph", function(seriesModel) {
    if (seriesModel.get("layout") === "circular") {
      circularLayout(seriesModel, "symbolSize");
    }
  });
}

// src/chart/graph/forceHelper.ts
var scaleAndAdd2 = scaleAndAdd;
function forceLayout(inNodes, inEdges, opts) {
  const nodes = inNodes;
  const edges = inEdges;
  const rect = opts.rect;
  const width = rect.width;
  const height = rect.height;
  const center3 = [rect.x + width / 2, rect.y + height / 2];
  const gravity = opts.gravity == null ? 0.1 : opts.gravity;
  for (let i = 0; i < nodes.length; i++) {
    const n = nodes[i];
    if (!n.p) {
      n.p = create(width * (Math.random() - 0.5) + center3[0], height * (Math.random() - 0.5) + center3[1]);
    }
    n.pp = clone2(n.p);
    n.edges = null;
  }
  const initialFriction = opts.friction == null ? 0.6 : opts.friction;
  let friction = initialFriction;
  let beforeStepCallback;
  let afterStepCallback;
  return {
    warmUp: function() {
      friction = initialFriction * 0.8;
    },
    setFixed: function(idx) {
      nodes[idx].fixed = true;
    },
    setUnfixed: function(idx) {
      nodes[idx].fixed = false;
    },
    beforeStep: function(cb) {
      beforeStepCallback = cb;
    },
    afterStep: function(cb) {
      afterStepCallback = cb;
    },
    step: function(cb) {
      beforeStepCallback && beforeStepCallback(nodes, edges);
      const v12 = [];
      const nLen = nodes.length;
      for (let i = 0; i < edges.length; i++) {
        const e2 = edges[i];
        if (e2.ignoreForceLayout) {
          continue;
        }
        const n1 = e2.n1;
        const n2 = e2.n2;
        sub(v12, n2.p, n1.p);
        const d = len(v12) - e2.d;
        let w = n2.w / (n1.w + n2.w);
        if (isNaN(w)) {
          w = 0;
        }
        normalize(v12, v12);
        !n1.fixed && scaleAndAdd2(n1.p, n1.p, v12, w * d * friction);
        !n2.fixed && scaleAndAdd2(n2.p, n2.p, v12, -(1 - w) * d * friction);
      }
      for (let i = 0; i < nLen; i++) {
        const n = nodes[i];
        if (!n.fixed) {
          sub(v12, center3, n.p);
          scaleAndAdd2(n.p, n.p, v12, gravity * friction);
        }
      }
      for (let i = 0; i < nLen; i++) {
        const n1 = nodes[i];
        for (let j = i + 1; j < nLen; j++) {
          const n2 = nodes[j];
          sub(v12, n2.p, n1.p);
          let d = len(v12);
          if (d === 0) {
            set(v12, Math.random() - 0.5, Math.random() - 0.5);
            d = 1;
          }
          const repFact = (n1.rep + n2.rep) / d / d;
          !n1.fixed && scaleAndAdd2(n1.pp, n1.pp, v12, repFact);
          !n2.fixed && scaleAndAdd2(n2.pp, n2.pp, v12, -repFact);
        }
      }
      const v = [];
      for (let i = 0; i < nLen; i++) {
        const n = nodes[i];
        if (!n.fixed) {
          sub(v, n.p, n.pp);
          scaleAndAdd2(n.p, n.p, v, friction);
          copy(n.pp, n.p);
        }
      }
      friction = friction * 0.992;
      const finished = friction < 0.01;
      afterStepCallback && afterStepCallback(nodes, edges, finished);
      cb && cb(finished);
    }
  };
}

// src/chart/graph/forceLayout.ts
function graphForceLayout(ecModel) {
  ecModel.eachSeriesByType("graph", function(graphSeries) {
    const coordSys = graphSeries.coordinateSystem;
    if (coordSys && coordSys.type !== "view") {
      return;
    }
    if (graphSeries.get("layout") === "force") {
      const preservedPoints = graphSeries.preservedPoints || {};
      const graph = graphSeries.getGraph();
      const nodeData = graph.data;
      const edgeData = graph.edgeData;
      const forceModel = graphSeries.getModel("force");
      const initLayout = forceModel.get("initLayout");
      if (graphSeries.preservedPoints) {
        nodeData.each(function(idx) {
          const id = nodeData.getId(idx);
          nodeData.setItemLayout(idx, preservedPoints[id] || [NaN, NaN]);
        });
      } else if (!initLayout || initLayout === "none") {
        simpleLayout(graphSeries);
      } else if (initLayout === "circular") {
        circularLayout(graphSeries, "value");
      }
      const nodeDataExtent = nodeData.getDataExtent("value");
      const edgeDataExtent = edgeData.getDataExtent("value");
      const repulsion = forceModel.get("repulsion");
      const edgeLength = forceModel.get("edgeLength");
      const repulsionArr = isArray(repulsion) ? repulsion : [repulsion, repulsion];
      let edgeLengthArr = isArray(edgeLength) ? edgeLength : [edgeLength, edgeLength];
      edgeLengthArr = [edgeLengthArr[1], edgeLengthArr[0]];
      const nodes = nodeData.mapArray("value", function(value, idx) {
        const point = nodeData.getItemLayout(idx);
        let rep = linearMap(value, nodeDataExtent, repulsionArr);
        if (isNaN(rep)) {
          rep = (repulsionArr[0] + repulsionArr[1]) / 2;
        }
        return {
          w: rep,
          rep,
          fixed: nodeData.getItemModel(idx).get("fixed"),
          p: !point || isNaN(point[0]) || isNaN(point[1]) ? null : point
        };
      });
      const edges = edgeData.mapArray("value", function(value, idx) {
        const edge = graph.getEdgeByIndex(idx);
        let d = linearMap(value, edgeDataExtent, edgeLengthArr);
        if (isNaN(d)) {
          d = (edgeLengthArr[0] + edgeLengthArr[1]) / 2;
        }
        const edgeModel = edge.getModel();
        const curveness = retrieve3(edge.getModel().get(["lineStyle", "curveness"]), -getCurvenessForEdge(edge, graphSeries, idx, true), 0);
        return {
          n1: nodes[edge.node1.dataIndex],
          n2: nodes[edge.node2.dataIndex],
          d,
          curveness,
          ignoreForceLayout: edgeModel.get("ignoreForceLayout")
        };
      });
      const rect = coordSys.getBoundingRect();
      const forceInstance = forceLayout(nodes, edges, {
        rect,
        gravity: forceModel.get("gravity"),
        friction: forceModel.get("friction")
      });
      forceInstance.beforeStep(function(nodes2, edges2) {
        for (let i = 0, l = nodes2.length; i < l; i++) {
          if (nodes2[i].fixed) {
            copy(nodes2[i].p, graph.getNodeByIndex(i).getLayout());
          }
        }
      });
      forceInstance.afterStep(function(nodes2, edges2, stopped) {
        for (let i = 0, l = nodes2.length; i < l; i++) {
          if (!nodes2[i].fixed) {
            graph.getNodeByIndex(i).setLayout(nodes2[i].p);
          }
          preservedPoints[nodeData.getId(i)] = nodes2[i].p;
        }
        for (let i = 0, l = edges2.length; i < l; i++) {
          const e2 = edges2[i];
          const edge = graph.getEdgeByIndex(i);
          const p1 = e2.n1.p;
          const p2 = e2.n2.p;
          let points4 = edge.getLayout();
          points4 = points4 ? points4.slice() : [];
          points4[0] = points4[0] || [];
          points4[1] = points4[1] || [];
          copy(points4[0], p1);
          copy(points4[1], p2);
          if (+e2.curveness) {
            points4[2] = [
              (p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * e2.curveness,
              (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * e2.curveness
            ];
          }
          edge.setLayout(points4);
        }
      });
      graphSeries.forceLayout = forceInstance;
      graphSeries.preservedPoints = preservedPoints;
      forceInstance.step();
    } else {
      graphSeries.forceLayout = null;
    }
  });
}

// src/chart/graph/createView.ts
function getViewRect(seriesModel, api2, aspect) {
  const layoutRef = createBoxLayoutReference(seriesModel, api2);
  const option = extend(seriesModel.getBoxLayoutParams(), {
    aspect
  });
  const viewRect2 = getLayoutRect(option, layoutRef.refContainer);
  return applyPreserveAspect(seriesModel, viewRect2, aspect);
}
function createViewCoordSys(ecModel, api2) {
  const viewList = [];
  ecModel.eachSeriesByType("graph", function(seriesModel) {
    injectCoordSysByOption({
      targetModel: seriesModel,
      coordSysType: "view",
      coordSysProvider: createViewCoordSys2,
      isDefaultDataCoordSys: true
    });
    function createViewCoordSys2() {
      const data = seriesModel.getData();
      const positions = data.mapArray(function(idx) {
        const itemModel = data.getItemModel(idx);
        return [+itemModel.get("x"), +itemModel.get("y")];
      });
      let min3 = [];
      let max3 = [];
      fromPoints(positions, min3, max3);
      if (max3[0] - min3[0] === 0) {
        max3[0] += 1;
        min3[0] -= 1;
      }
      if (max3[1] - min3[1] === 0) {
        max3[1] += 1;
        min3[1] -= 1;
      }
      const aspect = (max3[0] - min3[0]) / (max3[1] - min3[1]);
      const viewRect2 = getViewRect(seriesModel, api2, aspect);
      if (isNaN(aspect)) {
        min3 = [viewRect2.x, viewRect2.y];
        max3 = [viewRect2.x + viewRect2.width, viewRect2.y + viewRect2.height];
      }
      const bbWidth = max3[0] - min3[0];
      const bbHeight = max3[1] - min3[1];
      const viewCoordSys = new View_default(null, {api: api2, ecModel});
      viewCoordSys.zoomLimit = seriesModel.get("scaleLimit");
      viewCoordSys.setBoundingRect(min3[0], min3[1], bbWidth, bbHeight);
      viewCoordSys.setViewRect(viewRect2.x, viewRect2.y, viewRect2.width, viewRect2.height);
      viewCoordSys.setCenter(seriesModel.get("center"));
      viewCoordSys.setZoom(seriesModel.get("zoom"));
      viewList.push(viewCoordSys);
      return viewCoordSys;
    }
  });
  return viewList;
}

// src/chart/helper/LinePath.ts
var straightLineProto = Line_default.prototype;
var bezierCurveProto = BezierCurve_default.prototype;
var StraightLineShape = class {
  constructor() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.percent = 1;
  }
};
function isStraightLine(shape) {
  return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);
}
var ECLinePath = class extends Path_default {
  constructor(opts) {
    super(opts);
    this.type = "ec-line";
  }
  getDefaultStyle() {
    return {
      stroke: tokens_default.color.neutral99,
      fill: null
    };
  }
  getDefaultShape() {
    return new StraightLineShape();
  }
  buildPath(ctx, shape) {
    if (isStraightLine(shape)) {
      straightLineProto.buildPath.call(this, ctx, shape);
    } else {
      bezierCurveProto.buildPath.call(this, ctx, shape);
    }
  }
  pointAt(t) {
    if (isStraightLine(this.shape)) {
      return straightLineProto.pointAt.call(this, t);
    } else {
      return bezierCurveProto.pointAt.call(this, t);
    }
  }
  tangentAt(t) {
    const shape = this.shape;
    const p = isStraightLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : bezierCurveProto.tangentAt.call(this, t);
    return normalize(p, p);
  }
};
var LinePath_default = ECLinePath;

// src/chart/helper/Line.ts
var SYMBOL_CATEGORIES = ["fromSymbol", "toSymbol"];
function makeSymbolTypeKey(symbolCategory) {
  return "_" + symbolCategory + "Type";
}
function makeSymbolTypeValue(name, lineData, idx) {
  const symbolType = lineData.getItemVisual(idx, name);
  if (!symbolType || symbolType === "none") {
    return symbolType;
  }
  const symbolSize = lineData.getItemVisual(idx, name + "Size");
  const symbolRotate = lineData.getItemVisual(idx, name + "Rotate");
  const symbolOffset = lineData.getItemVisual(idx, name + "Offset");
  const symbolKeepAspect = lineData.getItemVisual(idx, name + "KeepAspect");
  const symbolSizeArr = normalizeSymbolSize(symbolSize);
  const symbolOffsetArr = normalizeSymbolOffset(symbolOffset || 0, symbolSizeArr);
  return symbolType + symbolSizeArr + symbolOffsetArr + (symbolRotate || "") + (symbolKeepAspect || "");
}
function createSymbol2(name, lineData, idx) {
  const symbolType = lineData.getItemVisual(idx, name);
  if (!symbolType || symbolType === "none") {
    return;
  }
  const symbolSize = lineData.getItemVisual(idx, name + "Size");
  const symbolRotate = lineData.getItemVisual(idx, name + "Rotate");
  const symbolOffset = lineData.getItemVisual(idx, name + "Offset");
  const symbolKeepAspect = lineData.getItemVisual(idx, name + "KeepAspect");
  const symbolSizeArr = normalizeSymbolSize(symbolSize);
  const symbolOffsetArr = normalizeSymbolOffset(symbolOffset || 0, symbolSizeArr);
  const symbolPath = createSymbol(symbolType, -symbolSizeArr[0] / 2 + symbolOffsetArr[0], -symbolSizeArr[1] / 2 + symbolOffsetArr[1], symbolSizeArr[0], symbolSizeArr[1], null, symbolKeepAspect);
  symbolPath.__specifiedRotation = symbolRotate == null || isNaN(symbolRotate) ? void 0 : +symbolRotate * Math.PI / 180 || 0;
  symbolPath.name = name;
  return symbolPath;
}
function createLine(points4) {
  const line2 = new LinePath_default({
    name: "line",
    subPixelOptimize: true
  });
  setLinePoints(line2.shape, points4);
  return line2;
}
function setLinePoints(targetShape, points4) {
  targetShape.x1 = points4[0][0];
  targetShape.y1 = points4[0][1];
  targetShape.x2 = points4[1][0];
  targetShape.y2 = points4[1][1];
  targetShape.percent = 1;
  const cp1 = points4[2];
  if (cp1) {
    targetShape.cpx1 = cp1[0];
    targetShape.cpy1 = cp1[1];
  } else {
    targetShape.cpx1 = NaN;
    targetShape.cpy1 = NaN;
  }
}
var Line2 = class extends Group_default {
  constructor(lineData, idx, seriesScope) {
    super();
    this._createLine(lineData, idx, seriesScope);
  }
  _createLine(lineData, idx, seriesScope) {
    const seriesModel = lineData.hostModel;
    const linePoints = lineData.getItemLayout(idx);
    const z2 = lineData.getItemVisual(idx, "z2");
    const line2 = createLine(linePoints);
    line2.shape.percent = 0;
    initProps(line2, {
      z2: retrieve2(z2, 0),
      shape: {
        percent: 1
      }
    }, seriesModel, idx);
    this.add(line2);
    each(SYMBOL_CATEGORIES, function(symbolCategory) {
      const symbol = createSymbol2(symbolCategory, lineData, idx);
      this.add(symbol);
      this[makeSymbolTypeKey(symbolCategory)] = makeSymbolTypeValue(symbolCategory, lineData, idx);
    }, this);
    this._updateCommonStl(lineData, idx, seriesScope);
  }
  updateData(lineData, idx, seriesScope) {
    const seriesModel = lineData.hostModel;
    const line2 = this.childOfName("line");
    const linePoints = lineData.getItemLayout(idx);
    const target = {
      shape: {}
    };
    setLinePoints(target.shape, linePoints);
    updateProps(line2, target, seriesModel, idx);
    each(SYMBOL_CATEGORIES, function(symbolCategory) {
      const symbolType = makeSymbolTypeValue(symbolCategory, lineData, idx);
      const key = makeSymbolTypeKey(symbolCategory);
      if (this[key] !== symbolType) {
        this.remove(this.childOfName(symbolCategory));
        const symbol = createSymbol2(symbolCategory, lineData, idx);
        this.add(symbol);
      }
      this[key] = symbolType;
    }, this);
    this._updateCommonStl(lineData, idx, seriesScope);
  }
  getLinePath() {
    return this.childAt(0);
  }
  _updateCommonStl(lineData, idx, seriesScope) {
    const seriesModel = lineData.hostModel;
    const line2 = this.childOfName("line");
    let emphasisLineStyle = seriesScope && seriesScope.emphasisLineStyle;
    let blurLineStyle = seriesScope && seriesScope.blurLineStyle;
    let selectLineStyle = seriesScope && seriesScope.selectLineStyle;
    let labelStatesModels = seriesScope && seriesScope.labelStatesModels;
    let emphasisDisabled = seriesScope && seriesScope.emphasisDisabled;
    let focus = seriesScope && seriesScope.focus;
    let blurScope = seriesScope && seriesScope.blurScope;
    if (!seriesScope || lineData.hasItemOption) {
      const itemModel = lineData.getItemModel(idx);
      const emphasisModel = itemModel.getModel("emphasis");
      emphasisLineStyle = emphasisModel.getModel("lineStyle").getLineStyle();
      blurLineStyle = itemModel.getModel(["blur", "lineStyle"]).getLineStyle();
      selectLineStyle = itemModel.getModel(["select", "lineStyle"]).getLineStyle();
      emphasisDisabled = emphasisModel.get("disabled");
      focus = emphasisModel.get("focus");
      blurScope = emphasisModel.get("blurScope");
      labelStatesModels = getLabelStatesModels(itemModel);
    }
    const lineStyle = lineData.getItemVisual(idx, "style");
    const visualColor = lineStyle.stroke;
    line2.useStyle(lineStyle);
    line2.style.fill = null;
    line2.style.strokeNoScale = true;
    line2.ensureState("emphasis").style = emphasisLineStyle;
    line2.ensureState("blur").style = blurLineStyle;
    line2.ensureState("select").style = selectLineStyle;
    each(SYMBOL_CATEGORIES, function(symbolCategory) {
      const symbol = this.childOfName(symbolCategory);
      if (symbol) {
        symbol.setColor(visualColor);
        symbol.style.opacity = lineStyle.opacity;
        for (let i = 0; i < SPECIAL_STATES.length; i++) {
          const stateName = SPECIAL_STATES[i];
          const lineState = line2.getState(stateName);
          if (lineState) {
            const lineStateStyle = lineState.style || {};
            const state = symbol.ensureState(stateName);
            const stateStyle = state.style || (state.style = {});
            if (lineStateStyle.stroke != null) {
              stateStyle[symbol.__isEmptyBrush ? "stroke" : "fill"] = lineStateStyle.stroke;
            }
            if (lineStateStyle.opacity != null) {
              stateStyle.opacity = lineStateStyle.opacity;
            }
          }
        }
        symbol.markRedraw();
      }
    }, this);
    const rawVal = seriesModel.getRawValue(idx);
    setLabelStyle(this, labelStatesModels, {
      labelDataIndex: idx,
      labelFetcher: {
        getFormattedLabel(dataIndex, stateName) {
          return seriesModel.getFormattedLabel(dataIndex, stateName, lineData.dataType);
        }
      },
      inheritColor: visualColor || tokens_default.color.neutral99,
      defaultOpacity: lineStyle.opacity,
      defaultText: (rawVal == null ? lineData.getName(idx) : isFinite(rawVal) ? round(rawVal) : rawVal) + ""
    });
    const label = this.getTextContent();
    if (label) {
      const labelNormalModel = labelStatesModels.normal;
      label.__align = label.style.align;
      label.__verticalAlign = label.style.verticalAlign;
      label.__position = labelNormalModel.get("position") || "middle";
      let distance2 = labelNormalModel.get("distance");
      if (!isArray(distance2)) {
        distance2 = [distance2, distance2];
      }
      label.__labelDistance = distance2;
    }
    this.setTextConfig({
      position: null,
      local: true,
      inside: false
    });
    toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
  }
  highlight() {
    enterEmphasis(this);
  }
  downplay() {
    leaveEmphasis(this);
  }
  updateLayout(lineData, idx) {
    this.setLinePoints(lineData.getItemLayout(idx));
  }
  setLinePoints(points4) {
    const linePath = this.childOfName("line");
    setLinePoints(linePath.shape, points4);
    linePath.dirty();
  }
  beforeUpdate() {
    const lineGroup = this;
    const symbolFrom = lineGroup.childOfName("fromSymbol");
    const symbolTo = lineGroup.childOfName("toSymbol");
    const label = lineGroup.getTextContent();
    if (!symbolFrom && !symbolTo && (!label || label.ignore)) {
      return;
    }
    let invScale = 1;
    let parentNode2 = this.parent;
    while (parentNode2) {
      if (parentNode2.scaleX) {
        invScale /= parentNode2.scaleX;
      }
      parentNode2 = parentNode2.parent;
    }
    const line2 = lineGroup.childOfName("line");
    if (!this.__dirty && !line2.__dirty) {
      return;
    }
    const percent = line2.shape.percent;
    const fromPos = line2.pointAt(0);
    const toPos = line2.pointAt(percent);
    const d = sub([], toPos, fromPos);
    normalize(d, d);
    function setSymbolRotation(symbol, percent2) {
      const specifiedRotation = symbol.__specifiedRotation;
      if (specifiedRotation == null) {
        const tangent = line2.tangentAt(percent2);
        symbol.attr("rotation", (percent2 === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
      } else {
        symbol.attr("rotation", specifiedRotation);
      }
    }
    if (symbolFrom) {
      symbolFrom.setPosition(fromPos);
      setSymbolRotation(symbolFrom, 0);
      symbolFrom.scaleX = symbolFrom.scaleY = invScale * percent;
      symbolFrom.markRedraw();
    }
    if (symbolTo) {
      symbolTo.setPosition(toPos);
      setSymbolRotation(symbolTo, 1);
      symbolTo.scaleX = symbolTo.scaleY = invScale * percent;
      symbolTo.markRedraw();
    }
    if (label && !label.ignore) {
      label.x = label.y = 0;
      label.originX = label.originY = 0;
      let textAlign;
      let textVerticalAlign;
      const distance2 = label.__labelDistance;
      const distanceX = distance2[0] * invScale;
      const distanceY = distance2[1] * invScale;
      const halfPercent = percent / 2;
      const tangent = line2.tangentAt(halfPercent);
      const n = [tangent[1], -tangent[0]];
      const cp = line2.pointAt(halfPercent);
      if (n[1] > 0) {
        n[0] = -n[0];
        n[1] = -n[1];
      }
      const dir3 = tangent[0] < 0 ? -1 : 1;
      if (label.__position !== "start" && label.__position !== "end") {
        let rotation = -Math.atan2(tangent[1], tangent[0]);
        if (toPos[0] < fromPos[0]) {
          rotation = Math.PI + rotation;
        }
        label.rotation = rotation;
      }
      let dy;
      switch (label.__position) {
        case "insideStartTop":
        case "insideMiddleTop":
        case "insideEndTop":
        case "middle":
          dy = -distanceY;
          textVerticalAlign = "bottom";
          break;
        case "insideStartBottom":
        case "insideMiddleBottom":
        case "insideEndBottom":
          dy = distanceY;
          textVerticalAlign = "top";
          break;
        default:
          dy = 0;
          textVerticalAlign = "middle";
      }
      switch (label.__position) {
        case "end":
          label.x = d[0] * distanceX + toPos[0];
          label.y = d[1] * distanceY + toPos[1];
          textAlign = d[0] > 0.8 ? "left" : d[0] < -0.8 ? "right" : "center";
          textVerticalAlign = d[1] > 0.8 ? "top" : d[1] < -0.8 ? "bottom" : "middle";
          break;
        case "start":
          label.x = -d[0] * distanceX + fromPos[0];
          label.y = -d[1] * distanceY + fromPos[1];
          textAlign = d[0] > 0.8 ? "right" : d[0] < -0.8 ? "left" : "center";
          textVerticalAlign = d[1] > 0.8 ? "bottom" : d[1] < -0.8 ? "top" : "middle";
          break;
        case "insideStartTop":
        case "insideStart":
        case "insideStartBottom":
          label.x = distanceX * dir3 + fromPos[0];
          label.y = fromPos[1] + dy;
          textAlign = tangent[0] < 0 ? "right" : "left";
          label.originX = -distanceX * dir3;
          label.originY = -dy;
          break;
        case "insideMiddleTop":
        case "insideMiddle":
        case "insideMiddleBottom":
        case "middle":
          label.x = cp[0];
          label.y = cp[1] + dy;
          textAlign = "center";
          label.originY = -dy;
          break;
        case "insideEndTop":
        case "insideEnd":
        case "insideEndBottom":
          label.x = -distanceX * dir3 + toPos[0];
          label.y = toPos[1] + dy;
          textAlign = tangent[0] >= 0 ? "right" : "left";
          label.originX = distanceX * dir3;
          label.originY = -dy;
          break;
      }
      label.scaleX = label.scaleY = invScale;
      label.setStyle({
        verticalAlign: label.__verticalAlign || textVerticalAlign,
        align: label.__align || textAlign
      });
    }
  }
};
var Line_default2 = Line2;

// src/chart/helper/LineDraw.ts
var LineDraw = class {
  constructor(LineCtor) {
    this.group = new Group_default();
    this._LineCtor = LineCtor || Line_default2;
  }
  updateData(lineData) {
    this._progressiveEls = null;
    const lineDraw = this;
    const group = lineDraw.group;
    const oldLineData = lineDraw._lineData;
    lineDraw._lineData = lineData;
    if (!oldLineData) {
      group.removeAll();
    }
    const seriesScope = makeSeriesScope2(lineData);
    lineData.diff(oldLineData).add((idx) => {
      this._doAdd(lineData, idx, seriesScope);
    }).update((newIdx, oldIdx) => {
      this._doUpdate(oldLineData, lineData, oldIdx, newIdx, seriesScope);
    }).remove((idx) => {
      group.remove(oldLineData.getItemGraphicEl(idx));
    }).execute();
  }
  updateLayout() {
    const lineData = this._lineData;
    if (!lineData) {
      return;
    }
    lineData.eachItemGraphicEl(function(el, idx) {
      el.updateLayout(lineData, idx);
    }, this);
  }
  incrementalPrepareUpdate(lineData) {
    this._seriesScope = makeSeriesScope2(lineData);
    this._lineData = null;
    this.group.removeAll();
  }
  incrementalUpdate(taskParams, lineData) {
    this._progressiveEls = [];
    function updateIncrementalAndHover(el) {
      if (!el.isGroup && !isEffectObject(el)) {
        el.incremental = true;
        el.ensureState("emphasis").hoverLayer = true;
      }
    }
    for (let idx = taskParams.start; idx < taskParams.end; idx++) {
      const itemLayout = lineData.getItemLayout(idx);
      if (lineNeedsDraw(itemLayout)) {
        const el = new this._LineCtor(lineData, idx, this._seriesScope);
        el.traverse(updateIncrementalAndHover);
        this.group.add(el);
        lineData.setItemGraphicEl(idx, el);
        this._progressiveEls.push(el);
      }
    }
  }
  remove() {
    this.group.removeAll();
  }
  eachRendered(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  }
  _doAdd(lineData, idx, seriesScope) {
    const itemLayout = lineData.getItemLayout(idx);
    if (!lineNeedsDraw(itemLayout)) {
      return;
    }
    const el = new this._LineCtor(lineData, idx, seriesScope);
    lineData.setItemGraphicEl(idx, el);
    this.group.add(el);
  }
  _doUpdate(oldLineData, newLineData, oldIdx, newIdx, seriesScope) {
    let itemEl = oldLineData.getItemGraphicEl(oldIdx);
    if (!lineNeedsDraw(newLineData.getItemLayout(newIdx))) {
      this.group.remove(itemEl);
      return;
    }
    if (!itemEl) {
      itemEl = new this._LineCtor(newLineData, newIdx, seriesScope);
    } else {
      itemEl.updateData(newLineData, newIdx, seriesScope);
    }
    newLineData.setItemGraphicEl(newIdx, itemEl);
    this.group.add(itemEl);
  }
};
function isEffectObject(el) {
  return el.animators && el.animators.length > 0;
}
function makeSeriesScope2(lineData) {
  const hostModel = lineData.hostModel;
  const emphasisModel = hostModel.getModel("emphasis");
  return {
    lineStyle: hostModel.getModel("lineStyle").getLineStyle(),
    emphasisLineStyle: emphasisModel.getModel(["lineStyle"]).getLineStyle(),
    blurLineStyle: hostModel.getModel(["blur", "lineStyle"]).getLineStyle(),
    selectLineStyle: hostModel.getModel(["select", "lineStyle"]).getLineStyle(),
    emphasisDisabled: emphasisModel.get("disabled"),
    blurScope: emphasisModel.get("blurScope"),
    focus: emphasisModel.get("focus"),
    labelStatesModels: getLabelStatesModels(hostModel)
  };
}
function isPointNaN(pt) {
  return isNaN(pt[0]) || isNaN(pt[1]);
}
function lineNeedsDraw(pts) {
  return pts && !isPointNaN(pts[0]) && !isPointNaN(pts[1]);
}
var LineDraw_default = LineDraw;

// src/chart/graph/adjustEdge.ts
var v1 = [];
var v2 = [];
var v3 = [];
var quadraticAt2 = quadraticAt;
var v2DistSquare = distSquare;
var mathAbs6 = Math.abs;
function intersectCurveCircle(curvePoints, center3, radius) {
  const p0 = curvePoints[0];
  const p1 = curvePoints[1];
  const p2 = curvePoints[2];
  let d = Infinity;
  let t;
  const radiusSquare = radius * radius;
  let interval = 0.1;
  for (let _t = 0.1; _t <= 0.9; _t += 0.1) {
    v1[0] = quadraticAt2(p0[0], p1[0], p2[0], _t);
    v1[1] = quadraticAt2(p0[1], p1[1], p2[1], _t);
    const diff = mathAbs6(v2DistSquare(v1, center3) - radiusSquare);
    if (diff < d) {
      d = diff;
      t = _t;
    }
  }
  for (let i = 0; i < 32; i++) {
    const next = t + interval;
    v2[0] = quadraticAt2(p0[0], p1[0], p2[0], t);
    v2[1] = quadraticAt2(p0[1], p1[1], p2[1], t);
    v3[0] = quadraticAt2(p0[0], p1[0], p2[0], next);
    v3[1] = quadraticAt2(p0[1], p1[1], p2[1], next);
    const diff = v2DistSquare(v2, center3) - radiusSquare;
    if (mathAbs6(diff) < 0.01) {
      break;
    }
    const nextDiff = v2DistSquare(v3, center3) - radiusSquare;
    interval /= 2;
    if (diff < 0) {
      if (nextDiff >= 0) {
        t = t + interval;
      } else {
        t = t - interval;
      }
    } else {
      if (nextDiff >= 0) {
        t = t - interval;
      } else {
        t = t + interval;
      }
    }
  }
  return t;
}
function adjustEdge(graph, scale4) {
  const tmp0 = [];
  const quadraticSubdivide2 = quadraticSubdivide;
  const pts = [[], [], []];
  const pts2 = [[], []];
  const v = [];
  scale4 /= 2;
  graph.eachEdge(function(edge, idx) {
    const linePoints = edge.getLayout();
    const fromSymbol = edge.getVisual("fromSymbol");
    const toSymbol = edge.getVisual("toSymbol");
    if (!linePoints.__original) {
      linePoints.__original = [
        clone2(linePoints[0]),
        clone2(linePoints[1])
      ];
      if (linePoints[2]) {
        linePoints.__original.push(clone2(linePoints[2]));
      }
    }
    const originalPoints = linePoints.__original;
    if (linePoints[2] != null) {
      copy(pts[0], originalPoints[0]);
      copy(pts[1], originalPoints[2]);
      copy(pts[2], originalPoints[1]);
      if (fromSymbol && fromSymbol !== "none") {
        const symbolSize = getSymbolSize(edge.node1);
        const t = intersectCurveCircle(pts, originalPoints[0], symbolSize * scale4);
        quadraticSubdivide2(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
        pts[0][0] = tmp0[3];
        pts[1][0] = tmp0[4];
        quadraticSubdivide2(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
        pts[0][1] = tmp0[3];
        pts[1][1] = tmp0[4];
      }
      if (toSymbol && toSymbol !== "none") {
        const symbolSize = getSymbolSize(edge.node2);
        const t = intersectCurveCircle(pts, originalPoints[1], symbolSize * scale4);
        quadraticSubdivide2(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
        pts[1][0] = tmp0[1];
        pts[2][0] = tmp0[2];
        quadraticSubdivide2(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
        pts[1][1] = tmp0[1];
        pts[2][1] = tmp0[2];
      }
      copy(linePoints[0], pts[0]);
      copy(linePoints[1], pts[2]);
      copy(linePoints[2], pts[1]);
    } else {
      copy(pts2[0], originalPoints[0]);
      copy(pts2[1], originalPoints[1]);
      sub(v, pts2[1], pts2[0]);
      normalize(v, v);
      if (fromSymbol && fromSymbol !== "none") {
        const symbolSize = getSymbolSize(edge.node1);
        scaleAndAdd(pts2[0], pts2[0], v, symbolSize * scale4);
      }
      if (toSymbol && toSymbol !== "none") {
        const symbolSize = getSymbolSize(edge.node2);
        scaleAndAdd(pts2[1], pts2[1], v, -symbolSize * scale4);
      }
      copy(linePoints[0], pts2[0]);
      copy(linePoints[1], pts2[1]);
    }
  });
}

// src/component/helper/thumbnailBridge.ts
var inner12 = makeInner();
function getThumbnailBridge(model) {
  if (model) {
    return inner12(model).bridge;
  }
}
function injectThumbnailBridge(model, thumbnailBridge) {
  if (model) {
    inner12(model).bridge = thumbnailBridge;
  }
}

// src/chart/graph/GraphView.ts
function isViewCoordSys(coordSys) {
  return coordSys.type === "view";
}
var GraphView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = GraphView2.type;
  }
  init(ecModel, api2) {
    const symbolDraw = new SymbolDraw_default();
    const lineDraw = new LineDraw_default();
    const group = this.group;
    const mainGroup = new Group_default();
    this._controller = new RoamController_default(api2.getZr());
    this._controllerHost = {
      target: mainGroup
    };
    mainGroup.add(symbolDraw.group);
    mainGroup.add(lineDraw.group);
    group.add(mainGroup);
    this._symbolDraw = symbolDraw;
    this._lineDraw = lineDraw;
    this._mainGroup = mainGroup;
    this._firstRender = true;
  }
  render(seriesModel, ecModel, api2) {
    const coordSys = seriesModel.coordinateSystem;
    let isForceLayout = false;
    this._model = seriesModel;
    this._api = api2;
    this._active = true;
    const thumbnailInfo = this._getThumbnailInfo();
    if (thumbnailInfo) {
      thumbnailInfo.bridge.reset(api2);
    }
    const symbolDraw = this._symbolDraw;
    const lineDraw = this._lineDraw;
    if (isViewCoordSys(coordSys)) {
      const groupNewProp = {
        x: coordSys.x,
        y: coordSys.y,
        scaleX: coordSys.scaleX,
        scaleY: coordSys.scaleY
      };
      if (this._firstRender) {
        this._mainGroup.attr(groupNewProp);
      } else {
        updateProps(this._mainGroup, groupNewProp, seriesModel);
      }
    }
    adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
    const data = seriesModel.getData();
    symbolDraw.updateData(data);
    const edgeData = seriesModel.getEdgeData();
    lineDraw.updateData(edgeData);
    this._updateNodeAndLinkScale();
    this._updateController(null, seriesModel, api2);
    clearTimeout(this._layoutTimeout);
    const forceLayout2 = seriesModel.forceLayout;
    const layoutAnimation = seriesModel.get(["force", "layoutAnimation"]);
    if (forceLayout2) {
      isForceLayout = true;
      this._startForceLayoutIteration(forceLayout2, api2, layoutAnimation);
    }
    const layout14 = seriesModel.get("layout");
    data.graph.eachNode((node) => {
      const idx = node.dataIndex;
      const el = node.getGraphicEl();
      const itemModel = node.getModel();
      if (!el) {
        return;
      }
      el.off("drag").off("dragend");
      const draggable = itemModel.get("draggable");
      if (draggable) {
        el.on("drag", (e2) => {
          switch (layout14) {
            case "force":
              forceLayout2.warmUp();
              !this._layouting && this._startForceLayoutIteration(forceLayout2, api2, layoutAnimation);
              forceLayout2.setFixed(idx);
              data.setItemLayout(idx, [el.x, el.y]);
              break;
            case "circular":
              data.setItemLayout(idx, [el.x, el.y]);
              node.setLayout({fixed: true}, true);
              circularLayout(seriesModel, "symbolSize", node, [e2.offsetX, e2.offsetY]);
              this.updateLayout(seriesModel);
              break;
            case "none":
            default:
              data.setItemLayout(idx, [el.x, el.y]);
              simpleLayoutEdge(seriesModel.getGraph(), seriesModel);
              this.updateLayout(seriesModel);
              break;
          }
        }).on("dragend", () => {
          if (forceLayout2) {
            forceLayout2.setUnfixed(idx);
          }
        });
      }
      el.setDraggable(draggable, !!itemModel.get("cursor"));
      const focus = itemModel.get(["emphasis", "focus"]);
      if (focus === "adjacency") {
        getECData(el).focus = node.getAdjacentDataIndices();
      }
    });
    data.graph.eachEdge(function(edge) {
      const el = edge.getGraphicEl();
      const focus = edge.getModel().get(["emphasis", "focus"]);
      if (!el) {
        return;
      }
      if (focus === "adjacency") {
        getECData(el).focus = {
          edge: [edge.dataIndex],
          node: [edge.node1.dataIndex, edge.node2.dataIndex]
        };
      }
    });
    const circularRotateLabel = seriesModel.get("layout") === "circular" && seriesModel.get(["circular", "rotateLabel"]);
    const cx = data.getLayout("cx");
    const cy = data.getLayout("cy");
    data.graph.eachNode((node) => {
      rotateNodeLabel(node, circularRotateLabel, cx, cy);
    });
    this._firstRender = false;
    if (!isForceLayout) {
      this._renderThumbnail(seriesModel, api2, this._symbolDraw, this._lineDraw);
    }
  }
  dispose() {
    this.remove();
    this._controller && this._controller.dispose();
    this._controllerHost = null;
  }
  _startForceLayoutIteration(forceLayout2, api2, layoutAnimation) {
    const self2 = this;
    let firstRendered = false;
    (function step() {
      forceLayout2.step(function(stopped) {
        self2.updateLayout(self2._model);
        if (stopped || !firstRendered) {
          firstRendered = true;
          self2._renderThumbnail(self2._model, api2, self2._symbolDraw, self2._lineDraw);
        }
        (self2._layouting = !stopped) && (layoutAnimation ? self2._layoutTimeout = setTimeout(step, 16) : step());
      });
    })();
  }
  _updateController(clipRect, seriesModel, api2) {
    const controller = this._controller;
    const controllerHost = this._controllerHost;
    const coordSys = seriesModel.coordinateSystem;
    if (!isViewCoordSys(coordSys)) {
      controller.disable();
      return;
    }
    controller.enable(seriesModel.get("roam"), {
      api: api2,
      zInfo: {component: seriesModel},
      triggerInfo: {
        roamTrigger: seriesModel.get("roamTrigger"),
        isInSelf: (e2, x, y) => coordSys.containPoint([x, y]),
        isInClip: (e2, x, y) => !clipRect || clipRect.contain(x, y)
      }
    });
    controllerHost.zoomLimit = seriesModel.get("scaleLimit");
    controllerHost.zoom = coordSys.getZoom();
    controller.off("pan").off("zoom").on("pan", (e2) => {
      api2.dispatchAction({
        seriesId: seriesModel.id,
        type: "graphRoam",
        dx: e2.dx,
        dy: e2.dy
      });
    }).on("zoom", (e2) => {
      api2.dispatchAction({
        seriesId: seriesModel.id,
        type: "graphRoam",
        zoom: e2.scale,
        originX: e2.originX,
        originY: e2.originY
      });
    });
  }
  updateViewOnPan(seriesModel, api2, params) {
    if (!this._active) {
      return;
    }
    updateViewOnPan(this._controllerHost, params.dx, params.dy);
    this._updateThumbnailWindow();
  }
  updateViewOnZoom(seriesModel, api2, params) {
    if (!this._active) {
      return;
    }
    updateViewOnZoom(this._controllerHost, params.zoom, params.originX, params.originY);
    this._updateNodeAndLinkScale();
    adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
    this._lineDraw.updateLayout();
    api2.updateLabelLayout();
    this._updateThumbnailWindow();
  }
  _updateNodeAndLinkScale() {
    const seriesModel = this._model;
    const data = seriesModel.getData();
    const nodeScale = getNodeGlobalScale(seriesModel);
    data.eachItemGraphicEl(function(el, idx) {
      el && el.setSymbolScale(nodeScale);
    });
  }
  updateLayout(seriesModel) {
    if (!this._active) {
      return;
    }
    adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
    this._symbolDraw.updateLayout();
    this._lineDraw.updateLayout();
  }
  remove() {
    this._active = false;
    clearTimeout(this._layoutTimeout);
    this._layouting = false;
    this._layoutTimeout = null;
    this._symbolDraw && this._symbolDraw.remove();
    this._lineDraw && this._lineDraw.remove();
    this._controller && this._controller.disable();
  }
  _getThumbnailInfo() {
    const model = this._model;
    const coordSys = model.coordinateSystem;
    if (coordSys.type !== "view") {
      return;
    }
    const bridge = getThumbnailBridge(model);
    if (!bridge) {
      return;
    }
    return {
      bridge,
      coordSys
    };
  }
  _updateThumbnailWindow() {
    const info = this._getThumbnailInfo();
    if (info) {
      info.bridge.updateWindow(info.coordSys.transform, this._api);
    }
  }
  _renderThumbnail(seriesModel, api2, symbolDraw, lineDraw) {
    const info = this._getThumbnailInfo();
    if (!info) {
      return;
    }
    const bridgeGroup = new Group_default();
    const symbolNodes = symbolDraw.group.children();
    const lineNodes = lineDraw.group.children();
    const lineGroup = new Group_default();
    const symbolGroup = new Group_default();
    bridgeGroup.add(symbolGroup);
    bridgeGroup.add(lineGroup);
    for (let i = 0; i < symbolNodes.length; i++) {
      const node = symbolNodes[i];
      const sub2 = node.children()[0];
      const x = node.x;
      const y = node.y;
      const subShape = clone(sub2.shape);
      const shape = extend(subShape, {
        width: sub2.scaleX,
        height: sub2.scaleY,
        x: x - sub2.scaleX / 2,
        y: y - sub2.scaleY / 2
      });
      const style = clone(sub2.style);
      const subThumbnail = new sub2.constructor({
        shape,
        style,
        z2: 151
      });
      symbolGroup.add(subThumbnail);
    }
    for (let i = 0; i < lineNodes.length; i++) {
      const node = lineNodes[i];
      const line2 = node.children()[0];
      const style = clone(line2.style);
      const shape = clone(line2.shape);
      const lineThumbnail = new LinePath_default({
        style,
        shape,
        z2: 151
      });
      lineGroup.add(lineThumbnail);
    }
    info.bridge.renderContent({
      api: api2,
      roamType: seriesModel.get("roam"),
      viewportRect: null,
      group: bridgeGroup,
      targetTrans: info.coordSys.transform
    });
  }
};
var GraphView = GraphView2;
GraphView.type = "graph";
var GraphView_default = GraphView;

// src/data/Graph.ts
function generateNodeKey(id) {
  return "_EC_" + id;
}
var Graph = class {
  constructor(directed) {
    this.type = "graph";
    this.nodes = [];
    this.edges = [];
    this._nodesMap = {};
    this._edgesMap = {};
    this._directed = directed || false;
  }
  isDirected() {
    return this._directed;
  }
  addNode(id, dataIndex) {
    id = id == null ? "" + dataIndex : "" + id;
    const nodesMap = this._nodesMap;
    if (nodesMap[generateNodeKey(id)]) {
      if (true) {
        console.error("Graph nodes have duplicate name or id");
      }
      return;
    }
    const node = new GraphNode(id, dataIndex);
    node.hostGraph = this;
    this.nodes.push(node);
    nodesMap[generateNodeKey(id)] = node;
    return node;
  }
  getNodeByIndex(dataIndex) {
    const rawIdx = this.data.getRawIndex(dataIndex);
    return this.nodes[rawIdx];
  }
  getNodeById(id) {
    return this._nodesMap[generateNodeKey(id)];
  }
  addEdge(n1, n2, dataIndex) {
    const nodesMap = this._nodesMap;
    const edgesMap = this._edgesMap;
    if (isNumber(n1)) {
      n1 = this.nodes[n1];
    }
    if (isNumber(n2)) {
      n2 = this.nodes[n2];
    }
    if (!(n1 instanceof GraphNode)) {
      n1 = nodesMap[generateNodeKey(n1)];
    }
    if (!(n2 instanceof GraphNode)) {
      n2 = nodesMap[generateNodeKey(n2)];
    }
    if (!n1 || !n2) {
      return;
    }
    const key = n1.id + "-" + n2.id;
    const edge = new GraphEdge(n1, n2, dataIndex);
    edge.hostGraph = this;
    if (this._directed) {
      n1.outEdges.push(edge);
      n2.inEdges.push(edge);
    }
    n1.edges.push(edge);
    if (n1 !== n2) {
      n2.edges.push(edge);
    }
    this.edges.push(edge);
    edgesMap[key] = edge;
    return edge;
  }
  getEdgeByIndex(dataIndex) {
    const rawIdx = this.edgeData.getRawIndex(dataIndex);
    return this.edges[rawIdx];
  }
  getEdge(n1, n2) {
    if (n1 instanceof GraphNode) {
      n1 = n1.id;
    }
    if (n2 instanceof GraphNode) {
      n2 = n2.id;
    }
    const edgesMap = this._edgesMap;
    if (this._directed) {
      return edgesMap[n1 + "-" + n2];
    } else {
      return edgesMap[n1 + "-" + n2] || edgesMap[n2 + "-" + n1];
    }
  }
  eachNode(cb, context) {
    const nodes = this.nodes;
    const len2 = nodes.length;
    for (let i = 0; i < len2; i++) {
      if (nodes[i].dataIndex >= 0) {
        cb.call(context, nodes[i], i);
      }
    }
  }
  eachEdge(cb, context) {
    const edges = this.edges;
    const len2 = edges.length;
    for (let i = 0; i < len2; i++) {
      if (edges[i].dataIndex >= 0 && edges[i].node1.dataIndex >= 0 && edges[i].node2.dataIndex >= 0) {
        cb.call(context, edges[i], i);
      }
    }
  }
  breadthFirstTraverse(cb, startNode, direction, context) {
    if (!(startNode instanceof GraphNode)) {
      startNode = this._nodesMap[generateNodeKey(startNode)];
    }
    if (!startNode) {
      return;
    }
    const edgeType = direction === "out" ? "outEdges" : direction === "in" ? "inEdges" : "edges";
    for (let i = 0; i < this.nodes.length; i++) {
      this.nodes[i].__visited = false;
    }
    if (cb.call(context, startNode, null)) {
      return;
    }
    const queue = [startNode];
    while (queue.length) {
      const currentNode = queue.shift();
      const edges = currentNode[edgeType];
      for (let i = 0; i < edges.length; i++) {
        const e2 = edges[i];
        const otherNode = e2.node1 === currentNode ? e2.node2 : e2.node1;
        if (!otherNode.__visited) {
          if (cb.call(context, otherNode, currentNode)) {
            return;
          }
          queue.push(otherNode);
          otherNode.__visited = true;
        }
      }
    }
  }
  update() {
    const data = this.data;
    const edgeData = this.edgeData;
    const nodes = this.nodes;
    const edges = this.edges;
    for (let i = 0, len2 = nodes.length; i < len2; i++) {
      nodes[i].dataIndex = -1;
    }
    for (let i = 0, len2 = data.count(); i < len2; i++) {
      nodes[data.getRawIndex(i)].dataIndex = i;
    }
    edgeData.filterSelf(function(idx) {
      const edge = edges[edgeData.getRawIndex(idx)];
      return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0;
    });
    for (let i = 0, len2 = edges.length; i < len2; i++) {
      edges[i].dataIndex = -1;
    }
    for (let i = 0, len2 = edgeData.count(); i < len2; i++) {
      edges[edgeData.getRawIndex(i)].dataIndex = i;
    }
  }
  clone() {
    const graph = new Graph(this._directed);
    const nodes = this.nodes;
    const edges = this.edges;
    for (let i = 0; i < nodes.length; i++) {
      graph.addNode(nodes[i].id, nodes[i].dataIndex);
    }
    for (let i = 0; i < edges.length; i++) {
      const e2 = edges[i];
      graph.addEdge(e2.node1.id, e2.node2.id, e2.dataIndex);
    }
    return graph;
  }
};
var GraphNode = class {
  constructor(id, dataIndex) {
    this.inEdges = [];
    this.outEdges = [];
    this.edges = [];
    this.dataIndex = -1;
    this.id = id == null ? "" : id;
    this.dataIndex = dataIndex == null ? -1 : dataIndex;
  }
  degree() {
    return this.edges.length;
  }
  inDegree() {
    return this.inEdges.length;
  }
  outDegree() {
    return this.outEdges.length;
  }
  getModel(path) {
    if (this.dataIndex < 0) {
      return;
    }
    const graph = this.hostGraph;
    const itemModel = graph.data.getItemModel(this.dataIndex);
    return itemModel.getModel(path);
  }
  getAdjacentDataIndices() {
    const dataIndices = {
      edge: [],
      node: []
    };
    for (let i = 0; i < this.edges.length; i++) {
      const adjacentEdge = this.edges[i];
      if (adjacentEdge.dataIndex < 0) {
        continue;
      }
      dataIndices.edge.push(adjacentEdge.dataIndex);
      dataIndices.node.push(adjacentEdge.node1.dataIndex, adjacentEdge.node2.dataIndex);
    }
    return dataIndices;
  }
  getTrajectoryDataIndices() {
    const connectedEdgesMap = createHashMap();
    const connectedNodesMap = createHashMap();
    for (let i = 0, len2 = this.edges.length; i < len2; i++) {
      const adjacentEdge = this.edges[i];
      if (adjacentEdge.dataIndex < 0) {
        continue;
      }
      connectedEdgesMap.set(adjacentEdge.dataIndex, true);
      const sourceNodesQueue = [adjacentEdge.node1];
      const targetNodesQueue = [adjacentEdge.node2];
      let nodeIteratorIndex = 0;
      while (nodeIteratorIndex < sourceNodesQueue.length) {
        const sourceNode = sourceNodesQueue[nodeIteratorIndex];
        nodeIteratorIndex++;
        connectedNodesMap.set(sourceNode.dataIndex, true);
        const sourceNodeInEdges = sourceNode.inEdges;
        for (let j = 0, len3 = sourceNodeInEdges.length, inEdge, inEdgeDataIndex; j < len3; j++) {
          inEdge = sourceNodeInEdges[j];
          inEdgeDataIndex = inEdge.dataIndex;
          if (inEdgeDataIndex >= 0 && !connectedEdgesMap.hasKey(inEdgeDataIndex)) {
            connectedEdgesMap.set(inEdgeDataIndex, true);
            sourceNodesQueue.push(inEdge.node1);
          }
        }
      }
      nodeIteratorIndex = 0;
      while (nodeIteratorIndex < targetNodesQueue.length) {
        const targetNode = targetNodesQueue[nodeIteratorIndex];
        nodeIteratorIndex++;
        connectedNodesMap.set(targetNode.dataIndex, true);
        const targetNodeOutEdges = targetNode.outEdges;
        for (let j = 0, len3 = targetNodeOutEdges.length, outEdge, outEdgeDataIndex; j < len3; j++) {
          outEdge = targetNodeOutEdges[j];
          outEdgeDataIndex = outEdge.dataIndex;
          if (outEdgeDataIndex >= 0 && !connectedEdgesMap.hasKey(outEdgeDataIndex)) {
            connectedEdgesMap.set(outEdgeDataIndex, true);
            targetNodesQueue.push(outEdge.node2);
          }
        }
      }
    }
    return {
      edge: connectedEdgesMap.keys(),
      node: connectedNodesMap.keys()
    };
  }
};
var GraphEdge = class {
  constructor(n1, n2, dataIndex) {
    this.dataIndex = -1;
    this.node1 = n1;
    this.node2 = n2;
    this.dataIndex = dataIndex == null ? -1 : dataIndex;
  }
  getModel(path) {
    if (this.dataIndex < 0) {
      return;
    }
    const graph = this.hostGraph;
    const itemModel = graph.edgeData.getItemModel(this.dataIndex);
    return itemModel.getModel(path);
  }
  getAdjacentDataIndices() {
    return {
      edge: [this.dataIndex],
      node: [this.node1.dataIndex, this.node2.dataIndex]
    };
  }
  getTrajectoryDataIndices() {
    const connectedEdgesMap = createHashMap();
    const connectedNodesMap = createHashMap();
    connectedEdgesMap.set(this.dataIndex, true);
    const sourceNodes = [this.node1];
    const targetNodes = [this.node2];
    let nodeIteratorIndex = 0;
    while (nodeIteratorIndex < sourceNodes.length) {
      const sourceNode = sourceNodes[nodeIteratorIndex];
      nodeIteratorIndex++;
      connectedNodesMap.set(sourceNode.dataIndex, true);
      const sourceNodeInEdges = sourceNode.inEdges;
      for (let j = 0, len2 = sourceNodeInEdges.length, inEdge, inEdgeDataIndex; j < len2; j++) {
        inEdge = sourceNode.inEdges[j];
        inEdgeDataIndex = inEdge.dataIndex;
        if (inEdgeDataIndex >= 0 && !connectedEdgesMap.hasKey(inEdgeDataIndex)) {
          connectedEdgesMap.set(inEdgeDataIndex, true);
          sourceNodes.push(inEdge.node1);
        }
      }
    }
    nodeIteratorIndex = 0;
    while (nodeIteratorIndex < targetNodes.length) {
      const targetNode = targetNodes[nodeIteratorIndex];
      nodeIteratorIndex++;
      connectedNodesMap.set(targetNode.dataIndex, true);
      const targetNodeOutEdges = targetNode.outEdges;
      for (let j = 0, len2 = targetNodeOutEdges.length, outEdge, outEdgeDataIndex; j < len2; j++) {
        outEdge = targetNode.outEdges[j];
        outEdgeDataIndex = outEdge.dataIndex;
        if (outEdgeDataIndex >= 0 && !connectedEdgesMap.hasKey(outEdgeDataIndex)) {
          connectedEdgesMap.set(outEdgeDataIndex, true);
          targetNodes.push(outEdge.node2);
        }
      }
    }
    return {
      edge: connectedEdgesMap.keys(),
      node: connectedNodesMap.keys()
    };
  }
};
function createGraphDataProxyMixin(hostName, dataName) {
  return {
    getValue(dimension) {
      const data = this[hostName][dataName];
      return data.getStore().get(data.getDimensionIndex(dimension || "value"), this.dataIndex);
    },
    setVisual(key, value) {
      this.dataIndex >= 0 && this[hostName][dataName].setItemVisual(this.dataIndex, key, value);
    },
    getVisual(key) {
      return this[hostName][dataName].getItemVisual(this.dataIndex, key);
    },
    setLayout(layout14, merge2) {
      this.dataIndex >= 0 && this[hostName][dataName].setItemLayout(this.dataIndex, layout14, merge2);
    },
    getLayout() {
      return this[hostName][dataName].getItemLayout(this.dataIndex);
    },
    getGraphicEl() {
      return this[hostName][dataName].getItemGraphicEl(this.dataIndex);
    },
    getRawIndex() {
      return this[hostName][dataName].getRawIndex(this.dataIndex);
    }
  };
}
mixin(GraphNode, createGraphDataProxyMixin("hostGraph", "data"));
mixin(GraphEdge, createGraphDataProxyMixin("hostGraph", "edgeData"));
var Graph_default = Graph;

// src/chart/helper/createGraphFromNodeEdge.ts
function createGraphFromNodeEdge(nodes, edges, seriesModel, directed, beforeLink) {
  const graph = new Graph_default(directed);
  for (let i = 0; i < nodes.length; i++) {
    graph.addNode(retrieve(nodes[i].id, nodes[i].name, i), i);
  }
  const linkNameList = [];
  const validEdges = [];
  let linkCount = 0;
  for (let i = 0; i < edges.length; i++) {
    const link = edges[i];
    const source = link.source;
    const target = link.target;
    if (graph.addEdge(source, target, linkCount)) {
      validEdges.push(link);
      linkNameList.push(retrieve(convertOptionIdName(link.id, null), source + " > " + target));
      linkCount++;
    }
  }
  const coordSys = seriesModel.get("coordinateSystem");
  let nodeData;
  if (coordSys === "cartesian2d" || coordSys === "polar" || coordSys === "matrix") {
    nodeData = createSeriesData_default(nodes, seriesModel);
  } else {
    const coordSysCtor = CoordinateSystem_default.get(coordSys);
    const coordDimensions = coordSysCtor ? coordSysCtor.dimensions || [] : [];
    if (indexOf(coordDimensions, "value") < 0) {
      coordDimensions.concat(["value"]);
    }
    const {dimensions} = prepareSeriesDataSchema(nodes, {
      coordDimensions,
      encodeDefine: seriesModel.getEncode()
    });
    nodeData = new SeriesData_default(dimensions, seriesModel);
    nodeData.initData(nodes);
  }
  const edgeData = new SeriesData_default(["value"], seriesModel);
  edgeData.initData(validEdges, linkNameList);
  beforeLink && beforeLink(nodeData, edgeData);
  linkSeriesData_default({
    mainData: nodeData,
    struct: graph,
    structAttr: "graph",
    datas: {node: nodeData, edge: edgeData},
    datasAttr: {node: "data", edge: "edgeData"}
  });
  graph.update();
  return graph;
}

// src/chart/graph/GraphSeries.ts
var GraphSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = GraphSeriesModel2.type;
    this.hasSymbolVisual = true;
  }
  init(option) {
    super.init.apply(this, arguments);
    const self2 = this;
    function getCategoriesData() {
      return self2._categoriesData;
    }
    this.legendVisualProvider = new LegendVisualProvider_default(getCategoriesData, getCategoriesData);
    this.fillDataTextStyle(option.edges || option.links);
    this._updateCategoriesData();
  }
  mergeOption(option) {
    super.mergeOption.apply(this, arguments);
    this.fillDataTextStyle(option.edges || option.links);
    this._updateCategoriesData();
  }
  mergeDefaultAndTheme(option) {
    super.mergeDefaultAndTheme.apply(this, arguments);
    defaultEmphasis(option, "edgeLabel", ["show"]);
  }
  getInitialData(option, ecModel) {
    const edges = option.edges || option.links || [];
    const nodes = option.data || option.nodes || [];
    const self2 = this;
    if (nodes && edges) {
      initCurvenessList(this);
      const graph = createGraphFromNodeEdge(nodes, edges, this, true, beforeLink);
      each(graph.edges, function(edge) {
        createEdgeMapForCurveness(edge.node1, edge.node2, this, edge.dataIndex);
      }, this);
      return graph.data;
    }
    function beforeLink(nodeData, edgeData) {
      nodeData.wrapMethod("getItemModel", function(model) {
        const categoriesModels = self2._categoriesModels;
        const categoryIdx = model.getShallow("category");
        const categoryModel = categoriesModels[categoryIdx];
        if (categoryModel) {
          categoryModel.parentModel = model.parentModel;
          model.parentModel = categoryModel;
        }
        return model;
      });
      const oldGetModel = Model_default.prototype.getModel;
      function newGetModel(path, parentModel) {
        const model = oldGetModel.call(this, path, parentModel);
        model.resolveParentPath = resolveParentPath;
        return model;
      }
      edgeData.wrapMethod("getItemModel", function(model) {
        model.resolveParentPath = resolveParentPath;
        model.getModel = newGetModel;
        return model;
      });
      function resolveParentPath(pathArr) {
        if (pathArr && (pathArr[0] === "label" || pathArr[1] === "label")) {
          const newPathArr = pathArr.slice();
          if (pathArr[0] === "label") {
            newPathArr[0] = "edgeLabel";
          } else if (pathArr[1] === "label") {
            newPathArr[1] = "edgeLabel";
          }
          return newPathArr;
        }
        return pathArr;
      }
    }
  }
  getGraph() {
    return this.getData().graph;
  }
  getEdgeData() {
    return this.getGraph().edgeData;
  }
  getCategoriesData() {
    return this._categoriesData;
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    if (dataType === "edge") {
      const nodeData = this.getData();
      const params = this.getDataParams(dataIndex, dataType);
      const edge = nodeData.graph.getEdgeByIndex(dataIndex);
      const sourceName = nodeData.getName(edge.node1.dataIndex);
      const targetName = nodeData.getName(edge.node2.dataIndex);
      const nameArr = [];
      sourceName != null && nameArr.push(sourceName);
      targetName != null && nameArr.push(targetName);
      return createTooltipMarkup("nameValue", {
        name: nameArr.join(" > "),
        value: params.value,
        noValue: params.value == null
      });
    }
    const nodeMarkup = defaultSeriesFormatTooltip({
      series: this,
      dataIndex,
      multipleSeries
    });
    return nodeMarkup;
  }
  _updateCategoriesData() {
    const categories = map(this.option.categories || [], function(category) {
      return category.value != null ? category : extend({
        value: 0
      }, category);
    });
    const categoriesData = new SeriesData_default(["value"], this);
    categoriesData.initData(categories);
    this._categoriesData = categoriesData;
    this._categoriesModels = categoriesData.mapArray(function(idx) {
      return categoriesData.getItemModel(idx);
    });
  }
  setZoom(zoom) {
    this.option.zoom = zoom;
  }
  setCenter(center3) {
    this.option.center = center3;
  }
  isAnimationEnabled() {
    return super.isAnimationEnabled() && !(this.get("layout") === "force" && this.get(["force", "layoutAnimation"]));
  }
};
var GraphSeriesModel = GraphSeriesModel2;
GraphSeriesModel.type = "series.graph";
GraphSeriesModel.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"];
GraphSeriesModel.defaultOption = {
  z: 2,
  coordinateSystem: "view",
  legendHoverLink: true,
  layout: null,
  circular: {
    rotateLabel: false
  },
  force: {
    initLayout: null,
    repulsion: [0, 50],
    gravity: 0.1,
    friction: 0.6,
    edgeLength: 30,
    layoutAnimation: true
  },
  left: "center",
  top: "center",
  symbol: "circle",
  symbolSize: 10,
  edgeSymbol: ["none", "none"],
  edgeSymbolSize: 10,
  edgeLabel: {
    position: "middle",
    distance: 5
  },
  draggable: false,
  roam: false,
  center: null,
  zoom: 1,
  nodeScaleRatio: 0.6,
  label: {
    show: false,
    formatter: "{b}"
  },
  itemStyle: {},
  lineStyle: {
    color: tokens_default.color.neutral50,
    width: 1,
    opacity: 0.5
  },
  emphasis: {
    scale: true,
    label: {
      show: true
    }
  },
  select: {
    itemStyle: {
      borderColor: tokens_default.color.primary
    }
  }
};
var GraphSeries_default = GraphSeriesModel;

// src/chart/graph/install.ts
function install14(registers) {
  registers.registerChartView(GraphView_default);
  registers.registerSeriesModel(GraphSeries_default);
  registers.registerProcessor(categoryFilter);
  registers.registerVisual(categoryVisual);
  registers.registerVisual(graphEdgeVisual);
  registers.registerLayout(graphSimpleLayout);
  registers.registerLayout(registers.PRIORITY.VISUAL.POST_CHART_LAYOUT, graphCircularLayout);
  registers.registerLayout(graphForceLayout);
  registers.registerCoordinateSystem("graphView", {
    dimensions: View_default.dimensions,
    create: createViewCoordSys
  });
  registers.registerAction({
    type: "focusNodeAdjacency",
    event: "focusNodeAdjacency",
    update: "series:focusNodeAdjacency"
  }, noop);
  registers.registerAction({
    type: "unfocusNodeAdjacency",
    event: "unfocusNodeAdjacency",
    update: "series:unfocusNodeAdjacency"
  }, noop);
  registers.registerAction({
    type: "graphRoam",
    event: "graphRoam",
    update: "none"
  }, function(payload, ecModel, api2) {
    ecModel.eachComponent({
      mainType: "series",
      query: payload
    }, function(seriesModel) {
      const graphView = api2.getViewOfSeriesModel(seriesModel);
      if (graphView) {
        if (payload.dx != null && payload.dy != null) {
          graphView.updateViewOnPan(seriesModel, api2, payload);
        }
        if (payload.zoom != null && payload.originX != null && payload.originY != null) {
          graphView.updateViewOnZoom(seriesModel, api2, payload);
        }
      }
      const coordSys = seriesModel.coordinateSystem;
      const res = updateCenterAndZoomInAction(coordSys, payload, seriesModel.get("scaleLimit"));
      seriesModel.setCenter && seriesModel.setCenter(res.center);
      seriesModel.setZoom && seriesModel.setZoom(res.zoom);
    });
  });
}

// src/chart/chord/ChordPiece.ts
var ChordPiece = class extends Sector_default {
  constructor(data, idx, startAngle) {
    super();
    getECData(this).dataType = "node";
    this.z2 = 2;
    const text = new Text_default();
    this.setTextContent(text);
    this.updateData(data, idx, startAngle, true);
  }
  updateData(data, idx, startAngle, firstCreate) {
    const sector = this;
    const node = data.graph.getNodeByIndex(idx);
    const seriesModel = data.hostModel;
    const itemModel = node.getModel();
    const emphasisModel = itemModel.getModel("emphasis");
    const layout14 = data.getItemLayout(idx);
    const shape = extend(getSectorCornerRadius(itemModel.getModel("itemStyle"), layout14, true), layout14);
    const el = this;
    if (isNaN(shape.startAngle)) {
      el.setShape(shape);
      return;
    }
    if (firstCreate) {
      el.setShape(shape);
    } else {
      updateProps(el, {
        shape
      }, seriesModel, idx);
    }
    const sectorShape = extend(getSectorCornerRadius(itemModel.getModel("itemStyle"), layout14, true), layout14);
    sector.setShape(sectorShape);
    sector.useStyle(data.getItemVisual(idx, "style"));
    setStatesStylesFromModel(sector, itemModel);
    this._updateLabel(seriesModel, itemModel, node);
    data.setItemGraphicEl(idx, el);
    setStatesStylesFromModel(el, itemModel, "itemStyle");
    const focus = emphasisModel.get("focus");
    toggleHoverEmphasis(this, focus === "adjacency" ? node.getAdjacentDataIndices() : focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  }
  _updateLabel(seriesModel, itemModel, node) {
    const label = this.getTextContent();
    const layout14 = node.getLayout();
    const midAngle = (layout14.startAngle + layout14.endAngle) / 2;
    const dx = Math.cos(midAngle);
    const dy = Math.sin(midAngle);
    const normalLabelModel = itemModel.getModel("label");
    label.ignore = !normalLabelModel.get("show");
    const labelStateModels = getLabelStatesModels(itemModel);
    const style = node.getVisual("style");
    setLabelStyle(label, labelStateModels, {
      labelFetcher: {
        getFormattedLabel(dataIndex, stateName, dataType, labelDimIndex, formatter, extendParams) {
          return seriesModel.getFormattedLabel(dataIndex, stateName, "node", labelDimIndex, retrieve3(formatter, labelStateModels.normal && labelStateModels.normal.get("formatter"), itemModel.get("name")), extendParams);
        }
      },
      labelDataIndex: node.dataIndex,
      defaultText: node.dataIndex + "",
      inheritColor: style.fill,
      defaultOpacity: style.opacity,
      defaultOutsidePosition: "startArc"
    });
    const labelPosition = normalLabelModel.get("position") || "outside";
    const labelPadding = normalLabelModel.get("distance") || 0;
    let r;
    if (labelPosition === "outside") {
      r = layout14.r + labelPadding;
    } else {
      r = (layout14.r + layout14.r0) / 2;
    }
    this.textConfig = {
      inside: labelPosition !== "outside"
    };
    const align = labelPosition !== "outside" ? normalLabelModel.get("align") || "center" : dx > 0 ? "left" : "right";
    const verticalAlign = labelPosition !== "outside" ? normalLabelModel.get("verticalAlign") || "middle" : dy > 0 ? "top" : "bottom";
    label.attr({
      x: dx * r + layout14.cx,
      y: dy * r + layout14.cy,
      rotation: 0,
      style: {
        align,
        verticalAlign
      }
    });
  }
};
var ChordPiece_default = ChordPiece;

// src/chart/chord/ChordEdge.ts
var ChordEdge = class extends Path_default {
  constructor(nodeData, edgeData, edgeIdx, startAngle) {
    super();
    getECData(this).dataType = "edge";
    this.updateData(nodeData, edgeData, edgeIdx, startAngle, true);
  }
  buildPath(ctx, shape) {
    ctx.moveTo(shape.s1[0], shape.s1[1]);
    const ratio = 0.7;
    const clockwise = shape.clockwise;
    ctx.arc(shape.cx, shape.cy, shape.r, shape.sStartAngle, shape.sEndAngle, !clockwise);
    ctx.bezierCurveTo((shape.cx - shape.s2[0]) * ratio + shape.s2[0], (shape.cy - shape.s2[1]) * ratio + shape.s2[1], (shape.cx - shape.t1[0]) * ratio + shape.t1[0], (shape.cy - shape.t1[1]) * ratio + shape.t1[1], shape.t1[0], shape.t1[1]);
    ctx.arc(shape.cx, shape.cy, shape.r, shape.tStartAngle, shape.tEndAngle, !clockwise);
    ctx.bezierCurveTo((shape.cx - shape.t2[0]) * ratio + shape.t2[0], (shape.cy - shape.t2[1]) * ratio + shape.t2[1], (shape.cx - shape.s1[0]) * ratio + shape.s1[0], (shape.cy - shape.s1[1]) * ratio + shape.s1[1], shape.s1[0], shape.s1[1]);
    ctx.closePath();
  }
  updateData(nodeData, edgeData, edgeIdx, startAngle, firstCreate) {
    const seriesModel = nodeData.hostModel;
    const edge = edgeData.graph.getEdgeByIndex(edgeIdx);
    const layout14 = edge.getLayout();
    const itemModel = edge.node1.getModel();
    const edgeModel = edgeData.getItemModel(edge.dataIndex);
    const lineStyle = edgeModel.getModel("lineStyle");
    const emphasisModel = edgeModel.getModel("emphasis");
    const focus = emphasisModel.get("focus");
    const shape = extend(getSectorCornerRadius(itemModel.getModel("itemStyle"), layout14, true), layout14);
    const el = this;
    if (isNaN(shape.sStartAngle) || isNaN(shape.tStartAngle)) {
      el.setShape(shape);
      return;
    }
    if (firstCreate) {
      el.setShape(shape);
      applyEdgeFill(el, edge, nodeData, lineStyle);
    } else {
      saveOldStyle(el);
      applyEdgeFill(el, edge, nodeData, lineStyle);
      updateProps(el, {
        shape
      }, seriesModel, edgeIdx);
    }
    toggleHoverEmphasis(this, focus === "adjacency" ? edge.getAdjacentDataIndices() : focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    setStatesStylesFromModel(el, edgeModel, "lineStyle");
    edgeData.setItemGraphicEl(edge.dataIndex, el);
  }
};
function applyEdgeFill(edgeShape, edge, nodeData, lineStyleModel) {
  const node1 = edge.node1;
  const node2 = edge.node2;
  const edgeStyle = edgeShape.style;
  edgeShape.setStyle(lineStyleModel.getLineStyle());
  const color4 = lineStyleModel.get("color");
  switch (color4) {
    case "source":
      edgeStyle.fill = nodeData.getItemVisual(node1.dataIndex, "style").fill;
      edgeStyle.decal = node1.getVisual("style").decal;
      break;
    case "target":
      edgeStyle.fill = nodeData.getItemVisual(node2.dataIndex, "style").fill;
      edgeStyle.decal = node2.getVisual("style").decal;
      break;
    case "gradient":
      const sourceColor = nodeData.getItemVisual(node1.dataIndex, "style").fill;
      const targetColor = nodeData.getItemVisual(node2.dataIndex, "style").fill;
      if (isString(sourceColor) && isString(targetColor)) {
        const shape = edgeShape.shape;
        const sMidX = (shape.s1[0] + shape.s2[0]) / 2;
        const sMidY = (shape.s1[1] + shape.s2[1]) / 2;
        const tMidX = (shape.t1[0] + shape.t2[0]) / 2;
        const tMidY = (shape.t1[1] + shape.t2[1]) / 2;
        edgeStyle.fill = new LinearGradient_default(sMidX, sMidY, tMidX, tMidY, [
          {offset: 0, color: sourceColor},
          {offset: 1, color: targetColor}
        ], true);
      }
      break;
  }
}

// src/chart/chord/ChordView.ts
var RADIAN3 = Math.PI / 180;
var ChordView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = ChordView2.type;
  }
  init(ecModel, api2) {
  }
  render(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    const oldData = this._data;
    const group = this.group;
    const startAngle = -seriesModel.get("startAngle") * RADIAN3;
    data.diff(oldData).add((newIdx) => {
      const layout14 = data.getItemLayout(newIdx);
      if (layout14) {
        const el = new ChordPiece_default(data, newIdx, startAngle);
        getECData(el).dataIndex = newIdx;
        group.add(el);
      }
    }).update((newIdx, oldIdx) => {
      let el = oldData.getItemGraphicEl(oldIdx);
      const layout14 = data.getItemLayout(newIdx);
      if (!layout14) {
        el && removeElementWithFadeOut(el, seriesModel, oldIdx);
        return;
      }
      if (!el) {
        el = new ChordPiece_default(data, newIdx, startAngle);
      } else {
        el.updateData(data, newIdx, startAngle);
      }
      group.add(el);
    }).remove((oldIdx) => {
      const el = oldData.getItemGraphicEl(oldIdx);
      el && removeElementWithFadeOut(el, seriesModel, oldIdx);
    }).execute();
    if (!oldData) {
      const center3 = seriesModel.get("center");
      this.group.scaleX = 0.01;
      this.group.scaleY = 0.01;
      this.group.originX = parsePercent2(center3[0], api2.getWidth());
      this.group.originY = parsePercent2(center3[1], api2.getHeight());
      initProps(this.group, {
        scaleX: 1,
        scaleY: 1
      }, seriesModel);
    }
    this._data = data;
    this.renderEdges(seriesModel, startAngle);
  }
  renderEdges(seriesModel, startAngle) {
    const nodeData = seriesModel.getData();
    const edgeData = seriesModel.getEdgeData();
    const oldData = this._edgeData;
    const group = this.group;
    edgeData.diff(oldData).add(function(newIdx) {
      const el = new ChordEdge(nodeData, edgeData, newIdx, startAngle);
      getECData(el).dataIndex = newIdx;
      group.add(el);
    }).update(function(newIdx, oldIdx) {
      const el = oldData.getItemGraphicEl(oldIdx);
      el.updateData(nodeData, edgeData, newIdx, startAngle);
      group.add(el);
    }).remove(function(oldIdx) {
      const el = oldData.getItemGraphicEl(oldIdx);
      el && removeElementWithFadeOut(el, seriesModel, oldIdx);
    }).execute();
    this._edgeData = edgeData;
  }
  dispose() {
  }
};
var ChordView = ChordView2;
ChordView.type = "chord";
var ChordView_default = ChordView;

// src/chart/chord/ChordSeries.ts
var ChordSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = ChordSeriesModel2.type;
  }
  init(option) {
    super.init.apply(this, arguments);
    this.fillDataTextStyle(option.edges || option.links);
    this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this));
  }
  mergeOption(option) {
    super.mergeOption.apply(this, arguments);
    this.fillDataTextStyle(option.edges || option.links);
  }
  getInitialData(option, ecModel) {
    const edges = option.edges || option.links || [];
    const nodes = option.data || option.nodes || [];
    if (nodes && edges) {
      const graph = createGraphFromNodeEdge(nodes, edges, this, true, beforeLink);
      return graph.data;
    }
    function beforeLink(nodeData, edgeData) {
      const oldGetModel = Model_default.prototype.getModel;
      function newGetModel(path, parentModel) {
        const model = oldGetModel.call(this, path, parentModel);
        model.resolveParentPath = resolveParentPath;
        return model;
      }
      edgeData.wrapMethod("getItemModel", function(model) {
        model.resolveParentPath = resolveParentPath;
        model.getModel = newGetModel;
        return model;
      });
      function resolveParentPath(pathArr) {
        if (pathArr && (pathArr[0] === "label" || pathArr[1] === "label")) {
          const newPathArr = pathArr.slice();
          if (pathArr[0] === "label") {
            newPathArr[0] = "edgeLabel";
          } else if (pathArr[1] === "label") {
            newPathArr[1] = "edgeLabel";
          }
          return newPathArr;
        }
        return pathArr;
      }
    }
  }
  getGraph() {
    return this.getData().graph;
  }
  getEdgeData() {
    return this.getGraph().edgeData;
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    const params = this.getDataParams(dataIndex, dataType);
    if (dataType === "edge") {
      const nodeData = this.getData();
      const edge = nodeData.graph.getEdgeByIndex(dataIndex);
      const sourceName = nodeData.getName(edge.node1.dataIndex);
      const targetName = nodeData.getName(edge.node2.dataIndex);
      const nameArr = [];
      sourceName != null && nameArr.push(sourceName);
      targetName != null && nameArr.push(targetName);
      return createTooltipMarkup("nameValue", {
        name: nameArr.join(" > "),
        value: params.value,
        noValue: params.value == null
      });
    }
    return createTooltipMarkup("nameValue", {
      name: params.name,
      value: params.value,
      noValue: params.value == null
    });
  }
  getDataParams(dataIndex, dataType) {
    const params = super.getDataParams(dataIndex, dataType);
    if (dataType === "node") {
      const nodeData = this.getData();
      const node = this.getGraph().getNodeByIndex(dataIndex);
      if (params.name == null) {
        params.name = nodeData.getName(dataIndex);
      }
      if (params.value == null) {
        const nodeValue = node.getLayout().value;
        params.value = nodeValue;
      }
    }
    return params;
  }
};
var ChordSeriesModel = ChordSeriesModel2;
ChordSeriesModel.type = "series.chord";
ChordSeriesModel.defaultOption = {
  z: 2,
  coordinateSystem: "none",
  legendHoverLink: true,
  colorBy: "data",
  left: 0,
  top: 0,
  right: 0,
  bottom: 0,
  width: null,
  height: null,
  center: ["50%", "50%"],
  radius: ["70%", "80%"],
  clockwise: true,
  startAngle: 90,
  endAngle: "auto",
  minAngle: 0,
  padAngle: 3,
  itemStyle: {
    borderRadius: [0, 0, 5, 5]
  },
  lineStyle: {
    width: 0,
    color: "source",
    opacity: 0.2
  },
  label: {
    show: true,
    position: "outside",
    distance: 5
  },
  emphasis: {
    focus: "adjacency",
    lineStyle: {
      opacity: 0.5
    }
  }
};
var ChordSeries_default = ChordSeriesModel;

// src/chart/chord/chordLayout.ts
var RADIAN4 = Math.PI / 180;
function chordCircularLayout(ecModel, api2) {
  ecModel.eachSeriesByType("chord", function(seriesModel) {
    chordLayout(seriesModel, api2);
  });
}
function chordLayout(seriesModel, api2) {
  const nodeData = seriesModel.getData();
  const nodeGraph = nodeData.graph;
  const edgeData = seriesModel.getEdgeData();
  const edgeCount = edgeData.count();
  if (!edgeCount) {
    return;
  }
  const {cx, cy, r, r0} = getCircleLayout(seriesModel, api2);
  let padAngle = Math.max((seriesModel.get("padAngle") || 0) * RADIAN4, 0);
  let minAngle = Math.max((seriesModel.get("minAngle") || 0) * RADIAN4, 0);
  const startAngle = -seriesModel.get("startAngle") * RADIAN4;
  const endAngle = startAngle + Math.PI * 2;
  const clockwise = seriesModel.get("clockwise");
  const dir3 = clockwise ? 1 : -1;
  const angles = [startAngle, endAngle];
  normalizeArcAngles(angles, !clockwise);
  const [normalizedStartAngle, normalizedEndAngle] = angles;
  const totalAngle = normalizedEndAngle - normalizedStartAngle;
  const allZero = nodeData.getSum("value") === 0 && edgeData.getSum("value") === 0;
  const nodeValues = [];
  let renderedNodeCount = 0;
  nodeGraph.eachEdge(function(edge) {
    const value = allZero ? 1 : edge.getValue("value");
    if (allZero && (value > 0 || minAngle)) {
      renderedNodeCount += 2;
    }
    const node1Index = edge.node1.dataIndex;
    const node2Index = edge.node2.dataIndex;
    nodeValues[node1Index] = (nodeValues[node1Index] || 0) + value;
    nodeValues[node2Index] = (nodeValues[node2Index] || 0) + value;
  });
  let nodeValueSum = 0;
  nodeGraph.eachNode((node) => {
    const dataValue = node.getValue("value");
    if (!isNaN(dataValue)) {
      nodeValues[node.dataIndex] = Math.max(dataValue, nodeValues[node.dataIndex] || 0);
    }
    if (!allZero && (nodeValues[node.dataIndex] > 0 || minAngle)) {
      renderedNodeCount++;
    }
    nodeValueSum += nodeValues[node.dataIndex] || 0;
  });
  if (renderedNodeCount === 0 || nodeValueSum === 0) {
    return;
  }
  if (padAngle * renderedNodeCount >= Math.abs(totalAngle)) {
    padAngle = Math.max(0, (Math.abs(totalAngle) - minAngle * renderedNodeCount) / renderedNodeCount);
  }
  if ((padAngle + minAngle) * renderedNodeCount >= Math.abs(totalAngle)) {
    minAngle = (Math.abs(totalAngle) - padAngle * renderedNodeCount) / renderedNodeCount;
  }
  const unitAngle = (totalAngle - padAngle * renderedNodeCount * dir3) / nodeValueSum;
  let totalDeficit = 0;
  let totalSurplus = 0;
  let totalSurplusSpan = 0;
  let minSurplus = Infinity;
  nodeGraph.eachNode((node) => {
    const value = nodeValues[node.dataIndex] || 0;
    const spanAngle = unitAngle * (nodeValueSum ? value : 1) * dir3;
    if (Math.abs(spanAngle) < minAngle) {
      totalDeficit += minAngle - Math.abs(spanAngle);
    } else {
      minSurplus = Math.min(minSurplus, Math.abs(spanAngle) - minAngle);
      totalSurplus += Math.abs(spanAngle) - minAngle;
      totalSurplusSpan += Math.abs(spanAngle);
    }
    node.setLayout({
      angle: spanAngle,
      value
    });
  });
  let surplusAsMuchAsPossible = false;
  if (totalDeficit > totalSurplus) {
    const scale4 = totalDeficit / totalSurplus;
    nodeGraph.eachNode((node) => {
      const spanAngle = node.getLayout().angle;
      if (Math.abs(spanAngle) >= minAngle) {
        node.setLayout({
          angle: spanAngle * scale4,
          ratio: scale4
        }, true);
      } else {
        node.setLayout({
          angle: minAngle,
          ratio: minAngle === 0 ? 1 : spanAngle / minAngle
        }, true);
      }
    });
  } else {
    nodeGraph.eachNode((node) => {
      if (surplusAsMuchAsPossible) {
        return;
      }
      const spanAngle = node.getLayout().angle;
      const borrowRatio = Math.min(spanAngle / totalSurplusSpan, 1);
      const borrowAngle = borrowRatio * totalDeficit;
      if (spanAngle - borrowAngle < minAngle) {
        surplusAsMuchAsPossible = true;
      }
    });
  }
  let restDeficit = totalDeficit;
  nodeGraph.eachNode((node) => {
    if (restDeficit <= 0) {
      return;
    }
    const spanAngle = node.getLayout().angle;
    if (spanAngle > minAngle && minAngle > 0) {
      const borrowRatio = surplusAsMuchAsPossible ? 1 : Math.min(spanAngle / totalSurplusSpan, 1);
      const maxBorrowAngle = spanAngle - minAngle;
      const borrowAngle = Math.min(maxBorrowAngle, Math.min(restDeficit, totalDeficit * borrowRatio));
      restDeficit -= borrowAngle;
      node.setLayout({
        angle: spanAngle - borrowAngle,
        ratio: (spanAngle - borrowAngle) / spanAngle
      }, true);
    } else if (minAngle > 0) {
      node.setLayout({
        angle: minAngle,
        ratio: spanAngle === 0 ? 1 : minAngle / spanAngle
      }, true);
    }
  });
  let angle = normalizedStartAngle;
  const edgeAccAngle = [];
  nodeGraph.eachNode((node) => {
    const spanAngle = Math.max(node.getLayout().angle, minAngle);
    node.setLayout({
      cx,
      cy,
      r0,
      r,
      startAngle: angle,
      endAngle: angle + spanAngle * dir3,
      clockwise
    }, true);
    edgeAccAngle[node.dataIndex] = angle;
    angle += (spanAngle + padAngle) * dir3;
  });
  nodeGraph.eachEdge((edge) => {
    const value = allZero ? 1 : edge.getValue("value");
    const spanAngle = unitAngle * (nodeValueSum ? value : 1) * dir3;
    const node1Index = edge.node1.dataIndex;
    const sStartAngle = edgeAccAngle[node1Index] || 0;
    const sSpan = Math.abs((edge.node1.getLayout().ratio || 1) * spanAngle);
    const sEndAngle = sStartAngle + sSpan * dir3;
    const s1 = [
      cx + r0 * Math.cos(sStartAngle),
      cy + r0 * Math.sin(sStartAngle)
    ];
    const s2 = [
      cx + r0 * Math.cos(sEndAngle),
      cy + r0 * Math.sin(sEndAngle)
    ];
    const node2Index = edge.node2.dataIndex;
    const tStartAngle = edgeAccAngle[node2Index] || 0;
    const tSpan = Math.abs((edge.node2.getLayout().ratio || 1) * spanAngle);
    const tEndAngle = tStartAngle + tSpan * dir3;
    const t1 = [
      cx + r0 * Math.cos(tStartAngle),
      cy + r0 * Math.sin(tStartAngle)
    ];
    const t2 = [
      cx + r0 * Math.cos(tEndAngle),
      cy + r0 * Math.sin(tEndAngle)
    ];
    edge.setLayout({
      s1,
      s2,
      sStartAngle,
      sEndAngle,
      t1,
      t2,
      tStartAngle,
      tEndAngle,
      cx,
      cy,
      r: r0,
      value,
      clockwise
    });
    edgeAccAngle[node1Index] = sEndAngle;
    edgeAccAngle[node2Index] = tEndAngle;
  });
}

// src/chart/chord/install.ts
function install15(registers) {
  registers.registerChartView(ChordView_default);
  registers.registerSeriesModel(ChordSeries_default);
  registers.registerLayout(registers.PRIORITY.VISUAL.POST_CHART_LAYOUT, chordCircularLayout);
  registers.registerProcessor(dataFilter("chord"));
}

// src/chart/gauge/PointerPath.ts
var PointerShape = class {
  constructor() {
    this.angle = 0;
    this.width = 10;
    this.r = 10;
    this.x = 0;
    this.y = 0;
  }
};
var PointerPath = class extends Path_default {
  constructor(opts) {
    super(opts);
    this.type = "pointer";
  }
  getDefaultShape() {
    return new PointerShape();
  }
  buildPath(ctx, shape) {
    const mathCos6 = Math.cos;
    const mathSin6 = Math.sin;
    const r = shape.r;
    const width = shape.width;
    let angle = shape.angle;
    const x = shape.x - mathCos6(angle) * width * (width >= r / 3 ? 1 : 2);
    const y = shape.y - mathSin6(angle) * width * (width >= r / 3 ? 1 : 2);
    angle = shape.angle - Math.PI / 2;
    ctx.moveTo(x, y);
    ctx.lineTo(shape.x + mathCos6(angle) * width, shape.y + mathSin6(angle) * width);
    ctx.lineTo(shape.x + mathCos6(shape.angle) * r, shape.y + mathSin6(shape.angle) * r);
    ctx.lineTo(shape.x - mathCos6(angle) * width, shape.y - mathSin6(angle) * width);
    ctx.lineTo(x, y);
  }
};
var PointerPath_default = PointerPath;

// src/chart/gauge/GaugeView.ts
function parsePosition(seriesModel, api2) {
  const center3 = seriesModel.get("center");
  const width = api2.getWidth();
  const height = api2.getHeight();
  const size = Math.min(width, height);
  const cx = parsePercent2(center3[0], api2.getWidth());
  const cy = parsePercent2(center3[1], api2.getHeight());
  const r = parsePercent2(seriesModel.get("radius"), size / 2);
  return {
    cx,
    cy,
    r
  };
}
function formatLabel(value, labelFormatter) {
  let label = value == null ? "" : value + "";
  if (labelFormatter) {
    if (isString(labelFormatter)) {
      label = labelFormatter.replace("{value}", label);
    } else if (isFunction(labelFormatter)) {
      label = labelFormatter(value);
    }
  }
  return label;
}
var GaugeView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = GaugeView2.type;
  }
  render(seriesModel, ecModel, api2) {
    this.group.removeAll();
    const colorList = seriesModel.get(["axisLine", "lineStyle", "color"]);
    const posInfo = parsePosition(seriesModel, api2);
    this._renderMain(seriesModel, ecModel, api2, colorList, posInfo);
    this._data = seriesModel.getData();
  }
  dispose() {
  }
  _renderMain(seriesModel, ecModel, api2, colorList, posInfo) {
    const group = this.group;
    const clockwise = seriesModel.get("clockwise");
    let startAngle = -seriesModel.get("startAngle") / 180 * Math.PI;
    let endAngle = -seriesModel.get("endAngle") / 180 * Math.PI;
    const axisLineModel = seriesModel.getModel("axisLine");
    const roundCap = axisLineModel.get("roundCap");
    const MainPath = roundCap ? sausage_default : Sector_default;
    const showAxis = axisLineModel.get("show");
    const lineStyleModel = axisLineModel.getModel("lineStyle");
    const axisLineWidth = lineStyleModel.get("width");
    const angles = [startAngle, endAngle];
    normalizeArcAngles(angles, !clockwise);
    startAngle = angles[0];
    endAngle = angles[1];
    const angleRangeSpan = endAngle - startAngle;
    let prevEndAngle = startAngle;
    const sectors = [];
    for (let i = 0; showAxis && i < colorList.length; i++) {
      const percent = Math.min(Math.max(colorList[i][0], 0), 1);
      endAngle = startAngle + angleRangeSpan * percent;
      const sector = new MainPath({
        shape: {
          startAngle: prevEndAngle,
          endAngle,
          cx: posInfo.cx,
          cy: posInfo.cy,
          clockwise,
          r0: posInfo.r - axisLineWidth,
          r: posInfo.r
        },
        silent: true
      });
      sector.setStyle({
        fill: colorList[i][1]
      });
      sector.setStyle(lineStyleModel.getLineStyle(["color", "width"]));
      sectors.push(sector);
      prevEndAngle = endAngle;
    }
    sectors.reverse();
    each(sectors, (sector) => group.add(sector));
    const getColor2 = function(percent) {
      if (percent <= 0) {
        return colorList[0][1];
      }
      let i;
      for (i = 0; i < colorList.length; i++) {
        if (colorList[i][0] >= percent && (i === 0 ? 0 : colorList[i - 1][0]) < percent) {
          return colorList[i][1];
        }
      }
      return colorList[i - 1][1];
    };
    this._renderTicks(seriesModel, ecModel, api2, getColor2, posInfo, startAngle, endAngle, clockwise, axisLineWidth);
    this._renderTitleAndDetail(seriesModel, ecModel, api2, getColor2, posInfo);
    this._renderAnchor(seriesModel, posInfo);
    this._renderPointer(seriesModel, ecModel, api2, getColor2, posInfo, startAngle, endAngle, clockwise, axisLineWidth);
  }
  _renderTicks(seriesModel, ecModel, api2, getColor2, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {
    const group = this.group;
    const cx = posInfo.cx;
    const cy = posInfo.cy;
    const r = posInfo.r;
    const minVal = +seriesModel.get("min");
    const maxVal = +seriesModel.get("max");
    const splitLineModel = seriesModel.getModel("splitLine");
    const tickModel = seriesModel.getModel("axisTick");
    const labelModel = seriesModel.getModel("axisLabel");
    const splitNumber = seriesModel.get("splitNumber");
    const subSplitNumber = tickModel.get("splitNumber");
    const splitLineLen = parsePercent2(splitLineModel.get("length"), r);
    const tickLen = parsePercent2(tickModel.get("length"), r);
    let angle = startAngle;
    const step = (endAngle - startAngle) / splitNumber;
    const subStep = step / subSplitNumber;
    const splitLineStyle = splitLineModel.getModel("lineStyle").getLineStyle();
    const tickLineStyle = tickModel.getModel("lineStyle").getLineStyle();
    const splitLineDistance = splitLineModel.get("distance");
    let unitX;
    let unitY;
    for (let i = 0; i <= splitNumber; i++) {
      unitX = Math.cos(angle);
      unitY = Math.sin(angle);
      if (splitLineModel.get("show")) {
        const distance2 = splitLineDistance ? splitLineDistance + axisLineWidth : axisLineWidth;
        const splitLine = new Line_default({
          shape: {
            x1: unitX * (r - distance2) + cx,
            y1: unitY * (r - distance2) + cy,
            x2: unitX * (r - splitLineLen - distance2) + cx,
            y2: unitY * (r - splitLineLen - distance2) + cy
          },
          style: splitLineStyle,
          silent: true
        });
        if (splitLineStyle.stroke === "auto") {
          splitLine.setStyle({
            stroke: getColor2(i / splitNumber)
          });
        }
        group.add(splitLine);
      }
      if (labelModel.get("show")) {
        const distance2 = labelModel.get("distance") + splitLineDistance;
        const label = formatLabel(round(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get("formatter"));
        const autoColor = getColor2(i / splitNumber);
        const textStyleX = unitX * (r - splitLineLen - distance2) + cx;
        const textStyleY = unitY * (r - splitLineLen - distance2) + cy;
        const rotateType = labelModel.get("rotate");
        let rotate2 = 0;
        if (rotateType === "radial") {
          rotate2 = -angle + 2 * Math.PI;
          if (rotate2 > Math.PI / 2) {
            rotate2 += Math.PI;
          }
        } else if (rotateType === "tangential") {
          rotate2 = -angle - Math.PI / 2;
        } else if (isNumber(rotateType)) {
          rotate2 = rotateType * Math.PI / 180;
        }
        if (rotate2 === 0) {
          group.add(new Text_default({
            style: createTextStyle(labelModel, {
              text: label,
              x: textStyleX,
              y: textStyleY,
              verticalAlign: unitY < -0.8 ? "top" : unitY > 0.8 ? "bottom" : "middle",
              align: unitX < -0.4 ? "left" : unitX > 0.4 ? "right" : "center"
            }, {
              inheritColor: autoColor
            }),
            silent: true
          }));
        } else {
          group.add(new Text_default({
            style: createTextStyle(labelModel, {
              text: label,
              x: textStyleX,
              y: textStyleY,
              verticalAlign: "middle",
              align: "center"
            }, {
              inheritColor: autoColor
            }),
            silent: true,
            originX: textStyleX,
            originY: textStyleY,
            rotation: rotate2
          }));
        }
      }
      if (tickModel.get("show") && i !== splitNumber) {
        let distance2 = tickModel.get("distance");
        distance2 = distance2 ? distance2 + axisLineWidth : axisLineWidth;
        for (let j = 0; j <= subSplitNumber; j++) {
          unitX = Math.cos(angle);
          unitY = Math.sin(angle);
          const tickLine = new Line_default({
            shape: {
              x1: unitX * (r - distance2) + cx,
              y1: unitY * (r - distance2) + cy,
              x2: unitX * (r - tickLen - distance2) + cx,
              y2: unitY * (r - tickLen - distance2) + cy
            },
            silent: true,
            style: tickLineStyle
          });
          if (tickLineStyle.stroke === "auto") {
            tickLine.setStyle({
              stroke: getColor2((i + j / subSplitNumber) / splitNumber)
            });
          }
          group.add(tickLine);
          angle += subStep;
        }
        angle -= subStep;
      } else {
        angle += step;
      }
    }
  }
  _renderPointer(seriesModel, ecModel, api2, getColor2, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {
    const group = this.group;
    const oldData = this._data;
    const oldProgressData = this._progressEls;
    const progressList = [];
    const showPointer2 = seriesModel.get(["pointer", "show"]);
    const progressModel = seriesModel.getModel("progress");
    const showProgress = progressModel.get("show");
    const data = seriesModel.getData();
    const valueDim = data.mapDimension("value");
    const minVal = +seriesModel.get("min");
    const maxVal = +seriesModel.get("max");
    const valueExtent = [minVal, maxVal];
    const angleExtent = [startAngle, endAngle];
    function createPointer(idx, angle) {
      const itemModel = data.getItemModel(idx);
      const pointerModel = itemModel.getModel("pointer");
      const pointerWidth = parsePercent2(pointerModel.get("width"), posInfo.r);
      const pointerLength = parsePercent2(pointerModel.get("length"), posInfo.r);
      const pointerStr = seriesModel.get(["pointer", "icon"]);
      const pointerOffset = pointerModel.get("offsetCenter");
      const pointerOffsetX = parsePercent2(pointerOffset[0], posInfo.r);
      const pointerOffsetY = parsePercent2(pointerOffset[1], posInfo.r);
      const pointerKeepAspect = pointerModel.get("keepAspect");
      let pointer;
      if (pointerStr) {
        pointer = createSymbol(pointerStr, pointerOffsetX - pointerWidth / 2, pointerOffsetY - pointerLength, pointerWidth, pointerLength, null, pointerKeepAspect);
      } else {
        pointer = new PointerPath_default({
          shape: {
            angle: -Math.PI / 2,
            width: pointerWidth,
            r: pointerLength,
            x: pointerOffsetX,
            y: pointerOffsetY
          }
        });
      }
      pointer.rotation = -(angle + Math.PI / 2);
      pointer.x = posInfo.cx;
      pointer.y = posInfo.cy;
      return pointer;
    }
    function createProgress(idx, endAngle2) {
      const roundCap = progressModel.get("roundCap");
      const ProgressPath = roundCap ? sausage_default : Sector_default;
      const isOverlap = progressModel.get("overlap");
      const progressWidth = isOverlap ? progressModel.get("width") : axisLineWidth / data.count();
      const r0 = isOverlap ? posInfo.r - progressWidth : posInfo.r - (idx + 1) * progressWidth;
      const r = isOverlap ? posInfo.r : posInfo.r - idx * progressWidth;
      const progress = new ProgressPath({
        shape: {
          startAngle,
          endAngle: endAngle2,
          cx: posInfo.cx,
          cy: posInfo.cy,
          clockwise,
          r0,
          r
        }
      });
      isOverlap && (progress.z2 = linearMap(data.get(valueDim, idx), [minVal, maxVal], [100, 0], true));
      return progress;
    }
    if (showProgress || showPointer2) {
      data.diff(oldData).add(function(idx) {
        const val = data.get(valueDim, idx);
        if (showPointer2) {
          const pointer = createPointer(idx, startAngle);
          initProps(pointer, {
            rotation: -((isNaN(+val) ? angleExtent[0] : linearMap(val, valueExtent, angleExtent, true)) + Math.PI / 2)
          }, seriesModel);
          group.add(pointer);
          data.setItemGraphicEl(idx, pointer);
        }
        if (showProgress) {
          const progress = createProgress(idx, startAngle);
          const isClip = progressModel.get("clip");
          initProps(progress, {
            shape: {
              endAngle: linearMap(val, valueExtent, angleExtent, isClip)
            }
          }, seriesModel);
          group.add(progress);
          setCommonECData(seriesModel.seriesIndex, data.dataType, idx, progress);
          progressList[idx] = progress;
        }
      }).update(function(newIdx, oldIdx) {
        const val = data.get(valueDim, newIdx);
        if (showPointer2) {
          const previousPointer = oldData.getItemGraphicEl(oldIdx);
          const previousRotate = previousPointer ? previousPointer.rotation : startAngle;
          const pointer = createPointer(newIdx, previousRotate);
          pointer.rotation = previousRotate;
          updateProps(pointer, {
            rotation: -((isNaN(+val) ? angleExtent[0] : linearMap(val, valueExtent, angleExtent, true)) + Math.PI / 2)
          }, seriesModel);
          group.add(pointer);
          data.setItemGraphicEl(newIdx, pointer);
        }
        if (showProgress) {
          const previousProgress = oldProgressData[oldIdx];
          const previousEndAngle = previousProgress ? previousProgress.shape.endAngle : startAngle;
          const progress = createProgress(newIdx, previousEndAngle);
          const isClip = progressModel.get("clip");
          updateProps(progress, {
            shape: {
              endAngle: linearMap(val, valueExtent, angleExtent, isClip)
            }
          }, seriesModel);
          group.add(progress);
          setCommonECData(seriesModel.seriesIndex, data.dataType, newIdx, progress);
          progressList[newIdx] = progress;
        }
      }).execute();
      data.each(function(idx) {
        const itemModel = data.getItemModel(idx);
        const emphasisModel = itemModel.getModel("emphasis");
        const focus = emphasisModel.get("focus");
        const blurScope = emphasisModel.get("blurScope");
        const emphasisDisabled = emphasisModel.get("disabled");
        if (showPointer2) {
          const pointer = data.getItemGraphicEl(idx);
          const symbolStyle = data.getItemVisual(idx, "style");
          const visualColor = symbolStyle.fill;
          if (pointer instanceof Image_default) {
            const pathStyle = pointer.style;
            pointer.useStyle(extend({
              image: pathStyle.image,
              x: pathStyle.x,
              y: pathStyle.y,
              width: pathStyle.width,
              height: pathStyle.height
            }, symbolStyle));
          } else {
            pointer.useStyle(symbolStyle);
            pointer.type !== "pointer" && pointer.setColor(visualColor);
          }
          pointer.setStyle(itemModel.getModel(["pointer", "itemStyle"]).getItemStyle());
          if (pointer.style.fill === "auto") {
            pointer.setStyle("fill", getColor2(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)));
          }
          pointer.z2EmphasisLift = 0;
          setStatesStylesFromModel(pointer, itemModel);
          toggleHoverEmphasis(pointer, focus, blurScope, emphasisDisabled);
        }
        if (showProgress) {
          const progress = progressList[idx];
          progress.useStyle(data.getItemVisual(idx, "style"));
          progress.setStyle(itemModel.getModel(["progress", "itemStyle"]).getItemStyle());
          progress.z2EmphasisLift = 0;
          setStatesStylesFromModel(progress, itemModel);
          toggleHoverEmphasis(progress, focus, blurScope, emphasisDisabled);
        }
      });
      this._progressEls = progressList;
    }
  }
  _renderAnchor(seriesModel, posInfo) {
    const anchorModel = seriesModel.getModel("anchor");
    const showAnchor = anchorModel.get("show");
    if (showAnchor) {
      const anchorSize = anchorModel.get("size");
      const anchorType = anchorModel.get("icon");
      const offsetCenter = anchorModel.get("offsetCenter");
      const anchorKeepAspect = anchorModel.get("keepAspect");
      const anchor = createSymbol(anchorType, posInfo.cx - anchorSize / 2 + parsePercent2(offsetCenter[0], posInfo.r), posInfo.cy - anchorSize / 2 + parsePercent2(offsetCenter[1], posInfo.r), anchorSize, anchorSize, null, anchorKeepAspect);
      anchor.z2 = anchorModel.get("showAbove") ? 1 : 0;
      anchor.setStyle(anchorModel.getModel("itemStyle").getItemStyle());
      this.group.add(anchor);
    }
  }
  _renderTitleAndDetail(seriesModel, ecModel, api2, getColor2, posInfo) {
    const data = seriesModel.getData();
    const valueDim = data.mapDimension("value");
    const minVal = +seriesModel.get("min");
    const maxVal = +seriesModel.get("max");
    const contentGroup = new Group_default();
    const newTitleEls = [];
    const newDetailEls = [];
    const hasAnimation = seriesModel.isAnimationEnabled();
    const showPointerAbove = seriesModel.get(["pointer", "showAbove"]);
    data.diff(this._data).add((idx) => {
      newTitleEls[idx] = new Text_default({
        silent: true
      });
      newDetailEls[idx] = new Text_default({
        silent: true
      });
    }).update((idx, oldIdx) => {
      newTitleEls[idx] = this._titleEls[oldIdx];
      newDetailEls[idx] = this._detailEls[oldIdx];
    }).execute();
    data.each(function(idx) {
      const itemModel = data.getItemModel(idx);
      const value = data.get(valueDim, idx);
      const itemGroup = new Group_default();
      const autoColor = getColor2(linearMap(value, [minVal, maxVal], [0, 1], true));
      const itemTitleModel = itemModel.getModel("title");
      if (itemTitleModel.get("show")) {
        const titleOffsetCenter = itemTitleModel.get("offsetCenter");
        const titleX = posInfo.cx + parsePercent2(titleOffsetCenter[0], posInfo.r);
        const titleY = posInfo.cy + parsePercent2(titleOffsetCenter[1], posInfo.r);
        const labelEl = newTitleEls[idx];
        labelEl.attr({
          z2: showPointerAbove ? 0 : 2,
          style: createTextStyle(itemTitleModel, {
            x: titleX,
            y: titleY,
            text: data.getName(idx),
            align: "center",
            verticalAlign: "middle"
          }, {inheritColor: autoColor})
        });
        itemGroup.add(labelEl);
      }
      const itemDetailModel = itemModel.getModel("detail");
      if (itemDetailModel.get("show")) {
        const detailOffsetCenter = itemDetailModel.get("offsetCenter");
        const detailX = posInfo.cx + parsePercent2(detailOffsetCenter[0], posInfo.r);
        const detailY = posInfo.cy + parsePercent2(detailOffsetCenter[1], posInfo.r);
        const width = parsePercent2(itemDetailModel.get("width"), posInfo.r);
        const height = parsePercent2(itemDetailModel.get("height"), posInfo.r);
        const detailColor = seriesModel.get(["progress", "show"]) ? data.getItemVisual(idx, "style").fill : autoColor;
        const labelEl = newDetailEls[idx];
        const formatter = itemDetailModel.get("formatter");
        labelEl.attr({
          z2: showPointerAbove ? 0 : 2,
          style: createTextStyle(itemDetailModel, {
            x: detailX,
            y: detailY,
            text: formatLabel(value, formatter),
            width: isNaN(width) ? null : width,
            height: isNaN(height) ? null : height,
            align: "center",
            verticalAlign: "middle"
          }, {inheritColor: detailColor})
        });
        setLabelValueAnimation(labelEl, {normal: itemDetailModel}, value, (value2) => formatLabel(value2, formatter));
        hasAnimation && animateLabelValue(labelEl, idx, data, seriesModel, {
          getFormattedLabel(labelDataIndex, status, dataType, labelDimIndex, fmt, extendParams) {
            return formatLabel(extendParams ? extendParams.interpolatedValue : value, formatter);
          }
        });
        itemGroup.add(labelEl);
      }
      contentGroup.add(itemGroup);
    });
    this.group.add(contentGroup);
    this._titleEls = newTitleEls;
    this._detailEls = newDetailEls;
  }
};
var GaugeView = GaugeView2;
GaugeView.type = "gauge";
var GaugeView_default = GaugeView;

// src/chart/gauge/GaugeSeries.ts
var GaugeSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = GaugeSeriesModel2.type;
    this.visualStyleAccessPath = "itemStyle";
  }
  getInitialData(option, ecModel) {
    return createSeriesDataSimply(this, ["value"]);
  }
};
var GaugeSeriesModel = GaugeSeriesModel2;
GaugeSeriesModel.type = "series.gauge";
GaugeSeriesModel.defaultOption = {
  z: 2,
  colorBy: "data",
  center: ["50%", "50%"],
  legendHoverLink: true,
  radius: "75%",
  startAngle: 225,
  endAngle: -45,
  clockwise: true,
  min: 0,
  max: 100,
  splitNumber: 10,
  axisLine: {
    show: true,
    roundCap: false,
    lineStyle: {
      color: [[1, tokens_default.color.neutral10]],
      width: 10
    }
  },
  progress: {
    show: false,
    overlap: true,
    width: 10,
    roundCap: false,
    clip: true
  },
  splitLine: {
    show: true,
    length: 10,
    distance: 10,
    lineStyle: {
      color: tokens_default.color.axisTick,
      width: 3,
      type: "solid"
    }
  },
  axisTick: {
    show: true,
    splitNumber: 5,
    length: 6,
    distance: 10,
    lineStyle: {
      color: tokens_default.color.axisTickMinor,
      width: 1,
      type: "solid"
    }
  },
  axisLabel: {
    show: true,
    distance: 15,
    color: tokens_default.color.axisLabel,
    fontSize: 12,
    rotate: 0
  },
  pointer: {
    icon: null,
    offsetCenter: [0, 0],
    show: true,
    showAbove: true,
    length: "60%",
    width: 6,
    keepAspect: false
  },
  anchor: {
    show: false,
    showAbove: false,
    size: 6,
    icon: "circle",
    offsetCenter: [0, 0],
    keepAspect: false,
    itemStyle: {
      color: tokens_default.color.neutral00,
      borderWidth: 0,
      borderColor: tokens_default.color.theme[0]
    }
  },
  title: {
    show: true,
    offsetCenter: [0, "20%"],
    color: tokens_default.color.secondary,
    fontSize: 16,
    valueAnimation: false
  },
  detail: {
    show: true,
    backgroundColor: tokens_default.color.transparent,
    borderWidth: 0,
    borderColor: tokens_default.color.neutral40,
    width: 100,
    height: null,
    padding: [5, 10],
    offsetCenter: [0, "40%"],
    color: tokens_default.color.primary,
    fontSize: 30,
    fontWeight: "bold",
    lineHeight: 30,
    valueAnimation: false
  }
};
var GaugeSeries_default = GaugeSeriesModel;

// src/chart/gauge/install.ts
function install16(registers) {
  registers.registerChartView(GaugeView_default);
  registers.registerSeriesModel(GaugeSeries_default);
}

// src/chart/funnel/FunnelView.ts
var opacityAccessPath = ["itemStyle", "opacity"];
var FunnelPiece = class extends Polygon_default {
  constructor(data, idx) {
    super();
    const polygon = this;
    const labelLine = new Polyline_default();
    const text = new Text_default();
    polygon.setTextContent(text);
    this.setTextGuideLine(labelLine);
    this.updateData(data, idx, true);
  }
  updateData(data, idx, firstCreate) {
    const polygon = this;
    const seriesModel = data.hostModel;
    const itemModel = data.getItemModel(idx);
    const layout14 = data.getItemLayout(idx);
    const emphasisModel = itemModel.getModel("emphasis");
    let opacity = itemModel.get(opacityAccessPath);
    opacity = opacity == null ? 1 : opacity;
    if (!firstCreate) {
      saveOldStyle(polygon);
    }
    polygon.useStyle(data.getItemVisual(idx, "style"));
    polygon.style.lineJoin = "round";
    if (firstCreate) {
      polygon.setShape({
        points: layout14.points
      });
      polygon.style.opacity = 0;
      initProps(polygon, {
        style: {
          opacity
        }
      }, seriesModel, idx);
    } else {
      updateProps(polygon, {
        style: {
          opacity
        },
        shape: {
          points: layout14.points
        }
      }, seriesModel, idx);
    }
    setStatesStylesFromModel(polygon, itemModel);
    this._updateLabel(data, idx);
    toggleHoverEmphasis(this, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  }
  _updateLabel(data, idx) {
    const polygon = this;
    const labelLine = this.getTextGuideLine();
    const labelText = polygon.getTextContent();
    const seriesModel = data.hostModel;
    const itemModel = data.getItemModel(idx);
    const layout14 = data.getItemLayout(idx);
    const labelLayout2 = layout14.label;
    const style = data.getItemVisual(idx, "style");
    const visualColor = style.fill;
    setLabelStyle(labelText, getLabelStatesModels(itemModel), {
      labelFetcher: data.hostModel,
      labelDataIndex: idx,
      defaultOpacity: style.opacity,
      defaultText: data.getName(idx)
    }, {normal: {
      align: labelLayout2.textAlign,
      verticalAlign: labelLayout2.verticalAlign
    }});
    const labelModel = itemModel.getModel("label");
    const labelColor = labelModel.get("color");
    const overrideColor = labelColor === "inherit" ? visualColor : null;
    polygon.setTextConfig({
      local: true,
      inside: !!labelLayout2.inside,
      insideStroke: overrideColor,
      outsideFill: overrideColor
    });
    const linePoints = labelLayout2.linePoints;
    labelLine.setShape({
      points: linePoints
    });
    polygon.textGuideLineConfig = {
      anchor: linePoints ? new Point_default(linePoints[0][0], linePoints[0][1]) : null
    };
    updateProps(labelText, {
      style: {
        x: labelLayout2.x,
        y: labelLayout2.y
      }
    }, seriesModel, idx);
    labelText.attr({
      rotation: labelLayout2.rotation,
      originX: labelLayout2.x,
      originY: labelLayout2.y,
      z2: 10
    });
    setLabelLineStyle(polygon, getLabelLineStatesModels(itemModel), {
      stroke: visualColor
    });
  }
};
var FunnelView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = FunnelView2.type;
    this.ignoreLabelLineUpdate = true;
  }
  render(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    const oldData = this._data;
    const group = this.group;
    data.diff(oldData).add(function(idx) {
      const funnelPiece = new FunnelPiece(data, idx);
      data.setItemGraphicEl(idx, funnelPiece);
      group.add(funnelPiece);
    }).update(function(newIdx, oldIdx) {
      const piece = oldData.getItemGraphicEl(oldIdx);
      piece.updateData(data, newIdx);
      group.add(piece);
      data.setItemGraphicEl(newIdx, piece);
    }).remove(function(idx) {
      const piece = oldData.getItemGraphicEl(idx);
      removeElementWithFadeOut(piece, seriesModel, idx);
    }).execute();
    this._data = data;
  }
  remove() {
    this.group.removeAll();
    this._data = null;
  }
  dispose() {
  }
};
var FunnelView = FunnelView2;
FunnelView.type = "funnel";
var FunnelView_default = FunnelView;

// src/chart/funnel/FunnelSeries.ts
var FunnelSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = FunnelSeriesModel2.type;
  }
  init(option) {
    super.init.apply(this, arguments);
    this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this));
    this._defaultLabelLine(option);
  }
  getInitialData(option, ecModel) {
    return createSeriesDataSimply(this, {
      coordDimensions: ["value"],
      encodeDefaulter: curry(makeSeriesEncodeForNameBased, this)
    });
  }
  _defaultLabelLine(option) {
    defaultEmphasis(option, "labelLine", ["show"]);
    const labelLineNormalOpt = option.labelLine;
    const labelLineEmphasisOpt = option.emphasis.labelLine;
    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
  }
  getDataParams(dataIndex) {
    const data = this.getData();
    const params = super.getDataParams(dataIndex);
    const valueDim = data.mapDimension("value");
    const sum2 = data.getSum(valueDim);
    params.percent = !sum2 ? 0 : +(data.get(valueDim, dataIndex) / sum2 * 100).toFixed(2);
    params.$vars.push("percent");
    return params;
  }
};
var FunnelSeriesModel = FunnelSeriesModel2;
FunnelSeriesModel.type = "series.funnel";
FunnelSeriesModel.defaultOption = {
  coordinateSystemUsage: "box",
  z: 2,
  legendHoverLink: true,
  colorBy: "data",
  left: 80,
  top: 60,
  right: 80,
  bottom: 65,
  minSize: "0%",
  maxSize: "100%",
  sort: "descending",
  orient: "vertical",
  gap: 0,
  funnelAlign: "center",
  label: {
    show: true,
    position: "outer"
  },
  labelLine: {
    show: true,
    length: 20,
    lineStyle: {
      width: 1
    }
  },
  itemStyle: {
    borderColor: tokens_default.color.neutral00,
    borderWidth: 1
  },
  emphasis: {
    label: {
      show: true
    }
  },
  select: {
    itemStyle: {
      borderColor: tokens_default.color.primary
    }
  }
};
var FunnelSeries_default = FunnelSeriesModel;

// src/chart/funnel/funnelLayout.ts
function getSortedIndices(data, sort4) {
  const valueDim = data.mapDimension("value");
  const valueArr = data.mapArray(valueDim, function(val) {
    return val;
  });
  const indices = [];
  const isAscending = sort4 === "ascending";
  for (let i = 0, len2 = data.count(); i < len2; i++) {
    indices[i] = i;
  }
  if (isFunction(sort4)) {
    indices.sort(sort4);
  } else if (sort4 !== "none") {
    indices.sort(function(a, b) {
      return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];
    });
  }
  return indices;
}
function labelLayout(data) {
  const seriesModel = data.hostModel;
  const orient = seriesModel.get("orient");
  data.each(function(idx) {
    const itemModel = data.getItemModel(idx);
    const labelModel = itemModel.getModel("label");
    let labelPosition = labelModel.get("position");
    const labelLineModel = itemModel.getModel("labelLine");
    const layout14 = data.getItemLayout(idx);
    const points4 = layout14.points;
    const isLabelInside = labelPosition === "inner" || labelPosition === "inside" || labelPosition === "center" || labelPosition === "insideLeft" || labelPosition === "insideRight";
    let textAlign;
    let textX;
    let textY;
    let linePoints;
    if (isLabelInside) {
      if (labelPosition === "insideLeft") {
        textX = (points4[0][0] + points4[3][0]) / 2 + 5;
        textY = (points4[0][1] + points4[3][1]) / 2;
        textAlign = "left";
      } else if (labelPosition === "insideRight") {
        textX = (points4[1][0] + points4[2][0]) / 2 - 5;
        textY = (points4[1][1] + points4[2][1]) / 2;
        textAlign = "right";
      } else {
        textX = (points4[0][0] + points4[1][0] + points4[2][0] + points4[3][0]) / 4;
        textY = (points4[0][1] + points4[1][1] + points4[2][1] + points4[3][1]) / 4;
        textAlign = "center";
      }
      linePoints = [
        [textX, textY],
        [textX, textY]
      ];
    } else {
      let x1;
      let y1;
      let x2;
      let y2;
      const labelLineLen = labelLineModel.get("length");
      if (true) {
        if (orient === "vertical" && ["top", "bottom"].indexOf(labelPosition) > -1) {
          labelPosition = "left";
          console.warn("Position error: Funnel chart on vertical orient dose not support top and bottom.");
        }
        if (orient === "horizontal" && ["left", "right"].indexOf(labelPosition) > -1) {
          labelPosition = "bottom";
          console.warn("Position error: Funnel chart on horizontal orient dose not support left and right.");
        }
      }
      if (labelPosition === "left") {
        x1 = (points4[3][0] + points4[0][0]) / 2;
        y1 = (points4[3][1] + points4[0][1]) / 2;
        x2 = x1 - labelLineLen;
        textX = x2 - 5;
        textAlign = "right";
      } else if (labelPosition === "right") {
        x1 = (points4[1][0] + points4[2][0]) / 2;
        y1 = (points4[1][1] + points4[2][1]) / 2;
        x2 = x1 + labelLineLen;
        textX = x2 + 5;
        textAlign = "left";
      } else if (labelPosition === "top") {
        x1 = (points4[3][0] + points4[0][0]) / 2;
        y1 = (points4[3][1] + points4[0][1]) / 2;
        y2 = y1 - labelLineLen;
        textY = y2 - 5;
        textAlign = "center";
      } else if (labelPosition === "bottom") {
        x1 = (points4[1][0] + points4[2][0]) / 2;
        y1 = (points4[1][1] + points4[2][1]) / 2;
        y2 = y1 + labelLineLen;
        textY = y2 + 5;
        textAlign = "center";
      } else if (labelPosition === "rightTop") {
        x1 = orient === "horizontal" ? points4[3][0] : points4[1][0];
        y1 = orient === "horizontal" ? points4[3][1] : points4[1][1];
        if (orient === "horizontal") {
          y2 = y1 - labelLineLen;
          textY = y2 - 5;
          textAlign = "center";
        } else {
          x2 = x1 + labelLineLen;
          textX = x2 + 5;
          textAlign = "top";
        }
      } else if (labelPosition === "rightBottom") {
        x1 = points4[2][0];
        y1 = points4[2][1];
        if (orient === "horizontal") {
          y2 = y1 + labelLineLen;
          textY = y2 + 5;
          textAlign = "center";
        } else {
          x2 = x1 + labelLineLen;
          textX = x2 + 5;
          textAlign = "bottom";
        }
      } else if (labelPosition === "leftTop") {
        x1 = points4[0][0];
        y1 = orient === "horizontal" ? points4[0][1] : points4[1][1];
        if (orient === "horizontal") {
          y2 = y1 - labelLineLen;
          textY = y2 - 5;
          textAlign = "center";
        } else {
          x2 = x1 - labelLineLen;
          textX = x2 - 5;
          textAlign = "right";
        }
      } else if (labelPosition === "leftBottom") {
        x1 = orient === "horizontal" ? points4[1][0] : points4[3][0];
        y1 = orient === "horizontal" ? points4[1][1] : points4[2][1];
        if (orient === "horizontal") {
          y2 = y1 + labelLineLen;
          textY = y2 + 5;
          textAlign = "center";
        } else {
          x2 = x1 - labelLineLen;
          textX = x2 - 5;
          textAlign = "right";
        }
      } else {
        x1 = (points4[1][0] + points4[2][0]) / 2;
        y1 = (points4[1][1] + points4[2][1]) / 2;
        if (orient === "horizontal") {
          y2 = y1 + labelLineLen;
          textY = y2 + 5;
          textAlign = "center";
        } else {
          x2 = x1 + labelLineLen;
          textX = x2 + 5;
          textAlign = "left";
        }
      }
      if (orient === "horizontal") {
        x2 = x1;
        textX = x2;
      } else {
        y2 = y1;
        textY = y2;
      }
      linePoints = [[x1, y1], [x2, y2]];
    }
    layout14.label = {
      linePoints,
      x: textX,
      y: textY,
      verticalAlign: "middle",
      textAlign,
      inside: isLabelInside
    };
  });
}
function funnelLayout(ecModel, api2) {
  ecModel.eachSeriesByType("funnel", function(seriesModel) {
    const data = seriesModel.getData();
    const valueDim = data.mapDimension("value");
    const sort4 = seriesModel.get("sort");
    const layoutRef = createBoxLayoutReference(seriesModel, api2);
    const viewRect2 = getLayoutRect(seriesModel.getBoxLayoutParams(), layoutRef.refContainer);
    const orient = seriesModel.get("orient");
    const viewWidth = viewRect2.width;
    const viewHeight = viewRect2.height;
    let indices = getSortedIndices(data, sort4);
    let x = viewRect2.x;
    let y = viewRect2.y;
    const sizeExtent = orient === "horizontal" ? [
      parsePercent2(seriesModel.get("minSize"), viewHeight),
      parsePercent2(seriesModel.get("maxSize"), viewHeight)
    ] : [
      parsePercent2(seriesModel.get("minSize"), viewWidth),
      parsePercent2(seriesModel.get("maxSize"), viewWidth)
    ];
    const dataExtent = data.getDataExtent(valueDim);
    let min3 = seriesModel.get("min");
    let max3 = seriesModel.get("max");
    if (min3 == null) {
      min3 = Math.min(dataExtent[0], 0);
    }
    if (max3 == null) {
      max3 = dataExtent[1];
    }
    const funnelAlign = seriesModel.get("funnelAlign");
    let gap = seriesModel.get("gap");
    const viewSize = orient === "horizontal" ? viewWidth : viewHeight;
    let itemSize = (viewSize - gap * (data.count() - 1)) / data.count();
    const getLinePoints = function(idx, offset) {
      if (orient === "horizontal") {
        const val2 = data.get(valueDim, idx) || 0;
        const itemHeight = linearMap(val2, [min3, max3], sizeExtent, true);
        let y0;
        switch (funnelAlign) {
          case "top":
            y0 = y;
            break;
          case "center":
            y0 = y + (viewHeight - itemHeight) / 2;
            break;
          case "bottom":
            y0 = y + (viewHeight - itemHeight);
            break;
        }
        return [
          [offset, y0],
          [offset, y0 + itemHeight]
        ];
      }
      const val = data.get(valueDim, idx) || 0;
      const itemWidth = linearMap(val, [min3, max3], sizeExtent, true);
      let x0;
      switch (funnelAlign) {
        case "left":
          x0 = x;
          break;
        case "center":
          x0 = x + (viewWidth - itemWidth) / 2;
          break;
        case "right":
          x0 = x + viewWidth - itemWidth;
          break;
      }
      return [
        [x0, offset],
        [x0 + itemWidth, offset]
      ];
    };
    if (sort4 === "ascending") {
      itemSize = -itemSize;
      gap = -gap;
      if (orient === "horizontal") {
        x += viewWidth;
      } else {
        y += viewHeight;
      }
      indices = indices.reverse();
    }
    for (let i = 0; i < indices.length; i++) {
      const idx = indices[i];
      const nextIdx = indices[i + 1];
      const itemModel = data.getItemModel(idx);
      if (orient === "horizontal") {
        let width = itemModel.get(["itemStyle", "width"]);
        if (width == null) {
          width = itemSize;
        } else {
          width = parsePercent2(width, viewWidth);
          if (sort4 === "ascending") {
            width = -width;
          }
        }
        const start2 = getLinePoints(idx, x);
        const end2 = getLinePoints(nextIdx, x + width);
        x += width + gap;
        data.setItemLayout(idx, {
          points: start2.concat(end2.slice().reverse())
        });
      } else {
        let height = itemModel.get(["itemStyle", "height"]);
        if (height == null) {
          height = itemSize;
        } else {
          height = parsePercent2(height, viewHeight);
          if (sort4 === "ascending") {
            height = -height;
          }
        }
        const start2 = getLinePoints(idx, y);
        const end2 = getLinePoints(nextIdx, y + height);
        y += height + gap;
        data.setItemLayout(idx, {
          points: start2.concat(end2.slice().reverse())
        });
      }
    }
    labelLayout(data);
  });
}

// src/chart/funnel/install.ts
function install17(registers) {
  registers.registerChartView(FunnelView_default);
  registers.registerSeriesModel(FunnelSeries_default);
  registers.registerLayout(funnelLayout);
  registers.registerProcessor(dataFilter("funnel"));
}

// src/chart/parallel/ParallelView.ts
var DEFAULT_SMOOTH = 0.3;
var ParallelView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = ParallelView2.type;
    this._dataGroup = new Group_default();
    this._initialized = false;
  }
  init() {
    this.group.add(this._dataGroup);
  }
  render(seriesModel, ecModel, api2, payload) {
    this._progressiveEls = null;
    const dataGroup = this._dataGroup;
    const data = seriesModel.getData();
    const oldData = this._data;
    const coordSys = seriesModel.coordinateSystem;
    const dimensions = coordSys.dimensions;
    const seriesScope = makeSeriesScope3(seriesModel);
    data.diff(oldData).add(add2).update(update).remove(remove).execute();
    function add2(newDataIndex) {
      const line2 = addEl(data, dataGroup, newDataIndex, dimensions, coordSys);
      updateElCommon(line2, data, newDataIndex, seriesScope);
    }
    function update(newDataIndex, oldDataIndex) {
      const line2 = oldData.getItemGraphicEl(oldDataIndex);
      const points4 = createLinePoints(data, newDataIndex, dimensions, coordSys);
      data.setItemGraphicEl(newDataIndex, line2);
      updateProps(line2, {shape: {points: points4}}, seriesModel, newDataIndex);
      saveOldStyle(line2);
      updateElCommon(line2, data, newDataIndex, seriesScope);
    }
    function remove(oldDataIndex) {
      const line2 = oldData.getItemGraphicEl(oldDataIndex);
      dataGroup.remove(line2);
    }
    if (!this._initialized) {
      this._initialized = true;
      const clipPath = createGridClipShape(coordSys, seriesModel, function() {
        setTimeout(function() {
          dataGroup.removeClipPath();
        });
      });
      dataGroup.setClipPath(clipPath);
    }
    this._data = data;
  }
  incrementalPrepareRender(seriesModel, ecModel, api2) {
    this._initialized = true;
    this._data = null;
    this._dataGroup.removeAll();
  }
  incrementalRender(taskParams, seriesModel, ecModel) {
    const data = seriesModel.getData();
    const coordSys = seriesModel.coordinateSystem;
    const dimensions = coordSys.dimensions;
    const seriesScope = makeSeriesScope3(seriesModel);
    const progressiveEls = this._progressiveEls = [];
    for (let dataIndex = taskParams.start; dataIndex < taskParams.end; dataIndex++) {
      const line2 = addEl(data, this._dataGroup, dataIndex, dimensions, coordSys);
      line2.incremental = true;
      updateElCommon(line2, data, dataIndex, seriesScope);
      progressiveEls.push(line2);
    }
  }
  remove() {
    this._dataGroup && this._dataGroup.removeAll();
    this._data = null;
  }
};
var ParallelView = ParallelView2;
ParallelView.type = "parallel";
function createGridClipShape(coordSys, seriesModel, cb) {
  const parallelModel = coordSys.model;
  const rect = coordSys.getRect();
  const rectEl = new Rect_default({
    shape: {
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    }
  });
  const dim = parallelModel.get("layout") === "horizontal" ? "width" : "height";
  rectEl.setShape(dim, 0);
  initProps(rectEl, {
    shape: {
      width: rect.width,
      height: rect.height
    }
  }, seriesModel, cb);
  return rectEl;
}
function createLinePoints(data, dataIndex, dimensions, coordSys) {
  const points4 = [];
  for (let i = 0; i < dimensions.length; i++) {
    const dimName = dimensions[i];
    const value = data.get(data.mapDimension(dimName), dataIndex);
    if (!isEmptyValue(value, coordSys.getAxis(dimName).type)) {
      points4.push(coordSys.dataToPoint(value, dimName));
    }
  }
  return points4;
}
function addEl(data, dataGroup, dataIndex, dimensions, coordSys) {
  const points4 = createLinePoints(data, dataIndex, dimensions, coordSys);
  const line2 = new Polyline_default({
    shape: {points: points4},
    z2: 10
  });
  dataGroup.add(line2);
  data.setItemGraphicEl(dataIndex, line2);
  return line2;
}
function makeSeriesScope3(seriesModel) {
  let smooth = seriesModel.get("smooth", true);
  smooth === true && (smooth = DEFAULT_SMOOTH);
  smooth = numericToNumber(smooth);
  eqNaN(smooth) && (smooth = 0);
  return {smooth};
}
function updateElCommon(el, data, dataIndex, seriesScope) {
  el.useStyle(data.getItemVisual(dataIndex, "style"));
  el.style.fill = null;
  el.setShape("smooth", seriesScope.smooth);
  const itemModel = data.getItemModel(dataIndex);
  const emphasisModel = itemModel.getModel("emphasis");
  setStatesStylesFromModel(el, itemModel, "lineStyle");
  toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
}
function isEmptyValue(val, axisType) {
  return axisType === "category" ? val == null : val == null || isNaN(val);
}
var ParallelView_default = ParallelView;

// src/chart/parallel/ParallelSeries.ts
var ParallelSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = ParallelSeriesModel2.type;
    this.visualStyleAccessPath = "lineStyle";
    this.visualDrawType = "stroke";
  }
  getInitialData(option, ecModel) {
    return createSeriesData_default(null, this, {
      useEncodeDefaulter: bind(makeDefaultEncode, null, this)
    });
  }
  getRawIndicesByActiveState(activeState) {
    const coordSys = this.coordinateSystem;
    const data = this.getData();
    const indices = [];
    coordSys.eachActiveState(data, function(theActiveState, dataIndex) {
      if (activeState === theActiveState) {
        indices.push(data.getRawIndex(dataIndex));
      }
    });
    return indices;
  }
};
var ParallelSeriesModel = ParallelSeriesModel2;
ParallelSeriesModel.type = "series.parallel";
ParallelSeriesModel.dependencies = ["parallel"];
ParallelSeriesModel.defaultOption = {
  z: 2,
  coordinateSystem: "parallel",
  parallelIndex: 0,
  label: {
    show: false
  },
  inactiveOpacity: 0.05,
  activeOpacity: 1,
  lineStyle: {
    width: 1,
    opacity: 0.45,
    type: "solid"
  },
  emphasis: {
    label: {
      show: false
    }
  },
  progressive: 500,
  smooth: false,
  animationEasing: "linear"
};
function makeDefaultEncode(seriesModel) {
  const parallelModel = seriesModel.ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
  if (!parallelModel) {
    return;
  }
  const encodeDefine = {};
  each(parallelModel.dimensions, function(axisDim) {
    const dataDimIndex = convertDimNameToNumber(axisDim);
    encodeDefine[axisDim] = dataDimIndex;
  });
  return encodeDefine;
}
function convertDimNameToNumber(dimName) {
  return +dimName.replace("dim", "");
}
var ParallelSeries_default = ParallelSeriesModel;

// src/chart/parallel/parallelVisual.ts
var opacityAccessPath2 = ["lineStyle", "opacity"];
var parallelVisual = {
  seriesType: "parallel",
  reset: function(seriesModel, ecModel) {
    const coordSys = seriesModel.coordinateSystem;
    const opacityMap = {
      normal: seriesModel.get(["lineStyle", "opacity"]),
      active: seriesModel.get("activeOpacity"),
      inactive: seriesModel.get("inactiveOpacity")
    };
    return {
      progress(params, data) {
        coordSys.eachActiveState(data, function(activeState, dataIndex) {
          let opacity = opacityMap[activeState];
          if (activeState === "normal" && data.hasItemOption) {
            const itemOpacity = data.getItemModel(dataIndex).get(opacityAccessPath2, true);
            itemOpacity != null && (opacity = itemOpacity);
          }
          const existsStyle = data.ensureUniqueItemVisual(dataIndex, "style");
          existsStyle.opacity = opacity;
        }, params.start, params.end);
      }
    };
  }
};
var parallelVisual_default = parallelVisual;

// src/coord/parallel/parallelPreprocessor.ts
function parallelPreprocessor(option) {
  createParallelIfNeeded(option);
  mergeAxisOptionFromParallel(option);
}
function createParallelIfNeeded(option) {
  if (option.parallel) {
    return;
  }
  let hasParallelSeries = false;
  each(option.series, function(seriesOpt) {
    if (seriesOpt && seriesOpt.type === "parallel") {
      hasParallelSeries = true;
    }
  });
  if (hasParallelSeries) {
    option.parallel = [{}];
  }
}
function mergeAxisOptionFromParallel(option) {
  const axes = normalizeToArray(option.parallelAxis);
  each(axes, function(axisOption) {
    if (!isObject(axisOption)) {
      return;
    }
    const parallelIndex = axisOption.parallelIndex || 0;
    const parallelOption = normalizeToArray(option.parallel)[parallelIndex];
    if (parallelOption && parallelOption.parallelAxisDefault) {
      merge(axisOption, parallelOption.parallelAxisDefault, false);
    }
  });
}

// src/component/parallel/ParallelView.ts
var CLICK_THRESHOLD = 5;
var ParallelView4 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = ParallelView4.type;
  }
  render(parallelModel, ecModel, api2) {
    this._model = parallelModel;
    this._api = api2;
    if (!this._handlers) {
      this._handlers = {};
      each(handlers, function(handler, eventName) {
        api2.getZr().on(eventName, this._handlers[eventName] = bind(handler, this));
      }, this);
    }
    createOrUpdate(this, "_throttledDispatchExpand", parallelModel.get("axisExpandRate"), "fixRate");
  }
  dispose(ecModel, api2) {
    clear(this, "_throttledDispatchExpand");
    each(this._handlers, function(handler, eventName) {
      api2.getZr().off(eventName, handler);
    });
    this._handlers = null;
  }
  _throttledDispatchExpand(opt) {
    this._dispatchExpand(opt);
  }
  _dispatchExpand(opt) {
    opt && this._api.dispatchAction(extend({type: "parallelAxisExpand"}, opt));
  }
};
var ParallelView3 = ParallelView4;
ParallelView3.type = "parallel";
var handlers = {
  mousedown: function(e2) {
    if (checkTrigger(this, "click")) {
      this._mouseDownPoint = [e2.offsetX, e2.offsetY];
    }
  },
  mouseup: function(e2) {
    const mouseDownPoint = this._mouseDownPoint;
    if (checkTrigger(this, "click") && mouseDownPoint) {
      const point = [e2.offsetX, e2.offsetY];
      const dist3 = Math.pow(mouseDownPoint[0] - point[0], 2) + Math.pow(mouseDownPoint[1] - point[1], 2);
      if (dist3 > CLICK_THRESHOLD) {
        return;
      }
      const result = this._model.coordinateSystem.getSlidedAxisExpandWindow([e2.offsetX, e2.offsetY]);
      result.behavior !== "none" && this._dispatchExpand({
        axisExpandWindow: result.axisExpandWindow
      });
    }
    this._mouseDownPoint = null;
  },
  mousemove: function(e2) {
    if (this._mouseDownPoint || !checkTrigger(this, "mousemove")) {
      return;
    }
    const model = this._model;
    const result = model.coordinateSystem.getSlidedAxisExpandWindow([e2.offsetX, e2.offsetY]);
    const behavior = result.behavior;
    behavior === "jump" && this._throttledDispatchExpand.debounceNextCall(model.get("axisExpandDebounce"));
    this._throttledDispatchExpand(behavior === "none" ? null : {
      axisExpandWindow: result.axisExpandWindow,
      animation: behavior === "jump" ? null : {
        duration: 0
      }
    });
  }
};
function checkTrigger(view, triggerOn) {
  const model = view._model;
  return model.get("axisExpandable") && model.get("axisExpandTriggerOn") === triggerOn;
}
var ParallelView_default2 = ParallelView3;

// src/coord/parallel/ParallelModel.ts
var ParallelModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = ParallelModel2.type;
  }
  init() {
    super.init.apply(this, arguments);
    this.mergeOption({});
  }
  mergeOption(newOption) {
    const thisOption = this.option;
    newOption && merge(thisOption, newOption, true);
    this._initDimensions();
  }
  contains(model, ecModel) {
    const parallelIndex = model.get("parallelIndex");
    return parallelIndex != null && ecModel.getComponent("parallel", parallelIndex) === this;
  }
  setAxisExpand(opt) {
    each([
      "axisExpandable",
      "axisExpandCenter",
      "axisExpandCount",
      "axisExpandWidth",
      "axisExpandWindow"
    ], function(name) {
      if (opt.hasOwnProperty(name)) {
        this.option[name] = opt[name];
      }
    }, this);
  }
  _initDimensions() {
    const dimensions = this.dimensions = [];
    const parallelAxisIndex = this.parallelAxisIndex = [];
    const axisModels = filter(this.ecModel.queryComponents({mainType: "parallelAxis"}), function(axisModel) {
      return (axisModel.get("parallelIndex") || 0) === this.componentIndex;
    }, this);
    each(axisModels, function(axisModel) {
      dimensions.push("dim" + axisModel.get("dim"));
      parallelAxisIndex.push(axisModel.componentIndex);
    });
  }
};
var ParallelModel = ParallelModel2;
ParallelModel.type = "parallel";
ParallelModel.dependencies = ["parallelAxis"];
ParallelModel.layoutMode = "box";
ParallelModel.defaultOption = {
  z: 0,
  left: 80,
  top: 60,
  right: 80,
  bottom: 60,
  layout: "horizontal",
  axisExpandable: false,
  axisExpandCenter: null,
  axisExpandCount: 0,
  axisExpandWidth: 50,
  axisExpandRate: 17,
  axisExpandDebounce: 50,
  axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
  axisExpandTriggerOn: "click",
  parallelAxisDefault: null
};
var ParallelModel_default = ParallelModel;

// src/coord/parallel/ParallelAxis.ts
var ParallelAxis = class extends Axis_default {
  constructor(dim, scale4, coordExtent, axisType, axisIndex) {
    super(dim, scale4, coordExtent);
    this.type = axisType || "value";
    this.axisIndex = axisIndex;
  }
  isHorizontal() {
    return this.coordinateSystem.getModel().get("layout") !== "horizontal";
  }
};
var ParallelAxis_default = ParallelAxis;

// src/component/helper/sliderMove.ts
function sliderMove(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {
  delta = delta || 0;
  const extentSpan = extent[1] - extent[0];
  if (minSpan != null) {
    minSpan = restrict(minSpan, [0, extentSpan]);
  }
  if (maxSpan != null) {
    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);
  }
  if (handleIndex === "all") {
    let handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);
    handleSpan = restrict(handleSpan, [0, extentSpan]);
    minSpan = maxSpan = restrict(handleSpan, [minSpan, maxSpan]);
    handleIndex = 0;
  }
  handleEnds[0] = restrict(handleEnds[0], extent);
  handleEnds[1] = restrict(handleEnds[1], extent);
  const originalDistSign = getSpanSign(handleEnds, handleIndex);
  handleEnds[handleIndex] += delta;
  const extentMinSpan = minSpan || 0;
  const realExtent = extent.slice();
  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;
  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent);
  let currDistSign;
  currDistSign = getSpanSign(handleEnds, handleIndex);
  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {
    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;
  }
  currDistSign = getSpanSign(handleEnds, handleIndex);
  if (maxSpan != null && currDistSign.span > maxSpan) {
    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;
  }
  return handleEnds;
}
function getSpanSign(handleEnds, handleIndex) {
  const dist3 = handleEnds[handleIndex] - handleEnds[1 - handleIndex];
  return {span: Math.abs(dist3), sign: dist3 > 0 ? -1 : dist3 < 0 ? 1 : handleIndex ? -1 : 1};
}
function restrict(value, extend2) {
  return Math.min(extend2[1] != null ? extend2[1] : Infinity, Math.max(extend2[0] != null ? extend2[0] : -Infinity, value));
}

// src/coord/parallel/Parallel.ts
var each6 = each;
var mathMin10 = Math.min;
var mathMax10 = Math.max;
var mathFloor2 = Math.floor;
var mathCeil2 = Math.ceil;
var round6 = round;
var PI9 = Math.PI;
var Parallel = class {
  constructor(parallelModel, ecModel, api2) {
    this.type = "parallel";
    this._axesMap = createHashMap();
    this._axesLayout = {};
    this.dimensions = parallelModel.dimensions;
    this._model = parallelModel;
    this._init(parallelModel, ecModel, api2);
  }
  _init(parallelModel, ecModel, api2) {
    const dimensions = parallelModel.dimensions;
    const parallelAxisIndex = parallelModel.parallelAxisIndex;
    each6(dimensions, function(dim, idx) {
      const axisIndex = parallelAxisIndex[idx];
      const axisModel = ecModel.getComponent("parallelAxis", axisIndex);
      const axis = this._axesMap.set(dim, new ParallelAxis_default(dim, createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisIndex));
      const isCategory2 = axis.type === "category";
      axis.onBand = isCategory2 && axisModel.get("boundaryGap");
      axis.inverse = axisModel.get("inverse");
      axisModel.axis = axis;
      axis.model = axisModel;
      axis.coordinateSystem = axisModel.coordinateSystem = this;
    }, this);
  }
  update(ecModel, api2) {
    this._updateAxesFromSeries(this._model, ecModel);
  }
  containPoint(point) {
    const layoutInfo = this._makeLayoutInfo();
    const axisBase = layoutInfo.axisBase;
    const layoutBase = layoutInfo.layoutBase;
    const pixelDimIndex = layoutInfo.pixelDimIndex;
    const pAxis = point[1 - pixelDimIndex];
    const pLayout = point[pixelDimIndex];
    return pAxis >= axisBase && pAxis <= axisBase + layoutInfo.axisLength && pLayout >= layoutBase && pLayout <= layoutBase + layoutInfo.layoutLength;
  }
  getModel() {
    return this._model;
  }
  _updateAxesFromSeries(parallelModel, ecModel) {
    ecModel.eachSeries(function(seriesModel) {
      if (!parallelModel.contains(seriesModel, ecModel)) {
        return;
      }
      const data = seriesModel.getData();
      each6(this.dimensions, function(dim) {
        const axis = this._axesMap.get(dim);
        axis.scale.unionExtentFromData(data, data.mapDimension(dim));
        niceScaleExtent(axis.scale, axis.model);
      }, this);
    }, this);
  }
  resize(parallelModel, api2) {
    const refContainer = createBoxLayoutReference(parallelModel, api2).refContainer;
    this._rect = getLayoutRect(parallelModel.getBoxLayoutParams(), refContainer);
    this._layoutAxes();
  }
  getRect() {
    return this._rect;
  }
  _makeLayoutInfo() {
    const parallelModel = this._model;
    const rect = this._rect;
    const xy = ["x", "y"];
    const wh = ["width", "height"];
    const layout14 = parallelModel.get("layout");
    const pixelDimIndex = layout14 === "horizontal" ? 0 : 1;
    const layoutLength = rect[wh[pixelDimIndex]];
    const layoutExtent = [0, layoutLength];
    const axisCount = this.dimensions.length;
    const axisExpandWidth = restrict2(parallelModel.get("axisExpandWidth"), layoutExtent);
    const axisExpandCount = restrict2(parallelModel.get("axisExpandCount") || 0, [0, axisCount]);
    const axisExpandable = parallelModel.get("axisExpandable") && axisCount > 3 && axisCount > axisExpandCount && axisExpandCount > 1 && axisExpandWidth > 0 && layoutLength > 0;
    let axisExpandWindow = parallelModel.get("axisExpandWindow");
    let winSize;
    if (!axisExpandWindow) {
      winSize = restrict2(axisExpandWidth * (axisExpandCount - 1), layoutExtent);
      const axisExpandCenter = parallelModel.get("axisExpandCenter") || mathFloor2(axisCount / 2);
      axisExpandWindow = [axisExpandWidth * axisExpandCenter - winSize / 2];
      axisExpandWindow[1] = axisExpandWindow[0] + winSize;
    } else {
      winSize = restrict2(axisExpandWindow[1] - axisExpandWindow[0], layoutExtent);
      axisExpandWindow[1] = axisExpandWindow[0] + winSize;
    }
    let axisCollapseWidth = (layoutLength - winSize) / (axisCount - axisExpandCount);
    axisCollapseWidth < 3 && (axisCollapseWidth = 0);
    const winInnerIndices = [
      mathFloor2(round6(axisExpandWindow[0] / axisExpandWidth, 1)) + 1,
      mathCeil2(round6(axisExpandWindow[1] / axisExpandWidth, 1)) - 1
    ];
    const axisExpandWindow0Pos = axisCollapseWidth / axisExpandWidth * axisExpandWindow[0];
    return {
      layout: layout14,
      pixelDimIndex,
      layoutBase: rect[xy[pixelDimIndex]],
      layoutLength,
      axisBase: rect[xy[1 - pixelDimIndex]],
      axisLength: rect[wh[1 - pixelDimIndex]],
      axisExpandable,
      axisExpandWidth,
      axisCollapseWidth,
      axisExpandWindow,
      axisCount,
      winInnerIndices,
      axisExpandWindow0Pos
    };
  }
  _layoutAxes() {
    const rect = this._rect;
    const axes = this._axesMap;
    const dimensions = this.dimensions;
    const layoutInfo = this._makeLayoutInfo();
    const layout14 = layoutInfo.layout;
    axes.each(function(axis) {
      const axisExtent = [0, layoutInfo.axisLength];
      const idx = axis.inverse ? 1 : 0;
      axis.setExtent(axisExtent[idx], axisExtent[1 - idx]);
    });
    each6(dimensions, function(dim, idx) {
      const posInfo = (layoutInfo.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)(idx, layoutInfo);
      const positionTable = {
        horizontal: {
          x: posInfo.position,
          y: layoutInfo.axisLength
        },
        vertical: {
          x: 0,
          y: posInfo.position
        }
      };
      const rotationTable = {
        horizontal: PI9 / 2,
        vertical: 0
      };
      const position2 = [
        positionTable[layout14].x + rect.x,
        positionTable[layout14].y + rect.y
      ];
      const rotation = rotationTable[layout14];
      const transform2 = create2();
      rotate(transform2, transform2, rotation);
      translate(transform2, transform2, position2);
      this._axesLayout[dim] = {
        position: position2,
        rotation,
        transform: transform2,
        axisNameAvailableWidth: posInfo.axisNameAvailableWidth,
        axisLabelShow: posInfo.axisLabelShow,
        nameTruncateMaxWidth: posInfo.nameTruncateMaxWidth,
        tickDirection: 1,
        labelDirection: 1
      };
    }, this);
  }
  getAxis(dim) {
    return this._axesMap.get(dim);
  }
  dataToPoint(value, dim) {
    return this.axisCoordToPoint(this._axesMap.get(dim).dataToCoord(value), dim);
  }
  eachActiveState(data, callback, start2, end2) {
    start2 == null && (start2 = 0);
    end2 == null && (end2 = data.count());
    const axesMap = this._axesMap;
    const dimensions = this.dimensions;
    const dataDimensions = [];
    const axisModels = [];
    each(dimensions, function(axisDim) {
      dataDimensions.push(data.mapDimension(axisDim));
      axisModels.push(axesMap.get(axisDim).model);
    });
    const hasActiveSet = this.hasAxisBrushed();
    for (let dataIndex = start2; dataIndex < end2; dataIndex++) {
      let activeState;
      if (!hasActiveSet) {
        activeState = "normal";
      } else {
        activeState = "active";
        const values = data.getValues(dataDimensions, dataIndex);
        for (let j = 0, lenj = dimensions.length; j < lenj; j++) {
          const state = axisModels[j].getActiveState(values[j]);
          if (state === "inactive") {
            activeState = "inactive";
            break;
          }
        }
      }
      callback(activeState, dataIndex);
    }
  }
  hasAxisBrushed() {
    const dimensions = this.dimensions;
    const axesMap = this._axesMap;
    let hasActiveSet = false;
    for (let j = 0, lenj = dimensions.length; j < lenj; j++) {
      if (axesMap.get(dimensions[j]).model.getActiveState() !== "normal") {
        hasActiveSet = true;
      }
    }
    return hasActiveSet;
  }
  axisCoordToPoint(coord, dim) {
    const axisLayout = this._axesLayout[dim];
    return applyTransform2([coord, 0], axisLayout.transform);
  }
  getAxisLayout(dim) {
    return clone(this._axesLayout[dim]);
  }
  getSlidedAxisExpandWindow(point) {
    const layoutInfo = this._makeLayoutInfo();
    const pixelDimIndex = layoutInfo.pixelDimIndex;
    let axisExpandWindow = layoutInfo.axisExpandWindow.slice();
    const winSize = axisExpandWindow[1] - axisExpandWindow[0];
    const extent = [0, layoutInfo.axisExpandWidth * (layoutInfo.axisCount - 1)];
    if (!this.containPoint(point)) {
      return {behavior: "none", axisExpandWindow};
    }
    const pointCoord = point[pixelDimIndex] - layoutInfo.layoutBase - layoutInfo.axisExpandWindow0Pos;
    let delta;
    let behavior = "slide";
    const axisCollapseWidth = layoutInfo.axisCollapseWidth;
    const triggerArea = this._model.get("axisExpandSlideTriggerArea");
    const useJump = triggerArea[0] != null;
    if (axisCollapseWidth) {
      if (useJump && axisCollapseWidth && pointCoord < winSize * triggerArea[0]) {
        behavior = "jump";
        delta = pointCoord - winSize * triggerArea[2];
      } else if (useJump && axisCollapseWidth && pointCoord > winSize * (1 - triggerArea[0])) {
        behavior = "jump";
        delta = pointCoord - winSize * (1 - triggerArea[2]);
      } else {
        (delta = pointCoord - winSize * triggerArea[1]) >= 0 && (delta = pointCoord - winSize * (1 - triggerArea[1])) <= 0 && (delta = 0);
      }
      delta *= layoutInfo.axisExpandWidth / axisCollapseWidth;
      delta ? sliderMove(delta, axisExpandWindow, extent, "all") : behavior = "none";
    } else {
      const winSize2 = axisExpandWindow[1] - axisExpandWindow[0];
      const pos = extent[1] * pointCoord / winSize2;
      axisExpandWindow = [mathMax10(0, pos - winSize2 / 2)];
      axisExpandWindow[1] = mathMin10(extent[1], axisExpandWindow[0] + winSize2);
      axisExpandWindow[0] = axisExpandWindow[1] - winSize2;
    }
    return {
      axisExpandWindow,
      behavior
    };
  }
};
function restrict2(len2, extent) {
  return mathMin10(mathMax10(len2, extent[0]), extent[1]);
}
function layoutAxisWithoutExpand(axisIndex, layoutInfo) {
  const step = layoutInfo.layoutLength / (layoutInfo.axisCount - 1);
  return {
    position: step * axisIndex,
    axisNameAvailableWidth: step,
    axisLabelShow: true
  };
}
function layoutAxisWithExpand(axisIndex, layoutInfo) {
  const layoutLength = layoutInfo.layoutLength;
  const axisExpandWidth = layoutInfo.axisExpandWidth;
  const axisCount = layoutInfo.axisCount;
  const axisCollapseWidth = layoutInfo.axisCollapseWidth;
  const winInnerIndices = layoutInfo.winInnerIndices;
  let position2;
  let axisNameAvailableWidth = axisCollapseWidth;
  let axisLabelShow = false;
  let nameTruncateMaxWidth;
  if (axisIndex < winInnerIndices[0]) {
    position2 = axisIndex * axisCollapseWidth;
    nameTruncateMaxWidth = axisCollapseWidth;
  } else if (axisIndex <= winInnerIndices[1]) {
    position2 = layoutInfo.axisExpandWindow0Pos + axisIndex * axisExpandWidth - layoutInfo.axisExpandWindow[0];
    axisNameAvailableWidth = axisExpandWidth;
    axisLabelShow = true;
  } else {
    position2 = layoutLength - (axisCount - 1 - axisIndex) * axisCollapseWidth;
    nameTruncateMaxWidth = axisCollapseWidth;
  }
  return {
    position: position2,
    axisNameAvailableWidth,
    axisLabelShow,
    nameTruncateMaxWidth
  };
}
var Parallel_default = Parallel;

// src/coord/parallel/parallelCreator.ts
function createParallelCoordSys(ecModel, api2) {
  const coordSysList = [];
  ecModel.eachComponent("parallel", function(parallelModel, idx) {
    const coordSys = new Parallel_default(parallelModel, ecModel, api2);
    coordSys.name = "parallel_" + idx;
    coordSys.resize(parallelModel, api2);
    parallelModel.coordinateSystem = coordSys;
    coordSys.model = parallelModel;
    coordSysList.push(coordSys);
  });
  ecModel.eachSeries(function(seriesModel) {
    if (seriesModel.get("coordinateSystem") === "parallel") {
      const parallelModel = seriesModel.getReferringComponents("parallel", SINGLE_REFERRING).models[0];
      seriesModel.coordinateSystem = parallelModel.coordinateSystem;
    }
  });
  return coordSysList;
}
var parallelCoordSysCreator = {
  create: createParallelCoordSys
};
var parallelCreator_default = parallelCoordSysCreator;

// src/coord/parallel/AxisModel.ts
var ParallelAxisModel = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = ParallelAxisModel.type;
    this.activeIntervals = [];
  }
  getAreaSelectStyle() {
    return makeStyleMapper([
      ["fill", "color"],
      ["lineWidth", "borderWidth"],
      ["stroke", "borderColor"],
      ["width", "width"],
      ["opacity", "opacity"]
    ])(this.getModel("areaSelectStyle"));
  }
  setActiveIntervals(intervals) {
    const activeIntervals = this.activeIntervals = clone(intervals);
    if (activeIntervals) {
      for (let i = activeIntervals.length - 1; i >= 0; i--) {
        asc(activeIntervals[i]);
      }
    }
  }
  getActiveState(value) {
    const activeIntervals = this.activeIntervals;
    if (!activeIntervals.length) {
      return "normal";
    }
    if (value == null || isNaN(+value)) {
      return "inactive";
    }
    if (activeIntervals.length === 1) {
      const interval = activeIntervals[0];
      if (interval[0] <= value && value <= interval[1]) {
        return "active";
      }
    } else {
      for (let i = 0, len2 = activeIntervals.length; i < len2; i++) {
        if (activeIntervals[i][0] <= value && value <= activeIntervals[i][1]) {
          return "active";
        }
      }
    }
    return "inactive";
  }
};
mixin(ParallelAxisModel, AxisModelCommonMixin);
var AxisModel_default = ParallelAxisModel;

// src/component/helper/BrushController.ts
var BRUSH_PANEL_GLOBAL = true;
var mathMin11 = Math.min;
var mathMax11 = Math.max;
var mathPow3 = Math.pow;
var COVER_Z = 1e4;
var UNSELECT_THRESHOLD = 6;
var MIN_RESIZE_LINE_WIDTH = 6;
var MUTEX_RESOURCE_KEY = "globalPan";
var DIRECTION_MAP = {
  w: [0, 0],
  e: [0, 1],
  n: [1, 0],
  s: [1, 1]
};
var CURSOR_MAP = {
  w: "ew",
  e: "ew",
  n: "ns",
  s: "ns",
  ne: "nesw",
  sw: "nesw",
  nw: "nwse",
  se: "nwse"
};
var DEFAULT_BRUSH_OPT = {
  brushStyle: {
    lineWidth: 2,
    stroke: tokens_default.color.backgroundTint,
    fill: tokens_default.color.borderTint
  },
  transformable: true,
  brushMode: "single",
  removeOnClick: false
};
var baseUID = 0;
var BrushController = class extends Eventful_default {
  constructor(zr) {
    super();
    this._track = [];
    this._covers = [];
    this._handlers = {};
    if (true) {
      assert(zr);
    }
    this._zr = zr;
    this.group = new Group_default();
    this._uid = "brushController_" + baseUID++;
    each(pointerHandlers, function(handler, eventName) {
      this._handlers[eventName] = bind(handler, this);
    }, this);
  }
  enableBrush(brushOption) {
    if (true) {
      assert(this._mounted);
    }
    this._brushType && this._doDisableBrush();
    brushOption.brushType && this._doEnableBrush(brushOption);
    return this;
  }
  _doEnableBrush(brushOption) {
    const zr = this._zr;
    if (!this._enableGlobalPan) {
      take(zr, MUTEX_RESOURCE_KEY, this._uid);
    }
    each(this._handlers, function(handler, eventName) {
      zr.on(eventName, handler);
    });
    this._brushType = brushOption.brushType;
    this._brushOption = merge(clone(DEFAULT_BRUSH_OPT), brushOption, true);
  }
  _doDisableBrush() {
    const zr = this._zr;
    release(zr, MUTEX_RESOURCE_KEY, this._uid);
    each(this._handlers, function(handler, eventName) {
      zr.off(eventName, handler);
    });
    this._brushType = this._brushOption = null;
  }
  setPanels(panelOpts) {
    if (panelOpts && panelOpts.length) {
      const panels = this._panels = {};
      each(panelOpts, function(panelOpts2) {
        panels[panelOpts2.panelId] = clone(panelOpts2);
      });
    } else {
      this._panels = null;
    }
    return this;
  }
  mount(opt) {
    opt = opt || {};
    if (true) {
      this._mounted = true;
    }
    this._enableGlobalPan = opt.enableGlobalPan;
    const thisGroup = this.group;
    this._zr.add(thisGroup);
    thisGroup.attr({
      x: opt.x || 0,
      y: opt.y || 0,
      rotation: opt.rotation || 0,
      scaleX: opt.scaleX || 1,
      scaleY: opt.scaleY || 1
    });
    this._transform = thisGroup.getLocalTransform();
    return this;
  }
  updateCovers(coverConfigList) {
    if (true) {
      assert(this._mounted);
    }
    coverConfigList = map(coverConfigList, function(coverConfig) {
      return merge(clone(DEFAULT_BRUSH_OPT), coverConfig, true);
    });
    const tmpIdPrefix = "\0-brush-index-";
    const oldCovers = this._covers;
    const newCovers = this._covers = [];
    const controller = this;
    const creatingCover = this._creatingCover;
    new DataDiffer_default(oldCovers, coverConfigList, oldGetKey, getKey2).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();
    return this;
    function getKey2(brushOption, index) {
      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + "-" + brushOption.brushType;
    }
    function oldGetKey(cover, index) {
      return getKey2(cover.__brushOption, index);
    }
    function addOrUpdate(newIndex, oldIndex) {
      const newBrushInternal = coverConfigList[newIndex];
      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {
        newCovers[newIndex] = oldCovers[oldIndex];
      } else {
        const cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushInternal, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushInternal));
        updateCoverAfterCreation(controller, cover);
      }
    }
    function remove(oldIndex) {
      if (oldCovers[oldIndex] !== creatingCover) {
        controller.group.remove(oldCovers[oldIndex]);
      }
    }
  }
  unmount() {
    if (true) {
      if (!this._mounted) {
        return;
      }
    }
    this.enableBrush(false);
    clearCovers(this);
    this._zr.remove(this.group);
    if (true) {
      this._mounted = false;
    }
    return this;
  }
  dispose() {
    this.unmount();
    this.off();
  }
};
function createCover(controller, brushOption) {
  const cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);
  cover.__brushOption = brushOption;
  updateZ(cover, brushOption);
  controller.group.add(cover);
  return cover;
}
function endCreating(controller, creatingCover) {
  const coverRenderer = getCoverRenderer(creatingCover);
  if (coverRenderer.endCreating) {
    coverRenderer.endCreating(controller, creatingCover);
    updateZ(creatingCover, creatingCover.__brushOption);
  }
  return creatingCover;
}
function updateCoverShape(controller, cover) {
  const brushOption = cover.__brushOption;
  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);
}
function updateZ(cover, brushOption) {
  let z = brushOption.z;
  z == null && (z = COVER_Z);
  cover.traverse(function(el) {
    el.z = z;
    el.z2 = z;
  });
}
function updateCoverAfterCreation(controller, cover) {
  getCoverRenderer(cover).updateCommon(controller, cover);
  updateCoverShape(controller, cover);
}
function getCoverRenderer(cover) {
  return coverRenderers[cover.__brushOption.brushType];
}
function getPanelByPoint(controller, e2, localCursorPoint) {
  const panels = controller._panels;
  if (!panels) {
    return BRUSH_PANEL_GLOBAL;
  }
  let panel;
  const transform2 = controller._transform;
  each(panels, function(pn) {
    pn.isTargetByCursor(e2, localCursorPoint, transform2) && (panel = pn);
  });
  return panel;
}
function getPanelByCover(controller, cover) {
  const panels = controller._panels;
  if (!panels) {
    return BRUSH_PANEL_GLOBAL;
  }
  const panelId = cover.__brushOption.panelId;
  return panelId != null ? panels[panelId] : BRUSH_PANEL_GLOBAL;
}
function clearCovers(controller) {
  const covers = controller._covers;
  const originalLength = covers.length;
  each(covers, function(cover) {
    controller.group.remove(cover);
  }, controller);
  covers.length = 0;
  return !!originalLength;
}
function trigger2(controller, opt) {
  const areas = map(controller._covers, function(cover) {
    const brushOption = cover.__brushOption;
    const range = clone(brushOption.range);
    return {
      brushType: brushOption.brushType,
      panelId: brushOption.panelId,
      range
    };
  });
  controller.trigger("brush", {
    areas,
    isEnd: !!opt.isEnd,
    removeOnClick: !!opt.removeOnClick
  });
}
function shouldShowCover(controller) {
  const track = controller._track;
  if (!track.length) {
    return false;
  }
  const p2 = track[track.length - 1];
  const p1 = track[0];
  const dx = p2[0] - p1[0];
  const dy = p2[1] - p1[1];
  const dist3 = mathPow3(dx * dx + dy * dy, 0.5);
  return dist3 > UNSELECT_THRESHOLD;
}
function getTrackEnds(track) {
  let tail = track.length - 1;
  tail < 0 && (tail = 0);
  return [track[0], track[tail]];
}
function createBaseRectCover(rectRangeConverter, controller, brushOption, edgeNameSequences) {
  const cover = new Group_default();
  cover.add(new Rect_default({
    name: "main",
    style: makeStyle(brushOption),
    silent: true,
    draggable: true,
    cursor: "move",
    drift: curry(driftRect, rectRangeConverter, controller, cover, ["n", "s", "w", "e"]),
    ondragend: curry(trigger2, controller, {isEnd: true})
  }));
  each(edgeNameSequences, function(nameSequence) {
    cover.add(new Rect_default({
      name: nameSequence.join(""),
      style: {opacity: 0},
      draggable: true,
      silent: true,
      invisible: true,
      drift: curry(driftRect, rectRangeConverter, controller, cover, nameSequence),
      ondragend: curry(trigger2, controller, {isEnd: true})
    }));
  });
  return cover;
}
function updateBaseRect(controller, cover, localRange, brushOption) {
  const lineWidth = brushOption.brushStyle.lineWidth || 0;
  const handleSize = mathMax11(lineWidth, MIN_RESIZE_LINE_WIDTH);
  const x = localRange[0][0];
  const y = localRange[1][0];
  const xa = x - lineWidth / 2;
  const ya = y - lineWidth / 2;
  const x2 = localRange[0][1];
  const y2 = localRange[1][1];
  const x2a = x2 - handleSize + lineWidth / 2;
  const y2a = y2 - handleSize + lineWidth / 2;
  const width = x2 - x;
  const height = y2 - y;
  const widtha = width + lineWidth;
  const heighta = height + lineWidth;
  updateRectShape(controller, cover, "main", x, y, width, height);
  if (brushOption.transformable) {
    updateRectShape(controller, cover, "w", xa, ya, handleSize, heighta);
    updateRectShape(controller, cover, "e", x2a, ya, handleSize, heighta);
    updateRectShape(controller, cover, "n", xa, ya, widtha, handleSize);
    updateRectShape(controller, cover, "s", xa, y2a, widtha, handleSize);
    updateRectShape(controller, cover, "nw", xa, ya, handleSize, handleSize);
    updateRectShape(controller, cover, "ne", x2a, ya, handleSize, handleSize);
    updateRectShape(controller, cover, "sw", xa, y2a, handleSize, handleSize);
    updateRectShape(controller, cover, "se", x2a, y2a, handleSize, handleSize);
  }
}
function updateCommon(controller, cover) {
  const brushOption = cover.__brushOption;
  const transformable = brushOption.transformable;
  const mainEl = cover.childAt(0);
  mainEl.useStyle(makeStyle(brushOption));
  mainEl.attr({
    silent: !transformable,
    cursor: transformable ? "move" : "default"
  });
  each([["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]], function(nameSequence) {
    const el = cover.childOfName(nameSequence.join(""));
    const globalDir = nameSequence.length === 1 ? getGlobalDirection1(controller, nameSequence[0]) : getGlobalDirection2(controller, nameSequence);
    el && el.attr({
      silent: !transformable,
      invisible: !transformable,
      cursor: transformable ? CURSOR_MAP[globalDir] + "-resize" : null
    });
  });
}
function updateRectShape(controller, cover, name, x, y, w, h) {
  const el = cover.childOfName(name);
  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));
}
function makeStyle(brushOption) {
  return defaults({strokeNoScale: true}, brushOption.brushStyle);
}
function formatRectRange(x, y, x2, y2) {
  const min3 = [mathMin11(x, x2), mathMin11(y, y2)];
  const max3 = [mathMax11(x, x2), mathMax11(y, y2)];
  return [
    [min3[0], max3[0]],
    [min3[1], max3[1]]
  ];
}
function getTransform2(controller) {
  return getTransform(controller.group);
}
function getGlobalDirection1(controller, localDirName) {
  const map3 = {w: "left", e: "right", n: "top", s: "bottom"};
  const inverseMap = {left: "w", right: "e", top: "n", bottom: "s"};
  const dir3 = transformDirection(map3[localDirName], getTransform2(controller));
  return inverseMap[dir3];
}
function getGlobalDirection2(controller, localDirNameSeq) {
  const globalDir = [
    getGlobalDirection1(controller, localDirNameSeq[0]),
    getGlobalDirection1(controller, localDirNameSeq[1])
  ];
  (globalDir[0] === "e" || globalDir[0] === "w") && globalDir.reverse();
  return globalDir.join("");
}
function driftRect(rectRangeConverter, controller, cover, dirNameSequence, dx, dy) {
  const brushOption = cover.__brushOption;
  const rectRange = rectRangeConverter.toRectRange(brushOption.range);
  const localDelta = toLocalDelta(controller, dx, dy);
  each(dirNameSequence, function(dirName) {
    const ind = DIRECTION_MAP[dirName];
    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];
  });
  brushOption.range = rectRangeConverter.fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));
  updateCoverAfterCreation(controller, cover);
  trigger2(controller, {isEnd: false});
}
function driftPolygon(controller, cover, dx, dy) {
  const range = cover.__brushOption.range;
  const localDelta = toLocalDelta(controller, dx, dy);
  each(range, function(point) {
    point[0] += localDelta[0];
    point[1] += localDelta[1];
  });
  updateCoverAfterCreation(controller, cover);
  trigger2(controller, {isEnd: false});
}
function toLocalDelta(controller, dx, dy) {
  const thisGroup = controller.group;
  const localD = thisGroup.transformCoordToLocal(dx, dy);
  const localZero = thisGroup.transformCoordToLocal(0, 0);
  return [localD[0] - localZero[0], localD[1] - localZero[1]];
}
function clipByPanel(controller, cover, data) {
  const panel = getPanelByCover(controller, cover);
  return panel && panel !== BRUSH_PANEL_GLOBAL ? panel.clipPath(data, controller._transform) : clone(data);
}
function pointsToRect(points4) {
  const xmin = mathMin11(points4[0][0], points4[1][0]);
  const ymin = mathMin11(points4[0][1], points4[1][1]);
  const xmax = mathMax11(points4[0][0], points4[1][0]);
  const ymax = mathMax11(points4[0][1], points4[1][1]);
  return {
    x: xmin,
    y: ymin,
    width: xmax - xmin,
    height: ymax - ymin
  };
}
function resetCursor(controller, e2, localCursorPoint) {
  if (!controller._brushType || isOutsideZrArea(controller, e2.offsetX, e2.offsetY)) {
    return;
  }
  const zr = controller._zr;
  const covers = controller._covers;
  const currPanel = getPanelByPoint(controller, e2, localCursorPoint);
  if (!controller._dragging) {
    for (let i = 0; i < covers.length; i++) {
      const brushOption = covers[i].__brushOption;
      if (currPanel && (currPanel === BRUSH_PANEL_GLOBAL || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {
        return;
      }
    }
  }
  currPanel && zr.setCursorStyle("crosshair");
}
function preventDefault(e2) {
  const rawE = e2.event;
  rawE.preventDefault && rawE.preventDefault();
}
function mainShapeContain(cover, x, y) {
  return cover.childOfName("main").contain(x, y);
}
function updateCoverByMouse(controller, e2, localCursorPoint, isEnd) {
  let creatingCover = controller._creatingCover;
  const panel = controller._creatingPanel;
  const thisBrushOption = controller._brushOption;
  let eventParams;
  controller._track.push(localCursorPoint.slice());
  if (shouldShowCover(controller) || creatingCover) {
    if (panel && !creatingCover) {
      thisBrushOption.brushMode === "single" && clearCovers(controller);
      const brushOption = clone(thisBrushOption);
      brushOption.brushType = determineBrushType(brushOption.brushType, panel);
      brushOption.panelId = panel === BRUSH_PANEL_GLOBAL ? null : panel.panelId;
      creatingCover = controller._creatingCover = createCover(controller, brushOption);
      controller._covers.push(creatingCover);
    }
    if (creatingCover) {
      const coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];
      const coverBrushOption = creatingCover.__brushOption;
      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));
      if (isEnd) {
        endCreating(controller, creatingCover);
        coverRenderer.updateCommon(controller, creatingCover);
      }
      updateCoverShape(controller, creatingCover);
      eventParams = {isEnd};
    }
  } else if (isEnd && thisBrushOption.brushMode === "single" && thisBrushOption.removeOnClick) {
    if (getPanelByPoint(controller, e2, localCursorPoint) && clearCovers(controller)) {
      eventParams = {isEnd, removeOnClick: true};
    }
  }
  return eventParams;
}
function determineBrushType(brushType, panel) {
  if (brushType === "auto") {
    if (true) {
      assert(panel && panel.defaultBrushType, 'MUST have defaultBrushType when brushType is "atuo"');
    }
    return panel.defaultBrushType;
  }
  return brushType;
}
var pointerHandlers = {
  mousedown: function(e2) {
    if (this._dragging) {
      handleDragEnd(this, e2);
    } else if (!e2.target || !e2.target.draggable) {
      preventDefault(e2);
      const localCursorPoint = this.group.transformCoordToLocal(e2.offsetX, e2.offsetY);
      this._creatingCover = null;
      const panel = this._creatingPanel = getPanelByPoint(this, e2, localCursorPoint);
      if (panel) {
        this._dragging = true;
        this._track = [localCursorPoint.slice()];
      }
    }
  },
  mousemove: function(e2) {
    const x = e2.offsetX;
    const y = e2.offsetY;
    const localCursorPoint = this.group.transformCoordToLocal(x, y);
    resetCursor(this, e2, localCursorPoint);
    if (this._dragging) {
      preventDefault(e2);
      const eventParams = updateCoverByMouse(this, e2, localCursorPoint, false);
      eventParams && trigger2(this, eventParams);
    }
  },
  mouseup: function(e2) {
    handleDragEnd(this, e2);
  }
};
function handleDragEnd(controller, e2) {
  if (controller._dragging) {
    preventDefault(e2);
    const x = e2.offsetX;
    const y = e2.offsetY;
    const localCursorPoint = controller.group.transformCoordToLocal(x, y);
    const eventParams = updateCoverByMouse(controller, e2, localCursorPoint, true);
    controller._dragging = false;
    controller._track = [];
    controller._creatingCover = null;
    eventParams && trigger2(controller, eventParams);
  }
}
function isOutsideZrArea(controller, x, y) {
  const zr = controller._zr;
  return x < 0 || x > zr.getWidth() || y < 0 || y > zr.getHeight();
}
var coverRenderers = {
  lineX: getLineRenderer(0),
  lineY: getLineRenderer(1),
  rect: {
    createCover: function(controller, brushOption) {
      function returnInput(range) {
        return range;
      }
      return createBaseRectCover({
        toRectRange: returnInput,
        fromRectRange: returnInput
      }, controller, brushOption, [["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]]);
    },
    getCreatingRange: function(localTrack) {
      const ends = getTrackEnds(localTrack);
      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);
    },
    updateCoverShape: function(controller, cover, localRange, brushOption) {
      updateBaseRect(controller, cover, localRange, brushOption);
    },
    updateCommon,
    contain: mainShapeContain
  },
  polygon: {
    createCover: function(controller, brushOption) {
      const cover = new Group_default();
      cover.add(new Polyline_default({
        name: "main",
        style: makeStyle(brushOption),
        silent: true
      }));
      return cover;
    },
    getCreatingRange: function(localTrack) {
      return localTrack;
    },
    endCreating: function(controller, cover) {
      cover.remove(cover.childAt(0));
      cover.add(new Polygon_default({
        name: "main",
        draggable: true,
        drift: curry(driftPolygon, controller, cover),
        ondragend: curry(trigger2, controller, {isEnd: true})
      }));
    },
    updateCoverShape: function(controller, cover, localRange, brushOption) {
      cover.childAt(0).setShape({
        points: clipByPanel(controller, cover, localRange)
      });
    },
    updateCommon,
    contain: mainShapeContain
  }
};
function getLineRenderer(xyIndex) {
  return {
    createCover: function(controller, brushOption) {
      return createBaseRectCover({
        toRectRange: function(range) {
          const rectRange = [range, [0, 100]];
          xyIndex && rectRange.reverse();
          return rectRange;
        },
        fromRectRange: function(rectRange) {
          return rectRange[xyIndex];
        }
      }, controller, brushOption, [[["w"], ["e"]], [["n"], ["s"]]][xyIndex]);
    },
    getCreatingRange: function(localTrack) {
      const ends = getTrackEnds(localTrack);
      const min3 = mathMin11(ends[0][xyIndex], ends[1][xyIndex]);
      const max3 = mathMax11(ends[0][xyIndex], ends[1][xyIndex]);
      return [min3, max3];
    },
    updateCoverShape: function(controller, cover, localRange, brushOption) {
      let otherExtent;
      const panel = getPanelByCover(controller, cover);
      if (panel !== BRUSH_PANEL_GLOBAL && panel.getLinearBrushOtherExtent) {
        otherExtent = panel.getLinearBrushOtherExtent(xyIndex);
      } else {
        const zr = controller._zr;
        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];
      }
      const rectRange = [localRange, otherExtent];
      xyIndex && rectRange.reverse();
      updateBaseRect(controller, cover, rectRange, brushOption);
    },
    updateCommon,
    contain: mainShapeContain
  };
}
var BrushController_default = BrushController;

// src/component/helper/brushHelper.ts
function makeRectPanelClipPath(rect) {
  rect = normalizeRect(rect);
  return function(localPoints) {
    return clipPointsByRect(localPoints, rect);
  };
}
function makeLinearBrushOtherExtent(rect, specifiedXYIndex) {
  rect = normalizeRect(rect);
  return function(xyIndex) {
    const idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;
    const brushWidth = idx ? rect.width : rect.height;
    const base2 = idx ? rect.x : rect.y;
    return [base2, base2 + (brushWidth || 0)];
  };
}
function makeRectIsTargetByCursor(rect, api2, targetModel) {
  const boundingRect = normalizeRect(rect);
  return function(e2, localCursorPoint) {
    return boundingRect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e2, api2, targetModel);
  };
}
function normalizeRect(rect) {
  return BoundingRect_default.create(rect);
}

// src/component/axis/ParallelAxisView.ts
var ParallelAxisView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = ParallelAxisView2.type;
  }
  init(ecModel, api2) {
    super.init.apply(this, arguments);
    (this._brushController = new BrushController_default(api2.getZr())).on("brush", bind(this._onBrush, this));
  }
  render(axisModel, ecModel, api2, payload) {
    if (fromAxisAreaSelect(axisModel, ecModel, payload)) {
      return;
    }
    this.axisModel = axisModel;
    this.api = api2;
    this.group.removeAll();
    const oldAxisGroup = this._axisGroup;
    this._axisGroup = new Group_default();
    this.group.add(this._axisGroup);
    if (!axisModel.get("show")) {
      return;
    }
    const coordSysModel = getCoordSysModel(axisModel, ecModel);
    const coordSys = coordSysModel.coordinateSystem;
    const areaSelectStyle = axisModel.getAreaSelectStyle();
    const areaWidth = areaSelectStyle.width;
    const dim = axisModel.axis.dim;
    const axisLayout = coordSys.getAxisLayout(dim);
    const builderOpt = extend({strokeContainThreshold: areaWidth}, axisLayout);
    const axisBuilder = new AxisBuilder_default(axisModel, api2, builderOpt);
    axisBuilder.build();
    this._axisGroup.add(axisBuilder.group);
    this._refreshBrushController(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api2);
    groupTransition(oldAxisGroup, this._axisGroup, axisModel);
  }
  _refreshBrushController(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api2) {
    const extent = axisModel.axis.getExtent();
    const extentLen = extent[1] - extent[0];
    const extra = Math.min(30, Math.abs(extentLen) * 0.1);
    const rect = BoundingRect_default.create({
      x: extent[0],
      y: -areaWidth / 2,
      width: extentLen,
      height: areaWidth
    });
    rect.x -= extra;
    rect.width += 2 * extra;
    this._brushController.mount({
      enableGlobalPan: true,
      rotation: builderOpt.rotation,
      x: builderOpt.position[0],
      y: builderOpt.position[1]
    }).setPanels([{
      panelId: "pl",
      clipPath: makeRectPanelClipPath(rect),
      isTargetByCursor: makeRectIsTargetByCursor(rect, api2, coordSysModel),
      getLinearBrushOtherExtent: makeLinearBrushOtherExtent(rect, 0)
    }]).enableBrush({
      brushType: "lineX",
      brushStyle: areaSelectStyle,
      removeOnClick: true
    }).updateCovers(getCoverInfoList(axisModel));
  }
  _onBrush(eventParam) {
    const coverInfoList = eventParam.areas;
    const axisModel = this.axisModel;
    const axis = axisModel.axis;
    const intervals = map(coverInfoList, function(coverInfo) {
      return [
        axis.coordToData(coverInfo.range[0], true),
        axis.coordToData(coverInfo.range[1], true)
      ];
    });
    if (!axisModel.option.realtime === eventParam.isEnd || eventParam.removeOnClick) {
      this.api.dispatchAction({
        type: "axisAreaSelect",
        parallelAxisId: axisModel.id,
        intervals
      });
    }
  }
  dispose() {
    this._brushController.dispose();
  }
};
var ParallelAxisView = ParallelAxisView2;
ParallelAxisView.type = "parallelAxis";
function fromAxisAreaSelect(axisModel, ecModel, payload) {
  return payload && payload.type === "axisAreaSelect" && ecModel.findComponents({mainType: "parallelAxis", query: payload})[0] === axisModel;
}
function getCoverInfoList(axisModel) {
  const axis = axisModel.axis;
  return map(axisModel.activeIntervals, function(interval) {
    return {
      brushType: "lineX",
      panelId: "pl",
      range: [
        axis.dataToCoord(interval[0], true),
        axis.dataToCoord(interval[1], true)
      ]
    };
  });
}
function getCoordSysModel(axisModel, ecModel) {
  return ecModel.getComponent("parallel", axisModel.get("parallelIndex"));
}
var ParallelAxisView_default = ParallelAxisView;

// src/component/axis/parallelAxisAction.ts
var actionInfo = {
  type: "axisAreaSelect",
  event: "axisAreaSelected"
};
function installParallelActions(registers) {
  registers.registerAction(actionInfo, function(payload, ecModel) {
    ecModel.eachComponent({mainType: "parallelAxis", query: payload}, function(parallelAxisModel) {
      parallelAxisModel.axis.model.setActiveIntervals(payload.intervals);
    });
  });
  registers.registerAction("parallelAxisExpand", function(payload, ecModel) {
    ecModel.eachComponent({mainType: "parallel", query: payload}, function(parallelModel) {
      parallelModel.setAxisExpand(payload);
    });
  });
}

// src/component/parallel/install.ts
var defaultAxisOption = {
  type: "value",
  areaSelectStyle: {
    width: 20,
    borderWidth: 1,
    borderColor: "rgba(160,197,232)",
    color: "rgba(160,197,232)",
    opacity: 0.3
  },
  realtime: true,
  z: 10
};
function install18(registers) {
  registers.registerComponentView(ParallelView_default2);
  registers.registerComponentModel(ParallelModel_default);
  registers.registerCoordinateSystem("parallel", parallelCreator_default);
  registers.registerPreprocessor(parallelPreprocessor);
  registers.registerComponentModel(AxisModel_default);
  registers.registerComponentView(ParallelAxisView_default);
  axisModelCreator(registers, "parallel", AxisModel_default, defaultAxisOption);
  installParallelActions(registers);
}

// src/chart/parallel/install.ts
function install19(registers) {
  use(install18);
  registers.registerChartView(ParallelView_default);
  registers.registerSeriesModel(ParallelSeries_default);
  registers.registerVisual(registers.PRIORITY.VISUAL.BRUSH, parallelVisual_default);
}

// src/chart/sankey/SankeyView.ts
var SankeyPathShape = class {
  constructor() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.cpx1 = 0;
    this.cpy1 = 0;
    this.cpx2 = 0;
    this.cpy2 = 0;
    this.extent = 0;
  }
};
var SankeyPath = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultShape() {
    return new SankeyPathShape();
  }
  buildPath(ctx, shape) {
    const extent = shape.extent;
    ctx.moveTo(shape.x1, shape.y1);
    ctx.bezierCurveTo(shape.cpx1, shape.cpy1, shape.cpx2, shape.cpy2, shape.x2, shape.y2);
    if (shape.orient === "vertical") {
      ctx.lineTo(shape.x2 + extent, shape.y2);
      ctx.bezierCurveTo(shape.cpx2 + extent, shape.cpy2, shape.cpx1 + extent, shape.cpy1, shape.x1 + extent, shape.y1);
    } else {
      ctx.lineTo(shape.x2, shape.y2 + extent);
      ctx.bezierCurveTo(shape.cpx2, shape.cpy2 + extent, shape.cpx1, shape.cpy1 + extent, shape.x1, shape.y1 + extent);
    }
    ctx.closePath();
  }
  highlight() {
    enterEmphasis(this);
  }
  downplay() {
    leaveEmphasis(this);
  }
};
var SankeyView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = SankeyView2.type;
    this._mainGroup = new Group_default();
    this._focusAdjacencyDisabled = false;
  }
  init(ecModel, api2) {
    this._controller = new RoamController_default(api2.getZr());
    this._controllerHost = {
      target: this.group
    };
    this.group.add(this._mainGroup);
  }
  render(seriesModel, ecModel, api2) {
    const sankeyView = this;
    const graph = seriesModel.getGraph();
    const mainGroup = this._mainGroup;
    const layoutInfo = seriesModel.layoutInfo;
    const width = layoutInfo.width;
    const height = layoutInfo.height;
    const nodeData = seriesModel.getData();
    const edgeData = seriesModel.getData("edge");
    const orient = seriesModel.get("orient");
    this._model = seriesModel;
    mainGroup.removeAll();
    mainGroup.x = layoutInfo.x;
    mainGroup.y = layoutInfo.y;
    this._updateViewCoordSys(seriesModel, api2);
    updateController(seriesModel, api2, mainGroup, this._controller, this._controllerHost, null);
    graph.eachEdge(function(edge) {
      const curve4 = new SankeyPath();
      const ecData = getECData(curve4);
      ecData.dataIndex = edge.dataIndex;
      ecData.seriesIndex = seriesModel.seriesIndex;
      ecData.dataType = "edge";
      const edgeModel = edge.getModel();
      const lineStyleModel = edgeModel.getModel("lineStyle");
      const curvature = lineStyleModel.get("curveness");
      const n1Layout = edge.node1.getLayout();
      const node1Model = edge.node1.getModel();
      const dragX1 = node1Model.get("localX");
      const dragY1 = node1Model.get("localY");
      const n2Layout = edge.node2.getLayout();
      const node2Model = edge.node2.getModel();
      const dragX2 = node2Model.get("localX");
      const dragY2 = node2Model.get("localY");
      const edgeLayout = edge.getLayout();
      let x1;
      let y1;
      let x2;
      let y2;
      let cpx1;
      let cpy1;
      let cpx2;
      let cpy2;
      curve4.shape.extent = Math.max(1, edgeLayout.dy);
      curve4.shape.orient = orient;
      if (orient === "vertical") {
        x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + edgeLayout.sy;
        y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + n1Layout.dy;
        x2 = (dragX2 != null ? dragX2 * width : n2Layout.x) + edgeLayout.ty;
        y2 = dragY2 != null ? dragY2 * height : n2Layout.y;
        cpx1 = x1;
        cpy1 = y1 * (1 - curvature) + y2 * curvature;
        cpx2 = x2;
        cpy2 = y1 * curvature + y2 * (1 - curvature);
      } else {
        x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + n1Layout.dx;
        y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + edgeLayout.sy;
        x2 = dragX2 != null ? dragX2 * width : n2Layout.x;
        y2 = (dragY2 != null ? dragY2 * height : n2Layout.y) + edgeLayout.ty;
        cpx1 = x1 * (1 - curvature) + x2 * curvature;
        cpy1 = y1;
        cpx2 = x1 * curvature + x2 * (1 - curvature);
        cpy2 = y2;
      }
      curve4.setShape({
        x1,
        y1,
        x2,
        y2,
        cpx1,
        cpy1,
        cpx2,
        cpy2
      });
      curve4.useStyle(lineStyleModel.getItemStyle());
      applyCurveStyle(curve4.style, orient, edge);
      const defaultEdgeLabelText = `${edgeModel.get("value")}`;
      const edgeLabelStateModels = getLabelStatesModels(edgeModel, "edgeLabel");
      setLabelStyle(curve4, edgeLabelStateModels, {
        labelFetcher: {
          getFormattedLabel(dataIndex, stateName, dataType, labelDimIndex, formatter, extendParams) {
            return seriesModel.getFormattedLabel(dataIndex, stateName, "edge", labelDimIndex, retrieve3(formatter, edgeLabelStateModels.normal && edgeLabelStateModels.normal.get("formatter"), defaultEdgeLabelText), extendParams);
          }
        },
        labelDataIndex: edge.dataIndex,
        defaultText: defaultEdgeLabelText
      });
      curve4.setTextConfig({position: "inside"});
      const emphasisModel = edgeModel.getModel("emphasis");
      setStatesStylesFromModel(curve4, edgeModel, "lineStyle", (model) => {
        const style = model.getItemStyle();
        applyCurveStyle(style, orient, edge);
        return style;
      });
      mainGroup.add(curve4);
      edgeData.setItemGraphicEl(edge.dataIndex, curve4);
      const focus = emphasisModel.get("focus");
      toggleHoverEmphasis(curve4, focus === "adjacency" ? edge.getAdjacentDataIndices() : focus === "trajectory" ? edge.getTrajectoryDataIndices() : focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    });
    graph.eachNode(function(node) {
      const layout14 = node.getLayout();
      const itemModel = node.getModel();
      const dragX = itemModel.get("localX");
      const dragY = itemModel.get("localY");
      const emphasisModel = itemModel.getModel("emphasis");
      const borderRadius = itemModel.get(["itemStyle", "borderRadius"]) || 0;
      const rect = new Rect_default({
        shape: {
          x: dragX != null ? dragX * width : layout14.x,
          y: dragY != null ? dragY * height : layout14.y,
          width: layout14.dx,
          height: layout14.dy,
          r: borderRadius
        },
        style: itemModel.getModel("itemStyle").getItemStyle(),
        z2: 10
      });
      setLabelStyle(rect, getLabelStatesModels(itemModel), {
        labelFetcher: {
          getFormattedLabel(dataIndex, stateName) {
            return seriesModel.getFormattedLabel(dataIndex, stateName, "node");
          }
        },
        labelDataIndex: node.dataIndex,
        defaultText: node.id
      });
      rect.disableLabelAnimation = true;
      rect.setStyle("fill", node.getVisual("color"));
      rect.setStyle("decal", node.getVisual("style").decal);
      setStatesStylesFromModel(rect, itemModel);
      mainGroup.add(rect);
      nodeData.setItemGraphicEl(node.dataIndex, rect);
      getECData(rect).dataType = "node";
      const focus = emphasisModel.get("focus");
      toggleHoverEmphasis(rect, focus === "adjacency" ? node.getAdjacentDataIndices() : focus === "trajectory" ? node.getTrajectoryDataIndices() : focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    });
    nodeData.eachItemGraphicEl(function(el, dataIndex) {
      const itemModel = nodeData.getItemModel(dataIndex);
      if (itemModel.get("draggable")) {
        el.drift = function(dx, dy) {
          sankeyView._focusAdjacencyDisabled = true;
          this.shape.x += dx;
          this.shape.y += dy;
          this.dirty();
          api2.dispatchAction({
            type: "dragNode",
            seriesId: seriesModel.id,
            dataIndex: nodeData.getRawIndex(dataIndex),
            localX: this.shape.x / width,
            localY: this.shape.y / height
          });
        };
        el.ondragend = function() {
          sankeyView._focusAdjacencyDisabled = false;
        };
        el.draggable = true;
        el.cursor = "move";
      }
    });
    if (!this._data && seriesModel.isAnimationEnabled()) {
      mainGroup.setClipPath(createGridClipShape2(mainGroup.getBoundingRect(), seriesModel, function() {
        mainGroup.removeClipPath();
      }));
    }
    this._data = seriesModel.getData();
  }
  dispose() {
    this._controller && this._controller.dispose();
    this._controllerHost = null;
  }
  _updateViewCoordSys(seriesModel, api2) {
    const layoutInfo = seriesModel.layoutInfo;
    const width = layoutInfo.width;
    const height = layoutInfo.height;
    const viewCoordSys = seriesModel.coordinateSystem = new View_default(null, {api: api2, ecModel: seriesModel.ecModel});
    viewCoordSys.zoomLimit = seriesModel.get("scaleLimit");
    viewCoordSys.setBoundingRect(0, 0, width, height);
    viewCoordSys.setCenter(seriesModel.get("center"));
    viewCoordSys.setZoom(seriesModel.get("zoom"));
    this._controllerHost.target.attr({
      x: viewCoordSys.x,
      y: viewCoordSys.y,
      scaleX: viewCoordSys.scaleX,
      scaleY: viewCoordSys.scaleY
    });
  }
};
var SankeyView = SankeyView2;
SankeyView.type = "sankey";
function applyCurveStyle(curveProps, orient, edge) {
  switch (curveProps.fill) {
    case "source":
      curveProps.fill = edge.node1.getVisual("color");
      curveProps.decal = edge.node1.getVisual("style").decal;
      break;
    case "target":
      curveProps.fill = edge.node2.getVisual("color");
      curveProps.decal = edge.node2.getVisual("style").decal;
      break;
    case "gradient":
      const sourceColor = edge.node1.getVisual("color");
      const targetColor = edge.node2.getVisual("color");
      if (isString(sourceColor) && isString(targetColor)) {
        curveProps.fill = new LinearGradient_default(0, 0, +(orient === "horizontal"), +(orient === "vertical"), [{
          color: sourceColor,
          offset: 0
        }, {
          color: targetColor,
          offset: 1
        }]);
      }
  }
}
function createGridClipShape2(rect, seriesModel, cb) {
  const rectEl = new Rect_default({
    shape: {
      x: rect.x - 10,
      y: rect.y - 10,
      width: 0,
      height: rect.height + 20
    }
  });
  initProps(rectEl, {
    shape: {
      width: rect.width + 20
    }
  }, seriesModel, cb);
  return rectEl;
}
var SankeyView_default = SankeyView;

// src/chart/sankey/SankeySeries.ts
var SankeySeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = SankeySeriesModel2.type;
  }
  getInitialData(option, ecModel) {
    const links = option.edges || option.links || [];
    const nodes = option.data || option.nodes || [];
    const levels = option.levels || [];
    this.levelModels = [];
    const levelModels = this.levelModels;
    for (let i = 0; i < levels.length; i++) {
      if (levels[i].depth != null && levels[i].depth >= 0) {
        levelModels[levels[i].depth] = new Model_default(levels[i], this, ecModel);
      } else {
        if (true) {
          throw new Error("levels[i].depth is mandatory and should be natural number");
        }
      }
    }
    const graph = createGraphFromNodeEdge(nodes, links, this, true, beforeLink);
    return graph.data;
    function beforeLink(nodeData, edgeData) {
      nodeData.wrapMethod("getItemModel", function(model, idx) {
        const seriesModel = model.parentModel;
        const layout14 = seriesModel.getData().getItemLayout(idx);
        if (layout14) {
          const nodeDepth = layout14.depth;
          const levelModel = seriesModel.levelModels[nodeDepth];
          if (levelModel) {
            model.parentModel = levelModel;
          }
        }
        return model;
      });
      edgeData.wrapMethod("getItemModel", function(model, idx) {
        const seriesModel = model.parentModel;
        const edge = seriesModel.getGraph().getEdgeByIndex(idx);
        const layout14 = edge.node1.getLayout();
        if (layout14) {
          const depth = layout14.depth;
          const levelModel = seriesModel.levelModels[depth];
          if (levelModel) {
            model.parentModel = levelModel;
          }
        }
        return model;
      });
    }
  }
  setNodePosition(dataIndex, localPosition) {
    const nodes = this.option.data || this.option.nodes;
    const dataItem = nodes[dataIndex];
    dataItem.localX = localPosition[0];
    dataItem.localY = localPosition[1];
  }
  setCenter(center3) {
    this.option.center = center3;
  }
  setZoom(zoom) {
    this.option.zoom = zoom;
  }
  getGraph() {
    return this.getData().graph;
  }
  getEdgeData() {
    return this.getGraph().edgeData;
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    function noValue(val) {
      return isNaN(val) || val == null;
    }
    if (dataType === "edge") {
      const params = this.getDataParams(dataIndex, dataType);
      const rawDataOpt = params.data;
      const edgeValue = params.value;
      const edgeName = rawDataOpt.source + " -- " + rawDataOpt.target;
      return createTooltipMarkup("nameValue", {
        name: edgeName,
        value: edgeValue,
        noValue: noValue(edgeValue)
      });
    } else {
      const node = this.getGraph().getNodeByIndex(dataIndex);
      const value = node.getLayout().value;
      const name = this.getDataParams(dataIndex, dataType).data.name;
      return createTooltipMarkup("nameValue", {
        name: name != null ? name + "" : null,
        value,
        noValue: noValue(value)
      });
    }
  }
  optionUpdated() {
  }
  getDataParams(dataIndex, dataType) {
    const params = super.getDataParams(dataIndex, dataType);
    if (params.value == null && dataType === "node") {
      const node = this.getGraph().getNodeByIndex(dataIndex);
      const nodeValue = node.getLayout().value;
      params.value = nodeValue;
    }
    return params;
  }
};
var SankeySeriesModel = SankeySeriesModel2;
SankeySeriesModel.type = "series.sankey";
SankeySeriesModel.layoutMode = "box";
SankeySeriesModel.defaultOption = {
  z: 2,
  coordinateSystemUsage: "box",
  left: "5%",
  top: "5%",
  right: "20%",
  bottom: "5%",
  orient: "horizontal",
  nodeWidth: 20,
  nodeGap: 8,
  draggable: true,
  layoutIterations: 32,
  roam: false,
  roamTrigger: "global",
  center: null,
  zoom: 1,
  label: {
    show: true,
    position: "right",
    fontSize: 12
  },
  edgeLabel: {
    show: false,
    fontSize: 12
  },
  levels: [],
  nodeAlign: "justify",
  lineStyle: {
    color: tokens_default.color.neutral50,
    opacity: 0.2,
    curveness: 0.5
  },
  emphasis: {
    label: {
      show: true
    },
    lineStyle: {
      opacity: 0.5
    }
  },
  select: {
    itemStyle: {
      borderColor: tokens_default.color.primary
    }
  },
  animationEasing: "linear",
  animationDuration: 1e3
};
var SankeySeries_default = SankeySeriesModel;

// src/chart/sankey/sankeyLayout.ts
function sankeyLayout(ecModel, api2) {
  ecModel.eachSeriesByType("sankey", function(seriesModel) {
    const nodeWidth = seriesModel.get("nodeWidth");
    const nodeGap = seriesModel.get("nodeGap");
    const refContainer = createBoxLayoutReference(seriesModel, api2).refContainer;
    const layoutInfo = getLayoutRect(seriesModel.getBoxLayoutParams(), refContainer);
    seriesModel.layoutInfo = layoutInfo;
    const width = layoutInfo.width;
    const height = layoutInfo.height;
    const graph = seriesModel.getGraph();
    const nodes = graph.nodes;
    const edges = graph.edges;
    computeNodeValues(nodes);
    const filteredNodes = filter(nodes, function(node) {
      return node.getLayout().value === 0;
    });
    const iterations = filteredNodes.length !== 0 ? 0 : seriesModel.get("layoutIterations");
    const orient = seriesModel.get("orient");
    const nodeAlign = seriesModel.get("nodeAlign");
    layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign);
  });
}
function layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign) {
  computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign);
  computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient);
  computeEdgeDepths(nodes, orient);
}
function computeNodeValues(nodes) {
  each(nodes, function(node) {
    const value1 = sum(node.outEdges, getEdgeValue);
    const value2 = sum(node.inEdges, getEdgeValue);
    const nodeRawValue = node.getValue() || 0;
    const value = Math.max(value1, value2, nodeRawValue);
    node.setLayout({value}, true);
  });
}
function computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign) {
  const remainEdges = [];
  const indegreeArr = [];
  let zeroIndegrees = [];
  let nextTargetNode = [];
  let x = 0;
  for (let i = 0; i < edges.length; i++) {
    remainEdges[i] = 1;
  }
  for (let i = 0; i < nodes.length; i++) {
    indegreeArr[i] = nodes[i].inEdges.length;
    if (indegreeArr[i] === 0) {
      zeroIndegrees.push(nodes[i]);
    }
  }
  let maxNodeDepth = -1;
  while (zeroIndegrees.length) {
    for (let idx = 0; idx < zeroIndegrees.length; idx++) {
      const node = zeroIndegrees[idx];
      const item = node.hostGraph.data.getRawDataItem(node.dataIndex);
      const isItemDepth = item.depth != null && item.depth >= 0;
      if (isItemDepth && item.depth > maxNodeDepth) {
        maxNodeDepth = item.depth;
      }
      node.setLayout({depth: isItemDepth ? item.depth : x}, true);
      orient === "vertical" ? node.setLayout({dy: nodeWidth}, true) : node.setLayout({dx: nodeWidth}, true);
      for (let edgeIdx = 0; edgeIdx < node.outEdges.length; edgeIdx++) {
        const edge = node.outEdges[edgeIdx];
        const indexEdge = edges.indexOf(edge);
        remainEdges[indexEdge] = 0;
        const targetNode = edge.node2;
        const nodeIndex = nodes.indexOf(targetNode);
        if (--indegreeArr[nodeIndex] === 0 && nextTargetNode.indexOf(targetNode) < 0) {
          nextTargetNode.push(targetNode);
        }
      }
    }
    ++x;
    zeroIndegrees = nextTargetNode;
    nextTargetNode = [];
  }
  for (let i = 0; i < remainEdges.length; i++) {
    if (remainEdges[i] === 1) {
      throw new Error("Sankey is a DAG, the original data has cycle!");
    }
  }
  const maxDepth = maxNodeDepth > x - 1 ? maxNodeDepth : x - 1;
  if (nodeAlign && nodeAlign !== "left") {
    adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth);
  }
  const kx = orient === "vertical" ? (height - nodeWidth) / maxDepth : (width - nodeWidth) / maxDepth;
  scaleNodeBreadths(nodes, kx, orient);
}
function isNodeDepth(node) {
  const item = node.hostGraph.data.getRawDataItem(node.dataIndex);
  return item.depth != null && item.depth >= 0;
}
function adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth) {
  if (nodeAlign === "right") {
    let nextSourceNode = [];
    let remainNodes = nodes;
    let nodeHeight = 0;
    while (remainNodes.length) {
      for (let i = 0; i < remainNodes.length; i++) {
        const node = remainNodes[i];
        node.setLayout({skNodeHeight: nodeHeight}, true);
        for (let j = 0; j < node.inEdges.length; j++) {
          const edge = node.inEdges[j];
          if (nextSourceNode.indexOf(edge.node1) < 0) {
            nextSourceNode.push(edge.node1);
          }
        }
      }
      remainNodes = nextSourceNode;
      nextSourceNode = [];
      ++nodeHeight;
    }
    each(nodes, function(node) {
      if (!isNodeDepth(node)) {
        node.setLayout({depth: Math.max(0, maxDepth - node.getLayout().skNodeHeight)}, true);
      }
    });
  } else if (nodeAlign === "justify") {
    moveSinksRight(nodes, maxDepth);
  }
}
function moveSinksRight(nodes, maxDepth) {
  each(nodes, function(node) {
    if (!isNodeDepth(node) && !node.outEdges.length) {
      node.setLayout({depth: maxDepth}, true);
    }
  });
}
function scaleNodeBreadths(nodes, kx, orient) {
  each(nodes, function(node) {
    const nodeDepth = node.getLayout().depth * kx;
    orient === "vertical" ? node.setLayout({y: nodeDepth}, true) : node.setLayout({x: nodeDepth}, true);
  });
}
function computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient) {
  const nodesByBreadth = prepareNodesByBreadth(nodes, orient);
  initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient);
  resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
  for (let alpha = 1; iterations > 0; iterations--) {
    alpha *= 0.99;
    relaxRightToLeft(nodesByBreadth, alpha, orient);
    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
    relaxLeftToRight(nodesByBreadth, alpha, orient);
    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
  }
}
function prepareNodesByBreadth(nodes, orient) {
  const nodesByBreadth = [];
  const keyAttr = orient === "vertical" ? "y" : "x";
  const groupResult = groupData(nodes, function(node) {
    return node.getLayout()[keyAttr];
  });
  groupResult.keys.sort(function(a, b) {
    return a - b;
  });
  each(groupResult.keys, function(key) {
    nodesByBreadth.push(groupResult.buckets.get(key));
  });
  return nodesByBreadth;
}
function initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient) {
  let minKy = Infinity;
  each(nodesByBreadth, function(nodes) {
    const n = nodes.length;
    let sum2 = 0;
    each(nodes, function(node) {
      sum2 += node.getLayout().value;
    });
    const ky = orient === "vertical" ? (width - (n - 1) * nodeGap) / sum2 : (height - (n - 1) * nodeGap) / sum2;
    if (ky < minKy) {
      minKy = ky;
    }
  });
  each(nodesByBreadth, function(nodes) {
    each(nodes, function(node, i) {
      const nodeDy = node.getLayout().value * minKy;
      if (orient === "vertical") {
        node.setLayout({x: i}, true);
        node.setLayout({dx: nodeDy}, true);
      } else {
        node.setLayout({y: i}, true);
        node.setLayout({dy: nodeDy}, true);
      }
    });
  });
  each(edges, function(edge) {
    const edgeDy = +edge.getValue() * minKy;
    edge.setLayout({dy: edgeDy}, true);
  });
}
function resolveCollisions(nodesByBreadth, nodeGap, height, width, orient) {
  const keyAttr = orient === "vertical" ? "x" : "y";
  each(nodesByBreadth, function(nodes) {
    nodes.sort(function(a, b) {
      return a.getLayout()[keyAttr] - b.getLayout()[keyAttr];
    });
    let nodeX;
    let node;
    let dy;
    let y0 = 0;
    const n = nodes.length;
    const nodeDyAttr = orient === "vertical" ? "dx" : "dy";
    for (let i = 0; i < n; i++) {
      node = nodes[i];
      dy = y0 - node.getLayout()[keyAttr];
      if (dy > 0) {
        nodeX = node.getLayout()[keyAttr] + dy;
        orient === "vertical" ? node.setLayout({x: nodeX}, true) : node.setLayout({y: nodeX}, true);
      }
      y0 = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap;
    }
    const viewWidth = orient === "vertical" ? width : height;
    dy = y0 - nodeGap - viewWidth;
    if (dy > 0) {
      nodeX = node.getLayout()[keyAttr] - dy;
      orient === "vertical" ? node.setLayout({x: nodeX}, true) : node.setLayout({y: nodeX}, true);
      y0 = nodeX;
      for (let i = n - 2; i >= 0; --i) {
        node = nodes[i];
        dy = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap - y0;
        if (dy > 0) {
          nodeX = node.getLayout()[keyAttr] - dy;
          orient === "vertical" ? node.setLayout({x: nodeX}, true) : node.setLayout({y: nodeX}, true);
        }
        y0 = node.getLayout()[keyAttr];
      }
    }
  });
}
function relaxRightToLeft(nodesByBreadth, alpha, orient) {
  each(nodesByBreadth.slice().reverse(), function(nodes) {
    each(nodes, function(node) {
      if (node.outEdges.length) {
        let y = sum(node.outEdges, weightedTarget, orient) / sum(node.outEdges, getEdgeValue);
        if (isNaN(y)) {
          const len2 = node.outEdges.length;
          y = len2 ? sum(node.outEdges, centerTarget, orient) / len2 : 0;
        }
        if (orient === "vertical") {
          const nodeX = node.getLayout().x + (y - center2(node, orient)) * alpha;
          node.setLayout({x: nodeX}, true);
        } else {
          const nodeY = node.getLayout().y + (y - center2(node, orient)) * alpha;
          node.setLayout({y: nodeY}, true);
        }
      }
    });
  });
}
function weightedTarget(edge, orient) {
  return center2(edge.node2, orient) * edge.getValue();
}
function centerTarget(edge, orient) {
  return center2(edge.node2, orient);
}
function weightedSource(edge, orient) {
  return center2(edge.node1, orient) * edge.getValue();
}
function centerSource(edge, orient) {
  return center2(edge.node1, orient);
}
function center2(node, orient) {
  return orient === "vertical" ? node.getLayout().x + node.getLayout().dx / 2 : node.getLayout().y + node.getLayout().dy / 2;
}
function getEdgeValue(edge) {
  return edge.getValue();
}
function sum(array, cb, orient) {
  let sum2 = 0;
  const len2 = array.length;
  let i = -1;
  while (++i < len2) {
    const value = +cb(array[i], orient);
    if (!isNaN(value)) {
      sum2 += value;
    }
  }
  return sum2;
}
function relaxLeftToRight(nodesByBreadth, alpha, orient) {
  each(nodesByBreadth, function(nodes) {
    each(nodes, function(node) {
      if (node.inEdges.length) {
        let y = sum(node.inEdges, weightedSource, orient) / sum(node.inEdges, getEdgeValue);
        if (isNaN(y)) {
          const len2 = node.inEdges.length;
          y = len2 ? sum(node.inEdges, centerSource, orient) / len2 : 0;
        }
        if (orient === "vertical") {
          const nodeX = node.getLayout().x + (y - center2(node, orient)) * alpha;
          node.setLayout({x: nodeX}, true);
        } else {
          const nodeY = node.getLayout().y + (y - center2(node, orient)) * alpha;
          node.setLayout({y: nodeY}, true);
        }
      }
    });
  });
}
function computeEdgeDepths(nodes, orient) {
  const keyAttr = orient === "vertical" ? "x" : "y";
  each(nodes, function(node) {
    node.outEdges.sort(function(a, b) {
      return a.node2.getLayout()[keyAttr] - b.node2.getLayout()[keyAttr];
    });
    node.inEdges.sort(function(a, b) {
      return a.node1.getLayout()[keyAttr] - b.node1.getLayout()[keyAttr];
    });
  });
  each(nodes, function(node) {
    let sy = 0;
    let ty = 0;
    each(node.outEdges, function(edge) {
      edge.setLayout({sy}, true);
      sy += edge.getLayout().dy;
    });
    each(node.inEdges, function(edge) {
      edge.setLayout({ty}, true);
      ty += edge.getLayout().dy;
    });
  });
}

// src/chart/sankey/sankeyVisual.ts
function sankeyVisual(ecModel) {
  ecModel.eachSeriesByType("sankey", function(seriesModel) {
    const graph = seriesModel.getGraph();
    const nodes = graph.nodes;
    const edges = graph.edges;
    if (nodes.length) {
      let minValue = Infinity;
      let maxValue = -Infinity;
      each(nodes, function(node) {
        const nodeValue = node.getLayout().value;
        if (nodeValue < minValue) {
          minValue = nodeValue;
        }
        if (nodeValue > maxValue) {
          maxValue = nodeValue;
        }
      });
      each(nodes, function(node) {
        const mapping = new VisualMapping_default({
          type: "color",
          mappingMethod: "linear",
          dataExtent: [minValue, maxValue],
          visual: seriesModel.get("color")
        });
        const mapValueToColor = mapping.mapValueToVisual(node.getLayout().value);
        const customColor = node.getModel().get(["itemStyle", "color"]);
        if (customColor != null) {
          node.setVisual("color", customColor);
          node.setVisual("style", {fill: customColor});
        } else {
          node.setVisual("color", mapValueToColor);
          node.setVisual("style", {fill: mapValueToColor});
        }
      });
    }
    if (edges.length) {
      each(edges, function(edge) {
        const edgeStyle = edge.getModel().get("lineStyle");
        edge.setVisual("style", edgeStyle);
      });
    }
  });
}

// src/chart/sankey/install.ts
function install20(registers) {
  registers.registerChartView(SankeyView_default);
  registers.registerSeriesModel(SankeySeries_default);
  registers.registerLayout(sankeyLayout);
  registers.registerVisual(sankeyVisual);
  registers.registerAction({
    type: "dragNode",
    event: "dragnode",
    update: "update"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: payload
    }, function(seriesModel) {
      seriesModel.setNodePosition(payload.dataIndex, [payload.localX, payload.localY]);
    });
  });
  registers.registerAction({
    type: "sankeyRoam",
    event: "sankeyRoam",
    update: "none"
  }, function(payload, ecModel, api2) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: payload
    }, function(seriesModel) {
      const coordSys = seriesModel.coordinateSystem;
      const res = updateCenterAndZoomInAction(coordSys, payload, seriesModel.get("scaleLimit"));
      seriesModel.setCenter(res.center);
      seriesModel.setZoom(res.zoom);
    });
  });
}

// src/chart/helper/whiskerBoxCommon.ts
var WhiskerBoxCommonMixin = class {
  _hasEncodeRule(key) {
    const encodeRules = this.getEncode();
    return encodeRules && encodeRules.get(key) != null;
  }
  getInitialData(option, ecModel) {
    let ordinalMeta;
    const xAxisModel = ecModel.getComponent("xAxis", this.get("xAxisIndex"));
    const yAxisModel = ecModel.getComponent("yAxis", this.get("yAxisIndex"));
    const xAxisType = xAxisModel.get("type");
    const yAxisType = yAxisModel.get("type");
    let addOrdinal;
    if (xAxisType === "category") {
      option.layout = "horizontal";
      ordinalMeta = xAxisModel.getOrdinalMeta();
      addOrdinal = !this._hasEncodeRule("x");
    } else if (yAxisType === "category") {
      option.layout = "vertical";
      ordinalMeta = yAxisModel.getOrdinalMeta();
      addOrdinal = !this._hasEncodeRule("y");
    } else {
      option.layout = option.layout || "horizontal";
    }
    const coordDims = ["x", "y"];
    const baseAxisDimIndex = option.layout === "horizontal" ? 0 : 1;
    const baseAxisDim = this._baseAxisDim = coordDims[baseAxisDimIndex];
    const otherAxisDim = coordDims[1 - baseAxisDimIndex];
    const axisModels = [xAxisModel, yAxisModel];
    const baseAxisType = axisModels[baseAxisDimIndex].get("type");
    const otherAxisType = axisModels[1 - baseAxisDimIndex].get("type");
    const data = option.data;
    if (data && addOrdinal) {
      const newOptionData = [];
      each(data, function(item, index) {
        let newItem;
        if (isArray(item)) {
          newItem = item.slice();
          item.unshift(index);
        } else if (isArray(item.value)) {
          newItem = extend({}, item);
          newItem.value = newItem.value.slice();
          item.value.unshift(index);
        } else {
          newItem = item;
        }
        newOptionData.push(newItem);
      });
      option.data = newOptionData;
    }
    const defaultValueDimensions = this.defaultValueDimensions;
    const coordDimensions = [{
      name: baseAxisDim,
      type: getDimensionTypeByAxis(baseAxisType),
      ordinalMeta,
      otherDims: {
        tooltip: false,
        itemName: 0
      },
      dimsDef: ["base"]
    }, {
      name: otherAxisDim,
      type: getDimensionTypeByAxis(otherAxisType),
      dimsDef: defaultValueDimensions.slice()
    }];
    return createSeriesDataSimply(this, {
      coordDimensions,
      dimensionsCount: defaultValueDimensions.length + 1,
      encodeDefaulter: curry(makeSeriesEncodeForAxisCoordSys, coordDimensions, this)
    });
  }
  getBaseAxis() {
    const dim = this._baseAxisDim;
    return this.ecModel.getComponent(dim + "Axis", this.get(dim + "AxisIndex")).axis;
  }
};

// src/chart/boxplot/BoxplotSeries.ts
var BoxplotSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = BoxplotSeriesModel2.type;
    this.defaultValueDimensions = [
      {name: "min", defaultTooltip: true},
      {name: "Q1", defaultTooltip: true},
      {name: "median", defaultTooltip: true},
      {name: "Q3", defaultTooltip: true},
      {name: "max", defaultTooltip: true}
    ];
    this.visualDrawType = "stroke";
  }
};
var BoxplotSeriesModel = BoxplotSeriesModel2;
BoxplotSeriesModel.type = "series.boxplot";
BoxplotSeriesModel.dependencies = ["xAxis", "yAxis", "grid"];
BoxplotSeriesModel.defaultOption = {
  z: 2,
  coordinateSystem: "cartesian2d",
  legendHoverLink: true,
  layout: null,
  boxWidth: [7, 50],
  itemStyle: {
    color: tokens_default.color.neutral00,
    borderWidth: 1
  },
  emphasis: {
    scale: true,
    itemStyle: {
      borderWidth: 2,
      shadowBlur: 5,
      shadowOffsetX: 1,
      shadowOffsetY: 1,
      shadowColor: tokens_default.color.shadow
    }
  },
  animationDuration: 800
};
mixin(BoxplotSeriesModel, WhiskerBoxCommonMixin, true);
var BoxplotSeries_default = BoxplotSeriesModel;

// src/chart/boxplot/BoxplotView.ts
var BoxplotView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = BoxplotView2.type;
  }
  render(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    const group = this.group;
    const oldData = this._data;
    if (!this._data) {
      group.removeAll();
    }
    const constDim = seriesModel.get("layout") === "horizontal" ? 1 : 0;
    data.diff(oldData).add(function(newIdx) {
      if (data.hasValue(newIdx)) {
        const itemLayout = data.getItemLayout(newIdx);
        const symbolEl = createNormalBox(itemLayout, data, newIdx, constDim, true);
        data.setItemGraphicEl(newIdx, symbolEl);
        group.add(symbolEl);
      }
    }).update(function(newIdx, oldIdx) {
      let symbolEl = oldData.getItemGraphicEl(oldIdx);
      if (!data.hasValue(newIdx)) {
        group.remove(symbolEl);
        return;
      }
      const itemLayout = data.getItemLayout(newIdx);
      if (!symbolEl) {
        symbolEl = createNormalBox(itemLayout, data, newIdx, constDim);
      } else {
        saveOldStyle(symbolEl);
        updateNormalBoxData(itemLayout, symbolEl, data, newIdx);
      }
      group.add(symbolEl);
      data.setItemGraphicEl(newIdx, symbolEl);
    }).remove(function(oldIdx) {
      const el = oldData.getItemGraphicEl(oldIdx);
      el && group.remove(el);
    }).execute();
    this._data = data;
  }
  remove(ecModel) {
    const group = this.group;
    const data = this._data;
    this._data = null;
    data && data.eachItemGraphicEl(function(el) {
      el && group.remove(el);
    });
  }
};
var BoxplotView = BoxplotView2;
BoxplotView.type = "boxplot";
var BoxPathShape = class {
};
var BoxPath = class extends Path_default {
  constructor(opts) {
    super(opts);
    this.type = "boxplotBoxPath";
  }
  getDefaultShape() {
    return new BoxPathShape();
  }
  buildPath(ctx, shape) {
    const ends = shape.points;
    let i = 0;
    ctx.moveTo(ends[i][0], ends[i][1]);
    i++;
    for (; i < 4; i++) {
      ctx.lineTo(ends[i][0], ends[i][1]);
    }
    ctx.closePath();
    for (; i < ends.length; i++) {
      ctx.moveTo(ends[i][0], ends[i][1]);
      i++;
      ctx.lineTo(ends[i][0], ends[i][1]);
    }
  }
};
function createNormalBox(itemLayout, data, dataIndex, constDim, isInit) {
  const ends = itemLayout.ends;
  const el = new BoxPath({
    shape: {
      points: isInit ? transInit(ends, constDim, itemLayout) : ends
    }
  });
  updateNormalBoxData(itemLayout, el, data, dataIndex, isInit);
  return el;
}
function updateNormalBoxData(itemLayout, el, data, dataIndex, isInit) {
  const seriesModel = data.hostModel;
  const updateMethod = graphic_exports[isInit ? "initProps" : "updateProps"];
  updateMethod(el, {shape: {points: itemLayout.ends}}, seriesModel, dataIndex);
  el.useStyle(data.getItemVisual(dataIndex, "style"));
  el.style.strokeNoScale = true;
  el.z2 = 100;
  const itemModel = data.getItemModel(dataIndex);
  const emphasisModel = itemModel.getModel("emphasis");
  setStatesStylesFromModel(el, itemModel);
  toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
}
function transInit(points4, dim, itemLayout) {
  return map(points4, function(point) {
    point = point.slice();
    point[dim] = itemLayout.initBaseline;
    return point;
  });
}
var BoxplotView_default = BoxplotView;

// src/chart/boxplot/boxplotLayout.ts
var each7 = each;
function boxplotLayout(ecModel) {
  const groupResult = groupSeriesByAxis(ecModel);
  each7(groupResult, function(groupItem) {
    const seriesModels = groupItem.seriesModels;
    if (!seriesModels.length) {
      return;
    }
    calculateBase(groupItem);
    each7(seriesModels, function(seriesModel, idx) {
      layoutSingleSeries(seriesModel, groupItem.boxOffsetList[idx], groupItem.boxWidthList[idx]);
    });
  });
}
function groupSeriesByAxis(ecModel) {
  const result = [];
  const axisList = [];
  ecModel.eachSeriesByType("boxplot", function(seriesModel) {
    const baseAxis = seriesModel.getBaseAxis();
    let idx = indexOf(axisList, baseAxis);
    if (idx < 0) {
      idx = axisList.length;
      axisList[idx] = baseAxis;
      result[idx] = {
        axis: baseAxis,
        seriesModels: []
      };
    }
    result[idx].seriesModels.push(seriesModel);
  });
  return result;
}
function calculateBase(groupItem) {
  const baseAxis = groupItem.axis;
  const seriesModels = groupItem.seriesModels;
  const seriesCount = seriesModels.length;
  const boxWidthList = groupItem.boxWidthList = [];
  const boxOffsetList = groupItem.boxOffsetList = [];
  const boundList = [];
  let bandWidth;
  if (baseAxis.type === "category") {
    bandWidth = baseAxis.getBandWidth();
  } else {
    let maxDataCount = 0;
    each7(seriesModels, function(seriesModel) {
      maxDataCount = Math.max(maxDataCount, seriesModel.getData().count());
    });
    const extent = baseAxis.getExtent();
    bandWidth = Math.abs(extent[1] - extent[0]) / maxDataCount;
  }
  each7(seriesModels, function(seriesModel) {
    let boxWidthBound = seriesModel.get("boxWidth");
    if (!isArray(boxWidthBound)) {
      boxWidthBound = [boxWidthBound, boxWidthBound];
    }
    boundList.push([
      parsePercent2(boxWidthBound[0], bandWidth) || 0,
      parsePercent2(boxWidthBound[1], bandWidth) || 0
    ]);
  });
  const availableWidth = bandWidth * 0.8 - 2;
  const boxGap = availableWidth / seriesCount * 0.3;
  const boxWidth = (availableWidth - boxGap * (seriesCount - 1)) / seriesCount;
  let base2 = boxWidth / 2 - availableWidth / 2;
  each7(seriesModels, function(seriesModel, idx) {
    boxOffsetList.push(base2);
    base2 += boxGap + boxWidth;
    boxWidthList.push(Math.min(Math.max(boxWidth, boundList[idx][0]), boundList[idx][1]));
  });
}
function layoutSingleSeries(seriesModel, offset, boxWidth) {
  const coordSys = seriesModel.coordinateSystem;
  const data = seriesModel.getData();
  const halfWidth = boxWidth / 2;
  const cDimIdx = seriesModel.get("layout") === "horizontal" ? 0 : 1;
  const vDimIdx = 1 - cDimIdx;
  const coordDims = ["x", "y"];
  const cDim = data.mapDimension(coordDims[cDimIdx]);
  const vDims = data.mapDimensionsAll(coordDims[vDimIdx]);
  if (cDim == null || vDims.length < 5) {
    return;
  }
  for (let dataIndex = 0; dataIndex < data.count(); dataIndex++) {
    const axisDimVal = data.get(cDim, dataIndex);
    const median = getPoint(axisDimVal, vDims[2], dataIndex);
    const end1 = getPoint(axisDimVal, vDims[0], dataIndex);
    const end2 = getPoint(axisDimVal, vDims[1], dataIndex);
    const end4 = getPoint(axisDimVal, vDims[3], dataIndex);
    const end5 = getPoint(axisDimVal, vDims[4], dataIndex);
    const ends = [];
    addBodyEnd(ends, end2, false);
    addBodyEnd(ends, end4, true);
    ends.push(end1, end2, end5, end4);
    layEndLine(ends, end1);
    layEndLine(ends, end5);
    layEndLine(ends, median);
    data.setItemLayout(dataIndex, {
      initBaseline: median[vDimIdx],
      ends
    });
  }
  function getPoint(axisDimVal, dim, dataIndex) {
    const val = data.get(dim, dataIndex);
    const p = [];
    p[cDimIdx] = axisDimVal;
    p[vDimIdx] = val;
    let point;
    if (isNaN(axisDimVal) || isNaN(val)) {
      point = [NaN, NaN];
    } else {
      point = coordSys.dataToPoint(p);
      point[cDimIdx] += offset;
    }
    return point;
  }
  function addBodyEnd(ends, point, start2) {
    const point1 = point.slice();
    const point2 = point.slice();
    point1[cDimIdx] += halfWidth;
    point2[cDimIdx] -= halfWidth;
    start2 ? ends.push(point1, point2) : ends.push(point2, point1);
  }
  function layEndLine(ends, endCenter) {
    const from = endCenter.slice();
    const to = endCenter.slice();
    from[cDimIdx] -= halfWidth;
    to[cDimIdx] += halfWidth;
    ends.push(from, to);
  }
}

// src/chart/boxplot/prepareBoxplotData.ts
function prepareBoxplotData(rawData, opt) {
  opt = opt || {};
  const boxData = [];
  const outliers = [];
  const boundIQR = opt.boundIQR;
  const useExtreme = boundIQR === "none" || boundIQR === 0;
  for (let i = 0; i < rawData.length; i++) {
    const ascList = asc(rawData[i].slice());
    const Q1 = quantile(ascList, 0.25);
    const Q2 = quantile(ascList, 0.5);
    const Q3 = quantile(ascList, 0.75);
    const min3 = ascList[0];
    const max3 = ascList[ascList.length - 1];
    const bound = (boundIQR == null ? 1.5 : boundIQR) * (Q3 - Q1);
    const low = useExtreme ? min3 : Math.max(min3, Q1 - bound);
    const high = useExtreme ? max3 : Math.min(max3, Q3 + bound);
    const itemNameFormatter = opt.itemNameFormatter;
    const itemName = isFunction(itemNameFormatter) ? itemNameFormatter({value: i}) : isString(itemNameFormatter) ? itemNameFormatter.replace("{value}", i + "") : i + "";
    boxData.push([itemName, low, Q1, Q2, Q3, high]);
    for (let j = 0; j < ascList.length; j++) {
      const dataItem = ascList[j];
      if (dataItem < low || dataItem > high) {
        const outlier = [itemName, dataItem];
        outliers.push(outlier);
      }
    }
  }
  return {
    boxData,
    outliers
  };
}

// src/chart/boxplot/boxplotTransform.ts
var boxplotTransform = {
  type: "echarts:boxplot",
  transform: function transform(params) {
    const upstream = params.upstream;
    if (upstream.sourceFormat !== SOURCE_FORMAT_ARRAY_ROWS) {
      let errMsg = "";
      if (true) {
        errMsg = makePrintable("source data is not applicable for this boxplot transform. Expect number[][].");
      }
      throwError(errMsg);
    }
    const result = prepareBoxplotData(upstream.getRawData(), params.config);
    return [{
      dimensions: ["ItemName", "Low", "Q1", "Q2", "Q3", "High"],
      data: result.boxData
    }, {
      data: result.outliers
    }];
  }
};

// src/chart/boxplot/install.ts
function install21(registers) {
  registers.registerSeriesModel(BoxplotSeries_default);
  registers.registerChartView(BoxplotView_default);
  registers.registerLayout(boxplotLayout);
  registers.registerTransform(boxplotTransform);
}

// src/chart/candlestick/candlestickVisual.ts
var positiveBorderColorQuery = ["itemStyle", "borderColor"];
var negativeBorderColorQuery = ["itemStyle", "borderColor0"];
var dojiBorderColorQuery = ["itemStyle", "borderColorDoji"];
var positiveColorQuery = ["itemStyle", "color"];
var negativeColorQuery = ["itemStyle", "color0"];
function getColor(sign, model) {
  return model.get(sign > 0 ? positiveColorQuery : negativeColorQuery);
}
function getBorderColor(sign, model) {
  return model.get(sign === 0 ? dojiBorderColorQuery : sign > 0 ? positiveBorderColorQuery : negativeBorderColorQuery);
}
var candlestickVisual = {
  seriesType: "candlestick",
  plan: createRenderPlanner(),
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    const isLargeRender = seriesModel.pipelineContext.large;
    return !isLargeRender && {
      progress(params, data) {
        let dataIndex;
        while ((dataIndex = params.next()) != null) {
          const itemModel = data.getItemModel(dataIndex);
          const sign = data.getItemLayout(dataIndex).sign;
          const style = itemModel.getItemStyle();
          style.fill = getColor(sign, itemModel);
          style.stroke = getBorderColor(sign, itemModel) || style.fill;
          const existsStyle = data.ensureUniqueItemVisual(dataIndex, "style");
          extend(existsStyle, style);
        }
      }
    };
  }
};
var candlestickVisual_default = candlestickVisual;

// src/chart/candlestick/CandlestickView.ts
var SKIP_PROPS = ["color", "borderColor"];
var CandlestickView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = CandlestickView2.type;
  }
  render(seriesModel, ecModel, api2) {
    this.group.removeClipPath();
    this._progressiveEls = null;
    this._updateDrawMode(seriesModel);
    this._isLargeDraw ? this._renderLarge(seriesModel) : this._renderNormal(seriesModel);
  }
  incrementalPrepareRender(seriesModel, ecModel, api2) {
    this._clear();
    this._updateDrawMode(seriesModel);
  }
  incrementalRender(params, seriesModel, ecModel, api2) {
    this._progressiveEls = [];
    this._isLargeDraw ? this._incrementalRenderLarge(params, seriesModel) : this._incrementalRenderNormal(params, seriesModel);
  }
  eachRendered(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  }
  _updateDrawMode(seriesModel) {
    const isLargeDraw = seriesModel.pipelineContext.large;
    if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {
      this._isLargeDraw = isLargeDraw;
      this._clear();
    }
  }
  _renderNormal(seriesModel) {
    const data = seriesModel.getData();
    const oldData = this._data;
    const group = this.group;
    const isSimpleBox = data.getLayout("isSimpleBox");
    const needsClip = seriesModel.get("clip", true);
    const coord = seriesModel.coordinateSystem;
    const clipArea = coord.getArea && coord.getArea();
    if (!this._data) {
      group.removeAll();
    }
    data.diff(oldData).add(function(newIdx) {
      if (data.hasValue(newIdx)) {
        const itemLayout = data.getItemLayout(newIdx);
        if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
          return;
        }
        const el = createNormalBox2(itemLayout, newIdx, true);
        initProps(el, {shape: {points: itemLayout.ends}}, seriesModel, newIdx);
        setBoxCommon(el, data, newIdx, isSimpleBox);
        group.add(el);
        data.setItemGraphicEl(newIdx, el);
      }
    }).update(function(newIdx, oldIdx) {
      let el = oldData.getItemGraphicEl(oldIdx);
      if (!data.hasValue(newIdx)) {
        group.remove(el);
        return;
      }
      const itemLayout = data.getItemLayout(newIdx);
      if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
        group.remove(el);
        return;
      }
      if (!el) {
        el = createNormalBox2(itemLayout, newIdx);
      } else {
        updateProps(el, {
          shape: {
            points: itemLayout.ends
          }
        }, seriesModel, newIdx);
        saveOldStyle(el);
      }
      setBoxCommon(el, data, newIdx, isSimpleBox);
      group.add(el);
      data.setItemGraphicEl(newIdx, el);
    }).remove(function(oldIdx) {
      const el = oldData.getItemGraphicEl(oldIdx);
      el && group.remove(el);
    }).execute();
    this._data = data;
  }
  _renderLarge(seriesModel) {
    this._clear();
    createLarge2(seriesModel, this.group);
    const clipPath = seriesModel.get("clip", true) ? createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null;
    if (clipPath) {
      this.group.setClipPath(clipPath);
    } else {
      this.group.removeClipPath();
    }
  }
  _incrementalRenderNormal(params, seriesModel) {
    const data = seriesModel.getData();
    const isSimpleBox = data.getLayout("isSimpleBox");
    let dataIndex;
    while ((dataIndex = params.next()) != null) {
      const itemLayout = data.getItemLayout(dataIndex);
      const el = createNormalBox2(itemLayout, dataIndex);
      setBoxCommon(el, data, dataIndex, isSimpleBox);
      el.incremental = true;
      this.group.add(el);
      this._progressiveEls.push(el);
    }
  }
  _incrementalRenderLarge(params, seriesModel) {
    createLarge2(seriesModel, this.group, this._progressiveEls, true);
  }
  remove(ecModel) {
    this._clear();
  }
  _clear() {
    this.group.removeAll();
    this._data = null;
  }
};
var CandlestickView = CandlestickView2;
CandlestickView.type = "candlestick";
var NormalBoxPathShape = class {
};
var NormalBoxPath = class extends Path_default {
  constructor(opts) {
    super(opts);
    this.type = "normalCandlestickBox";
  }
  getDefaultShape() {
    return new NormalBoxPathShape();
  }
  buildPath(ctx, shape) {
    const ends = shape.points;
    if (this.__simpleBox) {
      ctx.moveTo(ends[4][0], ends[4][1]);
      ctx.lineTo(ends[6][0], ends[6][1]);
    } else {
      ctx.moveTo(ends[0][0], ends[0][1]);
      ctx.lineTo(ends[1][0], ends[1][1]);
      ctx.lineTo(ends[2][0], ends[2][1]);
      ctx.lineTo(ends[3][0], ends[3][1]);
      ctx.closePath();
      ctx.moveTo(ends[4][0], ends[4][1]);
      ctx.lineTo(ends[5][0], ends[5][1]);
      ctx.moveTo(ends[6][0], ends[6][1]);
      ctx.lineTo(ends[7][0], ends[7][1]);
    }
  }
};
function createNormalBox2(itemLayout, dataIndex, isInit) {
  const ends = itemLayout.ends;
  return new NormalBoxPath({
    shape: {
      points: isInit ? transInit2(ends, itemLayout) : ends
    },
    z2: 100
  });
}
function isNormalBoxClipped(clipArea, itemLayout) {
  let clipped = true;
  for (let i = 0; i < itemLayout.ends.length; i++) {
    if (clipArea.contain(itemLayout.ends[i][0], itemLayout.ends[i][1])) {
      clipped = false;
      break;
    }
  }
  return clipped;
}
function setBoxCommon(el, data, dataIndex, isSimpleBox) {
  const itemModel = data.getItemModel(dataIndex);
  el.useStyle(data.getItemVisual(dataIndex, "style"));
  el.style.strokeNoScale = true;
  el.__simpleBox = isSimpleBox;
  setStatesStylesFromModel(el, itemModel);
  const sign = data.getItemLayout(dataIndex).sign;
  each(el.states, (state, stateName) => {
    const stateModel = itemModel.getModel(stateName);
    const color4 = getColor(sign, stateModel);
    const borderColor = getBorderColor(sign, stateModel) || color4;
    const stateStyle = state.style || (state.style = {});
    color4 && (stateStyle.fill = color4);
    borderColor && (stateStyle.stroke = borderColor);
  });
  const emphasisModel = itemModel.getModel("emphasis");
  toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
}
function transInit2(points4, itemLayout) {
  return map(points4, function(point) {
    point = point.slice();
    point[1] = itemLayout.initBaseline;
    return point;
  });
}
var LargeBoxPathShape = class {
};
var LargeBoxPath = class extends Path_default {
  constructor(opts) {
    super(opts);
    this.type = "largeCandlestickBox";
  }
  getDefaultShape() {
    return new LargeBoxPathShape();
  }
  buildPath(ctx, shape) {
    const points4 = shape.points;
    for (let i = 0; i < points4.length; ) {
      if (this.__sign === points4[i++]) {
        const x = points4[i++];
        ctx.moveTo(x, points4[i++]);
        ctx.lineTo(x, points4[i++]);
      } else {
        i += 3;
      }
    }
  }
};
function createLarge2(seriesModel, group, progressiveEls, incremental) {
  const data = seriesModel.getData();
  const largePoints = data.getLayout("largePoints");
  const elP = new LargeBoxPath({
    shape: {points: largePoints},
    __sign: 1,
    ignoreCoarsePointer: true
  });
  group.add(elP);
  const elN = new LargeBoxPath({
    shape: {points: largePoints},
    __sign: -1,
    ignoreCoarsePointer: true
  });
  group.add(elN);
  const elDoji = new LargeBoxPath({
    shape: {points: largePoints},
    __sign: 0,
    ignoreCoarsePointer: true
  });
  group.add(elDoji);
  setLargeStyle(1, elP, seriesModel, data);
  setLargeStyle(-1, elN, seriesModel, data);
  setLargeStyle(0, elDoji, seriesModel, data);
  if (incremental) {
    elP.incremental = true;
    elN.incremental = true;
  }
  if (progressiveEls) {
    progressiveEls.push(elP, elN);
  }
}
function setLargeStyle(sign, el, seriesModel, data) {
  const borderColor = getBorderColor(sign, seriesModel) || getColor(sign, seriesModel);
  const itemStyle = seriesModel.getModel("itemStyle").getItemStyle(SKIP_PROPS);
  el.useStyle(itemStyle);
  el.style.fill = null;
  el.style.stroke = borderColor;
}
var CandlestickView_default = CandlestickView;

// src/chart/candlestick/CandlestickSeries.ts
var CandlestickSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = CandlestickSeriesModel2.type;
    this.defaultValueDimensions = [
      {name: "open", defaultTooltip: true},
      {name: "close", defaultTooltip: true},
      {name: "lowest", defaultTooltip: true},
      {name: "highest", defaultTooltip: true}
    ];
  }
  getShadowDim() {
    return "open";
  }
  brushSelector(dataIndex, data, selectors) {
    const itemLayout = data.getItemLayout(dataIndex);
    return itemLayout && selectors.rect(itemLayout.brushRect);
  }
};
var CandlestickSeriesModel = CandlestickSeriesModel2;
CandlestickSeriesModel.type = "series.candlestick";
CandlestickSeriesModel.dependencies = ["xAxis", "yAxis", "grid"];
CandlestickSeriesModel.defaultOption = {
  z: 2,
  coordinateSystem: "cartesian2d",
  legendHoverLink: true,
  layout: null,
  clip: true,
  itemStyle: {
    color: "#eb5454",
    color0: "#47b262",
    borderColor: "#eb5454",
    borderColor0: "#47b262",
    borderColorDoji: null,
    borderWidth: 1
  },
  emphasis: {
    itemStyle: {
      borderWidth: 2
    }
  },
  barMaxWidth: null,
  barMinWidth: null,
  barWidth: null,
  large: true,
  largeThreshold: 600,
  progressive: 3e3,
  progressiveThreshold: 1e4,
  progressiveChunkMode: "mod",
  animationEasing: "linear",
  animationDuration: 300
};
mixin(CandlestickSeriesModel, WhiskerBoxCommonMixin, true);
var CandlestickSeries_default = CandlestickSeriesModel;

// src/chart/candlestick/preprocessor.ts
function candlestickPreprocessor(option) {
  if (!option || !isArray(option.series)) {
    return;
  }
  each(option.series, function(seriesItem) {
    if (isObject(seriesItem) && seriesItem.type === "k") {
      seriesItem.type = "candlestick";
    }
  });
}

// src/chart/candlestick/candlestickLayout.ts
var candlestickLayout = {
  seriesType: "candlestick",
  plan: createRenderPlanner(),
  reset: function(seriesModel) {
    const coordSys = seriesModel.coordinateSystem;
    const data = seriesModel.getData();
    const candleWidth = calculateCandleWidth(seriesModel, data);
    const cDimIdx = 0;
    const vDimIdx = 1;
    const coordDims = ["x", "y"];
    const cDimI = data.getDimensionIndex(data.mapDimension(coordDims[cDimIdx]));
    const vDimsI = map(data.mapDimensionsAll(coordDims[vDimIdx]), data.getDimensionIndex, data);
    const openDimI = vDimsI[0];
    const closeDimI = vDimsI[1];
    const lowestDimI = vDimsI[2];
    const highestDimI = vDimsI[3];
    data.setLayout({
      candleWidth,
      isSimpleBox: candleWidth <= 1.3
    });
    if (cDimI < 0 || vDimsI.length < 4) {
      return;
    }
    return {
      progress: seriesModel.pipelineContext.large ? largeProgress : normalProgress
    };
    function normalProgress(params, data2) {
      let dataIndex;
      const store = data2.getStore();
      while ((dataIndex = params.next()) != null) {
        const axisDimVal = store.get(cDimI, dataIndex);
        const openVal = store.get(openDimI, dataIndex);
        const closeVal = store.get(closeDimI, dataIndex);
        const lowestVal = store.get(lowestDimI, dataIndex);
        const highestVal = store.get(highestDimI, dataIndex);
        const ocLow = Math.min(openVal, closeVal);
        const ocHigh = Math.max(openVal, closeVal);
        const ocLowPoint = getPoint(ocLow, axisDimVal);
        const ocHighPoint = getPoint(ocHigh, axisDimVal);
        const lowestPoint = getPoint(lowestVal, axisDimVal);
        const highestPoint = getPoint(highestVal, axisDimVal);
        const ends = [];
        addBodyEnd(ends, ocHighPoint, 0);
        addBodyEnd(ends, ocLowPoint, 1);
        ends.push(subPixelOptimizePoint(highestPoint), subPixelOptimizePoint(ocHighPoint), subPixelOptimizePoint(lowestPoint), subPixelOptimizePoint(ocLowPoint));
        const itemModel = data2.getItemModel(dataIndex);
        const hasDojiColor = !!itemModel.get(["itemStyle", "borderColorDoji"]);
        data2.setItemLayout(dataIndex, {
          sign: getSign(store, dataIndex, openVal, closeVal, closeDimI, hasDojiColor),
          initBaseline: openVal > closeVal ? ocHighPoint[vDimIdx] : ocLowPoint[vDimIdx],
          ends,
          brushRect: makeBrushRect(lowestVal, highestVal, axisDimVal)
        });
      }
      function getPoint(val, axisDimVal) {
        const p = [];
        p[cDimIdx] = axisDimVal;
        p[vDimIdx] = val;
        return isNaN(axisDimVal) || isNaN(val) ? [NaN, NaN] : coordSys.dataToPoint(p);
      }
      function addBodyEnd(ends, point, start2) {
        const point1 = point.slice();
        const point2 = point.slice();
        point1[cDimIdx] = subPixelOptimize2(point1[cDimIdx] + candleWidth / 2, 1, false);
        point2[cDimIdx] = subPixelOptimize2(point2[cDimIdx] - candleWidth / 2, 1, true);
        start2 ? ends.push(point1, point2) : ends.push(point2, point1);
      }
      function makeBrushRect(lowestVal, highestVal, axisDimVal) {
        const pmin = getPoint(lowestVal, axisDimVal);
        const pmax = getPoint(highestVal, axisDimVal);
        pmin[cDimIdx] -= candleWidth / 2;
        pmax[cDimIdx] -= candleWidth / 2;
        return {
          x: pmin[0],
          y: pmin[1],
          width: vDimIdx ? candleWidth : pmax[0] - pmin[0],
          height: vDimIdx ? pmax[1] - pmin[1] : candleWidth
        };
      }
      function subPixelOptimizePoint(point) {
        point[cDimIdx] = subPixelOptimize2(point[cDimIdx], 1);
        return point;
      }
    }
    function largeProgress(params, data2) {
      const points4 = createFloat32Array(params.count * 4);
      let offset = 0;
      let point;
      const tmpIn = [];
      const tmpOut = [];
      let dataIndex;
      const store = data2.getStore();
      const hasDojiColor = !!seriesModel.get(["itemStyle", "borderColorDoji"]);
      while ((dataIndex = params.next()) != null) {
        const axisDimVal = store.get(cDimI, dataIndex);
        const openVal = store.get(openDimI, dataIndex);
        const closeVal = store.get(closeDimI, dataIndex);
        const lowestVal = store.get(lowestDimI, dataIndex);
        const highestVal = store.get(highestDimI, dataIndex);
        if (isNaN(axisDimVal) || isNaN(lowestVal) || isNaN(highestVal)) {
          points4[offset++] = NaN;
          offset += 3;
          continue;
        }
        points4[offset++] = getSign(store, dataIndex, openVal, closeVal, closeDimI, hasDojiColor);
        tmpIn[cDimIdx] = axisDimVal;
        tmpIn[vDimIdx] = lowestVal;
        point = coordSys.dataToPoint(tmpIn, null, tmpOut);
        points4[offset++] = point ? point[0] : NaN;
        points4[offset++] = point ? point[1] : NaN;
        tmpIn[vDimIdx] = highestVal;
        point = coordSys.dataToPoint(tmpIn, null, tmpOut);
        points4[offset++] = point ? point[1] : NaN;
      }
      data2.setLayout("largePoints", points4);
    }
  }
};
function getSign(store, dataIndex, openVal, closeVal, closeDimI, hasDojiColor) {
  let sign;
  if (openVal > closeVal) {
    sign = -1;
  } else if (openVal < closeVal) {
    sign = 1;
  } else {
    sign = hasDojiColor ? 0 : dataIndex > 0 ? store.get(closeDimI, dataIndex - 1) <= closeVal ? 1 : -1 : 1;
  }
  return sign;
}
function calculateCandleWidth(seriesModel, data) {
  const baseAxis = seriesModel.getBaseAxis();
  let extent;
  const bandWidth = baseAxis.type === "category" ? baseAxis.getBandWidth() : (extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / data.count());
  const barMaxWidth = parsePercent2(retrieve2(seriesModel.get("barMaxWidth"), bandWidth), bandWidth);
  const barMinWidth = parsePercent2(retrieve2(seriesModel.get("barMinWidth"), 1), bandWidth);
  const barWidth = seriesModel.get("barWidth");
  return barWidth != null ? parsePercent2(barWidth, bandWidth) : Math.max(Math.min(bandWidth / 2, barMaxWidth), barMinWidth);
}
var candlestickLayout_default = candlestickLayout;

// src/chart/candlestick/install.ts
function install22(registers) {
  registers.registerChartView(CandlestickView_default);
  registers.registerSeriesModel(CandlestickSeries_default);
  registers.registerPreprocessor(candlestickPreprocessor);
  registers.registerVisual(candlestickVisual_default);
  registers.registerLayout(candlestickLayout_default);
}

// src/chart/helper/EffectSymbol.ts
function updateRipplePath(rippleGroup, effectCfg) {
  const color4 = effectCfg.rippleEffectColor || effectCfg.color;
  rippleGroup.eachChild(function(ripplePath) {
    ripplePath.attr({
      z: effectCfg.z,
      zlevel: effectCfg.zlevel,
      style: {
        stroke: effectCfg.brushType === "stroke" ? color4 : null,
        fill: effectCfg.brushType === "fill" ? color4 : null
      }
    });
  });
}
var EffectSymbol = class extends Group_default {
  constructor(data, idx) {
    super();
    const symbol = new Symbol_default(data, idx);
    const rippleGroup = new Group_default();
    this.add(symbol);
    this.add(rippleGroup);
    this.updateData(data, idx);
  }
  stopEffectAnimation() {
    this.childAt(1).removeAll();
  }
  startEffectAnimation(effectCfg) {
    const symbolType = effectCfg.symbolType;
    const color4 = effectCfg.color;
    const rippleNumber = effectCfg.rippleNumber;
    const rippleGroup = this.childAt(1);
    for (let i = 0; i < rippleNumber; i++) {
      const ripplePath = createSymbol(symbolType, -1, -1, 2, 2, color4);
      ripplePath.attr({
        style: {
          strokeNoScale: true
        },
        z2: 99,
        silent: true,
        scaleX: 0.5,
        scaleY: 0.5
      });
      const delay = -i / rippleNumber * effectCfg.period + effectCfg.effectOffset;
      ripplePath.animate("", true).when(effectCfg.period, {
        scaleX: effectCfg.rippleScale / 2,
        scaleY: effectCfg.rippleScale / 2
      }).delay(delay).start();
      ripplePath.animateStyle(true).when(effectCfg.period, {
        opacity: 0
      }).delay(delay).start();
      rippleGroup.add(ripplePath);
    }
    updateRipplePath(rippleGroup, effectCfg);
  }
  updateEffectAnimation(effectCfg) {
    const oldEffectCfg = this._effectCfg;
    const rippleGroup = this.childAt(1);
    const DIFFICULT_PROPS = ["symbolType", "period", "rippleScale", "rippleNumber"];
    for (let i = 0; i < DIFFICULT_PROPS.length; i++) {
      const propName = DIFFICULT_PROPS[i];
      if (oldEffectCfg[propName] !== effectCfg[propName]) {
        this.stopEffectAnimation();
        this.startEffectAnimation(effectCfg);
        return;
      }
    }
    updateRipplePath(rippleGroup, effectCfg);
  }
  highlight() {
    enterEmphasis(this);
  }
  downplay() {
    leaveEmphasis(this);
  }
  getSymbolType() {
    const symbol = this.childAt(0);
    return symbol && symbol.getSymbolType();
  }
  updateData(data, idx) {
    const seriesModel = data.hostModel;
    this.childAt(0).updateData(data, idx);
    const rippleGroup = this.childAt(1);
    const itemModel = data.getItemModel(idx);
    const symbolType = data.getItemVisual(idx, "symbol");
    const symbolSize = normalizeSymbolSize(data.getItemVisual(idx, "symbolSize"));
    const symbolStyle = data.getItemVisual(idx, "style");
    const color4 = symbolStyle && symbolStyle.fill;
    const emphasisModel = itemModel.getModel("emphasis");
    rippleGroup.setScale(symbolSize);
    rippleGroup.traverse(function(ripplePath) {
      ripplePath.setStyle("fill", color4);
    });
    const symbolOffset = normalizeSymbolOffset(data.getItemVisual(idx, "symbolOffset"), symbolSize);
    if (symbolOffset) {
      rippleGroup.x = symbolOffset[0];
      rippleGroup.y = symbolOffset[1];
    }
    const symbolRotate = data.getItemVisual(idx, "symbolRotate");
    rippleGroup.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
    const effectCfg = {};
    effectCfg.showEffectOn = seriesModel.get("showEffectOn");
    effectCfg.rippleScale = itemModel.get(["rippleEffect", "scale"]);
    effectCfg.brushType = itemModel.get(["rippleEffect", "brushType"]);
    effectCfg.period = itemModel.get(["rippleEffect", "period"]) * 1e3;
    effectCfg.effectOffset = idx / data.count();
    effectCfg.z = seriesModel.getShallow("z") || 0;
    effectCfg.zlevel = seriesModel.getShallow("zlevel") || 0;
    effectCfg.symbolType = symbolType;
    effectCfg.color = color4;
    effectCfg.rippleEffectColor = itemModel.get(["rippleEffect", "color"]);
    effectCfg.rippleNumber = itemModel.get(["rippleEffect", "number"]);
    if (effectCfg.showEffectOn === "render") {
      this._effectCfg ? this.updateEffectAnimation(effectCfg) : this.startEffectAnimation(effectCfg);
      this._effectCfg = effectCfg;
    } else {
      this._effectCfg = null;
      this.stopEffectAnimation();
      this.onHoverStateChange = (toState) => {
        if (toState === "emphasis") {
          if (effectCfg.showEffectOn !== "render") {
            this.startEffectAnimation(effectCfg);
          }
        } else if (toState === "normal") {
          if (effectCfg.showEffectOn !== "render") {
            this.stopEffectAnimation();
          }
        }
      };
    }
    this._effectCfg = effectCfg;
    toggleHoverEmphasis(this, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  }
  fadeOut(cb) {
    cb && cb();
  }
};
var EffectSymbol_default = EffectSymbol;

// src/chart/effectScatter/EffectScatterView.ts
var EffectScatterView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = EffectScatterView2.type;
  }
  init() {
    this._symbolDraw = new SymbolDraw_default(EffectSymbol_default);
  }
  render(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    const effectSymbolDraw = this._symbolDraw;
    effectSymbolDraw.updateData(data, {clipShape: this._getClipShape(seriesModel)});
    this.group.add(effectSymbolDraw.group);
  }
  _getClipShape(seriesModel) {
    const coordSys = seriesModel.coordinateSystem;
    const clipArea = coordSys && coordSys.getArea && coordSys.getArea();
    return seriesModel.get("clip", true) ? clipArea : null;
  }
  updateTransform(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    this.group.dirty();
    const res = pointsLayout("").reset(seriesModel, ecModel, api2);
    if (res.progress) {
      res.progress({
        start: 0,
        end: data.count(),
        count: data.count()
      }, data);
    }
    this._symbolDraw.updateLayout();
  }
  _updateGroupTransform(seriesModel) {
    const coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.getRoamTransform) {
      this.group.transform = clone3(coordSys.getRoamTransform());
      this.group.decomposeTransform();
    }
  }
  remove(ecModel, api2) {
    this._symbolDraw && this._symbolDraw.remove(true);
  }
};
var EffectScatterView = EffectScatterView2;
EffectScatterView.type = "effectScatter";
var EffectScatterView_default = EffectScatterView;

// src/chart/effectScatter/EffectScatterSeries.ts
var EffectScatterSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = EffectScatterSeriesModel2.type;
    this.hasSymbolVisual = true;
  }
  getInitialData(option, ecModel) {
    return createSeriesData_default(null, this, {useEncodeDefaulter: true});
  }
  brushSelector(dataIndex, data, selectors) {
    return selectors.point(data.getItemLayout(dataIndex));
  }
};
var EffectScatterSeriesModel = EffectScatterSeriesModel2;
EffectScatterSeriesModel.type = "series.effectScatter";
EffectScatterSeriesModel.dependencies = ["grid", "polar"];
EffectScatterSeriesModel.defaultOption = {
  coordinateSystem: "cartesian2d",
  z: 2,
  legendHoverLink: true,
  effectType: "ripple",
  progressive: 0,
  showEffectOn: "render",
  clip: true,
  rippleEffect: {
    period: 4,
    scale: 2.5,
    brushType: "fill",
    number: 3
  },
  universalTransition: {
    divideShape: "clone"
  },
  symbolSize: 10
};
var EffectScatterSeries_default = EffectScatterSeriesModel;

// src/chart/effectScatter/install.ts
function install23(registers) {
  registers.registerChartView(EffectScatterView_default);
  registers.registerSeriesModel(EffectScatterSeries_default);
  registers.registerLayout(pointsLayout("effectScatter"));
}

// src/chart/helper/EffectLine.ts
var EffectLine = class extends Group_default {
  constructor(lineData, idx, seriesScope) {
    super();
    this.add(this.createLine(lineData, idx, seriesScope));
    this._updateEffectSymbol(lineData, idx);
  }
  createLine(lineData, idx, seriesScope) {
    return new Line_default2(lineData, idx, seriesScope);
  }
  _updateEffectSymbol(lineData, idx) {
    const itemModel = lineData.getItemModel(idx);
    const effectModel = itemModel.getModel("effect");
    let size = effectModel.get("symbolSize");
    const symbolType = effectModel.get("symbol");
    if (!isArray(size)) {
      size = [size, size];
    }
    const lineStyle = lineData.getItemVisual(idx, "style");
    const color4 = effectModel.get("color") || lineStyle && lineStyle.stroke;
    let symbol = this.childAt(1);
    if (this._symbolType !== symbolType) {
      this.remove(symbol);
      symbol = createSymbol(symbolType, -0.5, -0.5, 1, 1, color4);
      symbol.z2 = 100;
      symbol.culling = true;
      this.add(symbol);
    }
    if (!symbol) {
      return;
    }
    symbol.setStyle("shadowColor", color4);
    symbol.setStyle(effectModel.getItemStyle(["color"]));
    symbol.scaleX = size[0];
    symbol.scaleY = size[1];
    symbol.setColor(color4);
    this._symbolType = symbolType;
    this._symbolScale = size;
    this._updateEffectAnimation(lineData, effectModel, idx);
  }
  _updateEffectAnimation(lineData, effectModel, idx) {
    const symbol = this.childAt(1);
    if (!symbol) {
      return;
    }
    const points4 = lineData.getItemLayout(idx);
    let period = effectModel.get("period") * 1e3;
    const loop = effectModel.get("loop");
    const roundTrip = effectModel.get("roundTrip");
    const constantSpeed = effectModel.get("constantSpeed");
    const delayExpr = retrieve(effectModel.get("delay"), function(idx2) {
      return idx2 / lineData.count() * period / 3;
    });
    symbol.ignore = true;
    this._updateAnimationPoints(symbol, points4);
    if (constantSpeed > 0) {
      period = this._getLineLength(symbol) / constantSpeed * 1e3;
    }
    if (period !== this._period || loop !== this._loop || roundTrip !== this._roundTrip) {
      symbol.stopAnimation();
      let delayNum;
      if (isFunction(delayExpr)) {
        delayNum = delayExpr(idx);
      } else {
        delayNum = delayExpr;
      }
      if (symbol.__t > 0) {
        delayNum = -period * symbol.__t;
      }
      this._animateSymbol(symbol, period, delayNum, loop, roundTrip);
    }
    this._period = period;
    this._loop = loop;
    this._roundTrip = roundTrip;
  }
  _animateSymbol(symbol, period, delayNum, loop, roundTrip) {
    if (period > 0) {
      symbol.__t = 0;
      const self2 = this;
      const animator = symbol.animate("", loop).when(roundTrip ? period * 2 : period, {
        __t: roundTrip ? 2 : 1
      }).delay(delayNum).during(function() {
        self2._updateSymbolPosition(symbol);
      });
      if (!loop) {
        animator.done(function() {
          self2.remove(symbol);
        });
      }
      animator.start();
    }
  }
  _getLineLength(symbol) {
    return dist(symbol.__p1, symbol.__cp1) + dist(symbol.__cp1, symbol.__p2);
  }
  _updateAnimationPoints(symbol, points4) {
    symbol.__p1 = points4[0];
    symbol.__p2 = points4[1];
    symbol.__cp1 = points4[2] || [
      (points4[0][0] + points4[1][0]) / 2,
      (points4[0][1] + points4[1][1]) / 2
    ];
  }
  updateData(lineData, idx, seriesScope) {
    this.childAt(0).updateData(lineData, idx, seriesScope);
    this._updateEffectSymbol(lineData, idx);
  }
  _updateSymbolPosition(symbol) {
    const p1 = symbol.__p1;
    const p2 = symbol.__p2;
    const cp1 = symbol.__cp1;
    const t = symbol.__t < 1 ? symbol.__t : 2 - symbol.__t;
    const pos = [symbol.x, symbol.y];
    const lastPos = pos.slice();
    const quadraticAt3 = quadraticAt;
    const quadraticDerivativeAt2 = quadraticDerivativeAt;
    pos[0] = quadraticAt3(p1[0], cp1[0], p2[0], t);
    pos[1] = quadraticAt3(p1[1], cp1[1], p2[1], t);
    const tx = symbol.__t < 1 ? quadraticDerivativeAt2(p1[0], cp1[0], p2[0], t) : quadraticDerivativeAt2(p2[0], cp1[0], p1[0], 1 - t);
    const ty = symbol.__t < 1 ? quadraticDerivativeAt2(p1[1], cp1[1], p2[1], t) : quadraticDerivativeAt2(p2[1], cp1[1], p1[1], 1 - t);
    symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
    if (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") {
      if (symbol.__lastT !== void 0 && symbol.__lastT < symbol.__t) {
        symbol.scaleY = dist(lastPos, pos) * 1.05;
        if (t === 1) {
          pos[0] = lastPos[0] + (pos[0] - lastPos[0]) / 2;
          pos[1] = lastPos[1] + (pos[1] - lastPos[1]) / 2;
        }
      } else if (symbol.__lastT === 1) {
        symbol.scaleY = 2 * dist(p1, pos);
      } else {
        symbol.scaleY = this._symbolScale[1];
      }
    }
    symbol.__lastT = symbol.__t;
    symbol.ignore = false;
    symbol.x = pos[0];
    symbol.y = pos[1];
  }
  updateLayout(lineData, idx) {
    this.childAt(0).updateLayout(lineData, idx);
    const effectModel = lineData.getItemModel(idx).getModel("effect");
    this._updateEffectAnimation(lineData, effectModel, idx);
  }
};
var EffectLine_default = EffectLine;

// src/chart/helper/Polyline.ts
var Polyline5 = class extends Group_default {
  constructor(lineData, idx, seriesScope) {
    super();
    this._createPolyline(lineData, idx, seriesScope);
  }
  _createPolyline(lineData, idx, seriesScope) {
    const points4 = lineData.getItemLayout(idx);
    const line2 = new Polyline_default({
      shape: {
        points: points4
      }
    });
    this.add(line2);
    this._updateCommonStl(lineData, idx, seriesScope);
  }
  updateData(lineData, idx, seriesScope) {
    const seriesModel = lineData.hostModel;
    const line2 = this.childAt(0);
    const target = {
      shape: {
        points: lineData.getItemLayout(idx)
      }
    };
    updateProps(line2, target, seriesModel, idx);
    this._updateCommonStl(lineData, idx, seriesScope);
  }
  _updateCommonStl(lineData, idx, seriesScope) {
    const line2 = this.childAt(0);
    const itemModel = lineData.getItemModel(idx);
    let emphasisLineStyle = seriesScope && seriesScope.emphasisLineStyle;
    let focus = seriesScope && seriesScope.focus;
    let blurScope = seriesScope && seriesScope.blurScope;
    let emphasisDisabled = seriesScope && seriesScope.emphasisDisabled;
    if (!seriesScope || lineData.hasItemOption) {
      const emphasisModel = itemModel.getModel("emphasis");
      emphasisLineStyle = emphasisModel.getModel("lineStyle").getLineStyle();
      emphasisDisabled = emphasisModel.get("disabled");
      focus = emphasisModel.get("focus");
      blurScope = emphasisModel.get("blurScope");
    }
    line2.useStyle(lineData.getItemVisual(idx, "style"));
    line2.style.fill = null;
    line2.style.strokeNoScale = true;
    const lineEmphasisState = line2.ensureState("emphasis");
    lineEmphasisState.style = emphasisLineStyle;
    toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
  }
  updateLayout(lineData, idx) {
    const polyline = this.childAt(0);
    polyline.setShape("points", lineData.getItemLayout(idx));
  }
};
var Polyline_default2 = Polyline5;

// src/chart/helper/EffectPolyline.ts
var EffectPolyline = class extends EffectLine_default {
  constructor() {
    super(...arguments);
    this._lastFrame = 0;
    this._lastFramePercent = 0;
  }
  createLine(lineData, idx, seriesScope) {
    return new Polyline_default2(lineData, idx, seriesScope);
  }
  _updateAnimationPoints(symbol, points4) {
    this._points = points4;
    const accLenArr = [0];
    let len2 = 0;
    for (let i = 1; i < points4.length; i++) {
      const p1 = points4[i - 1];
      const p2 = points4[i];
      len2 += dist(p1, p2);
      accLenArr.push(len2);
    }
    if (len2 === 0) {
      this._length = 0;
      return;
    }
    for (let i = 0; i < accLenArr.length; i++) {
      accLenArr[i] /= len2;
    }
    this._offsets = accLenArr;
    this._length = len2;
  }
  _getLineLength() {
    return this._length;
  }
  _updateSymbolPosition(symbol) {
    const t = symbol.__t < 1 ? symbol.__t : 2 - symbol.__t;
    const points4 = this._points;
    const offsets = this._offsets;
    const len2 = points4.length;
    if (!offsets) {
      return;
    }
    const lastFrame = this._lastFrame;
    let frame;
    if (t < this._lastFramePercent) {
      const start2 = Math.min(lastFrame + 1, len2 - 1);
      for (frame = start2; frame >= 0; frame--) {
        if (offsets[frame] <= t) {
          break;
        }
      }
      frame = Math.min(frame, len2 - 2);
    } else {
      for (frame = lastFrame; frame < len2; frame++) {
        if (offsets[frame] > t) {
          break;
        }
      }
      frame = Math.min(frame - 1, len2 - 2);
    }
    const p = (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame]);
    const p0 = points4[frame];
    const p1 = points4[frame + 1];
    symbol.x = p0[0] * (1 - p) + p * p1[0];
    symbol.y = p0[1] * (1 - p) + p * p1[1];
    const tx = symbol.__t < 1 ? p1[0] - p0[0] : p0[0] - p1[0];
    const ty = symbol.__t < 1 ? p1[1] - p0[1] : p0[1] - p1[1];
    symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
    this._lastFrame = frame;
    this._lastFramePercent = t;
    symbol.ignore = false;
  }
};
var EffectPolyline_default = EffectPolyline;

// src/chart/helper/LargeLineDraw.ts
var LargeLinesPathShape = class {
  constructor() {
    this.polyline = false;
    this.curveness = 0;
    this.segs = [];
  }
};
var LargeLinesPath = class extends Path_default {
  constructor(opts) {
    super(opts);
    this._off = 0;
    this.hoverDataIdx = -1;
  }
  reset() {
    this.notClear = false;
    this._off = 0;
  }
  getDefaultStyle() {
    return {
      stroke: tokens_default.color.neutral99,
      fill: null
    };
  }
  getDefaultShape() {
    return new LargeLinesPathShape();
  }
  buildPath(ctx, shape) {
    const segs = shape.segs;
    const curveness = shape.curveness;
    let i;
    if (shape.polyline) {
      for (i = this._off; i < segs.length; ) {
        const count2 = segs[i++];
        if (count2 > 0) {
          ctx.moveTo(segs[i++], segs[i++]);
          for (let k = 1; k < count2; k++) {
            ctx.lineTo(segs[i++], segs[i++]);
          }
        }
      }
    } else {
      for (i = this._off; i < segs.length; ) {
        const x0 = segs[i++];
        const y0 = segs[i++];
        const x1 = segs[i++];
        const y1 = segs[i++];
        ctx.moveTo(x0, y0);
        if (curveness > 0) {
          const x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;
          const y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;
          ctx.quadraticCurveTo(x2, y2, x1, y1);
        } else {
          ctx.lineTo(x1, y1);
        }
      }
    }
    if (this.incremental) {
      this._off = i;
      this.notClear = true;
    }
  }
  findDataIndex(x, y) {
    const shape = this.shape;
    const segs = shape.segs;
    const curveness = shape.curveness;
    const lineWidth = this.style.lineWidth;
    if (shape.polyline) {
      let dataIndex = 0;
      for (let i = 0; i < segs.length; ) {
        const count2 = segs[i++];
        if (count2 > 0) {
          const x0 = segs[i++];
          const y0 = segs[i++];
          for (let k = 1; k < count2; k++) {
            const x1 = segs[i++];
            const y1 = segs[i++];
            if (containStroke(x0, y0, x1, y1, lineWidth, x, y)) {
              return dataIndex;
            }
          }
        }
        dataIndex++;
      }
    } else {
      let dataIndex = 0;
      for (let i = 0; i < segs.length; ) {
        const x0 = segs[i++];
        const y0 = segs[i++];
        const x1 = segs[i++];
        const y1 = segs[i++];
        if (curveness > 0) {
          const x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;
          const y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;
          if (containStroke3(x0, y0, x2, y2, x1, y1, lineWidth, x, y)) {
            return dataIndex;
          }
        } else {
          if (containStroke(x0, y0, x1, y1, lineWidth, x, y)) {
            return dataIndex;
          }
        }
        dataIndex++;
      }
    }
    return -1;
  }
  contain(x, y) {
    const localPos = this.transformCoordToLocal(x, y);
    const rect = this.getBoundingRect();
    x = localPos[0];
    y = localPos[1];
    if (rect.contain(x, y)) {
      const dataIdx = this.hoverDataIdx = this.findDataIndex(x, y);
      return dataIdx >= 0;
    }
    this.hoverDataIdx = -1;
    return false;
  }
  getBoundingRect() {
    let rect = this._rect;
    if (!rect) {
      const shape = this.shape;
      const points4 = shape.segs;
      let minX = Infinity;
      let minY = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      for (let i = 0; i < points4.length; ) {
        const x = points4[i++];
        const y = points4[i++];
        minX = Math.min(x, minX);
        maxX = Math.max(x, maxX);
        minY = Math.min(y, minY);
        maxY = Math.max(y, maxY);
      }
      rect = this._rect = new BoundingRect_default(minX, minY, maxX, maxY);
    }
    return rect;
  }
};
var LargeLineDraw = class {
  constructor() {
    this.group = new Group_default();
  }
  updateData(data) {
    this._clear();
    const lineEl = this._create();
    lineEl.setShape({
      segs: data.getLayout("linesPoints")
    });
    this._setCommon(lineEl, data);
  }
  incrementalPrepareUpdate(data) {
    this.group.removeAll();
    this._clear();
  }
  incrementalUpdate(taskParams, data) {
    const lastAdded = this._newAdded[0];
    const linePoints = data.getLayout("linesPoints");
    const oldSegs = lastAdded && lastAdded.shape.segs;
    if (oldSegs && oldSegs.length < 2e4) {
      const oldLen = oldSegs.length;
      const newSegs = new Float32Array(oldLen + linePoints.length);
      newSegs.set(oldSegs);
      newSegs.set(linePoints, oldLen);
      lastAdded.setShape({
        segs: newSegs
      });
    } else {
      this._newAdded = [];
      const lineEl = this._create();
      lineEl.incremental = true;
      lineEl.setShape({
        segs: linePoints
      });
      this._setCommon(lineEl, data);
      lineEl.__startIndex = taskParams.start;
    }
  }
  remove() {
    this._clear();
  }
  eachRendered(cb) {
    this._newAdded[0] && cb(this._newAdded[0]);
  }
  _create() {
    const lineEl = new LargeLinesPath({
      cursor: "default",
      ignoreCoarsePointer: true
    });
    this._newAdded.push(lineEl);
    this.group.add(lineEl);
    return lineEl;
  }
  _setCommon(lineEl, data, isIncremental) {
    const hostModel = data.hostModel;
    lineEl.setShape({
      polyline: hostModel.get("polyline"),
      curveness: hostModel.get(["lineStyle", "curveness"])
    });
    lineEl.useStyle(hostModel.getModel("lineStyle").getLineStyle());
    lineEl.style.strokeNoScale = true;
    const style = data.getVisual("style");
    if (style && style.stroke) {
      lineEl.setStyle("stroke", style.stroke);
    }
    lineEl.setStyle("fill", null);
    const ecData = getECData(lineEl);
    ecData.seriesIndex = hostModel.seriesIndex;
    lineEl.on("mousemove", function(e2) {
      ecData.dataIndex = null;
      const dataIndex = lineEl.hoverDataIdx;
      if (dataIndex > 0) {
        ecData.dataIndex = dataIndex + lineEl.__startIndex;
      }
    });
  }
  _clear() {
    this._newAdded = [];
    this.group.removeAll();
  }
};
var LargeLineDraw_default = LargeLineDraw;

// src/chart/lines/linesLayout.ts
var linesLayout = {
  seriesType: "lines",
  plan: createRenderPlanner(),
  reset: function(seriesModel) {
    const coordSys = seriesModel.coordinateSystem;
    if (!coordSys) {
      if (true) {
        error("The lines series must have a coordinate system.");
      }
      return;
    }
    const isPolyline = seriesModel.get("polyline");
    const isLarge = seriesModel.pipelineContext.large;
    return {
      progress(params, lineData) {
        const lineCoords = [];
        if (isLarge) {
          let points4;
          const segCount = params.end - params.start;
          if (isPolyline) {
            let totalCoordsCount = 0;
            for (let i = params.start; i < params.end; i++) {
              totalCoordsCount += seriesModel.getLineCoordsCount(i);
            }
            points4 = new Float32Array(segCount + totalCoordsCount * 2);
          } else {
            points4 = new Float32Array(segCount * 4);
          }
          let offset = 0;
          let pt = [];
          for (let i = params.start; i < params.end; i++) {
            const len2 = seriesModel.getLineCoords(i, lineCoords);
            if (isPolyline) {
              points4[offset++] = len2;
            }
            for (let k = 0; k < len2; k++) {
              pt = coordSys.dataToPoint(lineCoords[k], false, pt);
              points4[offset++] = pt[0];
              points4[offset++] = pt[1];
            }
          }
          lineData.setLayout("linesPoints", points4);
        } else {
          for (let i = params.start; i < params.end; i++) {
            const itemModel = lineData.getItemModel(i);
            const len2 = seriesModel.getLineCoords(i, lineCoords);
            const pts = [];
            if (isPolyline) {
              for (let j = 0; j < len2; j++) {
                pts.push(coordSys.dataToPoint(lineCoords[j]));
              }
            } else {
              pts[0] = coordSys.dataToPoint(lineCoords[0]);
              pts[1] = coordSys.dataToPoint(lineCoords[1]);
              const curveness = itemModel.get(["lineStyle", "curveness"]);
              if (+curveness) {
                pts[2] = [
                  (pts[0][0] + pts[1][0]) / 2 - (pts[0][1] - pts[1][1]) * curveness,
                  (pts[0][1] + pts[1][1]) / 2 - (pts[1][0] - pts[0][0]) * curveness
                ];
              }
            }
            lineData.setItemLayout(i, pts);
          }
        }
      }
    };
  }
};
var linesLayout_default = linesLayout;

// src/chart/lines/LinesView.ts
var LinesView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = LinesView2.type;
  }
  render(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    const lineDraw = this._updateLineDraw(data, seriesModel);
    const zlevel = seriesModel.get("zlevel");
    const trailLength = seriesModel.get(["effect", "trailLength"]);
    const zr = api2.getZr();
    const isSvg = zr.painter.getType() === "svg";
    if (!isSvg) {
      zr.painter.getLayer(zlevel).clear(true);
    }
    if (this._lastZlevel != null && !isSvg) {
      zr.configLayer(this._lastZlevel, {
        motionBlur: false
      });
    }
    if (this._showEffect(seriesModel) && trailLength > 0) {
      if (!isSvg) {
        zr.configLayer(zlevel, {
          motionBlur: true,
          lastFrameAlpha: Math.max(Math.min(trailLength / 10 + 0.9, 1), 0)
        });
      } else if (true) {
        console.warn("SVG render mode doesn't support lines with trail effect");
      }
    }
    lineDraw.updateData(data);
    const clipPath = seriesModel.get("clip", true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);
    if (clipPath) {
      this.group.setClipPath(clipPath);
    } else {
      this.group.removeClipPath();
    }
    this._lastZlevel = zlevel;
    this._finished = true;
  }
  incrementalPrepareRender(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    const lineDraw = this._updateLineDraw(data, seriesModel);
    lineDraw.incrementalPrepareUpdate(data);
    this._clearLayer(api2);
    this._finished = false;
  }
  incrementalRender(taskParams, seriesModel, ecModel) {
    this._lineDraw.incrementalUpdate(taskParams, seriesModel.getData());
    this._finished = taskParams.end === seriesModel.getData().count();
  }
  eachRendered(cb) {
    this._lineDraw && this._lineDraw.eachRendered(cb);
  }
  updateTransform(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    const pipelineContext = seriesModel.pipelineContext;
    if (!this._finished || pipelineContext.large || pipelineContext.progressiveRender) {
      return {
        update: true
      };
    } else {
      const res = linesLayout_default.reset(seriesModel, ecModel, api2);
      if (res.progress) {
        res.progress({
          start: 0,
          end: data.count(),
          count: data.count()
        }, data);
      }
      this._lineDraw.updateLayout();
      this._clearLayer(api2);
    }
  }
  _updateLineDraw(data, seriesModel) {
    let lineDraw = this._lineDraw;
    const hasEffect = this._showEffect(seriesModel);
    const isPolyline = !!seriesModel.get("polyline");
    const pipelineContext = seriesModel.pipelineContext;
    const isLargeDraw = pipelineContext.large;
    if (true) {
      if (hasEffect && isLargeDraw) {
        console.warn("Large lines not support effect");
      }
    }
    if (!lineDraw || hasEffect !== this._hasEffet || isPolyline !== this._isPolyline || isLargeDraw !== this._isLargeDraw) {
      if (lineDraw) {
        lineDraw.remove();
      }
      lineDraw = this._lineDraw = isLargeDraw ? new LargeLineDraw_default() : new LineDraw_default(isPolyline ? hasEffect ? EffectPolyline_default : Polyline_default2 : hasEffect ? EffectLine_default : Line_default2);
      this._hasEffet = hasEffect;
      this._isPolyline = isPolyline;
      this._isLargeDraw = isLargeDraw;
    }
    this.group.add(lineDraw.group);
    return lineDraw;
  }
  _showEffect(seriesModel) {
    return !!seriesModel.get(["effect", "show"]);
  }
  _clearLayer(api2) {
    const zr = api2.getZr();
    const isSvg = zr.painter.getType() === "svg";
    if (!isSvg && this._lastZlevel != null) {
      zr.painter.getLayer(this._lastZlevel).clear(true);
    }
  }
  remove(ecModel, api2) {
    this._lineDraw && this._lineDraw.remove();
    this._lineDraw = null;
    this._clearLayer(api2);
  }
  dispose(ecModel, api2) {
    this.remove(ecModel, api2);
  }
};
var LinesView = LinesView2;
LinesView.type = "lines";
var LinesView_default = LinesView;

// src/chart/lines/LinesSeries.ts
var Uint32Arr = typeof Uint32Array === "undefined" ? Array : Uint32Array;
var Float64Arr = typeof Float64Array === "undefined" ? Array : Float64Array;
function compatEc2(seriesOpt) {
  const data = seriesOpt.data;
  if (data && data[0] && data[0][0] && data[0][0].coord) {
    if (true) {
      console.warn("Lines data configuration has been changed to { coords:[[1,2],[2,3]] }");
    }
    seriesOpt.data = map(data, function(itemOpt) {
      const coords = [
        itemOpt[0].coord,
        itemOpt[1].coord
      ];
      const target = {
        coords
      };
      if (itemOpt[0].name) {
        target.fromName = itemOpt[0].name;
      }
      if (itemOpt[1].name) {
        target.toName = itemOpt[1].name;
      }
      return mergeAll([target, itemOpt[0], itemOpt[1]]);
    });
  }
}
var LinesSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = LinesSeriesModel2.type;
    this.visualStyleAccessPath = "lineStyle";
    this.visualDrawType = "stroke";
  }
  init(option) {
    option.data = option.data || [];
    compatEc2(option);
    const result = this._processFlatCoordsArray(option.data);
    this._flatCoords = result.flatCoords;
    this._flatCoordsOffset = result.flatCoordsOffset;
    if (result.flatCoords) {
      option.data = new Float32Array(result.count);
    }
    super.init.apply(this, arguments);
  }
  mergeOption(option) {
    compatEc2(option);
    if (option.data) {
      const result = this._processFlatCoordsArray(option.data);
      this._flatCoords = result.flatCoords;
      this._flatCoordsOffset = result.flatCoordsOffset;
      if (result.flatCoords) {
        option.data = new Float32Array(result.count);
      }
    }
    super.mergeOption.apply(this, arguments);
  }
  appendData(params) {
    const result = this._processFlatCoordsArray(params.data);
    if (result.flatCoords) {
      if (!this._flatCoords) {
        this._flatCoords = result.flatCoords;
        this._flatCoordsOffset = result.flatCoordsOffset;
      } else {
        this._flatCoords = concatArray(this._flatCoords, result.flatCoords);
        this._flatCoordsOffset = concatArray(this._flatCoordsOffset, result.flatCoordsOffset);
      }
      params.data = new Float32Array(result.count);
    }
    this.getRawData().appendData(params.data);
  }
  _getCoordsFromItemModel(idx) {
    const itemModel = this.getData().getItemModel(idx);
    const coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow("coords");
    if (true) {
      if (!(coords instanceof Array && coords.length > 0 && coords[0] instanceof Array)) {
        throw new Error("Invalid coords " + JSON.stringify(coords) + ". Lines must have 2d coords array in data item.");
      }
    }
    return coords;
  }
  getLineCoordsCount(idx) {
    if (this._flatCoordsOffset) {
      return this._flatCoordsOffset[idx * 2 + 1];
    } else {
      return this._getCoordsFromItemModel(idx).length;
    }
  }
  getLineCoords(idx, out2) {
    if (this._flatCoordsOffset) {
      const offset = this._flatCoordsOffset[idx * 2];
      const len2 = this._flatCoordsOffset[idx * 2 + 1];
      for (let i = 0; i < len2; i++) {
        out2[i] = out2[i] || [];
        out2[i][0] = this._flatCoords[offset + i * 2];
        out2[i][1] = this._flatCoords[offset + i * 2 + 1];
      }
      return len2;
    } else {
      const coords = this._getCoordsFromItemModel(idx);
      for (let i = 0; i < coords.length; i++) {
        out2[i] = out2[i] || [];
        out2[i][0] = coords[i][0];
        out2[i][1] = coords[i][1];
      }
      return coords.length;
    }
  }
  _processFlatCoordsArray(data) {
    let startOffset = 0;
    if (this._flatCoords) {
      startOffset = this._flatCoords.length;
    }
    if (isNumber(data[0])) {
      const len2 = data.length;
      const coordsOffsetAndLenStorage = new Uint32Arr(len2);
      const coordsStorage = new Float64Arr(len2);
      let coordsCursor = 0;
      let offsetCursor = 0;
      let dataCount = 0;
      for (let i = 0; i < len2; ) {
        dataCount++;
        const count2 = data[i++];
        coordsOffsetAndLenStorage[offsetCursor++] = coordsCursor + startOffset;
        coordsOffsetAndLenStorage[offsetCursor++] = count2;
        for (let k = 0; k < count2; k++) {
          const x = data[i++];
          const y = data[i++];
          coordsStorage[coordsCursor++] = x;
          coordsStorage[coordsCursor++] = y;
          if (i > len2) {
            if (true) {
              throw new Error("Invalid data format.");
            }
          }
        }
      }
      return {
        flatCoordsOffset: new Uint32Array(coordsOffsetAndLenStorage.buffer, 0, offsetCursor),
        flatCoords: coordsStorage,
        count: dataCount
      };
    }
    return {
      flatCoordsOffset: null,
      flatCoords: null,
      count: data.length
    };
  }
  getInitialData(option, ecModel) {
    if (true) {
      const CoordSys = CoordinateSystem_default.get(option.coordinateSystem);
      if (!CoordSys) {
        throw new Error("Unknown coordinate system " + option.coordinateSystem);
      }
    }
    const lineData = new SeriesData_default(["value"], this);
    lineData.hasItemOption = false;
    lineData.initData(option.data, [], function(dataItem, dimName, dataIndex, dimIndex) {
      if (dataItem instanceof Array) {
        return NaN;
      } else {
        lineData.hasItemOption = true;
        const value = dataItem.value;
        if (value != null) {
          return value instanceof Array ? value[dimIndex] : value;
        }
      }
    });
    return lineData;
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    const data = this.getData();
    const itemModel = data.getItemModel(dataIndex);
    const name = itemModel.get("name");
    if (name) {
      return name;
    }
    const fromName = itemModel.get("fromName");
    const toName = itemModel.get("toName");
    const nameArr = [];
    fromName != null && nameArr.push(fromName);
    toName != null && nameArr.push(toName);
    return createTooltipMarkup("nameValue", {
      name: nameArr.join(" > ")
    });
  }
  preventIncremental() {
    return !!this.get(["effect", "show"]);
  }
  getProgressive() {
    const progressive = this.option.progressive;
    if (progressive == null) {
      return this.option.large ? 1e4 : this.get("progressive");
    }
    return progressive;
  }
  getProgressiveThreshold() {
    const progressiveThreshold = this.option.progressiveThreshold;
    if (progressiveThreshold == null) {
      return this.option.large ? 2e4 : this.get("progressiveThreshold");
    }
    return progressiveThreshold;
  }
  getZLevelKey() {
    const effectModel = this.getModel("effect");
    const trailLength = effectModel.get("trailLength");
    return this.getData().count() > this.getProgressiveThreshold() ? this.id : effectModel.get("show") && trailLength > 0 ? trailLength + "" : "";
  }
};
var LinesSeriesModel = LinesSeriesModel2;
LinesSeriesModel.type = "series.lines";
LinesSeriesModel.dependencies = ["grid", "polar", "geo", "calendar"];
LinesSeriesModel.defaultOption = {
  coordinateSystem: "geo",
  z: 2,
  legendHoverLink: true,
  xAxisIndex: 0,
  yAxisIndex: 0,
  symbol: ["none", "none"],
  symbolSize: [10, 10],
  geoIndex: 0,
  effect: {
    show: false,
    period: 4,
    constantSpeed: 0,
    symbol: "circle",
    symbolSize: 3,
    loop: true,
    trailLength: 0.2
  },
  large: false,
  largeThreshold: 2e3,
  polyline: false,
  clip: true,
  label: {
    show: false,
    position: "end"
  },
  lineStyle: {
    opacity: 0.5
  }
};
var LinesSeries_default = LinesSeriesModel;

// src/chart/lines/linesVisual.ts
function normalize4(a) {
  if (!(a instanceof Array)) {
    a = [a, a];
  }
  return a;
}
var linesVisual = {
  seriesType: "lines",
  reset(seriesModel) {
    const symbolType = normalize4(seriesModel.get("symbol"));
    const symbolSize = normalize4(seriesModel.get("symbolSize"));
    const data = seriesModel.getData();
    data.setVisual("fromSymbol", symbolType && symbolType[0]);
    data.setVisual("toSymbol", symbolType && symbolType[1]);
    data.setVisual("fromSymbolSize", symbolSize && symbolSize[0]);
    data.setVisual("toSymbolSize", symbolSize && symbolSize[1]);
    function dataEach(data2, idx) {
      const itemModel = data2.getItemModel(idx);
      const symbolType2 = normalize4(itemModel.getShallow("symbol", true));
      const symbolSize2 = normalize4(itemModel.getShallow("symbolSize", true));
      symbolType2[0] && data2.setItemVisual(idx, "fromSymbol", symbolType2[0]);
      symbolType2[1] && data2.setItemVisual(idx, "toSymbol", symbolType2[1]);
      symbolSize2[0] && data2.setItemVisual(idx, "fromSymbolSize", symbolSize2[0]);
      symbolSize2[1] && data2.setItemVisual(idx, "toSymbolSize", symbolSize2[1]);
    }
    return {
      dataEach: data.hasItemOption ? dataEach : null
    };
  }
};
var linesVisual_default = linesVisual;

// src/chart/lines/install.ts
function install24(registers) {
  registers.registerChartView(LinesView_default);
  registers.registerSeriesModel(LinesSeries_default);
  registers.registerLayout(linesLayout_default);
  registers.registerVisual(linesVisual_default);
}

// src/chart/heatmap/HeatmapLayer.ts
var GRADIENT_LEVELS = 256;
var HeatmapLayer = class {
  constructor() {
    this.blurSize = 30;
    this.pointSize = 20;
    this.maxOpacity = 1;
    this.minOpacity = 0;
    this._gradientPixels = {
      inRange: null,
      outOfRange: null
    };
    const canvas = platformApi.createCanvas();
    this.canvas = canvas;
  }
  update(data, width, height, normalize5, colorFunc, isInRange) {
    const brush3 = this._getBrush();
    const gradientInRange = this._getGradient(colorFunc, "inRange");
    const gradientOutOfRange = this._getGradient(colorFunc, "outOfRange");
    const r = this.pointSize + this.blurSize;
    const canvas = this.canvas;
    const ctx = canvas.getContext("2d");
    const len2 = data.length;
    canvas.width = width;
    canvas.height = height;
    for (let i = 0; i < len2; ++i) {
      const p = data[i];
      const x = p[0];
      const y = p[1];
      const value = p[2];
      const alpha = normalize5(value);
      ctx.globalAlpha = alpha;
      ctx.drawImage(brush3, x - r, y - r);
    }
    if (!canvas.width || !canvas.height) {
      return canvas;
    }
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const pixels = imageData.data;
    let offset = 0;
    const pixelLen = pixels.length;
    const minOpacity = this.minOpacity;
    const maxOpacity = this.maxOpacity;
    const diffOpacity = maxOpacity - minOpacity;
    while (offset < pixelLen) {
      let alpha = pixels[offset + 3] / 256;
      const gradientOffset = Math.floor(alpha * (GRADIENT_LEVELS - 1)) * 4;
      if (alpha > 0) {
        const gradient = isInRange(alpha) ? gradientInRange : gradientOutOfRange;
        alpha > 0 && (alpha = alpha * diffOpacity + minOpacity);
        pixels[offset++] = gradient[gradientOffset];
        pixels[offset++] = gradient[gradientOffset + 1];
        pixels[offset++] = gradient[gradientOffset + 2];
        pixels[offset++] = gradient[gradientOffset + 3] * alpha * 256;
      } else {
        offset += 4;
      }
    }
    ctx.putImageData(imageData, 0, 0);
    return canvas;
  }
  _getBrush() {
    const brushCanvas = this._brushCanvas || (this._brushCanvas = platformApi.createCanvas());
    const r = this.pointSize + this.blurSize;
    const d = r * 2;
    brushCanvas.width = d;
    brushCanvas.height = d;
    const ctx = brushCanvas.getContext("2d");
    ctx.clearRect(0, 0, d, d);
    ctx.shadowOffsetX = d;
    ctx.shadowBlur = this.blurSize;
    ctx.shadowColor = tokens_default.color.neutral99;
    ctx.beginPath();
    ctx.arc(-r, r, this.pointSize, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.fill();
    return brushCanvas;
  }
  _getGradient(colorFunc, state) {
    const gradientPixels = this._gradientPixels;
    const pixelsSingleState = gradientPixels[state] || (gradientPixels[state] = new Uint8ClampedArray(256 * 4));
    const color4 = [0, 0, 0, 0];
    let off = 0;
    for (let i = 0; i < 256; i++) {
      colorFunc[state](i / 255, true, color4);
      pixelsSingleState[off++] = color4[0];
      pixelsSingleState[off++] = color4[1];
      pixelsSingleState[off++] = color4[2];
      pixelsSingleState[off++] = color4[3];
    }
    return pixelsSingleState;
  }
};
var HeatmapLayer_default = HeatmapLayer;

// src/chart/heatmap/HeatmapView.ts
function getIsInPiecewiseRange(dataExtent, pieceList, selected) {
  const dataSpan = dataExtent[1] - dataExtent[0];
  pieceList = map(pieceList, function(piece) {
    return {
      interval: [
        (piece.interval[0] - dataExtent[0]) / dataSpan,
        (piece.interval[1] - dataExtent[0]) / dataSpan
      ]
    };
  });
  const len2 = pieceList.length;
  let lastIndex = 0;
  return function(val) {
    let i;
    for (i = lastIndex; i < len2; i++) {
      const interval = pieceList[i].interval;
      if (interval[0] <= val && val <= interval[1]) {
        lastIndex = i;
        break;
      }
    }
    if (i === len2) {
      for (i = lastIndex - 1; i >= 0; i--) {
        const interval = pieceList[i].interval;
        if (interval[0] <= val && val <= interval[1]) {
          lastIndex = i;
          break;
        }
      }
    }
    return i >= 0 && i < len2 && selected[i];
  };
}
function getIsInContinuousRange(dataExtent, range) {
  const dataSpan = dataExtent[1] - dataExtent[0];
  range = [
    (range[0] - dataExtent[0]) / dataSpan,
    (range[1] - dataExtent[0]) / dataSpan
  ];
  return function(val) {
    return val >= range[0] && val <= range[1];
  };
}
function isGeoCoordSys(coordSys) {
  const dimensions = coordSys.dimensions;
  return dimensions[0] === "lng" && dimensions[1] === "lat";
}
var HeatmapView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = HeatmapView2.type;
  }
  render(seriesModel, ecModel, api2) {
    let visualMapOfThisSeries;
    ecModel.eachComponent("visualMap", function(visualMap) {
      visualMap.eachTargetSeries(function(targetSeries) {
        if (targetSeries === seriesModel) {
          visualMapOfThisSeries = visualMap;
        }
      });
    });
    if (true) {
      if (!visualMapOfThisSeries) {
        throw new Error("Heatmap must use with visualMap");
      }
    }
    this._progressiveEls = null;
    this.group.removeAll();
    const coordSys = seriesModel.coordinateSystem;
    if (coordSys.type === "cartesian2d" || coordSys.type === "calendar" || coordSys.type === "matrix") {
      this._renderOnGridLike(seriesModel, api2, 0, seriesModel.getData().count());
    } else if (isGeoCoordSys(coordSys)) {
      this._renderOnGeo(coordSys, seriesModel, visualMapOfThisSeries, api2);
    }
  }
  incrementalPrepareRender(seriesModel, ecModel, api2) {
    this.group.removeAll();
  }
  incrementalRender(params, seriesModel, ecModel, api2) {
    const coordSys = seriesModel.coordinateSystem;
    if (coordSys) {
      if (isGeoCoordSys(coordSys)) {
        this.render(seriesModel, ecModel, api2);
      } else {
        this._progressiveEls = [];
        this._renderOnGridLike(seriesModel, api2, params.start, params.end, true);
      }
    }
  }
  eachRendered(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  }
  _renderOnGridLike(seriesModel, api2, start2, end2, incremental) {
    const coordSys = seriesModel.coordinateSystem;
    const isCartesian2d = isCoordinateSystemType(coordSys, "cartesian2d");
    const isMatrix = isCoordinateSystemType(coordSys, "matrix");
    let width;
    let height;
    let xAxisExtent;
    let yAxisExtent;
    if (isCartesian2d) {
      const xAxis = coordSys.getAxis("x");
      const yAxis = coordSys.getAxis("y");
      if (true) {
        if (!(xAxis.type === "category" && yAxis.type === "category")) {
          throw new Error("Heatmap on cartesian must have two category axes");
        }
        if (!(xAxis.onBand && yAxis.onBand)) {
          throw new Error("Heatmap on cartesian must have two axes with boundaryGap true");
        }
      }
      width = xAxis.getBandWidth() + 0.5;
      height = yAxis.getBandWidth() + 0.5;
      xAxisExtent = xAxis.scale.getExtent();
      yAxisExtent = yAxis.scale.getExtent();
    }
    const group = this.group;
    const data = seriesModel.getData();
    let emphasisStyle = seriesModel.getModel(["emphasis", "itemStyle"]).getItemStyle();
    let blurStyle = seriesModel.getModel(["blur", "itemStyle"]).getItemStyle();
    let selectStyle = seriesModel.getModel(["select", "itemStyle"]).getItemStyle();
    let borderRadius = seriesModel.get(["itemStyle", "borderRadius"]);
    let labelStatesModels = getLabelStatesModels(seriesModel);
    const emphasisModel = seriesModel.getModel("emphasis");
    let focus = emphasisModel.get("focus");
    let blurScope = emphasisModel.get("blurScope");
    let emphasisDisabled = emphasisModel.get("disabled");
    const dataDims = isCartesian2d || isMatrix ? [
      data.mapDimension("x"),
      data.mapDimension("y"),
      data.mapDimension("value")
    ] : [
      data.mapDimension("time"),
      data.mapDimension("value")
    ];
    for (let idx = start2; idx < end2; idx++) {
      let rect;
      const style = data.getItemVisual(idx, "style");
      if (isCartesian2d) {
        const dataDimX = data.get(dataDims[0], idx);
        const dataDimY = data.get(dataDims[1], idx);
        if (isNaN(data.get(dataDims[2], idx)) || isNaN(dataDimX) || isNaN(dataDimY) || dataDimX < xAxisExtent[0] || dataDimX > xAxisExtent[1] || dataDimY < yAxisExtent[0] || dataDimY > yAxisExtent[1]) {
          continue;
        }
        const point = coordSys.dataToPoint([
          dataDimX,
          dataDimY
        ]);
        rect = new Rect_default({
          shape: {
            x: point[0] - width / 2,
            y: point[1] - height / 2,
            width,
            height
          },
          style
        });
      } else if (isMatrix) {
        const shape = coordSys.dataToLayout([
          data.get(dataDims[0], idx),
          data.get(dataDims[1], idx)
        ]).rect;
        if (eqNaN(shape.x)) {
          continue;
        }
        rect = new Rect_default({
          z2: 1,
          shape,
          style
        });
      } else {
        if (isNaN(data.get(dataDims[1], idx))) {
          continue;
        }
        const layout14 = coordSys.dataToLayout([data.get(dataDims[0], idx)]);
        const shape = layout14.contentRect || layout14.rect;
        if (eqNaN(shape.x) || eqNaN(shape.y)) {
          continue;
        }
        rect = new Rect_default({
          z2: 1,
          shape,
          style
        });
      }
      if (data.hasItemOption) {
        const itemModel = data.getItemModel(idx);
        const emphasisModel2 = itemModel.getModel("emphasis");
        emphasisStyle = emphasisModel2.getModel("itemStyle").getItemStyle();
        blurStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
        selectStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
        borderRadius = itemModel.get(["itemStyle", "borderRadius"]);
        focus = emphasisModel2.get("focus");
        blurScope = emphasisModel2.get("blurScope");
        emphasisDisabled = emphasisModel2.get("disabled");
        labelStatesModels = getLabelStatesModels(itemModel);
      }
      rect.shape.r = borderRadius;
      const rawValue = seriesModel.getRawValue(idx);
      let defaultText = "-";
      if (rawValue && rawValue[2] != null) {
        defaultText = rawValue[2] + "";
      }
      setLabelStyle(rect, labelStatesModels, {
        labelFetcher: seriesModel,
        labelDataIndex: idx,
        defaultOpacity: style.opacity,
        defaultText
      });
      rect.ensureState("emphasis").style = emphasisStyle;
      rect.ensureState("blur").style = blurStyle;
      rect.ensureState("select").style = selectStyle;
      toggleHoverEmphasis(rect, focus, blurScope, emphasisDisabled);
      rect.incremental = incremental;
      if (incremental) {
        rect.states.emphasis.hoverLayer = true;
      }
      group.add(rect);
      data.setItemGraphicEl(idx, rect);
      if (this._progressiveEls) {
        this._progressiveEls.push(rect);
      }
    }
  }
  _renderOnGeo(geo, seriesModel, visualMapModel, api2) {
    const inRangeVisuals = visualMapModel.targetVisuals.inRange;
    const outOfRangeVisuals = visualMapModel.targetVisuals.outOfRange;
    const data = seriesModel.getData();
    const hmLayer = this._hmLayer || (this._hmLayer || new HeatmapLayer_default());
    hmLayer.blurSize = seriesModel.get("blurSize");
    hmLayer.pointSize = seriesModel.get("pointSize");
    hmLayer.minOpacity = seriesModel.get("minOpacity");
    hmLayer.maxOpacity = seriesModel.get("maxOpacity");
    const rect = geo.getViewRect().clone();
    const roamTransform = geo.getRoamTransform();
    rect.applyTransform(roamTransform);
    const x = Math.max(rect.x, 0);
    const y = Math.max(rect.y, 0);
    const x2 = Math.min(rect.width + rect.x, api2.getWidth());
    const y2 = Math.min(rect.height + rect.y, api2.getHeight());
    const width = x2 - x;
    const height = y2 - y;
    const dims = [
      data.mapDimension("lng"),
      data.mapDimension("lat"),
      data.mapDimension("value")
    ];
    const points4 = data.mapArray(dims, function(lng, lat, value) {
      const pt = geo.dataToPoint([lng, lat]);
      pt[0] -= x;
      pt[1] -= y;
      pt.push(value);
      return pt;
    });
    const dataExtent = visualMapModel.getExtent();
    const isInRange = visualMapModel.type === "visualMap.continuous" ? getIsInContinuousRange(dataExtent, visualMapModel.option.range) : getIsInPiecewiseRange(dataExtent, visualMapModel.getPieceList(), visualMapModel.option.selected);
    hmLayer.update(points4, width, height, inRangeVisuals.color.getNormalizer(), {
      inRange: inRangeVisuals.color.getColorMapper(),
      outOfRange: outOfRangeVisuals.color.getColorMapper()
    }, isInRange);
    const img = new Image_default({
      style: {
        width,
        height,
        x,
        y,
        image: hmLayer.canvas
      },
      silent: true
    });
    this.group.add(img);
  }
};
var HeatmapView = HeatmapView2;
HeatmapView.type = "heatmap";
var HeatmapView_default = HeatmapView;

// src/chart/heatmap/HeatmapSeries.ts
var HeatmapSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = HeatmapSeriesModel2.type;
  }
  getInitialData(option, ecModel) {
    return createSeriesData_default(null, this, {
      generateCoord: "value"
    });
  }
  preventIncremental() {
    const coordSysCreator = CoordinateSystem_default.get(this.get("coordinateSystem"));
    if (coordSysCreator && coordSysCreator.dimensions) {
      return coordSysCreator.dimensions[0] === "lng" && coordSysCreator.dimensions[1] === "lat";
    }
  }
};
var HeatmapSeriesModel = HeatmapSeriesModel2;
HeatmapSeriesModel.type = "series.heatmap";
HeatmapSeriesModel.dependencies = ["grid", "geo", "calendar", "matrix"];
HeatmapSeriesModel.defaultOption = {
  coordinateSystem: "cartesian2d",
  z: 2,
  geoIndex: 0,
  blurSize: 30,
  pointSize: 20,
  maxOpacity: 1,
  minOpacity: 0,
  select: {
    itemStyle: {
      borderColor: tokens_default.color.primary
    }
  }
};
var HeatmapSeries_default = HeatmapSeriesModel;

// src/chart/heatmap/install.ts
function install25(registers) {
  registers.registerChartView(HeatmapView_default);
  registers.registerSeriesModel(HeatmapSeries_default);
}

// src/chart/bar/PictorialBarView.ts
var BAR_BORDER_WIDTH_QUERY = ["itemStyle", "borderWidth"];
var LAYOUT_ATTRS = [
  {xy: "x", wh: "width", index: 0, posDesc: ["left", "right"]},
  {xy: "y", wh: "height", index: 1, posDesc: ["top", "bottom"]}
];
var pathForLineWidth = new Circle_default();
var PictorialBarView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = PictorialBarView2.type;
  }
  render(seriesModel, ecModel, api2) {
    const group = this.group;
    const data = seriesModel.getData();
    const oldData = this._data;
    const cartesian = seriesModel.coordinateSystem;
    const baseAxis = cartesian.getBaseAxis();
    const isHorizontal = baseAxis.isHorizontal();
    const coordSysRect = cartesian.master.getRect();
    const opt = {
      ecSize: {width: api2.getWidth(), height: api2.getHeight()},
      seriesModel,
      coordSys: cartesian,
      coordSysExtent: [
        [coordSysRect.x, coordSysRect.x + coordSysRect.width],
        [coordSysRect.y, coordSysRect.y + coordSysRect.height]
      ],
      isHorizontal,
      valueDim: LAYOUT_ATTRS[+isHorizontal],
      categoryDim: LAYOUT_ATTRS[1 - +isHorizontal]
    };
    data.diff(oldData).add(function(dataIndex) {
      if (!data.hasValue(dataIndex)) {
        return;
      }
      const itemModel = getItemModel(data, dataIndex);
      const symbolMeta = getSymbolMeta(data, dataIndex, itemModel, opt);
      const bar = createBar(data, opt, symbolMeta);
      data.setItemGraphicEl(dataIndex, bar);
      group.add(bar);
      updateCommon2(bar, opt, symbolMeta);
    }).update(function(newIndex, oldIndex) {
      let bar = oldData.getItemGraphicEl(oldIndex);
      if (!data.hasValue(newIndex)) {
        group.remove(bar);
        return;
      }
      const itemModel = getItemModel(data, newIndex);
      const symbolMeta = getSymbolMeta(data, newIndex, itemModel, opt);
      const pictorialShapeStr = getShapeStr(data, symbolMeta);
      if (bar && pictorialShapeStr !== bar.__pictorialShapeStr) {
        group.remove(bar);
        data.setItemGraphicEl(newIndex, null);
        bar = null;
      }
      if (bar) {
        updateBar(bar, opt, symbolMeta);
      } else {
        bar = createBar(data, opt, symbolMeta, true);
      }
      data.setItemGraphicEl(newIndex, bar);
      bar.__pictorialSymbolMeta = symbolMeta;
      group.add(bar);
      updateCommon2(bar, opt, symbolMeta);
    }).remove(function(dataIndex) {
      const bar = oldData.getItemGraphicEl(dataIndex);
      bar && removeBar(oldData, dataIndex, bar.__pictorialSymbolMeta.animationModel, bar);
    }).execute();
    const clipPath = seriesModel.get("clip", true) ? createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null;
    if (clipPath) {
      group.setClipPath(clipPath);
    } else {
      group.removeClipPath();
    }
    this._data = data;
    return this.group;
  }
  remove(ecModel, api2) {
    const group = this.group;
    const data = this._data;
    if (ecModel.get("animation")) {
      if (data) {
        data.eachItemGraphicEl(function(bar) {
          removeBar(data, getECData(bar).dataIndex, ecModel, bar);
        });
      }
    } else {
      group.removeAll();
    }
  }
};
var PictorialBarView = PictorialBarView2;
PictorialBarView.type = "pictorialBar";
function getSymbolMeta(data, dataIndex, itemModel, opt) {
  const layout14 = data.getItemLayout(dataIndex);
  const symbolRepeat = itemModel.get("symbolRepeat");
  const symbolClip = itemModel.get("symbolClip");
  const symbolPosition = itemModel.get("symbolPosition") || "start";
  const symbolRotate = itemModel.get("symbolRotate");
  const rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
  const symbolPatternSize = itemModel.get("symbolPatternSize") || 2;
  const isAnimationEnabled2 = itemModel.isAnimationEnabled();
  const symbolMeta = {
    dataIndex,
    layout: layout14,
    itemModel,
    symbolType: data.getItemVisual(dataIndex, "symbol") || "circle",
    style: data.getItemVisual(dataIndex, "style"),
    symbolClip,
    symbolRepeat,
    symbolRepeatDirection: itemModel.get("symbolRepeatDirection"),
    symbolPatternSize,
    rotation,
    animationModel: isAnimationEnabled2 ? itemModel : null,
    hoverScale: isAnimationEnabled2 && itemModel.get(["emphasis", "scale"]),
    z2: itemModel.getShallow("z", true) || 0
  };
  prepareBarLength(itemModel, symbolRepeat, layout14, opt, symbolMeta);
  prepareSymbolSize(data, dataIndex, layout14, symbolRepeat, symbolClip, symbolMeta.boundingLength, symbolMeta.pxSign, symbolPatternSize, opt, symbolMeta);
  prepareLineWidth(itemModel, symbolMeta.symbolScale, rotation, opt, symbolMeta);
  const symbolSize = symbolMeta.symbolSize;
  const symbolOffset = normalizeSymbolOffset(itemModel.get("symbolOffset"), symbolSize);
  prepareLayoutInfo(itemModel, symbolSize, layout14, symbolRepeat, symbolClip, symbolOffset, symbolPosition, symbolMeta.valueLineWidth, symbolMeta.boundingLength, symbolMeta.repeatCutLength, opt, symbolMeta);
  return symbolMeta;
}
function prepareBarLength(itemModel, symbolRepeat, layout14, opt, outputSymbolMeta) {
  const valueDim = opt.valueDim;
  const symbolBoundingData = itemModel.get("symbolBoundingData");
  const valueAxis2 = opt.coordSys.getOtherAxis(opt.coordSys.getBaseAxis());
  const zeroPx = valueAxis2.toGlobalCoord(valueAxis2.dataToCoord(0));
  const pxSignIdx = 1 - +(layout14[valueDim.wh] <= 0);
  let boundingLength;
  if (isArray(symbolBoundingData)) {
    const symbolBoundingExtent = [
      convertToCoordOnAxis(valueAxis2, symbolBoundingData[0]) - zeroPx,
      convertToCoordOnAxis(valueAxis2, symbolBoundingData[1]) - zeroPx
    ];
    symbolBoundingExtent[1] < symbolBoundingExtent[0] && symbolBoundingExtent.reverse();
    boundingLength = symbolBoundingExtent[pxSignIdx];
  } else if (symbolBoundingData != null) {
    boundingLength = convertToCoordOnAxis(valueAxis2, symbolBoundingData) - zeroPx;
  } else if (symbolRepeat) {
    boundingLength = opt.coordSysExtent[valueDim.index][pxSignIdx] - zeroPx;
  } else {
    boundingLength = layout14[valueDim.wh];
  }
  outputSymbolMeta.boundingLength = boundingLength;
  if (symbolRepeat) {
    outputSymbolMeta.repeatCutLength = layout14[valueDim.wh];
  }
  const isXAxis = valueDim.xy === "x";
  const isInverse = valueAxis2.inverse;
  outputSymbolMeta.pxSign = isXAxis && !isInverse || !isXAxis && isInverse ? boundingLength >= 0 ? 1 : -1 : boundingLength > 0 ? 1 : -1;
}
function convertToCoordOnAxis(axis, value) {
  return axis.toGlobalCoord(axis.dataToCoord(axis.scale.parse(value)));
}
function prepareSymbolSize(data, dataIndex, layout14, symbolRepeat, symbolClip, boundingLength, pxSign, symbolPatternSize, opt, outputSymbolMeta) {
  const valueDim = opt.valueDim;
  const categoryDim = opt.categoryDim;
  const categorySize = Math.abs(layout14[categoryDim.wh]);
  const symbolSize = data.getItemVisual(dataIndex, "symbolSize");
  let parsedSymbolSize;
  if (isArray(symbolSize)) {
    parsedSymbolSize = symbolSize.slice();
  } else {
    if (symbolSize == null) {
      parsedSymbolSize = ["100%", "100%"];
    } else {
      parsedSymbolSize = [symbolSize, symbolSize];
    }
  }
  parsedSymbolSize[categoryDim.index] = parsePercent2(parsedSymbolSize[categoryDim.index], categorySize);
  parsedSymbolSize[valueDim.index] = parsePercent2(parsedSymbolSize[valueDim.index], symbolRepeat ? categorySize : Math.abs(boundingLength));
  outputSymbolMeta.symbolSize = parsedSymbolSize;
  const symbolScale = outputSymbolMeta.symbolScale = [
    parsedSymbolSize[0] / symbolPatternSize,
    parsedSymbolSize[1] / symbolPatternSize
  ];
  symbolScale[valueDim.index] *= (opt.isHorizontal ? -1 : 1) * pxSign;
}
function prepareLineWidth(itemModel, symbolScale, rotation, opt, outputSymbolMeta) {
  let valueLineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;
  if (valueLineWidth) {
    pathForLineWidth.attr({
      scaleX: symbolScale[0],
      scaleY: symbolScale[1],
      rotation
    });
    pathForLineWidth.updateTransform();
    valueLineWidth /= pathForLineWidth.getLineScale();
    valueLineWidth *= symbolScale[opt.valueDim.index];
  }
  outputSymbolMeta.valueLineWidth = valueLineWidth || 0;
}
function prepareLayoutInfo(itemModel, symbolSize, layout14, symbolRepeat, symbolClip, symbolOffset, symbolPosition, valueLineWidth, boundingLength, repeatCutLength, opt, outputSymbolMeta) {
  const categoryDim = opt.categoryDim;
  const valueDim = opt.valueDim;
  const pxSign = outputSymbolMeta.pxSign;
  const unitLength = Math.max(symbolSize[valueDim.index] + valueLineWidth, 0);
  let pathLen = unitLength;
  if (symbolRepeat) {
    const absBoundingLength = Math.abs(boundingLength);
    let symbolMargin = retrieve(itemModel.get("symbolMargin"), "15%") + "";
    let hasEndGap = false;
    if (symbolMargin.lastIndexOf("!") === symbolMargin.length - 1) {
      hasEndGap = true;
      symbolMargin = symbolMargin.slice(0, symbolMargin.length - 1);
    }
    let symbolMarginNumeric = parsePercent2(symbolMargin, symbolSize[valueDim.index]);
    let uLenWithMargin = Math.max(unitLength + symbolMarginNumeric * 2, 0);
    let endFix = hasEndGap ? 0 : symbolMarginNumeric * 2;
    const repeatSpecified = isNumeric(symbolRepeat);
    let repeatTimes = repeatSpecified ? symbolRepeat : toIntTimes((absBoundingLength + endFix) / uLenWithMargin);
    const mDiff = absBoundingLength - repeatTimes * unitLength;
    symbolMarginNumeric = mDiff / 2 / (hasEndGap ? repeatTimes : Math.max(repeatTimes - 1, 1));
    uLenWithMargin = unitLength + symbolMarginNumeric * 2;
    endFix = hasEndGap ? 0 : symbolMarginNumeric * 2;
    if (!repeatSpecified && symbolRepeat !== "fixed") {
      repeatTimes = repeatCutLength ? toIntTimes((Math.abs(repeatCutLength) + endFix) / uLenWithMargin) : 0;
    }
    pathLen = repeatTimes * uLenWithMargin - endFix;
    outputSymbolMeta.repeatTimes = repeatTimes;
    outputSymbolMeta.symbolMargin = symbolMarginNumeric;
  }
  const sizeFix = pxSign * (pathLen / 2);
  const pathPosition = outputSymbolMeta.pathPosition = [];
  pathPosition[categoryDim.index] = layout14[categoryDim.wh] / 2;
  pathPosition[valueDim.index] = symbolPosition === "start" ? sizeFix : symbolPosition === "end" ? boundingLength - sizeFix : boundingLength / 2;
  if (symbolOffset) {
    pathPosition[0] += symbolOffset[0];
    pathPosition[1] += symbolOffset[1];
  }
  const bundlePosition = outputSymbolMeta.bundlePosition = [];
  bundlePosition[categoryDim.index] = layout14[categoryDim.xy];
  bundlePosition[valueDim.index] = layout14[valueDim.xy];
  const barRectShape = outputSymbolMeta.barRectShape = extend({}, layout14);
  barRectShape[valueDim.wh] = pxSign * Math.max(Math.abs(layout14[valueDim.wh]), Math.abs(pathPosition[valueDim.index] + sizeFix));
  barRectShape[categoryDim.wh] = layout14[categoryDim.wh];
  const clipShape = outputSymbolMeta.clipShape = {};
  clipShape[categoryDim.xy] = -layout14[categoryDim.xy];
  clipShape[categoryDim.wh] = opt.ecSize[categoryDim.wh];
  clipShape[valueDim.xy] = 0;
  clipShape[valueDim.wh] = layout14[valueDim.wh];
}
function createPath(symbolMeta) {
  const symbolPatternSize = symbolMeta.symbolPatternSize;
  const path = createSymbol(symbolMeta.symbolType, -symbolPatternSize / 2, -symbolPatternSize / 2, symbolPatternSize, symbolPatternSize);
  path.attr({
    culling: true
  });
  path.type !== "image" && path.setStyle({
    strokeNoScale: true
  });
  return path;
}
function createOrUpdateRepeatSymbols(bar, opt, symbolMeta, isUpdate) {
  const bundle = bar.__pictorialBundle;
  const symbolSize = symbolMeta.symbolSize;
  const valueLineWidth = symbolMeta.valueLineWidth;
  const pathPosition = symbolMeta.pathPosition;
  const valueDim = opt.valueDim;
  const repeatTimes = symbolMeta.repeatTimes || 0;
  let index = 0;
  const unit = symbolSize[opt.valueDim.index] + valueLineWidth + symbolMeta.symbolMargin * 2;
  eachPath(bar, function(path) {
    path.__pictorialAnimationIndex = index;
    path.__pictorialRepeatTimes = repeatTimes;
    if (index < repeatTimes) {
      updateAttr(path, null, makeTarget(index), symbolMeta, isUpdate);
    } else {
      updateAttr(path, null, {scaleX: 0, scaleY: 0}, symbolMeta, isUpdate, function() {
        bundle.remove(path);
      });
    }
    index++;
  });
  for (; index < repeatTimes; index++) {
    const path = createPath(symbolMeta);
    path.__pictorialAnimationIndex = index;
    path.__pictorialRepeatTimes = repeatTimes;
    bundle.add(path);
    const target = makeTarget(index);
    updateAttr(path, {
      x: target.x,
      y: target.y,
      scaleX: 0,
      scaleY: 0
    }, {
      scaleX: target.scaleX,
      scaleY: target.scaleY,
      rotation: target.rotation
    }, symbolMeta, isUpdate);
  }
  function makeTarget(index2) {
    const position2 = pathPosition.slice();
    const pxSign = symbolMeta.pxSign;
    let i = index2;
    if (symbolMeta.symbolRepeatDirection === "start" ? pxSign > 0 : pxSign < 0) {
      i = repeatTimes - 1 - index2;
    }
    position2[valueDim.index] = unit * (i - repeatTimes / 2 + 0.5) + pathPosition[valueDim.index];
    return {
      x: position2[0],
      y: position2[1],
      scaleX: symbolMeta.symbolScale[0],
      scaleY: symbolMeta.symbolScale[1],
      rotation: symbolMeta.rotation
    };
  }
}
function createOrUpdateSingleSymbol(bar, opt, symbolMeta, isUpdate) {
  const bundle = bar.__pictorialBundle;
  let mainPath = bar.__pictorialMainPath;
  if (!mainPath) {
    mainPath = bar.__pictorialMainPath = createPath(symbolMeta);
    bundle.add(mainPath);
    updateAttr(mainPath, {
      x: symbolMeta.pathPosition[0],
      y: symbolMeta.pathPosition[1],
      scaleX: 0,
      scaleY: 0,
      rotation: symbolMeta.rotation
    }, {
      scaleX: symbolMeta.symbolScale[0],
      scaleY: symbolMeta.symbolScale[1]
    }, symbolMeta, isUpdate);
  } else {
    updateAttr(mainPath, null, {
      x: symbolMeta.pathPosition[0],
      y: symbolMeta.pathPosition[1],
      scaleX: symbolMeta.symbolScale[0],
      scaleY: symbolMeta.symbolScale[1],
      rotation: symbolMeta.rotation
    }, symbolMeta, isUpdate);
  }
}
function createOrUpdateBarRect(bar, symbolMeta, isUpdate) {
  const rectShape = extend({}, symbolMeta.barRectShape);
  let barRect = bar.__pictorialBarRect;
  if (!barRect) {
    barRect = bar.__pictorialBarRect = new Rect_default({
      z2: 2,
      shape: rectShape,
      silent: true,
      style: {
        stroke: "transparent",
        fill: "transparent",
        lineWidth: 0
      }
    });
    barRect.disableMorphing = true;
    bar.add(barRect);
  } else {
    updateAttr(barRect, null, {shape: rectShape}, symbolMeta, isUpdate);
  }
}
function createOrUpdateClip(bar, opt, symbolMeta, isUpdate) {
  if (symbolMeta.symbolClip) {
    let clipPath = bar.__pictorialClipPath;
    const clipShape = extend({}, symbolMeta.clipShape);
    const valueDim = opt.valueDim;
    const animationModel = symbolMeta.animationModel;
    const dataIndex = symbolMeta.dataIndex;
    if (clipPath) {
      updateProps(clipPath, {shape: clipShape}, animationModel, dataIndex);
    } else {
      clipShape[valueDim.wh] = 0;
      clipPath = new Rect_default({shape: clipShape});
      bar.__pictorialBundle.setClipPath(clipPath);
      bar.__pictorialClipPath = clipPath;
      const target = {};
      target[valueDim.wh] = symbolMeta.clipShape[valueDim.wh];
      graphic_exports[isUpdate ? "updateProps" : "initProps"](clipPath, {shape: target}, animationModel, dataIndex);
    }
  }
}
function getItemModel(data, dataIndex) {
  const itemModel = data.getItemModel(dataIndex);
  itemModel.getAnimationDelayParams = getAnimationDelayParams;
  itemModel.isAnimationEnabled = isAnimationEnabled;
  return itemModel;
}
function getAnimationDelayParams(path) {
  return {
    index: path.__pictorialAnimationIndex,
    count: path.__pictorialRepeatTimes
  };
}
function isAnimationEnabled() {
  return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
}
function createBar(data, opt, symbolMeta, isUpdate) {
  const bar = new Group_default();
  const bundle = new Group_default();
  bar.add(bundle);
  bar.__pictorialBundle = bundle;
  bundle.x = symbolMeta.bundlePosition[0];
  bundle.y = symbolMeta.bundlePosition[1];
  if (symbolMeta.symbolRepeat) {
    createOrUpdateRepeatSymbols(bar, opt, symbolMeta);
  } else {
    createOrUpdateSingleSymbol(bar, opt, symbolMeta);
  }
  createOrUpdateBarRect(bar, symbolMeta, isUpdate);
  createOrUpdateClip(bar, opt, symbolMeta, isUpdate);
  bar.__pictorialShapeStr = getShapeStr(data, symbolMeta);
  bar.__pictorialSymbolMeta = symbolMeta;
  return bar;
}
function updateBar(bar, opt, symbolMeta) {
  const animationModel = symbolMeta.animationModel;
  const dataIndex = symbolMeta.dataIndex;
  const bundle = bar.__pictorialBundle;
  updateProps(bundle, {
    x: symbolMeta.bundlePosition[0],
    y: symbolMeta.bundlePosition[1]
  }, animationModel, dataIndex);
  if (symbolMeta.symbolRepeat) {
    createOrUpdateRepeatSymbols(bar, opt, symbolMeta, true);
  } else {
    createOrUpdateSingleSymbol(bar, opt, symbolMeta, true);
  }
  createOrUpdateBarRect(bar, symbolMeta, true);
  createOrUpdateClip(bar, opt, symbolMeta, true);
}
function removeBar(data, dataIndex, animationModel, bar) {
  const labelRect = bar.__pictorialBarRect;
  labelRect && labelRect.removeTextContent();
  const paths = [];
  eachPath(bar, function(path) {
    paths.push(path);
  });
  bar.__pictorialMainPath && paths.push(bar.__pictorialMainPath);
  bar.__pictorialClipPath && (animationModel = null);
  each(paths, function(path) {
    removeElement(path, {scaleX: 0, scaleY: 0}, animationModel, dataIndex, function() {
      bar.parent && bar.parent.remove(bar);
    });
  });
  data.setItemGraphicEl(dataIndex, null);
}
function getShapeStr(data, symbolMeta) {
  return [
    data.getItemVisual(symbolMeta.dataIndex, "symbol") || "none",
    !!symbolMeta.symbolRepeat,
    !!symbolMeta.symbolClip
  ].join(":");
}
function eachPath(bar, cb, context) {
  each(bar.__pictorialBundle.children(), function(el) {
    el !== bar.__pictorialBarRect && cb.call(context, el);
  });
}
function updateAttr(el, immediateAttrs, animationAttrs, symbolMeta, isUpdate, cb) {
  immediateAttrs && el.attr(immediateAttrs);
  if (symbolMeta.symbolClip && !isUpdate) {
    animationAttrs && el.attr(animationAttrs);
  } else {
    animationAttrs && graphic_exports[isUpdate ? "updateProps" : "initProps"](el, animationAttrs, symbolMeta.animationModel, symbolMeta.dataIndex, cb);
  }
}
function updateCommon2(bar, opt, symbolMeta) {
  const dataIndex = symbolMeta.dataIndex;
  const itemModel = symbolMeta.itemModel;
  const emphasisModel = itemModel.getModel("emphasis");
  const emphasisStyle = emphasisModel.getModel("itemStyle").getItemStyle();
  const blurStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
  const selectStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
  const cursorStyle = itemModel.getShallow("cursor");
  const focus = emphasisModel.get("focus");
  const blurScope = emphasisModel.get("blurScope");
  const hoverScale = emphasisModel.get("scale");
  eachPath(bar, function(path) {
    if (path instanceof Image_default) {
      const pathStyle = path.style;
      path.useStyle(extend({
        image: pathStyle.image,
        x: pathStyle.x,
        y: pathStyle.y,
        width: pathStyle.width,
        height: pathStyle.height
      }, symbolMeta.style));
    } else {
      path.useStyle(symbolMeta.style);
    }
    const emphasisState = path.ensureState("emphasis");
    emphasisState.style = emphasisStyle;
    if (hoverScale) {
      emphasisState.scaleX = path.scaleX * 1.1;
      emphasisState.scaleY = path.scaleY * 1.1;
    }
    path.ensureState("blur").style = blurStyle;
    path.ensureState("select").style = selectStyle;
    cursorStyle && (path.cursor = cursorStyle);
    path.z2 = symbolMeta.z2;
  });
  const barPositionOutside = opt.valueDim.posDesc[+(symbolMeta.boundingLength > 0)];
  const barRect = bar.__pictorialBarRect;
  barRect.ignoreClip = true;
  setLabelStyle(barRect, getLabelStatesModels(itemModel), {
    labelFetcher: opt.seriesModel,
    labelDataIndex: dataIndex,
    defaultText: getDefaultLabel(opt.seriesModel.getData(), dataIndex),
    inheritColor: symbolMeta.style.fill,
    defaultOpacity: symbolMeta.style.opacity,
    defaultOutsidePosition: barPositionOutside
  });
  toggleHoverEmphasis(bar, focus, blurScope, emphasisModel.get("disabled"));
}
function toIntTimes(times) {
  const roundedTimes = Math.round(times);
  return Math.abs(times - roundedTimes) < 1e-4 ? roundedTimes : Math.ceil(times);
}
var PictorialBarView_default = PictorialBarView;

// src/chart/bar/PictorialBarSeries.ts
var PictorialBarSeriesModel2 = class extends BaseBarSeries_default {
  constructor() {
    super(...arguments);
    this.type = PictorialBarSeriesModel2.type;
    this.hasSymbolVisual = true;
    this.defaultSymbol = "roundRect";
  }
  getInitialData(option) {
    option.stack = null;
    return super.getInitialData.apply(this, arguments);
  }
};
var PictorialBarSeriesModel = PictorialBarSeriesModel2;
PictorialBarSeriesModel.type = "series.pictorialBar";
PictorialBarSeriesModel.dependencies = ["grid"];
PictorialBarSeriesModel.defaultOption = inheritDefaultOption(BaseBarSeries_default.defaultOption, {
  symbol: "circle",
  symbolSize: null,
  symbolRotate: null,
  symbolPosition: null,
  symbolOffset: null,
  symbolMargin: null,
  symbolRepeat: false,
  symbolRepeatDirection: "end",
  symbolClip: false,
  symbolBoundingData: null,
  symbolPatternSize: 400,
  barGap: "-100%",
  clip: false,
  progressive: 0,
  emphasis: {
    scale: false
  },
  select: {
    itemStyle: {
      borderColor: tokens_default.color.primary
    }
  }
});
var PictorialBarSeries_default = PictorialBarSeriesModel;

// src/chart/bar/installPictorialBar.ts
function install26(registers) {
  registers.registerChartView(PictorialBarView_default);
  registers.registerSeriesModel(PictorialBarSeries_default);
  registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, curry(layout2, "pictorialBar"));
  registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("pictorialBar"));
}

// src/chart/themeRiver/ThemeRiverView.ts
var ThemeRiverView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = ThemeRiverView2.type;
    this._layers = [];
  }
  render(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    const self2 = this;
    const group = this.group;
    const layersSeries = seriesModel.getLayerSeries();
    const layoutInfo = data.getLayout("layoutInfo");
    const rect = layoutInfo.rect;
    const boundaryGap = layoutInfo.boundaryGap;
    group.x = 0;
    group.y = rect.y + boundaryGap[0];
    function keyGetter(item) {
      return item.name;
    }
    const dataDiffer = new DataDiffer_default(this._layersSeries || [], layersSeries, keyGetter, keyGetter);
    const newLayersGroups = [];
    dataDiffer.add(bind(process2, this, "add")).update(bind(process2, this, "update")).remove(bind(process2, this, "remove")).execute();
    function process2(status, idx, oldIdx) {
      const oldLayersGroups = self2._layers;
      if (status === "remove") {
        group.remove(oldLayersGroups[idx]);
        return;
      }
      const points0 = [];
      const points1 = [];
      let style;
      const indices = layersSeries[idx].indices;
      let j = 0;
      for (; j < indices.length; j++) {
        const layout14 = data.getItemLayout(indices[j]);
        const x = layout14.x;
        const y0 = layout14.y0;
        const y = layout14.y;
        points0.push(x, y0);
        points1.push(x, y0 + y);
        style = data.getItemVisual(indices[j], "style");
      }
      let polygon;
      const textLayout = data.getItemLayout(indices[0]);
      const labelModel = seriesModel.getModel("label");
      const margin = labelModel.get("margin");
      const emphasisModel = seriesModel.getModel("emphasis");
      if (status === "add") {
        const layerGroup = newLayersGroups[idx] = new Group_default();
        polygon = new ECPolygon({
          shape: {
            points: points0,
            stackedOnPoints: points1,
            smooth: 0.4,
            stackedOnSmooth: 0.4,
            smoothConstraint: false
          },
          z2: 0
        });
        layerGroup.add(polygon);
        group.add(layerGroup);
        if (seriesModel.isAnimationEnabled()) {
          polygon.setClipPath(createGridClipShape3(polygon.getBoundingRect(), seriesModel, function() {
            polygon.removeClipPath();
          }));
        }
      } else {
        const layerGroup = oldLayersGroups[oldIdx];
        polygon = layerGroup.childAt(0);
        group.add(layerGroup);
        newLayersGroups[idx] = layerGroup;
        updateProps(polygon, {
          shape: {
            points: points0,
            stackedOnPoints: points1
          }
        }, seriesModel);
        saveOldStyle(polygon);
      }
      setLabelStyle(polygon, getLabelStatesModels(seriesModel), {
        labelDataIndex: indices[j - 1],
        defaultText: data.getName(indices[j - 1]),
        inheritColor: style.fill
      }, {
        normal: {
          verticalAlign: "middle"
        }
      });
      polygon.setTextConfig({
        position: null,
        local: true
      });
      const labelEl = polygon.getTextContent();
      if (labelEl) {
        labelEl.x = textLayout.x - margin;
        labelEl.y = textLayout.y0 + textLayout.y / 2;
      }
      polygon.useStyle(style);
      data.setItemGraphicEl(idx, polygon);
      setStatesStylesFromModel(polygon, seriesModel);
      toggleHoverEmphasis(polygon, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    }
    this._layersSeries = layersSeries;
    this._layers = newLayersGroups;
  }
};
var ThemeRiverView = ThemeRiverView2;
ThemeRiverView.type = "themeRiver";
function createGridClipShape3(rect, seriesModel, cb) {
  const rectEl = new Rect_default({
    shape: {
      x: rect.x - 10,
      y: rect.y - 10,
      width: 0,
      height: rect.height + 20
    }
  });
  initProps(rectEl, {
    shape: {
      x: rect.x - 50,
      width: rect.width + 100,
      height: rect.height + 20
    }
  }, seriesModel, cb);
  return rectEl;
}
var ThemeRiverView_default = ThemeRiverView;

// src/chart/themeRiver/ThemeRiverSeries.ts
var DATA_NAME_INDEX = 2;
var ThemeRiverSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = ThemeRiverSeriesModel2.type;
  }
  init(option) {
    super.init.apply(this, arguments);
    this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this));
  }
  fixData(data) {
    let rawDataLength = data.length;
    const timeValueKeys = {};
    const groupResult = groupData(data, (item) => {
      if (!timeValueKeys.hasOwnProperty(item[0] + "")) {
        timeValueKeys[item[0] + ""] = -1;
      }
      return item[2];
    });
    const layerData = [];
    groupResult.buckets.each(function(items, key) {
      layerData.push({
        name: key,
        dataList: items
      });
    });
    const layerNum = layerData.length;
    for (let k = 0; k < layerNum; ++k) {
      const name = layerData[k].name;
      for (let j = 0; j < layerData[k].dataList.length; ++j) {
        const timeValue = layerData[k].dataList[j][0] + "";
        timeValueKeys[timeValue] = k;
      }
      for (const timeValue in timeValueKeys) {
        if (timeValueKeys.hasOwnProperty(timeValue) && timeValueKeys[timeValue] !== k) {
          timeValueKeys[timeValue] = k;
          data[rawDataLength] = [timeValue, 0, name];
          rawDataLength++;
        }
      }
    }
    return data;
  }
  getInitialData(option, ecModel) {
    const singleAxisModel = this.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
    const axisType = singleAxisModel.get("type");
    const filterData = filter(option.data, function(dataItem) {
      return dataItem[2] !== void 0;
    });
    const data = this.fixData(filterData || []);
    const nameList = [];
    const nameMap = this.nameMap = createHashMap();
    let count2 = 0;
    for (let i = 0; i < data.length; ++i) {
      nameList.push(data[i][DATA_NAME_INDEX]);
      if (!nameMap.get(data[i][DATA_NAME_INDEX])) {
        nameMap.set(data[i][DATA_NAME_INDEX], count2);
        count2++;
      }
    }
    const {dimensions} = prepareSeriesDataSchema(data, {
      coordDimensions: ["single"],
      dimensionsDefine: [
        {
          name: "time",
          type: getDimensionTypeByAxis(axisType)
        },
        {
          name: "value",
          type: "float"
        },
        {
          name: "name",
          type: "ordinal"
        }
      ],
      encodeDefine: {
        single: 0,
        value: 1,
        itemName: 2
      }
    });
    const list = new SeriesData_default(dimensions, this);
    list.initData(data);
    return list;
  }
  getLayerSeries() {
    const data = this.getData();
    const lenCount = data.count();
    const indexArr = [];
    for (let i = 0; i < lenCount; ++i) {
      indexArr[i] = i;
    }
    const timeDim = data.mapDimension("single");
    const groupResult = groupData(indexArr, function(index) {
      return data.get("name", index);
    });
    const layerSeries = [];
    groupResult.buckets.each(function(items, key) {
      items.sort(function(index1, index2) {
        return data.get(timeDim, index1) - data.get(timeDim, index2);
      });
      layerSeries.push({
        name: key,
        indices: items
      });
    });
    return layerSeries;
  }
  getAxisTooltipData(dim, value, baseAxis) {
    if (!isArray(dim)) {
      dim = dim ? [dim] : [];
    }
    const data = this.getData();
    const layerSeries = this.getLayerSeries();
    const indices = [];
    const layerNum = layerSeries.length;
    let nestestValue;
    for (let i = 0; i < layerNum; ++i) {
      let minDist = Number.MAX_VALUE;
      let nearestIdx = -1;
      const pointNum = layerSeries[i].indices.length;
      for (let j = 0; j < pointNum; ++j) {
        const theValue = data.get(dim[0], layerSeries[i].indices[j]);
        const dist3 = Math.abs(theValue - value);
        if (dist3 <= minDist) {
          nestestValue = theValue;
          minDist = dist3;
          nearestIdx = layerSeries[i].indices[j];
        }
      }
      indices.push(nearestIdx);
    }
    return {dataIndices: indices, nestestValue};
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    const data = this.getData();
    const name = data.getName(dataIndex);
    const value = data.get(data.mapDimension("value"), dataIndex);
    return createTooltipMarkup("nameValue", {name, value});
  }
};
var ThemeRiverSeriesModel = ThemeRiverSeriesModel2;
ThemeRiverSeriesModel.type = "series.themeRiver";
ThemeRiverSeriesModel.dependencies = ["singleAxis"];
ThemeRiverSeriesModel.defaultOption = {
  z: 2,
  colorBy: "data",
  coordinateSystem: "singleAxis",
  boundaryGap: ["10%", "10%"],
  singleAxisIndex: 0,
  animationEasing: "linear",
  label: {
    margin: 4,
    show: true,
    position: "left",
    fontSize: 11
  },
  emphasis: {
    label: {
      show: true
    }
  }
};
var ThemeRiverSeries_default = ThemeRiverSeriesModel;

// src/chart/themeRiver/themeRiverLayout.ts
function themeRiverLayout(ecModel, api2) {
  ecModel.eachSeriesByType("themeRiver", function(seriesModel) {
    const data = seriesModel.getData();
    const single = seriesModel.coordinateSystem;
    const layoutInfo = {};
    const rect = single.getRect();
    layoutInfo.rect = rect;
    const boundaryGap = seriesModel.get("boundaryGap");
    const axis = single.getAxis();
    layoutInfo.boundaryGap = boundaryGap;
    if (axis.orient === "horizontal") {
      boundaryGap[0] = parsePercent2(boundaryGap[0], rect.height);
      boundaryGap[1] = parsePercent2(boundaryGap[1], rect.height);
      const height = rect.height - boundaryGap[0] - boundaryGap[1];
      doThemeRiverLayout(data, seriesModel, height);
    } else {
      boundaryGap[0] = parsePercent2(boundaryGap[0], rect.width);
      boundaryGap[1] = parsePercent2(boundaryGap[1], rect.width);
      const width = rect.width - boundaryGap[0] - boundaryGap[1];
      doThemeRiverLayout(data, seriesModel, width);
    }
    data.setLayout("layoutInfo", layoutInfo);
  });
}
function doThemeRiverLayout(data, seriesModel, height) {
  if (!data.count()) {
    return;
  }
  const coordSys = seriesModel.coordinateSystem;
  const layerSeries = seriesModel.getLayerSeries();
  const timeDim = data.mapDimension("single");
  const valueDim = data.mapDimension("value");
  const layerPoints = map(layerSeries, function(singleLayer) {
    return map(singleLayer.indices, function(idx) {
      const pt = coordSys.dataToPoint(data.get(timeDim, idx));
      pt[1] = data.get(valueDim, idx);
      return pt;
    });
  });
  const base2 = computeBaseline(layerPoints);
  const baseLine = base2.y0;
  const ky = height / base2.max;
  const n = layerSeries.length;
  const m2 = layerSeries[0].indices.length;
  let baseY0;
  for (let j = 0; j < m2; ++j) {
    baseY0 = baseLine[j] * ky;
    data.setItemLayout(layerSeries[0].indices[j], {
      layerIndex: 0,
      x: layerPoints[0][j][0],
      y0: baseY0,
      y: layerPoints[0][j][1] * ky
    });
    for (let i = 1; i < n; ++i) {
      baseY0 += layerPoints[i - 1][j][1] * ky;
      data.setItemLayout(layerSeries[i].indices[j], {
        layerIndex: i,
        x: layerPoints[i][j][0],
        y0: baseY0,
        y: layerPoints[i][j][1] * ky
      });
    }
  }
}
function computeBaseline(data) {
  const layerNum = data.length;
  const pointNum = data[0].length;
  const sums = [];
  const y0 = [];
  let max3 = 0;
  for (let i = 0; i < pointNum; ++i) {
    let temp = 0;
    for (let j = 0; j < layerNum; ++j) {
      temp += data[j][i][1];
    }
    if (temp > max3) {
      max3 = temp;
    }
    sums.push(temp);
  }
  for (let k = 0; k < pointNum; ++k) {
    y0[k] = (max3 - sums[k]) / 2;
  }
  max3 = 0;
  for (let l = 0; l < pointNum; ++l) {
    const sum2 = sums[l] + y0[l];
    if (sum2 > max3) {
      max3 = sum2;
    }
  }
  return {
    y0,
    max: max3
  };
}

// src/chart/themeRiver/install.ts
function install27(registers) {
  registers.registerChartView(ThemeRiverView_default);
  registers.registerSeriesModel(ThemeRiverSeries_default);
  registers.registerLayout(themeRiverLayout);
  registers.registerProcessor(dataFilter("themeRiver"));
}

// src/chart/sunburst/SunburstPiece.ts
var DEFAULT_SECTOR_Z = 2;
var DEFAULT_TEXT_Z = 4;
var SunburstPiece = class extends Sector_default {
  constructor(node, seriesModel, ecModel, api2) {
    super();
    this.z2 = DEFAULT_SECTOR_Z;
    this.textConfig = {
      inside: true
    };
    getECData(this).seriesIndex = seriesModel.seriesIndex;
    const text = new Text_default({
      z2: DEFAULT_TEXT_Z,
      silent: node.getModel().get(["label", "silent"])
    });
    this.setTextContent(text);
    this.updateData(true, node, seriesModel, ecModel, api2);
  }
  updateData(firstCreate, node, seriesModel, ecModel, api2) {
    this.node = node;
    node.piece = this;
    seriesModel = seriesModel || this._seriesModel;
    ecModel = ecModel || this._ecModel;
    const sector = this;
    getECData(sector).dataIndex = node.dataIndex;
    const itemModel = node.getModel();
    const emphasisModel = itemModel.getModel("emphasis");
    const layout14 = node.getLayout();
    const sectorShape = extend({}, layout14);
    sectorShape.label = null;
    const normalStyle = node.getVisual("style");
    normalStyle.lineJoin = "bevel";
    const decal = node.getVisual("decal");
    if (decal) {
      normalStyle.decal = createOrUpdatePatternFromDecal(decal, api2);
    }
    const cornerRadius = getSectorCornerRadius(itemModel.getModel("itemStyle"), sectorShape, true);
    extend(sectorShape, cornerRadius);
    each(SPECIAL_STATES, function(stateName) {
      const state = sector.ensureState(stateName);
      const itemStyleModel = itemModel.getModel([stateName, "itemStyle"]);
      state.style = itemStyleModel.getItemStyle();
      const cornerRadius2 = getSectorCornerRadius(itemStyleModel, sectorShape);
      if (cornerRadius2) {
        state.shape = cornerRadius2;
      }
    });
    if (firstCreate) {
      sector.setShape(sectorShape);
      sector.shape.r = layout14.r0;
      initProps(sector, {
        shape: {
          r: layout14.r
        }
      }, seriesModel, node.dataIndex);
    } else {
      updateProps(sector, {
        shape: sectorShape
      }, seriesModel);
      saveOldStyle(sector);
    }
    sector.useStyle(normalStyle);
    this._updateLabel(seriesModel);
    const cursorStyle = itemModel.getShallow("cursor");
    cursorStyle && sector.attr("cursor", cursorStyle);
    this._seriesModel = seriesModel || this._seriesModel;
    this._ecModel = ecModel || this._ecModel;
    const focus = emphasisModel.get("focus");
    const focusOrIndices = focus === "relative" ? concatArray(node.getAncestorsIndices(), node.getDescendantIndices()) : focus === "ancestor" ? node.getAncestorsIndices() : focus === "descendant" ? node.getDescendantIndices() : focus;
    toggleHoverEmphasis(this, focusOrIndices, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  }
  _updateLabel(seriesModel) {
    const itemModel = this.node.getModel();
    const normalLabelModel = itemModel.getModel("label");
    const layout14 = this.node.getLayout();
    const angle = layout14.endAngle - layout14.startAngle;
    const midAngle = (layout14.startAngle + layout14.endAngle) / 2;
    const dx = Math.cos(midAngle);
    const dy = Math.sin(midAngle);
    const sector = this;
    const label = sector.getTextContent();
    const dataIndex = this.node.dataIndex;
    const labelMinAngle = normalLabelModel.get("minAngle") / 180 * Math.PI;
    const isNormalShown = normalLabelModel.get("show") && !(labelMinAngle != null && Math.abs(angle) < labelMinAngle);
    label.ignore = !isNormalShown;
    each(DISPLAY_STATES, (stateName) => {
      const labelStateModel = stateName === "normal" ? itemModel.getModel("label") : itemModel.getModel([stateName, "label"]);
      const isNormal = stateName === "normal";
      const state = isNormal ? label : label.ensureState(stateName);
      let text = seriesModel.getFormattedLabel(dataIndex, stateName);
      if (isNormal) {
        text = text || this.node.name;
      }
      state.style = createTextStyle(labelStateModel, {}, null, stateName !== "normal", true);
      if (text) {
        state.style.text = text;
      }
      const isShown = labelStateModel.get("show");
      if (isShown != null && !isNormal) {
        state.ignore = !isShown;
      }
      const labelPosition = getLabelAttr(labelStateModel, "position");
      const sectorState = isNormal ? sector : sector.states[stateName];
      const labelColor = sectorState.style.fill;
      sectorState.textConfig = {
        outsideFill: labelStateModel.get("color") === "inherit" ? labelColor : null,
        inside: labelPosition !== "outside"
      };
      let r;
      const labelPadding = getLabelAttr(labelStateModel, "distance") || 0;
      let textAlign = getLabelAttr(labelStateModel, "align");
      const rotateType = getLabelAttr(labelStateModel, "rotate");
      const flipStartAngle = Math.PI * 0.5;
      const flipEndAngle = Math.PI * 1.5;
      const midAngleNormal = normalizeRadian(rotateType === "tangential" ? Math.PI / 2 - midAngle : midAngle);
      const needsFlip = midAngleNormal > flipStartAngle && !isRadianAroundZero(midAngleNormal - flipStartAngle) && midAngleNormal < flipEndAngle;
      if (labelPosition === "outside") {
        r = layout14.r + labelPadding;
        textAlign = needsFlip ? "right" : "left";
      } else {
        if (!textAlign || textAlign === "center") {
          if (angle === 2 * Math.PI && layout14.r0 === 0) {
            r = 0;
          } else {
            r = (layout14.r + layout14.r0) / 2;
          }
          textAlign = "center";
        } else if (textAlign === "left") {
          r = layout14.r0 + labelPadding;
          textAlign = needsFlip ? "right" : "left";
        } else if (textAlign === "right") {
          r = layout14.r - labelPadding;
          textAlign = needsFlip ? "left" : "right";
        }
      }
      state.style.align = textAlign;
      state.style.verticalAlign = getLabelAttr(labelStateModel, "verticalAlign") || "middle";
      state.x = r * dx + layout14.cx;
      state.y = r * dy + layout14.cy;
      let rotate2 = 0;
      if (rotateType === "radial") {
        rotate2 = normalizeRadian(-midAngle) + (needsFlip ? Math.PI : 0);
      } else if (rotateType === "tangential") {
        rotate2 = normalizeRadian(Math.PI / 2 - midAngle) + (needsFlip ? Math.PI : 0);
      } else if (isNumber(rotateType)) {
        rotate2 = rotateType * Math.PI / 180;
      }
      state.rotation = normalizeRadian(rotate2);
    });
    function getLabelAttr(model, name) {
      const stateAttr = model.get(name);
      if (stateAttr == null) {
        return normalLabelModel.get(name);
      }
      return stateAttr;
    }
    label.dirtyStyle();
  }
};
var SunburstPiece_default = SunburstPiece;

// src/chart/sunburst/sunburstAction.ts
var ROOT_TO_NODE_ACTION = "sunburstRootToNode";
var HIGHLIGHT_ACTION = "sunburstHighlight";
var UNHIGHLIGHT_ACTION = "sunburstUnhighlight";
function installSunburstAction(registers) {
  registers.registerAction({type: ROOT_TO_NODE_ACTION, update: "updateView"}, function(payload, ecModel) {
    ecModel.eachComponent({mainType: "series", subType: "sunburst", query: payload}, handleRootToNode);
    function handleRootToNode(model, index) {
      const targetInfo = retrieveTargetInfo(payload, [ROOT_TO_NODE_ACTION], model);
      if (targetInfo) {
        const originViewRoot = model.getViewRoot();
        if (originViewRoot) {
          payload.direction = aboveViewRoot(originViewRoot, targetInfo.node) ? "rollUp" : "drillDown";
        }
        model.resetViewRoot(targetInfo.node);
      }
    }
  });
  registers.registerAction({type: HIGHLIGHT_ACTION, update: "none"}, function(payload, ecModel, api2) {
    payload = extend({}, payload);
    ecModel.eachComponent({mainType: "series", subType: "sunburst", query: payload}, handleHighlight);
    function handleHighlight(model) {
      const targetInfo = retrieveTargetInfo(payload, [HIGHLIGHT_ACTION], model);
      if (targetInfo) {
        payload.dataIndex = targetInfo.node.dataIndex;
      }
    }
    if (true) {
      deprecateReplaceLog("sunburstHighlight", "highlight");
    }
    api2.dispatchAction(extend(payload, {
      type: "highlight"
    }));
  });
  registers.registerAction({type: UNHIGHLIGHT_ACTION, update: "updateView"}, function(payload, ecModel, api2) {
    payload = extend({}, payload);
    if (true) {
      deprecateReplaceLog("sunburstUnhighlight", "downplay");
    }
    api2.dispatchAction(extend(payload, {
      type: "downplay"
    }));
  });
}

// src/chart/sunburst/SunburstView.ts
var SunburstView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = SunburstView2.type;
  }
  render(seriesModel, ecModel, api2, payload) {
    const self2 = this;
    this.seriesModel = seriesModel;
    this.api = api2;
    this.ecModel = ecModel;
    const data = seriesModel.getData();
    const virtualRoot = data.tree.root;
    const newRoot = seriesModel.getViewRoot();
    const group = this.group;
    const renderLabelForZeroData = seriesModel.get("renderLabelForZeroData");
    const newChildren = [];
    newRoot.eachNode(function(node) {
      newChildren.push(node);
    });
    const oldChildren = this._oldChildren || [];
    dualTravel(newChildren, oldChildren);
    renderRollUp(virtualRoot, newRoot);
    this._initEvents();
    this._oldChildren = newChildren;
    function dualTravel(newChildren2, oldChildren2) {
      if (newChildren2.length === 0 && oldChildren2.length === 0) {
        return;
      }
      new DataDiffer_default(oldChildren2, newChildren2, getKey2, getKey2).add(processNode).update(processNode).remove(curry(processNode, null)).execute();
      function getKey2(node) {
        return node.getId();
      }
      function processNode(newIdx, oldIdx) {
        const newNode = newIdx == null ? null : newChildren2[newIdx];
        const oldNode = oldIdx == null ? null : oldChildren2[oldIdx];
        doRenderNode(newNode, oldNode);
      }
    }
    function doRenderNode(newNode, oldNode) {
      if (!renderLabelForZeroData && newNode && !newNode.getValue()) {
        newNode = null;
      }
      if (newNode !== virtualRoot && oldNode !== virtualRoot) {
        if (oldNode && oldNode.piece) {
          if (newNode) {
            oldNode.piece.updateData(false, newNode, seriesModel, ecModel, api2);
            data.setItemGraphicEl(newNode.dataIndex, oldNode.piece);
          } else {
            removeNode2(oldNode);
          }
        } else if (newNode) {
          const piece = new SunburstPiece_default(newNode, seriesModel, ecModel, api2);
          group.add(piece);
          data.setItemGraphicEl(newNode.dataIndex, piece);
        }
      }
    }
    function removeNode2(node) {
      if (!node) {
        return;
      }
      if (node.piece) {
        group.remove(node.piece);
        node.piece = null;
      }
    }
    function renderRollUp(virtualRoot2, viewRoot) {
      if (viewRoot.depth > 0) {
        if (self2.virtualPiece) {
          self2.virtualPiece.updateData(false, virtualRoot2, seriesModel, ecModel, api2);
        } else {
          self2.virtualPiece = new SunburstPiece_default(virtualRoot2, seriesModel, ecModel, api2);
          group.add(self2.virtualPiece);
        }
        viewRoot.piece.off("click");
        self2.virtualPiece.on("click", function(e2) {
          self2._rootToNode(viewRoot.parentNode);
        });
      } else if (self2.virtualPiece) {
        group.remove(self2.virtualPiece);
        self2.virtualPiece = null;
      }
    }
  }
  _initEvents() {
    this.group.off("click");
    this.group.on("click", (e2) => {
      let targetFound = false;
      const viewRoot = this.seriesModel.getViewRoot();
      viewRoot.eachNode((node) => {
        if (!targetFound && node.piece && node.piece === e2.target) {
          const nodeClick = node.getModel().get("nodeClick");
          if (nodeClick === "rootToNode") {
            this._rootToNode(node);
          } else if (nodeClick === "link") {
            const itemModel = node.getModel();
            const link = itemModel.get("link");
            if (link) {
              const linkTarget = itemModel.get("target", true) || "_blank";
              windowOpen(link, linkTarget);
            }
          }
          targetFound = true;
        }
      });
    });
  }
  _rootToNode(node) {
    if (node !== this.seriesModel.getViewRoot()) {
      this.api.dispatchAction({
        type: ROOT_TO_NODE_ACTION,
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: node
      });
    }
  }
  containPoint(point, seriesModel) {
    const treeRoot = seriesModel.getData();
    const itemLayout = treeRoot.getItemLayout(0);
    if (itemLayout) {
      const dx = point[0] - itemLayout.cx;
      const dy = point[1] - itemLayout.cy;
      const radius = Math.sqrt(dx * dx + dy * dy);
      return radius <= itemLayout.r && radius >= itemLayout.r0;
    }
  }
};
var SunburstView = SunburstView2;
SunburstView.type = "sunburst";
var SunburstView_default = SunburstView;

// src/chart/sunburst/SunburstSeries.ts
var SunburstSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = SunburstSeriesModel2.type;
    this.ignoreStyleOnData = true;
  }
  getInitialData(option, ecModel) {
    const root = {name: option.name, children: option.data};
    completeTreeValue2(root);
    const levelModels = this._levelModels = map(option.levels || [], function(levelDefine) {
      return new Model_default(levelDefine, this, ecModel);
    }, this);
    const tree = Tree_default.createTree(root, this, beforeLink);
    function beforeLink(nodeData) {
      nodeData.wrapMethod("getItemModel", function(model, idx) {
        const node = tree.getNodeByDataIndex(idx);
        const levelModel = levelModels[node.depth];
        levelModel && (model.parentModel = levelModel);
        return model;
      });
    }
    return tree.data;
  }
  optionUpdated() {
    this.resetViewRoot();
  }
  getDataParams(dataIndex) {
    const params = super.getDataParams.apply(this, arguments);
    const node = this.getData().tree.getNodeByDataIndex(dataIndex);
    params.treePathInfo = wrapTreePathInfo(node, this);
    return params;
  }
  getLevelModel(node) {
    return this._levelModels && this._levelModels[node.depth];
  }
  getViewRoot() {
    return this._viewRoot;
  }
  resetViewRoot(viewRoot) {
    viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
    const root = this.getRawData().tree.root;
    if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {
      this._viewRoot = root;
    }
  }
  enableAriaDecal() {
    enableAriaDecalForTree(this);
  }
};
var SunburstSeriesModel = SunburstSeriesModel2;
SunburstSeriesModel.type = "series.sunburst";
SunburstSeriesModel.defaultOption = {
  z: 2,
  center: ["50%", "50%"],
  radius: [0, "75%"],
  clockwise: true,
  startAngle: 90,
  minAngle: 0,
  stillShowZeroSum: true,
  nodeClick: "rootToNode",
  renderLabelForZeroData: false,
  label: {
    rotate: "radial",
    show: true,
    opacity: 1,
    align: "center",
    position: "inside",
    distance: 5,
    silent: true
  },
  itemStyle: {
    borderWidth: 1,
    borderColor: "white",
    borderType: "solid",
    shadowBlur: 0,
    shadowColor: "rgba(0, 0, 0, 0.2)",
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    opacity: 1
  },
  emphasis: {
    focus: "descendant"
  },
  blur: {
    itemStyle: {
      opacity: 0.2
    },
    label: {
      opacity: 0.1
    }
  },
  animationType: "expansion",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  data: [],
  sort: "desc"
};
function completeTreeValue2(dataNode) {
  let sum2 = 0;
  each(dataNode.children, function(child) {
    completeTreeValue2(child);
    let childValue = child.value;
    isArray(childValue) && (childValue = childValue[0]);
    sum2 += childValue;
  });
  let thisValue = dataNode.value;
  if (isArray(thisValue)) {
    thisValue = thisValue[0];
  }
  if (thisValue == null || isNaN(thisValue)) {
    thisValue = sum2;
  }
  if (thisValue < 0) {
    thisValue = 0;
  }
  isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
}
var SunburstSeries_default = SunburstSeriesModel;

// src/chart/sunburst/sunburstLayout.ts
var RADIAN5 = Math.PI / 180;
function sunburstLayout(seriesType2, ecModel, api2) {
  ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
    let center3 = seriesModel.get("center");
    let radius = seriesModel.get("radius");
    if (!isArray(radius)) {
      radius = [0, radius];
    }
    if (!isArray(center3)) {
      center3 = [center3, center3];
    }
    const width = api2.getWidth();
    const height = api2.getHeight();
    const size = Math.min(width, height);
    const cx = parsePercent2(center3[0], width);
    const cy = parsePercent2(center3[1], height);
    const r0 = parsePercent2(radius[0], size / 2);
    const r = parsePercent2(radius[1], size / 2);
    const startAngle = -seriesModel.get("startAngle") * RADIAN5;
    const minAngle = seriesModel.get("minAngle") * RADIAN5;
    const virtualRoot = seriesModel.getData().tree.root;
    const treeRoot = seriesModel.getViewRoot();
    const rootDepth = treeRoot.depth;
    const sort4 = seriesModel.get("sort");
    if (sort4 != null) {
      initChildren2(treeRoot, sort4);
    }
    let validDataCount = 0;
    each(treeRoot.children, function(child) {
      !isNaN(child.getValue()) && validDataCount++;
    });
    const sum2 = treeRoot.getValue();
    const unitRadian = Math.PI / (sum2 || validDataCount) * 2;
    const renderRollupNode = treeRoot.depth > 0;
    const levels = treeRoot.height - (renderRollupNode ? -1 : 1);
    const rPerLevel = (r - r0) / (levels || 1);
    const clockwise = seriesModel.get("clockwise");
    const stillShowZeroSum = seriesModel.get("stillShowZeroSum");
    const dir3 = clockwise ? 1 : -1;
    const renderNode2 = function(node, startAngle2) {
      if (!node) {
        return;
      }
      let endAngle = startAngle2;
      if (node !== virtualRoot) {
        const value = node.getValue();
        let angle = sum2 === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
        if (angle < minAngle) {
          angle = minAngle;
        }
        endAngle = startAngle2 + dir3 * angle;
        const depth = node.depth - rootDepth - (renderRollupNode ? -1 : 1);
        let rStart = r0 + rPerLevel * depth;
        let rEnd = r0 + rPerLevel * (depth + 1);
        const levelModel = seriesModel.getLevelModel(node);
        if (levelModel) {
          let r02 = levelModel.get("r0", true);
          let r2 = levelModel.get("r", true);
          const radius2 = levelModel.get("radius", true);
          if (radius2 != null) {
            r02 = radius2[0];
            r2 = radius2[1];
          }
          r02 != null && (rStart = parsePercent2(r02, size / 2));
          r2 != null && (rEnd = parsePercent2(r2, size / 2));
        }
        node.setLayout({
          angle,
          startAngle: startAngle2,
          endAngle,
          clockwise,
          cx,
          cy,
          r0: rStart,
          r: rEnd
        });
      }
      if (node.children && node.children.length) {
        let siblingAngle = 0;
        each(node.children, function(node2) {
          siblingAngle += renderNode2(node2, startAngle2 + siblingAngle);
        });
      }
      return endAngle - startAngle2;
    };
    if (renderRollupNode) {
      const rStart = r0;
      const rEnd = r0 + rPerLevel;
      const angle = Math.PI * 2;
      virtualRoot.setLayout({
        angle,
        startAngle,
        endAngle: startAngle + angle,
        clockwise,
        cx,
        cy,
        r0: rStart,
        r: rEnd
      });
    }
    renderNode2(treeRoot, startAngle);
  });
}
function initChildren2(node, sortOrder) {
  const children = node.children || [];
  node.children = sort3(children, sortOrder);
  if (children.length) {
    each(node.children, function(child) {
      initChildren2(child, sortOrder);
    });
  }
}
function sort3(children, sortOrder) {
  if (isFunction(sortOrder)) {
    const sortTargets = map(children, (child, idx) => {
      const value = child.getValue();
      return {
        params: {
          depth: child.depth,
          height: child.height,
          dataIndex: child.dataIndex,
          getValue: () => value
        },
        index: idx
      };
    });
    sortTargets.sort((a, b) => {
      return sortOrder(a.params, b.params);
    });
    return map(sortTargets, (target) => {
      return children[target.index];
    });
  } else {
    const isAsc = sortOrder === "asc";
    return children.sort(function(a, b) {
      const diff = (a.getValue() - b.getValue()) * (isAsc ? 1 : -1);
      return diff === 0 ? (a.dataIndex - b.dataIndex) * (isAsc ? -1 : 1) : diff;
    });
  }
}

// src/chart/sunburst/sunburstVisual.ts
function sunburstVisual(ecModel) {
  const paletteScope = {};
  function pickColor(node, seriesModel, treeHeight) {
    if (node.depth === 0) {
      return tokens_default.color.neutral50;
    }
    let current = node;
    while (current && current.depth > 1) {
      current = current.parentNode;
    }
    let color4 = seriesModel.getColorFromPalette(current.name || current.dataIndex + "", paletteScope);
    if (node.depth > 1 && isString(color4)) {
      color4 = lift(color4, (node.depth - 1) / (treeHeight - 1) * 0.5);
    }
    return color4;
  }
  ecModel.eachSeriesByType("sunburst", function(seriesModel) {
    const data = seriesModel.getData();
    const tree = data.tree;
    tree.eachNode(function(node) {
      const model = node.getModel();
      const style = model.getModel("itemStyle").getItemStyle();
      if (!style.fill) {
        style.fill = pickColor(node, seriesModel, tree.root.height);
      }
      const existsStyle = data.ensureUniqueItemVisual(node.dataIndex, "style");
      extend(existsStyle, style);
    });
  });
}

// src/chart/sunburst/install.ts
function install28(registers) {
  registers.registerChartView(SunburstView_default);
  registers.registerSeriesModel(SunburstSeries_default);
  registers.registerLayout(curry(sunburstLayout, "sunburst"));
  registers.registerProcessor(curry(dataFilter, "sunburst"));
  registers.registerVisual(sunburstVisual);
  installSunburstAction(registers);
}

// src/chart/custom/CustomSeries.ts
var STYLE_VISUAL_TYPE = {
  color: "fill",
  borderColor: "stroke"
};
var NON_STYLE_VISUAL_PROPS = {
  symbol: 1,
  symbolSize: 1,
  symbolKeepAspect: 1,
  legendIcon: 1,
  visualMeta: 1,
  liftZ: 1,
  decal: 1
};
var customInnerStore = makeInner();
var CustomSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = CustomSeriesModel2.type;
  }
  optionUpdated() {
    this.currentZLevel = this.get("zlevel", true);
    this.currentZ = this.get("z", true);
  }
  getInitialData(option, ecModel) {
    return createSeriesData_default(null, this);
  }
  getDataParams(dataIndex, dataType, el) {
    const params = super.getDataParams(dataIndex, dataType);
    el && (params.info = customInnerStore(el).info);
    return params;
  }
};
var CustomSeriesModel = CustomSeriesModel2;
CustomSeriesModel.type = "series.custom";
CustomSeriesModel.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar", "matrix"];
CustomSeriesModel.defaultOption = {
  coordinateSystem: "cartesian2d",
  z: 2,
  legendHoverLink: true,
  clip: false
};
var CustomSeries_default = CustomSeriesModel;

// src/coord/cartesian/prepareCustom.ts
function dataToCoordSize(dataSize, dataItem) {
  dataItem = dataItem || [0, 0];
  return map(["x", "y"], function(dim, dimIdx) {
    const axis = this.getAxis(dim);
    const val = dataItem[dimIdx];
    const halfSize = dataSize[dimIdx] / 2;
    return axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
  }, this);
}
function cartesianPrepareCustom(coordSys) {
  const rect = coordSys.master.getRect();
  return {
    coordSys: {
      type: "cartesian2d",
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    api: {
      coord: function(data) {
        return coordSys.dataToPoint(data);
      },
      size: bind(dataToCoordSize, coordSys)
    }
  };
}

// src/coord/geo/prepareCustom.ts
function dataToCoordSize2(dataSize, dataItem) {
  dataItem = dataItem || [0, 0];
  return map([0, 1], function(dimIdx) {
    const val = dataItem[dimIdx];
    const halfSize = dataSize[dimIdx] / 2;
    const p1 = [];
    const p2 = [];
    p1[dimIdx] = val - halfSize;
    p2[dimIdx] = val + halfSize;
    p1[1 - dimIdx] = p2[1 - dimIdx] = dataItem[1 - dimIdx];
    return Math.abs(this.dataToPoint(p1)[dimIdx] - this.dataToPoint(p2)[dimIdx]);
  }, this);
}
function geoPrepareCustom(coordSys) {
  const rect = coordSys.getBoundingRect();
  return {
    coordSys: {
      type: "geo",
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height,
      zoom: coordSys.getZoom()
    },
    api: {
      coord: function(data) {
        return coordSys.dataToPoint(data);
      },
      size: bind(dataToCoordSize2, coordSys)
    }
  };
}

// src/coord/single/prepareCustom.ts
function dataToCoordSize3(dataSize, dataItem) {
  const axis = this.getAxis();
  const val = dataItem instanceof Array ? dataItem[0] : dataItem;
  const halfSize = (dataSize instanceof Array ? dataSize[0] : dataSize) / 2;
  return axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
}
function singlePrepareCustom(coordSys) {
  const rect = coordSys.getRect();
  return {
    coordSys: {
      type: "singleAxis",
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    api: {
      coord: function(val) {
        return coordSys.dataToPoint(val);
      },
      size: bind(dataToCoordSize3, coordSys)
    }
  };
}

// src/coord/polar/prepareCustom.ts
function dataToCoordSize4(dataSize, dataItem) {
  dataItem = dataItem || [0, 0];
  return map(["Radius", "Angle"], function(dim, dimIdx) {
    const getterName = "get" + dim + "Axis";
    const axis = this[getterName]();
    const val = dataItem[dimIdx];
    const halfSize = dataSize[dimIdx] / 2;
    let result = axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
    if (dim === "Angle") {
      result = result * Math.PI / 180;
    }
    return result;
  }, this);
}
function polarPrepareCustom(coordSys) {
  const radiusAxis = coordSys.getRadiusAxis();
  const angleAxis = coordSys.getAngleAxis();
  const radius = radiusAxis.getExtent();
  radius[0] > radius[1] && radius.reverse();
  return {
    coordSys: {
      type: "polar",
      cx: coordSys.cx,
      cy: coordSys.cy,
      r: radius[1],
      r0: radius[0]
    },
    api: {
      coord: function(data) {
        const radius2 = radiusAxis.dataToRadius(data[0]);
        const angle = angleAxis.dataToAngle(data[1]);
        const coord = coordSys.coordToPoint([radius2, angle]);
        coord.push(radius2, angle * Math.PI / 180);
        return coord;
      },
      size: bind(dataToCoordSize4, coordSys)
    }
  };
}

// src/coord/calendar/prepareCustom.ts
function calendarPrepareCustom(coordSys) {
  const rect = coordSys.getRect();
  const rangeInfo = coordSys.getRangeInfo();
  return {
    coordSys: {
      type: "calendar",
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height,
      cellWidth: coordSys.getCellWidth(),
      cellHeight: coordSys.getCellHeight(),
      rangeInfo: {
        start: rangeInfo.start,
        end: rangeInfo.end,
        weeks: rangeInfo.weeks,
        dayCount: rangeInfo.allDay
      }
    },
    api: {
      coord: function(data, clamp2) {
        return coordSys.dataToPoint(data, clamp2);
      },
      layout: function(data, clamp2) {
        return coordSys.dataToLayout(data, clamp2);
      }
    }
  };
}

// src/coord/matrix/prepareCustom.ts
function matrixPrepareCustom(coordSys) {
  const rect = coordSys.getRect();
  return {
    coordSys: {
      type: "matrix",
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    api: {
      coord: function(data, opt) {
        return coordSys.dataToPoint(data, opt);
      },
      layout: function(data, opt) {
        return coordSys.dataToLayout(data, opt);
      }
    }
  };
}

// src/util/styleCompat.ts
var deprecatedLogs = {};
function isEC4CompatibleStyle(style, elType, hasOwnTextContentOption, hasOwnTextConfig) {
  return style && (style.legacy || style.legacy !== false && !hasOwnTextContentOption && !hasOwnTextConfig && elType !== "tspan" && (elType === "text" || hasOwn(style, "text")));
}
function convertFromEC4CompatibleStyle(hostStyle, elType, isNormal) {
  const srcStyle = hostStyle;
  let textConfig;
  let textContent;
  let textContentStyle;
  if (elType === "text") {
    textContentStyle = srcStyle;
  } else {
    textContentStyle = {};
    hasOwn(srcStyle, "text") && (textContentStyle.text = srcStyle.text);
    hasOwn(srcStyle, "rich") && (textContentStyle.rich = srcStyle.rich);
    hasOwn(srcStyle, "textFill") && (textContentStyle.fill = srcStyle.textFill);
    hasOwn(srcStyle, "textStroke") && (textContentStyle.stroke = srcStyle.textStroke);
    hasOwn(srcStyle, "fontFamily") && (textContentStyle.fontFamily = srcStyle.fontFamily);
    hasOwn(srcStyle, "fontSize") && (textContentStyle.fontSize = srcStyle.fontSize);
    hasOwn(srcStyle, "fontStyle") && (textContentStyle.fontStyle = srcStyle.fontStyle);
    hasOwn(srcStyle, "fontWeight") && (textContentStyle.fontWeight = srcStyle.fontWeight);
    textContent = {
      type: "text",
      style: textContentStyle,
      silent: true
    };
    textConfig = {};
    const hasOwnPos = hasOwn(srcStyle, "textPosition");
    if (isNormal) {
      textConfig.position = hasOwnPos ? srcStyle.textPosition : "inside";
    } else {
      hasOwnPos && (textConfig.position = srcStyle.textPosition);
    }
    hasOwn(srcStyle, "textPosition") && (textConfig.position = srcStyle.textPosition);
    hasOwn(srcStyle, "textOffset") && (textConfig.offset = srcStyle.textOffset);
    hasOwn(srcStyle, "textRotation") && (textConfig.rotation = srcStyle.textRotation);
    hasOwn(srcStyle, "textDistance") && (textConfig.distance = srcStyle.textDistance);
  }
  convertEC4CompatibleRichItem(textContentStyle, hostStyle);
  each(textContentStyle.rich, function(richItem) {
    convertEC4CompatibleRichItem(richItem, richItem);
  });
  return {
    textConfig,
    textContent
  };
}
function convertEC4CompatibleRichItem(out2, richItem) {
  if (!richItem) {
    return;
  }
  richItem.font = richItem.textFont || richItem.font;
  hasOwn(richItem, "textStrokeWidth") && (out2.lineWidth = richItem.textStrokeWidth);
  hasOwn(richItem, "textAlign") && (out2.align = richItem.textAlign);
  hasOwn(richItem, "textVerticalAlign") && (out2.verticalAlign = richItem.textVerticalAlign);
  hasOwn(richItem, "textLineHeight") && (out2.lineHeight = richItem.textLineHeight);
  hasOwn(richItem, "textWidth") && (out2.width = richItem.textWidth);
  hasOwn(richItem, "textHeight") && (out2.height = richItem.textHeight);
  hasOwn(richItem, "textBackgroundColor") && (out2.backgroundColor = richItem.textBackgroundColor);
  hasOwn(richItem, "textPadding") && (out2.padding = richItem.textPadding);
  hasOwn(richItem, "textBorderColor") && (out2.borderColor = richItem.textBorderColor);
  hasOwn(richItem, "textBorderWidth") && (out2.borderWidth = richItem.textBorderWidth);
  hasOwn(richItem, "textBorderRadius") && (out2.borderRadius = richItem.textBorderRadius);
  hasOwn(richItem, "textBoxShadowColor") && (out2.shadowColor = richItem.textBoxShadowColor);
  hasOwn(richItem, "textBoxShadowBlur") && (out2.shadowBlur = richItem.textBoxShadowBlur);
  hasOwn(richItem, "textBoxShadowOffsetX") && (out2.shadowOffsetX = richItem.textBoxShadowOffsetX);
  hasOwn(richItem, "textBoxShadowOffsetY") && (out2.shadowOffsetY = richItem.textBoxShadowOffsetY);
}
function convertToEC4StyleForCustomSerise(itemStl, txStl, txCfg) {
  const out2 = itemStl;
  out2.textPosition = out2.textPosition || txCfg.position || "inside";
  txCfg.offset != null && (out2.textOffset = txCfg.offset);
  txCfg.rotation != null && (out2.textRotation = txCfg.rotation);
  txCfg.distance != null && (out2.textDistance = txCfg.distance);
  const isInside = out2.textPosition.indexOf("inside") >= 0;
  const hostFill = itemStl.fill || tokens_default.color.neutral99;
  convertToEC4RichItem(out2, txStl);
  const textFillNotSet = out2.textFill == null;
  if (isInside) {
    if (textFillNotSet) {
      out2.textFill = txCfg.insideFill || tokens_default.color.neutral00;
      !out2.textStroke && txCfg.insideStroke && (out2.textStroke = txCfg.insideStroke);
      !out2.textStroke && (out2.textStroke = hostFill);
      out2.textStrokeWidth == null && (out2.textStrokeWidth = 2);
    }
  } else {
    if (textFillNotSet) {
      out2.textFill = itemStl.fill || txCfg.outsideFill || tokens_default.color.neutral00;
    }
    !out2.textStroke && txCfg.outsideStroke && (out2.textStroke = txCfg.outsideStroke);
  }
  out2.text = txStl.text;
  out2.rich = txStl.rich;
  each(txStl.rich, function(richItem) {
    convertToEC4RichItem(richItem, richItem);
  });
  return out2;
}
function convertToEC4RichItem(out2, richItem) {
  if (!richItem) {
    return;
  }
  hasOwn(richItem, "fill") && (out2.textFill = richItem.fill);
  hasOwn(richItem, "stroke") && (out2.textStroke = richItem.fill);
  hasOwn(richItem, "lineWidth") && (out2.textStrokeWidth = richItem.lineWidth);
  hasOwn(richItem, "font") && (out2.font = richItem.font);
  hasOwn(richItem, "fontStyle") && (out2.fontStyle = richItem.fontStyle);
  hasOwn(richItem, "fontWeight") && (out2.fontWeight = richItem.fontWeight);
  hasOwn(richItem, "fontSize") && (out2.fontSize = richItem.fontSize);
  hasOwn(richItem, "fontFamily") && (out2.fontFamily = richItem.fontFamily);
  hasOwn(richItem, "align") && (out2.textAlign = richItem.align);
  hasOwn(richItem, "verticalAlign") && (out2.textVerticalAlign = richItem.verticalAlign);
  hasOwn(richItem, "lineHeight") && (out2.textLineHeight = richItem.lineHeight);
  hasOwn(richItem, "width") && (out2.textWidth = richItem.width);
  hasOwn(richItem, "height") && (out2.textHeight = richItem.height);
  hasOwn(richItem, "backgroundColor") && (out2.textBackgroundColor = richItem.backgroundColor);
  hasOwn(richItem, "padding") && (out2.textPadding = richItem.padding);
  hasOwn(richItem, "borderColor") && (out2.textBorderColor = richItem.borderColor);
  hasOwn(richItem, "borderWidth") && (out2.textBorderWidth = richItem.borderWidth);
  hasOwn(richItem, "borderRadius") && (out2.textBorderRadius = richItem.borderRadius);
  hasOwn(richItem, "shadowColor") && (out2.textBoxShadowColor = richItem.shadowColor);
  hasOwn(richItem, "shadowBlur") && (out2.textBoxShadowBlur = richItem.shadowBlur);
  hasOwn(richItem, "shadowOffsetX") && (out2.textBoxShadowOffsetX = richItem.shadowOffsetX);
  hasOwn(richItem, "shadowOffsetY") && (out2.textBoxShadowOffsetY = richItem.shadowOffsetY);
  hasOwn(richItem, "textShadowColor") && (out2.textShadowColor = richItem.textShadowColor);
  hasOwn(richItem, "textShadowBlur") && (out2.textShadowBlur = richItem.textShadowBlur);
  hasOwn(richItem, "textShadowOffsetX") && (out2.textShadowOffsetX = richItem.textShadowOffsetX);
  hasOwn(richItem, "textShadowOffsetY") && (out2.textShadowOffsetY = richItem.textShadowOffsetY);
}
function warnDeprecated(deprecated, insteadApproach) {
  if (true) {
    const key = deprecated + "^_^" + insteadApproach;
    if (!deprecatedLogs[key]) {
      console.warn(`[ECharts] DEPRECATED: "${deprecated}" has been deprecated. ${insteadApproach}`);
      deprecatedLogs[key] = true;
    }
  }
}

// src/animation/customGraphicTransition.ts
var LEGACY_TRANSFORM_PROPS_MAP = {
  position: ["x", "y"],
  scale: ["scaleX", "scaleY"],
  origin: ["originX", "originY"]
};
var LEGACY_TRANSFORM_PROPS = keys(LEGACY_TRANSFORM_PROPS_MAP);
var TRANSFORM_PROPS_MAP = reduce(TRANSFORMABLE_PROPS, (obj, key) => {
  obj[key] = 1;
  return obj;
}, {});
var transformPropNamesStr = TRANSFORMABLE_PROPS.join(", ");
var ELEMENT_ANIMATABLE_PROPS = ["", "style", "shape", "extra"];
var transitionInnerStore = makeInner();
function getElementAnimationConfig(animationType, el, elOption, parentModel, dataIndex) {
  const animationProp = `${animationType}Animation`;
  const config = getAnimationConfig(animationType, parentModel, dataIndex) || {};
  const userDuring = transitionInnerStore(el).userDuring;
  if (config.duration > 0) {
    config.during = userDuring ? bind(duringCall, {el, userDuring}) : null;
    config.setToFinal = true;
    config.scope = animationType;
  }
  extend(config, elOption[animationProp]);
  return config;
}
function applyUpdateTransition(el, elOption, animatableModel, opts) {
  opts = opts || {};
  const {dataIndex, isInit, clearStyle} = opts;
  const hasAnimation = animatableModel.isAnimationEnabled();
  const store = transitionInnerStore(el);
  const styleOpt = elOption.style;
  store.userDuring = elOption.during;
  const transFromProps = {};
  const propsToSet = {};
  prepareTransformAllPropsFinal(el, elOption, propsToSet);
  if (el.type === "compound") {
    const paths = el.shape.paths;
    const optionPaths = elOption.shape.paths;
    for (let i = 0; i < optionPaths.length; i++) {
      const path = optionPaths[i];
      prepareShapeOrExtraAllPropsFinal("shape", path, paths[i]);
    }
  } else {
    prepareShapeOrExtraAllPropsFinal("shape", elOption, propsToSet);
    prepareShapeOrExtraAllPropsFinal("extra", elOption, propsToSet);
  }
  if (!isInit && hasAnimation) {
    prepareTransformTransitionFrom(el, elOption, transFromProps);
    prepareShapeOrExtraTransitionFrom("shape", el, elOption, transFromProps);
    prepareShapeOrExtraTransitionFrom("extra", el, elOption, transFromProps);
    prepareStyleTransitionFrom(el, elOption, styleOpt, transFromProps);
  }
  propsToSet.style = styleOpt;
  applyPropsDirectly(el, propsToSet, clearStyle);
  applyMiscProps(el, elOption);
  if (hasAnimation) {
    if (isInit) {
      const enterFromProps = {};
      each(ELEMENT_ANIMATABLE_PROPS, (propName) => {
        const prop = propName ? elOption[propName] : elOption;
        if (prop && prop.enterFrom) {
          if (propName) {
            enterFromProps[propName] = enterFromProps[propName] || {};
          }
          extend(propName ? enterFromProps[propName] : enterFromProps, prop.enterFrom);
        }
      });
      const config = getElementAnimationConfig("enter", el, elOption, animatableModel, dataIndex);
      if (config.duration > 0) {
        el.animateFrom(enterFromProps, config);
      }
    } else {
      applyPropsTransition(el, elOption, dataIndex || 0, animatableModel, transFromProps);
    }
  }
  updateLeaveTo(el, elOption);
  styleOpt ? el.dirty() : el.markRedraw();
}
function updateLeaveTo(el, elOption) {
  let leaveToProps = transitionInnerStore(el).leaveToProps;
  for (let i = 0; i < ELEMENT_ANIMATABLE_PROPS.length; i++) {
    const propName = ELEMENT_ANIMATABLE_PROPS[i];
    const prop = propName ? elOption[propName] : elOption;
    if (prop && prop.leaveTo) {
      if (!leaveToProps) {
        leaveToProps = transitionInnerStore(el).leaveToProps = {};
      }
      if (propName) {
        leaveToProps[propName] = leaveToProps[propName] || {};
      }
      extend(propName ? leaveToProps[propName] : leaveToProps, prop.leaveTo);
    }
  }
}
function applyLeaveTransition(el, elOption, animatableModel, onRemove) {
  if (el) {
    const parent = el.parent;
    const leaveToProps = transitionInnerStore(el).leaveToProps;
    if (leaveToProps) {
      const config = getElementAnimationConfig("update", el, elOption, animatableModel, 0);
      config.done = () => {
        parent && parent.remove(el);
        onRemove && onRemove();
      };
      el.animateTo(leaveToProps, config);
    } else {
      parent && parent.remove(el);
      onRemove && onRemove();
    }
  }
}
function isTransitionAll(transition) {
  return transition === "all";
}
function applyPropsDirectly(el, allPropsFinal, clearStyle) {
  const styleOpt = allPropsFinal.style;
  if (!el.isGroup && styleOpt) {
    if (clearStyle) {
      el.useStyle({});
      const animators = el.animators;
      for (let i = 0; i < animators.length; i++) {
        const animator = animators[i];
        if (animator.targetName === "style") {
          animator.changeTarget(el.style);
        }
      }
    }
    el.setStyle(styleOpt);
  }
  if (allPropsFinal) {
    allPropsFinal.style = null;
    allPropsFinal && el.attr(allPropsFinal);
    allPropsFinal.style = styleOpt;
  }
}
function applyPropsTransition(el, elOption, dataIndex, model, transFromProps) {
  if (transFromProps) {
    const config = getElementAnimationConfig("update", el, elOption, model, dataIndex);
    if (config.duration > 0) {
      el.animateFrom(transFromProps, config);
    }
  }
}
function applyMiscProps(el, elOption) {
  hasOwn(elOption, "silent") && (el.silent = elOption.silent);
  hasOwn(elOption, "ignore") && (el.ignore = elOption.ignore);
  if (el instanceof Displayable_default) {
    hasOwn(elOption, "invisible") && (el.invisible = elOption.invisible);
  }
  if (el instanceof Path_default) {
    hasOwn(elOption, "autoBatch") && (el.autoBatch = elOption.autoBatch);
  }
}
var tmpDuringScope = {};
var transitionDuringAPI = {
  setTransform(key, val) {
    if (true) {
      assert(hasOwn(TRANSFORM_PROPS_MAP, key), "Only " + transformPropNamesStr + " available in `setTransform`.");
    }
    tmpDuringScope.el[key] = val;
    return this;
  },
  getTransform(key) {
    if (true) {
      assert(hasOwn(TRANSFORM_PROPS_MAP, key), "Only " + transformPropNamesStr + " available in `getTransform`.");
    }
    return tmpDuringScope.el[key];
  },
  setShape(key, val) {
    if (true) {
      assertNotReserved(key);
    }
    const el = tmpDuringScope.el;
    const shape = el.shape || (el.shape = {});
    shape[key] = val;
    el.dirtyShape && el.dirtyShape();
    return this;
  },
  getShape(key) {
    if (true) {
      assertNotReserved(key);
    }
    const shape = tmpDuringScope.el.shape;
    if (shape) {
      return shape[key];
    }
  },
  setStyle(key, val) {
    if (true) {
      assertNotReserved(key);
    }
    const el = tmpDuringScope.el;
    const style = el.style;
    if (style) {
      if (true) {
        if (eqNaN(val)) {
          warn("style." + key + " must not be assigned with NaN.");
        }
      }
      style[key] = val;
      el.dirtyStyle && el.dirtyStyle();
    }
    return this;
  },
  getStyle(key) {
    if (true) {
      assertNotReserved(key);
    }
    const style = tmpDuringScope.el.style;
    if (style) {
      return style[key];
    }
  },
  setExtra(key, val) {
    if (true) {
      assertNotReserved(key);
    }
    const extra = tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {});
    extra[key] = val;
    return this;
  },
  getExtra(key) {
    if (true) {
      assertNotReserved(key);
    }
    const extra = tmpDuringScope.el.extra;
    if (extra) {
      return extra[key];
    }
  }
};
function assertNotReserved(key) {
  if (true) {
    if (key === "transition" || key === "enterFrom" || key === "leaveTo") {
      throw new Error('key must not be "' + key + '"');
    }
  }
}
function duringCall() {
  const scope = this;
  const el = scope.el;
  if (!el) {
    return;
  }
  const latestUserDuring = transitionInnerStore(el).userDuring;
  const scopeUserDuring = scope.userDuring;
  if (latestUserDuring !== scopeUserDuring) {
    scope.el = scope.userDuring = null;
    return;
  }
  tmpDuringScope.el = el;
  scopeUserDuring(transitionDuringAPI);
}
function prepareShapeOrExtraTransitionFrom(mainAttr, fromEl, elOption, transFromProps) {
  const attrOpt = elOption[mainAttr];
  if (!attrOpt) {
    return;
  }
  const elPropsInAttr = fromEl[mainAttr];
  let transFromPropsInAttr;
  if (elPropsInAttr) {
    const transition = elOption.transition;
    const attrTransition = attrOpt.transition;
    if (attrTransition) {
      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});
      if (isTransitionAll(attrTransition)) {
        extend(transFromPropsInAttr, elPropsInAttr);
      } else {
        const transitionKeys = normalizeToArray(attrTransition);
        for (let i = 0; i < transitionKeys.length; i++) {
          const key = transitionKeys[i];
          const elVal = elPropsInAttr[key];
          transFromPropsInAttr[key] = elVal;
        }
      }
    } else if (isTransitionAll(transition) || indexOf(transition, mainAttr) >= 0) {
      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});
      const elPropsInAttrKeys = keys(elPropsInAttr);
      for (let i = 0; i < elPropsInAttrKeys.length; i++) {
        const key = elPropsInAttrKeys[i];
        const elVal = elPropsInAttr[key];
        if (isNonStyleTransitionEnabled(attrOpt[key], elVal)) {
          transFromPropsInAttr[key] = elVal;
        }
      }
    }
  }
}
function prepareShapeOrExtraAllPropsFinal(mainAttr, elOption, allProps) {
  const attrOpt = elOption[mainAttr];
  if (!attrOpt) {
    return;
  }
  const allPropsInAttr = allProps[mainAttr] = {};
  const keysInAttr = keys(attrOpt);
  for (let i = 0; i < keysInAttr.length; i++) {
    const key = keysInAttr[i];
    allPropsInAttr[key] = cloneValue(attrOpt[key]);
  }
}
function prepareTransformTransitionFrom(el, elOption, transFromProps) {
  const transition = elOption.transition;
  const transitionKeys = isTransitionAll(transition) ? TRANSFORMABLE_PROPS : normalizeToArray(transition || []);
  for (let i = 0; i < transitionKeys.length; i++) {
    const key = transitionKeys[i];
    if (key === "style" || key === "shape" || key === "extra") {
      continue;
    }
    const elVal = el[key];
    if (true) {
      checkTransformPropRefer(key, "el.transition");
    }
    transFromProps[key] = elVal;
  }
}
function prepareTransformAllPropsFinal(el, elOption, allProps) {
  for (let i = 0; i < LEGACY_TRANSFORM_PROPS.length; i++) {
    const legacyName = LEGACY_TRANSFORM_PROPS[i];
    const xyName = LEGACY_TRANSFORM_PROPS_MAP[legacyName];
    const legacyArr = elOption[legacyName];
    if (legacyArr) {
      allProps[xyName[0]] = legacyArr[0];
      allProps[xyName[1]] = legacyArr[1];
    }
  }
  for (let i = 0; i < TRANSFORMABLE_PROPS.length; i++) {
    const key = TRANSFORMABLE_PROPS[i];
    if (elOption[key] != null) {
      allProps[key] = elOption[key];
    }
  }
}
function prepareStyleTransitionFrom(fromEl, elOption, styleOpt, transFromProps) {
  if (!styleOpt) {
    return;
  }
  const fromElStyle = fromEl.style;
  let transFromStyleProps;
  if (fromElStyle) {
    const styleTransition = styleOpt.transition;
    const elTransition = elOption.transition;
    if (styleTransition && !isTransitionAll(styleTransition)) {
      const transitionKeys = normalizeToArray(styleTransition);
      !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});
      for (let i = 0; i < transitionKeys.length; i++) {
        const key = transitionKeys[i];
        const elVal = fromElStyle[key];
        transFromStyleProps[key] = elVal;
      }
    } else if (fromEl.getAnimationStyleProps && (isTransitionAll(elTransition) || isTransitionAll(styleTransition) || indexOf(elTransition, "style") >= 0)) {
      const animationProps = fromEl.getAnimationStyleProps();
      const animationStyleProps = animationProps ? animationProps.style : null;
      if (animationStyleProps) {
        !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});
        const styleKeys = keys(styleOpt);
        for (let i = 0; i < styleKeys.length; i++) {
          const key = styleKeys[i];
          if (animationStyleProps[key]) {
            const elVal = fromElStyle[key];
            transFromStyleProps[key] = elVal;
          }
        }
      }
    }
  }
}
function isNonStyleTransitionEnabled(optVal, elVal) {
  return !isArrayLike(optVal) ? optVal != null && isFinite(optVal) : optVal !== elVal;
}
var checkTransformPropRefer;
if (true) {
  checkTransformPropRefer = function(key, usedIn) {
    if (!hasOwn(TRANSFORM_PROPS_MAP, key)) {
      warn("Prop `" + key + "` is not a permitted in `" + usedIn + "`. Only `" + keys(TRANSFORM_PROPS_MAP).join("`, `") + "` are permitted.");
    }
  };
}

// src/animation/customGraphicKeyframeAnimation.ts
var getStateToRestore = makeInner();
var KEYFRAME_EXCLUDE_KEYS = ["percent", "easing", "shape", "style", "extra"];
function stopPreviousKeyframeAnimationAndRestore(el) {
  el.stopAnimation("keyframe");
  el.attr(getStateToRestore(el));
}
function applyKeyframeAnimation(el, animationOpts, animatableModel) {
  if (!animatableModel.isAnimationEnabled() || !animationOpts) {
    return;
  }
  if (isArray(animationOpts)) {
    each(animationOpts, (singleAnimationOpts) => {
      applyKeyframeAnimation(el, singleAnimationOpts, animatableModel);
    });
    return;
  }
  const keyframes = animationOpts.keyframes;
  let duration = animationOpts.duration;
  if (animatableModel && duration == null) {
    const config = getAnimationConfig("enter", animatableModel, 0);
    duration = config && config.duration;
  }
  if (!keyframes || !duration) {
    return;
  }
  const stateToRestore = getStateToRestore(el);
  each(ELEMENT_ANIMATABLE_PROPS, (targetPropName) => {
    if (targetPropName && !el[targetPropName]) {
      return;
    }
    let animator;
    let endFrameIsSet = false;
    keyframes.sort((a, b) => a.percent - b.percent);
    each(keyframes, (kf) => {
      const animators = el.animators;
      const kfValues = targetPropName ? kf[targetPropName] : kf;
      if (true) {
        if (kf.percent >= 1) {
          endFrameIsSet = true;
        }
      }
      if (!kfValues) {
        return;
      }
      let propKeys = keys(kfValues);
      if (!targetPropName) {
        propKeys = filter(propKeys, (key) => indexOf(KEYFRAME_EXCLUDE_KEYS, key) < 0);
      }
      if (!propKeys.length) {
        return;
      }
      if (!animator) {
        animator = el.animate(targetPropName, animationOpts.loop, true);
        animator.scope = "keyframe";
      }
      for (let i = 0; i < animators.length; i++) {
        if (animators[i] !== animator && animators[i].targetName === animator.targetName) {
          animators[i].stopTracks(propKeys);
        }
      }
      targetPropName && (stateToRestore[targetPropName] = stateToRestore[targetPropName] || {});
      const savedTarget = targetPropName ? stateToRestore[targetPropName] : stateToRestore;
      each(propKeys, (key) => {
        savedTarget[key] = ((targetPropName ? el[targetPropName] : el) || {})[key];
      });
      animator.whenWithKeys(duration * kf.percent, kfValues, propKeys, kf.easing);
    });
    if (!animator) {
      return;
    }
    if (true) {
      if (!endFrameIsSet) {
        warn("End frame with percent: 1 is missing in the keyframeAnimation.", true);
      }
    }
    animator.delay(animationOpts.delay || 0).duration(duration).start(animationOpts.easing);
  });
}

// src/chart/custom/CustomView.ts
var EMPHASIS = "emphasis";
var NORMAL = "normal";
var BLUR = "blur";
var SELECT = "select";
var STATES = [NORMAL, EMPHASIS, BLUR, SELECT];
var PATH_ITEM_STYLE = {
  normal: ["itemStyle"],
  emphasis: [EMPHASIS, "itemStyle"],
  blur: [BLUR, "itemStyle"],
  select: [SELECT, "itemStyle"]
};
var PATH_LABEL = {
  normal: ["label"],
  emphasis: [EMPHASIS, "label"],
  blur: [BLUR, "label"],
  select: [SELECT, "label"]
};
var DEFAULT_TRANSITION = ["x", "y"];
var GROUP_DIFF_PREFIX = "e\0\0";
var attachedTxInfoTmp = {
  normal: {},
  emphasis: {},
  blur: {},
  select: {}
};
var prepareCustoms = {
  cartesian2d: cartesianPrepareCustom,
  geo: geoPrepareCustom,
  single: singlePrepareCustom,
  polar: polarPrepareCustom,
  calendar: calendarPrepareCustom,
  matrix: matrixPrepareCustom
};
function isPath2(el) {
  return el instanceof Path_default;
}
function isDisplayable(el) {
  return el instanceof Displayable_default;
}
function copyElement(sourceEl, targetEl) {
  targetEl.copyTransform(sourceEl);
  if (isDisplayable(targetEl) && isDisplayable(sourceEl)) {
    targetEl.setStyle(sourceEl.style);
    targetEl.z = sourceEl.z;
    targetEl.z2 = sourceEl.z2;
    targetEl.zlevel = sourceEl.zlevel;
    targetEl.invisible = sourceEl.invisible;
    targetEl.ignore = sourceEl.ignore;
    if (isPath2(targetEl) && isPath2(sourceEl)) {
      targetEl.setShape(sourceEl.shape);
    }
  }
}
var CustomChartView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = CustomChartView2.type;
  }
  render(customSeries, ecModel, api2, payload) {
    this._progressiveEls = null;
    const oldData = this._data;
    const data = customSeries.getData();
    const group = this.group;
    const renderItem = makeRenderItem(customSeries, data, ecModel, api2);
    if (!oldData) {
      group.removeAll();
    }
    data.diff(oldData).add(function(newIdx) {
      createOrUpdateItem(api2, null, newIdx, renderItem(newIdx, payload), customSeries, group, data);
    }).remove(function(oldIdx) {
      const el = oldData.getItemGraphicEl(oldIdx);
      el && applyLeaveTransition(el, customInnerStore(el).option, customSeries);
    }).update(function(newIdx, oldIdx) {
      const oldEl = oldData.getItemGraphicEl(oldIdx);
      createOrUpdateItem(api2, oldEl, newIdx, renderItem(newIdx, payload), customSeries, group, data);
    }).execute();
    const clipPath = customSeries.get("clip", true) ? createClipPath(customSeries.coordinateSystem, false, customSeries) : null;
    if (clipPath) {
      group.setClipPath(clipPath);
    } else {
      group.removeClipPath();
    }
    this._data = data;
  }
  incrementalPrepareRender(customSeries, ecModel, api2) {
    this.group.removeAll();
    this._data = null;
  }
  incrementalRender(params, customSeries, ecModel, api2, payload) {
    const data = customSeries.getData();
    const renderItem = makeRenderItem(customSeries, data, ecModel, api2);
    const progressiveEls = this._progressiveEls = [];
    function setIncrementalAndHoverLayer(el) {
      if (!el.isGroup) {
        el.incremental = true;
        el.ensureState("emphasis").hoverLayer = true;
      }
    }
    for (let idx = params.start; idx < params.end; idx++) {
      const el = createOrUpdateItem(null, null, idx, renderItem(idx, payload), customSeries, this.group, data);
      if (el) {
        el.traverse(setIncrementalAndHoverLayer);
        progressiveEls.push(el);
      }
    }
  }
  eachRendered(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  }
  filterForExposedEvent(eventType, query, targetEl, packedEvent) {
    const elementName = query.element;
    if (elementName == null || targetEl.name === elementName) {
      return true;
    }
    while ((targetEl = targetEl.__hostTarget || targetEl.parent) && targetEl !== this.group) {
      if (targetEl.name === elementName) {
        return true;
      }
    }
    return false;
  }
};
var CustomChartView = CustomChartView2;
CustomChartView.type = "custom";
var CustomView_default = CustomChartView;
function createEl(elOption) {
  const graphicType = elOption.type;
  let el;
  if (graphicType === "path") {
    const shape = elOption.shape;
    const pathRect = shape.width != null && shape.height != null ? {
      x: shape.x || 0,
      y: shape.y || 0,
      width: shape.width,
      height: shape.height
    } : null;
    const pathData = getPathData(shape);
    el = makePath(pathData, null, pathRect, shape.layout || "center");
    customInnerStore(el).customPathData = pathData;
  } else if (graphicType === "image") {
    el = new Image_default({});
    customInnerStore(el).customImagePath = elOption.style.image;
  } else if (graphicType === "text") {
    el = new Text_default({});
  } else if (graphicType === "group") {
    el = new Group_default();
  } else if (graphicType === "compoundPath") {
    const shape = elOption.shape;
    if (!shape || !shape.paths) {
      let errMsg = "";
      if (true) {
        errMsg = "shape.paths must be specified in compoundPath";
      }
      throwError(errMsg);
    }
    const paths = map(shape.paths, function(path) {
      if (path.type === "path") {
        return makePath(path.shape.pathData, path, null);
      }
      const Clz = getShapeClass(path.type);
      if (!Clz) {
        let errMsg = "";
        if (true) {
          errMsg = 'graphic type "' + graphicType + '" can not be found.';
        }
        throwError(errMsg);
      }
      return new Clz();
    });
    el = new CompoundPath_default({
      shape: {
        paths
      }
    });
  } else {
    const Clz = getShapeClass(graphicType);
    if (!Clz) {
      let errMsg = "";
      if (true) {
        errMsg = 'graphic type "' + graphicType + '" can not be found.';
      }
      throwError(errMsg);
    }
    el = new Clz();
  }
  customInnerStore(el).customGraphicType = graphicType;
  el.name = elOption.name;
  el.z2EmphasisLift = 1;
  el.z2SelectLift = 1;
  return el;
}
function updateElNormal(api2, el, dataIndex, elOption, attachedTxInfo, seriesModel, isInit) {
  stopPreviousKeyframeAnimationAndRestore(el);
  const txCfgOpt = attachedTxInfo && attachedTxInfo.normal.cfg;
  if (txCfgOpt) {
    el.setTextConfig(txCfgOpt);
  }
  if (elOption && elOption.transition == null) {
    elOption.transition = DEFAULT_TRANSITION;
  }
  const styleOpt = elOption && elOption.style;
  if (styleOpt) {
    if (el.type === "text") {
      const textOptionStyle = styleOpt;
      hasOwn(textOptionStyle, "textFill") && (textOptionStyle.fill = textOptionStyle.textFill);
      hasOwn(textOptionStyle, "textStroke") && (textOptionStyle.stroke = textOptionStyle.textStroke);
    }
    let decalPattern;
    const decalObj = isPath2(el) ? styleOpt.decal : null;
    if (api2 && decalObj) {
      decalObj.dirty = true;
      decalPattern = createOrUpdatePatternFromDecal(decalObj, api2);
    }
    styleOpt.__decalPattern = decalPattern;
  }
  if (isDisplayable(el)) {
    if (styleOpt) {
      const decalPattern = styleOpt.__decalPattern;
      if (decalPattern) {
        styleOpt.decal = decalPattern;
      }
    }
  }
  applyUpdateTransition(el, elOption, seriesModel, {
    dataIndex,
    isInit,
    clearStyle: true
  });
  applyKeyframeAnimation(el, elOption.keyframeAnimation, seriesModel);
}
function updateElOnState(state, el, elStateOpt, styleOpt, attachedTxInfo) {
  const elDisplayable = el.isGroup ? null : el;
  const txCfgOpt = attachedTxInfo && attachedTxInfo[state].cfg;
  if (elDisplayable) {
    const stateObj = elDisplayable.ensureState(state);
    if (styleOpt === false) {
      const existingEmphasisState = elDisplayable.getState(state);
      if (existingEmphasisState) {
        existingEmphasisState.style = null;
      }
    } else {
      stateObj.style = styleOpt || null;
    }
    if (txCfgOpt) {
      stateObj.textConfig = txCfgOpt;
    }
    setDefaultStateProxy(elDisplayable);
  }
}
function updateZ2(el, elOption, seriesModel) {
  if (el.isGroup) {
    return;
  }
  const elDisplayable = el;
  const currentZ = seriesModel.currentZ;
  const currentZLevel = seriesModel.currentZLevel;
  elDisplayable.z = currentZ;
  elDisplayable.zlevel = currentZLevel;
  const optZ2 = elOption.z2;
  optZ2 != null && (elDisplayable.z2 = optZ2 || 0);
  for (let i = 0; i < STATES.length; i++) {
    updateZForEachState(elDisplayable, elOption, STATES[i]);
  }
}
function updateZForEachState(elDisplayable, elOption, state) {
  const isNormal = state === NORMAL;
  const elStateOpt = isNormal ? elOption : retrieveStateOption(elOption, state);
  const optZ2 = elStateOpt ? elStateOpt.z2 : null;
  let stateObj;
  if (optZ2 != null) {
    stateObj = isNormal ? elDisplayable : elDisplayable.ensureState(state);
    stateObj.z2 = optZ2 || 0;
  }
}
function makeRenderItem(customSeries, data, ecModel, api2) {
  let renderItem = customSeries.get("renderItem");
  if (typeof renderItem === "string") {
    const registeredRenderItem = getCustomSeries(renderItem);
    if (registeredRenderItem) {
      renderItem = registeredRenderItem;
    } else if (true) {
      console.warn(`Custom series renderItem '${renderItem}' not found.
                Call 'echarts.registerCustomSeries' to register it.`);
    }
  }
  const coordSys = customSeries.coordinateSystem;
  let prepareResult2 = {};
  if (coordSys) {
    if (true) {
      assert(renderItem, "series.render is required.");
      assert(coordSys.prepareCustoms || prepareCustoms[coordSys.type], "This coordSys does not support custom series.");
    }
    prepareResult2 = coordSys.prepareCustoms ? coordSys.prepareCustoms(coordSys) : prepareCustoms[coordSys.type](coordSys);
  }
  const userAPI = defaults({
    getWidth: api2.getWidth,
    getHeight: api2.getHeight,
    getZr: api2.getZr,
    getDevicePixelRatio: api2.getDevicePixelRatio,
    value,
    style,
    ordinalRawValue,
    styleEmphasis,
    visual,
    barLayout,
    currentSeriesIndices,
    font
  }, prepareResult2.api || {});
  const userParams = {
    context: {},
    seriesId: customSeries.id,
    seriesName: customSeries.name,
    seriesIndex: customSeries.seriesIndex,
    coordSys: prepareResult2.coordSys,
    dataInsideLength: data.count(),
    encode: wrapEncodeDef(customSeries.getData()),
    itemPayload: customSeries.get("itemPayload") || {}
  };
  let currDataIndexInside;
  let currItemModel;
  let currItemStyleModels = {};
  let currLabelModels = {};
  const seriesItemStyleModels = {};
  const seriesLabelModels = {};
  for (let i = 0; i < STATES.length; i++) {
    const stateName = STATES[i];
    seriesItemStyleModels[stateName] = customSeries.getModel(PATH_ITEM_STYLE[stateName]);
    seriesLabelModels[stateName] = customSeries.getModel(PATH_LABEL[stateName]);
  }
  function getItemModel2(dataIndexInside) {
    return dataIndexInside === currDataIndexInside ? currItemModel || (currItemModel = data.getItemModel(dataIndexInside)) : data.getItemModel(dataIndexInside);
  }
  function getItemStyleModel(dataIndexInside, state) {
    return !data.hasItemOption ? seriesItemStyleModels[state] : dataIndexInside === currDataIndexInside ? currItemStyleModels[state] || (currItemStyleModels[state] = getItemModel2(dataIndexInside).getModel(PATH_ITEM_STYLE[state])) : getItemModel2(dataIndexInside).getModel(PATH_ITEM_STYLE[state]);
  }
  function getLabelModel(dataIndexInside, state) {
    return !data.hasItemOption ? seriesLabelModels[state] : dataIndexInside === currDataIndexInside ? currLabelModels[state] || (currLabelModels[state] = getItemModel2(dataIndexInside).getModel(PATH_LABEL[state])) : getItemModel2(dataIndexInside).getModel(PATH_LABEL[state]);
  }
  return function(dataIndexInside, payload) {
    currDataIndexInside = dataIndexInside;
    currItemModel = null;
    currItemStyleModels = {};
    currLabelModels = {};
    return renderItem && renderItem(defaults({
      dataIndexInside,
      dataIndex: data.getRawIndex(dataIndexInside),
      actionType: payload ? payload.type : null
    }, userParams), userAPI);
  };
  function value(dim, dataIndexInside) {
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    return data.getStore().get(data.getDimensionIndex(dim || 0), dataIndexInside);
  }
  function ordinalRawValue(dim, dataIndexInside) {
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    dim = dim || 0;
    const dimInfo = data.getDimensionInfo(dim);
    if (!dimInfo) {
      const dimIndex = data.getDimensionIndex(dim);
      return dimIndex >= 0 ? data.getStore().get(dimIndex, dataIndexInside) : void 0;
    }
    const val = data.get(dimInfo.name, dataIndexInside);
    const ordinalMeta = dimInfo && dimInfo.ordinalMeta;
    return ordinalMeta ? ordinalMeta.categories[val] : val;
  }
  function style(userProps, dataIndexInside) {
    if (true) {
      warnDeprecated("api.style", "Please write literal style directly instead.");
    }
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    const style2 = data.getItemVisual(dataIndexInside, "style");
    const visualColor = style2 && style2.fill;
    const opacity = style2 && style2.opacity;
    let itemStyle = getItemStyleModel(dataIndexInside, NORMAL).getItemStyle();
    visualColor != null && (itemStyle.fill = visualColor);
    opacity != null && (itemStyle.opacity = opacity);
    const opt = {inheritColor: isString(visualColor) ? visualColor : tokens_default.color.neutral99};
    const labelModel = getLabelModel(dataIndexInside, NORMAL);
    const textStyle = createTextStyle(labelModel, null, opt, false, true);
    textStyle.text = labelModel.getShallow("show") ? retrieve2(customSeries.getFormattedLabel(dataIndexInside, NORMAL), getDefaultLabel(data, dataIndexInside)) : null;
    const textConfig = createTextConfig(labelModel, opt, false);
    preFetchFromExtra(userProps, itemStyle);
    itemStyle = convertToEC4StyleForCustomSerise(itemStyle, textStyle, textConfig);
    userProps && applyUserPropsAfter(itemStyle, userProps);
    itemStyle.legacy = true;
    return itemStyle;
  }
  function styleEmphasis(userProps, dataIndexInside) {
    if (true) {
      warnDeprecated("api.styleEmphasis", "Please write literal style directly instead.");
    }
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    let itemStyle = getItemStyleModel(dataIndexInside, EMPHASIS).getItemStyle();
    const labelModel = getLabelModel(dataIndexInside, EMPHASIS);
    const textStyle = createTextStyle(labelModel, null, null, true, true);
    textStyle.text = labelModel.getShallow("show") ? retrieve3(customSeries.getFormattedLabel(dataIndexInside, EMPHASIS), customSeries.getFormattedLabel(dataIndexInside, NORMAL), getDefaultLabel(data, dataIndexInside)) : null;
    const textConfig = createTextConfig(labelModel, null, true);
    preFetchFromExtra(userProps, itemStyle);
    itemStyle = convertToEC4StyleForCustomSerise(itemStyle, textStyle, textConfig);
    userProps && applyUserPropsAfter(itemStyle, userProps);
    itemStyle.legacy = true;
    return itemStyle;
  }
  function applyUserPropsAfter(itemStyle, extra) {
    for (const key in extra) {
      if (hasOwn(extra, key)) {
        itemStyle[key] = extra[key];
      }
    }
  }
  function preFetchFromExtra(extra, itemStyle) {
    if (extra) {
      extra.textFill && (itemStyle.textFill = extra.textFill);
      extra.textPosition && (itemStyle.textPosition = extra.textPosition);
    }
  }
  function visual(visualType, dataIndexInside) {
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    if (hasOwn(STYLE_VISUAL_TYPE, visualType)) {
      const style2 = data.getItemVisual(dataIndexInside, "style");
      return style2 ? style2[STYLE_VISUAL_TYPE[visualType]] : null;
    }
    if (hasOwn(NON_STYLE_VISUAL_PROPS, visualType)) {
      return data.getItemVisual(dataIndexInside, visualType);
    }
  }
  function barLayout(opt) {
    if (coordSys.type === "cartesian2d") {
      const baseAxis = coordSys.getBaseAxis();
      return getLayoutOnAxis(defaults({axis: baseAxis}, opt));
    }
  }
  function currentSeriesIndices() {
    return ecModel.getCurrentSeriesIndices();
  }
  function font(opt) {
    return getFont(opt, ecModel);
  }
}
function wrapEncodeDef(data) {
  const encodeDef = {};
  each(data.dimensions, function(dimName) {
    const dimInfo = data.getDimensionInfo(dimName);
    if (!dimInfo.isExtraCoord) {
      const coordDim = dimInfo.coordDim;
      const dataDims = encodeDef[coordDim] = encodeDef[coordDim] || [];
      dataDims[dimInfo.coordDimIndex] = data.getDimensionIndex(dimName);
    }
  });
  return encodeDef;
}
function createOrUpdateItem(api2, existsEl, dataIndex, elOption, seriesModel, group, data) {
  if (!elOption) {
    group.remove(existsEl);
    return;
  }
  const el = doCreateOrUpdateEl(api2, existsEl, dataIndex, elOption, seriesModel, group);
  el && data.setItemGraphicEl(dataIndex, el);
  el && toggleHoverEmphasis(el, elOption.focus, elOption.blurScope, elOption.emphasisDisabled);
  return el;
}
function doCreateOrUpdateEl(api2, existsEl, dataIndex, elOption, seriesModel, group) {
  if (true) {
    assert(elOption, "should not have an null/undefined element setting");
  }
  let toBeReplacedIdx = -1;
  const oldEl = existsEl;
  if (existsEl && doesElNeedRecreate(existsEl, elOption, seriesModel)) {
    toBeReplacedIdx = indexOf(group.childrenRef(), existsEl);
    existsEl = null;
  }
  const isInit = !existsEl;
  let el = existsEl;
  if (!el) {
    el = createEl(elOption);
    if (oldEl) {
      copyElement(oldEl, el);
    }
  } else {
    el.clearStates();
  }
  if (elOption.morph === false) {
    el.disableMorphing = true;
  } else if (el.disableMorphing) {
    el.disableMorphing = false;
  }
  if (elOption.tooltipDisabled) {
    el.tooltipDisabled = true;
  }
  attachedTxInfoTmp.normal.cfg = attachedTxInfoTmp.normal.conOpt = attachedTxInfoTmp.emphasis.cfg = attachedTxInfoTmp.emphasis.conOpt = attachedTxInfoTmp.blur.cfg = attachedTxInfoTmp.blur.conOpt = attachedTxInfoTmp.select.cfg = attachedTxInfoTmp.select.conOpt = null;
  attachedTxInfoTmp.isLegacy = false;
  doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfoTmp);
  doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit);
  updateElNormal(api2, el, dataIndex, elOption, attachedTxInfoTmp, seriesModel, isInit);
  hasOwn(elOption, "info") && (customInnerStore(el).info = elOption.info);
  for (let i = 0; i < STATES.length; i++) {
    const stateName = STATES[i];
    if (stateName !== NORMAL) {
      const otherStateOpt = retrieveStateOption(elOption, stateName);
      const otherStyleOpt = retrieveStyleOptionOnState(elOption, otherStateOpt, stateName);
      updateElOnState(stateName, el, otherStateOpt, otherStyleOpt, attachedTxInfoTmp);
    }
  }
  updateZ2(el, elOption, seriesModel);
  if (elOption.type === "group") {
    mergeChildren(api2, el, dataIndex, elOption, seriesModel);
  }
  if (toBeReplacedIdx >= 0) {
    group.replaceAt(el, toBeReplacedIdx);
  } else {
    group.add(el);
  }
  return el;
}
function doesElNeedRecreate(el, elOption, seriesModel) {
  const elInner = customInnerStore(el);
  const elOptionType = elOption.type;
  const elOptionShape = elOption.shape;
  const elOptionStyle = elOption.style;
  return seriesModel.isUniversalTransitionEnabled() || elOptionType != null && elOptionType !== elInner.customGraphicType || elOptionType === "path" && hasOwnPathData(elOptionShape) && getPathData(elOptionShape) !== elInner.customPathData || elOptionType === "image" && hasOwn(elOptionStyle, "image") && elOptionStyle.image !== elInner.customImagePath;
}
function doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit) {
  const clipPathOpt = elOption.clipPath;
  if (clipPathOpt === false) {
    if (el && el.getClipPath()) {
      el.removeClipPath();
    }
  } else if (clipPathOpt) {
    let clipPath = el.getClipPath();
    if (clipPath && doesElNeedRecreate(clipPath, clipPathOpt, seriesModel)) {
      clipPath = null;
    }
    if (!clipPath) {
      clipPath = createEl(clipPathOpt);
      if (true) {
        assert(isPath2(clipPath), "Only any type of `path` can be used in `clipPath`, rather than " + clipPath.type + ".");
      }
      el.setClipPath(clipPath);
    }
    updateElNormal(null, clipPath, dataIndex, clipPathOpt, null, seriesModel, isInit);
  }
}
function doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfo) {
  if (el.isGroup || el.type === "compoundPath") {
    return;
  }
  processTxInfo(elOption, null, attachedTxInfo);
  processTxInfo(elOption, EMPHASIS, attachedTxInfo);
  let txConOptNormal = attachedTxInfo.normal.conOpt;
  const txConOptEmphasis = attachedTxInfo.emphasis.conOpt;
  const txConOptBlur = attachedTxInfo.blur.conOpt;
  const txConOptSelect = attachedTxInfo.select.conOpt;
  if (txConOptNormal != null || txConOptEmphasis != null || txConOptSelect != null || txConOptBlur != null) {
    let textContent = el.getTextContent();
    if (txConOptNormal === false) {
      textContent && el.removeTextContent();
    } else {
      txConOptNormal = attachedTxInfo.normal.conOpt = txConOptNormal || {type: "text"};
      if (!textContent) {
        textContent = createEl(txConOptNormal);
        el.setTextContent(textContent);
      } else {
        textContent.clearStates();
      }
      updateElNormal(null, textContent, dataIndex, txConOptNormal, null, seriesModel, isInit);
      const txConStlOptNormal = txConOptNormal && txConOptNormal.style;
      for (let i = 0; i < STATES.length; i++) {
        const stateName = STATES[i];
        if (stateName !== NORMAL) {
          const txConOptOtherState = attachedTxInfo[stateName].conOpt;
          updateElOnState(stateName, textContent, txConOptOtherState, retrieveStyleOptionOnState(txConOptNormal, txConOptOtherState, stateName), null);
        }
      }
      txConStlOptNormal ? textContent.dirty() : textContent.markRedraw();
    }
  }
}
function processTxInfo(elOption, state, attachedTxInfo) {
  const stateOpt = !state ? elOption : retrieveStateOption(elOption, state);
  const styleOpt = !state ? elOption.style : retrieveStyleOptionOnState(elOption, stateOpt, EMPHASIS);
  const elType = elOption.type;
  let txCfg = stateOpt ? stateOpt.textConfig : null;
  const txConOptNormal = elOption.textContent;
  let txConOpt = !txConOptNormal ? null : !state ? txConOptNormal : retrieveStateOption(txConOptNormal, state);
  if (styleOpt && (attachedTxInfo.isLegacy || isEC4CompatibleStyle(styleOpt, elType, !!txCfg, !!txConOpt))) {
    attachedTxInfo.isLegacy = true;
    const convertResult = convertFromEC4CompatibleStyle(styleOpt, elType, !state);
    if (!txCfg && convertResult.textConfig) {
      txCfg = convertResult.textConfig;
    }
    if (!txConOpt && convertResult.textContent) {
      txConOpt = convertResult.textContent;
    }
  }
  if (!state && txConOpt) {
    const txConOptNormal2 = txConOpt;
    !txConOptNormal2.type && (txConOptNormal2.type = "text");
    if (true) {
      assert(txConOptNormal2.type === "text", 'textContent.type must be "text"');
    }
  }
  const info = !state ? attachedTxInfo.normal : attachedTxInfo[state];
  info.cfg = txCfg;
  info.conOpt = txConOpt;
}
function retrieveStateOption(elOption, state) {
  return !state ? elOption : elOption ? elOption[state] : null;
}
function retrieveStyleOptionOnState(stateOptionNormal, stateOption, state) {
  let style = stateOption && stateOption.style;
  if (style == null && state === EMPHASIS && stateOptionNormal) {
    style = stateOptionNormal.styleEmphasis;
  }
  return style;
}
function mergeChildren(api2, el, dataIndex, elOption, seriesModel) {
  const newChildren = elOption.children;
  const newLen = newChildren ? newChildren.length : 0;
  const mergeChildren2 = elOption.$mergeChildren;
  const byName = mergeChildren2 === "byName" || elOption.diffChildrenByName;
  const notMerge = mergeChildren2 === false;
  if (!newLen && !byName && !notMerge) {
    return;
  }
  if (byName) {
    diffGroupChildren({
      api: api2,
      oldChildren: el.children() || [],
      newChildren: newChildren || [],
      dataIndex,
      seriesModel,
      group: el
    });
    return;
  }
  notMerge && el.removeAll();
  let index = 0;
  for (; index < newLen; index++) {
    const newChild = newChildren[index];
    const oldChild = el.childAt(index);
    if (newChild) {
      if (newChild.ignore == null) {
        newChild.ignore = false;
      }
      doCreateOrUpdateEl(api2, oldChild, dataIndex, newChild, seriesModel, el);
    } else {
      if (true) {
        assert(oldChild, "renderItem should not return a group containing elements as null/undefined/{} if they do not exist before.");
      }
      oldChild.ignore = true;
    }
  }
  for (let i = el.childCount() - 1; i >= index; i--) {
    const child = el.childAt(i);
    removeChildFromGroup(el, child, seriesModel);
  }
}
function removeChildFromGroup(group, child, seriesModel) {
  child && applyLeaveTransition(child, customInnerStore(group).option, seriesModel);
}
function diffGroupChildren(context) {
  new DataDiffer_default(context.oldChildren, context.newChildren, getKey, getKey, context).add(processAddUpdate).update(processAddUpdate).remove(processRemove).execute();
}
function getKey(item, idx) {
  const name = item && item.name;
  return name != null ? name : GROUP_DIFF_PREFIX + idx;
}
function processAddUpdate(newIndex, oldIndex) {
  const context = this.context;
  const childOption = newIndex != null ? context.newChildren[newIndex] : null;
  const child = oldIndex != null ? context.oldChildren[oldIndex] : null;
  doCreateOrUpdateEl(context.api, child, context.dataIndex, childOption, context.seriesModel, context.group);
}
function processRemove(oldIndex) {
  const context = this.context;
  const child = context.oldChildren[oldIndex];
  child && applyLeaveTransition(child, customInnerStore(child).option, context.seriesModel);
}
function getPathData(shape) {
  return shape && (shape.pathData || shape.d);
}
function hasOwnPathData(shape) {
  return shape && (hasOwn(shape, "pathData") || hasOwn(shape, "d"));
}

// src/chart/custom/install.ts
function install29(registers) {
  registers.registerChartView(CustomView_default);
  registers.registerSeriesModel(CustomSeries_default);
}

// src/component/graphic/GraphicModel.ts
function setKeyInfoToNewElOption(resultItem, newElOption) {
  const existElOption = resultItem.existing;
  newElOption.id = resultItem.keyInfo.id;
  !newElOption.type && existElOption && (newElOption.type = existElOption.type);
  if (newElOption.parentId == null) {
    const newElParentOption = newElOption.parentOption;
    if (newElParentOption) {
      newElOption.parentId = newElParentOption.id;
    } else if (existElOption) {
      newElOption.parentId = existElOption.parentId;
    }
  }
  newElOption.parentOption = null;
}
function isSetLoc(obj, props) {
  let isSet;
  each(props, function(prop) {
    obj[prop] != null && obj[prop] !== "auto" && (isSet = true);
  });
  return isSet;
}
function mergeNewElOptionToExist(existList, index, newElOption) {
  const newElOptCopy = extend({}, newElOption);
  const existElOption = existList[index];
  const $action = newElOption.$action || "merge";
  if ($action === "merge") {
    if (existElOption) {
      if (true) {
        const newType = newElOption.type;
        assert(!newType || existElOption.type === newType, 'Please set $action: "replace" to change `type`');
      }
      merge(existElOption, newElOptCopy, true);
      mergeLayoutParam(existElOption, newElOptCopy, {ignoreSize: true});
      copyLayoutParams(newElOption, existElOption);
      copyTransitionInfo(newElOption, existElOption);
      copyTransitionInfo(newElOption, existElOption, "shape");
      copyTransitionInfo(newElOption, existElOption, "style");
      copyTransitionInfo(newElOption, existElOption, "extra");
      newElOption.clipPath = existElOption.clipPath;
    } else {
      existList[index] = newElOptCopy;
    }
  } else if ($action === "replace") {
    existList[index] = newElOptCopy;
  } else if ($action === "remove") {
    existElOption && (existList[index] = null);
  }
}
var TRANSITION_PROPS_TO_COPY = ["transition", "enterFrom", "leaveTo"];
var ROOT_TRANSITION_PROPS_TO_COPY = TRANSITION_PROPS_TO_COPY.concat(["enterAnimation", "updateAnimation", "leaveAnimation"]);
function copyTransitionInfo(target, source, targetProp) {
  if (targetProp) {
    if (!target[targetProp] && source[targetProp]) {
      target[targetProp] = {};
    }
    target = target[targetProp];
    source = source[targetProp];
  }
  if (!target || !source) {
    return;
  }
  const props = targetProp ? TRANSITION_PROPS_TO_COPY : ROOT_TRANSITION_PROPS_TO_COPY;
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (target[prop] == null && source[prop] != null) {
      target[prop] = source[prop];
    }
  }
}
function setLayoutInfoToExist(existItem, newElOption) {
  if (!existItem) {
    return;
  }
  existItem.hv = newElOption.hv = [
    isSetLoc(newElOption, ["left", "right"]),
    isSetLoc(newElOption, ["top", "bottom"])
  ];
  if (existItem.type === "group") {
    const existingGroupOpt = existItem;
    const newGroupOpt = newElOption;
    existingGroupOpt.width == null && (existingGroupOpt.width = newGroupOpt.width = 0);
    existingGroupOpt.height == null && (existingGroupOpt.height = newGroupOpt.height = 0);
  }
}
var GraphicComponentModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = GraphicComponentModel2.type;
    this.preventAutoZ = true;
  }
  mergeOption(option, ecModel) {
    const elements = this.option.elements;
    this.option.elements = null;
    super.mergeOption(option, ecModel);
    this.option.elements = elements;
  }
  optionUpdated(newOption, isInit) {
    const thisOption = this.option;
    const newList = (isInit ? thisOption : newOption).elements;
    const existList = thisOption.elements = isInit ? [] : thisOption.elements;
    const flattenedList = [];
    this._flatten(newList, flattenedList, null);
    const mappingResult = mappingToExists(existList, flattenedList, "normalMerge");
    const elOptionsToUpdate = this._elOptionsToUpdate = [];
    each(mappingResult, function(resultItem, index) {
      const newElOption = resultItem.newOption;
      if (true) {
        assert(isObject(newElOption) || resultItem.existing, "Empty graphic option definition");
      }
      if (!newElOption) {
        return;
      }
      elOptionsToUpdate.push(newElOption);
      setKeyInfoToNewElOption(resultItem, newElOption);
      mergeNewElOptionToExist(existList, index, newElOption);
      setLayoutInfoToExist(existList[index], newElOption);
    }, this);
    thisOption.elements = filter(existList, (item) => {
      item && delete item.$action;
      return item != null;
    });
  }
  _flatten(optionList, result, parentOption) {
    each(optionList, function(option) {
      if (!option) {
        return;
      }
      if (parentOption) {
        option.parentOption = parentOption;
      }
      result.push(option);
      const children = option.children;
      if (children && children.length) {
        this._flatten(children, result, option);
      }
      delete option.children;
    }, this);
  }
  useElOptionsToUpdate() {
    const els = this._elOptionsToUpdate;
    this._elOptionsToUpdate = null;
    return els;
  }
};
var GraphicComponentModel = GraphicComponentModel2;
GraphicComponentModel.type = "graphic";
GraphicComponentModel.defaultOption = {
  elements: []
};

// src/component/axisPointer/BaseAxisPointer.ts
var inner13 = makeInner();
var clone4 = clone;
var bind2 = bind;
var BaseAxisPointer = class {
  constructor() {
    this._dragging = false;
    this.animationThreshold = 15;
  }
  render(axisModel, axisPointerModel, api2, forceRender) {
    const value = axisPointerModel.get("value");
    const status = axisPointerModel.get("status");
    this._axisModel = axisModel;
    this._axisPointerModel = axisPointerModel;
    this._api = api2;
    if (!forceRender && this._lastValue === value && this._lastStatus === status) {
      return;
    }
    this._lastValue = value;
    this._lastStatus = status;
    let group = this._group;
    const handle = this._handle;
    if (!status || status === "hide") {
      group && group.hide();
      handle && handle.hide();
      return;
    }
    group && group.show();
    handle && handle.show();
    const elOption = {};
    this.makeElOption(elOption, value, axisModel, axisPointerModel, api2);
    const graphicKey = elOption.graphicKey;
    if (graphicKey !== this._lastGraphicKey) {
      this.clear(api2);
    }
    this._lastGraphicKey = graphicKey;
    const moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);
    if (!group) {
      group = this._group = new Group_default();
      this.createPointerEl(group, elOption, axisModel, axisPointerModel);
      this.createLabelEl(group, elOption, axisModel, axisPointerModel);
      api2.getZr().add(group);
    } else {
      const doUpdateProps = curry(updateProps2, axisPointerModel, moveAnimation);
      this.updatePointerEl(group, elOption, doUpdateProps);
      this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
    }
    updateMandatoryProps(group, axisPointerModel, true);
    this._renderHandle(value);
  }
  remove(api2) {
    this.clear(api2);
  }
  dispose(api2) {
    this.clear(api2);
  }
  determineAnimation(axisModel, axisPointerModel) {
    const animation = axisPointerModel.get("animation");
    const axis = axisModel.axis;
    const isCategoryAxis = axis.type === "category";
    const useSnap = axisPointerModel.get("snap");
    if (!useSnap && !isCategoryAxis) {
      return false;
    }
    if (animation === "auto" || animation == null) {
      const animationThreshold = this.animationThreshold;
      if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
        return true;
      }
      if (useSnap) {
        const seriesDataCount = getAxisInfo(axisModel).seriesDataCount;
        const axisExtent = axis.getExtent();
        return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
      }
      return false;
    }
    return animation === true;
  }
  makeElOption(elOption, value, axisModel, axisPointerModel, api2) {
  }
  createPointerEl(group, elOption, axisModel, axisPointerModel) {
    const pointerOption = elOption.pointer;
    if (pointerOption) {
      const pointerEl = inner13(group).pointerEl = new graphic_exports[pointerOption.type](clone4(elOption.pointer));
      group.add(pointerEl);
    }
  }
  createLabelEl(group, elOption, axisModel, axisPointerModel) {
    if (elOption.label) {
      const labelEl = inner13(group).labelEl = new Text_default(clone4(elOption.label));
      group.add(labelEl);
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  }
  updatePointerEl(group, elOption, updateProps3) {
    const pointerEl = inner13(group).pointerEl;
    if (pointerEl && elOption.pointer) {
      pointerEl.setStyle(elOption.pointer.style);
      updateProps3(pointerEl, {shape: elOption.pointer.shape});
    }
  }
  updateLabelEl(group, elOption, updateProps3, axisPointerModel) {
    const labelEl = inner13(group).labelEl;
    if (labelEl) {
      labelEl.setStyle(elOption.label.style);
      updateProps3(labelEl, {
        x: elOption.label.x,
        y: elOption.label.y
      });
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  }
  _renderHandle(value) {
    if (this._dragging || !this.updateHandleTransform) {
      return;
    }
    const axisPointerModel = this._axisPointerModel;
    const zr = this._api.getZr();
    let handle = this._handle;
    const handleModel = axisPointerModel.getModel("handle");
    const status = axisPointerModel.get("status");
    if (!handleModel.get("show") || !status || status === "hide") {
      handle && zr.remove(handle);
      this._handle = null;
      return;
    }
    let isInit;
    if (!this._handle) {
      isInit = true;
      handle = this._handle = createIcon(handleModel.get("icon"), {
        cursor: "move",
        draggable: true,
        onmousemove(e2) {
          stop(e2.event);
        },
        onmousedown: bind2(this._onHandleDragMove, this, 0, 0),
        drift: bind2(this._onHandleDragMove, this),
        ondragend: bind2(this._onHandleDragEnd, this)
      });
      zr.add(handle);
    }
    updateMandatoryProps(handle, axisPointerModel, false);
    handle.setStyle(handleModel.getItemStyle(null, [
      "color",
      "borderColor",
      "borderWidth",
      "opacity",
      "shadowColor",
      "shadowBlur",
      "shadowOffsetX",
      "shadowOffsetY"
    ]));
    let handleSize = handleModel.get("size");
    if (!isArray(handleSize)) {
      handleSize = [handleSize, handleSize];
    }
    handle.scaleX = handleSize[0] / 2;
    handle.scaleY = handleSize[1] / 2;
    createOrUpdate(this, "_doDispatchAxisPointer", handleModel.get("throttle") || 0, "fixRate");
    this._moveHandleToValue(value, isInit);
  }
  _moveHandleToValue(value, isInit) {
    updateProps2(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
  }
  _onHandleDragMove(dx, dy) {
    const handle = this._handle;
    if (!handle) {
      return;
    }
    this._dragging = true;
    const trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
    this._payloadInfo = trans;
    handle.stopAnimation();
    handle.attr(getHandleTransProps(trans));
    inner13(handle).lastProp = null;
    this._doDispatchAxisPointer();
  }
  _doDispatchAxisPointer() {
    const handle = this._handle;
    if (!handle) {
      return;
    }
    const payloadInfo = this._payloadInfo;
    const axisModel = this._axisModel;
    this._api.dispatchAction({
      type: "updateAxisPointer",
      x: payloadInfo.cursorPoint[0],
      y: payloadInfo.cursorPoint[1],
      tooltipOption: payloadInfo.tooltipOption,
      axesInfo: [{
        axisDim: axisModel.axis.dim,
        axisIndex: axisModel.componentIndex
      }]
    });
  }
  _onHandleDragEnd() {
    this._dragging = false;
    const handle = this._handle;
    if (!handle) {
      return;
    }
    const value = this._axisPointerModel.get("value");
    this._moveHandleToValue(value);
    this._api.dispatchAction({
      type: "hideTip"
    });
  }
  clear(api2) {
    this._lastValue = null;
    this._lastStatus = null;
    const zr = api2.getZr();
    const group = this._group;
    const handle = this._handle;
    if (zr && group) {
      this._lastGraphicKey = null;
      group && zr.remove(group);
      handle && zr.remove(handle);
      this._group = null;
      this._handle = null;
      this._payloadInfo = null;
    }
    clear(this, "_doDispatchAxisPointer");
  }
  doClear() {
  }
  buildLabel(xy, wh, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
      x: xy[xDimIndex],
      y: xy[1 - xDimIndex],
      width: wh[xDimIndex],
      height: wh[1 - xDimIndex]
    };
  }
};
function updateProps2(animationModel, moveAnimation, el, props) {
  if (!propsEqual(inner13(el).lastProp, props)) {
    inner13(el).lastProp = props;
    moveAnimation ? updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));
  }
}
function propsEqual(lastProps, newProps) {
  if (isObject(lastProps) && isObject(newProps)) {
    let equals = true;
    each(newProps, function(item, key) {
      equals = equals && propsEqual(lastProps[key], item);
    });
    return !!equals;
  } else {
    return lastProps === newProps;
  }
}
function updateLabelShowHide(labelEl, axisPointerModel) {
  labelEl[axisPointerModel.get(["label", "show"]) ? "show" : "hide"]();
}
function getHandleTransProps(trans) {
  return {
    x: trans.x || 0,
    y: trans.y || 0,
    rotation: trans.rotation || 0
  };
}
function updateMandatoryProps(group, axisPointerModel, silent) {
  const z = axisPointerModel.get("z");
  const zlevel = axisPointerModel.get("zlevel");
  group && group.traverse(function(el) {
    if (el.type !== "group") {
      z != null && (el.z = z);
      zlevel != null && (el.zlevel = zlevel);
      el.silent = silent;
    }
  });
}
var BaseAxisPointer_default = BaseAxisPointer;

// src/component/axisPointer/viewHelper.ts
function buildElStyle(axisPointerModel) {
  const axisPointerType = axisPointerModel.get("type");
  const styleModel = axisPointerModel.getModel(axisPointerType + "Style");
  let style;
  if (axisPointerType === "line") {
    style = styleModel.getLineStyle();
    style.fill = null;
  } else if (axisPointerType === "shadow") {
    style = styleModel.getAreaStyle();
    style.stroke = null;
  }
  return style;
}
function buildLabelElOption(elOption, axisModel, axisPointerModel, api2, labelPos) {
  const value = axisPointerModel.get("value");
  const text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get("seriesDataIndices"), {
    precision: axisPointerModel.get(["label", "precision"]),
    formatter: axisPointerModel.get(["label", "formatter"])
  });
  const labelModel = axisPointerModel.getModel("label");
  const paddings = normalizeCssArray2(labelModel.get("padding") || 0);
  const font = labelModel.getFont();
  const textRect = getBoundingRect(text, font);
  const position2 = labelPos.position;
  const width = textRect.width + paddings[1] + paddings[3];
  const height = textRect.height + paddings[0] + paddings[2];
  const align = labelPos.align;
  align === "right" && (position2[0] -= width);
  align === "center" && (position2[0] -= width / 2);
  const verticalAlign = labelPos.verticalAlign;
  verticalAlign === "bottom" && (position2[1] -= height);
  verticalAlign === "middle" && (position2[1] -= height / 2);
  confineInContainer(position2, width, height, api2);
  let bgColor = labelModel.get("backgroundColor");
  if (!bgColor || bgColor === "auto") {
    bgColor = axisModel.get(["axisLine", "lineStyle", "color"]);
  }
  elOption.label = {
    x: position2[0],
    y: position2[1],
    style: createTextStyle(labelModel, {
      text,
      font,
      fill: labelModel.getTextColor(),
      padding: paddings,
      backgroundColor: bgColor
    }),
    z2: 10
  };
}
function confineInContainer(position2, width, height, api2) {
  const viewWidth = api2.getWidth();
  const viewHeight = api2.getHeight();
  position2[0] = Math.min(position2[0] + width, viewWidth) - width;
  position2[1] = Math.min(position2[1] + height, viewHeight) - height;
  position2[0] = Math.max(position2[0], 0);
  position2[1] = Math.max(position2[1], 0);
}
function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
  value = axis.scale.parse(value);
  let text = axis.scale.getLabel({
    value
  }, {
    precision: opt.precision
  });
  const formatter = opt.formatter;
  if (formatter) {
    const params = {
      value: getAxisRawValue(axis, {value}),
      axisDimension: axis.dim,
      axisIndex: axis.index,
      seriesData: []
    };
    each(seriesDataIndices, function(idxItem) {
      const series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
      const dataIndex = idxItem.dataIndexInside;
      const dataParams = series && series.getDataParams(dataIndex);
      dataParams && params.seriesData.push(dataParams);
    });
    if (isString(formatter)) {
      text = formatter.replace("{value}", text);
    } else if (isFunction(formatter)) {
      text = formatter(params);
    }
  }
  return text;
}
function getTransformedPosition(axis, value, layoutInfo) {
  const transform2 = create2();
  rotate(transform2, transform2, layoutInfo.rotation);
  translate(transform2, transform2, layoutInfo.position);
  return applyTransform2([
    axis.dataToCoord(value),
    (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)
  ], transform2);
}
function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api2) {
  const textLayout = AxisBuilder_default.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
  layoutInfo.labelMargin = axisPointerModel.get(["label", "margin"]);
  buildLabelElOption(elOption, axisModel, axisPointerModel, api2, {
    position: getTransformedPosition(axisModel.axis, value, layoutInfo),
    align: textLayout.textAlign,
    verticalAlign: textLayout.textVerticalAlign
  });
}
function makeLineShape(p1, p2, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x1: p1[xDimIndex],
    y1: p1[1 - xDimIndex],
    x2: p2[xDimIndex],
    y2: p2[1 - xDimIndex]
  };
}
function makeRectShape(xy, wh, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x: xy[xDimIndex],
    y: xy[1 - xDimIndex],
    width: wh[xDimIndex],
    height: wh[1 - xDimIndex]
  };
}
function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {
  return {
    cx,
    cy,
    r0,
    r,
    startAngle,
    endAngle,
    clockwise: true
  };
}

// src/component/axisPointer/CartesianAxisPointer.ts
var CartesianAxisPointer = class extends BaseAxisPointer_default {
  makeElOption(elOption, value, axisModel, axisPointerModel, api2) {
    const axis = axisModel.axis;
    const grid = axis.grid;
    const axisPointerType = axisPointerModel.get("type");
    const otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
    const pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));
    if (axisPointerType && axisPointerType !== "none") {
      const elStyle = buildElStyle(axisPointerModel);
      const pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }
    const layoutInfo = layout3(grid.getRect(), axisModel);
    buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api2);
  }
  getHandleTransform(value, axisModel, axisPointerModel) {
    const layoutInfo = layout3(axisModel.axis.grid.getRect(), axisModel, {labelInside: false});
    layoutInfo.labelMargin = axisPointerModel.get(["handle", "margin"]);
    const pos = getTransformedPosition(axisModel.axis, value, layoutInfo);
    return {
      x: pos[0],
      y: pos[1],
      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
    };
  }
  updateHandleTransform(transform2, delta, axisModel, axisPointerModel) {
    const axis = axisModel.axis;
    const grid = axis.grid;
    const axisExtent = axis.getGlobalExtent(true);
    const otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
    const dimIndex = axis.dim === "x" ? 0 : 1;
    const currPosition = [transform2.x, transform2.y];
    currPosition[dimIndex] += delta[dimIndex];
    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
    const cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
    const cursorPoint = [cursorOtherValue, cursorOtherValue];
    cursorPoint[dimIndex] = currPosition[dimIndex];
    const tooltipOptions = [
      {verticalAlign: "middle"},
      {align: "center"}
    ];
    return {
      x: currPosition[0],
      y: currPosition[1],
      rotation: transform2.rotation,
      cursorPoint,
      tooltipOption: tooltipOptions[dimIndex]
    };
  }
};
function getCartesian(grid, axis) {
  const opt = {};
  opt[axis.dim + "AxisIndex"] = axis.index;
  return grid.getCartesian(opt);
}
var pointerShapeBuilder = {
  line: function(axis, pixelValue, otherExtent) {
    const targetShape = makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));
    return {
      type: "Line",
      subPixelOptimize: true,
      shape: targetShape
    };
  },
  shadow: function(axis, pixelValue, otherExtent) {
    const bandWidth = Math.max(1, axis.getBandWidth());
    const span = otherExtent[1] - otherExtent[0];
    return {
      type: "Rect",
      shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
    };
  }
};
function getAxisDimIndex(axis) {
  return axis.dim === "x" ? 0 : 1;
}
var CartesianAxisPointer_default = CartesianAxisPointer;

// src/component/axisPointer/AxisPointerModel.ts
var AxisPointerModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = AxisPointerModel2.type;
  }
};
var AxisPointerModel = AxisPointerModel2;
AxisPointerModel.type = "axisPointer";
AxisPointerModel.defaultOption = {
  show: "auto",
  z: 50,
  type: "line",
  snap: false,
  triggerTooltip: true,
  triggerEmphasis: true,
  value: null,
  status: null,
  link: [],
  animation: null,
  animationDurationUpdate: 200,
  lineStyle: {
    color: tokens_default.color.border,
    width: 1,
    type: "dashed"
  },
  shadowStyle: {
    color: tokens_default.color.shadowTint
  },
  label: {
    show: true,
    formatter: null,
    precision: "auto",
    margin: 3,
    color: tokens_default.color.neutral00,
    padding: [5, 7, 5, 7],
    backgroundColor: tokens_default.color.accent60,
    borderColor: null,
    borderWidth: 0,
    borderRadius: 3
  },
  handle: {
    show: false,
    icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
    size: 45,
    margin: 50,
    color: tokens_default.color.accent40,
    throttle: 40
  }
};
var AxisPointerModel_default = AxisPointerModel;

// src/component/axisPointer/globalListener.ts
var inner14 = makeInner();
var each8 = each;
function register(key, api2, handler) {
  if (env_default.node) {
    return;
  }
  const zr = api2.getZr();
  inner14(zr).records || (inner14(zr).records = {});
  initGlobalListeners(zr, api2);
  const record = inner14(zr).records[key] || (inner14(zr).records[key] = {});
  record.handler = handler;
}
function initGlobalListeners(zr, api2) {
  if (inner14(zr).initialized) {
    return;
  }
  inner14(zr).initialized = true;
  useHandler("click", curry(doEnter, "click"));
  useHandler("mousemove", curry(doEnter, "mousemove"));
  useHandler("globalout", onLeave);
  function useHandler(eventType, cb) {
    zr.on(eventType, function(e2) {
      const dis = makeDispatchAction(api2);
      each8(inner14(zr).records, function(record) {
        record && cb(record, e2, dis.dispatchAction);
      });
      dispatchTooltipFinally(dis.pendings, api2);
    });
  }
}
function dispatchTooltipFinally(pendings, api2) {
  const showLen = pendings.showTip.length;
  const hideLen = pendings.hideTip.length;
  let actuallyPayload;
  if (showLen) {
    actuallyPayload = pendings.showTip[showLen - 1];
  } else if (hideLen) {
    actuallyPayload = pendings.hideTip[hideLen - 1];
  }
  if (actuallyPayload) {
    actuallyPayload.dispatchAction = null;
    api2.dispatchAction(actuallyPayload);
  }
}
function onLeave(record, e2, dispatchAction3) {
  record.handler("leave", null, dispatchAction3);
}
function doEnter(currTrigger, record, e2, dispatchAction3) {
  record.handler(currTrigger, e2, dispatchAction3);
}
function makeDispatchAction(api2) {
  const pendings = {
    showTip: [],
    hideTip: []
  };
  const dispatchAction3 = function(payload) {
    const pendingList = pendings[payload.type];
    if (pendingList) {
      pendingList.push(payload);
    } else {
      payload.dispatchAction = dispatchAction3;
      api2.dispatchAction(payload);
    }
  };
  return {
    dispatchAction: dispatchAction3,
    pendings
  };
}
function unregister(key, api2) {
  if (env_default.node) {
    return;
  }
  const zr = api2.getZr();
  const record = (inner14(zr).records || {})[key];
  if (record) {
    inner14(zr).records[key] = null;
  }
}

// src/component/axisPointer/AxisPointerView.ts
var AxisPointerView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = AxisPointerView2.type;
  }
  render(globalAxisPointerModel, ecModel, api2) {
    const globalTooltipModel = ecModel.getComponent("tooltip");
    const triggerOn = globalAxisPointerModel.get("triggerOn") || (globalTooltipModel && globalTooltipModel.get("triggerOn") || "mousemove|click");
    register("axisPointer", api2, function(currTrigger, e2, dispatchAction3) {
      if (triggerOn !== "none" && (currTrigger === "leave" || triggerOn.indexOf(currTrigger) >= 0)) {
        dispatchAction3({
          type: "updateAxisPointer",
          currTrigger,
          x: e2 && e2.offsetX,
          y: e2 && e2.offsetY
        });
      }
    });
  }
  remove(ecModel, api2) {
    unregister("axisPointer", api2);
  }
  dispose(ecModel, api2) {
    unregister("axisPointer", api2);
  }
};
var AxisPointerView = AxisPointerView2;
AxisPointerView.type = "axisPointer";
var AxisPointerView_default = AxisPointerView;

// src/component/axisPointer/findPointFromSeries.ts
function findPointFromSeries(finder, ecModel) {
  let point = [];
  const seriesIndex = finder.seriesIndex;
  let seriesModel;
  if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
    return {
      point: []
    };
  }
  const data = seriesModel.getData();
  const dataIndex = queryDataIndex(data, finder);
  if (dataIndex == null || dataIndex < 0 || isArray(dataIndex)) {
    return {point: []};
  }
  const el = data.getItemGraphicEl(dataIndex);
  const coordSys = seriesModel.coordinateSystem;
  if (seriesModel.getTooltipPosition) {
    point = seriesModel.getTooltipPosition(dataIndex) || [];
  } else if (coordSys && coordSys.dataToPoint) {
    if (finder.isStacked) {
      const baseAxis = coordSys.getBaseAxis();
      const valueAxis2 = coordSys.getOtherAxis(baseAxis);
      const valueAxisDim = valueAxis2.dim;
      const baseAxisDim = baseAxis.dim;
      const baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
      const baseDim = data.mapDimension(baseAxisDim);
      const stackedData = [];
      stackedData[baseDataOffset] = data.get(baseDim, dataIndex);
      stackedData[1 - baseDataOffset] = data.get(data.getCalculationInfo("stackResultDimension"), dataIndex);
      point = coordSys.dataToPoint(stackedData) || [];
    } else {
      point = coordSys.dataToPoint(data.getValues(map(coordSys.dimensions, function(dim) {
        return data.mapDimension(dim);
      }), dataIndex)) || [];
    }
  } else if (el) {
    const rect = el.getBoundingRect().clone();
    rect.applyTransform(el.transform);
    point = [
      rect.x + rect.width / 2,
      rect.y + rect.height / 2
    ];
  }
  return {point, el};
}

// src/component/axisPointer/axisTrigger.ts
var inner15 = makeInner();
function axisTrigger(payload, ecModel, api2) {
  const currTrigger = payload.currTrigger;
  let point = [payload.x, payload.y];
  const finder = payload;
  const dispatchAction3 = payload.dispatchAction || bind(api2.dispatchAction, api2);
  const coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
  if (!coordSysAxesInfo) {
    return;
  }
  if (illegalPoint(point)) {
    point = findPointFromSeries({
      seriesIndex: finder.seriesIndex,
      dataIndex: finder.dataIndex
    }, ecModel).point;
  }
  const isIllegalPoint = illegalPoint(point);
  const inputAxesInfo = finder.axesInfo;
  const axesInfo = coordSysAxesInfo.axesInfo;
  const shouldHide = currTrigger === "leave" || illegalPoint(point);
  const outputPayload = {};
  const showValueMap = {};
  const dataByCoordSys = {
    list: [],
    map: {}
  };
  const updaters = {
    showPointer: curry(showPointer, showValueMap),
    showTooltip: curry(showTooltip, dataByCoordSys)
  };
  each(coordSysAxesInfo.coordSysMap, function(coordSys, coordSysKey) {
    const coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
    each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function(axisInfo, key) {
      const axis = axisInfo.axis;
      const inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);
      if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
        let val = inputAxisInfo && inputAxisInfo.value;
        if (val == null && !isIllegalPoint) {
          val = axis.pointToData(point);
        }
        val != null && processOnAxis(axisInfo, val, updaters, false, outputPayload);
      }
    });
  });
  const linkTriggers = {};
  each(axesInfo, function(tarAxisInfo, tarKey) {
    const linkGroup = tarAxisInfo.linkGroup;
    if (linkGroup && !showValueMap[tarKey]) {
      each(linkGroup.axesInfo, function(srcAxisInfo, srcKey) {
        const srcValItem = showValueMap[srcKey];
        if (srcAxisInfo !== tarAxisInfo && srcValItem) {
          let val = srcValItem.value;
          linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
          linkTriggers[tarAxisInfo.key] = val;
        }
      });
    }
  });
  each(linkTriggers, function(val, tarKey) {
    processOnAxis(axesInfo[tarKey], val, updaters, true, outputPayload);
  });
  updateModelActually(showValueMap, axesInfo, outputPayload);
  dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction3);
  dispatchHighDownActually(axesInfo, dispatchAction3, api2);
  return outputPayload;
}
function processOnAxis(axisInfo, newValue, updaters, noSnap, outputFinder) {
  const axis = axisInfo.axis;
  if (axis.scale.isBlank() || !axis.containData(newValue)) {
    return;
  }
  if (!axisInfo.involveSeries) {
    updaters.showPointer(axisInfo, newValue);
    return;
  }
  const payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
  const payloadBatch = payloadInfo.payloadBatch;
  const snapToValue = payloadInfo.snapToValue;
  if (payloadBatch[0] && outputFinder.seriesIndex == null) {
    extend(outputFinder, payloadBatch[0]);
  }
  if (!noSnap && axisInfo.snap) {
    if (axis.containData(snapToValue) && snapToValue != null) {
      newValue = snapToValue;
    }
  }
  updaters.showPointer(axisInfo, newValue, payloadBatch);
  updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
}
function buildPayloadsBySeries(value, axisInfo) {
  const axis = axisInfo.axis;
  const dim = axis.dim;
  let snapToValue = value;
  const payloadBatch = [];
  let minDist = Number.MAX_VALUE;
  let minDiff = -1;
  each(axisInfo.seriesModels, function(series, idx) {
    const dataDim = series.getData().mapDimensionsAll(dim);
    let seriesNestestValue;
    let dataIndices;
    if (series.getAxisTooltipData) {
      const result = series.getAxisTooltipData(dataDim, value, axis);
      dataIndices = result.dataIndices;
      seriesNestestValue = result.nestestValue;
    } else {
      dataIndices = series.indicesOfNearest(dim, dataDim[0], value, axis.type === "category" ? 0.5 : null);
      if (!dataIndices.length) {
        return;
      }
      seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
    }
    if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
      return;
    }
    const diff = value - seriesNestestValue;
    const dist3 = Math.abs(diff);
    if (dist3 <= minDist) {
      if (dist3 < minDist || diff >= 0 && minDiff < 0) {
        minDist = dist3;
        minDiff = diff;
        snapToValue = seriesNestestValue;
        payloadBatch.length = 0;
      }
      each(dataIndices, function(dataIndex) {
        payloadBatch.push({
          seriesIndex: series.seriesIndex,
          dataIndexInside: dataIndex,
          dataIndex: series.getData().getRawIndex(dataIndex)
        });
      });
    }
  });
  return {
    payloadBatch,
    snapToValue
  };
}
function showPointer(showValueMap, axisInfo, value, payloadBatch) {
  showValueMap[axisInfo.key] = {
    value,
    payloadBatch
  };
}
function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
  const payloadBatch = payloadInfo.payloadBatch;
  const axis = axisInfo.axis;
  const axisModel = axis.model;
  const axisPointerModel = axisInfo.axisPointerModel;
  if (!axisInfo.triggerTooltip || !payloadBatch.length) {
    return;
  }
  const coordSysModel = axisInfo.coordSys.model;
  const coordSysKey = makeKey(coordSysModel);
  let coordSysItem = dataByCoordSys.map[coordSysKey];
  if (!coordSysItem) {
    coordSysItem = dataByCoordSys.map[coordSysKey] = {
      coordSysId: coordSysModel.id,
      coordSysIndex: coordSysModel.componentIndex,
      coordSysType: coordSysModel.type,
      coordSysMainType: coordSysModel.mainType,
      dataByAxis: []
    };
    dataByCoordSys.list.push(coordSysItem);
  }
  coordSysItem.dataByAxis.push({
    axisDim: axis.dim,
    axisIndex: axisModel.componentIndex,
    axisType: axisModel.type,
    axisId: axisModel.id,
    value,
    valueLabelOpt: {
      precision: axisPointerModel.get(["label", "precision"]),
      formatter: axisPointerModel.get(["label", "formatter"])
    },
    seriesDataIndices: payloadBatch.slice()
  });
}
function updateModelActually(showValueMap, axesInfo, outputPayload) {
  const outputAxesInfo = outputPayload.axesInfo = [];
  each(axesInfo, function(axisInfo, key) {
    const option = axisInfo.axisPointerModel.option;
    const valItem = showValueMap[key];
    if (valItem) {
      !axisInfo.useHandle && (option.status = "show");
      option.value = valItem.value;
      option.seriesDataIndices = (valItem.payloadBatch || []).slice();
    } else {
      !axisInfo.useHandle && (option.status = "hide");
    }
    option.status === "show" && outputAxesInfo.push({
      axisDim: axisInfo.axis.dim,
      axisIndex: axisInfo.axis.model.componentIndex,
      value: option.value
    });
  });
}
function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction3) {
  if (illegalPoint(point) || !dataByCoordSys.list.length) {
    dispatchAction3({type: "hideTip"});
    return;
  }
  const sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  dispatchAction3({
    type: "showTip",
    escapeConnect: true,
    x: point[0],
    y: point[1],
    tooltipOption: payload.tooltipOption,
    position: payload.position,
    dataIndexInside: sampleItem.dataIndexInside,
    dataIndex: sampleItem.dataIndex,
    seriesIndex: sampleItem.seriesIndex,
    dataByCoordSys: dataByCoordSys.list
  });
}
function dispatchHighDownActually(axesInfo, dispatchAction3, api2) {
  const zr = api2.getZr();
  const highDownKey = "axisPointerLastHighlights";
  const lastHighlights = inner15(zr)[highDownKey] || {};
  const newHighlights = inner15(zr)[highDownKey] = {};
  each(axesInfo, function(axisInfo, key) {
    const option = axisInfo.axisPointerModel.option;
    option.status === "show" && axisInfo.triggerEmphasis && each(option.seriesDataIndices, function(batchItem) {
      const key2 = batchItem.seriesIndex + " | " + batchItem.dataIndex;
      newHighlights[key2] = batchItem;
    });
  });
  const toHighlight = [];
  const toDownplay = [];
  each(lastHighlights, function(batchItem, key) {
    !newHighlights[key] && toDownplay.push(batchItem);
  });
  each(newHighlights, function(batchItem, key) {
    !lastHighlights[key] && toHighlight.push(batchItem);
  });
  toDownplay.length && api2.dispatchAction({
    type: "downplay",
    escapeConnect: true,
    notBlur: true,
    batch: toDownplay
  });
  toHighlight.length && api2.dispatchAction({
    type: "highlight",
    escapeConnect: true,
    notBlur: true,
    batch: toHighlight
  });
}
function findInputAxisInfo(inputAxesInfo, axisInfo) {
  for (let i = 0; i < (inputAxesInfo || []).length; i++) {
    const inputAxisInfo = inputAxesInfo[i];
    if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
      return inputAxisInfo;
    }
  }
}
function makeMapperParam(axisInfo) {
  const axisModel = axisInfo.axis.model;
  const item = {};
  const dim = item.axisDim = axisInfo.axis.dim;
  item.axisIndex = item[dim + "AxisIndex"] = axisModel.componentIndex;
  item.axisName = item[dim + "AxisName"] = axisModel.name;
  item.axisId = item[dim + "AxisId"] = axisModel.id;
  return item;
}
function illegalPoint(point) {
  return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
}

// src/component/axisPointer/install.ts
function install30(registers) {
  AxisView_default.registerAxisPointerClass("CartesianAxisPointer", CartesianAxisPointer_default);
  registers.registerComponentModel(AxisPointerModel_default);
  registers.registerComponentView(AxisPointerView_default);
  registers.registerPreprocessor(function(option) {
    if (option) {
      (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
      const link = option.axisPointer.link;
      if (link && !isArray(link)) {
        option.axisPointer.link = [link];
      }
    }
  });
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, function(ecModel, api2) {
    ecModel.getComponent("axisPointer").coordSysAxesInfo = collect(ecModel, api2);
  });
  registers.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, axisTrigger);
}

// src/component/grid/install.ts
function install31(registers) {
  use(install6);
  use(install30);
}

// src/component/axisPointer/PolarAxisPointer.ts
var PolarAxisPointer = class extends BaseAxisPointer_default {
  makeElOption(elOption, value, axisModel, axisPointerModel, api2) {
    const axis = axisModel.axis;
    if (axis.dim === "angle") {
      this.animationThreshold = Math.PI / 18;
    }
    const polar = axis.polar;
    const otherAxis = polar.getOtherAxis(axis);
    const otherExtent = otherAxis.getExtent();
    const coordValue = axis.dataToCoord(value);
    const axisPointerType = axisPointerModel.get("type");
    if (axisPointerType && axisPointerType !== "none") {
      const elStyle = buildElStyle(axisPointerModel);
      const pointerOption = pointerShapeBuilder2[axisPointerType](axis, polar, coordValue, otherExtent);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }
    const labelMargin = axisPointerModel.get(["label", "margin"]);
    const labelPos = getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin);
    buildLabelElOption(elOption, axisModel, axisPointerModel, api2, labelPos);
  }
};
function getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin) {
  const axis = axisModel.axis;
  const coord = axis.dataToCoord(value);
  let axisAngle = polar.getAngleAxis().getExtent()[0];
  axisAngle = axisAngle / 180 * Math.PI;
  const radiusExtent = polar.getRadiusAxis().getExtent();
  let position2;
  let align;
  let verticalAlign;
  if (axis.dim === "radius") {
    const transform2 = create2();
    rotate(transform2, transform2, axisAngle);
    translate(transform2, transform2, [polar.cx, polar.cy]);
    position2 = applyTransform2([coord, -labelMargin], transform2);
    const labelRotation = axisModel.getModel("axisLabel").get("rotate") || 0;
    const labelLayout2 = AxisBuilder_default.innerTextLayout(axisAngle, labelRotation * Math.PI / 180, -1);
    align = labelLayout2.textAlign;
    verticalAlign = labelLayout2.textVerticalAlign;
  } else {
    const r = radiusExtent[1];
    position2 = polar.coordToPoint([r + labelMargin, coord]);
    const cx = polar.cx;
    const cy = polar.cy;
    align = Math.abs(position2[0] - cx) / r < 0.3 ? "center" : position2[0] > cx ? "left" : "right";
    verticalAlign = Math.abs(position2[1] - cy) / r < 0.3 ? "middle" : position2[1] > cy ? "top" : "bottom";
  }
  return {
    position: position2,
    align,
    verticalAlign
  };
}
var pointerShapeBuilder2 = {
  line: function(axis, polar, coordValue, otherExtent) {
    return axis.dim === "angle" ? {
      type: "Line",
      shape: makeLineShape(polar.coordToPoint([otherExtent[0], coordValue]), polar.coordToPoint([otherExtent[1], coordValue]))
    } : {
      type: "Circle",
      shape: {
        cx: polar.cx,
        cy: polar.cy,
        r: coordValue
      }
    };
  },
  shadow: function(axis, polar, coordValue, otherExtent) {
    const bandWidth = Math.max(1, axis.getBandWidth());
    const radian = Math.PI / 180;
    return axis.dim === "angle" ? {
      type: "Sector",
      shape: makeSectorShape(polar.cx, polar.cy, otherExtent[0], otherExtent[1], (-coordValue - bandWidth / 2) * radian, (-coordValue + bandWidth / 2) * radian)
    } : {
      type: "Sector",
      shape: makeSectorShape(polar.cx, polar.cy, coordValue - bandWidth / 2, coordValue + bandWidth / 2, 0, Math.PI * 2)
    };
  }
};
var PolarAxisPointer_default = PolarAxisPointer;

// src/coord/polar/PolarModel.ts
var PolarModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = PolarModel2.type;
  }
  findAxisModel(axisType) {
    let foundAxisModel;
    const ecModel = this.ecModel;
    ecModel.eachComponent(axisType, function(axisModel) {
      if (axisModel.getCoordSysModel() === this) {
        foundAxisModel = axisModel;
      }
    }, this);
    return foundAxisModel;
  }
};
var PolarModel = PolarModel2;
PolarModel.type = "polar";
PolarModel.dependencies = ["radiusAxis", "angleAxis"];
PolarModel.defaultOption = {
  z: 0,
  center: ["50%", "50%"],
  radius: "80%"
};
var PolarModel_default = PolarModel;

// src/coord/polar/AxisModel.ts
var PolarAxisModel = class extends Component_default {
  getCoordSysModel() {
    return this.getReferringComponents("polar", SINGLE_REFERRING).models[0];
  }
};
PolarAxisModel.type = "polarAxis";
mixin(PolarAxisModel, AxisModelCommonMixin);
var AngleAxisModel2 = class extends PolarAxisModel {
  constructor() {
    super(...arguments);
    this.type = AngleAxisModel2.type;
  }
};
var AngleAxisModel = AngleAxisModel2;
AngleAxisModel.type = "angleAxis";
var RadiusAxisModel2 = class extends PolarAxisModel {
  constructor() {
    super(...arguments);
    this.type = RadiusAxisModel2.type;
  }
};
var RadiusAxisModel = RadiusAxisModel2;
RadiusAxisModel.type = "radiusAxis";

// src/coord/polar/RadiusAxis.ts
var RadiusAxis = class extends Axis_default {
  constructor(scale4, radiusExtent) {
    super("radius", scale4, radiusExtent);
  }
  pointToData(point, clamp2) {
    return this.polar.pointToData(point, clamp2)[this.dim === "radius" ? 0 : 1];
  }
};
RadiusAxis.prototype.dataToRadius = Axis_default.prototype.dataToCoord;
RadiusAxis.prototype.radiusToData = Axis_default.prototype.coordToData;
var RadiusAxis_default = RadiusAxis;

// src/coord/polar/AngleAxis.ts
var inner16 = makeInner();
var AngleAxis = class extends Axis_default {
  constructor(scale4, angleExtent) {
    super("angle", scale4, angleExtent || [0, 360]);
  }
  pointToData(point, clamp2) {
    return this.polar.pointToData(point, clamp2)[this.dim === "radius" ? 0 : 1];
  }
  calculateCategoryInterval() {
    const axis = this;
    const labelModel = axis.getLabelModel();
    const ordinalScale = axis.scale;
    const ordinalExtent = ordinalScale.getExtent();
    const tickCount = ordinalScale.count();
    if (ordinalExtent[1] - ordinalExtent[0] < 1) {
      return 0;
    }
    const tickValue = ordinalExtent[0];
    const unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
    const unitH = Math.abs(unitSpan);
    const rect = getBoundingRect(tickValue == null ? "" : tickValue + "", labelModel.getFont(), "center", "top");
    const maxH = Math.max(rect.height, 7);
    let dh = maxH / unitH;
    isNaN(dh) && (dh = Infinity);
    let interval = Math.max(0, Math.floor(dh));
    const cache = inner16(axis.model);
    const lastAutoInterval = cache.lastAutoInterval;
    const lastTickCount = cache.lastTickCount;
    if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval) {
      interval = lastAutoInterval;
    } else {
      cache.lastTickCount = tickCount;
      cache.lastAutoInterval = interval;
    }
    return interval;
  }
};
AngleAxis.prototype.dataToAngle = Axis_default.prototype.dataToCoord;
AngleAxis.prototype.angleToData = Axis_default.prototype.coordToData;
var AngleAxis_default = AngleAxis;

// src/coord/polar/Polar.ts
var polarDimensions = ["radius", "angle"];
var Polar = class {
  constructor(name) {
    this.dimensions = polarDimensions;
    this.type = "polar";
    this.cx = 0;
    this.cy = 0;
    this._radiusAxis = new RadiusAxis_default();
    this._angleAxis = new AngleAxis_default();
    this.axisPointerEnabled = true;
    this.name = name || "";
    this._radiusAxis.polar = this._angleAxis.polar = this;
  }
  containPoint(point) {
    const coord = this.pointToCoord(point);
    return this._radiusAxis.contain(coord[0]) && this._angleAxis.contain(coord[1]);
  }
  containData(data) {
    return this._radiusAxis.containData(data[0]) && this._angleAxis.containData(data[1]);
  }
  getAxis(dim) {
    const key = "_" + dim + "Axis";
    return this[key];
  }
  getAxes() {
    return [this._radiusAxis, this._angleAxis];
  }
  getAxesByScale(scaleType) {
    const axes = [];
    const angleAxis = this._angleAxis;
    const radiusAxis = this._radiusAxis;
    angleAxis.scale.type === scaleType && axes.push(angleAxis);
    radiusAxis.scale.type === scaleType && axes.push(radiusAxis);
    return axes;
  }
  getAngleAxis() {
    return this._angleAxis;
  }
  getRadiusAxis() {
    return this._radiusAxis;
  }
  getOtherAxis(axis) {
    const angleAxis = this._angleAxis;
    return axis === angleAxis ? this._radiusAxis : angleAxis;
  }
  getBaseAxis() {
    return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
  }
  getTooltipAxes(dim) {
    const baseAxis = dim != null && dim !== "auto" ? this.getAxis(dim) : this.getBaseAxis();
    return {
      baseAxes: [baseAxis],
      otherAxes: [this.getOtherAxis(baseAxis)]
    };
  }
  dataToPoint(data, clamp2, out2) {
    return this.coordToPoint([
      this._radiusAxis.dataToRadius(data[0], clamp2),
      this._angleAxis.dataToAngle(data[1], clamp2)
    ], out2);
  }
  pointToData(point, clamp2, out2) {
    out2 = out2 || [];
    const coord = this.pointToCoord(point);
    out2[0] = this._radiusAxis.radiusToData(coord[0], clamp2);
    out2[1] = this._angleAxis.angleToData(coord[1], clamp2);
    return out2;
  }
  pointToCoord(point) {
    let dx = point[0] - this.cx;
    let dy = point[1] - this.cy;
    const angleAxis = this.getAngleAxis();
    const extent = angleAxis.getExtent();
    let minAngle = Math.min(extent[0], extent[1]);
    let maxAngle = Math.max(extent[0], extent[1]);
    angleAxis.inverse ? minAngle = maxAngle - 360 : maxAngle = minAngle + 360;
    const radius = Math.sqrt(dx * dx + dy * dy);
    dx /= radius;
    dy /= radius;
    let radian = Math.atan2(-dy, dx) / Math.PI * 180;
    const dir3 = radian < minAngle ? 1 : -1;
    while (radian < minAngle || radian > maxAngle) {
      radian += dir3 * 360;
    }
    return [radius, radian];
  }
  coordToPoint(coord, out2) {
    out2 = out2 || [];
    const radius = coord[0];
    const radian = coord[1] / 180 * Math.PI;
    out2[0] = Math.cos(radian) * radius + this.cx;
    out2[1] = -Math.sin(radian) * radius + this.cy;
    return out2;
  }
  getArea() {
    const angleAxis = this.getAngleAxis();
    const radiusAxis = this.getRadiusAxis();
    const radiusExtent = radiusAxis.getExtent().slice();
    radiusExtent[0] > radiusExtent[1] && radiusExtent.reverse();
    const angleExtent = angleAxis.getExtent();
    const RADIAN6 = Math.PI / 180;
    const EPSILON7 = 1e-4;
    return {
      cx: this.cx,
      cy: this.cy,
      r0: radiusExtent[0],
      r: radiusExtent[1],
      startAngle: -angleExtent[0] * RADIAN6,
      endAngle: -angleExtent[1] * RADIAN6,
      clockwise: angleAxis.inverse,
      contain(x, y) {
        const dx = x - this.cx;
        const dy = y - this.cy;
        const d2 = dx * dx + dy * dy;
        const r = this.r;
        const r0 = this.r0;
        return r !== r0 && d2 - EPSILON7 <= r * r && d2 + EPSILON7 >= r0 * r0;
      },
      x: this.cx - radiusExtent[1],
      y: this.cy - radiusExtent[1],
      width: radiusExtent[1] * 2,
      height: radiusExtent[1] * 2
    };
  }
  convertToPixel(ecModel, finder, value) {
    const coordSys = getCoordSys3(finder);
    return coordSys === this ? this.dataToPoint(value) : null;
  }
  convertFromPixel(ecModel, finder, pixel) {
    const coordSys = getCoordSys3(finder);
    return coordSys === this ? this.pointToData(pixel) : null;
  }
};
function getCoordSys3(finder) {
  const seriesModel = finder.seriesModel;
  const polarModel = finder.polarModel;
  return polarModel && polarModel.coordinateSystem || seriesModel && seriesModel.coordinateSystem;
}
var Polar_default = Polar;

// src/coord/polar/polarCreator.ts
function resizePolar(polar, polarModel, api2) {
  const center3 = polarModel.get("center");
  const refContainer = createBoxLayoutReference(polarModel, api2).refContainer;
  polar.cx = parsePercent2(center3[0], refContainer.width) + refContainer.x;
  polar.cy = parsePercent2(center3[1], refContainer.height) + refContainer.y;
  const radiusAxis = polar.getRadiusAxis();
  const size = Math.min(refContainer.width, refContainer.height) / 2;
  let radius = polarModel.get("radius");
  if (radius == null) {
    radius = [0, "100%"];
  } else if (!isArray(radius)) {
    radius = [0, radius];
  }
  const parsedRadius = [
    parsePercent2(radius[0], size),
    parsePercent2(radius[1], size)
  ];
  radiusAxis.inverse ? radiusAxis.setExtent(parsedRadius[1], parsedRadius[0]) : radiusAxis.setExtent(parsedRadius[0], parsedRadius[1]);
}
function updatePolarScale(ecModel, api2) {
  const polar = this;
  const angleAxis = polar.getAngleAxis();
  const radiusAxis = polar.getRadiusAxis();
  angleAxis.scale.setExtent(Infinity, -Infinity);
  radiusAxis.scale.setExtent(Infinity, -Infinity);
  ecModel.eachSeries(function(seriesModel) {
    if (seriesModel.coordinateSystem === polar) {
      const data = seriesModel.getData();
      each(getDataDimensionsOnAxis(data, "radius"), function(dim) {
        radiusAxis.scale.unionExtentFromData(data, dim);
      });
      each(getDataDimensionsOnAxis(data, "angle"), function(dim) {
        angleAxis.scale.unionExtentFromData(data, dim);
      });
    }
  });
  niceScaleExtent(angleAxis.scale, angleAxis.model);
  niceScaleExtent(radiusAxis.scale, radiusAxis.model);
  if (angleAxis.type === "category" && !angleAxis.onBand) {
    const extent = angleAxis.getExtent();
    const diff = 360 / angleAxis.scale.count();
    angleAxis.inverse ? extent[1] += diff : extent[1] -= diff;
    angleAxis.setExtent(extent[0], extent[1]);
  }
}
function isAngleAxisModel(axisModel) {
  return axisModel.mainType === "angleAxis";
}
function setAxis(axis, axisModel) {
  axis.type = axisModel.get("type");
  axis.scale = createScaleByModel(axisModel);
  axis.onBand = axisModel.get("boundaryGap") && axis.type === "category";
  axis.inverse = axisModel.get("inverse");
  if (isAngleAxisModel(axisModel)) {
    axis.inverse = axis.inverse !== axisModel.get("clockwise");
    const startAngle = axisModel.get("startAngle");
    const endAngle = axisModel.get("endAngle") ?? startAngle + (axis.inverse ? -360 : 360);
    axis.setExtent(startAngle, endAngle);
  }
  axisModel.axis = axis;
  axis.model = axisModel;
}
var polarCreator = {
  dimensions: polarDimensions,
  create: function(ecModel, api2) {
    const polarList = [];
    ecModel.eachComponent("polar", function(polarModel, idx) {
      const polar = new Polar_default(idx + "");
      polar.update = updatePolarScale;
      const radiusAxis = polar.getRadiusAxis();
      const angleAxis = polar.getAngleAxis();
      const radiusAxisModel = polarModel.findAxisModel("radiusAxis");
      const angleAxisModel = polarModel.findAxisModel("angleAxis");
      setAxis(radiusAxis, radiusAxisModel);
      setAxis(angleAxis, angleAxisModel);
      resizePolar(polar, polarModel, api2);
      polarList.push(polar);
      polarModel.coordinateSystem = polar;
      polar.model = polarModel;
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.get("coordinateSystem") === "polar") {
        const polarModel = seriesModel.getReferringComponents("polar", SINGLE_REFERRING).models[0];
        if (true) {
          if (!polarModel) {
            throw new Error('Polar "' + retrieve(seriesModel.get("polarIndex"), seriesModel.get("polarId"), 0) + '" not found');
          }
        }
        seriesModel.coordinateSystem = polarModel.coordinateSystem;
      }
    });
    return polarList;
  }
};
var polarCreator_default = polarCreator;

// src/component/axis/AngleAxisView.ts
var elementList = [
  "axisLine",
  "axisLabel",
  "axisTick",
  "minorTick",
  "splitLine",
  "minorSplitLine",
  "splitArea"
];
function getAxisLineShape(polar, rExtent, angle) {
  rExtent[1] > rExtent[0] && (rExtent = rExtent.slice().reverse());
  const start2 = polar.coordToPoint([rExtent[0], angle]);
  const end2 = polar.coordToPoint([rExtent[1], angle]);
  return {
    x1: start2[0],
    y1: start2[1],
    x2: end2[0],
    y2: end2[1]
  };
}
function getRadiusIdx(polar) {
  const radiusAxis = polar.getRadiusAxis();
  return radiusAxis.inverse ? 0 : 1;
}
function fixAngleOverlap(list) {
  const firstItem = list[0];
  const lastItem = list[list.length - 1];
  if (firstItem && lastItem && Math.abs(Math.abs(firstItem.coord - lastItem.coord) - 360) < 1e-4) {
    list.pop();
  }
}
var AngleAxisView2 = class extends AxisView_default {
  constructor() {
    super(...arguments);
    this.type = AngleAxisView2.type;
    this.axisPointerClass = "PolarAxisPointer";
  }
  render(angleAxisModel, ecModel) {
    this.group.removeAll();
    if (!angleAxisModel.get("show")) {
      return;
    }
    const angleAxis = angleAxisModel.axis;
    const polar = angleAxis.polar;
    const radiusExtent = polar.getRadiusAxis().getExtent();
    const ticksAngles = angleAxis.getTicksCoords({breakTicks: "none"});
    const minorTickAngles = angleAxis.getMinorTicksCoords();
    const labels = map(angleAxis.getViewLabels(), function(labelItem) {
      labelItem = clone(labelItem);
      const scale4 = angleAxis.scale;
      const tickValue = scale4.type === "ordinal" ? scale4.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;
      labelItem.coord = angleAxis.dataToCoord(tickValue);
      return labelItem;
    });
    fixAngleOverlap(labels);
    fixAngleOverlap(ticksAngles);
    each(elementList, function(name) {
      if (angleAxisModel.get([name, "show"]) && (!angleAxis.scale.isBlank() || name === "axisLine")) {
        angelAxisElementsBuilders[name](this.group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels);
      }
    }, this);
  }
};
var AngleAxisView = AngleAxisView2;
AngleAxisView.type = "angleAxis";
var angelAxisElementsBuilders = {
  axisLine(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    const lineStyleModel = angleAxisModel.getModel(["axisLine", "lineStyle"]);
    const angleAxis = polar.getAngleAxis();
    const RADIAN6 = Math.PI / 180;
    const angleExtent = angleAxis.getExtent();
    const rId = getRadiusIdx(polar);
    const r0Id = rId ? 0 : 1;
    let shape;
    const shapeType = Math.abs(angleExtent[1] - angleExtent[0]) === 360 ? "Circle" : "Arc";
    if (radiusExtent[r0Id] === 0) {
      shape = new graphic_exports[shapeType]({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r: radiusExtent[rId],
          startAngle: -angleExtent[0] * RADIAN6,
          endAngle: -angleExtent[1] * RADIAN6,
          clockwise: angleAxis.inverse
        },
        style: lineStyleModel.getLineStyle(),
        z2: 1,
        silent: true
      });
    } else {
      shape = new Ring_default({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r: radiusExtent[rId],
          r0: radiusExtent[r0Id]
        },
        style: lineStyleModel.getLineStyle(),
        z2: 1,
        silent: true
      });
    }
    shape.style.fill = null;
    group.add(shape);
  },
  axisTick(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    const tickModel = angleAxisModel.getModel("axisTick");
    const tickLen = (tickModel.get("inside") ? -1 : 1) * tickModel.get("length");
    const radius = radiusExtent[getRadiusIdx(polar)];
    const lines = map(ticksAngles, function(tickAngleItem) {
      return new Line_default({
        shape: getAxisLineShape(polar, [radius, radius + tickLen], tickAngleItem.coord)
      });
    });
    group.add(mergePath2(lines, {
      style: defaults(tickModel.getModel("lineStyle").getLineStyle(), {
        stroke: angleAxisModel.get(["axisLine", "lineStyle", "color"])
      })
    }));
  },
  minorTick(group, angleAxisModel, polar, tickAngles, minorTickAngles, radiusExtent) {
    if (!minorTickAngles.length) {
      return;
    }
    const tickModel = angleAxisModel.getModel("axisTick");
    const minorTickModel = angleAxisModel.getModel("minorTick");
    const tickLen = (tickModel.get("inside") ? -1 : 1) * minorTickModel.get("length");
    const radius = radiusExtent[getRadiusIdx(polar)];
    const lines = [];
    for (let i = 0; i < minorTickAngles.length; i++) {
      for (let k = 0; k < minorTickAngles[i].length; k++) {
        lines.push(new Line_default({
          shape: getAxisLineShape(polar, [radius, radius + tickLen], minorTickAngles[i][k].coord)
        }));
      }
    }
    group.add(mergePath2(lines, {
      style: defaults(minorTickModel.getModel("lineStyle").getLineStyle(), defaults(tickModel.getLineStyle(), {
        stroke: angleAxisModel.get(["axisLine", "lineStyle", "color"])
      }))
    }));
  },
  axisLabel(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels) {
    const rawCategoryData = angleAxisModel.getCategories(true);
    const commonLabelModel = angleAxisModel.getModel("axisLabel");
    const labelMargin = commonLabelModel.get("margin");
    const triggerEvent = angleAxisModel.get("triggerEvent");
    each(labels, function(labelItem, idx) {
      let labelModel = commonLabelModel;
      const tickValue = labelItem.tickValue;
      const r = radiusExtent[getRadiusIdx(polar)];
      const p = polar.coordToPoint([r + labelMargin, labelItem.coord]);
      const cx = polar.cx;
      const cy = polar.cy;
      const labelTextAlign = Math.abs(p[0] - cx) / r < 0.3 ? "center" : p[0] > cx ? "left" : "right";
      const labelTextVerticalAlign = Math.abs(p[1] - cy) / r < 0.3 ? "middle" : p[1] > cy ? "top" : "bottom";
      if (rawCategoryData && rawCategoryData[tickValue]) {
        const rawCategoryItem = rawCategoryData[tickValue];
        if (isObject(rawCategoryItem) && rawCategoryItem.textStyle) {
          labelModel = new Model_default(rawCategoryItem.textStyle, commonLabelModel, commonLabelModel.ecModel);
        }
      }
      const textEl = new Text_default({
        silent: AxisBuilder_default.isLabelSilent(angleAxisModel),
        style: createTextStyle(labelModel, {
          x: p[0],
          y: p[1],
          fill: labelModel.getTextColor() || angleAxisModel.get(["axisLine", "lineStyle", "color"]),
          text: labelItem.formattedLabel,
          align: labelTextAlign,
          verticalAlign: labelTextVerticalAlign
        })
      });
      group.add(textEl);
      setTooltipConfig({
        el: textEl,
        componentModel: angleAxisModel,
        itemName: labelItem.formattedLabel,
        formatterParamsExtra: {
          isTruncated: () => textEl.isTruncated,
          value: labelItem.rawLabel,
          tickIndex: idx
        }
      });
      if (triggerEvent) {
        const eventData = AxisBuilder_default.makeAxisEventDataBase(angleAxisModel);
        eventData.targetType = "axisLabel";
        eventData.value = labelItem.rawLabel;
        getECData(textEl).eventData = eventData;
      }
    }, this);
  },
  splitLine(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    const splitLineModel = angleAxisModel.getModel("splitLine");
    const lineStyleModel = splitLineModel.getModel("lineStyle");
    let lineColors = lineStyleModel.get("color");
    let lineCount = 0;
    lineColors = lineColors instanceof Array ? lineColors : [lineColors];
    const splitLines = [];
    for (let i = 0; i < ticksAngles.length; i++) {
      const colorIndex = lineCount++ % lineColors.length;
      splitLines[colorIndex] = splitLines[colorIndex] || [];
      splitLines[colorIndex].push(new Line_default({
        shape: getAxisLineShape(polar, radiusExtent, ticksAngles[i].coord)
      }));
    }
    for (let i = 0; i < splitLines.length; i++) {
      group.add(mergePath2(splitLines[i], {
        style: defaults({
          stroke: lineColors[i % lineColors.length]
        }, lineStyleModel.getLineStyle()),
        silent: true,
        z: angleAxisModel.get("z")
      }));
    }
  },
  minorSplitLine(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    if (!minorTickAngles.length) {
      return;
    }
    const minorSplitLineModel = angleAxisModel.getModel("minorSplitLine");
    const lineStyleModel = minorSplitLineModel.getModel("lineStyle");
    const lines = [];
    for (let i = 0; i < minorTickAngles.length; i++) {
      for (let k = 0; k < minorTickAngles[i].length; k++) {
        lines.push(new Line_default({
          shape: getAxisLineShape(polar, radiusExtent, minorTickAngles[i][k].coord)
        }));
      }
    }
    group.add(mergePath2(lines, {
      style: lineStyleModel.getLineStyle(),
      silent: true,
      z: angleAxisModel.get("z")
    }));
  },
  splitArea(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    if (!ticksAngles.length) {
      return;
    }
    const splitAreaModel = angleAxisModel.getModel("splitArea");
    const areaStyleModel = splitAreaModel.getModel("areaStyle");
    let areaColors = areaStyleModel.get("color");
    let lineCount = 0;
    areaColors = areaColors instanceof Array ? areaColors : [areaColors];
    const splitAreas = [];
    const RADIAN6 = Math.PI / 180;
    let prevAngle = -ticksAngles[0].coord * RADIAN6;
    const r0 = Math.min(radiusExtent[0], radiusExtent[1]);
    const r1 = Math.max(radiusExtent[0], radiusExtent[1]);
    const clockwise = angleAxisModel.get("clockwise");
    for (let i = 1, len2 = ticksAngles.length; i <= len2; i++) {
      const coord = i === len2 ? ticksAngles[0].coord : ticksAngles[i].coord;
      const colorIndex = lineCount++ % areaColors.length;
      splitAreas[colorIndex] = splitAreas[colorIndex] || [];
      splitAreas[colorIndex].push(new Sector_default({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r0,
          r: r1,
          startAngle: prevAngle,
          endAngle: -coord * RADIAN6,
          clockwise
        },
        silent: true
      }));
      prevAngle = -coord * RADIAN6;
    }
    for (let i = 0; i < splitAreas.length; i++) {
      group.add(mergePath2(splitAreas[i], {
        style: defaults({
          fill: areaColors[i % areaColors.length]
        }, areaStyleModel.getAreaStyle()),
        silent: true
      }));
    }
  }
};
var AngleAxisView_default = AngleAxisView;

// src/component/axis/RadiusAxisView.ts
var selfBuilderAttrs2 = [
  "splitLine",
  "splitArea",
  "minorSplitLine"
];
var RadiusAxisView2 = class extends AxisView_default {
  constructor() {
    super(...arguments);
    this.type = RadiusAxisView2.type;
    this.axisPointerClass = "PolarAxisPointer";
  }
  render(radiusAxisModel, ecModel, api2) {
    this.group.removeAll();
    if (!radiusAxisModel.get("show")) {
      return;
    }
    const oldAxisGroup = this._axisGroup;
    const newAxisGroup = this._axisGroup = new Group_default();
    this.group.add(newAxisGroup);
    const radiusAxis = radiusAxisModel.axis;
    const polar = radiusAxis.polar;
    const angleAxis = polar.getAngleAxis();
    const ticksCoords = radiusAxis.getTicksCoords();
    const minorTicksCoords = radiusAxis.getMinorTicksCoords();
    const axisAngle = angleAxis.getExtent()[0];
    const radiusExtent = radiusAxis.getExtent();
    const layout14 = layoutAxis(polar, radiusAxisModel, axisAngle);
    const axisBuilder = new AxisBuilder_default(radiusAxisModel, api2, layout14);
    axisBuilder.build();
    newAxisGroup.add(axisBuilder.group);
    groupTransition(oldAxisGroup, newAxisGroup, radiusAxisModel);
    each(selfBuilderAttrs2, function(name) {
      if (radiusAxisModel.get([name, "show"]) && !radiusAxis.scale.isBlank()) {
        axisElementBuilders2[name](this.group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords);
      }
    }, this);
  }
};
var RadiusAxisView = RadiusAxisView2;
RadiusAxisView.type = "radiusAxis";
var axisElementBuilders2 = {
  splitLine(group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
    const splitLineModel = radiusAxisModel.getModel("splitLine");
    const lineStyleModel = splitLineModel.getModel("lineStyle");
    let lineColors = lineStyleModel.get("color");
    let lineCount = 0;
    const angleAxis = polar.getAngleAxis();
    const RADIAN6 = Math.PI / 180;
    const angleExtent = angleAxis.getExtent();
    const shapeType = Math.abs(angleExtent[1] - angleExtent[0]) === 360 ? "Circle" : "Arc";
    lineColors = lineColors instanceof Array ? lineColors : [lineColors];
    const splitLines = [];
    for (let i = 0; i < ticksCoords.length; i++) {
      const colorIndex = lineCount++ % lineColors.length;
      splitLines[colorIndex] = splitLines[colorIndex] || [];
      splitLines[colorIndex].push(new graphic_exports[shapeType]({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r: Math.max(ticksCoords[i].coord, 0),
          startAngle: -angleExtent[0] * RADIAN6,
          endAngle: -angleExtent[1] * RADIAN6,
          clockwise: angleAxis.inverse
        }
      }));
    }
    for (let i = 0; i < splitLines.length; i++) {
      group.add(mergePath2(splitLines[i], {
        style: defaults({
          stroke: lineColors[i % lineColors.length],
          fill: null
        }, lineStyleModel.getLineStyle()),
        silent: true
      }));
    }
  },
  minorSplitLine(group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords) {
    if (!minorTicksCoords.length) {
      return;
    }
    const minorSplitLineModel = radiusAxisModel.getModel("minorSplitLine");
    const lineStyleModel = minorSplitLineModel.getModel("lineStyle");
    const lines = [];
    for (let i = 0; i < minorTicksCoords.length; i++) {
      for (let k = 0; k < minorTicksCoords[i].length; k++) {
        lines.push(new Circle_default({
          shape: {
            cx: polar.cx,
            cy: polar.cy,
            r: minorTicksCoords[i][k].coord
          }
        }));
      }
    }
    group.add(mergePath2(lines, {
      style: defaults({
        fill: null
      }, lineStyleModel.getLineStyle()),
      silent: true
    }));
  },
  splitArea(group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
    if (!ticksCoords.length) {
      return;
    }
    const splitAreaModel = radiusAxisModel.getModel("splitArea");
    const areaStyleModel = splitAreaModel.getModel("areaStyle");
    let areaColors = areaStyleModel.get("color");
    let lineCount = 0;
    areaColors = areaColors instanceof Array ? areaColors : [areaColors];
    const splitAreas = [];
    let prevRadius = ticksCoords[0].coord;
    for (let i = 1; i < ticksCoords.length; i++) {
      const colorIndex = lineCount++ % areaColors.length;
      splitAreas[colorIndex] = splitAreas[colorIndex] || [];
      splitAreas[colorIndex].push(new Sector_default({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r0: prevRadius,
          r: ticksCoords[i].coord,
          startAngle: 0,
          endAngle: Math.PI * 2
        },
        silent: true
      }));
      prevRadius = ticksCoords[i].coord;
    }
    for (let i = 0; i < splitAreas.length; i++) {
      group.add(mergePath2(splitAreas[i], {
        style: defaults({
          fill: areaColors[i % areaColors.length]
        }, areaStyleModel.getAreaStyle()),
        silent: true
      }));
    }
  }
};
function layoutAxis(polar, radiusAxisModel, axisAngle) {
  return {
    position: [polar.cx, polar.cy],
    rotation: axisAngle / 180 * Math.PI,
    labelDirection: -1,
    tickDirection: -1,
    nameDirection: 1,
    labelRotate: radiusAxisModel.getModel("axisLabel").get("rotate"),
    z2: 1
  };
}
var RadiusAxisView_default = RadiusAxisView;

// src/layout/barPolar.ts
function getSeriesStackId2(seriesModel) {
  return seriesModel.get("stack") || "__ec_stack_" + seriesModel.seriesIndex;
}
function getAxisKey2(polar, axis) {
  return axis.dim + polar.model.componentIndex;
}
function barLayoutPolar(seriesType2, ecModel, api2) {
  const lastStackCoords = {};
  const barWidthAndOffset = calRadialBar(filter(ecModel.getSeriesByType(seriesType2), function(seriesModel) {
    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "polar";
  }));
  ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
    if (seriesModel.coordinateSystem.type !== "polar") {
      return;
    }
    const data = seriesModel.getData();
    const polar = seriesModel.coordinateSystem;
    const baseAxis = polar.getBaseAxis();
    const axisKey = getAxisKey2(polar, baseAxis);
    const stackId = getSeriesStackId2(seriesModel);
    const columnLayoutInfo = barWidthAndOffset[axisKey][stackId];
    const columnOffset = columnLayoutInfo.offset;
    const columnWidth = columnLayoutInfo.width;
    const valueAxis2 = polar.getOtherAxis(baseAxis);
    const cx = seriesModel.coordinateSystem.cx;
    const cy = seriesModel.coordinateSystem.cy;
    const barMinHeight = seriesModel.get("barMinHeight") || 0;
    const barMinAngle = seriesModel.get("barMinAngle") || 0;
    lastStackCoords[stackId] = lastStackCoords[stackId] || [];
    const valueDim = data.mapDimension(valueAxis2.dim);
    const baseDim = data.mapDimension(baseAxis.dim);
    const stacked = isDimensionStacked(data, valueDim);
    const clampLayout = baseAxis.dim !== "radius" || !seriesModel.get("roundCap", true);
    const valueAxisModel = valueAxis2.model;
    const startValue = valueAxisModel.get("startValue");
    const valueAxisStart = valueAxis2.dataToCoord(startValue || 0);
    for (let idx = 0, len2 = data.count(); idx < len2; idx++) {
      const value = data.get(valueDim, idx);
      const baseValue = data.get(baseDim, idx);
      const sign = value >= 0 ? "p" : "n";
      let baseCoord = valueAxisStart;
      if (stacked) {
        if (!lastStackCoords[stackId][baseValue]) {
          lastStackCoords[stackId][baseValue] = {
            p: valueAxisStart,
            n: valueAxisStart
          };
        }
        baseCoord = lastStackCoords[stackId][baseValue][sign];
      }
      let r0;
      let r;
      let startAngle;
      let endAngle;
      if (valueAxis2.dim === "radius") {
        let radiusSpan = valueAxis2.dataToCoord(value) - valueAxisStart;
        const angle = baseAxis.dataToCoord(baseValue);
        if (Math.abs(radiusSpan) < barMinHeight) {
          radiusSpan = (radiusSpan < 0 ? -1 : 1) * barMinHeight;
        }
        r0 = baseCoord;
        r = baseCoord + radiusSpan;
        startAngle = angle - columnOffset;
        endAngle = startAngle - columnWidth;
        stacked && (lastStackCoords[stackId][baseValue][sign] = r);
      } else {
        let angleSpan = valueAxis2.dataToCoord(value, clampLayout) - valueAxisStart;
        const radius = baseAxis.dataToCoord(baseValue);
        if (Math.abs(angleSpan) < barMinAngle) {
          angleSpan = (angleSpan < 0 ? -1 : 1) * barMinAngle;
        }
        r0 = radius + columnOffset;
        r = r0 + columnWidth;
        startAngle = baseCoord;
        endAngle = baseCoord + angleSpan;
        stacked && (lastStackCoords[stackId][baseValue][sign] = endAngle);
      }
      data.setItemLayout(idx, {
        cx,
        cy,
        r0,
        r,
        startAngle: -startAngle * Math.PI / 180,
        endAngle: -endAngle * Math.PI / 180,
        clockwise: startAngle >= endAngle
      });
    }
  });
}
function calRadialBar(barSeries) {
  const columnsMap = {};
  each(barSeries, function(seriesModel, idx) {
    const data = seriesModel.getData();
    const polar = seriesModel.coordinateSystem;
    const baseAxis = polar.getBaseAxis();
    const axisKey = getAxisKey2(polar, baseAxis);
    const axisExtent = baseAxis.getExtent();
    const bandWidth = baseAxis.type === "category" ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
    const columnsOnAxis = columnsMap[axisKey] || {
      bandWidth,
      remainedWidth: bandWidth,
      autoWidthCount: 0,
      categoryGap: "20%",
      gap: "30%",
      stacks: {}
    };
    const stacks = columnsOnAxis.stacks;
    columnsMap[axisKey] = columnsOnAxis;
    const stackId = getSeriesStackId2(seriesModel);
    if (!stacks[stackId]) {
      columnsOnAxis.autoWidthCount++;
    }
    stacks[stackId] = stacks[stackId] || {
      width: 0,
      maxWidth: 0
    };
    let barWidth = parsePercent2(seriesModel.get("barWidth"), bandWidth);
    const barMaxWidth = parsePercent2(seriesModel.get("barMaxWidth"), bandWidth);
    const barGap = seriesModel.get("barGap");
    const barCategoryGap = seriesModel.get("barCategoryGap");
    if (barWidth && !stacks[stackId].width) {
      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
      stacks[stackId].width = barWidth;
      columnsOnAxis.remainedWidth -= barWidth;
    }
    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
    barGap != null && (columnsOnAxis.gap = barGap);
    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
  });
  const result = {};
  each(columnsMap, function(columnsOnAxis, coordSysName) {
    result[coordSysName] = {};
    const stacks = columnsOnAxis.stacks;
    const bandWidth = columnsOnAxis.bandWidth;
    const categoryGap = parsePercent2(columnsOnAxis.categoryGap, bandWidth);
    const barGapPercent = parsePercent2(columnsOnAxis.gap, 1);
    let remainedWidth = columnsOnAxis.remainedWidth;
    let autoWidthCount = columnsOnAxis.autoWidthCount;
    let autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    each(stacks, function(column, stack) {
      let maxWidth = column.maxWidth;
      if (maxWidth && maxWidth < autoWidth) {
        maxWidth = Math.min(maxWidth, remainedWidth);
        if (column.width) {
          maxWidth = Math.min(maxWidth, column.width);
        }
        remainedWidth -= maxWidth;
        column.width = maxWidth;
        autoWidthCount--;
      }
    });
    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    let widthSum = 0;
    let lastColumn;
    each(stacks, function(column, idx) {
      if (!column.width) {
        column.width = autoWidth;
      }
      lastColumn = column;
      widthSum += column.width * (1 + barGapPercent);
    });
    if (lastColumn) {
      widthSum -= lastColumn.width * barGapPercent;
    }
    let offset = -widthSum / 2;
    each(stacks, function(column, stackId) {
      result[coordSysName][stackId] = result[coordSysName][stackId] || {
        offset,
        width: column.width
      };
      offset += column.width * (1 + barGapPercent);
    });
  });
  return result;
}
var barPolar_default = barLayoutPolar;

// src/component/polar/install.ts
var angleAxisExtraOption = {
  startAngle: 90,
  clockwise: true,
  splitNumber: 12,
  axisLabel: {
    rotate: 0
  }
};
var radiusAxisExtraOption = {
  splitNumber: 5
};
var PolarView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = PolarView2.type;
  }
};
var PolarView = PolarView2;
PolarView.type = "polar";
function install32(registers) {
  use(install30);
  AxisView_default.registerAxisPointerClass("PolarAxisPointer", PolarAxisPointer_default);
  registers.registerCoordinateSystem("polar", polarCreator_default);
  registers.registerComponentModel(PolarModel_default);
  registers.registerComponentView(PolarView);
  axisModelCreator(registers, "angle", AngleAxisModel, angleAxisExtraOption);
  axisModelCreator(registers, "radius", RadiusAxisModel, radiusAxisExtraOption);
  registers.registerComponentView(AngleAxisView_default);
  registers.registerComponentView(RadiusAxisView_default);
  registers.registerLayout(curry(barPolar_default, "bar"));
}

// src/coord/single/singleAxisHelper.ts
function layout8(axisModel, opt) {
  opt = opt || {};
  const single = axisModel.coordinateSystem;
  const axis = axisModel.axis;
  const layout14 = {};
  const axisPosition = axis.position;
  const orient = axis.orient;
  const rect = single.getRect();
  const rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
  const positionMap = {
    horizontal: {top: rectBound[2], bottom: rectBound[3]},
    vertical: {left: rectBound[0], right: rectBound[1]}
  };
  layout14.position = [
    orient === "vertical" ? positionMap.vertical[axisPosition] : rectBound[0],
    orient === "horizontal" ? positionMap.horizontal[axisPosition] : rectBound[3]
  ];
  const r = {horizontal: 0, vertical: 1};
  layout14.rotation = Math.PI / 2 * r[orient];
  const directionMap = {top: -1, bottom: 1, right: 1, left: -1};
  layout14.labelDirection = layout14.tickDirection = layout14.nameDirection = directionMap[axisPosition];
  if (axisModel.get(["axisTick", "inside"])) {
    layout14.tickDirection = -layout14.tickDirection;
  }
  if (retrieve(opt.labelInside, axisModel.get(["axisLabel", "inside"]))) {
    layout14.labelDirection = -layout14.labelDirection;
  }
  const labelRotate = axisModel.get(["axisLabel", "rotate"]);
  layout14.labelRotate = axisPosition === "top" ? -labelRotate : labelRotate;
  layout14.z2 = 1;
  return layout14;
}

// src/component/axis/SingleAxisView.ts
var selfBuilderAttrs3 = ["splitArea", "splitLine", "breakArea"];
var SingleAxisView2 = class extends AxisView_default {
  constructor() {
    super(...arguments);
    this.type = SingleAxisView2.type;
    this.axisPointerClass = "SingleAxisPointer";
  }
  render(axisModel, ecModel, api2, payload) {
    const group = this.group;
    group.removeAll();
    const oldAxisGroup = this._axisGroup;
    this._axisGroup = new Group_default();
    const layout14 = layout8(axisModel);
    const axisBuilder = new AxisBuilder_default(axisModel, api2, layout14);
    axisBuilder.build();
    group.add(this._axisGroup);
    group.add(axisBuilder.group);
    each(selfBuilderAttrs3, function(name) {
      if (axisModel.get([name, "show"])) {
        axisElementBuilders3[name](this, this.group, this._axisGroup, axisModel, api2);
      }
    }, this);
    groupTransition(oldAxisGroup, this._axisGroup, axisModel);
    super.render(axisModel, ecModel, api2, payload);
  }
  remove() {
    rectCoordAxisHandleRemove(this);
  }
};
var SingleAxisView = SingleAxisView2;
SingleAxisView.type = "singleAxis";
var axisElementBuilders3 = {
  splitLine(axisView, group, axisGroup, axisModel, api2) {
    const axis = axisModel.axis;
    if (axis.scale.isBlank()) {
      return;
    }
    const splitLineModel = axisModel.getModel("splitLine");
    const lineStyleModel = splitLineModel.getModel("lineStyle");
    let lineColors = lineStyleModel.get("color");
    lineColors = lineColors instanceof Array ? lineColors : [lineColors];
    const lineWidth = lineStyleModel.get("width");
    const gridRect = axisModel.coordinateSystem.getRect();
    const isHorizontal = axis.isHorizontal();
    const splitLines = [];
    let lineCount = 0;
    const ticksCoords = axis.getTicksCoords({
      tickModel: splitLineModel,
      breakTicks: "none",
      pruneByBreak: "preserve_extent_bound"
    });
    const p1 = [];
    const p2 = [];
    for (let i = 0; i < ticksCoords.length; ++i) {
      const tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
      if (isHorizontal) {
        p1[0] = tickCoord;
        p1[1] = gridRect.y;
        p2[0] = tickCoord;
        p2[1] = gridRect.y + gridRect.height;
      } else {
        p1[0] = gridRect.x;
        p1[1] = tickCoord;
        p2[0] = gridRect.x + gridRect.width;
        p2[1] = tickCoord;
      }
      const line2 = new Line_default({
        shape: {
          x1: p1[0],
          y1: p1[1],
          x2: p2[0],
          y2: p2[1]
        },
        silent: true
      });
      subPixelOptimizeLine2(line2.shape, lineWidth);
      const colorIndex = lineCount++ % lineColors.length;
      splitLines[colorIndex] = splitLines[colorIndex] || [];
      splitLines[colorIndex].push(line2);
    }
    const lineStyle = lineStyleModel.getLineStyle(["color"]);
    for (let i = 0; i < splitLines.length; ++i) {
      group.add(mergePath2(splitLines[i], {
        style: defaults({
          stroke: lineColors[i % lineColors.length]
        }, lineStyle),
        silent: true
      }));
    }
  },
  splitArea(axisView, group, axisGroup, axisModel, api2) {
    rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, axisModel);
  },
  breakArea(axisView, group, axisGroup, axisModel, api2) {
    const axisBreakHelper = getAxisBreakHelper();
    const scale4 = axisModel.axis.scale;
    if (axisBreakHelper && scale4.type !== "ordinal") {
      axisBreakHelper.rectCoordBuildBreakAxis(group, axisView, axisModel, axisModel.coordinateSystem.getRect(), api2);
    }
  }
};
var SingleAxisView_default = SingleAxisView;

// src/coord/single/AxisModel.ts
var SingleAxisModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = SingleAxisModel2.type;
  }
  getCoordSysModel() {
    return this;
  }
};
var SingleAxisModel = SingleAxisModel2;
SingleAxisModel.type = "singleAxis";
SingleAxisModel.layoutMode = "box";
SingleAxisModel.defaultOption = {
  left: "5%",
  top: "5%",
  right: "5%",
  bottom: "5%",
  type: "value",
  position: "bottom",
  orient: "horizontal",
  axisLine: {
    show: true,
    lineStyle: {
      width: 1,
      type: "solid"
    }
  },
  tooltip: {
    show: true
  },
  axisTick: {
    show: true,
    length: 6,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: true,
    interval: "auto"
  },
  splitLine: {
    show: true,
    lineStyle: {
      type: "dashed",
      opacity: 0.2
    }
  },
  jitter: 0,
  jitterOverlap: true,
  jitterMargin: 2
};
mixin(SingleAxisModel, AxisModelCommonMixin.prototype);
var AxisModel_default2 = SingleAxisModel;

// src/coord/single/SingleAxis.ts
var SingleAxis = class extends Axis_default {
  constructor(dim, scale4, coordExtent, axisType, position2) {
    super(dim, scale4, coordExtent);
    this.type = axisType || "value";
    this.position = position2 || "bottom";
  }
  isHorizontal() {
    const position2 = this.position;
    return position2 === "top" || position2 === "bottom";
  }
  pointToData(point, clamp2) {
    return this.coordinateSystem.pointToData(point)[0];
  }
};
var SingleAxis_default = SingleAxis;

// src/coord/single/Single.ts
var singleDimensions = ["single"];
var Single = class {
  constructor(axisModel, ecModel, api2) {
    this.type = "single";
    this.dimension = "single";
    this.dimensions = singleDimensions;
    this.axisPointerEnabled = true;
    this.model = axisModel;
    this._init(axisModel, ecModel, api2);
  }
  _init(axisModel, ecModel, api2) {
    const dim = this.dimension;
    const axis = new SingleAxis_default(dim, createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisModel.get("position"));
    const isCategory2 = axis.type === "category";
    axis.onBand = isCategory2 && axisModel.get("boundaryGap");
    axis.inverse = axisModel.get("inverse");
    axis.orient = axisModel.get("orient");
    axisModel.axis = axis;
    axis.model = axisModel;
    axis.coordinateSystem = this;
    this._axis = axis;
  }
  update(ecModel, api2) {
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.coordinateSystem === this) {
        const data = seriesModel.getData();
        each(data.mapDimensionsAll(this.dimension), function(dim) {
          this._axis.scale.unionExtentFromData(data, dim);
        }, this);
        niceScaleExtent(this._axis.scale, this._axis.model);
      }
    }, this);
  }
  resize(axisModel, api2) {
    const refContainer = createBoxLayoutReference(axisModel, api2).refContainer;
    this._rect = getLayoutRect(axisModel.getBoxLayoutParams(), refContainer);
    this._adjustAxis();
  }
  getRect() {
    return this._rect;
  }
  _adjustAxis() {
    const rect = this._rect;
    const axis = this._axis;
    const isHorizontal = axis.isHorizontal();
    const extent = isHorizontal ? [0, rect.width] : [0, rect.height];
    const idx = axis.inverse ? 1 : 0;
    axis.setExtent(extent[idx], extent[1 - idx]);
    this._updateAxisTransform(axis, isHorizontal ? rect.x : rect.y);
  }
  _updateAxisTransform(axis, coordBase) {
    const axisExtent = axis.getExtent();
    const extentSum = axisExtent[0] + axisExtent[1];
    const isHorizontal = axis.isHorizontal();
    axis.toGlobalCoord = isHorizontal ? function(coord) {
      return coord + coordBase;
    } : function(coord) {
      return extentSum - coord + coordBase;
    };
    axis.toLocalCoord = isHorizontal ? function(coord) {
      return coord - coordBase;
    } : function(coord) {
      return extentSum - coord + coordBase;
    };
  }
  getAxis() {
    return this._axis;
  }
  getBaseAxis() {
    return this._axis;
  }
  getAxes() {
    return [this._axis];
  }
  getTooltipAxes() {
    return {
      baseAxes: [this.getAxis()],
      otherAxes: []
    };
  }
  containPoint(point) {
    const rect = this.getRect();
    const axis = this.getAxis();
    const orient = axis.orient;
    if (orient === "horizontal") {
      return axis.contain(axis.toLocalCoord(point[0])) && (point[1] >= rect.y && point[1] <= rect.y + rect.height);
    } else {
      return axis.contain(axis.toLocalCoord(point[1])) && (point[0] >= rect.y && point[0] <= rect.y + rect.height);
    }
  }
  pointToData(point, reserved, out2) {
    out2 = out2 || [];
    const axis = this.getAxis();
    out2[0] = axis.coordToData(axis.toLocalCoord(point[axis.orient === "horizontal" ? 0 : 1]));
    return out2;
  }
  dataToPoint(val, reserved, out2) {
    const axis = this.getAxis();
    const rect = this.getRect();
    out2 = out2 || [];
    const idx = axis.orient === "horizontal" ? 0 : 1;
    if (val instanceof Array) {
      val = val[0];
    }
    out2[idx] = axis.toGlobalCoord(axis.dataToCoord(+val));
    out2[1 - idx] = idx === 0 ? rect.y + rect.height / 2 : rect.x + rect.width / 2;
    return out2;
  }
  convertToPixel(ecModel, finder, value) {
    const coordSys = getCoordSys4(finder);
    return coordSys === this ? this.dataToPoint(value) : null;
  }
  convertFromPixel(ecModel, finder, pixel) {
    const coordSys = getCoordSys4(finder);
    return coordSys === this ? this.pointToData(pixel) : null;
  }
};
function getCoordSys4(finder) {
  const seriesModel = finder.seriesModel;
  const singleModel = finder.singleAxisModel;
  return singleModel && singleModel.coordinateSystem || seriesModel && seriesModel.coordinateSystem;
}
var Single_default = Single;

// src/coord/single/singleCreator.ts
function create3(ecModel, api2) {
  const singles = [];
  ecModel.eachComponent("singleAxis", function(axisModel, idx) {
    const single = new Single_default(axisModel, ecModel, api2);
    single.name = "single_" + idx;
    single.resize(axisModel, api2);
    axisModel.coordinateSystem = single;
    singles.push(single);
  });
  ecModel.eachSeries(function(seriesModel) {
    if (seriesModel.get("coordinateSystem") === "singleAxis") {
      const singleAxisModel = seriesModel.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
      seriesModel.coordinateSystem = singleAxisModel && singleAxisModel.coordinateSystem;
    }
  });
  return singles;
}
var singleCreator = {
  create: create3,
  dimensions: singleDimensions
};
var singleCreator_default = singleCreator;

// src/component/axisPointer/SingleAxisPointer.ts
var XY3 = ["x", "y"];
var WH3 = ["width", "height"];
var SingleAxisPointer = class extends BaseAxisPointer_default {
  makeElOption(elOption, value, axisModel, axisPointerModel, api2) {
    const axis = axisModel.axis;
    const coordSys = axis.coordinateSystem;
    const otherExtent = getGlobalExtent(coordSys, 1 - getPointDimIndex(axis));
    const pixelValue = coordSys.dataToPoint(value)[0];
    const axisPointerType = axisPointerModel.get("type");
    if (axisPointerType && axisPointerType !== "none") {
      const elStyle = buildElStyle(axisPointerModel);
      const pointerOption = pointerShapeBuilder3[axisPointerType](axis, pixelValue, otherExtent);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }
    const layoutInfo = layout8(axisModel);
    buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api2);
  }
  getHandleTransform(value, axisModel, axisPointerModel) {
    const layoutInfo = layout8(axisModel, {labelInside: false});
    layoutInfo.labelMargin = axisPointerModel.get(["handle", "margin"]);
    const position2 = getTransformedPosition(axisModel.axis, value, layoutInfo);
    return {
      x: position2[0],
      y: position2[1],
      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
    };
  }
  updateHandleTransform(transform2, delta, axisModel, axisPointerModel) {
    const axis = axisModel.axis;
    const coordSys = axis.coordinateSystem;
    const dimIndex = getPointDimIndex(axis);
    const axisExtent = getGlobalExtent(coordSys, dimIndex);
    const currPosition = [transform2.x, transform2.y];
    currPosition[dimIndex] += delta[dimIndex];
    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
    const otherExtent = getGlobalExtent(coordSys, 1 - dimIndex);
    const cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
    const cursorPoint = [cursorOtherValue, cursorOtherValue];
    cursorPoint[dimIndex] = currPosition[dimIndex];
    return {
      x: currPosition[0],
      y: currPosition[1],
      rotation: transform2.rotation,
      cursorPoint,
      tooltipOption: {
        verticalAlign: "middle"
      }
    };
  }
};
var pointerShapeBuilder3 = {
  line: function(axis, pixelValue, otherExtent) {
    const targetShape = makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getPointDimIndex(axis));
    return {
      type: "Line",
      subPixelOptimize: true,
      shape: targetShape
    };
  },
  shadow: function(axis, pixelValue, otherExtent) {
    const bandWidth = axis.getBandWidth();
    const span = otherExtent[1] - otherExtent[0];
    return {
      type: "Rect",
      shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getPointDimIndex(axis))
    };
  }
};
function getPointDimIndex(axis) {
  return axis.isHorizontal() ? 0 : 1;
}
function getGlobalExtent(coordSys, dimIndex) {
  const rect = coordSys.getRect();
  return [rect[XY3[dimIndex]], rect[XY3[dimIndex]] + rect[WH3[dimIndex]]];
}
var SingleAxisPointer_default = SingleAxisPointer;

// src/component/singleAxis/install.ts
var SingleView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = SingleView2.type;
  }
};
var SingleView = SingleView2;
SingleView.type = "single";
function install33(registers) {
  use(install30);
  AxisView_default.registerAxisPointerClass("SingleAxisPointer", SingleAxisPointer_default);
  registers.registerComponentView(SingleView);
  registers.registerComponentView(SingleAxisView_default);
  registers.registerComponentModel(AxisModel_default2);
  axisModelCreator(registers, "single", AxisModel_default2, AxisModel_default2.defaultOption);
  registers.registerCoordinateSystem("single", singleCreator_default);
}

// src/coord/calendar/CalendarModel.ts
var CalendarModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = CalendarModel2.type;
  }
  init(option, parentModel, ecModel) {
    const inputPositionParams = getLayoutParams(option);
    super.init.apply(this, arguments);
    mergeAndNormalizeLayoutParams(option, inputPositionParams);
  }
  mergeOption(option) {
    super.mergeOption.apply(this, arguments);
    mergeAndNormalizeLayoutParams(this.option, option);
  }
  getCellSize() {
    return this.option.cellSize;
  }
};
var CalendarModel = CalendarModel2;
CalendarModel.type = "calendar";
CalendarModel.layoutMode = "box";
CalendarModel.defaultOption = {
  z: 2,
  left: 80,
  top: 60,
  cellSize: 20,
  orient: "horizontal",
  splitLine: {
    show: true,
    lineStyle: {
      color: tokens_default.color.axisLine,
      width: 1,
      type: "solid"
    }
  },
  itemStyle: {
    color: tokens_default.color.neutral00,
    borderWidth: 1,
    borderColor: tokens_default.color.neutral10
  },
  dayLabel: {
    show: true,
    firstDay: 0,
    position: "start",
    margin: tokens_default.size.s,
    color: tokens_default.color.secondary
  },
  monthLabel: {
    show: true,
    position: "start",
    margin: tokens_default.size.s,
    align: "center",
    formatter: null,
    color: tokens_default.color.secondary
  },
  yearLabel: {
    show: true,
    position: null,
    margin: tokens_default.size.xl,
    formatter: null,
    color: tokens_default.color.quaternary,
    fontFamily: "sans-serif",
    fontWeight: "bolder",
    fontSize: 20
  }
};
function mergeAndNormalizeLayoutParams(target, raw) {
  const cellSize = target.cellSize;
  let cellSizeArr;
  if (!isArray(cellSize)) {
    cellSizeArr = target.cellSize = [cellSize, cellSize];
  } else {
    cellSizeArr = cellSize;
  }
  if (cellSizeArr.length === 1) {
    cellSizeArr[1] = cellSizeArr[0];
  }
  const ignoreSize = map([0, 1], function(hvIdx) {
    if (sizeCalculable(raw, hvIdx)) {
      cellSizeArr[hvIdx] = "auto";
    }
    return cellSizeArr[hvIdx] != null && cellSizeArr[hvIdx] !== "auto";
  });
  mergeLayoutParam(target, raw, {
    type: "box",
    ignoreSize
  });
}
var CalendarModel_default = CalendarModel;

// src/component/calendar/CalendarView.ts
var CalendarView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = CalendarView2.type;
  }
  render(calendarModel, ecModel, api2) {
    const group = this.group;
    group.removeAll();
    const coordSys = calendarModel.coordinateSystem;
    const rangeData = coordSys.getRangeInfo();
    const orient = coordSys.getOrient();
    const localeModel = ecModel.getLocaleModel();
    this._renderDayRect(calendarModel, rangeData, group);
    this._renderLines(calendarModel, rangeData, orient, group);
    this._renderYearText(calendarModel, rangeData, orient, group);
    this._renderMonthText(calendarModel, localeModel, orient, group);
    this._renderWeekText(calendarModel, localeModel, rangeData, orient, group);
  }
  _renderDayRect(calendarModel, rangeData, group) {
    const coordSys = calendarModel.coordinateSystem;
    const itemRectStyleModel = calendarModel.getModel("itemStyle").getItemStyle();
    const sw = coordSys.getCellWidth();
    const sh = coordSys.getCellHeight();
    for (let i = rangeData.start.time; i <= rangeData.end.time; i = coordSys.getNextNDay(i, 1).time) {
      const point = coordSys.dataToCalendarLayout([i], false).tl;
      const rect = new Rect_default({
        shape: {
          x: point[0],
          y: point[1],
          width: sw,
          height: sh
        },
        cursor: "default",
        style: itemRectStyleModel
      });
      group.add(rect);
    }
  }
  _renderLines(calendarModel, rangeData, orient, group) {
    const self2 = this;
    const coordSys = calendarModel.coordinateSystem;
    const lineStyleModel = calendarModel.getModel(["splitLine", "lineStyle"]).getLineStyle();
    const show = calendarModel.get(["splitLine", "show"]);
    const lineWidth = lineStyleModel.lineWidth;
    this._tlpoints = [];
    this._blpoints = [];
    this._firstDayOfMonth = [];
    this._firstDayPoints = [];
    let firstDay = rangeData.start;
    for (let i = 0; firstDay.time <= rangeData.end.time; i++) {
      addPoints(firstDay.formatedDate);
      if (i === 0) {
        firstDay = coordSys.getDateInfo(rangeData.start.y + "-" + rangeData.start.m);
      }
      const date = firstDay.date;
      date.setMonth(date.getMonth() + 1);
      firstDay = coordSys.getDateInfo(date);
    }
    addPoints(coordSys.getNextNDay(rangeData.end.time, 1).formatedDate);
    function addPoints(date) {
      self2._firstDayOfMonth.push(coordSys.getDateInfo(date));
      self2._firstDayPoints.push(coordSys.dataToCalendarLayout([date], false).tl);
      const points4 = self2._getLinePointsOfOneWeek(calendarModel, date, orient);
      self2._tlpoints.push(points4[0]);
      self2._blpoints.push(points4[points4.length - 1]);
      show && self2._drawSplitline(points4, lineStyleModel, group);
    }
    show && this._drawSplitline(self2._getEdgesPoints(self2._tlpoints, lineWidth, orient), lineStyleModel, group);
    show && this._drawSplitline(self2._getEdgesPoints(self2._blpoints, lineWidth, orient), lineStyleModel, group);
  }
  _getEdgesPoints(points4, lineWidth, orient) {
    const rs = [points4[0].slice(), points4[points4.length - 1].slice()];
    const idx = orient === "horizontal" ? 0 : 1;
    rs[0][idx] = rs[0][idx] - lineWidth / 2;
    rs[1][idx] = rs[1][idx] + lineWidth / 2;
    return rs;
  }
  _drawSplitline(points4, lineStyle, group) {
    const poyline = new Polyline_default({
      z2: 20,
      shape: {
        points: points4
      },
      style: lineStyle
    });
    group.add(poyline);
  }
  _getLinePointsOfOneWeek(calendarModel, date, orient) {
    const coordSys = calendarModel.coordinateSystem;
    const parsedDate = coordSys.getDateInfo(date);
    const points4 = [];
    for (let i = 0; i < 7; i++) {
      const tmpD = coordSys.getNextNDay(parsedDate.time, i);
      const point = coordSys.dataToCalendarLayout([tmpD.time], false);
      points4[2 * tmpD.day] = point.tl;
      points4[2 * tmpD.day + 1] = point[orient === "horizontal" ? "bl" : "tr"];
    }
    return points4;
  }
  _formatterLabel(formatter, params) {
    if (isString(formatter) && formatter) {
      return formatTplSimple(formatter, params);
    }
    if (isFunction(formatter)) {
      return formatter(params);
    }
    return params.nameMap;
  }
  _yearTextPositionControl(textEl, point, orient, position2, margin) {
    let x = point[0];
    let y = point[1];
    let aligns = ["center", "bottom"];
    if (position2 === "bottom") {
      y += margin;
      aligns = ["center", "top"];
    } else if (position2 === "left") {
      x -= margin;
    } else if (position2 === "right") {
      x += margin;
      aligns = ["center", "top"];
    } else {
      y -= margin;
    }
    let rotate2 = 0;
    if (position2 === "left" || position2 === "right") {
      rotate2 = Math.PI / 2;
    }
    return {
      rotation: rotate2,
      x,
      y,
      style: {
        align: aligns[0],
        verticalAlign: aligns[1]
      }
    };
  }
  _renderYearText(calendarModel, rangeData, orient, group) {
    const yearLabel = calendarModel.getModel("yearLabel");
    if (!yearLabel.get("show")) {
      return;
    }
    const margin = yearLabel.get("margin");
    let pos = yearLabel.get("position");
    if (!pos) {
      pos = orient !== "horizontal" ? "top" : "left";
    }
    const points4 = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]];
    const xc = (points4[0][0] + points4[1][0]) / 2;
    const yc = (points4[0][1] + points4[1][1]) / 2;
    const idx = orient === "horizontal" ? 0 : 1;
    const posPoints = {
      top: [xc, points4[idx][1]],
      bottom: [xc, points4[1 - idx][1]],
      left: [points4[1 - idx][0], yc],
      right: [points4[idx][0], yc]
    };
    let name = rangeData.start.y;
    if (+rangeData.end.y > +rangeData.start.y) {
      name = name + "-" + rangeData.end.y;
    }
    const formatter = yearLabel.get("formatter");
    const params = {
      start: rangeData.start.y,
      end: rangeData.end.y,
      nameMap: name
    };
    const content = this._formatterLabel(formatter, params);
    const yearText = new Text_default({
      z2: 30,
      style: createTextStyle(yearLabel, {
        text: content
      }),
      silent: yearLabel.get("silent")
    });
    yearText.attr(this._yearTextPositionControl(yearText, posPoints[pos], orient, pos, margin));
    group.add(yearText);
  }
  _monthTextPositionControl(point, isCenter, orient, position2, margin) {
    let align = "left";
    let vAlign = "top";
    let x = point[0];
    let y = point[1];
    if (orient === "horizontal") {
      y = y + margin;
      if (isCenter) {
        align = "center";
      }
      if (position2 === "start") {
        vAlign = "bottom";
      }
    } else {
      x = x + margin;
      if (isCenter) {
        vAlign = "middle";
      }
      if (position2 === "start") {
        align = "right";
      }
    }
    return {
      x,
      y,
      align,
      verticalAlign: vAlign
    };
  }
  _renderMonthText(calendarModel, localeModel, orient, group) {
    const monthLabel = calendarModel.getModel("monthLabel");
    if (!monthLabel.get("show")) {
      return;
    }
    let nameMap = monthLabel.get("nameMap");
    let margin = monthLabel.get("margin");
    const pos = monthLabel.get("position");
    const align = monthLabel.get("align");
    const termPoints = [this._tlpoints, this._blpoints];
    if (!nameMap || isString(nameMap)) {
      if (nameMap) {
        localeModel = getLocaleModel(nameMap) || localeModel;
      }
      nameMap = localeModel.get(["time", "monthAbbr"]) || [];
    }
    const idx = pos === "start" ? 0 : 1;
    const axis = orient === "horizontal" ? 0 : 1;
    margin = pos === "start" ? -margin : margin;
    const isCenter = align === "center";
    const labelSilent = monthLabel.get("silent");
    for (let i = 0; i < termPoints[idx].length - 1; i++) {
      const tmp = termPoints[idx][i].slice();
      const firstDay = this._firstDayOfMonth[i];
      if (isCenter) {
        const firstDayPoints = this._firstDayPoints[i];
        tmp[axis] = (firstDayPoints[axis] + termPoints[0][i + 1][axis]) / 2;
      }
      const formatter = monthLabel.get("formatter");
      const name = nameMap[+firstDay.m - 1];
      const params = {
        yyyy: firstDay.y,
        yy: (firstDay.y + "").slice(2),
        MM: firstDay.m,
        M: +firstDay.m,
        nameMap: name
      };
      const content = this._formatterLabel(formatter, params);
      const monthText = new Text_default({
        z2: 30,
        style: extend(createTextStyle(monthLabel, {text: content}), this._monthTextPositionControl(tmp, isCenter, orient, pos, margin)),
        silent: labelSilent
      });
      group.add(monthText);
    }
  }
  _weekTextPositionControl(point, orient, position2, margin, cellSize) {
    let align = "center";
    let vAlign = "middle";
    let x = point[0];
    let y = point[1];
    const isStart = position2 === "start";
    if (orient === "horizontal") {
      x = x + margin + (isStart ? 1 : -1) * cellSize[0] / 2;
      align = isStart ? "right" : "left";
    } else {
      y = y + margin + (isStart ? 1 : -1) * cellSize[1] / 2;
      vAlign = isStart ? "bottom" : "top";
    }
    return {
      x,
      y,
      align,
      verticalAlign: vAlign
    };
  }
  _renderWeekText(calendarModel, localeModel, rangeData, orient, group) {
    const dayLabel = calendarModel.getModel("dayLabel");
    if (!dayLabel.get("show")) {
      return;
    }
    const coordSys = calendarModel.coordinateSystem;
    const pos = dayLabel.get("position");
    let nameMap = dayLabel.get("nameMap");
    let margin = dayLabel.get("margin");
    const firstDayOfWeek = coordSys.getFirstDayOfWeek();
    if (!nameMap || isString(nameMap)) {
      if (nameMap) {
        localeModel = getLocaleModel(nameMap) || localeModel;
      }
      const dayOfWeekShort = localeModel.get(["time", "dayOfWeekShort"]);
      nameMap = dayOfWeekShort || map(localeModel.get(["time", "dayOfWeekAbbr"]), (val) => val[0]);
    }
    let start2 = coordSys.getNextNDay(rangeData.end.time, 7 - rangeData.lweek).time;
    const cellSize = [coordSys.getCellWidth(), coordSys.getCellHeight()];
    margin = parsePercent2(margin, Math.min(cellSize[1], cellSize[0]));
    if (pos === "start") {
      start2 = coordSys.getNextNDay(rangeData.start.time, -(7 + rangeData.fweek)).time;
      margin = -margin;
    }
    const labelSilent = dayLabel.get("silent");
    for (let i = 0; i < 7; i++) {
      const tmpD = coordSys.getNextNDay(start2, i);
      const point = coordSys.dataToCalendarLayout([tmpD.time], false).center;
      let day = i;
      day = Math.abs((i + firstDayOfWeek) % 7);
      const weekText = new Text_default({
        z2: 30,
        style: extend(createTextStyle(dayLabel, {text: nameMap[day]}), this._weekTextPositionControl(point, orient, pos, margin, cellSize)),
        silent: labelSilent
      });
      group.add(weekText);
    }
  }
};
var CalendarView = CalendarView2;
CalendarView.type = "calendar";
var CalendarView_default = CalendarView;

// src/coord/calendar/Calendar.ts
var PROXIMATE_ONE_DAY = 864e5;
var Calendar2 = class {
  constructor(calendarModel, ecModel, api2) {
    this.type = "calendar";
    this.dimensions = Calendar2.dimensions;
    this.getDimensionsInfo = Calendar2.getDimensionsInfo;
    this._model = calendarModel;
    this._update(ecModel, api2);
  }
  static getDimensionsInfo() {
    return [{
      name: "time",
      type: "time"
    }, "value"];
  }
  getRangeInfo() {
    return this._rangeInfo;
  }
  getModel() {
    return this._model;
  }
  getRect() {
    return this._rect;
  }
  getCellWidth() {
    return this._sw;
  }
  getCellHeight() {
    return this._sh;
  }
  getOrient() {
    return this._orient;
  }
  getFirstDayOfWeek() {
    return this._firstDayOfWeek;
  }
  getDateInfo(date) {
    date = parseDate(date);
    const y = date.getFullYear();
    const m2 = date.getMonth() + 1;
    const mStr = m2 < 10 ? "0" + m2 : "" + m2;
    const d = date.getDate();
    const dStr = d < 10 ? "0" + d : "" + d;
    let day = date.getDay();
    day = Math.abs((day + 7 - this.getFirstDayOfWeek()) % 7);
    return {
      y: y + "",
      m: mStr,
      d: dStr,
      day,
      time: date.getTime(),
      formatedDate: y + "-" + mStr + "-" + dStr,
      date
    };
  }
  getNextNDay(date, n) {
    n = n || 0;
    if (n === 0) {
      return this.getDateInfo(date);
    }
    date = new Date(this.getDateInfo(date).time);
    date.setDate(date.getDate() + n);
    return this.getDateInfo(date);
  }
  _update(ecModel, api2) {
    this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay");
    this._orient = this._model.get("orient");
    this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0;
    this._rangeInfo = this._getRangeInfo(this._initRangeOption());
    const weeks = this._rangeInfo.weeks || 1;
    const whNames = ["width", "height"];
    const cellSize = this._model.getCellSize().slice();
    const layoutParams = this._model.getBoxLayoutParams();
    const cellNumbers = this._orient === "horizontal" ? [weeks, 7] : [7, weeks];
    each([0, 1], function(idx) {
      if (cellSizeSpecified(cellSize, idx)) {
        layoutParams[whNames[idx]] = cellSize[idx] * cellNumbers[idx];
      }
    });
    const whGlobal = {
      width: api2.getWidth(),
      height: api2.getHeight()
    };
    const calendarRect = this._rect = getLayoutRect(layoutParams, whGlobal);
    each([0, 1], function(idx) {
      if (!cellSizeSpecified(cellSize, idx)) {
        cellSize[idx] = calendarRect[whNames[idx]] / cellNumbers[idx];
      }
    });
    function cellSizeSpecified(cellSize2, idx) {
      return cellSize2[idx] != null && cellSize2[idx] !== "auto";
    }
    this._sw = cellSize[0];
    this._sh = cellSize[1];
  }
  dataToPoint(data, clamp2, out2) {
    out2 = out2 || [];
    isArray(data) && (data = data[0]);
    clamp2 == null && (clamp2 = true);
    const dayInfo = this.getDateInfo(data);
    const range = this._rangeInfo;
    const date = dayInfo.formatedDate;
    if (clamp2 && !(dayInfo.time >= range.start.time && dayInfo.time < range.end.time + PROXIMATE_ONE_DAY)) {
      out2[0] = out2[1] = NaN;
      return out2;
    }
    const week = dayInfo.day;
    const nthWeek = this._getRangeInfo([range.start.time, date]).nthWeek;
    if (this._orient === "vertical") {
      out2[0] = this._rect.x + week * this._sw + this._sw / 2;
      out2[1] = this._rect.y + nthWeek * this._sh + this._sh / 2;
    } else {
      out2[0] = this._rect.x + nthWeek * this._sw + this._sw / 2;
      out2[1] = this._rect.y + week * this._sh + this._sh / 2;
    }
    return out2;
  }
  pointToData(point) {
    const date = this.pointToDate(point);
    return date && date.time;
  }
  dataToLayout(data, clamp2, out2) {
    out2 = out2 || {};
    const rect = out2.rect = out2.rect || {};
    const contentRect = out2.contentRect = out2.contentRect || {};
    const point = this.dataToPoint(data, clamp2);
    rect.x = point[0] - this._sw / 2;
    rect.y = point[1] - this._sh / 2;
    rect.width = this._sw;
    rect.height = this._sh;
    BoundingRect_default.copy(contentRect, rect);
    expandOrShrinkRect(contentRect, this._lineWidth / 2, true, true);
    return out2;
  }
  dataToCalendarLayout(data, clamp2) {
    const point = this.dataToPoint(data, clamp2);
    return {
      center: point,
      tl: [
        point[0] - this._sw / 2,
        point[1] - this._sh / 2
      ],
      tr: [
        point[0] + this._sw / 2,
        point[1] - this._sh / 2
      ],
      br: [
        point[0] + this._sw / 2,
        point[1] + this._sh / 2
      ],
      bl: [
        point[0] - this._sw / 2,
        point[1] + this._sh / 2
      ]
    };
  }
  pointToDate(point) {
    const nthX = Math.floor((point[0] - this._rect.x) / this._sw) + 1;
    const nthY = Math.floor((point[1] - this._rect.y) / this._sh) + 1;
    const range = this._rangeInfo.range;
    if (this._orient === "vertical") {
      return this._getDateByWeeksAndDay(nthY, nthX - 1, range);
    }
    return this._getDateByWeeksAndDay(nthX, nthY - 1, range);
  }
  convertToPixel(ecModel, finder, value) {
    const coordSys = getCoordSys5(finder);
    return coordSys === this ? coordSys.dataToPoint(value) : null;
  }
  convertToLayout(ecModel, finder, value) {
    const coordSys = getCoordSys5(finder);
    return coordSys === this ? coordSys.dataToLayout(value) : null;
  }
  convertFromPixel(ecModel, finder, pixel) {
    const coordSys = getCoordSys5(finder);
    return coordSys === this ? coordSys.pointToData(pixel) : null;
  }
  containPoint(point) {
    console.warn("Not implemented.");
    return false;
  }
  _initRangeOption() {
    let range = this._model.get("range");
    let normalizedRange;
    if (isArray(range) && range.length === 1) {
      range = range[0];
    }
    if (!isArray(range)) {
      const rangeStr = range.toString();
      if (/^\d{4}$/.test(rangeStr)) {
        normalizedRange = [rangeStr + "-01-01", rangeStr + "-12-31"];
      }
      if (/^\d{4}[\/|-]\d{1,2}$/.test(rangeStr)) {
        const start2 = this.getDateInfo(rangeStr);
        const firstDay = start2.date;
        firstDay.setMonth(firstDay.getMonth() + 1);
        const end2 = this.getNextNDay(firstDay, -1);
        normalizedRange = [start2.formatedDate, end2.formatedDate];
      }
      if (/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(rangeStr)) {
        normalizedRange = [rangeStr, rangeStr];
      }
    } else {
      normalizedRange = range;
    }
    if (!normalizedRange) {
      if (true) {
        logError("Invalid date range.");
      }
      return range;
    }
    const tmp = this._getRangeInfo(normalizedRange);
    if (tmp.start.time > tmp.end.time) {
      normalizedRange.reverse();
    }
    return normalizedRange;
  }
  _getRangeInfo(range) {
    const parsedRange = [
      this.getDateInfo(range[0]),
      this.getDateInfo(range[1])
    ];
    let reversed;
    if (parsedRange[0].time > parsedRange[1].time) {
      reversed = true;
      parsedRange.reverse();
    }
    let allDay = Math.floor(parsedRange[1].time / PROXIMATE_ONE_DAY) - Math.floor(parsedRange[0].time / PROXIMATE_ONE_DAY) + 1;
    const date = new Date(parsedRange[0].time);
    const startDateNum = date.getDate();
    const endDateNum = parsedRange[1].date.getDate();
    date.setDate(startDateNum + allDay - 1);
    let dateNum = date.getDate();
    if (dateNum !== endDateNum) {
      const sign = date.getTime() - parsedRange[1].time > 0 ? 1 : -1;
      while ((dateNum = date.getDate()) !== endDateNum && (date.getTime() - parsedRange[1].time) * sign > 0) {
        allDay -= sign;
        date.setDate(dateNum - sign);
      }
    }
    const weeks = Math.floor((allDay + parsedRange[0].day + 6) / 7);
    const nthWeek = reversed ? -weeks + 1 : weeks - 1;
    reversed && parsedRange.reverse();
    return {
      range: [parsedRange[0].formatedDate, parsedRange[1].formatedDate],
      start: parsedRange[0],
      end: parsedRange[1],
      allDay,
      weeks,
      nthWeek,
      fweek: parsedRange[0].day,
      lweek: parsedRange[1].day
    };
  }
  _getDateByWeeksAndDay(nthWeek, day, range) {
    const rangeInfo = this._getRangeInfo(range);
    if (nthWeek > rangeInfo.weeks || nthWeek === 0 && day < rangeInfo.fweek || nthWeek === rangeInfo.weeks && day > rangeInfo.lweek) {
      return null;
    }
    const nthDay = (nthWeek - 1) * 7 - rangeInfo.fweek + day;
    const date = new Date(rangeInfo.start.time);
    date.setDate(+rangeInfo.start.d + nthDay);
    return this.getDateInfo(date);
  }
  static create(ecModel, api2) {
    const calendarList = [];
    ecModel.eachComponent("calendar", function(calendarModel) {
      const calendar = new Calendar2(calendarModel, ecModel, api2);
      calendarList.push(calendar);
      calendarModel.coordinateSystem = calendar;
    });
    ecModel.eachComponent((mainType, componentModel) => {
      injectCoordSysByOption({
        targetModel: componentModel,
        coordSysType: "calendar",
        coordSysProvider: simpleCoordSysInjectionProvider
      });
    });
    return calendarList;
  }
};
var Calendar = Calendar2;
Calendar.dimensions = ["time", "value"];
function getCoordSys5(finder) {
  const calendarModel = finder.calendarModel;
  const seriesModel = finder.seriesModel;
  const coordSys = calendarModel ? calendarModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem : null;
  return coordSys;
}
var Calendar_default = Calendar;

// src/component/calendar/install.ts
function install34(registers) {
  registers.registerComponentModel(CalendarModel_default);
  registers.registerComponentView(CalendarView_default);
  registers.registerCoordinateSystem("calendar", Calendar_default);
}

// src/coord/matrix/matrixCoordHelper.ts
var MatrixCellLayoutInfoType = {
  level: 1,
  leaf: 2,
  nonLeaf: 3
};
var MatrixClampOption = {
  none: 0,
  all: 1,
  body: 2,
  corner: 3
};
function coordDataToAllCellLevelLayout(coordValue, dims, thisDimIdx) {
  let result = dims[XY2[thisDimIdx]].getCell(coordValue);
  if (!result && isNumber(coordValue) && coordValue < 0) {
    result = dims[XY2[1 - thisDimIdx]].getUnitLayoutInfo(thisDimIdx, Math.round(coordValue));
  }
  return result;
}
function resetXYLocatorRange(out2) {
  const rg = out2 || [];
  rg[0] = rg[0] || [];
  rg[1] = rg[1] || [];
  rg[0][0] = rg[0][1] = rg[1][0] = rg[1][1] = NaN;
  return rg;
}
function parseCoordRangeOption(locOut, reasonOut, data, dims, clamp2) {
  parseCoordRangeOptionOnOneDim(locOut[0], reasonOut, clamp2, data, dims, 0);
  parseCoordRangeOptionOnOneDim(locOut[1], reasonOut, clamp2, data, dims, 1);
}
function parseCoordRangeOptionOnOneDim(locDimOut, reasonOut, clamp2, data, dims, dimIdx) {
  locDimOut[0] = Infinity;
  locDimOut[1] = -Infinity;
  const dataOnDim = data[dimIdx];
  const coordValArr = isArray(dataOnDim) ? dataOnDim : [dataOnDim];
  const len2 = coordValArr.length;
  const hasClamp = !!clamp2;
  if (len2 === 1 || len2 === 2) {
    parseCoordRangeOptionOnOneDimOnePart(locDimOut, reasonOut, coordValArr, hasClamp, dims, dimIdx, 0);
    if (len2 > 1) {
      parseCoordRangeOptionOnOneDimOnePart(locDimOut, reasonOut, coordValArr, hasClamp, dims, dimIdx, 1);
    }
  } else {
    if (reasonOut) {
      reasonOut.push(`Can only contain 1 or 2 coords, rather than ${len2}.`);
    }
    locDimOut[0] = locDimOut[1] = NaN;
  }
  if (hasClamp) {
    let locLowerBound = -dims[XY2[1 - dimIdx]].getLocatorCount(dimIdx);
    let locUpperBound = dims[XY2[dimIdx]].getLocatorCount(dimIdx) - 1;
    if (clamp2 === MatrixClampOption.body) {
      locLowerBound = mathMax2(0, locLowerBound);
    } else if (clamp2 === MatrixClampOption.corner) {
      locUpperBound = mathMin2(-1, locUpperBound);
    }
    if (locUpperBound < locLowerBound) {
      locLowerBound = locUpperBound = NaN;
    }
    if (eqNaN(locDimOut[0])) {
      locDimOut[0] = locLowerBound;
    }
    if (eqNaN(locDimOut[1])) {
      locDimOut[1] = locUpperBound;
    }
    locDimOut[0] = mathMax2(mathMin2(locDimOut[0], locUpperBound), locLowerBound);
    locDimOut[1] = mathMax2(mathMin2(locDimOut[1], locUpperBound), locLowerBound);
  }
}
function parseCoordRangeOptionOnOneDimOnePart(locDimOut, reasonOut, coordValArr, hasClamp, dims, dimIdx, partIdx) {
  const layout14 = coordDataToAllCellLevelLayout(coordValArr[partIdx], dims, dimIdx);
  if (!layout14) {
    if (!hasClamp && reasonOut) {
      reasonOut.push(`Can not find layout by coord[${dimIdx}][${partIdx}].`);
    }
    locDimOut[0] = locDimOut[1] = NaN;
    return;
  }
  const locatorA = layout14.id[XY2[dimIdx]];
  let locatorB = locatorA;
  const dimCell = cellLayoutInfoToDimCell(layout14);
  if (dimCell) {
    locatorB += dimCell.span[XY2[dimIdx]] - 1;
  }
  locDimOut[0] = mathMin2(locDimOut[0], locatorA, locatorB);
  locDimOut[1] = mathMax2(locDimOut[1], locatorA, locatorB);
}
function isXYLocatorRangeInvalidOnDim(locatorRange, dimIdx) {
  return eqNaN(locatorRange[dimIdx][0]) || eqNaN(locatorRange[dimIdx][1]);
}
function resolveXYLocatorRangeByCellMerge(inOutLocatorRange, outMergedMarkList, mergeDefList, mergeDefListTravelLen) {
  outMergedMarkList = outMergedMarkList || _tmpOutMergedMarkList;
  for (let idx = 0; idx < mergeDefListTravelLen; idx++) {
    outMergedMarkList[idx] = false;
  }
  while (true) {
    let expanded = false;
    for (let idx = 0; idx < mergeDefListTravelLen; idx++) {
      const mergeDef = mergeDefList[idx];
      if (!outMergedMarkList[idx] && mergeDef.cellMergeOwner && expandXYLocatorRangeIfIntersect(inOutLocatorRange, mergeDef.locatorRange)) {
        outMergedMarkList[idx] = true;
        expanded = true;
      }
    }
    if (!expanded) {
      break;
    }
  }
}
var _tmpOutMergedMarkList = [];
function expandXYLocatorRangeIfIntersect(thisLocRange, otherLocRange) {
  if (!locatorRangeIntersectOneDim(thisLocRange[0], otherLocRange[0]) || !locatorRangeIntersectOneDim(thisLocRange[1], otherLocRange[1])) {
    return false;
  }
  thisLocRange[0][0] = mathMin2(thisLocRange[0][0], otherLocRange[0][0]);
  thisLocRange[0][1] = mathMax2(thisLocRange[0][1], otherLocRange[0][1]);
  thisLocRange[1][0] = mathMin2(thisLocRange[1][0], otherLocRange[1][0]);
  thisLocRange[1][1] = mathMax2(thisLocRange[1][1], otherLocRange[1][1]);
  return true;
}
function locatorRangeIntersectOneDim(locRange1OneDim, locRange2OneDim) {
  return locRange1OneDim[1] >= locRange2OneDim[0] && locRange1OneDim[0] <= locRange2OneDim[1];
}
function fillIdSpanFromLocatorRange(owner, locatorRange) {
  owner.id.set(locatorRange[0][0], locatorRange[1][0]);
  owner.span.set(locatorRange[0][1] - owner.id.x + 1, locatorRange[1][1] - owner.id.y + 1);
}
function cloneXYLocatorRange(target, source) {
  target[0][0] = source[0][0];
  target[0][1] = source[0][1];
  target[1][0] = source[1][0];
  target[1][1] = source[1][1];
}
function xyLocatorRangeToRectOneDim(oneDimOut, locRange, dims, dimIdx) {
  const layoutMin = coordDataToAllCellLevelLayout(locRange[dimIdx][0], dims, dimIdx);
  const layoutMax = coordDataToAllCellLevelLayout(locRange[dimIdx][1], dims, dimIdx);
  oneDimOut[XY2[dimIdx]] = oneDimOut[WH2[dimIdx]] = NaN;
  if (layoutMin && layoutMax) {
    oneDimOut[XY2[dimIdx]] = layoutMin.xy;
    oneDimOut[WH2[dimIdx]] = layoutMax.xy + layoutMax.wh - layoutMin.xy;
  }
}
function setDimXYValue(out2, dimIdx, valueOnThisDim, valueOnOtherDim) {
  out2[XY2[dimIdx]] = valueOnThisDim;
  out2[XY2[1 - dimIdx]] = valueOnOtherDim;
  return out2;
}
function cellLayoutInfoToDimCell(cellLayoutInfo) {
  return cellLayoutInfo && (cellLayoutInfo.type === MatrixCellLayoutInfoType.leaf || cellLayoutInfo.type === MatrixCellLayoutInfoType.nonLeaf) ? cellLayoutInfo : null;
}
function createNaNRectLike() {
  return {x: NaN, y: NaN, width: NaN, height: NaN};
}

// src/coord/matrix/MatrixDim.ts
var MatrixDim = class {
  constructor(dim, dimModel) {
    this._cells = [];
    this._levels = [];
    this.dim = dim;
    this.dimIdx = dim === "x" ? 0 : 1;
    this._model = dimModel;
    this._uniqueValueGen = createUniqueValueGenerator(dim);
    let dimModelData = dimModel.get("data", true);
    if (dimModelData != null && !isArray(dimModelData)) {
      if (true) {
        error(`Illegal echarts option - matrix.${this.dim}.data must be an array if specified.`);
      }
      dimModelData = [];
    }
    if (dimModelData) {
      this._initByDimModelData(dimModelData);
    } else {
      this._initBySeriesData();
    }
  }
  _initByDimModelData(dimModelData) {
    const self2 = this;
    const _cells = self2._cells;
    const _levels = self2._levels;
    const sameLocatorCellsLists = [];
    let _cellCount = 0;
    self2._leavesCount = traverseInitCells(dimModelData, 0, 0);
    postInitCells();
    return;
    function traverseInitCells(dimModelData2, firstLeafLocator, level) {
      let totalSpan = 0;
      if (!dimModelData2) {
        return totalSpan;
      }
      each(dimModelData2, (option, optionIdx) => {
        let invalidOption = false;
        let cellOption;
        if (isString(option)) {
          cellOption = {value: option};
        } else if (isObject(option)) {
          cellOption = option;
          if (option.value != null && !isString(option.value)) {
            invalidOption = true;
            cellOption = {value: null};
          }
        } else {
          cellOption = {value: null};
          if (option != null) {
            invalidOption = true;
          }
        }
        if (invalidOption) {
          if (true) {
            error(`Illegal echarts option - matrix.${self2.dim}.data[${optionIdx}] must be \`string | {value: string}\`.`);
          }
        }
        const cell = {
          type: MatrixCellLayoutInfoType.nonLeaf,
          ordinal: NaN,
          level,
          firstLeafLocator,
          id: new Point_default(),
          span: setDimXYValue(new Point_default(), self2.dimIdx, 1, 1),
          option: cellOption,
          xy: NaN,
          wh: NaN,
          dim: self2,
          rect: createNaNRectLike()
        };
        _cellCount++;
        (sameLocatorCellsLists[firstLeafLocator] || (sameLocatorCellsLists[firstLeafLocator] = [])).push(cell);
        if (!_levels[level]) {
          _levels[level] = {
            type: MatrixCellLayoutInfoType.level,
            xy: NaN,
            wh: NaN,
            option: null,
            id: new Point_default(),
            dim: self2
          };
        }
        const childrenSpan = traverseInitCells(cellOption.children, firstLeafLocator, level + 1);
        const subSpan = Math.max(1, childrenSpan);
        cell.span[XY2[self2.dimIdx]] = subSpan;
        totalSpan += subSpan;
        firstLeafLocator += subSpan;
      });
      return totalSpan;
    }
    function postInitCells() {
      const categories = [];
      while (_cells.length < _cellCount) {
        for (let locator = 0; locator < sameLocatorCellsLists.length; locator++) {
          const cell = sameLocatorCellsLists[locator].pop();
          if (cell) {
            cell.ordinal = categories.length;
            const val = cell.option.value;
            categories.push(val);
            _cells.push(cell);
            self2._uniqueValueGen.calcDupBase(val);
          }
        }
      }
      self2._uniqueValueGen.ensureValueUnique(categories, _cells);
      const ordinalMeta = self2._ordinalMeta = new OrdinalMeta_default({
        categories,
        needCollect: false,
        deduplication: false
      });
      self2._scale = new Ordinal_default({ordinalMeta});
      for (let idx = 0; idx < self2._leavesCount; idx++) {
        const leaf = self2._cells[idx];
        leaf.type = MatrixCellLayoutInfoType.leaf;
        leaf.span[XY2[1 - self2.dimIdx]] = self2._levels.length - leaf.level;
      }
      self2._initCellsId();
      self2._initLevelIdOptions();
    }
  }
  _initBySeriesData() {
    const self2 = this;
    self2._leavesCount = 0;
    self2._levels = [{
      type: MatrixCellLayoutInfoType.level,
      xy: NaN,
      wh: NaN,
      option: null,
      id: new Point_default(),
      dim: self2
    }];
    self2._initLevelIdOptions();
    const ordinalMeta = self2._ordinalMeta = new OrdinalMeta_default({
      needCollect: true,
      deduplication: true,
      onCollect: (value, ordinalNumber) => {
        const cell = self2._cells[ordinalNumber] = {
          type: MatrixCellLayoutInfoType.leaf,
          ordinal: ordinalNumber,
          level: 0,
          firstLeafLocator: ordinalNumber,
          id: new Point_default(),
          span: setDimXYValue(new Point_default(), self2.dimIdx, 1, 1),
          option: {value: value + ""},
          xy: NaN,
          wh: NaN,
          dim: self2,
          rect: createNaNRectLike()
        };
        self2._leavesCount++;
        self2._setCellId(cell);
      }
    });
    self2._scale = new Ordinal_default({ordinalMeta});
  }
  _setCellId(cell) {
    const levelsLen = this._levels.length;
    const dimIdx = this.dimIdx;
    setDimXYValue(cell.id, dimIdx, cell.firstLeafLocator, cell.level - levelsLen);
  }
  _initCellsId() {
    const levelsLen = this._levels.length;
    const dimIdx = this.dimIdx;
    each(this._cells, (cell) => {
      setDimXYValue(cell.id, dimIdx, cell.firstLeafLocator, cell.level - levelsLen);
    });
  }
  _initLevelIdOptions() {
    const levelsLen = this._levels.length;
    const dimIdx = this.dimIdx;
    let levelOptionList = this._model.get("levels", true);
    levelOptionList = isArray(levelOptionList) ? levelOptionList : [];
    each(this._levels, (levelCfg, level) => {
      setDimXYValue(levelCfg.id, dimIdx, 0, level - levelsLen);
      levelCfg.option = levelOptionList[level];
    });
  }
  shouldShow() {
    return !!this._model.getShallow("show", true);
  }
  resetLayoutIterator(it, dimIdx, startLocator, count2) {
    it = it || new ListIterator();
    if (dimIdx === this.dimIdx) {
      const len2 = this._leavesCount;
      const startIdx = startLocator != null ? Math.max(0, startLocator) : 0;
      count2 = count2 != null ? Math.min(count2, len2) : len2;
      it.reset(this._cells, startIdx, startIdx + count2);
    } else {
      const len2 = this._levels.length;
      const startIdx = startLocator != null ? Math.max(0, startLocator + len2) : 0;
      count2 = count2 != null ? Math.min(count2, len2) : len2;
      it.reset(this._levels, startIdx, startIdx + count2);
    }
    return it;
  }
  resetCellIterator(it) {
    return (it || new ListIterator()).reset(this._cells, 0);
  }
  resetLevelIterator(it) {
    return (it || new ListIterator()).reset(this._levels, 0);
  }
  getLayout(outRect, dimIdx, locator) {
    const layout14 = this.getUnitLayoutInfo(dimIdx, locator);
    outRect[XY2[dimIdx]] = layout14 ? layout14.xy : NaN;
    outRect[WH2[dimIdx]] = layout14 ? layout14.wh : NaN;
  }
  getUnitLayoutInfo(dimIdx, locator) {
    return dimIdx === this.dimIdx ? locator < this._leavesCount ? this._cells[locator] : void 0 : this._levels[locator + this._levels.length];
  }
  getCell(value) {
    const ordinal = this._scale.parse(value);
    return eqNaN(ordinal) ? void 0 : this._cells[ordinal];
  }
  getLocatorCount(dimIdx) {
    return dimIdx === this.dimIdx ? this._leavesCount : this._levels.length;
  }
  getOrdinalMeta() {
    return this._ordinalMeta;
  }
};
function createUniqueValueGenerator(dim) {
  const dimUpper = dim.toUpperCase();
  const defaultValReg = new RegExp(`^${dimUpper}([0-9]+)$`);
  let dupBase = 0;
  function calcDupBase(val) {
    let matchResult;
    if (val != null && (matchResult = val.match(defaultValReg))) {
      dupBase = mathMax2(dupBase, +matchResult[1] + 1);
    }
  }
  function makeUniqueValue() {
    return `${dimUpper}${dupBase++}`;
  }
  function ensureValueUnique(categories, cells) {
    const cateMap = createHashMap();
    for (let idx = 0; idx < categories.length; idx++) {
      let value = categories[idx];
      if (value == null || cateMap.get(value) != null) {
        categories[idx] = value = makeUniqueValue();
        cells[idx].option = defaults({value}, cells[idx].option);
      }
      cateMap.set(value, true);
    }
  }
  return {calcDupBase, ensureValueUnique};
}

// src/coord/matrix/MatrixBodyCorner.ts
var MatrixBodyCorner = class {
  constructor(kind, bodyOrCornerModel, dims) {
    this._model = bodyOrCornerModel;
    this._dims = dims;
    this._kind = kind;
    this._cellMergeOwnerList = [];
  }
  _ensureCellMap() {
    const self2 = this;
    let _cellMap = self2._cellMap;
    if (!_cellMap) {
      _cellMap = self2._cellMap = createHashMap();
      fillCellMap();
    }
    return _cellMap;
    function fillCellMap() {
      const parsedList = [];
      let cellOptionList = self2._model.getShallow("data");
      if (cellOptionList && !isArray(cellOptionList)) {
        if (true) {
          error(`matrix.${cellOptionList}.data must be an array if specified.`);
        }
        cellOptionList = null;
      }
      each(cellOptionList, (option, idx) => {
        if (!isObject(option) || !isArray(option.coord)) {
          if (true) {
            error(`Illegal matrix.${self2._kind}.data[${idx}], must be a {coord: [...], ...}`);
          }
          return;
        }
        const locatorRange = resetXYLocatorRange([]);
        let reasonArr = null;
        if (true) {
          reasonArr = [];
        }
        parseCoordRangeOption(locatorRange, reasonArr, option.coord, self2._dims, MatrixClampOption[self2._kind]);
        if (isXYLocatorRangeInvalidOnDim(locatorRange, 0) || isXYLocatorRangeInvalidOnDim(locatorRange, 1)) {
          if (true) {
            error(`Can not determine cells by option matrix.${self2._kind}.data[${idx}]: ${reasonArr.join(" ")}`);
          }
          return;
        }
        const cellMergeOwner = option && option.mergeCells;
        const parsed = {id: new Point_default(), span: new Point_default(), locatorRange, option, cellMergeOwner};
        fillIdSpanFromLocatorRange(parsed, locatorRange);
        parsedList.push(parsed);
      });
      const mergedMarkList = [];
      for (let parsedIdx = 0; parsedIdx < parsedList.length; parsedIdx++) {
        const parsed = parsedList[parsedIdx];
        if (!parsed.cellMergeOwner) {
          continue;
        }
        const locatorRange = parsed.locatorRange;
        resolveXYLocatorRangeByCellMerge(locatorRange, mergedMarkList, parsedList, parsedIdx);
        for (let idx = 0; idx < parsedIdx; idx++) {
          if (mergedMarkList[idx]) {
            parsedList[idx].cellMergeOwner = false;
          }
        }
        if (locatorRange[0][0] !== parsed.id.x || locatorRange[1][0] !== parsed.id.y) {
          parsed.cellMergeOwner = false;
          const newOption = extend({}, parsed.option);
          newOption.coord = null;
          const newParsed = {
            id: new Point_default(),
            span: new Point_default(),
            locatorRange,
            option: newOption,
            cellMergeOwner: true
          };
          fillIdSpanFromLocatorRange(newParsed, locatorRange);
          parsedList.push(newParsed);
        }
      }
      each(parsedList, (parsed) => {
        const topLeftCell = ensureBodyOrCornerCell(parsed.id.x, parsed.id.y);
        if (parsed.cellMergeOwner) {
          topLeftCell.cellMergeOwner = true;
          topLeftCell.span = parsed.span;
          topLeftCell.locatorRange = parsed.locatorRange;
          topLeftCell.spanRect = createNaNRectLike();
          self2._cellMergeOwnerList.push(topLeftCell);
        }
        if (!parsed.cellMergeOwner && !parsed.option) {
          return;
        }
        for (let yidx = 0; yidx < parsed.span.y; yidx++) {
          for (let xidx = 0; xidx < parsed.span.x; xidx++) {
            const cell = ensureBodyOrCornerCell(parsed.id.x + xidx, parsed.id.y + yidx);
            cell.option = parsed.option;
            if (parsed.cellMergeOwner) {
              cell.inSpanOf = topLeftCell;
            }
          }
        }
      });
    }
    function ensureBodyOrCornerCell(x, y) {
      const key = makeCellMapKey(x, y);
      let cell = _cellMap.get(key);
      if (!cell) {
        cell = _cellMap.set(key, {
          id: new Point_default(x, y),
          option: null,
          inSpanOf: null,
          span: null,
          spanRect: null,
          locatorRange: null,
          cellMergeOwner: false
        });
      }
      return cell;
    }
  }
  getCell(xy) {
    return this._ensureCellMap().get(makeCellMapKey(xy[0], xy[1]));
  }
  travelExistingCells(cb) {
    this._ensureCellMap().each(cb);
  }
  expandRangeByCellMerge(locatorRange) {
    if (isXYLocatorRangeInvalidOnDim(locatorRange, 0) && isXYLocatorRangeInvalidOnDim(locatorRange, 1) && locatorRange[0][0] === locatorRange[0][1] && locatorRange[1][0] === locatorRange[1][1]) {
      _tmpERBCMLocator[0] = locatorRange[0][0];
      _tmpERBCMLocator[1] = locatorRange[1][0];
      const cell = this.getCell(_tmpERBCMLocator);
      const inSpanOf = cell.inSpanOf;
      if (inSpanOf) {
        cloneXYLocatorRange(locatorRange, inSpanOf.locatorRange);
        return;
      }
    }
    const list = this._cellMergeOwnerList;
    resolveXYLocatorRangeByCellMerge(locatorRange, null, list, list.length);
  }
};
var _tmpERBCMLocator = [];
function makeCellMapKey(x, y) {
  return `${x}|${y}`;
}

// src/coord/matrix/MatrixModel.ts
var defaultLabelOption = {
  show: true,
  color: tokens_default.color.secondary,
  overflow: "break",
  lineOverflow: "truncate",
  padding: [2, 3, 2, 3],
  distance: 0
};
function makeDefaultCellItemStyleOption(isCorner) {
  return {
    color: "none",
    borderWidth: 1,
    borderColor: isCorner ? "none" : tokens_default.color.borderTint
  };
}
var defaultDimOption = {
  show: true,
  label: defaultLabelOption,
  itemStyle: makeDefaultCellItemStyleOption(false),
  silent: void 0,
  dividerLineStyle: {
    width: 1,
    color: tokens_default.color.border
  }
};
var defaultBodyOption = {
  label: defaultLabelOption,
  itemStyle: makeDefaultCellItemStyleOption(false),
  silent: void 0
};
var defaultCornerOption = {
  label: defaultLabelOption,
  itemStyle: makeDefaultCellItemStyleOption(true),
  silent: void 0
};
var defaultMatrixOption = {
  z: -50,
  left: "10%",
  top: "10%",
  right: "10%",
  bottom: "10%",
  x: defaultDimOption,
  y: defaultDimOption,
  body: defaultBodyOption,
  corner: defaultCornerOption,
  backgroundStyle: {
    color: "none",
    borderColor: tokens_default.color.axisLine,
    borderWidth: 1
  }
};
var MatrixModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = MatrixModel2.type;
  }
  optionUpdated() {
    const dimModels = this._dimModels = {
      x: new MatrixDimensionModel(this.get("x", true) || {}),
      y: new MatrixDimensionModel(this.get("y", true) || {})
    };
    dimModels.x.option.type = dimModels.y.option.type = "category";
    const xDim2 = dimModels.x.dim = new MatrixDim("x", dimModels.x);
    const yDim2 = dimModels.y.dim = new MatrixDim("y", dimModels.y);
    const dims = {x: xDim2, y: yDim2};
    this._body = new MatrixBodyCorner("body", new Model_default(this.getShallow("body")), dims);
    this._corner = new MatrixBodyCorner("corner", new Model_default(this.getShallow("corner")), dims);
  }
  getDimensionModel(dim) {
    return this._dimModels[dim];
  }
  getBody() {
    return this._body;
  }
  getCorner() {
    return this._corner;
  }
};
var MatrixModel = MatrixModel2;
MatrixModel.type = "matrix";
MatrixModel.layoutMode = "box";
MatrixModel.defaultOption = defaultMatrixOption;
var MatrixDimensionModel = class extends Model_default {
  getOrdinalMeta() {
    return this.dim.getOrdinalMeta();
  }
};
var MatrixModel_default = MatrixModel;

// src/component/matrix/MatrixView.ts
var round7 = Math.round;
var Z2_BACKGROUND = 0;
var Z2_OUTER_BORDER = 99;
var Z2_BODY_CORNER_CELL_DEFAULT = {normal: 25, special: 100};
var Z2_DIMENSION_CELL_DEFAULT = {normal: 50, special: 125};
var MatrixView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = MatrixView2.type;
  }
  render(matrixModel) {
    this.group.removeAll();
    const group = this.group;
    const coordSys = matrixModel.coordinateSystem;
    const rect = coordSys.getRect();
    const xDimModel = matrixModel.getDimensionModel("x");
    const yDimModel = matrixModel.getDimensionModel("y");
    const xDim2 = xDimModel.dim;
    const yDim2 = yDimModel.dim;
    renderDimensionCells(group, matrixModel);
    createBodyAndCorner(group, matrixModel, xDim2, yDim2);
    const borderZ2Option = matrixModel.getShallow("borderZ2", true);
    const outerBorderZ2 = retrieve2(borderZ2Option, Z2_OUTER_BORDER);
    const dividerLineZ2 = outerBorderZ2 - 1;
    const bgStyle = matrixModel.getModel("backgroundStyle").getItemStyle(["borderWidth"]);
    bgStyle.lineWidth = 0;
    const borderStyle = matrixModel.getModel("backgroundStyle").getItemStyle(["color", "decal", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]);
    borderStyle.fill = "none";
    const bgRect = createMatrixRect(rect.clone(), bgStyle, Z2_BACKGROUND);
    const borderRect = createMatrixRect(rect.clone(), borderStyle, outerBorderZ2);
    bgRect.silent = true;
    borderRect.silent = true;
    group.add(bgRect);
    group.add(borderRect);
    const xDimCell0 = xDim2.getUnitLayoutInfo(0, 0);
    const yDimCell0 = yDim2.getUnitLayoutInfo(1, 0);
    if (xDimCell0 && yDimCell0) {
      if (xDim2.shouldShow()) {
        group.add(createMatrixLine({
          x1: rect.x,
          y1: yDimCell0.xy,
          x2: rect.x + rect.width,
          y2: yDimCell0.xy
        }, xDimModel.getModel("dividerLineStyle").getLineStyle(), dividerLineZ2));
      }
      if (yDim2.shouldShow()) {
        group.add(createMatrixLine({
          x1: xDimCell0.xy,
          y1: rect.y,
          x2: xDimCell0.xy,
          y2: rect.y + rect.height
        }, yDimModel.getModel("dividerLineStyle").getLineStyle(), dividerLineZ2));
      }
    }
  }
};
var MatrixView = MatrixView2;
MatrixView.type = "matrix";
function renderDimensionCells(group, matrixModel) {
  renderOnDimension(0);
  renderOnDimension(1);
  function renderOnDimension(dimIdx) {
    const thisDimModel = matrixModel.getDimensionModel(XY2[dimIdx]);
    const thisDim = thisDimModel.dim;
    if (!thisDim.shouldShow()) {
      return;
    }
    const thisDimBgStyleModel = thisDimModel.getModel("itemStyle");
    const thisDimLabelModel = thisDimModel.getModel("label");
    const tooltipOption = matrixModel.getShallow("tooltip", true);
    const xyLocator = [];
    for (const it = thisDim.resetCellIterator(); it.next(); ) {
      const dimCell = it.item;
      const shape = {};
      BoundingRect_default.copy(shape, dimCell.rect);
      set(xyLocator, dimCell.id.x, dimCell.id.y);
      createMatrixCell(xyLocator, matrixModel, group, dimCell.option, thisDimBgStyleModel, thisDimLabelModel, thisDimModel, shape, dimCell.option.value, Z2_DIMENSION_CELL_DEFAULT, tooltipOption);
    }
  }
}
function createBodyAndCorner(group, matrixModel, xDim2, yDim2) {
  createBodyOrCornerCells("body", matrixModel.getBody(), xDim2, yDim2);
  if (xDim2.shouldShow() && yDim2.shouldShow()) {
    createBodyOrCornerCells("corner", matrixModel.getCorner(), yDim2, xDim2);
  }
  function createBodyOrCornerCells(bodyCornerOptionRoot, bodyOrCorner, dimForCoordX, dimForCoordY) {
    const parentCellModel = new Model_default(matrixModel.getShallow(bodyCornerOptionRoot, true));
    const parentItemStyleModel = parentCellModel.getModel("itemStyle");
    const parentLabelModel = parentCellModel.getModel("label");
    const itx = new ListIterator();
    const ity = new ListIterator();
    const xyLocator = [];
    const tooltipOption = matrixModel.getShallow("tooltip", true);
    for (dimForCoordY.resetLayoutIterator(ity, 1); ity.next(); ) {
      for (dimForCoordX.resetLayoutIterator(itx, 0); itx.next(); ) {
        const xLayout = itx.item;
        const yLayout = ity.item;
        set(xyLocator, xLayout.id.x, yLayout.id.y);
        const bodyCornerCell = bodyOrCorner.getCell(xyLocator);
        if (bodyCornerCell && bodyCornerCell.inSpanOf && bodyCornerCell.inSpanOf !== bodyCornerCell) {
          continue;
        }
        const shape = {};
        if (bodyCornerCell && bodyCornerCell.span) {
          BoundingRect_default.copy(shape, bodyCornerCell.spanRect);
        } else {
          xLayout.dim.getLayout(shape, 0, xyLocator[0]);
          yLayout.dim.getLayout(shape, 1, xyLocator[1]);
        }
        const bodyCornerCellOption = bodyCornerCell ? bodyCornerCell.option : null;
        createMatrixCell(xyLocator, matrixModel, group, bodyCornerCellOption, parentItemStyleModel, parentLabelModel, parentCellModel, shape, bodyCornerCellOption ? bodyCornerCellOption.value : null, Z2_BODY_CORNER_CELL_DEFAULT, tooltipOption);
      }
    }
  }
}
function createMatrixCell(xyLocator, matrixModel, group, cellOption, parentItemStyleModel, parentLabelModel, parentCellModel, shape, textValue, zrCellDefault, tooltipOption) {
  _tmpCellItemStyleModel.option = cellOption ? cellOption.itemStyle : null;
  _tmpCellItemStyleModel.parentModel = parentItemStyleModel;
  _tmpCellModel.option = cellOption;
  _tmpCellModel.parentModel = parentCellModel;
  const z2 = retrieve2(_tmpCellModel.getShallow("z2"), cellOption && cellOption.itemStyle ? zrCellDefault.special : zrCellDefault.normal);
  const tooltipOptionShow = tooltipOption && tooltipOption.show;
  const cellRect = createMatrixRect(shape, _tmpCellItemStyleModel.getItemStyle(), z2);
  group.add(cellRect);
  const cursorOption = _tmpCellModel.get("cursor");
  if (cursorOption != null) {
    cellRect.attr("cursor", cursorOption);
  }
  let cellText;
  if (textValue != null) {
    const text = textValue + "";
    _tmpCellLabelModel.option = cellOption ? cellOption.label : null;
    _tmpCellLabelModel.parentModel = parentLabelModel;
    setLabelStyle(cellRect, {normal: _tmpCellLabelModel}, {
      defaultText: text,
      autoOverflowArea: true,
      layoutRect: clone(cellRect.shape)
    });
    cellText = cellRect.getTextContent();
    if (cellText) {
      cellText.z2 = z2 + 1;
      const style = cellText.style;
      if (style && (style.overflow && style.overflow !== "none" && style.lineOverflow)) {
        const clipShape = {};
        BoundingRect_default.copy(clipShape, shape);
        expandOrShrinkRect(clipShape, (cellRect.style?.lineWidth || 0) / 2, true, true);
        cellRect.updateInnerText();
        cellText.getLocalTransform(_tmpInnerTextTrans);
        invert(_tmpInnerTextTrans, _tmpInnerTextTrans);
        BoundingRect_default.applyTransform(clipShape, clipShape, _tmpInnerTextTrans);
        cellText.setClipPath(new Rect_default({shape: clipShape}));
      }
    }
    setTooltipConfig({
      el: cellRect,
      componentModel: matrixModel,
      itemName: text,
      itemTooltipOption: tooltipOption,
      formatterParamsExtra: {
        xyLocator: xyLocator.slice()
      }
    });
  }
  if (cellText) {
    let labelSilent = _tmpCellLabelModel.get("silent");
    if (labelSilent == null) {
      labelSilent = !tooltipOptionShow;
    }
    cellText.silent = labelSilent;
    cellText.ignoreHostSilent = true;
  }
  let rectSilent = _tmpCellModel.get("silent");
  if (rectSilent == null) {
    rectSilent = !cellRect.style || cellRect.style.fill === "none" || !cellRect.style.fill;
  }
  cellRect.silent = rectSilent;
}
var _tmpCellModel = new Model_default();
var _tmpCellItemStyleModel = new Model_default();
var _tmpCellLabelModel = new Model_default();
var _tmpInnerTextTrans = [];
function createMatrixRect(shape, style, z2) {
  const lineWidth = style.lineWidth;
  if (lineWidth) {
    const x2Original = shape.x + shape.width;
    const y2Original = shape.y + shape.height;
    shape.x = subPixelOptimize(shape.x, lineWidth, true);
    shape.y = subPixelOptimize(shape.y, lineWidth, true);
    shape.width = subPixelOptimize(x2Original, lineWidth, true) - shape.x;
    shape.height = subPixelOptimize(y2Original, lineWidth, true) - shape.y;
  }
  return new Rect_default({
    shape,
    style,
    z2
  });
}
function createMatrixLine(shape, style, z2) {
  const lineWidth = style.lineWidth;
  if (lineWidth) {
    if (round7(shape.x1 * 2) === round7(shape.x2 * 2)) {
      shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);
    }
    if (round7(shape.y1 * 2) === round7(shape.y2 * 2)) {
      shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);
    }
  }
  return new Line_default({
    shape,
    style,
    silent: true,
    z2
  });
}
var MatrixView_default = MatrixView;

// src/coord/matrix/Matrix.ts
var Matrix2 = class {
  constructor(matrixModel, ecModel, api2) {
    this.dimensions = Matrix2.dimensions;
    this.type = "matrix";
    this._model = matrixModel;
    const models = this._dimModels = {
      x: matrixModel.getDimensionModel("x"),
      y: matrixModel.getDimensionModel("y")
    };
    this._dims = {
      x: models.x.dim,
      y: models.y.dim
    };
    this._resize(matrixModel, api2);
  }
  static getDimensionsInfo() {
    return [
      {name: "x", type: "ordinal"},
      {name: "y", type: "ordinal"},
      {name: "value"}
    ];
  }
  static create(ecModel, api2) {
    const matrixList = [];
    ecModel.eachComponent("matrix", function(matrixModel) {
      const matrix14 = new Matrix2(matrixModel, ecModel, api2);
      matrixList.push(matrix14);
      matrixModel.coordinateSystem = matrix14;
    });
    ecModel.eachComponent((mainType, componentModel) => {
      injectCoordSysByOption({
        targetModel: componentModel,
        coordSysType: "matrix",
        coordSysProvider: simpleCoordSysInjectionProvider
      });
    });
    return matrixList;
  }
  getRect() {
    return this._rect;
  }
  _resize(matrixModel, api2) {
    const dims = this._dims;
    const dimModels = this._dimModels;
    const rect = this._rect = getLayoutRect(matrixModel.getBoxLayoutParams(), {
      width: api2.getWidth(),
      height: api2.getHeight()
    });
    layOutUnitsOnDimension(dimModels, dims, rect, 0);
    layOutUnitsOnDimension(dimModels, dims, rect, 1);
    layOutDimCellsRestInfoByUnit(0, dims);
    layOutDimCellsRestInfoByUnit(1, dims);
    layOutBodyCornerCellMerge(this._model.getBody(), dims);
    layOutBodyCornerCellMerge(this._model.getCorner(), dims);
  }
  dataToPoint(data, opt, out2) {
    out2 = out2 || [];
    this.dataToLayout(data, opt, _dtpOutDataToLayout);
    out2[0] = _dtpOutDataToLayout.rect.x + _dtpOutDataToLayout.rect.width / 2;
    out2[1] = _dtpOutDataToLayout.rect.y + _dtpOutDataToLayout.rect.height / 2;
    return out2;
  }
  dataToLayout(data, opt, out2) {
    const dims = this._dims;
    out2 = out2 || {};
    const outRect = out2.rect = out2.rect || {};
    outRect.x = outRect.y = outRect.width = outRect.height = NaN;
    const outLocRange = out2.matrixXYLocatorRange = resetXYLocatorRange(out2.matrixXYLocatorRange);
    if (!isArray(data)) {
      if (true) {
        error("Input data must be an array in `convertToLayout`, `convertToPixel`");
      }
      return out2;
    }
    parseCoordRangeOption(outLocRange, null, data, dims, retrieve2(opt && opt.clamp, MatrixClampOption.none));
    if (!opt || !opt.ignoreMergeCells) {
      if (!opt || opt.clamp !== MatrixClampOption.corner) {
        this._model.getBody().expandRangeByCellMerge(outLocRange);
      }
      if (!opt || opt.clamp !== MatrixClampOption.body) {
        this._model.getCorner().expandRangeByCellMerge(outLocRange);
      }
    }
    xyLocatorRangeToRectOneDim(outRect, outLocRange, dims, 0);
    xyLocatorRangeToRectOneDim(outRect, outLocRange, dims, 1);
    return out2;
  }
  pointToData(point, opt, out2) {
    const dims = this._dims;
    pointToDataOneDimPrepareCtx(_tmpCtxPointToData, 0, dims, point, opt && opt.clamp);
    pointToDataOneDimPrepareCtx(_tmpCtxPointToData, 1, dims, point, opt && opt.clamp);
    out2 = out2 || [];
    out2[0] = out2[1] = NaN;
    if (_tmpCtxPointToData.y === CtxPointToDataAreaType.inCorner && _tmpCtxPointToData.x === CtxPointToDataAreaType.inBody) {
      pointToDataOnlyHeaderFillOut(_tmpCtxPointToData, out2, 0, dims);
    } else if (_tmpCtxPointToData.x === CtxPointToDataAreaType.inCorner && _tmpCtxPointToData.y === CtxPointToDataAreaType.inBody) {
      pointToDataOnlyHeaderFillOut(_tmpCtxPointToData, out2, 1, dims);
    } else {
      pointToDataBodyCornerFillOut(_tmpCtxPointToData, out2, 0, dims);
      pointToDataBodyCornerFillOut(_tmpCtxPointToData, out2, 1, dims);
    }
    return out2;
  }
  convertToPixel(ecModel, finder, value, opt) {
    const coordSys = getCoordSys6(finder);
    return coordSys === this ? coordSys.dataToPoint(value, opt) : void 0;
  }
  convertToLayout(ecModel, finder, value, opt) {
    const coordSys = getCoordSys6(finder);
    return coordSys === this ? coordSys.dataToLayout(value, opt) : void 0;
  }
  convertFromPixel(ecModel, finder, pixel, opt) {
    const coordSys = getCoordSys6(finder);
    return coordSys === this ? coordSys.pointToData(pixel, opt) : void 0;
  }
  containPoint(point) {
    return this._rect.contain(point[0], point[1]);
  }
};
var Matrix = Matrix2;
Matrix.dimensions = ["x", "y", "value"];
var _dtpOutDataToLayout = {rect: createNaNRectLike()};
var _ptdLevelIt = new ListIterator();
var _ptdDimCellIt = new ListIterator();
function layOutUnitsOnDimension(dimModels, dims, matrixRect, dimIdx) {
  const otherDimIdx = 1 - dimIdx;
  const thisDim = dims[XY2[dimIdx]];
  const otherDim = dims[XY2[otherDimIdx]];
  const otherDimShow = otherDim.shouldShow();
  for (const it2 = thisDim.resetCellIterator(); it2.next(); ) {
    it2.item.wh = it2.item.xy = NaN;
  }
  for (const it2 = otherDim.resetLayoutIterator(null, dimIdx); it2.next(); ) {
    it2.item.wh = it2.item.xy = NaN;
  }
  let restSize = matrixRect[WH2[dimIdx]];
  let restCellsCount = thisDim.getLocatorCount(dimIdx) + otherDim.getLocatorCount(dimIdx);
  const tmpLevelModel = new Model_default();
  for (const it2 = otherDim.resetLevelIterator(); it2.next(); ) {
    tmpLevelModel.option = it2.item.option;
    tmpLevelModel.parentModel = dimModels[XY2[otherDimIdx]];
    layOutSpecified(it2.item, otherDimShow ? tmpLevelModel.get("levelSize") : 0);
  }
  const tmpCellModel = new Model_default();
  for (const it2 = thisDim.resetCellIterator(); it2.next(); ) {
    if (it2.item.type === MatrixCellLayoutInfoType.leaf) {
      tmpCellModel.option = it2.item.option;
      tmpCellModel.parentModel = void 0;
      layOutSpecified(it2.item, tmpCellModel.get("size"));
    }
  }
  function layOutSpecified(item, sizeOption) {
    const size = parseSizeOption(sizeOption, dimIdx, matrixRect);
    if (!eqNaN(size)) {
      item.wh = confineSize(size, restSize);
      restSize = confineSize(restSize - item.wh);
      restCellsCount--;
    }
  }
  const computedCellWH = restCellsCount ? restSize / restCellsCount : 0;
  const notAlignToBigmost = !restCellsCount && restSize >= 1;
  let currXY = matrixRect[XY2[dimIdx]];
  const maxLocator = thisDim.getLocatorCount(dimIdx) - 1;
  const it = new ListIterator();
  for (otherDim.resetLayoutIterator(it, dimIdx); it.next(); ) {
    layOutUnspecified(it.item);
  }
  for (thisDim.resetLayoutIterator(it, dimIdx); it.next(); ) {
    layOutUnspecified(it.item);
  }
  function layOutUnspecified(item) {
    if (eqNaN(item.wh)) {
      item.wh = computedCellWH;
    }
    item.xy = currXY;
    if (item.id[XY2[dimIdx]] === maxLocator && !notAlignToBigmost) {
      item.wh = matrixRect[XY2[dimIdx]] + matrixRect[WH2[dimIdx]] - item.xy;
    }
    currXY += item.wh;
  }
}
function layOutDimCellsRestInfoByUnit(dimIdx, dims) {
  for (const it = dims[XY2[dimIdx]].resetCellIterator(); it.next(); ) {
    const dimCell = it.item;
    layOutRectOneDimBasedOnUnit(dimCell.rect, dimIdx, dimCell.id, dimCell.span, dims);
    layOutRectOneDimBasedOnUnit(dimCell.rect, 1 - dimIdx, dimCell.id, dimCell.span, dims);
    if (dimCell.type === MatrixCellLayoutInfoType.nonLeaf) {
      dimCell.xy = dimCell.rect[XY2[dimIdx]];
      dimCell.wh = dimCell.rect[WH2[dimIdx]];
    }
  }
}
function layOutBodyCornerCellMerge(bodyOrCorner, dims) {
  bodyOrCorner.travelExistingCells((cell) => {
    const computedSpan = cell.span;
    if (computedSpan) {
      const layoutRect = cell.spanRect;
      const id = cell.id;
      layOutRectOneDimBasedOnUnit(layoutRect, 0, id, computedSpan, dims);
      layOutRectOneDimBasedOnUnit(layoutRect, 1, id, computedSpan, dims);
    }
  });
}
function layOutRectOneDimBasedOnUnit(outRect, dimIdx, id, span, dims) {
  outRect[WH2[dimIdx]] = 0;
  const locator = id[XY2[dimIdx]];
  const dim = locator < 0 ? dims[XY2[1 - dimIdx]] : dims[XY2[dimIdx]];
  const layoutUnit = dim.getUnitLayoutInfo(dimIdx, id[XY2[dimIdx]]);
  outRect[XY2[dimIdx]] = layoutUnit.xy;
  outRect[WH2[dimIdx]] = layoutUnit.wh;
  if (span[XY2[dimIdx]] > 1) {
    const layoutUnit2 = dim.getUnitLayoutInfo(dimIdx, id[XY2[dimIdx]] + span[XY2[dimIdx]] - 1);
    outRect[WH2[dimIdx]] = layoutUnit2.xy + layoutUnit2.wh - layoutUnit.xy;
  }
}
function parseSizeOption(sizeOption, dimIdx, matrixRect) {
  const sizeNum = parsePositionSizeOption(sizeOption, matrixRect[WH2[dimIdx]]);
  return confineSize(sizeNum, matrixRect[WH2[dimIdx]]);
}
function confineSize(sizeNum, sizeLimit) {
  return Math.max(Math.min(sizeNum, retrieve2(sizeLimit, Infinity)), 0);
}
function getCoordSys6(finder) {
  const matrixModel = finder.matrixModel;
  const seriesModel = finder.seriesModel;
  const coordSys = matrixModel ? matrixModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem : null;
  return coordSys;
}
var CtxPointToDataAreaType = {inBody: 1, inCorner: 2, outside: 3};
var _tmpCtxPointToData = {x: null, y: null, point: []};
function pointToDataOneDimPrepareCtx(ctx, dimIdx, dims, point, clamp2) {
  const thisDim = dims[XY2[dimIdx]];
  const otherDim = dims[XY2[1 - dimIdx]];
  const bodyMaxUnit = thisDim.getUnitLayoutInfo(dimIdx, thisDim.getLocatorCount(dimIdx) - 1);
  const body0Unit = thisDim.getUnitLayoutInfo(dimIdx, 0);
  const cornerMinUnit = otherDim.getUnitLayoutInfo(dimIdx, -otherDim.getLocatorCount(dimIdx));
  const cornerMinus1Unit = otherDim.shouldShow() ? otherDim.getUnitLayoutInfo(dimIdx, -1) : null;
  let coord = ctx.point[dimIdx] = point[dimIdx];
  if (!body0Unit && !cornerMinus1Unit) {
    ctx[XY2[dimIdx]] = CtxPointToDataAreaType.outside;
    return;
  }
  if (clamp2 === MatrixClampOption.body) {
    if (body0Unit) {
      ctx[XY2[dimIdx]] = CtxPointToDataAreaType.inBody;
      coord = mathMin2(bodyMaxUnit.xy + bodyMaxUnit.wh, mathMax2(body0Unit.xy, coord));
      ctx.point[dimIdx] = coord;
    } else {
      ctx[XY2[dimIdx]] = CtxPointToDataAreaType.outside;
    }
    return;
  } else if (clamp2 === MatrixClampOption.corner) {
    if (cornerMinus1Unit) {
      ctx[XY2[dimIdx]] = CtxPointToDataAreaType.inCorner;
      coord = mathMin2(cornerMinus1Unit.xy + cornerMinus1Unit.wh, mathMax2(cornerMinUnit.xy, coord));
      ctx.point[dimIdx] = coord;
    } else {
      ctx[XY2[dimIdx]] = CtxPointToDataAreaType.outside;
    }
    return;
  }
  const pxLoc0 = body0Unit ? body0Unit.xy : cornerMinus1Unit ? cornerMinus1Unit.xy + cornerMinus1Unit.wh : NaN;
  const pxMin = cornerMinUnit ? cornerMinUnit.xy : pxLoc0;
  const pxMax = bodyMaxUnit ? bodyMaxUnit.xy + bodyMaxUnit.wh : pxLoc0;
  if (coord < pxMin) {
    if (!clamp2) {
      ctx[XY2[dimIdx]] = CtxPointToDataAreaType.outside;
      return;
    }
    coord = pxMin;
  } else if (coord > pxMax) {
    if (!clamp2) {
      ctx[XY2[dimIdx]] = CtxPointToDataAreaType.outside;
      return;
    }
    coord = pxMax;
  }
  ctx.point[dimIdx] = coord;
  ctx[XY2[dimIdx]] = pxLoc0 <= coord && coord <= pxMax ? CtxPointToDataAreaType.inBody : pxMin <= coord && coord <= pxLoc0 ? CtxPointToDataAreaType.inCorner : CtxPointToDataAreaType.outside;
}
function pointToDataOnlyHeaderFillOut(ctx, partialOut, dimIdx, dims) {
  const otherDimIdx = 1 - dimIdx;
  if (ctx[XY2[dimIdx]] === CtxPointToDataAreaType.outside) {
    return;
  }
  for (dims[XY2[dimIdx]].resetCellIterator(_ptdDimCellIt); _ptdDimCellIt.next(); ) {
    const cell = _ptdDimCellIt.item;
    if (isCoordInRect(ctx.point[dimIdx], cell.rect, dimIdx) && isCoordInRect(ctx.point[otherDimIdx], cell.rect, otherDimIdx)) {
      partialOut[dimIdx] = cell.ordinal;
      partialOut[otherDimIdx] = cell.id[XY2[otherDimIdx]];
      return;
    }
  }
}
function pointToDataBodyCornerFillOut(ctx, partialOut, dimIdx, dims) {
  if (ctx[XY2[dimIdx]] === CtxPointToDataAreaType.outside) {
    return;
  }
  const dim = ctx[XY2[dimIdx]] === CtxPointToDataAreaType.inCorner ? dims[XY2[1 - dimIdx]] : dims[XY2[dimIdx]];
  for (dim.resetLayoutIterator(_ptdLevelIt, dimIdx); _ptdLevelIt.next(); ) {
    if (isCoordInLayoutInfo(ctx.point[dimIdx], _ptdLevelIt.item)) {
      partialOut[dimIdx] = _ptdLevelIt.item.id[XY2[dimIdx]];
      return;
    }
  }
}
function isCoordInLayoutInfo(coord, cell) {
  return cell.xy <= coord && coord <= cell.xy + cell.wh;
}
function isCoordInRect(coord, rect, dimIdx) {
  return rect[XY2[dimIdx]] <= coord && coord <= rect[XY2[dimIdx]] + rect[WH2[dimIdx]];
}
var Matrix_default = Matrix;

// src/component/matrix/install.ts
function install35(registers) {
  registers.registerComponentModel(MatrixModel_default);
  registers.registerComponentView(MatrixView_default);
  registers.registerCoordinateSystem("matrix", Matrix_default);
}

// src/component/graphic/GraphicView.ts
var nonShapeGraphicElements = {
  path: null,
  compoundPath: null,
  group: Group_default,
  image: Image_default,
  text: Text_default
};
var inner17 = makeInner();
var GraphicComponentView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = GraphicComponentView2.type;
  }
  init() {
    this._elMap = createHashMap();
  }
  render(graphicModel, ecModel, api2) {
    if (graphicModel !== this._lastGraphicModel) {
      this._clear();
    }
    this._lastGraphicModel = graphicModel;
    this._updateElements(graphicModel);
    this._relocate(graphicModel, api2);
  }
  _updateElements(graphicModel) {
    const elOptionsToUpdate = graphicModel.useElOptionsToUpdate();
    if (!elOptionsToUpdate) {
      return;
    }
    const elMap = this._elMap;
    const rootGroup = this.group;
    const globalZ = graphicModel.get("z");
    const globalZLevel = graphicModel.get("zlevel");
    each(elOptionsToUpdate, function(elOption) {
      const id = convertOptionIdName(elOption.id, null);
      const elExisting = id != null ? elMap.get(id) : null;
      const parentId = convertOptionIdName(elOption.parentId, null);
      const targetElParent = parentId != null ? elMap.get(parentId) : rootGroup;
      const elType = elOption.type;
      const elOptionStyle = elOption.style;
      if (elType === "text" && elOptionStyle) {
        if (elOption.hv && elOption.hv[1]) {
          elOptionStyle.textVerticalAlign = elOptionStyle.textBaseline = elOptionStyle.verticalAlign = elOptionStyle.align = null;
        }
      }
      let textContentOption = elOption.textContent;
      let textConfig = elOption.textConfig;
      if (elOptionStyle && isEC4CompatibleStyle(elOptionStyle, elType, !!textConfig, !!textContentOption)) {
        const convertResult = convertFromEC4CompatibleStyle(elOptionStyle, elType, true);
        if (!textConfig && convertResult.textConfig) {
          textConfig = elOption.textConfig = convertResult.textConfig;
        }
        if (!textContentOption && convertResult.textContent) {
          textContentOption = convertResult.textContent;
        }
      }
      const elOptionCleaned = getCleanedElOption(elOption);
      if (true) {
        elExisting && assert(targetElParent === elExisting.parent, "Changing parent is not supported.");
      }
      const $action = elOption.$action || "merge";
      const isMerge = $action === "merge";
      const isReplace = $action === "replace";
      if (isMerge) {
        const isInit = !elExisting;
        let el2 = elExisting;
        if (isInit) {
          el2 = createEl2(id, targetElParent, elOption.type, elMap);
        } else {
          el2 && (inner17(el2).isNew = false);
          stopPreviousKeyframeAnimationAndRestore(el2);
        }
        if (el2) {
          applyUpdateTransition(el2, elOptionCleaned, graphicModel, {isInit});
          updateCommonAttrs(el2, elOption, globalZ, globalZLevel);
        }
      } else if (isReplace) {
        removeEl(elExisting, elOption, elMap, graphicModel);
        const el2 = createEl2(id, targetElParent, elOption.type, elMap);
        if (el2) {
          applyUpdateTransition(el2, elOptionCleaned, graphicModel, {isInit: true});
          updateCommonAttrs(el2, elOption, globalZ, globalZLevel);
        }
      } else if ($action === "remove") {
        updateLeaveTo(elExisting, elOption);
        removeEl(elExisting, elOption, elMap, graphicModel);
      }
      const el = elMap.get(id);
      if (el && textContentOption) {
        if (isMerge) {
          const textContentExisting = el.getTextContent();
          textContentExisting ? textContentExisting.attr(textContentOption) : el.setTextContent(new Text_default(textContentOption));
        } else if (isReplace) {
          el.setTextContent(new Text_default(textContentOption));
        }
      }
      if (el) {
        const clipPathOption = elOption.clipPath;
        if (clipPathOption) {
          const clipPathType = clipPathOption.type;
          let clipPath;
          let isInit = false;
          if (isMerge) {
            const oldClipPath = el.getClipPath();
            isInit = !oldClipPath || inner17(oldClipPath).type !== clipPathType;
            clipPath = isInit ? newEl(clipPathType) : oldClipPath;
          } else if (isReplace) {
            isInit = true;
            clipPath = newEl(clipPathType);
          }
          el.setClipPath(clipPath);
          applyUpdateTransition(clipPath, clipPathOption, graphicModel, {isInit});
          applyKeyframeAnimation(clipPath, clipPathOption.keyframeAnimation, graphicModel);
        }
        const elInner = inner17(el);
        el.setTextConfig(textConfig);
        elInner.option = elOption;
        setEventData(el, graphicModel, elOption);
        setTooltipConfig({
          el,
          componentModel: graphicModel,
          itemName: el.name,
          itemTooltipOption: elOption.tooltip
        });
        applyKeyframeAnimation(el, elOption.keyframeAnimation, graphicModel);
      }
    });
  }
  _relocate(graphicModel, api2) {
    const elOptions = graphicModel.option.elements;
    const rootGroup = this.group;
    const elMap = this._elMap;
    const apiWidth = api2.getWidth();
    const apiHeight = api2.getHeight();
    const xy = ["x", "y"];
    for (let i = 0; i < elOptions.length; i++) {
      const elOption = elOptions[i];
      const id = convertOptionIdName(elOption.id, null);
      const el = id != null ? elMap.get(id) : null;
      if (!el || !el.isGroup) {
        continue;
      }
      const parentEl = el.parent;
      const isParentRoot = parentEl === rootGroup;
      const elInner = inner17(el);
      const parentElInner = inner17(parentEl);
      elInner.width = parsePercent2(elInner.option.width, isParentRoot ? apiWidth : parentElInner.width) || 0;
      elInner.height = parsePercent2(elInner.option.height, isParentRoot ? apiHeight : parentElInner.height) || 0;
    }
    for (let i = elOptions.length - 1; i >= 0; i--) {
      const elOption = elOptions[i];
      const id = convertOptionIdName(elOption.id, null);
      const el = id != null ? elMap.get(id) : null;
      if (!el) {
        continue;
      }
      const parentEl = el.parent;
      const parentElInner = inner17(parentEl);
      const containerInfo = parentEl === rootGroup ? {
        width: apiWidth,
        height: apiHeight
      } : {
        width: parentElInner.width,
        height: parentElInner.height
      };
      const layoutPos = {};
      const layouted = positionElement(el, elOption, containerInfo, null, {hv: elOption.hv, boundingMode: elOption.bounding}, layoutPos);
      if (!inner17(el).isNew && layouted) {
        const transition = elOption.transition;
        const animatePos = {};
        for (let k = 0; k < xy.length; k++) {
          const key = xy[k];
          const val = layoutPos[key];
          if (transition && (isTransitionAll(transition) || indexOf(transition, key) >= 0)) {
            animatePos[key] = val;
          } else {
            el[key] = val;
          }
        }
        updateProps(el, animatePos, graphicModel, 0);
      } else {
        el.attr(layoutPos);
      }
    }
  }
  _clear() {
    const elMap = this._elMap;
    elMap.each((el) => {
      removeEl(el, inner17(el).option, elMap, this._lastGraphicModel);
    });
    this._elMap = createHashMap();
  }
  dispose() {
    this._clear();
  }
};
var GraphicComponentView = GraphicComponentView2;
GraphicComponentView.type = "graphic";
function newEl(graphicType) {
  if (true) {
    assert(graphicType, "graphic type MUST be set");
  }
  const Clz = hasOwn(nonShapeGraphicElements, graphicType) ? nonShapeGraphicElements[graphicType] : getShapeClass(graphicType);
  if (true) {
    assert(Clz, `graphic type ${graphicType} can not be found`);
  }
  const el = new Clz({});
  inner17(el).type = graphicType;
  return el;
}
function createEl2(id, targetElParent, graphicType, elMap) {
  const el = newEl(graphicType);
  targetElParent.add(el);
  elMap.set(id, el);
  inner17(el).id = id;
  inner17(el).isNew = true;
  return el;
}
function removeEl(elExisting, elOption, elMap, graphicModel) {
  const existElParent = elExisting && elExisting.parent;
  if (existElParent) {
    elExisting.type === "group" && elExisting.traverse(function(el) {
      removeEl(el, elOption, elMap, graphicModel);
    });
    applyLeaveTransition(elExisting, elOption, graphicModel);
    elMap.removeKey(inner17(elExisting).id);
  }
}
function updateCommonAttrs(el, elOption, defaultZ, defaultZlevel) {
  if (!el.isGroup) {
    each([
      ["cursor", Displayable_default.prototype.cursor],
      ["zlevel", defaultZlevel || 0],
      ["z", defaultZ || 0],
      ["z2", 0]
    ], (item) => {
      const prop = item[0];
      if (hasOwn(elOption, prop)) {
        el[prop] = retrieve2(elOption[prop], item[1]);
      } else if (el[prop] == null) {
        el[prop] = item[1];
      }
    });
  }
  each(keys(elOption), (key) => {
    if (key.indexOf("on") === 0) {
      const val = elOption[key];
      el[key] = isFunction(val) ? val : null;
    }
  });
  if (hasOwn(elOption, "draggable")) {
    el.draggable = elOption.draggable;
  }
  elOption.name != null && (el.name = elOption.name);
  elOption.id != null && (el.id = elOption.id);
}
function getCleanedElOption(elOption) {
  elOption = extend({}, elOption);
  each(["id", "parentId", "$action", "hv", "bounding", "textContent", "clipPath"].concat(LOCATION_PARAMS), function(name) {
    delete elOption[name];
  });
  return elOption;
}
function setEventData(el, graphicModel, elOption) {
  let eventData = getECData(el).eventData;
  if (!el.silent && !el.ignore && !eventData) {
    eventData = getECData(el).eventData = {
      componentType: "graphic",
      componentIndex: graphicModel.componentIndex,
      name: el.name
    };
  }
  if (eventData) {
    eventData.info = elOption.info;
  }
}

// src/component/graphic/install.ts
function install36(registers) {
  registers.registerComponentModel(GraphicComponentModel);
  registers.registerComponentView(GraphicComponentView);
  registers.registerPreprocessor(function(option) {
    const graphicOption = option.graphic;
    if (isArray(graphicOption)) {
      if (!graphicOption[0] || !graphicOption[0].elements) {
        option.graphic = [{elements: graphicOption}];
      } else {
        option.graphic = [option.graphic[0]];
      }
    } else if (graphicOption && !graphicOption.elements) {
      option.graphic = [{elements: [graphicOption]}];
    }
  });
}

// src/component/dataZoom/helper.ts
var DATA_ZOOM_AXIS_DIMENSIONS = [
  "x",
  "y",
  "radius",
  "angle",
  "single"
];
var SERIES_COORDS = ["cartesian2d", "polar", "singleAxis"];
function isCoordSupported(seriesModel) {
  const coordType = seriesModel.get("coordinateSystem");
  return indexOf(SERIES_COORDS, coordType) >= 0;
}
function getAxisMainType(axisDim) {
  if (true) {
    assert(axisDim);
  }
  return axisDim + "Axis";
}
function findEffectedDataZooms(ecModel, payload) {
  const axisRecords = createHashMap();
  const effectedModels = [];
  const effectedModelMap = createHashMap();
  ecModel.eachComponent({mainType: "dataZoom", query: payload}, function(dataZoomModel) {
    if (!effectedModelMap.get(dataZoomModel.uid)) {
      addToEffected(dataZoomModel);
    }
  });
  let foundNewLink;
  do {
    foundNewLink = false;
    ecModel.eachComponent("dataZoom", processSingle);
  } while (foundNewLink);
  function processSingle(dataZoomModel) {
    if (!effectedModelMap.get(dataZoomModel.uid) && isLinked(dataZoomModel)) {
      addToEffected(dataZoomModel);
      foundNewLink = true;
    }
  }
  function addToEffected(dataZoom) {
    effectedModelMap.set(dataZoom.uid, true);
    effectedModels.push(dataZoom);
    markAxisControlled(dataZoom);
  }
  function isLinked(dataZoomModel) {
    let isLink = false;
    dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
      const axisIdxArr = axisRecords.get(axisDim);
      if (axisIdxArr && axisIdxArr[axisIndex]) {
        isLink = true;
      }
    });
    return isLink;
  }
  function markAxisControlled(dataZoomModel) {
    dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
      (axisRecords.get(axisDim) || axisRecords.set(axisDim, []))[axisIndex] = true;
    });
  }
  return effectedModels;
}
function collectReferCoordSysModelInfo(dataZoomModel) {
  const ecModel = dataZoomModel.ecModel;
  const coordSysInfoWrap = {
    infoList: [],
    infoMap: createHashMap()
  };
  dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
    const axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
    if (!axisModel) {
      return;
    }
    const coordSysModel = axisModel.getCoordSysModel();
    if (!coordSysModel) {
      return;
    }
    const coordSysUid = coordSysModel.uid;
    let coordSysInfo = coordSysInfoWrap.infoMap.get(coordSysUid);
    if (!coordSysInfo) {
      coordSysInfo = {model: coordSysModel, axisModels: []};
      coordSysInfoWrap.infoList.push(coordSysInfo);
      coordSysInfoWrap.infoMap.set(coordSysUid, coordSysInfo);
    }
    coordSysInfo.axisModels.push(axisModel);
  });
  return coordSysInfoWrap;
}

// src/component/dataZoom/DataZoomModel.ts
var DataZoomAxisInfo = class {
  constructor() {
    this.indexList = [];
    this.indexMap = [];
  }
  add(axisCmptIdx) {
    if (!this.indexMap[axisCmptIdx]) {
      this.indexList.push(axisCmptIdx);
      this.indexMap[axisCmptIdx] = true;
    }
  }
};
var DataZoomModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = DataZoomModel2.type;
    this._autoThrottle = true;
    this._noTarget = true;
    this._rangePropMode = ["percent", "percent"];
  }
  init(option, parentModel, ecModel) {
    const inputRawOption = retrieveRawOption(option);
    this.settledOption = inputRawOption;
    this.mergeDefaultAndTheme(option, ecModel);
    this._doInit(inputRawOption);
  }
  mergeOption(newOption) {
    const inputRawOption = retrieveRawOption(newOption);
    merge(this.option, newOption, true);
    merge(this.settledOption, inputRawOption, true);
    this._doInit(inputRawOption);
  }
  _doInit(inputRawOption) {
    const thisOption = this.option;
    this._setDefaultThrottle(inputRawOption);
    this._updateRangeUse(inputRawOption);
    const settledOption = this.settledOption;
    each([["start", "startValue"], ["end", "endValue"]], function(names, index) {
      if (this._rangePropMode[index] === "value") {
        thisOption[names[0]] = settledOption[names[0]] = null;
      }
    }, this);
    this._resetTarget();
  }
  _resetTarget() {
    const optionOrient = this.get("orient", true);
    const targetAxisIndexMap = this._targetAxisInfoMap = createHashMap();
    const hasAxisSpecified = this._fillSpecifiedTargetAxis(targetAxisIndexMap);
    if (hasAxisSpecified) {
      this._orient = optionOrient || this._makeAutoOrientByTargetAxis();
    } else {
      this._orient = optionOrient || "horizontal";
      this._fillAutoTargetAxisByOrient(targetAxisIndexMap, this._orient);
    }
    this._noTarget = true;
    targetAxisIndexMap.each(function(axisInfo) {
      if (axisInfo.indexList.length) {
        this._noTarget = false;
      }
    }, this);
  }
  _fillSpecifiedTargetAxis(targetAxisIndexMap) {
    let hasAxisSpecified = false;
    each(DATA_ZOOM_AXIS_DIMENSIONS, function(axisDim) {
      const refering = this.getReferringComponents(getAxisMainType(axisDim), MULTIPLE_REFERRING);
      if (!refering.specified) {
        return;
      }
      hasAxisSpecified = true;
      const axisInfo = new DataZoomAxisInfo();
      each(refering.models, function(axisModel) {
        axisInfo.add(axisModel.componentIndex);
      });
      targetAxisIndexMap.set(axisDim, axisInfo);
    }, this);
    return hasAxisSpecified;
  }
  _fillAutoTargetAxisByOrient(targetAxisIndexMap, orient) {
    const ecModel = this.ecModel;
    let needAuto = true;
    if (needAuto) {
      const axisDim = orient === "vertical" ? "y" : "x";
      const axisModels = ecModel.findComponents({mainType: axisDim + "Axis"});
      setParallelAxis(axisModels, axisDim);
    }
    if (needAuto) {
      const axisModels = ecModel.findComponents({
        mainType: "singleAxis",
        filter: (axisModel) => axisModel.get("orient", true) === orient
      });
      setParallelAxis(axisModels, "single");
    }
    function setParallelAxis(axisModels, axisDim) {
      const axisModel = axisModels[0];
      if (!axisModel) {
        return;
      }
      const axisInfo = new DataZoomAxisInfo();
      axisInfo.add(axisModel.componentIndex);
      targetAxisIndexMap.set(axisDim, axisInfo);
      needAuto = false;
      if (axisDim === "x" || axisDim === "y") {
        const gridModel = axisModel.getReferringComponents("grid", SINGLE_REFERRING).models[0];
        gridModel && each(axisModels, function(axModel) {
          if (axisModel.componentIndex !== axModel.componentIndex && gridModel === axModel.getReferringComponents("grid", SINGLE_REFERRING).models[0]) {
            axisInfo.add(axModel.componentIndex);
          }
        });
      }
    }
    if (needAuto) {
      each(DATA_ZOOM_AXIS_DIMENSIONS, function(axisDim) {
        if (!needAuto) {
          return;
        }
        const axisModels = ecModel.findComponents({
          mainType: getAxisMainType(axisDim),
          filter: (axisModel) => axisModel.get("type", true) === "category"
        });
        if (axisModels[0]) {
          const axisInfo = new DataZoomAxisInfo();
          axisInfo.add(axisModels[0].componentIndex);
          targetAxisIndexMap.set(axisDim, axisInfo);
          needAuto = false;
        }
      }, this);
    }
  }
  _makeAutoOrientByTargetAxis() {
    let dim;
    this.eachTargetAxis(function(axisDim) {
      !dim && (dim = axisDim);
    }, this);
    return dim === "y" ? "vertical" : "horizontal";
  }
  _setDefaultThrottle(inputRawOption) {
    if (inputRawOption.hasOwnProperty("throttle")) {
      this._autoThrottle = false;
    }
    if (this._autoThrottle) {
      const globalOption = this.ecModel.option;
      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;
    }
  }
  _updateRangeUse(inputRawOption) {
    const rangePropMode = this._rangePropMode;
    const rangeModeInOption = this.get("rangeMode");
    each([["start", "startValue"], ["end", "endValue"]], function(names, index) {
      const percentSpecified = inputRawOption[names[0]] != null;
      const valueSpecified = inputRawOption[names[1]] != null;
      if (percentSpecified && !valueSpecified) {
        rangePropMode[index] = "percent";
      } else if (!percentSpecified && valueSpecified) {
        rangePropMode[index] = "value";
      } else if (rangeModeInOption) {
        rangePropMode[index] = rangeModeInOption[index];
      } else if (percentSpecified) {
        rangePropMode[index] = "percent";
      }
    });
  }
  noTarget() {
    return this._noTarget;
  }
  getFirstTargetAxisModel() {
    let firstAxisModel;
    this.eachTargetAxis(function(axisDim, axisIndex) {
      if (firstAxisModel == null) {
        firstAxisModel = this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
      }
    }, this);
    return firstAxisModel;
  }
  eachTargetAxis(callback, context) {
    this._targetAxisInfoMap.each(function(axisInfo, axisDim) {
      each(axisInfo.indexList, function(axisIndex) {
        callback.call(context, axisDim, axisIndex);
      });
    });
  }
  getAxisProxy(axisDim, axisIndex) {
    const axisModel = this.getAxisModel(axisDim, axisIndex);
    if (axisModel) {
      return axisModel.__dzAxisProxy;
    }
  }
  getAxisModel(axisDim, axisIndex) {
    if (true) {
      assert(axisDim && axisIndex != null);
    }
    const axisInfo = this._targetAxisInfoMap.get(axisDim);
    if (axisInfo && axisInfo.indexMap[axisIndex]) {
      return this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
    }
  }
  setRawRange(opt) {
    const thisOption = this.option;
    const settledOption = this.settledOption;
    each([["start", "startValue"], ["end", "endValue"]], function(names) {
      if (opt[names[0]] != null || opt[names[1]] != null) {
        thisOption[names[0]] = settledOption[names[0]] = opt[names[0]];
        thisOption[names[1]] = settledOption[names[1]] = opt[names[1]];
      }
    }, this);
    this._updateRangeUse(opt);
  }
  setCalculatedRange(opt) {
    const option = this.option;
    each(["start", "startValue", "end", "endValue"], function(name) {
      option[name] = opt[name];
    });
  }
  getPercentRange() {
    const axisProxy = this.findRepresentativeAxisProxy();
    if (axisProxy) {
      return axisProxy.getDataPercentWindow();
    }
  }
  getValueRange(axisDim, axisIndex) {
    if (axisDim == null && axisIndex == null) {
      const axisProxy = this.findRepresentativeAxisProxy();
      if (axisProxy) {
        return axisProxy.getDataValueWindow();
      }
    } else {
      return this.getAxisProxy(axisDim, axisIndex).getDataValueWindow();
    }
  }
  findRepresentativeAxisProxy(axisModel) {
    if (axisModel) {
      return axisModel.__dzAxisProxy;
    }
    let firstProxy;
    const axisDimList = this._targetAxisInfoMap.keys();
    for (let i = 0; i < axisDimList.length; i++) {
      const axisDim = axisDimList[i];
      const axisInfo = this._targetAxisInfoMap.get(axisDim);
      for (let j = 0; j < axisInfo.indexList.length; j++) {
        const proxy = this.getAxisProxy(axisDim, axisInfo.indexList[j]);
        if (proxy.hostedBy(this)) {
          return proxy;
        }
        if (!firstProxy) {
          firstProxy = proxy;
        }
      }
    }
    return firstProxy;
  }
  getRangePropMode() {
    return this._rangePropMode.slice();
  }
  getOrient() {
    if (true) {
      assert(this._orient);
    }
    return this._orient;
  }
};
var DataZoomModel = DataZoomModel2;
DataZoomModel.type = "dataZoom";
DataZoomModel.dependencies = [
  "xAxis",
  "yAxis",
  "radiusAxis",
  "angleAxis",
  "singleAxis",
  "series",
  "toolbox"
];
DataZoomModel.defaultOption = {
  z: 4,
  filterMode: "filter",
  start: 0,
  end: 100
};
function retrieveRawOption(option) {
  const ret = {};
  each(["start", "end", "startValue", "endValue", "throttle"], function(name) {
    option.hasOwnProperty(name) && (ret[name] = option[name]);
  });
  return ret;
}
var DataZoomModel_default = DataZoomModel;

// src/component/dataZoom/SelectZoomModel.ts
var SelectDataZoomModel2 = class extends DataZoomModel_default {
  constructor() {
    super(...arguments);
    this.type = SelectDataZoomModel2.type;
  }
};
var SelectDataZoomModel = SelectDataZoomModel2;
SelectDataZoomModel.type = "dataZoom.select";
var SelectZoomModel_default = SelectDataZoomModel;

// src/component/dataZoom/DataZoomView.ts
var DataZoomView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = DataZoomView2.type;
  }
  render(dataZoomModel, ecModel, api2, payload) {
    this.dataZoomModel = dataZoomModel;
    this.ecModel = ecModel;
    this.api = api2;
  }
};
var DataZoomView = DataZoomView2;
DataZoomView.type = "dataZoom";
var DataZoomView_default = DataZoomView;

// src/component/dataZoom/SelectZoomView.ts
var SelectDataZoomView2 = class extends DataZoomView_default {
  constructor() {
    super(...arguments);
    this.type = SelectDataZoomView2.type;
  }
};
var SelectDataZoomView = SelectDataZoomView2;
SelectDataZoomView.type = "dataZoom.select";
var SelectZoomView_default = SelectDataZoomView;

// src/component/dataZoom/AxisProxy.ts
var each9 = each;
var asc2 = asc;
var AxisProxy = class {
  constructor(dimName, axisIndex, dataZoomModel, ecModel) {
    this._dimName = dimName;
    this._axisIndex = axisIndex;
    this.ecModel = ecModel;
    this._dataZoomModel = dataZoomModel;
  }
  hostedBy(dataZoomModel) {
    return this._dataZoomModel === dataZoomModel;
  }
  getDataValueWindow() {
    return this._valueWindow.slice();
  }
  getDataPercentWindow() {
    return this._percentWindow.slice();
  }
  getTargetSeriesModels() {
    const seriesModels = [];
    this.ecModel.eachSeries(function(seriesModel) {
      if (isCoordSupported(seriesModel)) {
        const axisMainType = getAxisMainType(this._dimName);
        const axisModel = seriesModel.getReferringComponents(axisMainType, SINGLE_REFERRING).models[0];
        if (axisModel && this._axisIndex === axisModel.componentIndex) {
          seriesModels.push(seriesModel);
        }
      }
    }, this);
    return seriesModels;
  }
  getAxisModel() {
    return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
  }
  getMinMaxSpan() {
    return clone(this._minMaxSpan);
  }
  calculateDataWindow(opt) {
    const dataExtent = this._dataExtent;
    const axisModel = this.getAxisModel();
    const scale4 = axisModel.axis.scale;
    const rangePropMode = this._dataZoomModel.getRangePropMode();
    const percentExtent = [0, 100];
    const percentWindow = [];
    const valueWindow = [];
    let hasPropModeValue;
    each9(["start", "end"], function(prop, idx) {
      let boundPercent = opt[prop];
      let boundValue = opt[prop + "Value"];
      if (rangePropMode[idx] === "percent") {
        boundPercent == null && (boundPercent = percentExtent[idx]);
        boundValue = scale4.parse(linearMap(boundPercent, percentExtent, dataExtent));
      } else {
        hasPropModeValue = true;
        boundValue = boundValue == null ? dataExtent[idx] : scale4.parse(boundValue);
        boundPercent = linearMap(boundValue, dataExtent, percentExtent);
      }
      valueWindow[idx] = boundValue == null || isNaN(boundValue) ? dataExtent[idx] : boundValue;
      percentWindow[idx] = boundPercent == null || isNaN(boundPercent) ? percentExtent[idx] : boundPercent;
    });
    asc2(valueWindow);
    asc2(percentWindow);
    const spans = this._minMaxSpan;
    hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);
    function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {
      const suffix = toValue ? "Span" : "ValueSpan";
      sliderMove(0, fromWindow, fromExtent, "all", spans["min" + suffix], spans["max" + suffix]);
      for (let i = 0; i < 2; i++) {
        toWindow[i] = linearMap(fromWindow[i], fromExtent, toExtent, true);
        toValue && (toWindow[i] = scale4.parse(toWindow[i]));
      }
    }
    return {
      valueWindow,
      percentWindow
    };
  }
  reset(dataZoomModel) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    }
    const targetSeries = this.getTargetSeriesModels();
    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries);
    this._updateMinMaxSpan();
    const dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);
    this._valueWindow = dataWindow.valueWindow;
    this._percentWindow = dataWindow.percentWindow;
    this._setAxisModel();
  }
  filterData(dataZoomModel, api2) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    }
    const axisDim = this._dimName;
    const seriesModels = this.getTargetSeriesModels();
    const filterMode = dataZoomModel.get("filterMode");
    const valueWindow = this._valueWindow;
    if (filterMode === "none") {
      return;
    }
    each9(seriesModels, function(seriesModel) {
      let seriesData = seriesModel.getData();
      const dataDims = seriesData.mapDimensionsAll(axisDim);
      if (!dataDims.length) {
        return;
      }
      if (filterMode === "weakFilter") {
        const store = seriesData.getStore();
        const dataDimIndices = map(dataDims, (dim) => seriesData.getDimensionIndex(dim), seriesData);
        seriesData.filterSelf(function(dataIndex) {
          let leftOut;
          let rightOut;
          let hasValue;
          for (let i = 0; i < dataDims.length; i++) {
            const value = store.get(dataDimIndices[i], dataIndex);
            const thisHasValue = !isNaN(value);
            const thisLeftOut = value < valueWindow[0];
            const thisRightOut = value > valueWindow[1];
            if (thisHasValue && !thisLeftOut && !thisRightOut) {
              return true;
            }
            thisHasValue && (hasValue = true);
            thisLeftOut && (leftOut = true);
            thisRightOut && (rightOut = true);
          }
          return hasValue && leftOut && rightOut;
        });
      } else {
        each9(dataDims, function(dim) {
          if (filterMode === "empty") {
            seriesModel.setData(seriesData = seriesData.map(dim, function(value) {
              return !isInWindow(value) ? NaN : value;
            }));
          } else {
            const range = {};
            range[dim] = valueWindow;
            seriesData.selectRange(range);
          }
        });
      }
      each9(dataDims, function(dim) {
        seriesData.setApproximateExtent(valueWindow, dim);
      });
    });
    function isInWindow(value) {
      return value >= valueWindow[0] && value <= valueWindow[1];
    }
  }
  _updateMinMaxSpan() {
    const minMaxSpan = this._minMaxSpan = {};
    const dataZoomModel = this._dataZoomModel;
    const dataExtent = this._dataExtent;
    each9(["min", "max"], function(minMax) {
      let percentSpan = dataZoomModel.get(minMax + "Span");
      let valueSpan = dataZoomModel.get(minMax + "ValueSpan");
      valueSpan != null && (valueSpan = this.getAxisModel().axis.scale.parse(valueSpan));
      if (valueSpan != null) {
        percentSpan = linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);
      } else if (percentSpan != null) {
        valueSpan = linearMap(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];
      }
      minMaxSpan[minMax + "Span"] = percentSpan;
      minMaxSpan[minMax + "ValueSpan"] = valueSpan;
    }, this);
  }
  _setAxisModel() {
    const axisModel = this.getAxisModel();
    const percentWindow = this._percentWindow;
    const valueWindow = this._valueWindow;
    if (!percentWindow) {
      return;
    }
    let precision = getPixelPrecision(valueWindow, [0, 500]);
    precision = Math.min(precision, 20);
    const rawExtentInfo = axisModel.axis.scale.rawExtentInfo;
    if (percentWindow[0] !== 0) {
      rawExtentInfo.setDeterminedMinMax("min", +valueWindow[0].toFixed(precision));
    }
    if (percentWindow[1] !== 100) {
      rawExtentInfo.setDeterminedMinMax("max", +valueWindow[1].toFixed(precision));
    }
    rawExtentInfo.freeze();
  }
};
function calculateDataExtent(axisProxy, axisDim, seriesModels) {
  const dataExtent = [Infinity, -Infinity];
  each9(seriesModels, function(seriesModel) {
    unionAxisExtentFromData(dataExtent, seriesModel.getData(), axisDim);
  });
  const axisModel = axisProxy.getAxisModel();
  const rawExtentResult = ensureScaleRawExtentInfo(axisModel.axis.scale, axisModel, dataExtent).calculate();
  return [rawExtentResult.min, rawExtentResult.max];
}
var AxisProxy_default = AxisProxy;

// src/component/dataZoom/dataZoomProcessor.ts
var dataZoomProcessor = {
  getTargetSeries(ecModel) {
    function eachAxisModel(cb) {
      ecModel.eachComponent("dataZoom", function(dataZoomModel) {
        dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
          const axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
          cb(axisDim, axisIndex, axisModel, dataZoomModel);
        });
      });
    }
    eachAxisModel(function(axisDim, axisIndex, axisModel, dataZoomModel) {
      axisModel.__dzAxisProxy = null;
    });
    const proxyList = [];
    eachAxisModel(function(axisDim, axisIndex, axisModel, dataZoomModel) {
      if (!axisModel.__dzAxisProxy) {
        axisModel.__dzAxisProxy = new AxisProxy_default(axisDim, axisIndex, dataZoomModel, ecModel);
        proxyList.push(axisModel.__dzAxisProxy);
      }
    });
    const seriesModelMap = createHashMap();
    each(proxyList, function(axisProxy) {
      each(axisProxy.getTargetSeriesModels(), function(seriesModel) {
        seriesModelMap.set(seriesModel.uid, seriesModel);
      });
    });
    return seriesModelMap;
  },
  overallReset(ecModel, api2) {
    ecModel.eachComponent("dataZoom", function(dataZoomModel) {
      dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
        dataZoomModel.getAxisProxy(axisDim, axisIndex).reset(dataZoomModel);
      });
      dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
        dataZoomModel.getAxisProxy(axisDim, axisIndex).filterData(dataZoomModel, api2);
      });
    });
    ecModel.eachComponent("dataZoom", function(dataZoomModel) {
      const axisProxy = dataZoomModel.findRepresentativeAxisProxy();
      if (axisProxy) {
        const percentRange = axisProxy.getDataPercentWindow();
        const valueRange = axisProxy.getDataValueWindow();
        dataZoomModel.setCalculatedRange({
          start: percentRange[0],
          end: percentRange[1],
          startValue: valueRange[0],
          endValue: valueRange[1]
        });
      }
    });
  }
};
var dataZoomProcessor_default = dataZoomProcessor;

// src/component/dataZoom/dataZoomAction.ts
function installDataZoomAction(registers) {
  registers.registerAction("dataZoom", function(payload, ecModel) {
    const effectedModels = findEffectedDataZooms(ecModel, payload);
    each(effectedModels, function(dataZoomModel) {
      dataZoomModel.setRawRange({
        start: payload.start,
        end: payload.end,
        startValue: payload.startValue,
        endValue: payload.endValue
      });
    });
  });
}

// src/component/dataZoom/installCommon.ts
var installed = false;
function installCommon(registers) {
  if (installed) {
    return;
  }
  installed = true;
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, dataZoomProcessor_default);
  installDataZoomAction(registers);
  registers.registerSubTypeDefaulter("dataZoom", function() {
    return "slider";
  });
}

// src/component/dataZoom/installDataZoomSelect.ts
function install37(registers) {
  registers.registerComponentModel(SelectZoomModel_default);
  registers.registerComponentView(SelectZoomView_default);
  installCommon(registers);
}

// src/component/toolbox/featureManager.ts
var ToolboxFeature = class {
};
var features = {};
function registerFeature(name, ctor) {
  features[name] = ctor;
}
function getFeature(name) {
  return features[name];
}

// src/component/toolbox/ToolboxModel.ts
var ToolboxModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = ToolboxModel2.type;
  }
  optionUpdated() {
    super.optionUpdated.apply(this, arguments);
    const {ecModel} = this;
    each(this.option.feature, function(featureOpt, featureName) {
      const Feature = getFeature(featureName);
      if (Feature) {
        if (Feature.getDefaultOption) {
          Feature.defaultOption = Feature.getDefaultOption(ecModel);
        }
        merge(featureOpt, Feature.defaultOption);
      }
    });
  }
};
var ToolboxModel = ToolboxModel2;
ToolboxModel.type = "toolbox";
ToolboxModel.layoutMode = {
  type: "box",
  ignoreSize: true
};
ToolboxModel.defaultOption = {
  show: true,
  z: 6,
  orient: "horizontal",
  left: "right",
  top: "top",
  backgroundColor: "transparent",
  borderColor: tokens_default.color.border,
  borderRadius: 0,
  borderWidth: 0,
  padding: tokens_default.size.m,
  itemSize: 15,
  itemGap: tokens_default.size.s,
  showTitle: true,
  iconStyle: {
    borderColor: tokens_default.color.accent50,
    color: "none"
  },
  emphasis: {
    iconStyle: {
      borderColor: tokens_default.color.accent50
    }
  },
  tooltip: {
    show: false,
    position: "bottom"
  }
};
var ToolboxModel_default = ToolboxModel;

// src/component/helper/listComponent.ts
function makeBackground(rect, componentModel) {
  const padding = normalizeCssArray2(componentModel.get("padding"));
  const style = componentModel.getItemStyle(["color", "opacity"]);
  style.fill = componentModel.get("backgroundColor");
  const bgRect = new Rect_default({
    shape: {
      x: rect.x - padding[3],
      y: rect.y - padding[0],
      width: rect.width + padding[1] + padding[3],
      height: rect.height + padding[0] + padding[2],
      r: componentModel.get("borderRadius")
    },
    style,
    silent: true,
    z2: -1
  });
  return bgRect;
}

// src/component/toolbox/ToolboxView.ts
var ToolboxView = class extends Component_default2 {
  render(toolboxModel, ecModel, api2, payload) {
    const group = this.group;
    group.removeAll();
    if (!toolboxModel.get("show")) {
      return;
    }
    const itemSize = +toolboxModel.get("itemSize");
    const isVertical = toolboxModel.get("orient") === "vertical";
    const featureOpts = toolboxModel.get("feature") || {};
    const features2 = this._features || (this._features = {});
    const featureNames = [];
    each(featureOpts, function(opt, name) {
      featureNames.push(name);
    });
    new DataDiffer_default(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(curry(processFeature, null)).execute();
    this._featureNames = featureNames;
    function processFeature(newIndex, oldIndex) {
      const featureName = featureNames[newIndex];
      const oldName = featureNames[oldIndex];
      const featureOpt = featureOpts[featureName];
      const featureModel = new Model_default(featureOpt, toolboxModel, toolboxModel.ecModel);
      let feature;
      if (payload && payload.newTitle != null && payload.featureName === featureName) {
        featureOpt.title = payload.newTitle;
      }
      if (featureName && !oldName) {
        if (isUserFeatureName(featureName)) {
          feature = {
            onclick: featureModel.option.onclick,
            featureName
          };
        } else {
          const Feature = getFeature(featureName);
          if (!Feature) {
            return;
          }
          feature = new Feature();
        }
        features2[featureName] = feature;
      } else {
        feature = features2[oldName];
        if (!feature) {
          return;
        }
      }
      feature.uid = getUID("toolbox-feature");
      feature.model = featureModel;
      feature.ecModel = ecModel;
      feature.api = api2;
      const isToolboxFeature = feature instanceof ToolboxFeature;
      if (!featureName && oldName) {
        isToolboxFeature && feature.dispose && feature.dispose(ecModel, api2);
        return;
      }
      if (!featureModel.get("show") || isToolboxFeature && feature.unusable) {
        isToolboxFeature && feature.remove && feature.remove(ecModel, api2);
        return;
      }
      createIconPaths(featureModel, feature, featureName);
      featureModel.setIconStatus = function(iconName, status) {
        const option = this.option;
        const iconPaths = this.iconPaths;
        option.iconStatus = option.iconStatus || {};
        option.iconStatus[iconName] = status;
        if (iconPaths[iconName]) {
          (status === "emphasis" ? enterEmphasis : leaveEmphasis)(iconPaths[iconName]);
        }
      };
      if (feature instanceof ToolboxFeature) {
        if (feature.render) {
          feature.render(featureModel, ecModel, api2, payload);
        }
      }
    }
    function createIconPaths(featureModel, feature, featureName) {
      const iconStyleModel = featureModel.getModel("iconStyle");
      const iconStyleEmphasisModel = featureModel.getModel(["emphasis", "iconStyle"]);
      const icons = feature instanceof ToolboxFeature && feature.getIcons ? feature.getIcons() : featureModel.get("icon");
      const titles = featureModel.get("title") || {};
      let iconsMap;
      let titlesMap;
      if (isString(icons)) {
        iconsMap = {};
        iconsMap[featureName] = icons;
      } else {
        iconsMap = icons;
      }
      if (isString(titles)) {
        titlesMap = {};
        titlesMap[featureName] = titles;
      } else {
        titlesMap = titles;
      }
      const iconPaths = featureModel.iconPaths = {};
      each(iconsMap, function(iconStr, iconName) {
        const path = createIcon(iconStr, {}, {
          x: -itemSize / 2,
          y: -itemSize / 2,
          width: itemSize,
          height: itemSize
        });
        path.setStyle(iconStyleModel.getItemStyle());
        const pathEmphasisState = path.ensureState("emphasis");
        pathEmphasisState.style = iconStyleEmphasisModel.getItemStyle();
        const textContent = new Text_default({
          style: {
            text: titlesMap[iconName],
            align: iconStyleEmphasisModel.get("textAlign"),
            borderRadius: iconStyleEmphasisModel.get("textBorderRadius"),
            padding: iconStyleEmphasisModel.get("textPadding"),
            fill: null,
            font: getFont({
              fontStyle: iconStyleEmphasisModel.get("textFontStyle"),
              fontFamily: iconStyleEmphasisModel.get("textFontFamily"),
              fontSize: iconStyleEmphasisModel.get("textFontSize"),
              fontWeight: iconStyleEmphasisModel.get("textFontWeight")
            }, ecModel)
          },
          ignore: true
        });
        path.setTextContent(textContent);
        setTooltipConfig({
          el: path,
          componentModel: toolboxModel,
          itemName: iconName,
          formatterParamsExtra: {
            title: titlesMap[iconName]
          }
        });
        path.__title = titlesMap[iconName];
        path.on("mouseover", function() {
          const hoverStyle = iconStyleEmphasisModel.getItemStyle();
          const defaultTextPosition = isVertical ? toolboxModel.get("right") == null && toolboxModel.get("left") !== "right" ? "right" : "left" : toolboxModel.get("bottom") == null && toolboxModel.get("top") !== "bottom" ? "bottom" : "top";
          textContent.setStyle({
            fill: iconStyleEmphasisModel.get("textFill") || hoverStyle.fill || hoverStyle.stroke || tokens_default.color.neutral99,
            backgroundColor: iconStyleEmphasisModel.get("textBackgroundColor")
          });
          path.setTextConfig({
            position: iconStyleEmphasisModel.get("textPosition") || defaultTextPosition
          });
          textContent.ignore = !toolboxModel.get("showTitle");
          api2.enterEmphasis(this);
        }).on("mouseout", function() {
          if (featureModel.get(["iconStatus", iconName]) !== "emphasis") {
            api2.leaveEmphasis(this);
          }
          textContent.hide();
        });
        (featureModel.get(["iconStatus", iconName]) === "emphasis" ? enterEmphasis : leaveEmphasis)(path);
        group.add(path);
        path.on("click", bind(feature.onclick, feature, ecModel, api2, iconName));
        iconPaths[iconName] = path;
      });
    }
    const refContainer = createBoxLayoutReference(toolboxModel, api2).refContainer;
    const boxLayoutParams = toolboxModel.getBoxLayoutParams();
    const padding = toolboxModel.get("padding");
    const viewRect2 = getLayoutRect(boxLayoutParams, refContainer, padding);
    box(toolboxModel.get("orient"), group, toolboxModel.get("itemGap"), viewRect2.width, viewRect2.height);
    positionElement(group, boxLayoutParams, refContainer, padding);
    group.add(makeBackground(group.getBoundingRect(), toolboxModel));
    isVertical || group.eachChild(function(icon) {
      const titleText = icon.__title;
      const emphasisState = icon.ensureState("emphasis");
      const emphasisTextConfig = emphasisState.textConfig || (emphasisState.textConfig = {});
      const textContent = icon.getTextContent();
      const emphasisTextState = textContent && textContent.ensureState("emphasis");
      if (emphasisTextState && !isFunction(emphasisTextState) && titleText) {
        const emphasisTextStyle = emphasisTextState.style || (emphasisTextState.style = {});
        const rect = getBoundingRect(titleText, Text_default.makeFont(emphasisTextStyle));
        const offsetX = icon.x + group.x;
        const offsetY = icon.y + group.y + itemSize;
        let needPutOnTop = false;
        if (offsetY + rect.height > api2.getHeight()) {
          emphasisTextConfig.position = "top";
          needPutOnTop = true;
        }
        const topOffset = needPutOnTop ? -5 - rect.height : itemSize + 10;
        if (offsetX + rect.width / 2 > api2.getWidth()) {
          emphasisTextConfig.position = ["100%", topOffset];
          emphasisTextStyle.align = "right";
        } else if (offsetX - rect.width / 2 < 0) {
          emphasisTextConfig.position = [0, topOffset];
          emphasisTextStyle.align = "left";
        }
      }
    });
  }
  updateView(toolboxModel, ecModel, api2, payload) {
    each(this._features, function(feature) {
      feature instanceof ToolboxFeature && feature.updateView && feature.updateView(feature.model, ecModel, api2, payload);
    });
  }
  remove(ecModel, api2) {
    each(this._features, function(feature) {
      feature instanceof ToolboxFeature && feature.remove && feature.remove(ecModel, api2);
    });
    this.group.removeAll();
  }
  dispose(ecModel, api2) {
    each(this._features, function(feature) {
      feature instanceof ToolboxFeature && feature.dispose && feature.dispose(ecModel, api2);
    });
  }
};
ToolboxView.type = "toolbox";
function isUserFeatureName(featureName) {
  return featureName.indexOf("my") === 0;
}
var ToolboxView_default = ToolboxView;

// src/component/toolbox/feature/SaveAsImage.ts
var SaveAsImage = class extends ToolboxFeature {
  onclick(ecModel, api2) {
    const model = this.model;
    const title = model.get("name") || ecModel.get("title.0.text") || "echarts";
    const isSvg = api2.getZr().painter.getType() === "svg";
    const type = isSvg ? "svg" : model.get("type", true) || "png";
    const url = api2.getConnectedDataURL({
      type,
      backgroundColor: model.get("backgroundColor", true) || ecModel.get("backgroundColor") || tokens_default.color.neutral00,
      connectedBackgroundColor: model.get("connectedBackgroundColor"),
      excludeComponents: model.get("excludeComponents"),
      pixelRatio: model.get("pixelRatio")
    });
    const browser = env_default.browser;
    if (typeof MouseEvent === "function" && (browser.newEdge || !browser.ie && !browser.edge)) {
      const $a = document.createElement("a");
      $a.download = title + "." + type;
      $a.target = "_blank";
      $a.href = url;
      const evt = new MouseEvent("click", {
        view: document.defaultView,
        bubbles: true,
        cancelable: false
      });
      $a.dispatchEvent(evt);
    } else {
      if (window.navigator.msSaveOrOpenBlob || isSvg) {
        const parts = url.split(",");
        const base64Encoded = parts[0].indexOf("base64") > -1;
        let bstr = isSvg ? decodeURIComponent(parts[1]) : parts[1];
        base64Encoded && (bstr = window.atob(bstr));
        const filename = title + "." + type;
        if (window.navigator.msSaveOrOpenBlob) {
          let n = bstr.length;
          const u8arr = new Uint8Array(n);
          while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
          }
          const blob = new Blob([u8arr]);
          window.navigator.msSaveOrOpenBlob(blob, filename);
        } else {
          const frame = document.createElement("iframe");
          document.body.appendChild(frame);
          const cw = frame.contentWindow;
          const doc = cw.document;
          doc.open("image/svg+xml", "replace");
          doc.write(bstr);
          doc.close();
          cw.focus();
          doc.execCommand("SaveAs", true, filename);
          document.body.removeChild(frame);
        }
      } else {
        const lang = model.get("lang");
        const html = '<body style="margin:0;"><img src="' + url + '" style="max-width:100%;" title="' + (lang && lang[0] || "") + '" /></body>';
        const tab = window.open();
        tab.document.write(html);
        tab.document.title = title;
      }
    }
  }
  static getDefaultOption(ecModel) {
    const defaultOption3 = {
      show: true,
      icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
      title: ecModel.getLocaleModel().get(["toolbox", "saveAsImage", "title"]),
      type: "png",
      connectedBackgroundColor: tokens_default.color.neutral00,
      name: "",
      excludeComponents: ["toolbox"],
      lang: ecModel.getLocaleModel().get(["toolbox", "saveAsImage", "lang"])
    };
    return defaultOption3;
  }
};
var SaveAsImage_default = SaveAsImage;

// src/component/toolbox/feature/MagicType.ts
var INNER_STACK_KEYWORD = "__ec_magicType_stack__";
var radioTypes = [
  ["line", "bar"],
  ["stack"]
];
var MagicType = class extends ToolboxFeature {
  getIcons() {
    const model = this.model;
    const availableIcons = model.get("icon");
    const icons = {};
    each(model.get("type"), function(type) {
      if (availableIcons[type]) {
        icons[type] = availableIcons[type];
      }
    });
    return icons;
  }
  static getDefaultOption(ecModel) {
    const defaultOption3 = {
      show: true,
      type: [],
      icon: {
        line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
        bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
        stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
      },
      title: ecModel.getLocaleModel().get(["toolbox", "magicType", "title"]),
      option: {},
      seriesIndex: {}
    };
    return defaultOption3;
  }
  onclick(ecModel, api2, type) {
    const model = this.model;
    const seriesIndex = model.get(["seriesIndex", type]);
    if (!seriesOptGenreator[type]) {
      return;
    }
    const newOption = {
      series: []
    };
    const generateNewSeriesTypes = function(seriesModel) {
      const seriesType2 = seriesModel.subType;
      const seriesId = seriesModel.id;
      const newSeriesOpt = seriesOptGenreator[type](seriesType2, seriesId, seriesModel, model);
      if (newSeriesOpt) {
        defaults(newSeriesOpt, seriesModel.option);
        newOption.series.push(newSeriesOpt);
      }
      const coordSys = seriesModel.coordinateSystem;
      if (coordSys && coordSys.type === "cartesian2d" && (type === "line" || type === "bar")) {
        const categoryAxis2 = coordSys.getAxesByScale("ordinal")[0];
        if (categoryAxis2) {
          const axisDim = categoryAxis2.dim;
          const axisType = axisDim + "Axis";
          const axisModel = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0];
          const axisIndex = axisModel.componentIndex;
          newOption[axisType] = newOption[axisType] || [];
          for (let i = 0; i <= axisIndex; i++) {
            newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};
          }
          newOption[axisType][axisIndex].boundaryGap = type === "bar";
        }
      }
    };
    each(radioTypes, function(radio) {
      if (indexOf(radio, type) >= 0) {
        each(radio, function(item) {
          model.setIconStatus(item, "normal");
        });
      }
    });
    model.setIconStatus(type, "emphasis");
    ecModel.eachComponent({
      mainType: "series",
      query: seriesIndex == null ? null : {
        seriesIndex
      }
    }, generateNewSeriesTypes);
    let newTitle;
    let currentType = type;
    if (type === "stack") {
      newTitle = merge({
        stack: model.option.title.tiled,
        tiled: model.option.title.stack
      }, model.option.title);
      if (model.get(["iconStatus", type]) !== "emphasis") {
        currentType = "tiled";
      }
    }
    api2.dispatchAction({
      type: "changeMagicType",
      currentType,
      newOption,
      newTitle,
      featureName: "magicType"
    });
  }
};
var seriesOptGenreator = {
  line: function(seriesType2, seriesId, seriesModel, model) {
    if (seriesType2 === "bar") {
      return merge({
        id: seriesId,
        type: "line",
        data: seriesModel.get("data"),
        stack: seriesModel.get("stack"),
        markPoint: seriesModel.get("markPoint"),
        markLine: seriesModel.get("markLine")
      }, model.get(["option", "line"]) || {}, true);
    }
  },
  bar: function(seriesType2, seriesId, seriesModel, model) {
    if (seriesType2 === "line") {
      return merge({
        id: seriesId,
        type: "bar",
        data: seriesModel.get("data"),
        stack: seriesModel.get("stack"),
        markPoint: seriesModel.get("markPoint"),
        markLine: seriesModel.get("markLine")
      }, model.get(["option", "bar"]) || {}, true);
    }
  },
  stack: function(seriesType2, seriesId, seriesModel, model) {
    const isStack = seriesModel.get("stack") === INNER_STACK_KEYWORD;
    if (seriesType2 === "line" || seriesType2 === "bar") {
      model.setIconStatus("stack", isStack ? "normal" : "emphasis");
      return merge({
        id: seriesId,
        stack: isStack ? "" : INNER_STACK_KEYWORD
      }, model.get(["option", "stack"]) || {}, true);
    }
  }
};
registerAction({
  type: "changeMagicType",
  event: "magicTypeChanged",
  update: "prepareAndUpdate"
}, function(payload, ecModel) {
  ecModel.mergeOption(payload.newOption);
});
var MagicType_default = MagicType;

// src/component/toolbox/feature/DataView.ts
var BLOCK_SPLITER = new Array(60).join("-");
var ITEM_SPLITER = "	";
function groupSeries(ecModel) {
  const seriesGroupByCategoryAxis = {};
  const otherSeries = [];
  const meta = [];
  ecModel.eachRawSeries(function(seriesModel) {
    const coordSys = seriesModel.coordinateSystem;
    if (coordSys && (coordSys.type === "cartesian2d" || coordSys.type === "polar")) {
      const baseAxis = coordSys.getBaseAxis();
      if (baseAxis.type === "category") {
        const key = baseAxis.dim + "_" + baseAxis.index;
        if (!seriesGroupByCategoryAxis[key]) {
          seriesGroupByCategoryAxis[key] = {
            categoryAxis: baseAxis,
            valueAxis: coordSys.getOtherAxis(baseAxis),
            series: []
          };
          meta.push({
            axisDim: baseAxis.dim,
            axisIndex: baseAxis.index
          });
        }
        seriesGroupByCategoryAxis[key].series.push(seriesModel);
      } else {
        otherSeries.push(seriesModel);
      }
    } else {
      otherSeries.push(seriesModel);
    }
  });
  return {
    seriesGroupByCategoryAxis,
    other: otherSeries,
    meta
  };
}
function assembleSeriesWithCategoryAxis(groups) {
  const tables = [];
  each(groups, function(group, key) {
    const categoryAxis2 = group.categoryAxis;
    const valueAxis2 = group.valueAxis;
    const valueAxisDim = valueAxis2.dim;
    const headers = [" "].concat(map(group.series, function(series) {
      return series.name;
    }));
    const columns = [categoryAxis2.model.getCategories()];
    each(group.series, function(series) {
      const rawData = series.getRawData();
      columns.push(series.getRawData().mapArray(rawData.mapDimension(valueAxisDim), function(val) {
        return val;
      }));
    });
    const lines = [headers.join(ITEM_SPLITER)];
    for (let i = 0; i < columns[0].length; i++) {
      const items = [];
      for (let j = 0; j < columns.length; j++) {
        items.push(columns[j][i]);
      }
      lines.push(items.join(ITEM_SPLITER));
    }
    tables.push(lines.join("\n"));
  });
  return tables.join("\n\n" + BLOCK_SPLITER + "\n\n");
}
function assembleOtherSeries(series) {
  return map(series, function(series2) {
    const data = series2.getRawData();
    const lines = [series2.name];
    const vals = [];
    data.each(data.dimensions, function() {
      const argLen = arguments.length;
      const dataIndex = arguments[argLen - 1];
      const name = data.getName(dataIndex);
      for (let i = 0; i < argLen - 1; i++) {
        vals[i] = arguments[i];
      }
      lines.push((name ? name + ITEM_SPLITER : "") + vals.join(ITEM_SPLITER));
    });
    return lines.join("\n");
  }).join("\n\n" + BLOCK_SPLITER + "\n\n");
}
function getContentFromModel(ecModel) {
  const result = groupSeries(ecModel);
  return {
    value: filter([
      assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis),
      assembleOtherSeries(result.other)
    ], function(str) {
      return !!str.replace(/[\n\t\s]/g, "");
    }).join("\n\n" + BLOCK_SPLITER + "\n\n"),
    meta: result.meta
  };
}
function trim2(str) {
  return str.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function isTSVFormat(block) {
  const firstLine = block.slice(0, block.indexOf("\n"));
  if (firstLine.indexOf(ITEM_SPLITER) >= 0) {
    return true;
  }
}
var itemSplitRegex = new RegExp("[" + ITEM_SPLITER + "]+", "g");
function parseTSVContents(tsv) {
  const tsvLines = tsv.split(/\n+/g);
  const headers = trim2(tsvLines.shift()).split(itemSplitRegex);
  const categories = [];
  const series = map(headers, function(header) {
    return {
      name: header,
      data: []
    };
  });
  for (let i = 0; i < tsvLines.length; i++) {
    const items = trim2(tsvLines[i]).split(itemSplitRegex);
    categories.push(items.shift());
    for (let j = 0; j < items.length; j++) {
      series[j] && (series[j].data[i] = items[j]);
    }
  }
  return {
    series,
    categories
  };
}
function parseListContents(str) {
  const lines = str.split(/\n+/g);
  const seriesName = trim2(lines.shift());
  const data = [];
  for (let i = 0; i < lines.length; i++) {
    const line2 = trim2(lines[i]);
    if (!line2) {
      continue;
    }
    let items = line2.split(itemSplitRegex);
    let name = "";
    let value;
    let hasName = false;
    if (isNaN(items[0])) {
      hasName = true;
      name = items[0];
      items = items.slice(1);
      data[i] = {
        name,
        value: []
      };
      value = data[i].value;
    } else {
      value = data[i] = [];
    }
    for (let j = 0; j < items.length; j++) {
      value.push(+items[j]);
    }
    if (value.length === 1) {
      hasName ? data[i].value = value[0] : data[i] = value[0];
    }
  }
  return {
    name: seriesName,
    data
  };
}
function parseContents(str, blockMetaList) {
  const blocks = str.split(new RegExp("\n*" + BLOCK_SPLITER + "\n*", "g"));
  const newOption = {
    series: []
  };
  each(blocks, function(block, idx) {
    if (isTSVFormat(block)) {
      const result = parseTSVContents(block);
      const blockMeta = blockMetaList[idx];
      const axisKey = blockMeta.axisDim + "Axis";
      if (blockMeta) {
        newOption[axisKey] = newOption[axisKey] || [];
        newOption[axisKey][blockMeta.axisIndex] = {
          data: result.categories
        };
        newOption.series = newOption.series.concat(result.series);
      }
    } else {
      const result = parseListContents(block);
      newOption.series.push(result);
    }
  });
  return newOption;
}
var DataView = class extends ToolboxFeature {
  onclick(ecModel, api2) {
    setTimeout(() => {
      api2.dispatchAction({
        type: "hideTip"
      });
    });
    const container = api2.getDom();
    const model = this.model;
    if (this._dom) {
      container.removeChild(this._dom);
    }
    const root = document.createElement("div");
    root.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px";
    root.style.backgroundColor = model.get("backgroundColor") || tokens_default.color.neutral00;
    const header = document.createElement("h4");
    const lang = model.get("lang") || [];
    header.innerHTML = lang[0] || model.get("title");
    header.style.cssText = "margin:10px 20px";
    header.style.color = model.get("textColor");
    const viewMain = document.createElement("div");
    const textarea = document.createElement("textarea");
    viewMain.style.cssText = "overflow:auto";
    const optionToContent = model.get("optionToContent");
    const contentToOption = model.get("contentToOption");
    const result = getContentFromModel(ecModel);
    if (isFunction(optionToContent)) {
      const htmlOrDom = optionToContent(api2.getOption());
      if (isString(htmlOrDom)) {
        viewMain.innerHTML = htmlOrDom;
      } else if (isDom(htmlOrDom)) {
        viewMain.appendChild(htmlOrDom);
      }
    } else {
      textarea.readOnly = model.get("readOnly");
      const style = textarea.style;
      style.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none";
      style.color = model.get("textColor");
      style.borderColor = model.get("textareaBorderColor");
      style.backgroundColor = model.get("textareaColor");
      textarea.value = result.value;
      viewMain.appendChild(textarea);
    }
    const blockMetaList = result.meta;
    const buttonContainer = document.createElement("div");
    buttonContainer.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
    let buttonStyle = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px";
    const closeButton = document.createElement("div");
    const refreshButton = document.createElement("div");
    buttonStyle += ";background-color:" + model.get("buttonColor");
    buttonStyle += ";color:" + model.get("buttonTextColor");
    const self2 = this;
    function close() {
      container.removeChild(root);
      self2._dom = null;
    }
    addEventListener(closeButton, "click", close);
    addEventListener(refreshButton, "click", function() {
      if (contentToOption == null && optionToContent != null || contentToOption != null && optionToContent == null) {
        if (true) {
          warn("It seems you have just provided one of `contentToOption` and `optionToContent` functions but missed the other one. Data change is ignored.");
        }
        close();
        return;
      }
      let newOption;
      try {
        if (isFunction(contentToOption)) {
          newOption = contentToOption(viewMain, api2.getOption());
        } else {
          newOption = parseContents(textarea.value, blockMetaList);
        }
      } catch (e2) {
        close();
        throw new Error("Data view format error " + e2);
      }
      if (newOption) {
        api2.dispatchAction({
          type: "changeDataView",
          newOption
        });
      }
      close();
    });
    closeButton.innerHTML = lang[1];
    refreshButton.innerHTML = lang[2];
    refreshButton.style.cssText = closeButton.style.cssText = buttonStyle;
    !model.get("readOnly") && buttonContainer.appendChild(refreshButton);
    buttonContainer.appendChild(closeButton);
    root.appendChild(header);
    root.appendChild(viewMain);
    root.appendChild(buttonContainer);
    viewMain.style.height = container.clientHeight - 80 + "px";
    container.appendChild(root);
    this._dom = root;
  }
  remove(ecModel, api2) {
    this._dom && api2.getDom().removeChild(this._dom);
  }
  dispose(ecModel, api2) {
    this.remove(ecModel, api2);
  }
  static getDefaultOption(ecModel) {
    const defaultOption3 = {
      show: true,
      readOnly: false,
      optionToContent: null,
      contentToOption: null,
      icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
      title: ecModel.getLocaleModel().get(["toolbox", "dataView", "title"]),
      lang: ecModel.getLocaleModel().get(["toolbox", "dataView", "lang"]),
      backgroundColor: tokens_default.color.background,
      textColor: tokens_default.color.primary,
      textareaColor: tokens_default.color.background,
      textareaBorderColor: tokens_default.color.border,
      buttonColor: tokens_default.color.accent50,
      buttonTextColor: tokens_default.color.neutral00
    };
    return defaultOption3;
  }
};
function tryMergeDataOption(newData, originalData) {
  return map(newData, function(newVal, idx) {
    const original = originalData && originalData[idx];
    if (isObject(original) && !isArray(original)) {
      const newValIsObject = isObject(newVal) && !isArray(newVal);
      if (!newValIsObject) {
        newVal = {
          value: newVal
        };
      }
      const shouldDeleteName = original.name != null && newVal.name == null;
      newVal = defaults(newVal, original);
      shouldDeleteName && delete newVal.name;
      return newVal;
    } else {
      return newVal;
    }
  });
}
registerAction({
  type: "changeDataView",
  event: "dataViewChanged",
  update: "prepareAndUpdate"
}, function(payload, ecModel) {
  const newSeriesOptList = [];
  each(payload.newOption.series, function(seriesOpt) {
    const seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];
    if (!seriesModel) {
      newSeriesOptList.push(extend({
        type: "scatter"
      }, seriesOpt));
    } else {
      const originalData = seriesModel.get("data");
      newSeriesOptList.push({
        name: seriesOpt.name,
        data: tryMergeDataOption(seriesOpt.data, originalData)
      });
    }
  });
  ecModel.mergeOption(defaults({
    series: newSeriesOptList
  }, payload.newOption));
});
var DataView_default = DataView;

// src/component/dataZoom/history.ts
var each10 = each;
var inner18 = makeInner();
function push(ecModel, newSnapshot) {
  const storedSnapshots = getStoreSnapshots(ecModel);
  each10(newSnapshot, function(batchItem, dataZoomId) {
    let i = storedSnapshots.length - 1;
    for (; i >= 0; i--) {
      const snapshot = storedSnapshots[i];
      if (snapshot[dataZoomId]) {
        break;
      }
    }
    if (i < 0) {
      const dataZoomModel = ecModel.queryComponents({mainType: "dataZoom", subType: "select", id: dataZoomId})[0];
      if (dataZoomModel) {
        const percentRange = dataZoomModel.getPercentRange();
        storedSnapshots[0][dataZoomId] = {
          dataZoomId,
          start: percentRange[0],
          end: percentRange[1]
        };
      }
    }
  });
  storedSnapshots.push(newSnapshot);
}
function pop(ecModel) {
  const storedSnapshots = getStoreSnapshots(ecModel);
  const head = storedSnapshots[storedSnapshots.length - 1];
  storedSnapshots.length > 1 && storedSnapshots.pop();
  const snapshot = {};
  each10(head, function(batchItem, dataZoomId) {
    for (let i = storedSnapshots.length - 1; i >= 0; i--) {
      batchItem = storedSnapshots[i][dataZoomId];
      if (batchItem) {
        snapshot[dataZoomId] = batchItem;
        break;
      }
    }
  });
  return snapshot;
}
function clear2(ecModel) {
  inner18(ecModel).snapshots = null;
}
function count(ecModel) {
  return getStoreSnapshots(ecModel).length;
}
function getStoreSnapshots(ecModel) {
  const store = inner18(ecModel);
  if (!store.snapshots) {
    store.snapshots = [{}];
  }
  return store.snapshots;
}

// src/component/toolbox/feature/Restore.ts
var RestoreOption = class extends ToolboxFeature {
  onclick(ecModel, api2) {
    clear2(ecModel);
    api2.dispatchAction({
      type: "restore",
      from: this.uid
    });
  }
  static getDefaultOption(ecModel) {
    const defaultOption3 = {
      show: true,
      icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
      title: ecModel.getLocaleModel().get(["toolbox", "restore", "title"])
    };
    return defaultOption3;
  }
};
registerAction({type: "restore", event: "restore", update: "prepareAndUpdate"}, function(payload, ecModel) {
  ecModel.resetOption("recreate");
});
var Restore_default = RestoreOption;

// src/component/helper/BrushTargetManager.ts
var INCLUDE_FINDER_MAIN_TYPES = [
  "grid",
  "xAxis",
  "yAxis",
  "geo",
  "graph",
  "polar",
  "radiusAxis",
  "angleAxis",
  "bmap"
];
var BrushTargetManager = class {
  constructor(finder, ecModel, opt) {
    this._targetInfoList = [];
    const foundCpts = parseFinder2(ecModel, finder);
    each(targetInfoBuilders, (builder, type) => {
      if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {
        builder(foundCpts, this._targetInfoList);
      }
    });
  }
  setOutputRanges(areas, ecModel) {
    this.matchOutputRanges(areas, ecModel, function(area, coordRange, coordSys) {
      (area.coordRanges || (area.coordRanges = [])).push(coordRange);
      if (!area.coordRange) {
        area.coordRange = coordRange;
        const result = coordConvert[area.brushType](0, coordSys, coordRange);
        area.__rangeOffset = {
          offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),
          xyMinMax: result.xyMinMax
        };
      }
    });
    return areas;
  }
  matchOutputRanges(areas, ecModel, cb) {
    each(areas, function(area) {
      const targetInfo = this.findTargetInfo(area, ecModel);
      if (targetInfo && targetInfo !== true) {
        each(targetInfo.coordSyses, function(coordSys) {
          const result = coordConvert[area.brushType](1, coordSys, area.range, true);
          cb(area, result.values, coordSys, ecModel);
        });
      }
    }, this);
  }
  setInputRanges(areas, ecModel) {
    each(areas, function(area) {
      const targetInfo = this.findTargetInfo(area, ecModel);
      if (true) {
        assert(!targetInfo || targetInfo === true || area.coordRange, "coordRange must be specified when coord index specified.");
        assert(!targetInfo || targetInfo !== true || area.range, "range must be specified in global brush.");
      }
      area.range = area.range || [];
      if (targetInfo && targetInfo !== true) {
        area.panelId = targetInfo.panelId;
        const result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);
        const rangeOffset = area.__rangeOffset;
        area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;
      }
    }, this);
  }
  makePanelOpts(api2, getDefaultBrushType) {
    return map(this._targetInfoList, function(targetInfo) {
      const rect = targetInfo.getPanelRect();
      return {
        panelId: targetInfo.panelId,
        defaultBrushType: getDefaultBrushType ? getDefaultBrushType(targetInfo) : null,
        clipPath: makeRectPanelClipPath(rect),
        isTargetByCursor: makeRectIsTargetByCursor(rect, api2, targetInfo.coordSysModel),
        getLinearBrushOtherExtent: makeLinearBrushOtherExtent(rect)
      };
    });
  }
  controlSeries(area, seriesModel, ecModel) {
    const targetInfo = this.findTargetInfo(area, ecModel);
    return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;
  }
  findTargetInfo(area, ecModel) {
    const targetInfoList = this._targetInfoList;
    const foundCpts = parseFinder2(ecModel, area);
    for (let i = 0; i < targetInfoList.length; i++) {
      const targetInfo = targetInfoList[i];
      const areaPanelId = area.panelId;
      if (areaPanelId) {
        if (targetInfo.panelId === areaPanelId) {
          return targetInfo;
        }
      } else {
        for (let j = 0; j < targetInfoMatchers.length; j++) {
          if (targetInfoMatchers[j](foundCpts, targetInfo)) {
            return targetInfo;
          }
        }
      }
    }
    return true;
  }
};
function formatMinMax(minMax) {
  minMax[0] > minMax[1] && minMax.reverse();
  return minMax;
}
function parseFinder2(ecModel, finder) {
  return parseFinder(ecModel, finder, {includeMainTypes: INCLUDE_FINDER_MAIN_TYPES});
}
var targetInfoBuilders = {
  grid: function(foundCpts, targetInfoList) {
    const xAxisModels = foundCpts.xAxisModels;
    const yAxisModels = foundCpts.yAxisModels;
    const gridModels = foundCpts.gridModels;
    const gridModelMap = createHashMap();
    const xAxesHas = {};
    const yAxesHas = {};
    if (!xAxisModels && !yAxisModels && !gridModels) {
      return;
    }
    each(xAxisModels, function(axisModel) {
      const gridModel = axisModel.axis.grid.model;
      gridModelMap.set(gridModel.id, gridModel);
      xAxesHas[gridModel.id] = true;
    });
    each(yAxisModels, function(axisModel) {
      const gridModel = axisModel.axis.grid.model;
      gridModelMap.set(gridModel.id, gridModel);
      yAxesHas[gridModel.id] = true;
    });
    each(gridModels, function(gridModel) {
      gridModelMap.set(gridModel.id, gridModel);
      xAxesHas[gridModel.id] = true;
      yAxesHas[gridModel.id] = true;
    });
    gridModelMap.each(function(gridModel) {
      const grid = gridModel.coordinateSystem;
      const cartesians = [];
      each(grid.getCartesians(), function(cartesian, index) {
        if (indexOf(xAxisModels, cartesian.getAxis("x").model) >= 0 || indexOf(yAxisModels, cartesian.getAxis("y").model) >= 0) {
          cartesians.push(cartesian);
        }
      });
      targetInfoList.push({
        panelId: "grid--" + gridModel.id,
        gridModel,
        coordSysModel: gridModel,
        coordSys: cartesians[0],
        coordSyses: cartesians,
        getPanelRect: panelRectBuilders.grid,
        xAxisDeclared: xAxesHas[gridModel.id],
        yAxisDeclared: yAxesHas[gridModel.id]
      });
    });
  },
  geo: function(foundCpts, targetInfoList) {
    each(foundCpts.geoModels, function(geoModel) {
      const coordSys = geoModel.coordinateSystem;
      targetInfoList.push({
        panelId: "geo--" + geoModel.id,
        geoModel,
        coordSysModel: geoModel,
        coordSys,
        coordSyses: [coordSys],
        getPanelRect: panelRectBuilders.geo
      });
    });
  }
};
var targetInfoMatchers = [
  function(foundCpts, targetInfo) {
    const xAxisModel = foundCpts.xAxisModel;
    const yAxisModel = foundCpts.yAxisModel;
    let gridModel = foundCpts.gridModel;
    !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);
    !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);
    return gridModel && gridModel === targetInfo.gridModel;
  },
  function(foundCpts, targetInfo) {
    const geoModel = foundCpts.geoModel;
    return geoModel && geoModel === targetInfo.geoModel;
  }
];
var panelRectBuilders = {
  grid: function() {
    return this.coordSys.master.getRect().clone();
  },
  geo: function() {
    const coordSys = this.coordSys;
    const rect = coordSys.getBoundingRect().clone();
    rect.applyTransform(getTransform(coordSys));
    return rect;
  }
};
var coordConvert = {
  lineX: curry(axisConvert, 0),
  lineY: curry(axisConvert, 1),
  rect: function(to, coordSys, rangeOrCoordRange, clamp2) {
    const xminymin = to ? coordSys.pointToData([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp2) : coordSys.dataToPoint([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp2);
    const xmaxymax = to ? coordSys.pointToData([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp2) : coordSys.dataToPoint([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp2);
    const values = [
      formatMinMax([xminymin[0], xmaxymax[0]]),
      formatMinMax([xminymin[1], xmaxymax[1]])
    ];
    return {values, xyMinMax: values};
  },
  polygon: function(to, coordSys, rangeOrCoordRange, clamp2) {
    const xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];
    const values = map(rangeOrCoordRange, function(item) {
      const p = to ? coordSys.pointToData(item, clamp2) : coordSys.dataToPoint(item, clamp2);
      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);
      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);
      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);
      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);
      return p;
    });
    return {values, xyMinMax};
  }
};
function axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {
  if (true) {
    assert(coordSys.type === "cartesian2d", "lineX/lineY brush is available only in cartesian2d.");
  }
  const axis = coordSys.getAxis(["x", "y"][axisNameIndex]);
  const values = formatMinMax(map([0, 1], function(i) {
    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i]), true) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));
  }));
  const xyMinMax = [];
  xyMinMax[axisNameIndex] = values;
  xyMinMax[1 - axisNameIndex] = [NaN, NaN];
  return {values, xyMinMax};
}
var diffProcessor = {
  lineX: curry(axisDiffProcessor, 0),
  lineY: curry(axisDiffProcessor, 1),
  rect: function(values, refer, scales) {
    return [
      [values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]],
      [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]
    ];
  },
  polygon: function(values, refer, scales) {
    return map(values, function(item, idx) {
      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];
    });
  }
};
function axisDiffProcessor(axisNameIndex, values, refer, scales) {
  return [
    values[0] - scales[axisNameIndex] * refer[0],
    values[1] - scales[axisNameIndex] * refer[1]
  ];
}
function getScales(xyMinMaxCurr, xyMinMaxOrigin) {
  const sizeCurr = getSize2(xyMinMaxCurr);
  const sizeOrigin = getSize2(xyMinMaxOrigin);
  const scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];
  isNaN(scales[0]) && (scales[0] = 1);
  isNaN(scales[1]) && (scales[1] = 1);
  return scales;
}
function getSize2(xyMinMax) {
  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];
}
var BrushTargetManager_default = BrushTargetManager;

// src/component/toolbox/feature/DataZoom.ts
var each11 = each;
var DATA_ZOOM_ID_BASE = makeInternalComponentId("toolbox-dataZoom_");
var DataZoomFeature = class extends ToolboxFeature {
  render(featureModel, ecModel, api2, payload) {
    if (!this._brushController) {
      this._brushController = new BrushController_default(api2.getZr());
      this._brushController.on("brush", bind(this._onBrush, this)).mount();
    }
    updateZoomBtnStatus(featureModel, ecModel, this, payload, api2);
    updateBackBtnStatus(featureModel, ecModel);
  }
  onclick(ecModel, api2, type) {
    handlers2[type].call(this);
  }
  remove(ecModel, api2) {
    this._brushController && this._brushController.unmount();
  }
  dispose(ecModel, api2) {
    this._brushController && this._brushController.dispose();
  }
  _onBrush(eventParam) {
    const areas = eventParam.areas;
    if (!eventParam.isEnd || !areas.length) {
      return;
    }
    const snapshot = {};
    const ecModel = this.ecModel;
    this._brushController.updateCovers([]);
    const brushTargetManager = new BrushTargetManager_default(makeAxisFinder(this.model), ecModel, {include: ["grid"]});
    brushTargetManager.matchOutputRanges(areas, ecModel, function(area, coordRange, coordSys) {
      if (coordSys.type !== "cartesian2d") {
        return;
      }
      const brushType = area.brushType;
      if (brushType === "rect") {
        setBatch("x", coordSys, coordRange[0]);
        setBatch("y", coordSys, coordRange[1]);
      } else {
        setBatch({lineX: "x", lineY: "y"}[brushType], coordSys, coordRange);
      }
    });
    push(ecModel, snapshot);
    this._dispatchZoomAction(snapshot);
    function setBatch(dimName, coordSys, minMax) {
      const axis = coordSys.getAxis(dimName);
      const axisModel = axis.model;
      const dataZoomModel = findDataZoom(dimName, axisModel, ecModel);
      const minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();
      if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {
        minMax = sliderMove(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);
      }
      dataZoomModel && (snapshot[dataZoomModel.id] = {
        dataZoomId: dataZoomModel.id,
        startValue: minMax[0],
        endValue: minMax[1]
      });
    }
    function findDataZoom(dimName, axisModel, ecModel2) {
      let found;
      ecModel2.eachComponent({mainType: "dataZoom", subType: "select"}, function(dzModel) {
        const has3 = dzModel.getAxisModel(dimName, axisModel.componentIndex);
        has3 && (found = dzModel);
      });
      return found;
    }
  }
  _dispatchZoomAction(snapshot) {
    const batch = [];
    each11(snapshot, function(batchItem, dataZoomId) {
      batch.push(clone(batchItem));
    });
    batch.length && this.api.dispatchAction({
      type: "dataZoom",
      from: this.uid,
      batch
    });
  }
  static getDefaultOption(ecModel) {
    const defaultOption3 = {
      show: true,
      filterMode: "filter",
      icon: {
        zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
        back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
      },
      title: ecModel.getLocaleModel().get(["toolbox", "dataZoom", "title"]),
      brushStyle: {
        borderWidth: 0,
        color: tokens_default.color.backgroundTint
      }
    };
    return defaultOption3;
  }
};
var handlers2 = {
  zoom: function() {
    const nextActive = !this._isZoomActive;
    this.api.dispatchAction({
      type: "takeGlobalCursor",
      key: "dataZoomSelect",
      dataZoomSelectActive: nextActive
    });
  },
  back: function() {
    this._dispatchZoomAction(pop(this.ecModel));
  }
};
function makeAxisFinder(dzFeatureModel) {
  const setting = {
    xAxisIndex: dzFeatureModel.get("xAxisIndex", true),
    yAxisIndex: dzFeatureModel.get("yAxisIndex", true),
    xAxisId: dzFeatureModel.get("xAxisId", true),
    yAxisId: dzFeatureModel.get("yAxisId", true)
  };
  if (setting.xAxisIndex == null && setting.xAxisId == null) {
    setting.xAxisIndex = "all";
  }
  if (setting.yAxisIndex == null && setting.yAxisId == null) {
    setting.yAxisIndex = "all";
  }
  return setting;
}
function updateBackBtnStatus(featureModel, ecModel) {
  featureModel.setIconStatus("back", count(ecModel) > 1 ? "emphasis" : "normal");
}
function updateZoomBtnStatus(featureModel, ecModel, view, payload, api2) {
  let zoomActive = view._isZoomActive;
  if (payload && payload.type === "takeGlobalCursor") {
    zoomActive = payload.key === "dataZoomSelect" ? payload.dataZoomSelectActive : false;
  }
  view._isZoomActive = zoomActive;
  featureModel.setIconStatus("zoom", zoomActive ? "emphasis" : "normal");
  const brushTargetManager = new BrushTargetManager_default(makeAxisFinder(featureModel), ecModel, {include: ["grid"]});
  const panels = brushTargetManager.makePanelOpts(api2, function(targetInfo) {
    return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? "lineX" : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? "lineY" : "rect";
  });
  view._brushController.setPanels(panels).enableBrush(zoomActive && panels.length ? {
    brushType: "auto",
    brushStyle: featureModel.getModel("brushStyle").getItemStyle()
  } : false);
}
registerInternalOptionCreator("dataZoom", function(ecModel) {
  const toolboxModel = ecModel.getComponent("toolbox", 0);
  const featureDataZoomPath = ["feature", "dataZoom"];
  if (!toolboxModel || toolboxModel.get(featureDataZoomPath) == null) {
    return;
  }
  const dzFeatureModel = toolboxModel.getModel(featureDataZoomPath);
  const dzOptions = [];
  const finder = makeAxisFinder(dzFeatureModel);
  const finderResult = parseFinder(ecModel, finder);
  each11(finderResult.xAxisModels, (axisModel) => buildInternalOptions(axisModel, "xAxis", "xAxisIndex"));
  each11(finderResult.yAxisModels, (axisModel) => buildInternalOptions(axisModel, "yAxis", "yAxisIndex"));
  function buildInternalOptions(axisModel, axisMainType, axisIndexPropName) {
    const axisIndex = axisModel.componentIndex;
    const newOpt = {
      type: "select",
      $fromToolbox: true,
      filterMode: dzFeatureModel.get("filterMode", true) || "filter",
      id: DATA_ZOOM_ID_BASE + axisMainType + axisIndex
    };
    newOpt[axisIndexPropName] = axisIndex;
    dzOptions.push(newOpt);
  }
  return dzOptions;
});
var DataZoom_default = DataZoomFeature;

// src/component/toolbox/install.ts
function install38(registers) {
  registers.registerComponentModel(ToolboxModel_default);
  registers.registerComponentView(ToolboxView_default);
  registerFeature("saveAsImage", SaveAsImage_default);
  registerFeature("magicType", MagicType_default);
  registerFeature("dataView", DataView_default);
  registerFeature("dataZoom", DataZoom_default);
  registerFeature("restore", Restore_default);
  use(install37);
}

// src/component/tooltip/TooltipModel.ts
var TooltipModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = TooltipModel2.type;
  }
};
var TooltipModel = TooltipModel2;
TooltipModel.type = "tooltip";
TooltipModel.dependencies = ["axisPointer"];
TooltipModel.defaultOption = {
  z: 60,
  show: true,
  showContent: true,
  trigger: "item",
  triggerOn: "mousemove|click",
  alwaysShowContent: false,
  renderMode: "auto",
  confine: null,
  showDelay: 0,
  hideDelay: 100,
  transitionDuration: 0.4,
  displayTransition: true,
  enterable: false,
  backgroundColor: tokens_default.color.neutral00,
  shadowBlur: 10,
  shadowColor: "rgba(0, 0, 0, .2)",
  shadowOffsetX: 1,
  shadowOffsetY: 2,
  borderRadius: 4,
  borderWidth: 1,
  defaultBorderColor: tokens_default.color.border,
  padding: null,
  extraCssText: "",
  axisPointer: {
    type: "line",
    axis: "auto",
    animation: "auto",
    animationDurationUpdate: 200,
    animationEasingUpdate: "exponentialOut",
    crossStyle: {
      color: tokens_default.color.borderShade,
      width: 1,
      type: "dashed",
      textStyle: {}
    }
  },
  textStyle: {
    color: tokens_default.color.tertiary,
    fontSize: 14
  }
};
var TooltipModel_default = TooltipModel;

// src/component/tooltip/helper.ts
function shouldTooltipConfine(tooltipModel) {
  const confineOption = tooltipModel.get("confine");
  return confineOption != null ? !!confineOption : tooltipModel.get("renderMode") === "richText";
}
function testStyle(styleProps) {
  if (!env_default.domSupported) {
    return;
  }
  const style = document.documentElement.style;
  for (let i = 0, len2 = styleProps.length; i < len2; i++) {
    if (styleProps[i] in style) {
      return styleProps[i];
    }
  }
}
var TRANSFORM_VENDOR = testStyle(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]);
var TRANSITION_VENDOR = testStyle(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function toCSSVendorPrefix(styleVendor, styleProp) {
  if (!styleVendor) {
    return styleProp;
  }
  styleProp = toCamelCase(styleProp, true);
  const idx = styleVendor.indexOf(styleProp);
  styleVendor = idx === -1 ? styleProp : `-${styleVendor.slice(0, idx)}-${styleProp}`;
  return styleVendor.toLowerCase();
}
function getComputedStyle(el, style) {
  const stl = el.currentStyle || document.defaultView && document.defaultView.getComputedStyle(el);
  return stl ? style ? stl[style] : stl : null;
}

// src/component/tooltip/TooltipHTMLContent.ts
var CSS_TRANSITION_VENDOR = toCSSVendorPrefix(TRANSITION_VENDOR, "transition");
var CSS_TRANSFORM_VENDOR = toCSSVendorPrefix(TRANSFORM_VENDOR, "transform");
var gCssText = `position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;${env_default.transform3dSupported ? "will-change:transform;" : ""}`;
function mirrorPos(pos) {
  pos = pos === "left" ? "right" : pos === "right" ? "left" : pos === "top" ? "bottom" : "top";
  return pos;
}
function assembleArrow(tooltipModel, borderColor, arrowPosition) {
  if (!isString(arrowPosition) || arrowPosition === "inside") {
    return "";
  }
  const backgroundColor2 = tooltipModel.get("backgroundColor");
  const borderWidth = tooltipModel.get("borderWidth");
  borderColor = convertToColorString(borderColor);
  const arrowPos = mirrorPos(arrowPosition);
  const arrowSize = Math.max(Math.round(borderWidth) * 1.5, 6);
  let positionStyle = "";
  let transformStyle = CSS_TRANSFORM_VENDOR + ":";
  let rotateDeg;
  if (indexOf(["left", "right"], arrowPos) > -1) {
    positionStyle += "top:50%";
    transformStyle += `translateY(-50%) rotate(${rotateDeg = arrowPos === "left" ? -225 : -45}deg)`;
  } else {
    positionStyle += "left:50%";
    transformStyle += `translateX(-50%) rotate(${rotateDeg = arrowPos === "top" ? 225 : 45}deg)`;
  }
  const rotateRadian = rotateDeg * Math.PI / 180;
  const arrowWH = arrowSize + borderWidth;
  const rotatedWH = arrowWH * Math.abs(Math.cos(rotateRadian)) + arrowWH * Math.abs(Math.sin(rotateRadian));
  const arrowOffset = Math.round(((rotatedWH - Math.SQRT2 * borderWidth) / 2 + Math.SQRT2 * borderWidth - (rotatedWH - arrowWH) / 2) * 100) / 100;
  positionStyle += `;${arrowPos}:-${arrowOffset}px`;
  const borderStyle = `${borderColor} solid ${borderWidth}px;`;
  const styleCss = [
    `position:absolute;width:${arrowSize}px;height:${arrowSize}px;z-index:-1;`,
    `${positionStyle};${transformStyle};`,
    `border-bottom:${borderStyle}`,
    `border-right:${borderStyle}`,
    `background-color:${backgroundColor2};`
  ];
  return `<div style="${styleCss.join("")}"></div>`;
}
function assembleTransition(duration, onlyFadeTransition, enableDisplayTransition) {
  const transitionCurve = "cubic-bezier(0.23,1,0.32,1)";
  let transitionOption = "";
  let transitionText = "";
  if (enableDisplayTransition) {
    transitionOption = ` ${duration / 2}s ${transitionCurve}`;
    transitionText = `opacity${transitionOption},visibility${transitionOption}`;
  }
  if (!onlyFadeTransition) {
    transitionOption = ` ${duration}s ${transitionCurve}`;
    transitionText += (transitionText.length ? "," : "") + (env_default.transformSupported ? `${CSS_TRANSFORM_VENDOR}${transitionOption}` : `,left${transitionOption},top${transitionOption}`);
  }
  return CSS_TRANSITION_VENDOR + ":" + transitionText;
}
function assembleTransform(x, y, toString) {
  const x0 = x.toFixed(0) + "px";
  const y0 = y.toFixed(0) + "px";
  if (!env_default.transformSupported) {
    return toString ? `top:${y0};left:${x0};` : [["top", y0], ["left", x0]];
  }
  const is3d = env_default.transform3dSupported;
  const translate2 = `translate${is3d ? "3d" : ""}(${x0},${y0}${is3d ? ",0" : ""})`;
  return toString ? "top:0;left:0;" + CSS_TRANSFORM_VENDOR + ":" + translate2 + ";" : [["top", 0], ["left", 0], [TRANSFORM_VENDOR, translate2]];
}
function assembleFont(textStyleModel) {
  const cssText = [];
  const fontSize = textStyleModel.get("fontSize");
  const color4 = textStyleModel.getTextColor();
  color4 && cssText.push("color:" + color4);
  cssText.push("font:" + textStyleModel.getFont());
  const lineHeight = retrieve2(textStyleModel.get("lineHeight"), Math.round(fontSize * 3 / 2));
  fontSize && cssText.push("line-height:" + lineHeight + "px");
  const shadowColor = textStyleModel.get("textShadowColor");
  const shadowBlur = textStyleModel.get("textShadowBlur") || 0;
  const shadowOffsetX = textStyleModel.get("textShadowOffsetX") || 0;
  const shadowOffsetY = textStyleModel.get("textShadowOffsetY") || 0;
  shadowColor && shadowBlur && cssText.push("text-shadow:" + shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor);
  each(["decoration", "align"], function(name) {
    const val = textStyleModel.get(name);
    val && cssText.push("text-" + name + ":" + val);
  });
  return cssText.join(";");
}
function assembleCssText(tooltipModel, enableTransition, onlyFadeTransition, enableDisplayTransition) {
  const cssText = [];
  const transitionDuration = tooltipModel.get("transitionDuration");
  const backgroundColor2 = tooltipModel.get("backgroundColor");
  const shadowBlur = tooltipModel.get("shadowBlur");
  const shadowColor = tooltipModel.get("shadowColor");
  const shadowOffsetX = tooltipModel.get("shadowOffsetX");
  const shadowOffsetY = tooltipModel.get("shadowOffsetY");
  const textStyleModel = tooltipModel.getModel("textStyle");
  const padding = getPaddingFromTooltipModel(tooltipModel, "html");
  const boxShadow = `${shadowOffsetX}px ${shadowOffsetY}px ${shadowBlur}px ${shadowColor}`;
  cssText.push("box-shadow:" + boxShadow);
  enableTransition && transitionDuration > 0 && cssText.push(assembleTransition(transitionDuration, onlyFadeTransition, enableDisplayTransition));
  if (backgroundColor2) {
    cssText.push("background-color:" + backgroundColor2);
  }
  each(["width", "color", "radius"], function(name) {
    const borderName = "border-" + name;
    const camelCase = toCamelCase(borderName);
    const val = tooltipModel.get(camelCase);
    val != null && cssText.push(borderName + ":" + val + (name === "color" ? "" : "px"));
  });
  cssText.push(assembleFont(textStyleModel));
  if (padding != null) {
    cssText.push("padding:" + normalizeCssArray2(padding).join("px ") + "px");
  }
  return cssText.join(";") + ";";
}
function makeStyleCoord(out2, zr, container, zrX, zrY) {
  const zrPainter = zr && zr.painter;
  if (container) {
    const zrViewportRoot = zrPainter && zrPainter.getViewportRoot();
    if (zrViewportRoot) {
      transformLocalCoord(out2, zrViewportRoot, container, zrX, zrY);
    }
  } else {
    out2[0] = zrX;
    out2[1] = zrY;
    const viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset();
    if (viewportRootOffset) {
      out2[0] += viewportRootOffset.offsetLeft;
      out2[1] += viewportRootOffset.offsetTop;
    }
  }
  out2[2] = out2[0] / zr.getWidth();
  out2[3] = out2[1] / zr.getHeight();
}
var TooltipHTMLContent = class {
  constructor(api2, opt) {
    this._show = false;
    this._styleCoord = [0, 0, 0, 0];
    this._enterable = true;
    this._alwaysShowContent = false;
    this._firstShow = true;
    this._longHide = true;
    if (env_default.wxa) {
      return null;
    }
    const el = document.createElement("div");
    el.domBelongToZr = true;
    this.el = el;
    const zr = this._zr = api2.getZr();
    const appendTo = opt.appendTo;
    const container = appendTo && (isString(appendTo) ? document.querySelector(appendTo) : isDom(appendTo) ? appendTo : isFunction(appendTo) && appendTo(api2.getDom()));
    makeStyleCoord(this._styleCoord, zr, container, api2.getWidth() / 2, api2.getHeight() / 2);
    (container || api2.getDom()).appendChild(el);
    this._api = api2;
    this._container = container;
    const self2 = this;
    el.onmouseenter = function() {
      if (self2._enterable) {
        clearTimeout(self2._hideTimeout);
        self2._show = true;
      }
      self2._inContent = true;
    };
    el.onmousemove = function(e2) {
      e2 = e2 || window.event;
      if (!self2._enterable) {
        const handler = zr.handler;
        const zrViewportRoot = zr.painter.getViewportRoot();
        normalizeEvent(zrViewportRoot, e2, true);
        handler.dispatch("mousemove", e2);
      }
    };
    el.onmouseleave = function() {
      self2._inContent = false;
      if (self2._enterable) {
        if (self2._show) {
          self2.hideLater(self2._hideDelay);
        }
      }
    };
  }
  update(tooltipModel) {
    if (!this._container) {
      const container = this._api.getDom();
      const position2 = getComputedStyle(container, "position");
      const domStyle = container.style;
      if (domStyle.position !== "absolute" && position2 !== "absolute") {
        domStyle.position = "relative";
      }
    }
    const alwaysShowContent = tooltipModel.get("alwaysShowContent");
    alwaysShowContent && this._moveIfResized();
    this._alwaysShowContent = alwaysShowContent;
    this._enableDisplayTransition = tooltipModel.get("displayTransition") && tooltipModel.get("transitionDuration") > 0;
    this.el.className = tooltipModel.get("className") || "";
  }
  show(tooltipModel, nearPointColor) {
    clearTimeout(this._hideTimeout);
    clearTimeout(this._longHideTimeout);
    const el = this.el;
    const style = el.style;
    const styleCoord = this._styleCoord;
    if (!el.innerHTML) {
      style.display = "none";
    } else {
      style.cssText = gCssText + assembleCssText(tooltipModel, !this._firstShow, this._longHide, this._enableDisplayTransition) + assembleTransform(styleCoord[0], styleCoord[1], true) + `border-color:${convertToColorString(nearPointColor)};` + (tooltipModel.get("extraCssText") || "") + `;pointer-events:${this._enterable ? "auto" : "none"}`;
    }
    this._show = true;
    this._firstShow = false;
    this._longHide = false;
  }
  setContent(content, markers, tooltipModel, borderColor, arrowPosition) {
    const el = this.el;
    if (content == null) {
      el.innerHTML = "";
      return;
    }
    let arrow = "";
    if (isString(arrowPosition) && tooltipModel.get("trigger") === "item" && !shouldTooltipConfine(tooltipModel)) {
      arrow = assembleArrow(tooltipModel, borderColor, arrowPosition);
    }
    if (isString(content)) {
      el.innerHTML = content + arrow;
    } else if (content) {
      el.innerHTML = "";
      if (!isArray(content)) {
        content = [content];
      }
      for (let i = 0; i < content.length; i++) {
        if (isDom(content[i]) && content[i].parentNode !== el) {
          el.appendChild(content[i]);
        }
      }
      if (arrow && el.childNodes.length) {
        const arrowEl = document.createElement("div");
        arrowEl.innerHTML = arrow;
        el.appendChild(arrowEl);
      }
    }
  }
  setEnterable(enterable) {
    this._enterable = enterable;
  }
  getSize() {
    const el = this.el;
    return el ? [el.offsetWidth, el.offsetHeight] : [0, 0];
  }
  moveTo(zrX, zrY) {
    if (!this.el) {
      return;
    }
    const styleCoord = this._styleCoord;
    makeStyleCoord(styleCoord, this._zr, this._container, zrX, zrY);
    if (styleCoord[0] != null && styleCoord[1] != null) {
      const style = this.el.style;
      const transforms = assembleTransform(styleCoord[0], styleCoord[1]);
      each(transforms, (transform2) => {
        style[transform2[0]] = transform2[1];
      });
    }
  }
  _moveIfResized() {
    const ratioX = this._styleCoord[2];
    const ratioY = this._styleCoord[3];
    this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
  }
  hide() {
    const style = this.el.style;
    if (this._enableDisplayTransition) {
      style.visibility = "hidden";
      style.opacity = "0";
    } else {
      style.display = "none";
    }
    env_default.transform3dSupported && (style.willChange = "");
    this._show = false;
    this._longHideTimeout = setTimeout(() => this._longHide = true, 500);
  }
  hideLater(time) {
    if (this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent) {
      if (time) {
        this._hideDelay = time;
        this._show = false;
        this._hideTimeout = setTimeout(bind(this.hide, this), time);
      } else {
        this.hide();
      }
    }
  }
  isShow() {
    return this._show;
  }
  dispose() {
    clearTimeout(this._hideTimeout);
    clearTimeout(this._longHideTimeout);
    const zr = this._zr;
    transformLocalCoordClear(zr && zr.painter && zr.painter.getViewportRoot(), this._container);
    if (this.el) {
      const parentNode2 = this.el.parentNode;
      parentNode2 && parentNode2.removeChild(this.el);
    }
    this.el = this._container = null;
  }
};
var TooltipHTMLContent_default = TooltipHTMLContent;

// src/component/tooltip/TooltipRichContent.ts
var TooltipRichContent = class {
  constructor(api2) {
    this._show = false;
    this._styleCoord = [0, 0, 0, 0];
    this._alwaysShowContent = false;
    this._enterable = true;
    this._zr = api2.getZr();
    makeStyleCoord2(this._styleCoord, this._zr, api2.getWidth() / 2, api2.getHeight() / 2);
  }
  update(tooltipModel) {
    const alwaysShowContent = tooltipModel.get("alwaysShowContent");
    alwaysShowContent && this._moveIfResized();
    this._alwaysShowContent = alwaysShowContent;
  }
  show() {
    if (this._hideTimeout) {
      clearTimeout(this._hideTimeout);
    }
    this.el.show();
    this._show = true;
  }
  setContent(content, markupStyleCreator, tooltipModel, borderColor, arrowPosition) {
    if (isObject(content)) {
      throwError(true ? "Passing DOM nodes as content is not supported in richText tooltip!" : "");
    }
    if (this.el) {
      this._zr.remove(this.el);
    }
    const textStyleModel = tooltipModel.getModel("textStyle");
    this.el = new Text_default({
      style: {
        rich: markupStyleCreator.richTextStyles,
        text: content,
        lineHeight: 22,
        borderWidth: 1,
        borderColor,
        textShadowColor: textStyleModel.get("textShadowColor"),
        fill: tooltipModel.get(["textStyle", "color"]),
        padding: getPaddingFromTooltipModel(tooltipModel, "richText"),
        verticalAlign: "top",
        align: "left"
      },
      z: tooltipModel.get("z")
    });
    each([
      "backgroundColor",
      "borderRadius",
      "shadowColor",
      "shadowBlur",
      "shadowOffsetX",
      "shadowOffsetY"
    ], (propName) => {
      this.el.style[propName] = tooltipModel.get(propName);
    });
    each([
      "textShadowBlur",
      "textShadowOffsetX",
      "textShadowOffsetY"
    ], (propName) => {
      this.el.style[propName] = textStyleModel.get(propName) || 0;
    });
    this._zr.add(this.el);
    const self2 = this;
    this.el.on("mouseover", function() {
      if (self2._enterable) {
        clearTimeout(self2._hideTimeout);
        self2._show = true;
      }
      self2._inContent = true;
    });
    this.el.on("mouseout", function() {
      if (self2._enterable) {
        if (self2._show) {
          self2.hideLater(self2._hideDelay);
        }
      }
      self2._inContent = false;
    });
  }
  setEnterable(enterable) {
    this._enterable = enterable;
  }
  getSize() {
    const el = this.el;
    const bounding = this.el.getBoundingRect();
    const shadowOuterSize = calcShadowOuterSize(el.style);
    return [
      bounding.width + shadowOuterSize.left + shadowOuterSize.right,
      bounding.height + shadowOuterSize.top + shadowOuterSize.bottom
    ];
  }
  moveTo(x, y) {
    const el = this.el;
    if (el) {
      const styleCoord = this._styleCoord;
      makeStyleCoord2(styleCoord, this._zr, x, y);
      x = styleCoord[0];
      y = styleCoord[1];
      const style = el.style;
      const borderWidth = mathMaxWith0(style.borderWidth || 0);
      const shadowOuterSize = calcShadowOuterSize(style);
      el.x = x + borderWidth + shadowOuterSize.left;
      el.y = y + borderWidth + shadowOuterSize.top;
      el.markRedraw();
    }
  }
  _moveIfResized() {
    const ratioX = this._styleCoord[2];
    const ratioY = this._styleCoord[3];
    this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
  }
  hide() {
    if (this.el) {
      this.el.hide();
    }
    this._show = false;
  }
  hideLater(time) {
    if (this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent) {
      if (time) {
        this._hideDelay = time;
        this._show = false;
        this._hideTimeout = setTimeout(bind(this.hide, this), time);
      } else {
        this.hide();
      }
    }
  }
  isShow() {
    return this._show;
  }
  dispose() {
    this._zr.remove(this.el);
  }
};
function mathMaxWith0(val) {
  return Math.max(0, val);
}
function calcShadowOuterSize(style) {
  const shadowBlur = mathMaxWith0(style.shadowBlur || 0);
  const shadowOffsetX = mathMaxWith0(style.shadowOffsetX || 0);
  const shadowOffsetY = mathMaxWith0(style.shadowOffsetY || 0);
  return {
    left: mathMaxWith0(shadowBlur - shadowOffsetX),
    right: mathMaxWith0(shadowBlur + shadowOffsetX),
    top: mathMaxWith0(shadowBlur - shadowOffsetY),
    bottom: mathMaxWith0(shadowBlur + shadowOffsetY)
  };
}
function makeStyleCoord2(out2, zr, zrX, zrY) {
  out2[0] = zrX;
  out2[1] = zrY;
  out2[2] = out2[0] / zr.getWidth();
  out2[3] = out2[1] / zr.getHeight();
}
var TooltipRichContent_default = TooltipRichContent;

// src/component/tooltip/TooltipView.ts
var proxyRect = new Rect_default({
  shape: {x: -1, y: -1, width: 2, height: 2}
});
var TooltipView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = TooltipView2.type;
  }
  init(ecModel, api2) {
    if (env_default.node || !api2.getDom()) {
      return;
    }
    const tooltipModel = ecModel.getComponent("tooltip");
    const renderMode = this._renderMode = getTooltipRenderMode(tooltipModel.get("renderMode"));
    this._tooltipContent = renderMode === "richText" ? new TooltipRichContent_default(api2) : new TooltipHTMLContent_default(api2, {
      appendTo: tooltipModel.get("appendToBody", true) ? "body" : tooltipModel.get("appendTo", true)
    });
  }
  render(tooltipModel, ecModel, api2) {
    if (env_default.node || !api2.getDom()) {
      return;
    }
    this.group.removeAll();
    this._tooltipModel = tooltipModel;
    this._ecModel = ecModel;
    this._api = api2;
    const tooltipContent = this._tooltipContent;
    tooltipContent.update(tooltipModel);
    tooltipContent.setEnterable(tooltipModel.get("enterable"));
    this._initGlobalListener();
    this._keepShow();
    if (this._renderMode !== "richText" && tooltipModel.get("transitionDuration")) {
      createOrUpdate(this, "_updatePosition", 50, "fixRate");
    } else {
      clear(this, "_updatePosition");
    }
  }
  _initGlobalListener() {
    const tooltipModel = this._tooltipModel;
    const triggerOn = tooltipModel.get("triggerOn");
    register("itemTooltip", this._api, bind(function(currTrigger, e2, dispatchAction3) {
      if (triggerOn !== "none") {
        if (triggerOn.indexOf(currTrigger) >= 0) {
          this._tryShow(e2, dispatchAction3);
        } else if (currTrigger === "leave") {
          this._hide(dispatchAction3);
        }
      }
    }, this));
  }
  _keepShow() {
    const tooltipModel = this._tooltipModel;
    const ecModel = this._ecModel;
    const api2 = this._api;
    const triggerOn = tooltipModel.get("triggerOn");
    if (this._lastX != null && this._lastY != null && triggerOn !== "none" && triggerOn !== "click") {
      const self2 = this;
      clearTimeout(this._refreshUpdateTimeout);
      this._refreshUpdateTimeout = setTimeout(function() {
        !api2.isDisposed() && self2.manuallyShowTip(tooltipModel, ecModel, api2, {
          x: self2._lastX,
          y: self2._lastY,
          dataByCoordSys: self2._lastDataByCoordSys
        });
      });
    }
  }
  manuallyShowTip(tooltipModel, ecModel, api2, payload) {
    if (payload.from === this.uid || env_default.node || !api2.getDom()) {
      return;
    }
    const dispatchAction3 = makeDispatchAction2(payload, api2);
    this._ticket = "";
    const dataByCoordSys = payload.dataByCoordSys;
    const cmptRef = findComponentReference(payload, ecModel, api2);
    if (cmptRef) {
      const rect = cmptRef.el.getBoundingRect().clone();
      rect.applyTransform(cmptRef.el.transform);
      this._tryShow({
        offsetX: rect.x + rect.width / 2,
        offsetY: rect.y + rect.height / 2,
        target: cmptRef.el,
        position: payload.position,
        positionDefault: "bottom"
      }, dispatchAction3);
    } else if (payload.tooltip && payload.x != null && payload.y != null) {
      const el = proxyRect;
      el.x = payload.x;
      el.y = payload.y;
      el.update();
      getECData(el).tooltipConfig = {
        name: null,
        option: payload.tooltip
      };
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        target: el
      }, dispatchAction3);
    } else if (dataByCoordSys) {
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        dataByCoordSys,
        tooltipOption: payload.tooltipOption
      }, dispatchAction3);
    } else if (payload.seriesIndex != null) {
      if (this._manuallyAxisShowTip(tooltipModel, ecModel, api2, payload)) {
        return;
      }
      const pointInfo = findPointFromSeries(payload, ecModel);
      const cx = pointInfo.point[0];
      const cy = pointInfo.point[1];
      if (cx != null && cy != null) {
        this._tryShow({
          offsetX: cx,
          offsetY: cy,
          target: pointInfo.el,
          position: payload.position,
          positionDefault: "bottom"
        }, dispatchAction3);
      }
    } else if (payload.x != null && payload.y != null) {
      api2.dispatchAction({
        type: "updateAxisPointer",
        x: payload.x,
        y: payload.y
      });
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        target: api2.getZr().findHover(payload.x, payload.y).target
      }, dispatchAction3);
    }
  }
  manuallyHideTip(tooltipModel, ecModel, api2, payload) {
    const tooltipContent = this._tooltipContent;
    if (this._tooltipModel) {
      tooltipContent.hideLater(this._tooltipModel.get("hideDelay"));
    }
    this._lastX = this._lastY = this._lastDataByCoordSys = null;
    if (payload.from !== this.uid) {
      this._hide(makeDispatchAction2(payload, api2));
    }
  }
  _manuallyAxisShowTip(tooltipModel, ecModel, api2, payload) {
    const seriesIndex = payload.seriesIndex;
    const dataIndex = payload.dataIndex;
    const coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
    if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
      return;
    }
    const seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    if (!seriesModel) {
      return;
    }
    const data = seriesModel.getData();
    const tooltipCascadedModel = buildTooltipModel([
      data.getItemModel(dataIndex),
      seriesModel,
      (seriesModel.coordinateSystem || {}).model
    ], this._tooltipModel);
    if (tooltipCascadedModel.get("trigger") !== "axis") {
      return;
    }
    api2.dispatchAction({
      type: "updateAxisPointer",
      seriesIndex,
      dataIndex,
      position: payload.position
    });
    return true;
  }
  _tryShow(e2, dispatchAction3) {
    const el = e2.target;
    const tooltipModel = this._tooltipModel;
    if (!tooltipModel) {
      return;
    }
    this._lastX = e2.offsetX;
    this._lastY = e2.offsetY;
    const dataByCoordSys = e2.dataByCoordSys;
    if (dataByCoordSys && dataByCoordSys.length) {
      this._showAxisTooltip(dataByCoordSys, e2);
    } else if (el) {
      const ecData = getECData(el);
      if (ecData.ssrType === "legend") {
        return;
      }
      this._lastDataByCoordSys = null;
      let seriesDispatcher;
      let cmptDispatcher;
      findEventDispatcher(el, function(target) {
        if (target.tooltipDisabled) {
          seriesDispatcher = cmptDispatcher = null;
          return true;
        }
        if (seriesDispatcher || cmptDispatcher) {
          return;
        }
        if (getECData(target).dataIndex != null) {
          seriesDispatcher = target;
        } else if (getECData(target).tooltipConfig != null) {
          cmptDispatcher = target;
        }
      }, true);
      if (seriesDispatcher) {
        this._showSeriesItemTooltip(e2, seriesDispatcher, dispatchAction3);
      } else if (cmptDispatcher) {
        this._showComponentItemTooltip(e2, cmptDispatcher, dispatchAction3);
      } else {
        this._hide(dispatchAction3);
      }
    } else {
      this._lastDataByCoordSys = null;
      this._hide(dispatchAction3);
    }
  }
  _showOrMove(tooltipModel, cb) {
    const delay = tooltipModel.get("showDelay");
    cb = bind(cb, this);
    clearTimeout(this._showTimout);
    delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
  }
  _showAxisTooltip(dataByCoordSys, e2) {
    const ecModel = this._ecModel;
    const globalTooltipModel = this._tooltipModel;
    const point = [e2.offsetX, e2.offsetY];
    const singleTooltipModel = buildTooltipModel([e2.tooltipOption], globalTooltipModel);
    const renderMode = this._renderMode;
    const cbParamsList = [];
    const articleMarkup = createTooltipMarkup("section", {
      blocks: [],
      noHeader: true
    });
    const markupTextArrLegacy = [];
    const markupStyleCreator = new TooltipMarkupStyleCreator();
    each(dataByCoordSys, function(itemCoordSys) {
      each(itemCoordSys.dataByAxis, function(axisItem) {
        const axisModel = ecModel.getComponent(axisItem.axisDim + "Axis", axisItem.axisIndex);
        const axisValue = axisItem.value;
        if (!axisModel || axisValue == null) {
          return;
        }
        const axisValueLabel = getValueLabel(axisValue, axisModel.axis, ecModel, axisItem.seriesDataIndices, axisItem.valueLabelOpt);
        const axisSectionMarkup = createTooltipMarkup("section", {
          header: axisValueLabel,
          noHeader: !trim(axisValueLabel),
          sortBlocks: true,
          blocks: []
        });
        articleMarkup.blocks.push(axisSectionMarkup);
        each(axisItem.seriesDataIndices, function(idxItem) {
          const series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
          const dataIndex = idxItem.dataIndexInside;
          const cbParams = series.getDataParams(dataIndex);
          if (cbParams.dataIndex < 0) {
            return;
          }
          cbParams.axisDim = axisItem.axisDim;
          cbParams.axisIndex = axisItem.axisIndex;
          cbParams.axisType = axisItem.axisType;
          cbParams.axisId = axisItem.axisId;
          cbParams.axisValue = getAxisRawValue(axisModel.axis, {value: axisValue});
          cbParams.axisValueLabel = axisValueLabel;
          cbParams.marker = markupStyleCreator.makeTooltipMarker("item", convertToColorString(cbParams.color), renderMode);
          const seriesTooltipResult = normalizeTooltipFormatResult(series.formatTooltip(dataIndex, true, null));
          const frag = seriesTooltipResult.frag;
          if (frag) {
            const valueFormatter = buildTooltipModel([series], globalTooltipModel).get("valueFormatter");
            axisSectionMarkup.blocks.push(valueFormatter ? extend({valueFormatter}, frag) : frag);
          }
          if (seriesTooltipResult.text) {
            markupTextArrLegacy.push(seriesTooltipResult.text);
          }
          cbParamsList.push(cbParams);
        });
      });
    });
    articleMarkup.blocks.reverse();
    markupTextArrLegacy.reverse();
    const positionExpr = e2.position;
    const orderMode = singleTooltipModel.get("order");
    const builtMarkupText = buildTooltipMarkup(articleMarkup, markupStyleCreator, renderMode, orderMode, ecModel.get("useUTC"), singleTooltipModel.get("textStyle"));
    builtMarkupText && markupTextArrLegacy.unshift(builtMarkupText);
    const blockBreak = renderMode === "richText" ? "\n\n" : "<br/>";
    const allMarkupText = markupTextArrLegacy.join(blockBreak);
    this._showOrMove(singleTooltipModel, function() {
      if (this._updateContentNotChangedOnAxis(dataByCoordSys, cbParamsList)) {
        this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, cbParamsList);
      } else {
        this._showTooltipContent(singleTooltipModel, allMarkupText, cbParamsList, Math.random() + "", point[0], point[1], positionExpr, null, markupStyleCreator);
      }
    });
  }
  _showSeriesItemTooltip(e2, dispatcher, dispatchAction3) {
    const ecModel = this._ecModel;
    const ecData = getECData(dispatcher);
    const seriesIndex = ecData.seriesIndex;
    const seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    const dataModel = ecData.dataModel || seriesModel;
    const dataIndex = ecData.dataIndex;
    const dataType = ecData.dataType;
    const data = dataModel.getData(dataType);
    const renderMode = this._renderMode;
    const positionDefault = e2.positionDefault;
    const tooltipModel = buildTooltipModel([
      data.getItemModel(dataIndex),
      dataModel,
      seriesModel && (seriesModel.coordinateSystem || {}).model
    ], this._tooltipModel, positionDefault ? {position: positionDefault} : null);
    const tooltipTrigger = tooltipModel.get("trigger");
    if (tooltipTrigger != null && tooltipTrigger !== "item") {
      return;
    }
    const params = dataModel.getDataParams(dataIndex, dataType);
    const markupStyleCreator = new TooltipMarkupStyleCreator();
    params.marker = markupStyleCreator.makeTooltipMarker("item", convertToColorString(params.color), renderMode);
    const seriesTooltipResult = normalizeTooltipFormatResult(dataModel.formatTooltip(dataIndex, false, dataType));
    const orderMode = tooltipModel.get("order");
    const valueFormatter = tooltipModel.get("valueFormatter");
    const frag = seriesTooltipResult.frag;
    const markupText = frag ? buildTooltipMarkup(valueFormatter ? extend({valueFormatter}, frag) : frag, markupStyleCreator, renderMode, orderMode, ecModel.get("useUTC"), tooltipModel.get("textStyle")) : seriesTooltipResult.text;
    const asyncTicket = "item_" + dataModel.name + "_" + dataIndex;
    this._showOrMove(tooltipModel, function() {
      this._showTooltipContent(tooltipModel, markupText, params, asyncTicket, e2.offsetX, e2.offsetY, e2.position, e2.target, markupStyleCreator);
    });
    dispatchAction3({
      type: "showTip",
      dataIndexInside: dataIndex,
      dataIndex: data.getRawIndex(dataIndex),
      seriesIndex,
      from: this.uid
    });
  }
  _showComponentItemTooltip(e2, el, dispatchAction3) {
    const isHTMLRenderMode = this._renderMode === "html";
    const ecData = getECData(el);
    const tooltipConfig = ecData.tooltipConfig;
    let tooltipOpt = tooltipConfig.option || {};
    let encodeHTMLContent = tooltipOpt.encodeHTMLContent;
    if (isString(tooltipOpt)) {
      const content = tooltipOpt;
      tooltipOpt = {
        content,
        formatter: content
      };
      encodeHTMLContent = true;
    }
    if (encodeHTMLContent && isHTMLRenderMode && tooltipOpt.content) {
      tooltipOpt = clone(tooltipOpt);
      tooltipOpt.content = encodeHTML(tooltipOpt.content);
    }
    const tooltipModelCascade = [tooltipOpt];
    const cmpt = this._ecModel.getComponent(ecData.componentMainType, ecData.componentIndex);
    if (cmpt) {
      tooltipModelCascade.push(cmpt);
    }
    tooltipModelCascade.push({formatter: tooltipOpt.content});
    const positionDefault = e2.positionDefault;
    const subTooltipModel = buildTooltipModel(tooltipModelCascade, this._tooltipModel, positionDefault ? {position: positionDefault} : null);
    const defaultHtml = subTooltipModel.get("content");
    const asyncTicket = Math.random() + "";
    const markupStyleCreator = new TooltipMarkupStyleCreator();
    this._showOrMove(subTooltipModel, function() {
      const formatterParams = clone(subTooltipModel.get("formatterParams") || {});
      this._showTooltipContent(subTooltipModel, defaultHtml, formatterParams, asyncTicket, e2.offsetX, e2.offsetY, e2.position, el, markupStyleCreator);
    });
    dispatchAction3({
      type: "showTip",
      from: this.uid
    });
  }
  _showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el, markupStyleCreator) {
    this._ticket = "";
    if (!tooltipModel.get("showContent") || !tooltipModel.get("show")) {
      return;
    }
    const tooltipContent = this._tooltipContent;
    tooltipContent.setEnterable(tooltipModel.get("enterable"));
    const formatter = tooltipModel.get("formatter");
    positionExpr = positionExpr || tooltipModel.get("position");
    let html = defaultHtml;
    const nearPoint = this._getNearestPoint([x, y], params, tooltipModel.get("trigger"), tooltipModel.get("borderColor"), tooltipModel.get("defaultBorderColor", true));
    const nearPointColor = nearPoint.color;
    if (formatter) {
      if (isString(formatter)) {
        const useUTC = tooltipModel.ecModel.get("useUTC");
        const params0 = isArray(params) ? params[0] : params;
        const isTimeAxis = params0 && params0.axisType && params0.axisType.indexOf("time") >= 0;
        html = formatter;
        if (isTimeAxis) {
          html = format(params0.axisValue, html, useUTC);
        }
        html = formatTpl(html, params, true);
      } else if (isFunction(formatter)) {
        const callback = bind(function(cbTicket, html2) {
          if (cbTicket === this._ticket) {
            tooltipContent.setContent(html2, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
            this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
          }
        }, this);
        this._ticket = asyncTicket;
        html = formatter(params, asyncTicket, callback);
      } else {
        html = formatter;
      }
    }
    tooltipContent.setContent(html, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
    tooltipContent.show(tooltipModel, nearPointColor);
    this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
  }
  _getNearestPoint(point, tooltipDataParams, trigger3, borderColor, defaultBorderColor) {
    if (trigger3 === "axis" || isArray(tooltipDataParams)) {
      return {
        color: borderColor || defaultBorderColor
      };
    }
    if (!isArray(tooltipDataParams)) {
      return {
        color: borderColor || tooltipDataParams.color || tooltipDataParams.borderColor
      };
    }
  }
  _updatePosition(tooltipModel, positionExpr, x, y, content, params, el) {
    const viewWidth = this._api.getWidth();
    const viewHeight = this._api.getHeight();
    positionExpr = positionExpr || tooltipModel.get("position");
    const contentSize = content.getSize();
    let align = tooltipModel.get("align");
    let vAlign = tooltipModel.get("verticalAlign");
    const rect = el && el.getBoundingRect().clone();
    el && rect.applyTransform(el.transform);
    if (isFunction(positionExpr)) {
      positionExpr = positionExpr([x, y], params, content.el, rect, {
        viewSize: [viewWidth, viewHeight],
        contentSize: contentSize.slice()
      });
    }
    if (isArray(positionExpr)) {
      x = parsePercent2(positionExpr[0], viewWidth);
      y = parsePercent2(positionExpr[1], viewHeight);
    } else if (isObject(positionExpr)) {
      const boxLayoutPosition = positionExpr;
      boxLayoutPosition.width = contentSize[0];
      boxLayoutPosition.height = contentSize[1];
      const layoutRect = getLayoutRect(boxLayoutPosition, {width: viewWidth, height: viewHeight});
      x = layoutRect.x;
      y = layoutRect.y;
      align = null;
      vAlign = null;
    } else if (isString(positionExpr) && el) {
      const pos = calcTooltipPosition(positionExpr, rect, contentSize, tooltipModel.get("borderWidth"));
      x = pos[0];
      y = pos[1];
    } else {
      const pos = refixTooltipPosition(x, y, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
      x = pos[0];
      y = pos[1];
    }
    align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === "right" ? contentSize[0] : 0);
    vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === "bottom" ? contentSize[1] : 0);
    if (shouldTooltipConfine(tooltipModel)) {
      const pos = confineTooltipPosition(x, y, content, viewWidth, viewHeight);
      x = pos[0];
      y = pos[1];
    }
    content.moveTo(x, y);
  }
  _updateContentNotChangedOnAxis(dataByCoordSys, cbParamsList) {
    const lastCoordSys = this._lastDataByCoordSys;
    const lastCbParamsList = this._cbParamsList;
    let contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
    contentNotChanged && each(lastCoordSys, (lastItemCoordSys, indexCoordSys) => {
      const lastDataByAxis = lastItemCoordSys.dataByAxis || [];
      const thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
      const thisDataByAxis = thisItemCoordSys.dataByAxis || [];
      contentNotChanged = contentNotChanged && lastDataByAxis.length === thisDataByAxis.length;
      contentNotChanged && each(lastDataByAxis, (lastItem, indexAxis) => {
        const thisItem = thisDataByAxis[indexAxis] || {};
        const lastIndices = lastItem.seriesDataIndices || [];
        const newIndices = thisItem.seriesDataIndices || [];
        contentNotChanged = contentNotChanged && lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
        contentNotChanged && each(lastIndices, (lastIdxItem, j) => {
          const newIdxItem = newIndices[j];
          contentNotChanged = contentNotChanged && lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
        });
        lastCbParamsList && each(lastItem.seriesDataIndices, (idxItem) => {
          const seriesIdx = idxItem.seriesIndex;
          const cbParams = cbParamsList[seriesIdx];
          const lastCbParams = lastCbParamsList[seriesIdx];
          if (cbParams && lastCbParams && lastCbParams.data !== cbParams.data) {
            contentNotChanged = false;
          }
        });
      });
    });
    this._lastDataByCoordSys = dataByCoordSys;
    this._cbParamsList = cbParamsList;
    return !!contentNotChanged;
  }
  _hide(dispatchAction3) {
    this._lastDataByCoordSys = null;
    dispatchAction3({
      type: "hideTip",
      from: this.uid
    });
  }
  dispose(ecModel, api2) {
    if (env_default.node || !api2.getDom()) {
      return;
    }
    clear(this, "_updatePosition");
    this._tooltipContent.dispose();
    unregister("itemTooltip", api2);
  }
};
var TooltipView = TooltipView2;
TooltipView.type = "tooltip";
function buildTooltipModel(modelCascade, globalTooltipModel, defaultTooltipOption) {
  const ecModel = globalTooltipModel.ecModel;
  let resultModel;
  if (defaultTooltipOption) {
    resultModel = new Model_default(defaultTooltipOption, ecModel, ecModel);
    resultModel = new Model_default(globalTooltipModel.option, resultModel, ecModel);
  } else {
    resultModel = globalTooltipModel;
  }
  for (let i = modelCascade.length - 1; i >= 0; i--) {
    let tooltipOpt = modelCascade[i];
    if (tooltipOpt) {
      if (tooltipOpt instanceof Model_default) {
        tooltipOpt = tooltipOpt.get("tooltip", true);
      }
      if (isString(tooltipOpt)) {
        tooltipOpt = {
          formatter: tooltipOpt
        };
      }
      if (tooltipOpt) {
        resultModel = new Model_default(tooltipOpt, resultModel, ecModel);
      }
    }
  }
  return resultModel;
}
function makeDispatchAction2(payload, api2) {
  return payload.dispatchAction || bind(api2.dispatchAction, api2);
}
function refixTooltipPosition(x, y, content, viewWidth, viewHeight, gapH, gapV) {
  const size = content.getSize();
  const width = size[0];
  const height = size[1];
  if (gapH != null) {
    if (x + width + gapH + 2 > viewWidth) {
      x -= width + gapH;
    } else {
      x += gapH;
    }
  }
  if (gapV != null) {
    if (y + height + gapV > viewHeight) {
      y -= height + gapV;
    } else {
      y += gapV;
    }
  }
  return [x, y];
}
function confineTooltipPosition(x, y, content, viewWidth, viewHeight) {
  const size = content.getSize();
  const width = size[0];
  const height = size[1];
  x = Math.min(x + width, viewWidth) - width;
  y = Math.min(y + height, viewHeight) - height;
  x = Math.max(x, 0);
  y = Math.max(y, 0);
  return [x, y];
}
function calcTooltipPosition(position2, rect, contentSize, borderWidth) {
  const domWidth = contentSize[0];
  const domHeight = contentSize[1];
  const offset = Math.ceil(Math.SQRT2 * borderWidth) + 8;
  let x = 0;
  let y = 0;
  const rectWidth = rect.width;
  const rectHeight = rect.height;
  switch (position2) {
    case "inside":
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y + rectHeight / 2 - domHeight / 2;
      break;
    case "top":
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y - domHeight - offset;
      break;
    case "bottom":
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y + rectHeight + offset;
      break;
    case "left":
      x = rect.x - domWidth - offset;
      y = rect.y + rectHeight / 2 - domHeight / 2;
      break;
    case "right":
      x = rect.x + rectWidth + offset;
      y = rect.y + rectHeight / 2 - domHeight / 2;
  }
  return [x, y];
}
function isCenterAlign(align) {
  return align === "center" || align === "middle";
}
function findComponentReference(payload, ecModel, api2) {
  const {queryOptionMap} = preParseFinder(payload);
  const componentMainType = queryOptionMap.keys()[0];
  if (!componentMainType || componentMainType === "series") {
    return;
  }
  const queryResult = queryReferringComponents(ecModel, componentMainType, queryOptionMap.get(componentMainType), {useDefault: false, enableAll: false, enableNone: false});
  const model = queryResult.models[0];
  if (!model) {
    return;
  }
  const view = api2.getViewOfComponentModel(model);
  let el;
  view.group.traverse((subEl) => {
    const tooltipConfig = getECData(subEl).tooltipConfig;
    if (tooltipConfig && tooltipConfig.name === payload.name) {
      el = subEl;
      return true;
    }
  });
  if (el) {
    return {
      componentMainType,
      componentIndex: model.componentIndex,
      el
    };
  }
}
var TooltipView_default = TooltipView;

// src/component/tooltip/install.ts
function install39(registers) {
  use(install30);
  registers.registerComponentModel(TooltipModel_default);
  registers.registerComponentView(TooltipView_default);
  registers.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, noop);
  registers.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, noop);
}

// src/component/brush/preprocessor.ts
var DEFAULT_TOOLBOX_BTNS = ["rect", "polygon", "keep", "clear"];
function brushPreprocessor(option, isNew) {
  const brushComponents = normalizeToArray(option ? option.brush : []);
  if (!brushComponents.length) {
    return;
  }
  let brushComponentSpecifiedBtns = [];
  each(brushComponents, function(brushOpt) {
    const tbs = brushOpt.hasOwnProperty("toolbox") ? brushOpt.toolbox : [];
    if (tbs instanceof Array) {
      brushComponentSpecifiedBtns = brushComponentSpecifiedBtns.concat(tbs);
    }
  });
  let toolbox = option && option.toolbox;
  if (isArray(toolbox)) {
    toolbox = toolbox[0];
  }
  if (!toolbox) {
    toolbox = {feature: {}};
    option.toolbox = [toolbox];
  }
  const toolboxFeature = toolbox.feature || (toolbox.feature = {});
  const toolboxBrush = toolboxFeature.brush || (toolboxFeature.brush = {});
  const brushTypes = toolboxBrush.type || (toolboxBrush.type = []);
  brushTypes.push.apply(brushTypes, brushComponentSpecifiedBtns);
  removeDuplicate(brushTypes);
  if (isNew && !brushTypes.length) {
    brushTypes.push.apply(brushTypes, DEFAULT_TOOLBOX_BTNS);
  }
}
function removeDuplicate(arr) {
  const map3 = {};
  each(arr, function(val) {
    map3[val] = 1;
  });
  arr.length = 0;
  each(map3, function(flag, val) {
    arr.push(val);
  });
}

// src/visual/visualSolution.ts
var each12 = each;
function hasKeys(obj) {
  if (obj) {
    for (const name in obj) {
      if (obj.hasOwnProperty(name)) {
        return true;
      }
    }
  }
}
function createVisualMappings(option, stateList, supplementVisualOption) {
  const visualMappings = {};
  each12(stateList, function(state) {
    const mappings = visualMappings[state] = createMappings();
    each12(option[state], function(visualData, visualType) {
      if (!VisualMapping_default.isValidType(visualType)) {
        return;
      }
      let mappingOption = {
        type: visualType,
        visual: visualData
      };
      supplementVisualOption && supplementVisualOption(mappingOption, state);
      mappings[visualType] = new VisualMapping_default(mappingOption);
      if (visualType === "opacity") {
        mappingOption = clone(mappingOption);
        mappingOption.type = "colorAlpha";
        mappings.__hidden.__alphaForOpacity = new VisualMapping_default(mappingOption);
      }
    });
  });
  return visualMappings;
  function createMappings() {
    const Creater = function() {
    };
    Creater.prototype.__hidden = Creater.prototype;
    const obj = new Creater();
    return obj;
  }
}
function replaceVisualOption(thisOption, newOption, keys2) {
  let has3;
  each(keys2, function(key) {
    if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
      has3 = true;
    }
  });
  has3 && each(keys2, function(key) {
    if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
      thisOption[key] = clone(newOption[key]);
    } else {
      delete thisOption[key];
    }
  });
}
function applyVisual(stateList, visualMappings, data, getValueState, scope, dimension) {
  const visualTypesMap = {};
  each(stateList, function(state) {
    const visualTypes = VisualMapping_default.prepareVisualTypes(visualMappings[state]);
    visualTypesMap[state] = visualTypes;
  });
  let dataIndex;
  function getVisual(key) {
    return getItemVisualFromData(data, dataIndex, key);
  }
  function setVisual(key, value) {
    setItemVisualFromData(data, dataIndex, key, value);
  }
  if (dimension == null) {
    data.each(eachItem);
  } else {
    data.each([dimension], eachItem);
  }
  function eachItem(valueOrIndex, index) {
    dataIndex = dimension == null ? valueOrIndex : index;
    const rawDataItem = data.getRawDataItem(dataIndex);
    if (rawDataItem && rawDataItem.visualMap === false) {
      return;
    }
    const valueState = getValueState.call(scope, valueOrIndex);
    const mappings = visualMappings[valueState];
    const visualTypes = visualTypesMap[valueState];
    for (let i = 0, len2 = visualTypes.length; i < len2; i++) {
      const type = visualTypes[i];
      mappings[type] && mappings[type].applyVisual(valueOrIndex, getVisual, setVisual);
    }
  }
}
function incrementalApplyVisual(stateList, visualMappings, getValueState, dim) {
  const visualTypesMap = {};
  each(stateList, function(state) {
    const visualTypes = VisualMapping_default.prepareVisualTypes(visualMappings[state]);
    visualTypesMap[state] = visualTypes;
  });
  return {
    progress: function progress(params, data) {
      let dimIndex;
      if (dim != null) {
        dimIndex = data.getDimensionIndex(dim);
      }
      function getVisual(key) {
        return getItemVisualFromData(data, dataIndex, key);
      }
      function setVisual(key, value) {
        setItemVisualFromData(data, dataIndex, key, value);
      }
      let dataIndex;
      const store = data.getStore();
      while ((dataIndex = params.next()) != null) {
        const rawDataItem = data.getRawDataItem(dataIndex);
        if (rawDataItem && rawDataItem.visualMap === false) {
          continue;
        }
        const value = dim != null ? store.get(dimIndex, dataIndex) : dataIndex;
        const valueState = getValueState(value);
        const mappings = visualMappings[valueState];
        const visualTypes = visualTypesMap[valueState];
        for (let i = 0, len2 = visualTypes.length; i < len2; i++) {
          const type = visualTypes[i];
          mappings[type] && mappings[type].applyVisual(value, getVisual, setVisual);
        }
      }
    }
  };
}

// src/component/brush/selector.ts
function makeBrushCommonSelectorForSeries(area) {
  const brushType = area.brushType;
  const selectors = {
    point(itemLayout) {
      return selector[brushType].point(itemLayout, selectors, area);
    },
    rect(itemLayout) {
      return selector[brushType].rect(itemLayout, selectors, area);
    }
  };
  return selectors;
}
var selector = {
  lineX: getLineSelectors(0),
  lineY: getLineSelectors(1),
  rect: {
    point: function(itemLayout, selectors, area) {
      return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]);
    },
    rect: function(itemLayout, selectors, area) {
      return itemLayout && area.boundingRect.intersect(itemLayout);
    }
  },
  polygon: {
    point: function(itemLayout, selectors, area) {
      return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]) && contain3(area.range, itemLayout[0], itemLayout[1]);
    },
    rect: function(itemLayout, selectors, area) {
      const points4 = area.range;
      if (!itemLayout || points4.length <= 1) {
        return false;
      }
      const x = itemLayout.x;
      const y = itemLayout.y;
      const width = itemLayout.width;
      const height = itemLayout.height;
      const p = points4[0];
      if (contain3(points4, x, y) || contain3(points4, x + width, y) || contain3(points4, x, y + height) || contain3(points4, x + width, y + height) || BoundingRect_default.create(itemLayout).contain(p[0], p[1]) || linePolygonIntersect(x, y, x + width, y, points4) || linePolygonIntersect(x, y, x, y + height, points4) || linePolygonIntersect(x + width, y, x + width, y + height, points4) || linePolygonIntersect(x, y + height, x + width, y + height, points4)) {
        return true;
      }
    }
  }
};
function getLineSelectors(xyIndex) {
  const xy = ["x", "y"];
  const wh = ["width", "height"];
  return {
    point: function(itemLayout, selectors, area) {
      if (itemLayout) {
        const range = area.range;
        const p = itemLayout[xyIndex];
        return inLineRange(p, range);
      }
    },
    rect: function(itemLayout, selectors, area) {
      if (itemLayout) {
        const range = area.range;
        const layoutRange = [
          itemLayout[xy[xyIndex]],
          itemLayout[xy[xyIndex]] + itemLayout[wh[xyIndex]]
        ];
        layoutRange[1] < layoutRange[0] && layoutRange.reverse();
        return inLineRange(layoutRange[0], range) || inLineRange(layoutRange[1], range) || inLineRange(range[0], layoutRange) || inLineRange(range[1], layoutRange);
      }
    }
  };
}
function inLineRange(p, range) {
  return range[0] <= p && p <= range[1];
}

// src/component/brush/visualEncoding.ts
var STATE_LIST = ["inBrush", "outOfBrush"];
var DISPATCH_METHOD = "__ecBrushSelect";
var DISPATCH_FLAG = "__ecInBrushSelectEvent";
function layoutCovers(ecModel) {
  ecModel.eachComponent({mainType: "brush"}, function(brushModel) {
    const brushTargetManager = brushModel.brushTargetManager = new BrushTargetManager_default(brushModel.option, ecModel);
    brushTargetManager.setInputRanges(brushModel.areas, ecModel);
  });
}
function brushVisual(ecModel, api2, payload) {
  const brushSelected = [];
  let throttleType;
  let throttleDelay;
  ecModel.eachComponent({mainType: "brush"}, function(brushModel) {
    payload && payload.type === "takeGlobalCursor" && brushModel.setBrushOption(payload.key === "brush" ? payload.brushOption : {brushType: false});
  });
  layoutCovers(ecModel);
  ecModel.eachComponent({mainType: "brush"}, function(brushModel, brushIndex) {
    const thisBrushSelected = {
      brushId: brushModel.id,
      brushIndex,
      brushName: brushModel.name,
      areas: clone(brushModel.areas),
      selected: []
    };
    brushSelected.push(thisBrushSelected);
    const brushOption = brushModel.option;
    const brushLink = brushOption.brushLink;
    const linkedSeriesMap = [];
    const selectedDataIndexForLink = [];
    const rangeInfoBySeries = [];
    let hasBrushExists = false;
    if (!brushIndex) {
      throttleType = brushOption.throttleType;
      throttleDelay = brushOption.throttleDelay;
    }
    const areas = map(brushModel.areas, function(area) {
      const builder = boundingRectBuilders[area.brushType];
      const selectableArea = defaults({boundingRect: builder ? builder(area) : void 0}, area);
      selectableArea.selectors = makeBrushCommonSelectorForSeries(selectableArea);
      return selectableArea;
    });
    const visualMappings = createVisualMappings(brushModel.option, STATE_LIST, function(mappingOption) {
      mappingOption.mappingMethod = "fixed";
    });
    isArray(brushLink) && each(brushLink, function(seriesIndex) {
      linkedSeriesMap[seriesIndex] = 1;
    });
    function linkOthers(seriesIndex) {
      return brushLink === "all" || !!linkedSeriesMap[seriesIndex];
    }
    function brushed(rangeInfoList) {
      return !!rangeInfoList.length;
    }
    ecModel.eachSeries(function(seriesModel, seriesIndex) {
      const rangeInfoList = rangeInfoBySeries[seriesIndex] = [];
      seriesModel.subType === "parallel" ? stepAParallel(seriesModel, seriesIndex) : stepAOthers(seriesModel, seriesIndex, rangeInfoList);
    });
    function stepAParallel(seriesModel, seriesIndex) {
      const coordSys = seriesModel.coordinateSystem;
      hasBrushExists = hasBrushExists || coordSys.hasAxisBrushed();
      linkOthers(seriesIndex) && coordSys.eachActiveState(seriesModel.getData(), function(activeState, dataIndex) {
        activeState === "active" && (selectedDataIndexForLink[dataIndex] = 1);
      });
    }
    function stepAOthers(seriesModel, seriesIndex, rangeInfoList) {
      if (!seriesModel.brushSelector || brushModelNotControll(brushModel, seriesIndex)) {
        return;
      }
      each(areas, function(area) {
        if (brushModel.brushTargetManager.controlSeries(area, seriesModel, ecModel)) {
          rangeInfoList.push(area);
        }
        hasBrushExists = hasBrushExists || brushed(rangeInfoList);
      });
      if (linkOthers(seriesIndex) && brushed(rangeInfoList)) {
        const data = seriesModel.getData();
        data.each(function(dataIndex) {
          if (checkInRange(seriesModel, rangeInfoList, data, dataIndex)) {
            selectedDataIndexForLink[dataIndex] = 1;
          }
        });
      }
    }
    ecModel.eachSeries(function(seriesModel, seriesIndex) {
      const seriesBrushSelected = {
        seriesId: seriesModel.id,
        seriesIndex,
        seriesName: seriesModel.name,
        dataIndex: []
      };
      thisBrushSelected.selected.push(seriesBrushSelected);
      const rangeInfoList = rangeInfoBySeries[seriesIndex];
      const data = seriesModel.getData();
      const getValueState = linkOthers(seriesIndex) ? function(dataIndex) {
        return selectedDataIndexForLink[dataIndex] ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), "inBrush") : "outOfBrush";
      } : function(dataIndex) {
        return checkInRange(seriesModel, rangeInfoList, data, dataIndex) ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), "inBrush") : "outOfBrush";
      };
      (linkOthers(seriesIndex) ? hasBrushExists : brushed(rangeInfoList)) && applyVisual(STATE_LIST, visualMappings, data, getValueState);
    });
  });
  dispatchAction(api2, throttleType, throttleDelay, brushSelected, payload);
}
function dispatchAction(api2, throttleType, throttleDelay, brushSelected, payload) {
  if (!payload) {
    return;
  }
  const zr = api2.getZr();
  if (zr[DISPATCH_FLAG]) {
    return;
  }
  if (!zr[DISPATCH_METHOD]) {
    zr[DISPATCH_METHOD] = doDispatch;
  }
  const fn = createOrUpdate(zr, DISPATCH_METHOD, throttleDelay, throttleType);
  fn(api2, brushSelected);
}
function doDispatch(api2, brushSelected) {
  if (!api2.isDisposed()) {
    const zr = api2.getZr();
    zr[DISPATCH_FLAG] = true;
    api2.dispatchAction({
      type: "brushSelect",
      batch: brushSelected
    });
    zr[DISPATCH_FLAG] = false;
  }
}
function checkInRange(seriesModel, rangeInfoList, data, dataIndex) {
  for (let i = 0, len2 = rangeInfoList.length; i < len2; i++) {
    const area = rangeInfoList[i];
    if (seriesModel.brushSelector(dataIndex, data, area.selectors, area)) {
      return true;
    }
  }
}
function brushModelNotControll(brushModel, seriesIndex) {
  const seriesIndices = brushModel.option.seriesIndex;
  return seriesIndices != null && seriesIndices !== "all" && (isArray(seriesIndices) ? indexOf(seriesIndices, seriesIndex) < 0 : seriesIndex !== seriesIndices);
}
var boundingRectBuilders = {
  rect: function(area) {
    return getBoundingRectFromMinMax(area.range);
  },
  polygon: function(area) {
    let minMax;
    const range = area.range;
    for (let i = 0, len2 = range.length; i < len2; i++) {
      minMax = minMax || [[Infinity, -Infinity], [Infinity, -Infinity]];
      const rg = range[i];
      rg[0] < minMax[0][0] && (minMax[0][0] = rg[0]);
      rg[0] > minMax[0][1] && (minMax[0][1] = rg[0]);
      rg[1] < minMax[1][0] && (minMax[1][0] = rg[1]);
      rg[1] > minMax[1][1] && (minMax[1][1] = rg[1]);
    }
    return minMax && getBoundingRectFromMinMax(minMax);
  }
};
function getBoundingRectFromMinMax(minMax) {
  return new BoundingRect_default(minMax[0][0], minMax[1][0], minMax[0][1] - minMax[0][0], minMax[1][1] - minMax[1][0]);
}

// src/component/brush/BrushView.ts
var BrushView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = BrushView2.type;
  }
  init(ecModel, api2) {
    this.ecModel = ecModel;
    this.api = api2;
    this.model;
    (this._brushController = new BrushController_default(api2.getZr())).on("brush", bind(this._onBrush, this)).mount();
  }
  render(brushModel, ecModel, api2, payload) {
    this.model = brushModel;
    this._updateController(brushModel, ecModel, api2, payload);
  }
  updateTransform(brushModel, ecModel, api2, payload) {
    layoutCovers(ecModel);
    this._updateController(brushModel, ecModel, api2, payload);
  }
  updateVisual(brushModel, ecModel, api2, payload) {
    this.updateTransform(brushModel, ecModel, api2, payload);
  }
  updateView(brushModel, ecModel, api2, payload) {
    this._updateController(brushModel, ecModel, api2, payload);
  }
  _updateController(brushModel, ecModel, api2, payload) {
    (!payload || payload.$from !== brushModel.id) && this._brushController.setPanels(brushModel.brushTargetManager.makePanelOpts(api2)).enableBrush(brushModel.brushOption).updateCovers(brushModel.areas.slice());
  }
  dispose() {
    this._brushController.dispose();
  }
  _onBrush(eventParam) {
    const modelId = this.model.id;
    const areas = this.model.brushTargetManager.setOutputRanges(eventParam.areas, this.ecModel);
    (!eventParam.isEnd || eventParam.removeOnClick) && this.api.dispatchAction({
      type: "brush",
      brushId: modelId,
      areas: clone(areas),
      $from: modelId
    });
    eventParam.isEnd && this.api.dispatchAction({
      type: "brushEnd",
      brushId: modelId,
      areas: clone(areas),
      $from: modelId
    });
  }
};
var BrushView = BrushView2;
BrushView.type = "brush";
var BrushView_default = BrushView;

// src/component/brush/BrushModel.ts
var BrushModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = BrushModel2.type;
    this.areas = [];
    this.brushOption = {};
  }
  optionUpdated(newOption, isInit) {
    const thisOption = this.option;
    !isInit && replaceVisualOption(thisOption, newOption, ["inBrush", "outOfBrush"]);
    const inBrush = thisOption.inBrush = thisOption.inBrush || {};
    thisOption.outOfBrush = thisOption.outOfBrush || {color: this.option.defaultOutOfBrushColor};
    if (!inBrush.hasOwnProperty("liftZ")) {
      inBrush.liftZ = 5;
    }
  }
  setAreas(areas) {
    if (true) {
      assert(isArray(areas));
      each(areas, function(area) {
        assert(area.brushType, "Illegal areas");
      });
    }
    if (!areas) {
      return;
    }
    this.areas = map(areas, function(area) {
      return generateBrushOption(this.option, area);
    }, this);
  }
  setBrushOption(brushOption) {
    this.brushOption = generateBrushOption(this.option, brushOption);
    this.brushType = this.brushOption.brushType;
  }
};
var BrushModel = BrushModel2;
BrushModel.type = "brush";
BrushModel.dependencies = ["geo", "grid", "xAxis", "yAxis", "parallel", "series"];
BrushModel.defaultOption = {
  seriesIndex: "all",
  brushType: "rect",
  brushMode: "single",
  transformable: true,
  brushStyle: {
    borderWidth: 1,
    color: tokens_default.color.backgroundTint,
    borderColor: tokens_default.color.borderTint
  },
  throttleType: "fixRate",
  throttleDelay: 0,
  removeOnClick: true,
  z: 1e4,
  defaultOutOfBrushColor: tokens_default.color.disabled
};
function generateBrushOption(option, brushOption) {
  return merge({
    brushType: option.brushType,
    brushMode: option.brushMode,
    transformable: option.transformable,
    brushStyle: new Model_default(option.brushStyle).getItemStyle(),
    removeOnClick: option.removeOnClick,
    z: option.z
  }, brushOption, true);
}
var BrushModel_default = BrushModel;

// src/component/toolbox/feature/Brush.ts
var ICON_TYPES = ["rect", "polygon", "lineX", "lineY", "keep", "clear"];
var BrushFeature = class extends ToolboxFeature {
  render(featureModel, ecModel, api2) {
    let brushType;
    let brushMode;
    let isBrushed;
    ecModel.eachComponent({mainType: "brush"}, function(brushModel) {
      brushType = brushModel.brushType;
      brushMode = brushModel.brushOption.brushMode || "single";
      isBrushed = isBrushed || !!brushModel.areas.length;
    });
    this._brushType = brushType;
    this._brushMode = brushMode;
    each(featureModel.get("type", true), function(type) {
      featureModel.setIconStatus(type, (type === "keep" ? brushMode === "multiple" : type === "clear" ? isBrushed : type === brushType) ? "emphasis" : "normal");
    });
  }
  updateView(featureModel, ecModel, api2) {
    this.render(featureModel, ecModel, api2);
  }
  getIcons() {
    const model = this.model;
    const availableIcons = model.get("icon", true);
    const icons = {};
    each(model.get("type", true), function(type) {
      if (availableIcons[type]) {
        icons[type] = availableIcons[type];
      }
    });
    return icons;
  }
  onclick(ecModel, api2, type) {
    const brushType = this._brushType;
    const brushMode = this._brushMode;
    if (type === "clear") {
      api2.dispatchAction({
        type: "axisAreaSelect",
        intervals: []
      });
      api2.dispatchAction({
        type: "brush",
        command: "clear",
        areas: []
      });
    } else {
      api2.dispatchAction({
        type: "takeGlobalCursor",
        key: "brush",
        brushOption: {
          brushType: type === "keep" ? brushType : brushType === type ? false : type,
          brushMode: type === "keep" ? brushMode === "multiple" ? "single" : "multiple" : brushMode
        }
      });
    }
  }
  static getDefaultOption(ecModel) {
    const defaultOption3 = {
      show: true,
      type: ICON_TYPES.slice(),
      icon: {
        rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
        polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
        lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
        lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
        keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
        clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
      },
      title: ecModel.getLocaleModel().get(["toolbox", "brush", "title"])
    };
    return defaultOption3;
  }
};
var Brush_default = BrushFeature;

// src/component/brush/install.ts
function install40(registers) {
  registers.registerComponentView(BrushView_default);
  registers.registerComponentModel(BrushModel_default);
  registers.registerPreprocessor(brushPreprocessor);
  registers.registerVisual(registers.PRIORITY.VISUAL.BRUSH, brushVisual);
  registers.registerAction({type: "brush", event: "brush", update: "updateVisual"}, function(payload, ecModel) {
    ecModel.eachComponent({mainType: "brush", query: payload}, function(brushModel) {
      brushModel.setAreas(payload.areas);
    });
  });
  registers.registerAction({type: "brushSelect", event: "brushSelected", update: "none"}, noop);
  registers.registerAction({type: "brushEnd", event: "brushEnd", update: "none"}, noop);
  registerFeature("brush", Brush_default);
}

// src/component/title/install.ts
var TitleModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = TitleModel2.type;
    this.layoutMode = {type: "box", ignoreSize: true};
  }
};
var TitleModel = TitleModel2;
TitleModel.type = "title";
TitleModel.defaultOption = {
  z: 6,
  show: true,
  text: "",
  target: "blank",
  subtext: "",
  subtarget: "blank",
  left: "center",
  top: tokens_default.size.m,
  backgroundColor: tokens_default.color.transparent,
  borderColor: tokens_default.color.primary,
  borderWidth: 0,
  padding: 5,
  itemGap: 10,
  textStyle: {
    fontSize: 18,
    fontWeight: "bold",
    color: tokens_default.color.primary
  },
  subtextStyle: {
    fontSize: 12,
    color: tokens_default.color.quaternary
  }
};
var TitleView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = TitleView2.type;
  }
  render(titleModel, ecModel, api2) {
    this.group.removeAll();
    if (!titleModel.get("show")) {
      return;
    }
    const group = this.group;
    const textStyleModel = titleModel.getModel("textStyle");
    const subtextStyleModel = titleModel.getModel("subtextStyle");
    let textAlign = titleModel.get("textAlign");
    let textVerticalAlign = retrieve2(titleModel.get("textBaseline"), titleModel.get("textVerticalAlign"));
    const textEl = new Text_default({
      style: createTextStyle(textStyleModel, {
        text: titleModel.get("text"),
        fill: textStyleModel.getTextColor()
      }, {disableBox: true}),
      z2: 10
    });
    const textRect = textEl.getBoundingRect();
    const subText = titleModel.get("subtext");
    const subTextEl = new Text_default({
      style: createTextStyle(subtextStyleModel, {
        text: subText,
        fill: subtextStyleModel.getTextColor(),
        y: textRect.height + titleModel.get("itemGap"),
        verticalAlign: "top"
      }, {disableBox: true}),
      z2: 10
    });
    const link = titleModel.get("link");
    const sublink = titleModel.get("sublink");
    const triggerEvent = titleModel.get("triggerEvent", true);
    textEl.silent = !link && !triggerEvent;
    subTextEl.silent = !sublink && !triggerEvent;
    if (link) {
      textEl.on("click", function() {
        windowOpen(link, "_" + titleModel.get("target"));
      });
    }
    if (sublink) {
      subTextEl.on("click", function() {
        windowOpen(sublink, "_" + titleModel.get("subtarget"));
      });
    }
    getECData(textEl).eventData = getECData(subTextEl).eventData = triggerEvent ? {
      componentType: "title",
      componentIndex: titleModel.componentIndex
    } : null;
    group.add(textEl);
    subText && group.add(subTextEl);
    let groupRect = group.getBoundingRect();
    const layoutOption = titleModel.getBoxLayoutParams();
    layoutOption.width = groupRect.width;
    layoutOption.height = groupRect.height;
    const layoutRef = createBoxLayoutReference(titleModel, api2);
    const layoutRect = getLayoutRect(layoutOption, layoutRef.refContainer, titleModel.get("padding"));
    if (!textAlign) {
      textAlign = titleModel.get("left") || titleModel.get("right");
      if (textAlign === "middle") {
        textAlign = "center";
      }
      if (textAlign === "right") {
        layoutRect.x += layoutRect.width;
      } else if (textAlign === "center") {
        layoutRect.x += layoutRect.width / 2;
      }
    }
    if (!textVerticalAlign) {
      textVerticalAlign = titleModel.get("top") || titleModel.get("bottom");
      if (textVerticalAlign === "center") {
        textVerticalAlign = "middle";
      }
      if (textVerticalAlign === "bottom") {
        layoutRect.y += layoutRect.height;
      } else if (textVerticalAlign === "middle") {
        layoutRect.y += layoutRect.height / 2;
      }
      textVerticalAlign = textVerticalAlign || "top";
    }
    group.x = layoutRect.x;
    group.y = layoutRect.y;
    group.markRedraw();
    const alignStyle = {
      align: textAlign,
      verticalAlign: textVerticalAlign
    };
    textEl.setStyle(alignStyle);
    subTextEl.setStyle(alignStyle);
    groupRect = group.getBoundingRect();
    const padding = layoutRect.margin;
    const style = titleModel.getItemStyle(["color", "opacity"]);
    style.fill = titleModel.get("backgroundColor");
    const rect = new Rect_default({
      shape: {
        x: groupRect.x - padding[3],
        y: groupRect.y - padding[0],
        width: groupRect.width + padding[1] + padding[3],
        height: groupRect.height + padding[0] + padding[2],
        r: titleModel.get("borderRadius")
      },
      style,
      subPixelOptimize: true,
      silent: true
    });
    group.add(rect);
  }
};
var TitleView = TitleView2;
TitleView.type = "title";
function install41(registers) {
  registers.registerComponentModel(TitleModel);
  registers.registerComponentView(TitleView);
}

// src/component/timeline/TimelineModel.ts
var TimelineModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = TimelineModel2.type;
    this.layoutMode = "box";
  }
  init(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
    this._initData();
  }
  mergeOption(option) {
    super.mergeOption.apply(this, arguments);
    this._initData();
  }
  setCurrentIndex(currentIndex) {
    if (currentIndex == null) {
      currentIndex = this.option.currentIndex;
    }
    const count2 = this._data.count();
    if (this.option.loop) {
      currentIndex = (currentIndex % count2 + count2) % count2;
    } else {
      currentIndex >= count2 && (currentIndex = count2 - 1);
      currentIndex < 0 && (currentIndex = 0);
    }
    this.option.currentIndex = currentIndex;
  }
  getCurrentIndex() {
    return this.option.currentIndex;
  }
  isIndexMax() {
    return this.getCurrentIndex() >= this._data.count() - 1;
  }
  setPlayState(state) {
    this.option.autoPlay = !!state;
  }
  getPlayState() {
    return !!this.option.autoPlay;
  }
  _initData() {
    const thisOption = this.option;
    const dataArr = thisOption.data || [];
    const axisType = thisOption.axisType;
    const names = this._names = [];
    let processedDataArr;
    if (axisType === "category") {
      processedDataArr = [];
      each(dataArr, function(item, index) {
        const value = convertOptionIdName(getDataItemValue(item), "");
        let newItem;
        if (isObject(item)) {
          newItem = clone(item);
          newItem.value = index;
        } else {
          newItem = index;
        }
        processedDataArr.push(newItem);
        names.push(value);
      });
    } else {
      processedDataArr = dataArr;
    }
    const dimType = {
      category: "ordinal",
      time: "time",
      value: "number"
    }[axisType] || "number";
    const data = this._data = new SeriesData_default([{
      name: "value",
      type: dimType
    }], this);
    data.initData(processedDataArr, names);
  }
  getData() {
    return this._data;
  }
  getCategories() {
    if (this.get("axisType") === "category") {
      return this._names.slice();
    }
  }
};
var TimelineModel = TimelineModel2;
TimelineModel.type = "timeline";
TimelineModel.defaultOption = {
  z: 4,
  show: true,
  axisType: "time",
  realtime: true,
  left: "20%",
  top: null,
  right: "20%",
  bottom: 0,
  width: null,
  height: 40,
  padding: tokens_default.size.m,
  controlPosition: "left",
  autoPlay: false,
  rewind: false,
  loop: true,
  playInterval: 2e3,
  currentIndex: 0,
  itemStyle: {},
  label: {
    color: tokens_default.color.secondary
  },
  data: []
};
var TimelineModel_default = TimelineModel;

// src/component/timeline/SliderTimelineModel.ts
var SliderTimelineModel2 = class extends TimelineModel_default {
  constructor() {
    super(...arguments);
    this.type = SliderTimelineModel2.type;
  }
};
var SliderTimelineModel = SliderTimelineModel2;
SliderTimelineModel.type = "timeline.slider";
SliderTimelineModel.defaultOption = inheritDefaultOption(TimelineModel_default.defaultOption, {
  backgroundColor: "rgba(0,0,0,0)",
  borderColor: tokens_default.color.border,
  borderWidth: 0,
  orient: "horizontal",
  inverse: false,
  tooltip: {
    trigger: "item"
  },
  symbol: "circle",
  symbolSize: 12,
  lineStyle: {
    show: true,
    width: 2,
    color: tokens_default.color.accent10
  },
  label: {
    position: "auto",
    show: true,
    interval: "auto",
    rotate: 0,
    color: tokens_default.color.tertiary
  },
  itemStyle: {
    color: tokens_default.color.accent20,
    borderWidth: 0
  },
  checkpointStyle: {
    symbol: "circle",
    symbolSize: 15,
    color: tokens_default.color.accent50,
    borderColor: tokens_default.color.accent50,
    borderWidth: 0,
    shadowBlur: 0,
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    shadowColor: "rgba(0, 0, 0, 0)",
    animation: true,
    animationDuration: 300,
    animationEasing: "quinticInOut"
  },
  controlStyle: {
    show: true,
    showPlayBtn: true,
    showPrevBtn: true,
    showNextBtn: true,
    itemSize: 24,
    itemGap: 12,
    position: "left",
    playIcon: "path://M15 0C23.2843 0 30 6.71573 30 15C30 23.2843 23.2843 30 15 30C6.71573 30 0 23.2843 0 15C0 6.71573 6.71573 0 15 0ZM15 3C8.37258 3 3 8.37258 3 15C3 21.6274 8.37258 27 15 27C21.6274 27 27 21.6274 27 15C27 8.37258 21.6274 3 15 3ZM11.5 10.6699C11.5 9.90014 12.3333 9.41887 13 9.80371L20.5 14.1338C21.1667 14.5187 21.1667 15.4813 20.5 15.8662L13 20.1963C12.3333 20.5811 11.5 20.0999 11.5 19.3301V10.6699Z",
    stopIcon: "path://M15 0C23.2843 0 30 6.71573 30 15C30 23.2843 23.2843 30 15 30C6.71573 30 0 23.2843 0 15C0 6.71573 6.71573 0 15 0ZM15 3C8.37258 3 3 8.37258 3 15C3 21.6274 8.37258 27 15 27C21.6274 27 27 21.6274 27 15C27 8.37258 21.6274 3 15 3ZM11.5 10C12.3284 10 13 10.6716 13 11.5V18.5C13 19.3284 12.3284 20 11.5 20C10.6716 20 10 19.3284 10 18.5V11.5C10 10.6716 10.6716 10 11.5 10ZM18.5 10C19.3284 10 20 10.6716 20 11.5V18.5C20 19.3284 19.3284 20 18.5 20C17.6716 20 17 19.3284 17 18.5V11.5C17 10.6716 17.6716 10 18.5 10Z",
    nextIcon: "path://M0.838834 18.7383C0.253048 18.1525 0.253048 17.2028 0.838834 16.617L7.55635 9.89949L0.838834 3.18198C0.253048 2.59619 0.253048 1.64645 0.838834 1.06066C1.42462 0.474874 2.37437 0.474874 2.96015 1.06066L10.7383 8.83883L10.8412 8.95277C11.2897 9.50267 11.2897 10.2963 10.8412 10.8462L10.7383 10.9602L2.96015 18.7383C2.37437 19.3241 1.42462 19.3241 0.838834 18.7383Z",
    prevIcon: "path://M10.9602 1.06066C11.5459 1.64645 11.5459 2.59619 10.9602 3.18198L4.24264 9.89949L10.9602 16.617C11.5459 17.2028 11.5459 18.1525 10.9602 18.7383C10.3744 19.3241 9.42462 19.3241 8.83883 18.7383L1.06066 10.9602L0.957771 10.8462C0.509245 10.2963 0.509245 9.50267 0.957771 8.95277L1.06066 8.83883L8.83883 1.06066C9.42462 0.474874 10.3744 0.474874 10.9602 1.06066Z",
    prevBtnSize: 18,
    nextBtnSize: 18,
    color: tokens_default.color.accent50,
    borderColor: tokens_default.color.accent50,
    borderWidth: 0
  },
  emphasis: {
    label: {
      show: true,
      color: tokens_default.color.accent60
    },
    itemStyle: {
      color: tokens_default.color.accent60,
      borderColor: tokens_default.color.accent60
    },
    controlStyle: {
      color: tokens_default.color.accent70,
      borderColor: tokens_default.color.accent70
    }
  },
  progress: {
    lineStyle: {
      color: tokens_default.color.accent30
    },
    itemStyle: {
      color: tokens_default.color.accent40
    }
  },
  data: []
});
mixin(SliderTimelineModel, DataFormatMixin.prototype);
var SliderTimelineModel_default = SliderTimelineModel;

// src/component/timeline/TimelineView.ts
var TimelineView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = TimelineView2.type;
  }
};
var TimelineView = TimelineView2;
TimelineView.type = "timeline";
var TimelineView_default = TimelineView;

// src/component/timeline/TimelineAxis.ts
var TimelineAxis = class extends Axis_default {
  constructor(dim, scale4, coordExtent, axisType) {
    super(dim, scale4, coordExtent);
    this.type = axisType || "value";
  }
  getLabelModel() {
    return this.model.getModel("label");
  }
  isHorizontal() {
    return this.model.get("orient") === "horizontal";
  }
};
var TimelineAxis_default = TimelineAxis;

// src/component/timeline/SliderTimelineView.ts
var PI10 = Math.PI;
var labelDataIndexStore = makeInner();
var SliderTimelineView2 = class extends TimelineView_default {
  constructor() {
    super(...arguments);
    this.type = SliderTimelineView2.type;
  }
  init(ecModel, api2) {
    this.api = api2;
  }
  render(timelineModel, ecModel, api2) {
    this.model = timelineModel;
    this.api = api2;
    this.ecModel = ecModel;
    this.group.removeAll();
    if (timelineModel.get("show", true)) {
      const layoutInfo = this._layout(timelineModel, api2);
      const mainGroup = this._createGroup("_mainGroup");
      const labelGroup = this._createGroup("_labelGroup");
      const axis = this._axis = this._createAxis(layoutInfo, timelineModel);
      timelineModel.formatTooltip = function(dataIndex) {
        const name = axis.scale.getLabel({value: dataIndex});
        return createTooltipMarkup("nameValue", {noName: true, value: name});
      };
      each(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(name) {
        this["_render" + name](layoutInfo, mainGroup, axis, timelineModel);
      }, this);
      this._renderAxisLabel(layoutInfo, labelGroup, axis, timelineModel);
      this._position(layoutInfo, timelineModel);
    }
    this._doPlayStop();
    this._updateTicksStatus();
  }
  remove() {
    this._clearTimer();
    this.group.removeAll();
  }
  dispose() {
    this._clearTimer();
  }
  _layout(timelineModel, api2) {
    const labelPosOpt = timelineModel.get(["label", "position"]);
    const orient = timelineModel.get("orient");
    const viewRect2 = getViewRect2(timelineModel, api2);
    let parsedLabelPos;
    if (labelPosOpt == null || labelPosOpt === "auto") {
      parsedLabelPos = orient === "horizontal" ? viewRect2.y + viewRect2.height / 2 < api2.getHeight() / 2 ? "-" : "+" : viewRect2.x + viewRect2.width / 2 < api2.getWidth() / 2 ? "+" : "-";
    } else if (isString(labelPosOpt)) {
      parsedLabelPos = {
        horizontal: {top: "-", bottom: "+"},
        vertical: {left: "-", right: "+"}
      }[orient][labelPosOpt];
    } else {
      parsedLabelPos = labelPosOpt;
    }
    const labelAlignMap = {
      horizontal: "center",
      vertical: parsedLabelPos >= 0 || parsedLabelPos === "+" ? "left" : "right"
    };
    const labelBaselineMap = {
      horizontal: parsedLabelPos >= 0 || parsedLabelPos === "+" ? "top" : "bottom",
      vertical: "middle"
    };
    const rotationMap = {
      horizontal: 0,
      vertical: PI10 / 2
    };
    const mainLength = orient === "vertical" ? viewRect2.height : viewRect2.width;
    const controlModel = timelineModel.getModel("controlStyle");
    const showControl = controlModel.get("show", true);
    const controlSize = showControl ? controlModel.get("itemSize") : 0;
    const controlGap = showControl ? controlModel.get("itemGap") : 0;
    const sizePlusGap = controlSize + controlGap;
    let labelRotation = timelineModel.get(["label", "rotate"]) || 0;
    labelRotation = labelRotation * PI10 / 180;
    let playPosition;
    let prevBtnPosition;
    let nextBtnPosition;
    const controlPosition = controlModel.get("position", true);
    const showPlayBtn = showControl && controlModel.get("showPlayBtn", true);
    const showPrevBtn = showControl && controlModel.get("showPrevBtn", true);
    const showNextBtn = showControl && controlModel.get("showNextBtn", true);
    let xLeft = 0;
    let xRight = mainLength;
    if (controlPosition === "left" || controlPosition === "bottom") {
      showPlayBtn && (playPosition = [0, 0], xLeft += sizePlusGap);
      showPrevBtn && (prevBtnPosition = [xLeft, 0], xLeft += sizePlusGap);
      showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
    } else {
      showPlayBtn && (playPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
      showPrevBtn && (prevBtnPosition = [0, 0], xLeft += sizePlusGap);
      showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
    }
    const axisExtent = [xLeft, xRight];
    if (timelineModel.get("inverse")) {
      axisExtent.reverse();
    }
    return {
      viewRect: viewRect2,
      mainLength,
      orient,
      rotation: rotationMap[orient],
      labelRotation,
      labelPosOpt: parsedLabelPos,
      labelAlign: timelineModel.get(["label", "align"]) || labelAlignMap[orient],
      labelBaseline: timelineModel.get(["label", "verticalAlign"]) || timelineModel.get(["label", "baseline"]) || labelBaselineMap[orient],
      playPosition,
      prevBtnPosition,
      nextBtnPosition,
      axisExtent,
      controlSize,
      controlGap
    };
  }
  _position(layoutInfo, timelineModel) {
    const mainGroup = this._mainGroup;
    const labelGroup = this._labelGroup;
    let viewRect2 = layoutInfo.viewRect;
    if (layoutInfo.orient === "vertical") {
      const m2 = create2();
      const rotateOriginX = viewRect2.x;
      const rotateOriginY = viewRect2.y + viewRect2.height;
      translate(m2, m2, [-rotateOriginX, -rotateOriginY]);
      rotate(m2, m2, -PI10 / 2);
      translate(m2, m2, [rotateOriginX, rotateOriginY]);
      viewRect2 = viewRect2.clone();
      viewRect2.applyTransform(m2);
    }
    const viewBound = getBound(viewRect2);
    const mainBound = getBound(mainGroup.getBoundingRect());
    const labelBound = getBound(labelGroup.getBoundingRect());
    const mainPosition = [mainGroup.x, mainGroup.y];
    const labelsPosition = [labelGroup.x, labelGroup.y];
    labelsPosition[0] = mainPosition[0] = viewBound[0][0];
    const labelPosOpt = layoutInfo.labelPosOpt;
    if (labelPosOpt == null || isString(labelPosOpt)) {
      const mainBoundIdx = labelPosOpt === "+" ? 0 : 1;
      toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
      toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx);
    } else {
      const mainBoundIdx = labelPosOpt >= 0 ? 0 : 1;
      toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
      labelsPosition[1] = mainPosition[1] + labelPosOpt;
    }
    mainGroup.setPosition(mainPosition);
    labelGroup.setPosition(labelsPosition);
    mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation;
    setOrigin(mainGroup);
    setOrigin(labelGroup);
    function setOrigin(targetGroup) {
      targetGroup.originX = viewBound[0][0] - targetGroup.x;
      targetGroup.originY = viewBound[1][0] - targetGroup.y;
    }
    function getBound(rect) {
      return [
        [rect.x, rect.x + rect.width],
        [rect.y, rect.y + rect.height]
      ];
    }
    function toBound(fromPos, from, to, dimIdx, boundIdx) {
      fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx];
    }
  }
  _createAxis(layoutInfo, timelineModel) {
    const data = timelineModel.getData();
    const axisType = timelineModel.get("axisType");
    const scale4 = createScaleByModel2(timelineModel, axisType);
    scale4.getTicks = function() {
      return data.mapArray(["value"], function(value) {
        return {value};
      });
    };
    const dataExtent = data.getDataExtent("value");
    scale4.setExtent(dataExtent[0], dataExtent[1]);
    scale4.calcNiceTicks();
    const axis = new TimelineAxis_default("value", scale4, layoutInfo.axisExtent, axisType);
    axis.model = timelineModel;
    return axis;
  }
  _createGroup(key) {
    const newGroup = this[key] = new Group_default();
    this.group.add(newGroup);
    return newGroup;
  }
  _renderAxisLine(layoutInfo, group, axis, timelineModel) {
    const axisExtent = axis.getExtent();
    if (!timelineModel.get(["lineStyle", "show"])) {
      return;
    }
    const line2 = new Line_default({
      shape: {
        x1: axisExtent[0],
        y1: 0,
        x2: axisExtent[1],
        y2: 0
      },
      style: extend({lineCap: "round"}, timelineModel.getModel("lineStyle").getLineStyle()),
      silent: true,
      z2: 1
    });
    group.add(line2);
    const progressLine = this._progressLine = new Line_default({
      shape: {
        x1: axisExtent[0],
        x2: this._currentPointer ? this._currentPointer.x : axisExtent[0],
        y1: 0,
        y2: 0
      },
      style: defaults({lineCap: "round", lineWidth: line2.style.lineWidth}, timelineModel.getModel(["progress", "lineStyle"]).getLineStyle()),
      silent: true,
      z2: 1
    });
    group.add(progressLine);
  }
  _renderAxisTick(layoutInfo, group, axis, timelineModel) {
    const data = timelineModel.getData();
    const ticks = axis.scale.getTicks();
    this._tickSymbols = [];
    each(ticks, (tick) => {
      const tickCoord = axis.dataToCoord(tick.value);
      const itemModel = data.getItemModel(tick.value);
      const itemStyleModel = itemModel.getModel("itemStyle");
      const hoverStyleModel = itemModel.getModel(["emphasis", "itemStyle"]);
      const progressStyleModel = itemModel.getModel(["progress", "itemStyle"]);
      const symbolOpt = {
        x: tickCoord,
        y: 0,
        onclick: bind(this._changeTimeline, this, tick.value)
      };
      const el = giveSymbol(itemModel, itemStyleModel, group, symbolOpt);
      el.ensureState("emphasis").style = hoverStyleModel.getItemStyle();
      el.ensureState("progress").style = progressStyleModel.getItemStyle();
      enableHoverEmphasis(el);
      const ecData = getECData(el);
      if (itemModel.get("tooltip")) {
        ecData.dataIndex = tick.value;
        ecData.dataModel = timelineModel;
      } else {
        ecData.dataIndex = ecData.dataModel = null;
      }
      this._tickSymbols.push(el);
    });
  }
  _renderAxisLabel(layoutInfo, group, axis, timelineModel) {
    const labelModel = axis.getLabelModel();
    if (!labelModel.get("show")) {
      return;
    }
    const data = timelineModel.getData();
    const labels = axis.getViewLabels();
    this._tickLabels = [];
    each(labels, (labelItem) => {
      const dataIndex = labelItem.tickValue;
      const itemModel = data.getItemModel(dataIndex);
      const normalLabelModel = itemModel.getModel("label");
      const hoverLabelModel = itemModel.getModel(["emphasis", "label"]);
      const progressLabelModel = itemModel.getModel(["progress", "label"]);
      const tickCoord = axis.dataToCoord(labelItem.tickValue);
      const textEl = new Text_default({
        x: tickCoord,
        y: 0,
        rotation: layoutInfo.labelRotation - layoutInfo.rotation,
        onclick: bind(this._changeTimeline, this, dataIndex),
        silent: false,
        style: createTextStyle(normalLabelModel, {
          text: labelItem.formattedLabel,
          align: layoutInfo.labelAlign,
          verticalAlign: layoutInfo.labelBaseline
        })
      });
      textEl.ensureState("emphasis").style = createTextStyle(hoverLabelModel);
      textEl.ensureState("progress").style = createTextStyle(progressLabelModel);
      group.add(textEl);
      enableHoverEmphasis(textEl);
      labelDataIndexStore(textEl).dataIndex = dataIndex;
      this._tickLabels.push(textEl);
    });
  }
  _renderControl(layoutInfo, group, axis, timelineModel) {
    const controlSize = layoutInfo.controlSize;
    const rotation = layoutInfo.rotation;
    const itemStyle = timelineModel.getModel("controlStyle").getItemStyle();
    const hoverStyle = timelineModel.getModel(["emphasis", "controlStyle"]).getItemStyle();
    const playState = timelineModel.getPlayState();
    const inverse = timelineModel.get("inverse", true);
    makeBtn(layoutInfo.nextBtnPosition, "next", bind(this._changeTimeline, this, inverse ? "-" : "+"));
    makeBtn(layoutInfo.prevBtnPosition, "prev", bind(this._changeTimeline, this, inverse ? "+" : "-"));
    makeBtn(layoutInfo.playPosition, playState ? "stop" : "play", bind(this._handlePlayClick, this, !playState), true);
    function makeBtn(position2, iconName, onclick, willRotate) {
      if (!position2) {
        return;
      }
      const iconSize = parsePercent(retrieve2(timelineModel.get(["controlStyle", iconName + "BtnSize"]), controlSize), controlSize);
      const rect = [0, -iconSize / 2, iconSize, iconSize];
      const btn = makeControlIcon(timelineModel, iconName + "Icon", rect, {
        x: position2[0],
        y: position2[1],
        originX: controlSize / 2,
        originY: 0,
        rotation: willRotate ? -rotation : 0,
        rectHover: true,
        style: itemStyle,
        onclick
      });
      btn.ensureState("emphasis").style = hoverStyle;
      group.add(btn);
      enableHoverEmphasis(btn);
    }
  }
  _renderCurrentPointer(layoutInfo, group, axis, timelineModel) {
    const data = timelineModel.getData();
    const currentIndex = timelineModel.getCurrentIndex();
    const pointerModel = data.getItemModel(currentIndex).getModel("checkpointStyle");
    const me = this;
    const callback = {
      onCreate(pointer) {
        pointer.draggable = true;
        pointer.drift = bind(me._handlePointerDrag, me);
        pointer.ondragend = bind(me._handlePointerDragend, me);
        pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel, true);
      },
      onUpdate(pointer) {
        pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel);
      }
    };
    this._currentPointer = giveSymbol(pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, callback);
  }
  _handlePlayClick(nextState) {
    this._clearTimer();
    this.api.dispatchAction({
      type: "timelinePlayChange",
      playState: nextState,
      from: this.uid
    });
  }
  _handlePointerDrag(dx, dy, e2) {
    this._clearTimer();
    this._pointerChangeTimeline([e2.offsetX, e2.offsetY]);
  }
  _handlePointerDragend(e2) {
    this._pointerChangeTimeline([e2.offsetX, e2.offsetY], true);
  }
  _pointerChangeTimeline(mousePos, trigger3) {
    let toCoord = this._toAxisCoord(mousePos)[0];
    const axis = this._axis;
    const axisExtent = asc(axis.getExtent().slice());
    toCoord > axisExtent[1] && (toCoord = axisExtent[1]);
    toCoord < axisExtent[0] && (toCoord = axisExtent[0]);
    this._currentPointer.x = toCoord;
    this._currentPointer.markRedraw();
    const progressLine = this._progressLine;
    if (progressLine) {
      progressLine.shape.x2 = toCoord;
      progressLine.dirty();
    }
    const targetDataIndex = this._findNearestTick(toCoord);
    const timelineModel = this.model;
    if (trigger3 || targetDataIndex !== timelineModel.getCurrentIndex() && timelineModel.get("realtime")) {
      this._changeTimeline(targetDataIndex);
    }
  }
  _doPlayStop() {
    this._clearTimer();
    if (this.model.getPlayState()) {
      this._timer = setTimeout(() => {
        const timelineModel = this.model;
        this._changeTimeline(timelineModel.getCurrentIndex() + (timelineModel.get("rewind", true) ? -1 : 1));
      }, this.model.get("playInterval"));
    }
  }
  _toAxisCoord(vertex) {
    const trans = this._mainGroup.getLocalTransform();
    return applyTransform2(vertex, trans, true);
  }
  _findNearestTick(axisCoord) {
    const data = this.model.getData();
    let dist3 = Infinity;
    let targetDataIndex;
    const axis = this._axis;
    data.each(["value"], function(value, dataIndex) {
      const coord = axis.dataToCoord(value);
      const d = Math.abs(coord - axisCoord);
      if (d < dist3) {
        dist3 = d;
        targetDataIndex = dataIndex;
      }
    });
    return targetDataIndex;
  }
  _clearTimer() {
    if (this._timer) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  }
  _changeTimeline(nextIndex) {
    const currentIndex = this.model.getCurrentIndex();
    if (nextIndex === "+") {
      nextIndex = currentIndex + 1;
    } else if (nextIndex === "-") {
      nextIndex = currentIndex - 1;
    }
    this.api.dispatchAction({
      type: "timelineChange",
      currentIndex: nextIndex,
      from: this.uid
    });
  }
  _updateTicksStatus() {
    const currentIndex = this.model.getCurrentIndex();
    const tickSymbols = this._tickSymbols;
    const tickLabels = this._tickLabels;
    if (tickSymbols) {
      for (let i = 0; i < tickSymbols.length; i++) {
        tickSymbols && tickSymbols[i] && tickSymbols[i].toggleState("progress", i < currentIndex);
      }
    }
    if (tickLabels) {
      for (let i = 0; i < tickLabels.length; i++) {
        tickLabels && tickLabels[i] && tickLabels[i].toggleState("progress", labelDataIndexStore(tickLabels[i]).dataIndex <= currentIndex);
      }
    }
  }
};
var SliderTimelineView = SliderTimelineView2;
SliderTimelineView.type = "timeline.slider";
function createScaleByModel2(model, axisType) {
  axisType = axisType || model.get("type");
  if (axisType) {
    switch (axisType) {
      case "category":
        return new Ordinal_default({
          ordinalMeta: model.getCategories(),
          extent: [Infinity, -Infinity]
        });
      case "time":
        return new Time_default({
          locale: model.ecModel.getLocaleModel(),
          useUTC: model.ecModel.get("useUTC")
        });
      default:
        return new Interval_default();
    }
  }
}
function getViewRect2(model, api2) {
  return getLayoutRect(model.getBoxLayoutParams(), createBoxLayoutReference(model, api2).refContainer, model.get("padding"));
}
function makeControlIcon(timelineModel, objPath, rect, opts) {
  const style = opts.style;
  const icon = createIcon(timelineModel.get(["controlStyle", objPath]), opts || {}, new BoundingRect_default(rect[0], rect[1], rect[2], rect[3]));
  if (style) {
    icon.setStyle(style);
  }
  return icon;
}
function giveSymbol(hostModel, itemStyleModel, group, opt, symbol, callback) {
  const color4 = itemStyleModel.get("color");
  if (!symbol) {
    const symbolType = hostModel.get("symbol");
    symbol = createSymbol(symbolType, -1, -1, 2, 2, color4);
    symbol.setStyle("strokeNoScale", true);
    group.add(symbol);
    callback && callback.onCreate(symbol);
  } else {
    symbol.setColor(color4);
    group.add(symbol);
    callback && callback.onUpdate(symbol);
  }
  const itemStyle = itemStyleModel.getItemStyle(["color"]);
  symbol.setStyle(itemStyle);
  opt = merge({
    rectHover: true,
    z2: 100
  }, opt, true);
  const symbolSize = normalizeSymbolSize(hostModel.get("symbolSize"));
  opt.scaleX = symbolSize[0] / 2;
  opt.scaleY = symbolSize[1] / 2;
  const symbolOffset = normalizeSymbolOffset(hostModel.get("symbolOffset"), symbolSize);
  if (symbolOffset) {
    opt.x = (opt.x || 0) + symbolOffset[0];
    opt.y = (opt.y || 0) + symbolOffset[1];
  }
  const symbolRotate = hostModel.get("symbolRotate");
  opt.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
  symbol.attr(opt);
  symbol.updateTransform();
  return symbol;
}
function pointerMoveTo(pointer, progressLine, dataIndex, axis, timelineModel, noAnimation) {
  if (pointer.dragging) {
    return;
  }
  const pointerModel = timelineModel.getModel("checkpointStyle");
  const toCoord = axis.dataToCoord(timelineModel.getData().get("value", dataIndex));
  if (noAnimation || !pointerModel.get("animation", true)) {
    pointer.attr({
      x: toCoord,
      y: 0
    });
    progressLine && progressLine.attr({
      shape: {x2: toCoord}
    });
  } else {
    const animationCfg = {
      duration: pointerModel.get("animationDuration", true),
      easing: pointerModel.get("animationEasing", true)
    };
    pointer.stopAnimation(null, true);
    pointer.animateTo({
      x: toCoord,
      y: 0
    }, animationCfg);
    progressLine && progressLine.animateTo({
      shape: {x2: toCoord}
    }, animationCfg);
  }
}
var SliderTimelineView_default = SliderTimelineView;

// src/component/timeline/timelineAction.ts
function installTimelineAction(registers) {
  registers.registerAction({type: "timelineChange", event: "timelineChanged", update: "prepareAndUpdate"}, function(payload, ecModel, api2) {
    const timelineModel = ecModel.getComponent("timeline");
    if (timelineModel && payload.currentIndex != null) {
      timelineModel.setCurrentIndex(payload.currentIndex);
      if (!timelineModel.get("loop", true) && timelineModel.isIndexMax() && timelineModel.getPlayState()) {
        timelineModel.setPlayState(false);
        api2.dispatchAction({
          type: "timelinePlayChange",
          playState: false,
          from: payload.from
        });
      }
    }
    ecModel.resetOption("timeline", {replaceMerge: timelineModel.get("replaceMerge", true)});
    return defaults({
      currentIndex: timelineModel.option.currentIndex
    }, payload);
  });
  registers.registerAction({type: "timelinePlayChange", event: "timelinePlayChanged", update: "update"}, function(payload, ecModel) {
    const timelineModel = ecModel.getComponent("timeline");
    if (timelineModel && payload.playState != null) {
      timelineModel.setPlayState(payload.playState);
    }
  });
}

// src/component/timeline/preprocessor.ts
function timelinePreprocessor(option) {
  let timelineOpt = option && option.timeline;
  if (!isArray(timelineOpt)) {
    timelineOpt = timelineOpt ? [timelineOpt] : [];
  }
  each(timelineOpt, function(opt) {
    if (!opt) {
      return;
    }
    compatibleEC2(opt);
  });
}
function compatibleEC2(opt) {
  const type = opt.type;
  const ec2Types = {number: "value", time: "time"};
  if (ec2Types[type]) {
    opt.axisType = ec2Types[type];
    delete opt.type;
  }
  transferItem(opt);
  if (has(opt, "controlPosition")) {
    const controlStyle = opt.controlStyle || (opt.controlStyle = {});
    if (!has(controlStyle, "position")) {
      controlStyle.position = opt.controlPosition;
    }
    if (controlStyle.position === "none" && !has(controlStyle, "show")) {
      controlStyle.show = false;
      delete controlStyle.position;
    }
    delete opt.controlPosition;
  }
  each(opt.data || [], function(dataItem) {
    if (isObject(dataItem) && !isArray(dataItem)) {
      if (!has(dataItem, "value") && has(dataItem, "name")) {
        dataItem.value = dataItem.name;
      }
      transferItem(dataItem);
    }
  });
}
function transferItem(opt) {
  const itemStyle = opt.itemStyle || (opt.itemStyle = {});
  const itemStyleEmphasis = itemStyle.emphasis || (itemStyle.emphasis = {});
  const label = opt.label || (opt.label || {});
  const labelNormal = label.normal || (label.normal = {});
  const excludeLabelAttr = {normal: 1, emphasis: 1};
  each(label, function(value, name) {
    if (!excludeLabelAttr[name] && !has(labelNormal, name)) {
      labelNormal[name] = value;
    }
  });
  if (itemStyleEmphasis.label && !has(label, "emphasis")) {
    label.emphasis = itemStyleEmphasis.label;
    delete itemStyleEmphasis.label;
  }
}
function has(obj, attr) {
  return obj.hasOwnProperty(attr);
}

// src/component/timeline/install.ts
function install42(registers) {
  registers.registerComponentModel(SliderTimelineModel_default);
  registers.registerComponentView(SliderTimelineView_default);
  registers.registerSubTypeDefaulter("timeline", function() {
    return "slider";
  });
  installTimelineAction(registers);
  registers.registerPreprocessor(timelinePreprocessor);
}

// src/component/marker/checkMarkerInSeries.ts
function checkMarkerInSeries(seriesOpts, markerType) {
  if (!seriesOpts) {
    return false;
  }
  const seriesOptArr = isArray(seriesOpts) ? seriesOpts : [seriesOpts];
  for (let idx = 0; idx < seriesOptArr.length; idx++) {
    if (seriesOptArr[idx] && seriesOptArr[idx][markerType]) {
      return true;
    }
  }
  return false;
}

// src/component/marker/MarkerModel.ts
function fillLabel(opt) {
  defaultEmphasis(opt, "label", ["show"]);
}
var inner19 = makeInner();
var MarkerModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = MarkerModel2.type;
    this.createdBySelf = false;
  }
  init(option, parentModel, ecModel) {
    if (true) {
      if (this.type === "marker") {
        throw new Error("Marker component is abstract component. Use markLine, markPoint, markArea instead.");
      }
    }
    this.mergeDefaultAndTheme(option, ecModel);
    this._mergeOption(option, ecModel, false, true);
  }
  isAnimationEnabled() {
    if (env_default.node) {
      return false;
    }
    const hostSeries = this.__hostSeries;
    return this.getShallow("animation") && hostSeries && hostSeries.isAnimationEnabled();
  }
  mergeOption(newOpt, ecModel) {
    this._mergeOption(newOpt, ecModel, false, false);
  }
  _mergeOption(newOpt, ecModel, createdBySelf, isInit) {
    const componentType = this.mainType;
    if (!createdBySelf) {
      ecModel.eachSeries(function(seriesModel) {
        const markerOpt = seriesModel.get(this.mainType, true);
        let markerModel = inner19(seriesModel)[componentType];
        if (!markerOpt || !markerOpt.data) {
          inner19(seriesModel)[componentType] = null;
          return;
        }
        if (!markerModel) {
          if (isInit) {
            fillLabel(markerOpt);
          }
          each(markerOpt.data, function(item) {
            if (item instanceof Array) {
              fillLabel(item[0]);
              fillLabel(item[1]);
            } else {
              fillLabel(item);
            }
          });
          markerModel = this.createMarkerModelFromSeries(markerOpt, this, ecModel);
          extend(markerModel, {
            mainType: this.mainType,
            seriesIndex: seriesModel.seriesIndex,
            name: seriesModel.name,
            createdBySelf: true
          });
          markerModel.__hostSeries = seriesModel;
        } else {
          markerModel._mergeOption(markerOpt, ecModel, true);
        }
        inner19(seriesModel)[componentType] = markerModel;
      }, this);
    }
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    const data = this.getData();
    const value = this.getRawValue(dataIndex);
    const itemName = data.getName(dataIndex);
    return createTooltipMarkup("section", {
      header: this.name,
      blocks: [createTooltipMarkup("nameValue", {
        name: itemName,
        value,
        noName: !itemName,
        noValue: value == null
      })]
    });
  }
  getData() {
    return this._data;
  }
  setData(data) {
    this._data = data;
  }
  getDataParams(dataIndex, dataType) {
    const params = DataFormatMixin.prototype.getDataParams.call(this, dataIndex, dataType);
    const hostSeries = this.__hostSeries;
    if (hostSeries) {
      params.seriesId = hostSeries.id;
      params.seriesName = hostSeries.name;
      params.seriesType = hostSeries.subType;
    }
    return params;
  }
  static getMarkerModelFromSeries(seriesModel, componentType) {
    return inner19(seriesModel)[componentType];
  }
};
var MarkerModel = MarkerModel2;
MarkerModel.type = "marker";
MarkerModel.dependencies = ["series", "grid", "polar", "geo"];
mixin(MarkerModel, DataFormatMixin.prototype);
var MarkerModel_default = MarkerModel;

// src/component/marker/MarkPointModel.ts
var MarkPointModel2 = class extends MarkerModel_default {
  constructor() {
    super(...arguments);
    this.type = MarkPointModel2.type;
  }
  createMarkerModelFromSeries(markerOpt, masterMarkerModel, ecModel) {
    return new MarkPointModel2(markerOpt, masterMarkerModel, ecModel);
  }
};
var MarkPointModel = MarkPointModel2;
MarkPointModel.type = "markPoint";
MarkPointModel.defaultOption = {
  z: 5,
  symbol: "pin",
  symbolSize: 50,
  tooltip: {
    trigger: "item"
  },
  label: {
    show: true,
    position: "inside"
  },
  itemStyle: {
    borderWidth: 2
  },
  emphasis: {
    label: {
      show: true
    }
  }
};
var MarkPointModel_default = MarkPointModel;

// src/component/marker/markerHelper.ts
function hasXOrY(item) {
  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));
}
function hasXAndY(item) {
  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));
}
function markerTypeCalculatorWithExtent(markerType, data, axisDim, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {
  const coordArr = [];
  const stacked = isDimensionStacked(data, targetDataDim);
  const calcDataDim = stacked ? data.getCalculationInfo("stackResultDimension") : targetDataDim;
  const value = numCalculate(data, calcDataDim, markerType);
  const seriesModel = data.hostModel;
  const dataIndex = seriesModel.indicesOfNearest(axisDim, calcDataDim, value)[0];
  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);
  coordArr[targetCoordIndex] = data.get(calcDataDim, dataIndex);
  const coordArrValue = data.get(targetDataDim, dataIndex);
  let precision = getPrecision(data.get(targetDataDim, dataIndex));
  precision = Math.min(precision, 20);
  if (precision >= 0) {
    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);
  }
  return [coordArr, coordArrValue];
}
var markerTypeCalculator = {
  min: curry(markerTypeCalculatorWithExtent, "min"),
  max: curry(markerTypeCalculatorWithExtent, "max"),
  average: curry(markerTypeCalculatorWithExtent, "average"),
  median: curry(markerTypeCalculatorWithExtent, "median")
};
function dataTransform(seriesModel, item) {
  if (!item) {
    return;
  }
  const data = seriesModel.getData();
  const coordSys = seriesModel.coordinateSystem;
  const dims = coordSys && coordSys.dimensions;
  if (!hasXAndY(item) && !isArray(item.coord) && isArray(dims)) {
    const axisInfo = getAxisInfo2(item, data, coordSys, seriesModel);
    item = clone(item);
    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {
      const otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);
      const targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);
      const coordInfo = markerTypeCalculator[item.type](data, axisInfo.valueAxis.dim, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex);
      item.coord = coordInfo[0];
      item.value = coordInfo[1];
    } else {
      item.coord = [
        item.xAxis != null ? item.xAxis : item.radiusAxis,
        item.yAxis != null ? item.yAxis : item.angleAxis
      ];
    }
  }
  if (item.coord == null || !isArray(dims)) {
    item.coord = [];
    const baseAxis = seriesModel.getBaseAxis();
    if (baseAxis && item.type && markerTypeCalculator[item.type]) {
      const otherAxis = coordSys.getOtherAxis(baseAxis);
      if (otherAxis) {
        item.value = numCalculate(data, data.mapDimension(otherAxis.dim), item.type);
      }
    }
  } else {
    const coord = item.coord;
    for (let i = 0; i < 2; i++) {
      if (markerTypeCalculator[coord[i]]) {
        coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);
      }
    }
  }
  return item;
}
function getAxisInfo2(item, data, coordSys, seriesModel) {
  const ret = {};
  if (item.valueIndex != null || item.valueDim != null) {
    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;
    ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));
    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);
    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
  } else {
    ret.baseAxis = seriesModel.getBaseAxis();
    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);
    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
    ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);
  }
  return ret;
}
function dataDimToCoordDim(seriesModel, dataDim) {
  const dimItem = seriesModel.getData().getDimensionInfo(dataDim);
  return dimItem && dimItem.coordDim;
}
function dataFilter2(coordSys, item) {
  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;
}
function zoneFilter(coordSys, item1, item2) {
  return coordSys && coordSys.containZone && item1.coord && item2.coord && !hasXOrY(item1) && !hasXOrY(item2) ? coordSys.containZone(item1.coord, item2.coord) : true;
}
function createMarkerDimValueGetter(inCoordSys, dims) {
  return inCoordSys ? function(item, dimName, dataIndex, dimIndex) {
    const rawVal = dimIndex < 2 ? item.coord && item.coord[dimIndex] : item.value;
    return parseDataValue(rawVal, dims[dimIndex]);
  } : function(item, dimName, dataIndex, dimIndex) {
    return parseDataValue(item.value, dims[dimIndex]);
  };
}
function numCalculate(data, valueDataDim, type) {
  if (type === "average") {
    let sum2 = 0;
    let count2 = 0;
    data.each(valueDataDim, function(val, idx) {
      if (!isNaN(val)) {
        sum2 += val;
        count2++;
      }
    });
    return sum2 / count2;
  } else if (type === "median") {
    return data.getMedian(valueDataDim);
  } else {
    return data.getDataExtent(valueDataDim)[type === "max" ? 1 : 0];
  }
}

// src/component/marker/MarkerView.ts
var inner20 = makeInner();
var MarkerView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = MarkerView2.type;
  }
  init() {
    this.markerGroupMap = createHashMap();
  }
  render(markerModel, ecModel, api2) {
    const markerGroupMap = this.markerGroupMap;
    markerGroupMap.each(function(item) {
      inner20(item).keep = false;
    });
    ecModel.eachSeries((seriesModel) => {
      const markerModel2 = MarkerModel_default.getMarkerModelFromSeries(seriesModel, this.type);
      markerModel2 && this.renderSeries(seriesModel, markerModel2, ecModel, api2);
    });
    markerGroupMap.each((item) => {
      !inner20(item).keep && this.group.remove(item.group);
    });
  }
  markKeep(drawGroup) {
    inner20(drawGroup).keep = true;
  }
  toggleBlurSeries(seriesModelList, isBlur) {
    each(seriesModelList, (seriesModel) => {
      const markerModel = MarkerModel_default.getMarkerModelFromSeries(seriesModel, this.type);
      if (markerModel) {
        const data = markerModel.getData();
        data.eachItemGraphicEl(function(el) {
          if (el) {
            isBlur ? enterBlur(el) : leaveBlur(el);
          }
        });
      }
    });
  }
};
var MarkerView = MarkerView2;
MarkerView.type = "marker";
var MarkerView_default = MarkerView;

// src/component/marker/MarkPointView.ts
function updateMarkerLayout(mpData, seriesModel, api2) {
  const coordSys = seriesModel.coordinateSystem;
  const apiWidth = api2.getWidth();
  const apiHeight = api2.getHeight();
  const coordRect = coordSys && coordSys.getArea && coordSys.getArea();
  mpData.each(function(idx) {
    const itemModel = mpData.getItemModel(idx);
    const isRelativeToCoordinate = itemModel.get("relativeTo") === "coordinate";
    const width = isRelativeToCoordinate ? coordRect ? coordRect.width : 0 : apiWidth;
    const height = isRelativeToCoordinate ? coordRect ? coordRect.height : 0 : apiHeight;
    const left = isRelativeToCoordinate && coordRect ? coordRect.x : 0;
    const top = isRelativeToCoordinate && coordRect ? coordRect.y : 0;
    let point;
    const xPx = parsePercent2(itemModel.get("x"), width) + left;
    const yPx = parsePercent2(itemModel.get("y"), height) + top;
    if (!isNaN(xPx) && !isNaN(yPx)) {
      point = [xPx, yPx];
    } else if (seriesModel.getMarkerPosition) {
      point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));
    } else if (coordSys) {
      const x = mpData.get(coordSys.dimensions[0], idx);
      const y = mpData.get(coordSys.dimensions[1], idx);
      point = coordSys.dataToPoint([x, y]);
    }
    if (!isNaN(xPx)) {
      point[0] = xPx;
    }
    if (!isNaN(yPx)) {
      point[1] = yPx;
    }
    mpData.setItemLayout(idx, point);
  });
}
var MarkPointView2 = class extends MarkerView_default {
  constructor() {
    super(...arguments);
    this.type = MarkPointView2.type;
  }
  updateTransform(markPointModel, ecModel, api2) {
    ecModel.eachSeries(function(seriesModel) {
      const mpModel = MarkerModel_default.getMarkerModelFromSeries(seriesModel, "markPoint");
      if (mpModel) {
        updateMarkerLayout(mpModel.getData(), seriesModel, api2);
        this.markerGroupMap.get(seriesModel.id).updateLayout();
      }
    }, this);
  }
  renderSeries(seriesModel, mpModel, ecModel, api2) {
    const coordSys = seriesModel.coordinateSystem;
    const seriesId = seriesModel.id;
    const seriesData = seriesModel.getData();
    const symbolDrawMap = this.markerGroupMap;
    const symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw_default());
    const mpData = createData(coordSys, seriesModel, mpModel);
    mpModel.setData(mpData);
    updateMarkerLayout(mpModel.getData(), seriesModel, api2);
    mpData.each(function(idx) {
      const itemModel = mpData.getItemModel(idx);
      let symbol = itemModel.getShallow("symbol");
      let symbolSize = itemModel.getShallow("symbolSize");
      let symbolRotate = itemModel.getShallow("symbolRotate");
      let symbolOffset = itemModel.getShallow("symbolOffset");
      const symbolKeepAspect = itemModel.getShallow("symbolKeepAspect");
      if (isFunction(symbol) || isFunction(symbolSize) || isFunction(symbolRotate) || isFunction(symbolOffset)) {
        const rawIdx = mpModel.getRawValue(idx);
        const dataParams = mpModel.getDataParams(idx);
        if (isFunction(symbol)) {
          symbol = symbol(rawIdx, dataParams);
        }
        if (isFunction(symbolSize)) {
          symbolSize = symbolSize(rawIdx, dataParams);
        }
        if (isFunction(symbolRotate)) {
          symbolRotate = symbolRotate(rawIdx, dataParams);
        }
        if (isFunction(symbolOffset)) {
          symbolOffset = symbolOffset(rawIdx, dataParams);
        }
      }
      const style = itemModel.getModel("itemStyle").getItemStyle();
      const z2 = itemModel.get("z2");
      const color4 = getVisualFromData(seriesData, "color");
      if (!style.fill) {
        style.fill = color4;
      }
      mpData.setItemVisual(idx, {
        z2: retrieve2(z2, 0),
        symbol,
        symbolSize,
        symbolRotate,
        symbolOffset,
        symbolKeepAspect,
        style
      });
    });
    symbolDraw.updateData(mpData);
    this.group.add(symbolDraw.group);
    mpData.eachItemGraphicEl(function(el) {
      el.traverse(function(child) {
        getECData(child).dataModel = mpModel;
      });
    });
    this.markKeep(symbolDraw);
    symbolDraw.group.silent = mpModel.get("silent") || seriesModel.get("silent");
  }
};
var MarkPointView = MarkPointView2;
MarkPointView.type = "markPoint";
function createData(coordSys, seriesModel, mpModel) {
  let coordDimsInfos;
  if (coordSys) {
    coordDimsInfos = map(coordSys && coordSys.dimensions, function(coordDim) {
      const info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};
      return extend(extend({}, info), {
        name: coordDim,
        ordinalMeta: null
      });
    });
  } else {
    coordDimsInfos = [{
      name: "value",
      type: "float"
    }];
  }
  const mpData = new SeriesData_default(coordDimsInfos, mpModel);
  let dataOpt = map(mpModel.get("data"), curry(dataTransform, seriesModel));
  if (coordSys) {
    dataOpt = filter(dataOpt, curry(dataFilter2, coordSys));
  }
  const dimValueGetter = createMarkerDimValueGetter(!!coordSys, coordDimsInfos);
  mpData.initData(dataOpt, null, dimValueGetter);
  return mpData;
}
var MarkPointView_default = MarkPointView;

// src/component/marker/installMarkPoint.ts
function install43(registers) {
  registers.registerComponentModel(MarkPointModel_default);
  registers.registerComponentView(MarkPointView_default);
  registers.registerPreprocessor(function(opt) {
    if (checkMarkerInSeries(opt.series, "markPoint")) {
      opt.markPoint = opt.markPoint || {};
    }
  });
}

// src/component/marker/MarkLineModel.ts
var MarkLineModel2 = class extends MarkerModel_default {
  constructor() {
    super(...arguments);
    this.type = MarkLineModel2.type;
  }
  createMarkerModelFromSeries(markerOpt, masterMarkerModel, ecModel) {
    return new MarkLineModel2(markerOpt, masterMarkerModel, ecModel);
  }
};
var MarkLineModel = MarkLineModel2;
MarkLineModel.type = "markLine";
MarkLineModel.defaultOption = {
  z: 5,
  symbol: ["circle", "arrow"],
  symbolSize: [8, 16],
  symbolOffset: 0,
  precision: 2,
  tooltip: {
    trigger: "item"
  },
  label: {
    show: true,
    position: "end",
    distance: 5
  },
  lineStyle: {
    type: "dashed"
  },
  emphasis: {
    label: {
      show: true
    },
    lineStyle: {
      width: 3
    }
  },
  animationEasing: "linear"
};
var MarkLineModel_default = MarkLineModel;

// src/component/marker/MarkLineView.ts
var inner21 = makeInner();
var markLineTransform = function(seriesModel, coordSys, mlModel, item) {
  const data = seriesModel.getData();
  let itemArray;
  if (!isArray(item)) {
    const mlType = item.type;
    if (mlType === "min" || mlType === "max" || mlType === "average" || mlType === "median" || (item.xAxis != null || item.yAxis != null)) {
      let valueAxis2;
      let value;
      if (item.yAxis != null || item.xAxis != null) {
        valueAxis2 = coordSys.getAxis(item.yAxis != null ? "y" : "x");
        value = retrieve(item.yAxis, item.xAxis);
      } else {
        const axisInfo = getAxisInfo2(item, data, coordSys, seriesModel);
        valueAxis2 = axisInfo.valueAxis;
        const valueDataDim = getStackedDimension(data, axisInfo.valueDataDim);
        value = numCalculate(data, valueDataDim, mlType);
      }
      const valueIndex = valueAxis2.dim === "x" ? 0 : 1;
      const baseIndex = 1 - valueIndex;
      const mlFrom = clone(item);
      const mlTo = {
        coord: []
      };
      mlFrom.type = null;
      mlFrom.coord = [];
      mlFrom.coord[baseIndex] = -Infinity;
      mlTo.coord[baseIndex] = Infinity;
      const precision = mlModel.get("precision");
      if (precision >= 0 && isNumber(value)) {
        value = +value.toFixed(Math.min(precision, 20));
      }
      mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;
      itemArray = [mlFrom, mlTo, {
        type: mlType,
        valueIndex: item.valueIndex,
        value
      }];
    } else {
      if (true) {
        logError("Invalid markLine data.");
      }
      itemArray = [];
    }
  } else {
    itemArray = item;
  }
  const normalizedItem = [
    dataTransform(seriesModel, itemArray[0]),
    dataTransform(seriesModel, itemArray[1]),
    extend({}, itemArray[2])
  ];
  normalizedItem[2].type = normalizedItem[2].type || null;
  merge(normalizedItem[2], normalizedItem[0]);
  merge(normalizedItem[2], normalizedItem[1]);
  return normalizedItem;
};
function isInfinity(val) {
  return !isNaN(val) && !isFinite(val);
}
function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
  const otherDimIndex = 1 - dimIndex;
  const dimName = coordSys.dimensions[dimIndex];
  return isInfinity(fromCoord[otherDimIndex]) && isInfinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);
}
function markLineFilter(coordSys, item) {
  if (coordSys.type === "cartesian2d") {
    const fromCoord = item[0].coord;
    const toCoord = item[1].coord;
    if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
      return true;
    }
  }
  return dataFilter2(coordSys, item[0]) && dataFilter2(coordSys, item[1]);
}
function updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api2) {
  const coordSys = seriesModel.coordinateSystem;
  const itemModel = data.getItemModel(idx);
  let point;
  const xPx = parsePercent2(itemModel.get("x"), api2.getWidth());
  const yPx = parsePercent2(itemModel.get("y"), api2.getHeight());
  if (!isNaN(xPx) && !isNaN(yPx)) {
    point = [xPx, yPx];
  } else {
    if (seriesModel.getMarkerPosition) {
      point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));
    } else {
      const dims = coordSys.dimensions;
      const x = data.get(dims[0], idx);
      const y = data.get(dims[1], idx);
      point = coordSys.dataToPoint([x, y]);
    }
    if (isCoordinateSystemType(coordSys, "cartesian2d")) {
      const xAxis = coordSys.getAxis("x");
      const yAxis = coordSys.getAxis("y");
      const dims = coordSys.dimensions;
      if (isInfinity(data.get(dims[0], idx))) {
        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);
      } else if (isInfinity(data.get(dims[1], idx))) {
        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);
      }
    }
    if (!isNaN(xPx)) {
      point[0] = xPx;
    }
    if (!isNaN(yPx)) {
      point[1] = yPx;
    }
  }
  data.setItemLayout(idx, point);
}
var MarkLineView2 = class extends MarkerView_default {
  constructor() {
    super(...arguments);
    this.type = MarkLineView2.type;
  }
  updateTransform(markLineModel, ecModel, api2) {
    ecModel.eachSeries(function(seriesModel) {
      const mlModel = MarkerModel_default.getMarkerModelFromSeries(seriesModel, "markLine");
      if (mlModel) {
        const mlData = mlModel.getData();
        const fromData = inner21(mlModel).from;
        const toData = inner21(mlModel).to;
        fromData.each(function(idx) {
          updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api2);
          updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api2);
        });
        mlData.each(function(idx) {
          mlData.setItemLayout(idx, [
            fromData.getItemLayout(idx),
            toData.getItemLayout(idx)
          ]);
        });
        this.markerGroupMap.get(seriesModel.id).updateLayout();
      }
    }, this);
  }
  renderSeries(seriesModel, mlModel, ecModel, api2) {
    const coordSys = seriesModel.coordinateSystem;
    const seriesId = seriesModel.id;
    const seriesData = seriesModel.getData();
    const lineDrawMap = this.markerGroupMap;
    const lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw_default());
    this.group.add(lineDraw.group);
    const mlData = createList2(coordSys, seriesModel, mlModel);
    const fromData = mlData.from;
    const toData = mlData.to;
    const lineData = mlData.line;
    inner21(mlModel).from = fromData;
    inner21(mlModel).to = toData;
    mlModel.setData(lineData);
    let symbolType = mlModel.get("symbol");
    let symbolSize = mlModel.get("symbolSize");
    let symbolRotate = mlModel.get("symbolRotate");
    let symbolOffset = mlModel.get("symbolOffset");
    if (!isArray(symbolType)) {
      symbolType = [symbolType, symbolType];
    }
    if (!isArray(symbolSize)) {
      symbolSize = [symbolSize, symbolSize];
    }
    if (!isArray(symbolRotate)) {
      symbolRotate = [symbolRotate, symbolRotate];
    }
    if (!isArray(symbolOffset)) {
      symbolOffset = [symbolOffset, symbolOffset];
    }
    mlData.from.each(function(idx) {
      updateDataVisualAndLayout(fromData, idx, true);
      updateDataVisualAndLayout(toData, idx, false);
    });
    lineData.each(function(idx) {
      const itemModel = lineData.getItemModel(idx);
      const lineStyle = itemModel.getModel("lineStyle").getLineStyle();
      lineData.setItemLayout(idx, [
        fromData.getItemLayout(idx),
        toData.getItemLayout(idx)
      ]);
      const z2 = itemModel.get("z2");
      if (lineStyle.stroke == null) {
        lineStyle.stroke = fromData.getItemVisual(idx, "style").fill;
      }
      lineData.setItemVisual(idx, {
        z2: retrieve2(z2, 0),
        fromSymbolKeepAspect: fromData.getItemVisual(idx, "symbolKeepAspect"),
        fromSymbolOffset: fromData.getItemVisual(idx, "symbolOffset"),
        fromSymbolRotate: fromData.getItemVisual(idx, "symbolRotate"),
        fromSymbolSize: fromData.getItemVisual(idx, "symbolSize"),
        fromSymbol: fromData.getItemVisual(idx, "symbol"),
        toSymbolKeepAspect: toData.getItemVisual(idx, "symbolKeepAspect"),
        toSymbolOffset: toData.getItemVisual(idx, "symbolOffset"),
        toSymbolRotate: toData.getItemVisual(idx, "symbolRotate"),
        toSymbolSize: toData.getItemVisual(idx, "symbolSize"),
        toSymbol: toData.getItemVisual(idx, "symbol"),
        style: lineStyle
      });
    });
    lineDraw.updateData(lineData);
    mlData.line.eachItemGraphicEl(function(el) {
      getECData(el).dataModel = mlModel;
      el.traverse(function(child) {
        getECData(child).dataModel = mlModel;
      });
    });
    function updateDataVisualAndLayout(data, idx, isFrom) {
      const itemModel = data.getItemModel(idx);
      updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api2);
      const style = itemModel.getModel("itemStyle").getItemStyle();
      if (style.fill == null) {
        style.fill = getVisualFromData(seriesData, "color");
      }
      data.setItemVisual(idx, {
        symbolKeepAspect: itemModel.get("symbolKeepAspect"),
        symbolOffset: retrieve2(itemModel.get("symbolOffset", true), symbolOffset[isFrom ? 0 : 1]),
        symbolRotate: retrieve2(itemModel.get("symbolRotate", true), symbolRotate[isFrom ? 0 : 1]),
        symbolSize: retrieve2(itemModel.get("symbolSize"), symbolSize[isFrom ? 0 : 1]),
        symbol: retrieve2(itemModel.get("symbol", true), symbolType[isFrom ? 0 : 1]),
        style
      });
    }
    this.markKeep(lineDraw);
    lineDraw.group.silent = mlModel.get("silent") || seriesModel.get("silent");
  }
};
var MarkLineView = MarkLineView2;
MarkLineView.type = "markLine";
function createList2(coordSys, seriesModel, mlModel) {
  let coordDimsInfos;
  if (coordSys) {
    coordDimsInfos = map(coordSys && coordSys.dimensions, function(coordDim) {
      const info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};
      return extend(extend({}, info), {
        name: coordDim,
        ordinalMeta: null
      });
    });
  } else {
    coordDimsInfos = [{
      name: "value",
      type: "float"
    }];
  }
  const fromData = new SeriesData_default(coordDimsInfos, mlModel);
  const toData = new SeriesData_default(coordDimsInfos, mlModel);
  const lineData = new SeriesData_default([], mlModel);
  let optData = map(mlModel.get("data"), curry(markLineTransform, seriesModel, coordSys, mlModel));
  if (coordSys) {
    optData = filter(optData, curry(markLineFilter, coordSys));
  }
  const dimValueGetter = createMarkerDimValueGetter(!!coordSys, coordDimsInfos);
  fromData.initData(map(optData, function(item) {
    return item[0];
  }), null, dimValueGetter);
  toData.initData(map(optData, function(item) {
    return item[1];
  }), null, dimValueGetter);
  lineData.initData(map(optData, function(item) {
    return item[2];
  }));
  lineData.hasItemOption = true;
  return {
    from: fromData,
    to: toData,
    line: lineData
  };
}
var MarkLineView_default = MarkLineView;

// src/component/marker/installMarkLine.ts
function install44(registers) {
  registers.registerComponentModel(MarkLineModel_default);
  registers.registerComponentView(MarkLineView_default);
  registers.registerPreprocessor(function(opt) {
    if (checkMarkerInSeries(opt.series, "markLine")) {
      opt.markLine = opt.markLine || {};
    }
  });
}

// src/component/marker/MarkAreaModel.ts
var MarkAreaModel2 = class extends MarkerModel_default {
  constructor() {
    super(...arguments);
    this.type = MarkAreaModel2.type;
  }
  createMarkerModelFromSeries(markerOpt, masterMarkerModel, ecModel) {
    return new MarkAreaModel2(markerOpt, masterMarkerModel, ecModel);
  }
};
var MarkAreaModel = MarkAreaModel2;
MarkAreaModel.type = "markArea";
MarkAreaModel.defaultOption = {
  z: 1,
  tooltip: {
    trigger: "item"
  },
  animation: false,
  label: {
    show: true,
    position: "top"
  },
  itemStyle: {
    borderWidth: 0
  },
  emphasis: {
    label: {
      show: true,
      position: "top"
    }
  }
};
var MarkAreaModel_default = MarkAreaModel;

// src/component/marker/MarkAreaView.ts
var inner22 = makeInner();
var markAreaTransform = function(seriesModel, coordSys, maModel, item) {
  const item0 = item[0];
  const item1 = item[1];
  if (!item0 || !item1) {
    return;
  }
  const lt2 = dataTransform(seriesModel, item0);
  const rb2 = dataTransform(seriesModel, item1);
  const ltCoord = lt2.coord;
  const rbCoord = rb2.coord;
  ltCoord[0] = retrieve(ltCoord[0], -Infinity);
  ltCoord[1] = retrieve(ltCoord[1], -Infinity);
  rbCoord[0] = retrieve(rbCoord[0], Infinity);
  rbCoord[1] = retrieve(rbCoord[1], Infinity);
  const result = mergeAll([{}, lt2, rb2]);
  result.coord = [
    lt2.coord,
    rb2.coord
  ];
  result.x0 = lt2.x;
  result.y0 = lt2.y;
  result.x1 = rb2.x;
  result.y1 = rb2.y;
  return result;
};
function isInfinity2(val) {
  return !isNaN(val) && !isFinite(val);
}
function ifMarkAreaHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
  const otherDimIndex = 1 - dimIndex;
  return isInfinity2(fromCoord[otherDimIndex]) && isInfinity2(toCoord[otherDimIndex]);
}
function markAreaFilter(coordSys, item) {
  const fromCoord = item.coord[0];
  const toCoord = item.coord[1];
  const item0 = {
    coord: fromCoord,
    x: item.x0,
    y: item.y0
  };
  const item1 = {
    coord: toCoord,
    x: item.x1,
    y: item.y1
  };
  if (isCoordinateSystemType(coordSys, "cartesian2d")) {
    if (fromCoord && toCoord && (ifMarkAreaHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkAreaHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
      return true;
    }
    return zoneFilter(coordSys, item0, item1);
  }
  return dataFilter2(coordSys, item0) || dataFilter2(coordSys, item1);
}
function getSingleMarkerEndPoint(data, idx, dims, seriesModel, api2) {
  const coordSys = seriesModel.coordinateSystem;
  const itemModel = data.getItemModel(idx);
  let point;
  const xPx = parsePercent2(itemModel.get(dims[0]), api2.getWidth());
  const yPx = parsePercent2(itemModel.get(dims[1]), api2.getHeight());
  if (!isNaN(xPx) && !isNaN(yPx)) {
    point = [xPx, yPx];
  } else {
    if (seriesModel.getMarkerPosition) {
      const pointValue0 = data.getValues(["x0", "y0"], idx);
      const pointValue1 = data.getValues(["x1", "y1"], idx);
      const clampPointValue0 = coordSys.clampData(pointValue0);
      const clampPointValue1 = coordSys.clampData(pointValue1);
      const pointValue = [];
      if (dims[0] === "x0") {
        pointValue[0] = clampPointValue0[0] > clampPointValue1[0] ? pointValue1[0] : pointValue0[0];
      } else {
        pointValue[0] = clampPointValue0[0] > clampPointValue1[0] ? pointValue0[0] : pointValue1[0];
      }
      if (dims[1] === "y0") {
        pointValue[1] = clampPointValue0[1] > clampPointValue1[1] ? pointValue1[1] : pointValue0[1];
      } else {
        pointValue[1] = clampPointValue0[1] > clampPointValue1[1] ? pointValue0[1] : pointValue1[1];
      }
      point = seriesModel.getMarkerPosition(pointValue, dims, true);
    } else {
      const x = data.get(dims[0], idx);
      const y = data.get(dims[1], idx);
      const pt = [x, y];
      coordSys.clampData && coordSys.clampData(pt, pt);
      point = coordSys.dataToPoint(pt, true);
    }
    if (isCoordinateSystemType(coordSys, "cartesian2d")) {
      const xAxis = coordSys.getAxis("x");
      const yAxis = coordSys.getAxis("y");
      const x = data.get(dims[0], idx);
      const y = data.get(dims[1], idx);
      if (isInfinity2(x)) {
        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === "x0" ? 0 : 1]);
      } else if (isInfinity2(y)) {
        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === "y0" ? 0 : 1]);
      }
    }
    if (!isNaN(xPx)) {
      point[0] = xPx;
    }
    if (!isNaN(yPx)) {
      point[1] = yPx;
    }
  }
  return point;
}
var dimPermutations = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]];
var MarkAreaView2 = class extends MarkerView_default {
  constructor() {
    super(...arguments);
    this.type = MarkAreaView2.type;
  }
  updateTransform(markAreaModel, ecModel, api2) {
    ecModel.eachSeries(function(seriesModel) {
      const maModel = MarkerModel_default.getMarkerModelFromSeries(seriesModel, "markArea");
      if (maModel) {
        const areaData = maModel.getData();
        areaData.each(function(idx) {
          const points4 = map(dimPermutations, function(dim) {
            return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api2);
          });
          areaData.setItemLayout(idx, points4);
          const el = areaData.getItemGraphicEl(idx);
          el.setShape("points", points4);
        });
      }
    }, this);
  }
  renderSeries(seriesModel, maModel, ecModel, api2) {
    const coordSys = seriesModel.coordinateSystem;
    const seriesId = seriesModel.id;
    const seriesData = seriesModel.getData();
    const areaGroupMap = this.markerGroupMap;
    const polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, {group: new Group_default()});
    this.group.add(polygonGroup.group);
    this.markKeep(polygonGroup);
    const areaData = createList3(coordSys, seriesModel, maModel);
    maModel.setData(areaData);
    areaData.each(function(idx) {
      const points4 = map(dimPermutations, function(dim) {
        return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api2);
      });
      const xAxisScale = coordSys.getAxis("x").scale;
      const yAxisScale = coordSys.getAxis("y").scale;
      const xAxisExtent = xAxisScale.getExtent();
      const yAxisExtent = yAxisScale.getExtent();
      const xPointExtent = [xAxisScale.parse(areaData.get("x0", idx)), xAxisScale.parse(areaData.get("x1", idx))];
      const yPointExtent = [yAxisScale.parse(areaData.get("y0", idx)), yAxisScale.parse(areaData.get("y1", idx))];
      asc(xPointExtent);
      asc(yPointExtent);
      const overlapped = !(xAxisExtent[0] > xPointExtent[1] || xAxisExtent[1] < xPointExtent[0] || yAxisExtent[0] > yPointExtent[1] || yAxisExtent[1] < yPointExtent[0]);
      const allClipped = !overlapped;
      areaData.setItemLayout(idx, {
        points: points4,
        allClipped
      });
      const itemModel = areaData.getItemModel(idx);
      const style = itemModel.getModel("itemStyle").getItemStyle();
      const z2 = itemModel.get("z2");
      const color4 = getVisualFromData(seriesData, "color");
      if (!style.fill) {
        style.fill = color4;
        if (isString(style.fill)) {
          style.fill = modifyAlpha(style.fill, 0.4);
        }
      }
      if (!style.stroke) {
        style.stroke = color4;
      }
      areaData.setItemVisual(idx, "style", style);
      areaData.setItemVisual(idx, "z2", retrieve2(z2, 0));
    });
    areaData.diff(inner22(polygonGroup).data).add(function(idx) {
      const layout14 = areaData.getItemLayout(idx);
      const z2 = areaData.getItemVisual(idx, "z2");
      if (!layout14.allClipped) {
        const polygon = new Polygon_default({
          z2: retrieve2(z2, 0),
          shape: {
            points: layout14.points
          }
        });
        areaData.setItemGraphicEl(idx, polygon);
        polygonGroup.group.add(polygon);
      }
    }).update(function(newIdx, oldIdx) {
      let polygon = inner22(polygonGroup).data.getItemGraphicEl(oldIdx);
      const layout14 = areaData.getItemLayout(newIdx);
      const z2 = areaData.getItemVisual(newIdx, "z2");
      if (!layout14.allClipped) {
        if (polygon) {
          updateProps(polygon, {
            z2: retrieve2(z2, 0),
            shape: {
              points: layout14.points
            }
          }, maModel, newIdx);
        } else {
          polygon = new Polygon_default({
            shape: {
              points: layout14.points
            }
          });
        }
        areaData.setItemGraphicEl(newIdx, polygon);
        polygonGroup.group.add(polygon);
      } else if (polygon) {
        polygonGroup.group.remove(polygon);
      }
    }).remove(function(idx) {
      const polygon = inner22(polygonGroup).data.getItemGraphicEl(idx);
      polygonGroup.group.remove(polygon);
    }).execute();
    areaData.eachItemGraphicEl(function(polygon, idx) {
      const itemModel = areaData.getItemModel(idx);
      const style = areaData.getItemVisual(idx, "style");
      polygon.useStyle(areaData.getItemVisual(idx, "style"));
      setLabelStyle(polygon, getLabelStatesModels(itemModel), {
        labelFetcher: maModel,
        labelDataIndex: idx,
        defaultText: areaData.getName(idx) || "",
        inheritColor: isString(style.fill) ? modifyAlpha(style.fill, 1) : tokens_default.color.neutral99
      });
      setStatesStylesFromModel(polygon, itemModel);
      toggleHoverEmphasis(polygon, null, null, itemModel.get(["emphasis", "disabled"]));
      getECData(polygon).dataModel = maModel;
    });
    inner22(polygonGroup).data = areaData;
    polygonGroup.group.silent = maModel.get("silent") || seriesModel.get("silent");
  }
};
var MarkAreaView = MarkAreaView2;
MarkAreaView.type = "markArea";
function createList3(coordSys, seriesModel, maModel) {
  let areaData;
  let dataDims;
  const dims = ["x0", "y0", "x1", "y1"];
  if (coordSys) {
    const coordDimsInfos = map(coordSys && coordSys.dimensions, function(coordDim) {
      const data = seriesModel.getData();
      const info = data.getDimensionInfo(data.mapDimension(coordDim)) || {};
      return extend(extend({}, info), {
        name: coordDim,
        ordinalMeta: null
      });
    });
    dataDims = map(dims, (dim, idx) => ({
      name: dim,
      type: coordDimsInfos[idx % 2].type
    }));
    areaData = new SeriesData_default(dataDims, maModel);
  } else {
    dataDims = [{
      name: "value",
      type: "float"
    }];
    areaData = new SeriesData_default(dataDims, maModel);
  }
  let optData = map(maModel.get("data"), curry(markAreaTransform, seriesModel, coordSys, maModel));
  if (coordSys) {
    optData = filter(optData, curry(markAreaFilter, coordSys));
  }
  const dimValueGetter = coordSys ? function(item, dimName, dataIndex, dimIndex) {
    const rawVal = item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];
    return parseDataValue(rawVal, dataDims[dimIndex]);
  } : function(item, dimName, dataIndex, dimIndex) {
    return parseDataValue(item.value, dataDims[dimIndex]);
  };
  areaData.initData(optData, null, dimValueGetter);
  areaData.hasItemOption = true;
  return areaData;
}
var MarkAreaView_default = MarkAreaView;

// src/component/marker/installMarkArea.ts
function install45(registers) {
  registers.registerComponentModel(MarkAreaModel_default);
  registers.registerComponentView(MarkAreaView_default);
  registers.registerPreprocessor(function(opt) {
    if (checkMarkerInSeries(opt.series, "markArea")) {
      opt.markArea = opt.markArea || {};
    }
  });
}

// src/component/legend/LegendModel.ts
var getDefaultSelectorOptions = function(ecModel, type) {
  if (type === "all") {
    return {
      type: "all",
      title: ecModel.getLocaleModel().get(["legend", "selector", "all"])
    };
  } else if (type === "inverse") {
    return {
      type: "inverse",
      title: ecModel.getLocaleModel().get(["legend", "selector", "inverse"])
    };
  }
};
var LegendModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = LegendModel2.type;
    this.layoutMode = {
      type: "box",
      ignoreSize: true
    };
  }
  init(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
    option.selected = option.selected || {};
    this._updateSelector(option);
  }
  mergeOption(option, ecModel) {
    super.mergeOption(option, ecModel);
    this._updateSelector(option);
  }
  _updateSelector(option) {
    let selector2 = option.selector;
    const {ecModel} = this;
    if (selector2 === true) {
      selector2 = option.selector = ["all", "inverse"];
    }
    if (isArray(selector2)) {
      each(selector2, function(item, index) {
        isString(item) && (item = {type: item});
        selector2[index] = merge(item, getDefaultSelectorOptions(ecModel, item.type));
      });
    }
  }
  optionUpdated() {
    this._updateData(this.ecModel);
    const legendData = this._data;
    if (legendData[0] && this.get("selectedMode") === "single") {
      let hasSelected = false;
      for (let i = 0; i < legendData.length; i++) {
        const name = legendData[i].get("name");
        if (this.isSelected(name)) {
          this.select(name);
          hasSelected = true;
          break;
        }
      }
      !hasSelected && this.select(legendData[0].get("name"));
    }
  }
  _updateData(ecModel) {
    let potentialData = [];
    let availableNames = [];
    ecModel.eachRawSeries(function(seriesModel) {
      const seriesName = seriesModel.name;
      availableNames.push(seriesName);
      let isPotential;
      if (seriesModel.legendVisualProvider) {
        const provider = seriesModel.legendVisualProvider;
        const names = provider.getAllNames();
        if (!ecModel.isSeriesFiltered(seriesModel)) {
          availableNames = availableNames.concat(names);
        }
        if (names.length) {
          potentialData = potentialData.concat(names);
        } else {
          isPotential = true;
        }
      } else {
        isPotential = true;
      }
      if (isPotential && isNameSpecified(seriesModel)) {
        potentialData.push(seriesModel.name);
      }
    });
    this._availableNames = availableNames;
    const rawData = this.get("data") || potentialData;
    const legendNameMap = createHashMap();
    const legendData = map(rawData, function(dataItem) {
      if (isString(dataItem) || isNumber(dataItem)) {
        dataItem = {
          name: dataItem
        };
      }
      if (legendNameMap.get(dataItem.name)) {
        return null;
      }
      legendNameMap.set(dataItem.name, true);
      return new Model_default(dataItem, this, this.ecModel);
    }, this);
    this._data = filter(legendData, (item) => !!item);
  }
  getData() {
    return this._data;
  }
  select(name) {
    const selected = this.option.selected;
    const selectedMode = this.get("selectedMode");
    if (selectedMode === "single") {
      const data = this._data;
      each(data, function(dataItem) {
        selected[dataItem.get("name")] = false;
      });
    }
    selected[name] = true;
  }
  unSelect(name) {
    if (this.get("selectedMode") !== "single") {
      this.option.selected[name] = false;
    }
  }
  toggleSelected(name) {
    const selected = this.option.selected;
    if (!selected.hasOwnProperty(name)) {
      selected[name] = true;
    }
    this[selected[name] ? "unSelect" : "select"](name);
  }
  allSelect() {
    const data = this._data;
    const selected = this.option.selected;
    each(data, function(dataItem) {
      selected[dataItem.get("name", true)] = true;
    });
  }
  inverseSelect() {
    const data = this._data;
    const selected = this.option.selected;
    each(data, function(dataItem) {
      const name = dataItem.get("name", true);
      if (!selected.hasOwnProperty(name)) {
        selected[name] = true;
      }
      selected[name] = !selected[name];
    });
  }
  isSelected(name) {
    const selected = this.option.selected;
    return !(selected.hasOwnProperty(name) && !selected[name]) && indexOf(this._availableNames, name) >= 0;
  }
  getOrient() {
    return this.get("orient") === "vertical" ? {index: 1, name: "vertical"} : {index: 0, name: "horizontal"};
  }
};
var LegendModel = LegendModel2;
LegendModel.type = "legend.plain";
LegendModel.dependencies = ["series"];
LegendModel.defaultOption = {
  z: 4,
  show: true,
  orient: "horizontal",
  left: "center",
  bottom: tokens_default.size.m,
  align: "auto",
  backgroundColor: tokens_default.color.transparent,
  borderColor: tokens_default.color.border,
  borderRadius: 0,
  borderWidth: 0,
  padding: 5,
  itemGap: 8,
  itemWidth: 25,
  itemHeight: 14,
  symbolRotate: "inherit",
  symbolKeepAspect: true,
  inactiveColor: tokens_default.color.disabled,
  inactiveBorderColor: tokens_default.color.disabled,
  inactiveBorderWidth: "auto",
  itemStyle: {
    color: "inherit",
    opacity: "inherit",
    borderColor: "inherit",
    borderWidth: "auto",
    borderCap: "inherit",
    borderJoin: "inherit",
    borderDashOffset: "inherit",
    borderMiterLimit: "inherit"
  },
  lineStyle: {
    width: "auto",
    color: "inherit",
    inactiveColor: tokens_default.color.disabled,
    inactiveWidth: 2,
    opacity: "inherit",
    type: "inherit",
    cap: "inherit",
    join: "inherit",
    dashOffset: "inherit",
    miterLimit: "inherit"
  },
  textStyle: {
    color: tokens_default.color.secondary
  },
  selectedMode: true,
  selector: false,
  selectorLabel: {
    show: true,
    borderRadius: 10,
    padding: [3, 5, 3, 5],
    fontSize: 12,
    fontFamily: "sans-serif",
    color: tokens_default.color.tertiary,
    borderWidth: 1,
    borderColor: tokens_default.color.border
  },
  emphasis: {
    selectorLabel: {
      show: true,
      color: tokens_default.color.quaternary
    }
  },
  selectorPosition: "auto",
  selectorItemGap: 7,
  selectorButtonGap: 10,
  tooltip: {
    show: false
  },
  triggerEvent: false
};
var LegendModel_default = LegendModel;

// src/component/legend/LegendView.ts
var curry2 = curry;
var each13 = each;
var Group4 = Group_default;
var LegendView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = LegendView2.type;
    this.newlineDisabled = false;
  }
  init() {
    this.group.add(this._contentGroup = new Group4());
    this.group.add(this._selectorGroup = new Group4());
    this._isFirstRender = true;
  }
  getContentGroup() {
    return this._contentGroup;
  }
  getSelectorGroup() {
    return this._selectorGroup;
  }
  render(legendModel, ecModel, api2) {
    const isFirstRender = this._isFirstRender;
    this._isFirstRender = false;
    this.resetInner();
    if (!legendModel.get("show", true)) {
      return;
    }
    let itemAlign = legendModel.get("align");
    const orient = legendModel.get("orient");
    if (!itemAlign || itemAlign === "auto") {
      itemAlign = legendModel.get("left") === "right" && orient === "vertical" ? "right" : "left";
    }
    const selector2 = legendModel.get("selector", true);
    let selectorPosition = legendModel.get("selectorPosition", true);
    if (selector2 && (!selectorPosition || selectorPosition === "auto")) {
      selectorPosition = orient === "horizontal" ? "end" : "start";
    }
    this.renderInner(itemAlign, legendModel, ecModel, api2, selector2, orient, selectorPosition);
    const refContainer = createBoxLayoutReference(legendModel, api2).refContainer;
    const positionInfo = legendModel.getBoxLayoutParams();
    const padding = legendModel.get("padding");
    const maxSize = getLayoutRect(positionInfo, refContainer, padding);
    const mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector2, selectorPosition);
    const layoutRect = getLayoutRect(defaults({
      width: mainRect.width,
      height: mainRect.height
    }, positionInfo), refContainer, padding);
    this.group.x = layoutRect.x - mainRect.x;
    this.group.y = layoutRect.y - mainRect.y;
    this.group.markRedraw();
    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));
  }
  resetInner() {
    this.getContentGroup().removeAll();
    this._backgroundEl && this.group.remove(this._backgroundEl);
    this.getSelectorGroup().removeAll();
  }
  renderInner(itemAlign, legendModel, ecModel, api2, selector2, orient, selectorPosition) {
    const contentGroup = this.getContentGroup();
    const legendDrawnMap = createHashMap();
    const selectMode = legendModel.get("selectedMode");
    const triggerEvent = legendModel.get("triggerEvent");
    const excludeSeriesId = [];
    ecModel.eachRawSeries(function(seriesModel) {
      !seriesModel.get("legendHoverLink") && excludeSeriesId.push(seriesModel.id);
    });
    each13(legendModel.getData(), function(legendItemModel, dataIndex) {
      const name = legendItemModel.get("name");
      if (!this.newlineDisabled && (name === "" || name === "\n")) {
        const g = new Group4();
        g.newline = true;
        contentGroup.add(g);
        return;
      }
      const seriesModel = ecModel.getSeriesByName(name)[0];
      if (legendDrawnMap.get(name)) {
        return;
      }
      if (seriesModel) {
        const data = seriesModel.getData();
        const lineVisualStyle = data.getVisual("legendLineStyle") || {};
        const legendIcon = data.getVisual("legendIcon");
        const style = data.getVisual("style");
        const itemGroup = this._createItem(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, style, legendIcon, selectMode, api2);
        itemGroup.on("click", curry2(dispatchSelectAction, name, null, api2, excludeSeriesId)).on("mouseover", curry2(dispatchHighlightAction, seriesModel.name, null, api2, excludeSeriesId)).on("mouseout", curry2(dispatchDownplayAction, seriesModel.name, null, api2, excludeSeriesId));
        if (ecModel.ssr) {
          itemGroup.eachChild((child) => {
            const ecData = getECData(child);
            ecData.seriesIndex = seriesModel.seriesIndex;
            ecData.dataIndex = dataIndex;
            ecData.ssrType = "legend";
          });
        }
        if (triggerEvent) {
          itemGroup.eachChild((child) => {
            this.packEventData(child, legendModel, seriesModel, dataIndex, name);
          });
        }
        legendDrawnMap.set(name, true);
      } else {
        ecModel.eachRawSeries(function(seriesModel2) {
          if (legendDrawnMap.get(name)) {
            return;
          }
          if (seriesModel2.legendVisualProvider) {
            const provider = seriesModel2.legendVisualProvider;
            if (!provider.containName(name)) {
              return;
            }
            const idx = provider.indexOfName(name);
            let style = provider.getItemVisual(idx, "style");
            const legendIcon = provider.getItemVisual(idx, "legendIcon");
            const colorArr = parse(style.fill);
            if (colorArr && colorArr[3] === 0) {
              colorArr[3] = 0.2;
              style = extend(extend({}, style), {fill: stringify(colorArr, "rgba")});
            }
            const itemGroup = this._createItem(seriesModel2, name, dataIndex, legendItemModel, legendModel, itemAlign, {}, style, legendIcon, selectMode, api2);
            itemGroup.on("click", curry2(dispatchSelectAction, null, name, api2, excludeSeriesId)).on("mouseover", curry2(dispatchHighlightAction, null, name, api2, excludeSeriesId)).on("mouseout", curry2(dispatchDownplayAction, null, name, api2, excludeSeriesId));
            if (ecModel.ssr) {
              itemGroup.eachChild((child) => {
                const ecData = getECData(child);
                ecData.seriesIndex = seriesModel2.seriesIndex;
                ecData.dataIndex = dataIndex;
                ecData.ssrType = "legend";
              });
            }
            if (triggerEvent) {
              itemGroup.eachChild((child) => {
                this.packEventData(child, legendModel, seriesModel2, dataIndex, name);
              });
            }
            legendDrawnMap.set(name, true);
          }
        }, this);
      }
      if (true) {
        if (!legendDrawnMap.get(name)) {
          console.warn(name + " series not exists. Legend data should be same with series name or data name.");
        }
      }
    }, this);
    if (selector2) {
      this._createSelector(selector2, legendModel, api2, orient, selectorPosition);
    }
  }
  packEventData(el, legendModel, seriesModel, dataIndex, name) {
    const eventData = {
      componentType: "legend",
      componentIndex: legendModel.componentIndex,
      dataIndex,
      value: name,
      seriesIndex: seriesModel.seriesIndex
    };
    getECData(el).eventData = eventData;
  }
  _createSelector(selector2, legendModel, api2, orient, selectorPosition) {
    const selectorGroup = this.getSelectorGroup();
    each13(selector2, function createSelectorButton(selectorItem) {
      const type = selectorItem.type;
      const labelText = new Text_default({
        style: {
          x: 0,
          y: 0,
          align: "center",
          verticalAlign: "middle"
        },
        onclick() {
          api2.dispatchAction({
            type: type === "all" ? "legendAllSelect" : "legendInverseSelect",
            legendId: legendModel.id
          });
        }
      });
      selectorGroup.add(labelText);
      const labelModel = legendModel.getModel("selectorLabel");
      const emphasisLabelModel = legendModel.getModel(["emphasis", "selectorLabel"]);
      setLabelStyle(labelText, {normal: labelModel, emphasis: emphasisLabelModel}, {
        defaultText: selectorItem.title
      });
      enableHoverEmphasis(labelText);
    });
  }
  _createItem(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, itemVisualStyle, legendIcon, selectMode, api2) {
    const drawType = seriesModel.visualDrawType;
    const itemWidth = legendModel.get("itemWidth");
    const itemHeight = legendModel.get("itemHeight");
    const isSelected = legendModel.isSelected(name);
    const iconRotate = legendItemModel.get("symbolRotate");
    const symbolKeepAspect = legendItemModel.get("symbolKeepAspect");
    const legendIconType = legendItemModel.get("icon");
    legendIcon = legendIconType || legendIcon || "roundRect";
    const style = getLegendStyle(legendIcon, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api2);
    const itemGroup = new Group4();
    const textStyleModel = legendItemModel.getModel("textStyle");
    if (isFunction(seriesModel.getLegendIcon) && (!legendIconType || legendIconType === "inherit")) {
      itemGroup.add(seriesModel.getLegendIcon({
        itemWidth,
        itemHeight,
        icon: legendIcon,
        iconRotate,
        itemStyle: style.itemStyle,
        lineStyle: style.lineStyle,
        symbolKeepAspect
      }));
    } else {
      const rotate2 = legendIconType === "inherit" && seriesModel.getData().getVisual("symbol") ? iconRotate === "inherit" ? seriesModel.getData().getVisual("symbolRotate") : iconRotate : 0;
      itemGroup.add(getDefaultLegendIcon({
        itemWidth,
        itemHeight,
        icon: legendIcon,
        iconRotate: rotate2,
        itemStyle: style.itemStyle,
        lineStyle: style.lineStyle,
        symbolKeepAspect
      }));
    }
    const textX = itemAlign === "left" ? itemWidth + 5 : -5;
    const textAlign = itemAlign;
    const formatter = legendModel.get("formatter");
    let content = name;
    if (isString(formatter) && formatter) {
      content = formatter.replace("{name}", name != null ? name : "");
    } else if (isFunction(formatter)) {
      content = formatter(name);
    }
    const textColor = isSelected ? textStyleModel.getTextColor() : legendItemModel.get("inactiveColor");
    itemGroup.add(new Text_default({
      style: createTextStyle(textStyleModel, {
        text: content,
        x: textX,
        y: itemHeight / 2,
        fill: textColor,
        align: textAlign,
        verticalAlign: "middle"
      }, {inheritColor: textColor})
    }));
    const hitRect = new Rect_default({
      shape: itemGroup.getBoundingRect(),
      style: {
        fill: "transparent"
      }
    });
    const tooltipModel = legendItemModel.getModel("tooltip");
    if (tooltipModel.get("show")) {
      setTooltipConfig({
        el: hitRect,
        componentModel: legendModel,
        itemName: name,
        itemTooltipOption: tooltipModel.option
      });
    }
    itemGroup.add(hitRect);
    itemGroup.eachChild(function(child) {
      child.silent = true;
    });
    hitRect.silent = !selectMode;
    this.getContentGroup().add(itemGroup);
    enableHoverEmphasis(itemGroup);
    itemGroup.__legendDataIndex = dataIndex;
    return itemGroup;
  }
  layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector2, selectorPosition) {
    const contentGroup = this.getContentGroup();
    const selectorGroup = this.getSelectorGroup();
    box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), maxSize.width, maxSize.height);
    const contentRect = contentGroup.getBoundingRect();
    const contentPos = [-contentRect.x, -contentRect.y];
    selectorGroup.markRedraw();
    contentGroup.markRedraw();
    if (selector2) {
      box("horizontal", selectorGroup, legendModel.get("selectorItemGap", true));
      const selectorRect = selectorGroup.getBoundingRect();
      const selectorPos = [-selectorRect.x, -selectorRect.y];
      const selectorButtonGap = legendModel.get("selectorButtonGap", true);
      const orientIdx = legendModel.getOrient().index;
      const wh = orientIdx === 0 ? "width" : "height";
      const hw = orientIdx === 0 ? "height" : "width";
      const yx = orientIdx === 0 ? "y" : "x";
      if (selectorPosition === "end") {
        selectorPos[orientIdx] += contentRect[wh] + selectorButtonGap;
      } else {
        contentPos[orientIdx] += selectorRect[wh] + selectorButtonGap;
      }
      selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2;
      selectorGroup.x = selectorPos[0];
      selectorGroup.y = selectorPos[1];
      contentGroup.x = contentPos[0];
      contentGroup.y = contentPos[1];
      const mainRect = {x: 0, y: 0};
      mainRect[wh] = contentRect[wh] + selectorButtonGap + selectorRect[wh];
      mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw]);
      mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx]);
      return mainRect;
    } else {
      contentGroup.x = contentPos[0];
      contentGroup.y = contentPos[1];
      return this.group.getBoundingRect();
    }
  }
  remove() {
    this.getContentGroup().removeAll();
    this._isFirstRender = true;
  }
};
var LegendView = LegendView2;
LegendView.type = "legend.plain";
function getLegendStyle(iconType, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api2) {
  function handleCommonProps(style, visualStyle) {
    if (style.lineWidth === "auto") {
      style.lineWidth = visualStyle.lineWidth > 0 ? 2 : 0;
    }
    each13(style, (propVal, propName) => {
      style[propName] === "inherit" && (style[propName] = visualStyle[propName]);
    });
  }
  const itemStyleModel = legendItemModel.getModel("itemStyle");
  const itemStyle = itemStyleModel.getItemStyle();
  const iconBrushType = iconType.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke";
  const decalStyle = itemStyleModel.getShallow("decal");
  itemStyle.decal = !decalStyle || decalStyle === "inherit" ? itemVisualStyle.decal : createOrUpdatePatternFromDecal(decalStyle, api2);
  if (itemStyle.fill === "inherit") {
    itemStyle.fill = itemVisualStyle[drawType];
  }
  if (itemStyle.stroke === "inherit") {
    itemStyle.stroke = itemVisualStyle[iconBrushType];
  }
  if (itemStyle.opacity === "inherit") {
    itemStyle.opacity = (drawType === "fill" ? itemVisualStyle : lineVisualStyle).opacity;
  }
  handleCommonProps(itemStyle, itemVisualStyle);
  const legendLineModel = legendItemModel.getModel("lineStyle");
  const lineStyle = legendLineModel.getLineStyle();
  handleCommonProps(lineStyle, lineVisualStyle);
  itemStyle.fill === "auto" && (itemStyle.fill = itemVisualStyle.fill);
  itemStyle.stroke === "auto" && (itemStyle.stroke = itemVisualStyle.fill);
  lineStyle.stroke === "auto" && (lineStyle.stroke = itemVisualStyle.fill);
  if (!isSelected) {
    const borderWidth = legendItemModel.get("inactiveBorderWidth");
    const visualHasBorder = itemStyle[iconBrushType];
    itemStyle.lineWidth = borderWidth === "auto" ? itemVisualStyle.lineWidth > 0 && visualHasBorder ? 2 : 0 : itemStyle.lineWidth;
    itemStyle.fill = legendItemModel.get("inactiveColor");
    itemStyle.stroke = legendItemModel.get("inactiveBorderColor");
    lineStyle.stroke = legendLineModel.get("inactiveColor");
    lineStyle.lineWidth = legendLineModel.get("inactiveWidth");
  }
  return {itemStyle, lineStyle};
}
function getDefaultLegendIcon(opt) {
  const symboType = opt.icon || "roundRect";
  const icon = createSymbol(symboType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill, opt.symbolKeepAspect);
  icon.setStyle(opt.itemStyle);
  icon.rotation = (opt.iconRotate || 0) * Math.PI / 180;
  icon.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);
  if (symboType.indexOf("empty") > -1) {
    icon.style.stroke = icon.style.fill;
    icon.style.fill = tokens_default.color.neutral00;
    icon.style.lineWidth = 2;
  }
  return icon;
}
function dispatchSelectAction(seriesName, dataName, api2, excludeSeriesId) {
  dispatchDownplayAction(seriesName, dataName, api2, excludeSeriesId);
  api2.dispatchAction({
    type: "legendToggleSelect",
    name: seriesName != null ? seriesName : dataName
  });
  dispatchHighlightAction(seriesName, dataName, api2, excludeSeriesId);
}
function isUseHoverLayer(api2) {
  const list = api2.getZr().storage.getDisplayList();
  let emphasisState;
  let i = 0;
  const len2 = list.length;
  while (i < len2 && !(emphasisState = list[i].states.emphasis)) {
    i++;
  }
  return emphasisState && emphasisState.hoverLayer;
}
function dispatchHighlightAction(seriesName, dataName, api2, excludeSeriesId) {
  if (!isUseHoverLayer(api2)) {
    api2.dispatchAction({
      type: "highlight",
      seriesName,
      name: dataName,
      excludeSeriesId
    });
  }
}
function dispatchDownplayAction(seriesName, dataName, api2, excludeSeriesId) {
  if (!isUseHoverLayer(api2)) {
    api2.dispatchAction({
      type: "downplay",
      seriesName,
      name: dataName,
      excludeSeriesId
    });
  }
}
var LegendView_default = LegendView;

// src/component/legend/legendFilter.ts
function legendFilter(ecModel) {
  const legendModels = ecModel.findComponents({
    mainType: "legend"
  });
  if (legendModels && legendModels.length) {
    ecModel.filterSeries(function(series) {
      for (let i = 0; i < legendModels.length; i++) {
        if (!legendModels[i].isSelected(series.name)) {
          return false;
        }
      }
      return true;
    });
  }
}

// src/component/legend/legendAction.ts
function legendSelectActionHandler(methodName, payload, ecModel) {
  const isAllSelect = methodName === "allSelect" || methodName === "inverseSelect";
  const selectedMap = {};
  const actionLegendIndices = [];
  ecModel.eachComponent({mainType: "legend", query: payload}, function(legendModel) {
    if (isAllSelect) {
      legendModel[methodName]();
    } else {
      legendModel[methodName](payload.name);
    }
    makeSelectedMap(legendModel, selectedMap);
    actionLegendIndices.push(legendModel.componentIndex);
  });
  const allSelectedMap = {};
  ecModel.eachComponent("legend", function(legendModel) {
    each(selectedMap, function(isSelected, name) {
      legendModel[isSelected ? "select" : "unSelect"](name);
    });
    makeSelectedMap(legendModel, allSelectedMap);
  });
  return isAllSelect ? {
    selected: allSelectedMap,
    legendIndex: actionLegendIndices
  } : {
    name: payload.name,
    selected: allSelectedMap
  };
}
function makeSelectedMap(legendModel, out2) {
  const selectedMap = out2 || {};
  each(legendModel.getData(), function(model) {
    const name = model.get("name");
    if (name === "\n" || name === "") {
      return;
    }
    const isItemSelected = legendModel.isSelected(name);
    if (hasOwn(selectedMap, name)) {
      selectedMap[name] = selectedMap[name] && isItemSelected;
    } else {
      selectedMap[name] = isItemSelected;
    }
  });
  return selectedMap;
}
function installLegendAction(registers) {
  registers.registerAction("legendToggleSelect", "legendselectchanged", curry(legendSelectActionHandler, "toggleSelected"));
  registers.registerAction("legendAllSelect", "legendselectall", curry(legendSelectActionHandler, "allSelect"));
  registers.registerAction("legendInverseSelect", "legendinverseselect", curry(legendSelectActionHandler, "inverseSelect"));
  registers.registerAction("legendSelect", "legendselected", curry(legendSelectActionHandler, "select"));
  registers.registerAction("legendUnSelect", "legendunselected", curry(legendSelectActionHandler, "unSelect"));
}

// src/component/legend/installLegendPlain.ts
function install46(registers) {
  registers.registerComponentModel(LegendModel_default);
  registers.registerComponentView(LegendView_default);
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter);
  registers.registerSubTypeDefaulter("legend", function() {
    return "plain";
  });
  installLegendAction(registers);
}

// src/component/legend/ScrollableLegendModel.ts
var ScrollableLegendModel2 = class extends LegendModel_default {
  constructor() {
    super(...arguments);
    this.type = ScrollableLegendModel2.type;
  }
  setScrollDataIndex(scrollDataIndex) {
    this.option.scrollDataIndex = scrollDataIndex;
  }
  init(option, parentModel, ecModel) {
    const inputPositionParams = getLayoutParams(option);
    super.init(option, parentModel, ecModel);
    mergeAndNormalizeLayoutParams2(this, option, inputPositionParams);
  }
  mergeOption(option, ecModel) {
    super.mergeOption(option, ecModel);
    mergeAndNormalizeLayoutParams2(this, this.option, option);
  }
};
var ScrollableLegendModel = ScrollableLegendModel2;
ScrollableLegendModel.type = "legend.scroll";
ScrollableLegendModel.defaultOption = inheritDefaultOption(LegendModel_default.defaultOption, {
  scrollDataIndex: 0,
  pageButtonItemGap: 5,
  pageButtonGap: null,
  pageButtonPosition: "end",
  pageFormatter: "{current}/{total}",
  pageIcons: {
    horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
    vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
  },
  pageIconColor: tokens_default.color.accent50,
  pageIconInactiveColor: tokens_default.color.accent10,
  pageIconSize: 15,
  pageTextStyle: {
    color: tokens_default.color.tertiary
  },
  animationDurationUpdate: 800
});
function mergeAndNormalizeLayoutParams2(legendModel, target, raw) {
  const orient = legendModel.getOrient();
  const ignoreSize = [1, 1];
  ignoreSize[orient.index] = 0;
  mergeLayoutParam(target, raw, {
    type: "box",
    ignoreSize: !!ignoreSize
  });
}
var ScrollableLegendModel_default = ScrollableLegendModel;

// src/component/legend/ScrollableLegendView.ts
var Group5 = Group_default;
var WH4 = ["width", "height"];
var XY4 = ["x", "y"];
var ScrollableLegendView2 = class extends LegendView_default {
  constructor() {
    super(...arguments);
    this.type = ScrollableLegendView2.type;
    this.newlineDisabled = true;
    this._currentIndex = 0;
  }
  init() {
    super.init();
    this.group.add(this._containerGroup = new Group5());
    this._containerGroup.add(this.getContentGroup());
    this.group.add(this._controllerGroup = new Group5());
  }
  resetInner() {
    super.resetInner();
    this._controllerGroup.removeAll();
    this._containerGroup.removeClipPath();
    this._containerGroup.__rectSize = null;
  }
  renderInner(itemAlign, legendModel, ecModel, api2, selector2, orient, selectorPosition) {
    const self2 = this;
    super.renderInner(itemAlign, legendModel, ecModel, api2, selector2, orient, selectorPosition);
    const controllerGroup = this._controllerGroup;
    const pageIconSize = legendModel.get("pageIconSize", true);
    const pageIconSizeArr = isArray(pageIconSize) ? pageIconSize : [pageIconSize, pageIconSize];
    createPageButton("pagePrev", 0);
    const pageTextStyleModel = legendModel.getModel("pageTextStyle");
    controllerGroup.add(new Text_default({
      name: "pageText",
      style: {
        text: "xx/xx",
        fill: pageTextStyleModel.getTextColor(),
        font: pageTextStyleModel.getFont(),
        verticalAlign: "middle",
        align: "center"
      },
      silent: true
    }));
    createPageButton("pageNext", 1);
    function createPageButton(name, iconIdx) {
      const pageDataIndexName = name + "DataIndex";
      const icon = createIcon(legendModel.get("pageIcons", true)[legendModel.getOrient().name][iconIdx], {
        onclick: bind(self2._pageGo, self2, pageDataIndexName, legendModel, api2)
      }, {
        x: -pageIconSizeArr[0] / 2,
        y: -pageIconSizeArr[1] / 2,
        width: pageIconSizeArr[0],
        height: pageIconSizeArr[1]
      });
      icon.name = name;
      controllerGroup.add(icon);
    }
  }
  layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector2, selectorPosition) {
    const selectorGroup = this.getSelectorGroup();
    const orientIdx = legendModel.getOrient().index;
    const wh = WH4[orientIdx];
    const xy = XY4[orientIdx];
    const hw = WH4[1 - orientIdx];
    const yx = XY4[1 - orientIdx];
    selector2 && box("horizontal", selectorGroup, legendModel.get("selectorItemGap", true));
    const selectorButtonGap = legendModel.get("selectorButtonGap", true);
    const selectorRect = selectorGroup.getBoundingRect();
    const selectorPos = [-selectorRect.x, -selectorRect.y];
    const processMaxSize = clone(maxSize);
    selector2 && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);
    const mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx, xy);
    if (selector2) {
      if (selectorPosition === "end") {
        selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;
      } else {
        const offset = selectorRect[wh] + selectorButtonGap;
        selectorPos[orientIdx] -= offset;
        mainRect[xy] -= offset;
      }
      mainRect[wh] += selectorRect[wh] + selectorButtonGap;
      selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;
      mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);
      mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);
      selectorGroup.x = selectorPos[0];
      selectorGroup.y = selectorPos[1];
      selectorGroup.markRedraw();
    }
    return mainRect;
  }
  _layoutContentAndController(legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx, xy) {
    const contentGroup = this.getContentGroup();
    const containerGroup = this._containerGroup;
    const controllerGroup = this._controllerGroup;
    box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);
    box("horizontal", controllerGroup, legendModel.get("pageButtonItemGap", true));
    const contentRect = contentGroup.getBoundingRect();
    const controllerRect = controllerGroup.getBoundingRect();
    const showController = this._showController = contentRect[wh] > maxSize[wh];
    const contentPos = [-contentRect.x, -contentRect.y];
    if (!isFirstRender) {
      contentPos[orientIdx] = contentGroup[xy];
    }
    const containerPos = [0, 0];
    const controllerPos = [-controllerRect.x, -controllerRect.y];
    const pageButtonGap = retrieve2(legendModel.get("pageButtonGap", true), legendModel.get("itemGap", true));
    if (showController) {
      const pageButtonPosition = legendModel.get("pageButtonPosition", true);
      if (pageButtonPosition === "end") {
        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];
      } else {
        containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;
      }
    }
    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;
    contentGroup.setPosition(contentPos);
    containerGroup.setPosition(containerPos);
    controllerGroup.setPosition(controllerPos);
    const mainRect = {x: 0, y: 0};
    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];
    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]);
    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);
    containerGroup.__rectSize = maxSize[wh];
    if (showController) {
      const clipShape = {x: 0, y: 0};
      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);
      clipShape[hw] = mainRect[hw];
      containerGroup.setClipPath(new Rect_default({shape: clipShape}));
      containerGroup.__rectSize = clipShape[wh];
    } else {
      controllerGroup.eachChild(function(child) {
        child.attr({
          invisible: true,
          silent: true
        });
      });
    }
    const pageInfo = this._getPageInfo(legendModel);
    pageInfo.pageIndex != null && updateProps(contentGroup, {x: pageInfo.contentPosition[0], y: pageInfo.contentPosition[1]}, showController ? legendModel : null);
    this._updatePageInfoView(legendModel, pageInfo);
    return mainRect;
  }
  _pageGo(to, legendModel, api2) {
    const scrollDataIndex = this._getPageInfo(legendModel)[to];
    scrollDataIndex != null && api2.dispatchAction({
      type: "legendScroll",
      scrollDataIndex,
      legendId: legendModel.id
    });
  }
  _updatePageInfoView(legendModel, pageInfo) {
    const controllerGroup = this._controllerGroup;
    each(["pagePrev", "pageNext"], function(name) {
      const key = name + "DataIndex";
      const canJump = pageInfo[key] != null;
      const icon = controllerGroup.childOfName(name);
      if (icon) {
        icon.setStyle("fill", canJump ? legendModel.get("pageIconColor", true) : legendModel.get("pageIconInactiveColor", true));
        icon.cursor = canJump ? "pointer" : "default";
      }
    });
    const pageText = controllerGroup.childOfName("pageText");
    const pageFormatter = legendModel.get("pageFormatter");
    const pageIndex = pageInfo.pageIndex;
    const current = pageIndex != null ? pageIndex + 1 : 0;
    const total = pageInfo.pageCount;
    pageText && pageFormatter && pageText.setStyle("text", isString(pageFormatter) ? pageFormatter.replace("{current}", current == null ? "" : current + "").replace("{total}", total == null ? "" : total + "") : pageFormatter({current, total}));
  }
  _getPageInfo(legendModel) {
    const scrollDataIndex = legendModel.get("scrollDataIndex", true);
    const contentGroup = this.getContentGroup();
    const containerRectSize = this._containerGroup.__rectSize;
    const orientIdx = legendModel.getOrient().index;
    const wh = WH4[orientIdx];
    const xy = XY4[orientIdx];
    const targetItemIndex = this._findTargetItemIndex(scrollDataIndex);
    const children = contentGroup.children();
    const targetItem = children[targetItemIndex];
    const itemCount = children.length;
    const pCount = !itemCount ? 0 : 1;
    const result = {
      contentPosition: [contentGroup.x, contentGroup.y],
      pageCount: pCount,
      pageIndex: pCount - 1,
      pagePrevDataIndex: null,
      pageNextDataIndex: null
    };
    if (!targetItem) {
      return result;
    }
    const targetItemInfo = getItemInfo(targetItem);
    result.contentPosition[orientIdx] = -targetItemInfo.s;
    for (let i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {
      currItemInfo = getItemInfo(children[i]);
      if (!currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || currItemInfo && !intersect2(currItemInfo, winStartItemInfo.s)) {
        if (winEndItemInfo.i > winStartItemInfo.i) {
          winStartItemInfo = winEndItemInfo;
        } else {
          winStartItemInfo = currItemInfo;
        }
        if (winStartItemInfo) {
          if (result.pageNextDataIndex == null) {
            result.pageNextDataIndex = winStartItemInfo.i;
          }
          ++result.pageCount;
        }
      }
      winEndItemInfo = currItemInfo;
    }
    for (let i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {
      currItemInfo = getItemInfo(children[i]);
      if ((!currItemInfo || !intersect2(winEndItemInfo, currItemInfo.s)) && winStartItemInfo.i < winEndItemInfo.i) {
        winEndItemInfo = winStartItemInfo;
        if (result.pagePrevDataIndex == null) {
          result.pagePrevDataIndex = winStartItemInfo.i;
        }
        ++result.pageCount;
        ++result.pageIndex;
      }
      winStartItemInfo = currItemInfo;
    }
    return result;
    function getItemInfo(el) {
      if (el) {
        const itemRect = el.getBoundingRect();
        const start2 = itemRect[xy] + el[xy];
        return {
          s: start2,
          e: start2 + itemRect[wh],
          i: el.__legendDataIndex
        };
      }
    }
    function intersect2(itemInfo, winStart) {
      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;
    }
  }
  _findTargetItemIndex(targetDataIndex) {
    if (!this._showController) {
      return 0;
    }
    let index;
    const contentGroup = this.getContentGroup();
    let defaultIndex;
    contentGroup.eachChild(function(child, idx) {
      const legendDataIdx = child.__legendDataIndex;
      if (defaultIndex == null && legendDataIdx != null) {
        defaultIndex = idx;
      }
      if (legendDataIdx === targetDataIndex) {
        index = idx;
      }
    });
    return index != null ? index : defaultIndex;
  }
};
var ScrollableLegendView = ScrollableLegendView2;
ScrollableLegendView.type = "legend.scroll";
var ScrollableLegendView_default = ScrollableLegendView;

// src/component/legend/scrollableLegendAction.ts
function installScrollableLegendAction(registers) {
  registers.registerAction("legendScroll", "legendscroll", function(payload, ecModel) {
    const scrollDataIndex = payload.scrollDataIndex;
    scrollDataIndex != null && ecModel.eachComponent({mainType: "legend", subType: "scroll", query: payload}, function(legendModel) {
      legendModel.setScrollDataIndex(scrollDataIndex);
    });
  });
}

// src/component/legend/installLegendScroll.ts
function install47(registers) {
  use(install46);
  registers.registerComponentModel(ScrollableLegendModel_default);
  registers.registerComponentView(ScrollableLegendView_default);
  installScrollableLegendAction(registers);
}

// src/component/legend/install.ts
function install48(registers) {
  use(install46);
  use(install47);
}

// src/component/dataZoom/InsideZoomModel.ts
var InsideZoomModel2 = class extends DataZoomModel_default {
  constructor() {
    super(...arguments);
    this.type = InsideZoomModel2.type;
  }
};
var InsideZoomModel = InsideZoomModel2;
InsideZoomModel.type = "dataZoom.inside";
InsideZoomModel.defaultOption = inheritDefaultOption(DataZoomModel_default.defaultOption, {
  disabled: false,
  zoomLock: false,
  zoomOnMouseWheel: true,
  moveOnMouseMove: true,
  moveOnMouseWheel: false,
  preventDefaultMouseMove: true
});
var InsideZoomModel_default = InsideZoomModel;

// src/component/dataZoom/roams.ts
var inner23 = makeInner();
function setViewInfoToCoordSysRecord(api2, dataZoomModel, getRange) {
  inner23(api2).coordSysRecordMap.each(function(coordSysRecord) {
    const dzInfo = coordSysRecord.dataZoomInfoMap.get(dataZoomModel.uid);
    if (dzInfo) {
      dzInfo.getRange = getRange;
    }
  });
}
function disposeCoordSysRecordIfNeeded(api2, dataZoomModel) {
  const coordSysRecordMap = inner23(api2).coordSysRecordMap;
  const coordSysKeyArr = coordSysRecordMap.keys();
  for (let i = 0; i < coordSysKeyArr.length; i++) {
    const coordSysKey = coordSysKeyArr[i];
    const coordSysRecord = coordSysRecordMap.get(coordSysKey);
    const dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;
    if (dataZoomInfoMap) {
      const dzUid = dataZoomModel.uid;
      const dzInfo = dataZoomInfoMap.get(dzUid);
      if (dzInfo) {
        dataZoomInfoMap.removeKey(dzUid);
        if (!dataZoomInfoMap.keys().length) {
          disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);
        }
      }
    }
  }
}
function disposeCoordSysRecord(coordSysRecordMap, coordSysRecord) {
  if (coordSysRecord) {
    coordSysRecordMap.removeKey(coordSysRecord.model.uid);
    const controller = coordSysRecord.controller;
    controller && controller.dispose();
  }
}
function createCoordSysRecord(api2, coordSysModel) {
  const coordSysRecord = {
    model: coordSysModel,
    containsPoint: curry(containsPoint, coordSysModel),
    dispatchAction: curry(dispatchAction2, api2),
    dataZoomInfoMap: null,
    controller: null
  };
  const controller = coordSysRecord.controller = new RoamController_default(api2.getZr());
  each(["pan", "zoom", "scrollMove"], function(eventName) {
    controller.on(eventName, function(event) {
      const batch = [];
      coordSysRecord.dataZoomInfoMap.each(function(dzInfo) {
        if (!event.isAvailableBehavior(dzInfo.model.option)) {
          return;
        }
        const method = (dzInfo.getRange || {})[eventName];
        const range = method && method(dzInfo.dzReferCoordSysInfo, coordSysRecord.model.mainType, coordSysRecord.controller, event);
        !dzInfo.model.get("disabled", true) && range && batch.push({
          dataZoomId: dzInfo.model.id,
          start: range[0],
          end: range[1]
        });
      });
      batch.length && coordSysRecord.dispatchAction(batch);
    });
  });
  return coordSysRecord;
}
function dispatchAction2(api2, batch) {
  if (!api2.isDisposed()) {
    api2.dispatchAction({
      type: "dataZoom",
      animation: {
        easing: "cubicOut",
        duration: 100
      },
      batch
    });
  }
}
function containsPoint(coordSysModel, e2, x, y) {
  return coordSysModel.coordinateSystem.containPoint([x, y]);
}
function mergeControllerParams(dataZoomInfoMap, coordSysRecord, api2) {
  let controlType;
  const prefix = "type_";
  const typePriority = {
    type_true: 2,
    type_move: 1,
    type_false: 0,
    type_undefined: -1
  };
  let preventDefaultMouseMove = true;
  dataZoomInfoMap.each(function(dataZoomInfo) {
    const dataZoomModel = dataZoomInfo.model;
    const oneType = dataZoomModel.get("disabled", true) ? false : dataZoomModel.get("zoomLock", true) ? "move" : true;
    if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {
      controlType = oneType;
    }
    preventDefaultMouseMove = preventDefaultMouseMove && dataZoomModel.get("preventDefaultMouseMove", true);
  });
  return {
    controlType,
    opt: {
      zoomOnMouseWheel: true,
      moveOnMouseMove: true,
      moveOnMouseWheel: true,
      preventDefaultMouseMove: !!preventDefaultMouseMove,
      api: api2,
      zInfo: {
        component: coordSysRecord.model
      },
      triggerInfo: {
        roamTrigger: null,
        isInSelf: coordSysRecord.containsPoint
      }
    }
  };
}
function installDataZoomRoamProcessor(registers) {
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, function(ecModel, api2) {
    const apiInner = inner23(api2);
    const coordSysRecordMap = apiInner.coordSysRecordMap || (apiInner.coordSysRecordMap = createHashMap());
    coordSysRecordMap.each(function(coordSysRecord) {
      coordSysRecord.dataZoomInfoMap = null;
    });
    ecModel.eachComponent({mainType: "dataZoom", subType: "inside"}, function(dataZoomModel) {
      const dzReferCoordSysWrap = collectReferCoordSysModelInfo(dataZoomModel);
      each(dzReferCoordSysWrap.infoList, function(dzCoordSysInfo) {
        const coordSysUid = dzCoordSysInfo.model.uid;
        const coordSysRecord = coordSysRecordMap.get(coordSysUid) || coordSysRecordMap.set(coordSysUid, createCoordSysRecord(api2, dzCoordSysInfo.model));
        const dataZoomInfoMap = coordSysRecord.dataZoomInfoMap || (coordSysRecord.dataZoomInfoMap = createHashMap());
        dataZoomInfoMap.set(dataZoomModel.uid, {
          dzReferCoordSysInfo: dzCoordSysInfo,
          model: dataZoomModel,
          getRange: null
        });
      });
    });
    coordSysRecordMap.each(function(coordSysRecord) {
      const controller = coordSysRecord.controller;
      let firstDzInfo;
      const dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;
      if (dataZoomInfoMap) {
        const firstDzKey = dataZoomInfoMap.keys()[0];
        if (firstDzKey != null) {
          firstDzInfo = dataZoomInfoMap.get(firstDzKey);
        }
      }
      if (!firstDzInfo) {
        disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);
        return;
      }
      const controllerParams = mergeControllerParams(dataZoomInfoMap, coordSysRecord, api2);
      controller.enable(controllerParams.controlType, controllerParams.opt);
      createOrUpdate(coordSysRecord, "dispatchAction", firstDzInfo.model.get("throttle", true), "fixRate");
    });
  });
}

// src/component/dataZoom/InsideZoomView.ts
var InsideZoomView = class extends DataZoomView_default {
  constructor() {
    super(...arguments);
    this.type = "dataZoom.inside";
  }
  render(dataZoomModel, ecModel, api2) {
    super.render.apply(this, arguments);
    if (dataZoomModel.noTarget()) {
      this._clear();
      return;
    }
    this.range = dataZoomModel.getPercentRange();
    setViewInfoToCoordSysRecord(api2, dataZoomModel, {
      pan: bind(getRangeHandlers.pan, this),
      zoom: bind(getRangeHandlers.zoom, this),
      scrollMove: bind(getRangeHandlers.scrollMove, this)
    });
  }
  dispose() {
    this._clear();
    super.dispose.apply(this, arguments);
  }
  _clear() {
    disposeCoordSysRecordIfNeeded(this.api, this.dataZoomModel);
    this.range = null;
  }
};
InsideZoomView.type = "dataZoom.inside";
var getRangeHandlers = {
  zoom(coordSysInfo, coordSysMainType, controller, e2) {
    const lastRange = this.range;
    const range = lastRange.slice();
    const axisModel = coordSysInfo.axisModels[0];
    if (!axisModel) {
      return;
    }
    const directionInfo = getDirectionInfo[coordSysMainType](null, [e2.originX, e2.originY], axisModel, controller, coordSysInfo);
    const percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];
    const scale4 = Math.max(1 / e2.scale, 0);
    range[0] = (range[0] - percentPoint) * scale4 + percentPoint;
    range[1] = (range[1] - percentPoint) * scale4 + percentPoint;
    const minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
    sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);
    this.range = range;
    if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
      return range;
    }
  },
  pan: makeMover(function(range, axisModel, coordSysInfo, coordSysMainType, controller, e2) {
    const directionInfo = getDirectionInfo[coordSysMainType]([e2.oldX, e2.oldY], [e2.newX, e2.newY], axisModel, controller, coordSysInfo);
    return directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;
  }),
  scrollMove: makeMover(function(range, axisModel, coordSysInfo, coordSysMainType, controller, e2) {
    const directionInfo = getDirectionInfo[coordSysMainType]([0, 0], [e2.scrollDelta, e2.scrollDelta], axisModel, controller, coordSysInfo);
    return directionInfo.signal * (range[1] - range[0]) * e2.scrollDelta;
  })
};
function makeMover(getPercentDelta) {
  return function(coordSysInfo, coordSysMainType, controller, e2) {
    const lastRange = this.range;
    const range = lastRange.slice();
    const axisModel = coordSysInfo.axisModels[0];
    if (!axisModel) {
      return;
    }
    const percentDelta = getPercentDelta(range, axisModel, coordSysInfo, coordSysMainType, controller, e2);
    sliderMove(percentDelta, range, [0, 100], "all");
    this.range = range;
    if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
      return range;
    }
  };
}
var getDirectionInfo = {
  grid(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
    const axis = axisModel.axis;
    const ret = {};
    const rect = coordSysInfo.model.coordinateSystem.getRect();
    oldPoint = oldPoint || [0, 0];
    if (axis.dim === "x") {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = rect.width;
      ret.pixelStart = rect.x;
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = rect.height;
      ret.pixelStart = rect.y;
      ret.signal = axis.inverse ? -1 : 1;
    }
    return ret;
  },
  polar(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
    const axis = axisModel.axis;
    const ret = {};
    const polar = coordSysInfo.model.coordinateSystem;
    const radiusExtent = polar.getRadiusAxis().getExtent();
    const angleExtent = polar.getAngleAxis().getExtent();
    oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];
    newPoint = polar.pointToCoord(newPoint);
    if (axisModel.mainType === "radiusAxis") {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = radiusExtent[1] - radiusExtent[0];
      ret.pixelStart = radiusExtent[0];
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = angleExtent[1] - angleExtent[0];
      ret.pixelStart = angleExtent[0];
      ret.signal = axis.inverse ? -1 : 1;
    }
    return ret;
  },
  singleAxis(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
    const axis = axisModel.axis;
    const rect = coordSysInfo.model.coordinateSystem.getRect();
    const ret = {};
    oldPoint = oldPoint || [0, 0];
    if (axis.orient === "horizontal") {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = rect.width;
      ret.pixelStart = rect.x;
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = rect.height;
      ret.pixelStart = rect.y;
      ret.signal = axis.inverse ? -1 : 1;
    }
    return ret;
  }
};
var InsideZoomView_default = InsideZoomView;

// src/component/dataZoom/installDataZoomInside.ts
function install49(registers) {
  installCommon(registers);
  registers.registerComponentModel(InsideZoomModel_default);
  registers.registerComponentView(InsideZoomView_default);
  installDataZoomRoamProcessor(registers);
}

// src/component/dataZoom/SliderZoomModel.ts
var SliderZoomModel2 = class extends DataZoomModel_default {
  constructor() {
    super(...arguments);
    this.type = SliderZoomModel2.type;
  }
};
var SliderZoomModel = SliderZoomModel2;
SliderZoomModel.type = "dataZoom.slider";
SliderZoomModel.layoutMode = "box";
SliderZoomModel.defaultOption = inheritDefaultOption(DataZoomModel_default.defaultOption, {
  show: true,
  right: "ph",
  top: "ph",
  width: "ph",
  height: "ph",
  left: null,
  bottom: null,
  borderColor: tokens_default.color.accent10,
  borderRadius: 0,
  backgroundColor: tokens_default.color.transparent,
  dataBackground: {
    lineStyle: {
      color: tokens_default.color.accent30,
      width: 0.5
    },
    areaStyle: {
      color: tokens_default.color.accent20,
      opacity: 0.2
    }
  },
  selectedDataBackground: {
    lineStyle: {
      color: tokens_default.color.accent40,
      width: 0.5
    },
    areaStyle: {
      color: tokens_default.color.accent20,
      opacity: 0.3
    }
  },
  fillerColor: "rgba(135,175,274,0.2)",
  handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
  handleSize: "100%",
  handleStyle: {
    color: tokens_default.color.neutral00,
    borderColor: tokens_default.color.accent20
  },
  moveHandleSize: 7,
  moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
  moveHandleStyle: {
    color: tokens_default.color.accent40,
    opacity: 0.5
  },
  showDetail: true,
  showDataShadow: "auto",
  realtime: true,
  zoomLock: false,
  textStyle: {
    color: tokens_default.color.tertiary
  },
  brushSelect: true,
  brushStyle: {
    color: tokens_default.color.accent30,
    opacity: 0.3
  },
  emphasis: {
    handleLabel: {
      show: true
    },
    handleStyle: {
      borderColor: tokens_default.color.accent40
    },
    moveHandleStyle: {
      opacity: 0.8
    }
  },
  defaultLocationEdgeGap: 15
});
var SliderZoomModel_default = SliderZoomModel;

// src/component/dataZoom/SliderZoomView.ts
var Rect3 = Rect_default;
var DEFAULT_FRAME_BORDER_WIDTH = 1;
var DEFAULT_FILLER_SIZE = 30;
var DEFAULT_MOVE_HANDLE_SIZE = 7;
var HORIZONTAL = "horizontal";
var VERTICAL = "vertical";
var LABEL_GAP = 5;
var SHOW_DATA_SHADOW_SERIES_TYPE = ["line", "bar", "candlestick", "scatter"];
var REALTIME_ANIMATION_CONFIG = {
  easing: "cubicOut",
  duration: 100,
  delay: 0
};
var SliderZoomView2 = class extends DataZoomView_default {
  constructor() {
    super(...arguments);
    this.type = SliderZoomView2.type;
    this._displayables = {};
  }
  init(ecModel, api2) {
    this.api = api2;
    this._onBrush = bind(this._onBrush, this);
    this._onBrushEnd = bind(this._onBrushEnd, this);
  }
  render(dataZoomModel, ecModel, api2, payload) {
    super.render.apply(this, arguments);
    createOrUpdate(this, "_dispatchZoomAction", dataZoomModel.get("throttle"), "fixRate");
    this._orient = dataZoomModel.getOrient();
    if (dataZoomModel.get("show") === false) {
      this.group.removeAll();
      return;
    }
    if (dataZoomModel.noTarget()) {
      this._clear();
      this.group.removeAll();
      return;
    }
    if (!payload || payload.type !== "dataZoom" || payload.from !== this.uid) {
      this._buildView();
    }
    this._updateView();
  }
  dispose() {
    this._clear();
    super.dispose.apply(this, arguments);
  }
  _clear() {
    clear(this, "_dispatchZoomAction");
    const zr = this.api.getZr();
    zr.off("mousemove", this._onBrush);
    zr.off("mouseup", this._onBrushEnd);
  }
  _buildView() {
    const thisGroup = this.group;
    thisGroup.removeAll();
    this._brushing = false;
    this._displayables.brushRect = null;
    this._resetLocation();
    this._resetInterval();
    const barGroup = this._displayables.sliderGroup = new Group_default();
    this._renderBackground();
    this._renderHandle();
    this._renderDataShadow();
    thisGroup.add(barGroup);
    this._positionGroup();
  }
  _resetLocation() {
    const dataZoomModel = this.dataZoomModel;
    const api2 = this.api;
    const showMoveHandle = dataZoomModel.get("brushSelect");
    const moveHandleSize = showMoveHandle ? DEFAULT_MOVE_HANDLE_SIZE : 0;
    const refContainer = createBoxLayoutReference(dataZoomModel, api2).refContainer;
    const coordRect = this._findCoordRect();
    const edgeGap = dataZoomModel.get("defaultLocationEdgeGap", true) || 0;
    const positionInfo = this._orient === HORIZONTAL ? {
      right: refContainer.width - coordRect.x - coordRect.width,
      top: refContainer.height - DEFAULT_FILLER_SIZE - edgeGap - moveHandleSize,
      width: coordRect.width,
      height: DEFAULT_FILLER_SIZE
    } : {
      right: edgeGap,
      top: coordRect.y,
      width: DEFAULT_FILLER_SIZE,
      height: coordRect.height
    };
    const layoutParams = getLayoutParams(dataZoomModel.option);
    each(["right", "top", "width", "height"], function(name) {
      if (layoutParams[name] === "ph") {
        layoutParams[name] = positionInfo[name];
      }
    });
    const layoutRect = getLayoutRect(layoutParams, refContainer);
    this._location = {x: layoutRect.x, y: layoutRect.y};
    this._size = [layoutRect.width, layoutRect.height];
    this._orient === VERTICAL && this._size.reverse();
  }
  _positionGroup() {
    const thisGroup = this.group;
    const location = this._location;
    const orient = this._orient;
    const targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();
    const inverse = targetAxisModel && targetAxisModel.get("inverse");
    const sliderGroup = this._displayables.sliderGroup;
    const otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse;
    sliderGroup.attr(orient === HORIZONTAL && !inverse ? {scaleY: otherAxisInverse ? 1 : -1, scaleX: 1} : orient === HORIZONTAL && inverse ? {scaleY: otherAxisInverse ? 1 : -1, scaleX: -1} : orient === VERTICAL && !inverse ? {scaleY: otherAxisInverse ? -1 : 1, scaleX: 1, rotation: Math.PI / 2} : {scaleY: otherAxisInverse ? -1 : 1, scaleX: -1, rotation: Math.PI / 2});
    const rect = thisGroup.getBoundingRect([sliderGroup]);
    thisGroup.x = location.x - rect.x;
    thisGroup.y = location.y - rect.y;
    thisGroup.markRedraw();
  }
  _getViewExtent() {
    return [0, this._size[0]];
  }
  _renderBackground() {
    const dataZoomModel = this.dataZoomModel;
    const size = this._size;
    const barGroup = this._displayables.sliderGroup;
    const brushSelect = dataZoomModel.get("brushSelect");
    barGroup.add(new Rect3({
      silent: true,
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1]
      },
      style: {
        fill: dataZoomModel.get("backgroundColor")
      },
      z2: -40
    }));
    const clickPanel = new Rect3({
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1]
      },
      style: {
        fill: "transparent"
      },
      z2: 0,
      onclick: bind(this._onClickPanel, this)
    });
    const zr = this.api.getZr();
    if (brushSelect) {
      clickPanel.on("mousedown", this._onBrushStart, this);
      clickPanel.cursor = "crosshair";
      zr.on("mousemove", this._onBrush);
      zr.on("mouseup", this._onBrushEnd);
    } else {
      zr.off("mousemove", this._onBrush);
      zr.off("mouseup", this._onBrushEnd);
    }
    barGroup.add(clickPanel);
  }
  _renderDataShadow() {
    const info = this._dataShadowInfo = this._prepareDataShadowInfo();
    this._displayables.dataShadowSegs = [];
    if (!info) {
      return;
    }
    const size = this._size;
    const oldSize = this._shadowSize || [];
    const seriesModel = info.series;
    const data = seriesModel.getRawData();
    const candlestickDim = seriesModel.getShadowDim && seriesModel.getShadowDim();
    const otherDim = candlestickDim && data.getDimensionInfo(candlestickDim) ? seriesModel.getShadowDim() : info.otherDim;
    if (otherDim == null) {
      return;
    }
    let polygonPts = this._shadowPolygonPts;
    let polylinePts = this._shadowPolylinePts;
    if (data !== this._shadowData || otherDim !== this._shadowDim || size[0] !== oldSize[0] || size[1] !== oldSize[1]) {
      const thisDataExtent = data.getDataExtent(info.thisDim);
      let otherDataExtent = data.getDataExtent(otherDim);
      const otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;
      otherDataExtent = [
        otherDataExtent[0] - otherOffset,
        otherDataExtent[1] + otherOffset
      ];
      const otherShadowExtent = [0, size[1]];
      const thisShadowExtent = [0, size[0]];
      const areaPoints = [[size[0], 0], [0, 0]];
      const linePoints = [];
      const step = thisShadowExtent[1] / Math.max(1, data.count() - 1);
      const normalizationConstant = size[0] / (thisDataExtent[1] - thisDataExtent[0]);
      const isTimeAxis = info.thisAxis.type === "time";
      let thisCoord = -step;
      const stride = Math.round(data.count() / size[0]);
      let lastIsEmpty;
      data.each([info.thisDim, otherDim], function(thisValue, otherValue, index) {
        if (stride > 0 && index % stride) {
          if (!isTimeAxis) {
            thisCoord += step;
          }
          return;
        }
        thisCoord = isTimeAxis ? (+thisValue - thisDataExtent[0]) * normalizationConstant : thisCoord + step;
        const isEmpty = otherValue == null || isNaN(otherValue) || otherValue === "";
        const otherCoord = isEmpty ? 0 : linearMap(otherValue, otherDataExtent, otherShadowExtent, true);
        if (isEmpty && !lastIsEmpty && index) {
          areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);
          linePoints.push([linePoints[linePoints.length - 1][0], 0]);
        } else if (!isEmpty && lastIsEmpty) {
          areaPoints.push([thisCoord, 0]);
          linePoints.push([thisCoord, 0]);
        }
        if (!isEmpty) {
          areaPoints.push([thisCoord, otherCoord]);
          linePoints.push([thisCoord, otherCoord]);
        }
        lastIsEmpty = isEmpty;
      });
      polygonPts = this._shadowPolygonPts = areaPoints;
      polylinePts = this._shadowPolylinePts = linePoints;
    }
    this._shadowData = data;
    this._shadowDim = otherDim;
    this._shadowSize = [size[0], size[1]];
    const dataZoomModel = this.dataZoomModel;
    function createDataShadowGroup(isSelectedArea) {
      const model = dataZoomModel.getModel(isSelectedArea ? "selectedDataBackground" : "dataBackground");
      const group = new Group_default();
      const polygon = new Polygon_default({
        shape: {points: polygonPts},
        segmentIgnoreThreshold: 1,
        style: model.getModel("areaStyle").getAreaStyle(),
        silent: true,
        z2: -20
      });
      const polyline = new Polyline_default({
        shape: {points: polylinePts},
        segmentIgnoreThreshold: 1,
        style: model.getModel("lineStyle").getLineStyle(),
        silent: true,
        z2: -19
      });
      group.add(polygon);
      group.add(polyline);
      return group;
    }
    for (let i = 0; i < 3; i++) {
      const group = createDataShadowGroup(i === 1);
      this._displayables.sliderGroup.add(group);
      this._displayables.dataShadowSegs.push(group);
    }
  }
  _prepareDataShadowInfo() {
    const dataZoomModel = this.dataZoomModel;
    const showDataShadow = dataZoomModel.get("showDataShadow");
    if (showDataShadow === false) {
      return;
    }
    let result;
    const ecModel = this.ecModel;
    dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
      const seriesModels = dataZoomModel.getAxisProxy(axisDim, axisIndex).getTargetSeriesModels();
      each(seriesModels, function(seriesModel) {
        if (result) {
          return;
        }
        if (showDataShadow !== true && indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get("type")) < 0) {
          return;
        }
        const thisAxis = ecModel.getComponent(getAxisMainType(axisDim), axisIndex).axis;
        let otherDim = getOtherDim(axisDim);
        let otherAxisInverse;
        const coordSys = seriesModel.coordinateSystem;
        if (otherDim != null && coordSys.getOtherAxis) {
          otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;
        }
        otherDim = seriesModel.getData().mapDimension(otherDim);
        const thisDim = seriesModel.getData().mapDimension(axisDim);
        result = {
          thisAxis,
          series: seriesModel,
          thisDim,
          otherDim,
          otherAxisInverse
        };
      }, this);
    }, this);
    return result;
  }
  _renderHandle() {
    const thisGroup = this.group;
    const displayables = this._displayables;
    const handles = displayables.handles = [null, null];
    const handleLabels = displayables.handleLabels = [null, null];
    const sliderGroup = this._displayables.sliderGroup;
    const size = this._size;
    const dataZoomModel = this.dataZoomModel;
    const api2 = this.api;
    const borderRadius = dataZoomModel.get("borderRadius") || 0;
    const brushSelect = dataZoomModel.get("brushSelect");
    const filler = displayables.filler = new Rect3({
      silent: brushSelect,
      style: {
        fill: dataZoomModel.get("fillerColor")
      },
      textConfig: {
        position: "inside"
      }
    });
    sliderGroup.add(filler);
    sliderGroup.add(new Rect3({
      silent: true,
      subPixelOptimize: true,
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1],
        r: borderRadius
      },
      style: {
        stroke: dataZoomModel.get("dataBackgroundColor") || dataZoomModel.get("borderColor"),
        lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
        fill: tokens_default.color.transparent
      }
    }));
    each([0, 1], function(handleIndex) {
      let iconStr = dataZoomModel.get("handleIcon");
      if (!symbolBuildProxies[iconStr] && iconStr.indexOf("path://") < 0 && iconStr.indexOf("image://") < 0) {
        iconStr = "path://" + iconStr;
        if (true) {
          deprecateLog("handleIcon now needs 'path://' prefix when using a path string");
        }
      }
      const path = createSymbol(iconStr, -1, 0, 2, 2, null, true);
      path.attr({
        cursor: getCursor(this._orient),
        draggable: true,
        drift: bind(this._onDragMove, this, handleIndex),
        ondragend: bind(this._onDragEnd, this),
        onmouseover: bind(this._showDataInfo, this, true),
        onmouseout: bind(this._showDataInfo, this, false),
        z2: 5
      });
      const bRect = path.getBoundingRect();
      const handleSize = dataZoomModel.get("handleSize");
      this._handleHeight = parsePercent2(handleSize, this._size[1]);
      this._handleWidth = bRect.width / bRect.height * this._handleHeight;
      path.setStyle(dataZoomModel.getModel("handleStyle").getItemStyle());
      path.style.strokeNoScale = true;
      path.rectHover = true;
      path.ensureState("emphasis").style = dataZoomModel.getModel(["emphasis", "handleStyle"]).getItemStyle();
      enableHoverEmphasis(path);
      const handleColor = dataZoomModel.get("handleColor");
      if (handleColor != null) {
        path.style.fill = handleColor;
      }
      sliderGroup.add(handles[handleIndex] = path);
      const textStyleModel = dataZoomModel.getModel("textStyle");
      const handleLabel = dataZoomModel.get("handleLabel") || {};
      const handleLabelShow = handleLabel.show || false;
      thisGroup.add(handleLabels[handleIndex] = new Text_default({
        silent: true,
        invisible: !handleLabelShow,
        style: createTextStyle(textStyleModel, {
          x: 0,
          y: 0,
          text: "",
          verticalAlign: "middle",
          align: "center",
          fill: textStyleModel.getTextColor(),
          font: textStyleModel.getFont()
        }),
        z2: 10
      }));
    }, this);
    let actualMoveZone = filler;
    if (brushSelect) {
      const moveHandleHeight = parsePercent2(dataZoomModel.get("moveHandleSize"), size[1]);
      const moveHandle = displayables.moveHandle = new Rect_default({
        style: dataZoomModel.getModel("moveHandleStyle").getItemStyle(),
        silent: true,
        shape: {
          r: [0, 0, 2, 2],
          y: size[1] - 0.5,
          height: moveHandleHeight
        }
      });
      const iconSize = moveHandleHeight * 0.8;
      const moveHandleIcon = displayables.moveHandleIcon = createSymbol(dataZoomModel.get("moveHandleIcon"), -iconSize / 2, -iconSize / 2, iconSize, iconSize, tokens_default.color.neutral00, true);
      moveHandleIcon.silent = true;
      moveHandleIcon.y = size[1] + moveHandleHeight / 2 - 0.5;
      moveHandle.ensureState("emphasis").style = dataZoomModel.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
      const moveZoneExpandSize = Math.min(size[1] / 2, Math.max(moveHandleHeight, 10));
      actualMoveZone = displayables.moveZone = new Rect_default({
        invisible: true,
        shape: {
          y: size[1] - moveZoneExpandSize,
          height: moveHandleHeight + moveZoneExpandSize
        }
      });
      actualMoveZone.on("mouseover", () => {
        api2.enterEmphasis(moveHandle);
      }).on("mouseout", () => {
        api2.leaveEmphasis(moveHandle);
      });
      sliderGroup.add(moveHandle);
      sliderGroup.add(moveHandleIcon);
      sliderGroup.add(actualMoveZone);
    }
    actualMoveZone.attr({
      draggable: true,
      cursor: "default",
      drift: bind(this._onDragMove, this, "all"),
      ondragstart: bind(this._showDataInfo, this, true),
      ondragend: bind(this._onDragEnd, this),
      onmouseover: bind(this._showDataInfo, this, true),
      onmouseout: bind(this._showDataInfo, this, false)
    });
  }
  _resetInterval() {
    const range = this._range = this.dataZoomModel.getPercentRange();
    const viewExtent = this._getViewExtent();
    this._handleEnds = [
      linearMap(range[0], [0, 100], viewExtent, true),
      linearMap(range[1], [0, 100], viewExtent, true)
    ];
  }
  _updateInterval(handleIndex, delta) {
    const dataZoomModel = this.dataZoomModel;
    const handleEnds = this._handleEnds;
    const viewExtend = this._getViewExtent();
    const minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
    const percentExtent = [0, 100];
    sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get("zoomLock") ? "all" : handleIndex, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);
    const lastRange = this._range;
    const range = this._range = asc([
      linearMap(handleEnds[0], viewExtend, percentExtent, true),
      linearMap(handleEnds[1], viewExtend, percentExtent, true)
    ]);
    return !lastRange || lastRange[0] !== range[0] || lastRange[1] !== range[1];
  }
  _updateView(nonRealtime) {
    const displaybles = this._displayables;
    const handleEnds = this._handleEnds;
    const handleInterval = asc(handleEnds.slice());
    const size = this._size;
    each([0, 1], function(handleIndex) {
      const handle = displaybles.handles[handleIndex];
      const handleHeight = this._handleHeight;
      handle.attr({
        scaleX: handleHeight / 2,
        scaleY: handleHeight / 2,
        x: handleEnds[handleIndex] + (handleIndex ? -1 : 1),
        y: size[1] / 2 - handleHeight / 2
      });
    }, this);
    displaybles.filler.setShape({
      x: handleInterval[0],
      y: 0,
      width: handleInterval[1] - handleInterval[0],
      height: size[1]
    });
    const viewExtent = {
      x: handleInterval[0],
      width: handleInterval[1] - handleInterval[0]
    };
    if (displaybles.moveHandle) {
      displaybles.moveHandle.setShape(viewExtent);
      displaybles.moveZone.setShape(viewExtent);
      displaybles.moveZone.getBoundingRect();
      displaybles.moveHandleIcon && displaybles.moveHandleIcon.attr("x", viewExtent.x + viewExtent.width / 2);
    }
    const dataShadowSegs = displaybles.dataShadowSegs;
    const segIntervals = [0, handleInterval[0], handleInterval[1], size[0]];
    for (let i = 0; i < dataShadowSegs.length; i++) {
      const segGroup = dataShadowSegs[i];
      let clipPath = segGroup.getClipPath();
      if (!clipPath) {
        clipPath = new Rect_default();
        segGroup.setClipPath(clipPath);
      }
      clipPath.setShape({
        x: segIntervals[i],
        y: 0,
        width: segIntervals[i + 1] - segIntervals[i],
        height: size[1]
      });
    }
    this._updateDataInfo(nonRealtime);
  }
  _updateDataInfo(nonRealtime) {
    const dataZoomModel = this.dataZoomModel;
    const displaybles = this._displayables;
    const handleLabels = displaybles.handleLabels;
    const orient = this._orient;
    let labelTexts = ["", ""];
    if (dataZoomModel.get("showDetail")) {
      const axisProxy = dataZoomModel.findRepresentativeAxisProxy();
      if (axisProxy) {
        const axis = axisProxy.getAxisModel().axis;
        const range = this._range;
        const dataInterval = nonRealtime ? axisProxy.calculateDataWindow({
          start: range[0],
          end: range[1]
        }).valueWindow : axisProxy.getDataValueWindow();
        labelTexts = [
          this._formatLabel(dataInterval[0], axis),
          this._formatLabel(dataInterval[1], axis)
        ];
      }
    }
    const orderedHandleEnds = asc(this._handleEnds.slice());
    setLabel.call(this, 0);
    setLabel.call(this, 1);
    function setLabel(handleIndex) {
      const barTransform = getTransform(displaybles.handles[handleIndex].parent, this.group);
      const direction = transformDirection(handleIndex === 0 ? "right" : "left", barTransform);
      const offset = this._handleWidth / 2 + LABEL_GAP;
      const textPoint = applyTransform2([
        orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset),
        this._size[1] / 2
      ], barTransform);
      handleLabels[handleIndex].setStyle({
        x: textPoint[0],
        y: textPoint[1],
        verticalAlign: orient === HORIZONTAL ? "middle" : direction,
        align: orient === HORIZONTAL ? direction : "center",
        text: labelTexts[handleIndex]
      });
    }
  }
  _formatLabel(value, axis) {
    const dataZoomModel = this.dataZoomModel;
    const labelFormatter = dataZoomModel.get("labelFormatter");
    let labelPrecision = dataZoomModel.get("labelPrecision");
    if (labelPrecision == null || labelPrecision === "auto") {
      labelPrecision = axis.getPixelPrecision();
    }
    const valueStr = value == null || isNaN(value) ? "" : axis.type === "category" || axis.type === "time" ? axis.scale.getLabel({
      value: Math.round(value)
    }) : value.toFixed(Math.min(labelPrecision, 20));
    return isFunction(labelFormatter) ? labelFormatter(value, valueStr) : isString(labelFormatter) ? labelFormatter.replace("{value}", valueStr) : valueStr;
  }
  _showDataInfo(isEmphasis) {
    const handleLabel = this.dataZoomModel.get("handleLabel") || {};
    const normalShow = handleLabel.show || false;
    const emphasisHandleLabel = this.dataZoomModel.getModel(["emphasis", "handleLabel"]);
    const emphasisShow = emphasisHandleLabel.get("show") || false;
    const toShow = isEmphasis || this._dragging ? emphasisShow : normalShow;
    const displayables = this._displayables;
    const handleLabels = displayables.handleLabels;
    handleLabels[0].attr("invisible", !toShow);
    handleLabels[1].attr("invisible", !toShow);
    displayables.moveHandle && this.api[toShow ? "enterEmphasis" : "leaveEmphasis"](displayables.moveHandle, 1);
  }
  _onDragMove(handleIndex, dx, dy, event) {
    this._dragging = true;
    stop(event.event);
    const barTransform = this._displayables.sliderGroup.getLocalTransform();
    const vertex = applyTransform2([dx, dy], barTransform, true);
    const changed = this._updateInterval(handleIndex, vertex[0]);
    const realtime = this.dataZoomModel.get("realtime");
    this._updateView(!realtime);
    changed && realtime && this._dispatchZoomAction(true);
  }
  _onDragEnd() {
    this._dragging = false;
    this._showDataInfo(false);
    const realtime = this.dataZoomModel.get("realtime");
    !realtime && this._dispatchZoomAction(false);
  }
  _onClickPanel(e2) {
    const size = this._size;
    const localPoint = this._displayables.sliderGroup.transformCoordToLocal(e2.offsetX, e2.offsetY);
    if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {
      return;
    }
    const handleEnds = this._handleEnds;
    const center3 = (handleEnds[0] + handleEnds[1]) / 2;
    const changed = this._updateInterval("all", localPoint[0] - center3);
    this._updateView();
    changed && this._dispatchZoomAction(false);
  }
  _onBrushStart(e2) {
    const x = e2.offsetX;
    const y = e2.offsetY;
    this._brushStart = new Point_default(x, y);
    this._brushing = true;
    this._brushStartTime = +new Date();
  }
  _onBrushEnd(e2) {
    if (!this._brushing) {
      return;
    }
    const brushRect = this._displayables.brushRect;
    this._brushing = false;
    if (!brushRect) {
      return;
    }
    brushRect.attr("ignore", true);
    const brushShape = brushRect.shape;
    const brushEndTime = +new Date();
    if (brushEndTime - this._brushStartTime < 200 && Math.abs(brushShape.width) < 5) {
      return;
    }
    const viewExtend = this._getViewExtent();
    const percentExtent = [0, 100];
    const handleEnds = this._handleEnds = [brushShape.x, brushShape.x + brushShape.width];
    const minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
    sliderMove(0, handleEnds, viewExtend, 0, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);
    this._range = asc([
      linearMap(handleEnds[0], viewExtend, percentExtent, true),
      linearMap(handleEnds[1], viewExtend, percentExtent, true)
    ]);
    this._updateView();
    this._dispatchZoomAction(false);
  }
  _onBrush(e2) {
    if (this._brushing) {
      stop(e2.event);
      this._updateBrushRect(e2.offsetX, e2.offsetY);
    }
  }
  _updateBrushRect(mouseX, mouseY) {
    const displayables = this._displayables;
    const dataZoomModel = this.dataZoomModel;
    let brushRect = displayables.brushRect;
    if (!brushRect) {
      brushRect = displayables.brushRect = new Rect3({
        silent: true,
        style: dataZoomModel.getModel("brushStyle").getItemStyle()
      });
      displayables.sliderGroup.add(brushRect);
    }
    brushRect.attr("ignore", false);
    const brushStart = this._brushStart;
    const sliderGroup = this._displayables.sliderGroup;
    const endPoint = sliderGroup.transformCoordToLocal(mouseX, mouseY);
    const startPoint = sliderGroup.transformCoordToLocal(brushStart.x, brushStart.y);
    const size = this._size;
    endPoint[0] = Math.max(Math.min(size[0], endPoint[0]), 0);
    brushRect.setShape({
      x: startPoint[0],
      y: 0,
      width: endPoint[0] - startPoint[0],
      height: size[1]
    });
  }
  _dispatchZoomAction(realtime) {
    const range = this._range;
    this.api.dispatchAction({
      type: "dataZoom",
      from: this.uid,
      dataZoomId: this.dataZoomModel.id,
      animation: realtime ? REALTIME_ANIMATION_CONFIG : null,
      start: range[0],
      end: range[1]
    });
  }
  _findCoordRect() {
    let rect;
    const coordSysInfoList = collectReferCoordSysModelInfo(this.dataZoomModel).infoList;
    if (!rect && coordSysInfoList.length) {
      const coordSys = coordSysInfoList[0].model.coordinateSystem;
      rect = coordSys.getRect && coordSys.getRect();
    }
    if (!rect) {
      const width = this.api.getWidth();
      const height = this.api.getHeight();
      rect = {
        x: width * 0.2,
        y: height * 0.2,
        width: width * 0.6,
        height: height * 0.6
      };
    }
    return rect;
  }
};
var SliderZoomView = SliderZoomView2;
SliderZoomView.type = "dataZoom.slider";
function getOtherDim(thisDim) {
  const map3 = {x: "y", y: "x", radius: "angle", angle: "radius"};
  return map3[thisDim];
}
function getCursor(orient) {
  return orient === "vertical" ? "ns-resize" : "ew-resize";
}
var SliderZoomView_default = SliderZoomView;

// src/component/dataZoom/installDataZoomSlider.ts
function install50(registers) {
  registers.registerComponentModel(SliderZoomModel_default);
  registers.registerComponentView(SliderZoomView_default);
  installCommon(registers);
}

// src/component/dataZoom/install.ts
function install51(registers) {
  use(install49);
  use(install50);
}

// src/visual/visualDefault.ts
var visualDefault = {
  get: function(visualType, key, isCategory2) {
    const value = clone((defaultOption2[visualType] || {})[key]);
    return isCategory2 ? isArray(value) ? value[value.length - 1] : value : value;
  }
};
var defaultOption2 = {
  color: {
    active: ["#006edd", "#e0ffff"],
    inactive: [tokens_default.color.transparent]
  },
  colorHue: {
    active: [0, 360],
    inactive: [0, 0]
  },
  colorSaturation: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  colorLightness: {
    active: [0.9, 0.5],
    inactive: [0, 0]
  },
  colorAlpha: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  opacity: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  symbol: {
    active: ["circle", "roundRect", "diamond"],
    inactive: ["none"]
  },
  symbolSize: {
    active: [10, 50],
    inactive: [0, 0]
  }
};
var visualDefault_default = visualDefault;

// src/component/visualMap/VisualMapModel.ts
var mapVisual2 = VisualMapping_default.mapVisual;
var eachVisual = VisualMapping_default.eachVisual;
var isArray2 = isArray;
var each14 = each;
var asc3 = asc;
var linearMap2 = linearMap;
var VisualMapModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = VisualMapModel2.type;
    this.stateList = ["inRange", "outOfRange"];
    this.replacableOptionKeys = [
      "inRange",
      "outOfRange",
      "target",
      "controller",
      "color"
    ];
    this.layoutMode = {
      type: "box",
      ignoreSize: true
    };
    this.dataBound = [-Infinity, Infinity];
    this.targetVisuals = {};
    this.controllerVisuals = {};
  }
  init(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
  }
  optionUpdated(newOption, isInit) {
    const thisOption = this.option;
    !isInit && replaceVisualOption(thisOption, newOption, this.replacableOptionKeys);
    this.textStyleModel = this.getModel("textStyle");
    this.resetItemSize();
    this.completeVisualOption();
  }
  resetVisual(supplementVisualOption) {
    const stateList = this.stateList;
    supplementVisualOption = bind(supplementVisualOption, this);
    this.controllerVisuals = createVisualMappings(this.option.controller, stateList, supplementVisualOption);
    this.targetVisuals = createVisualMappings(this.option.target, stateList, supplementVisualOption);
  }
  getItemSymbol() {
    return null;
  }
  getTargetSeriesIndices() {
    const optionSeriesId = this.option.seriesId;
    let optionSeriesIndex = this.option.seriesIndex;
    if (optionSeriesIndex == null && optionSeriesId == null) {
      optionSeriesIndex = "all";
    }
    const seriesModels = queryReferringComponents(this.ecModel, "series", {
      index: optionSeriesIndex,
      id: optionSeriesId
    }, {
      useDefault: false,
      enableAll: true,
      enableNone: false
    }).models;
    return map(seriesModels, (seriesModel) => seriesModel.componentIndex);
  }
  eachTargetSeries(callback, context) {
    each(this.getTargetSeriesIndices(), function(seriesIndex) {
      const seriesModel = this.ecModel.getSeriesByIndex(seriesIndex);
      if (seriesModel) {
        callback.call(context, seriesModel);
      }
    }, this);
  }
  isTargetSeries(seriesModel) {
    let is = false;
    this.eachTargetSeries(function(model) {
      model === seriesModel && (is = true);
    });
    return is;
  }
  formatValueText(value, isCategory2, edgeSymbols) {
    const option = this.option;
    const precision = option.precision;
    const dataBound = this.dataBound;
    const formatter = option.formatter;
    let isMinMax;
    edgeSymbols = edgeSymbols || ["<", ">"];
    if (isArray(value)) {
      value = value.slice();
      isMinMax = true;
    }
    const textValue = isCategory2 ? value : isMinMax ? [toFixed(value[0]), toFixed(value[1])] : toFixed(value);
    if (isString(formatter)) {
      return formatter.replace("{value}", isMinMax ? textValue[0] : textValue).replace("{value2}", isMinMax ? textValue[1] : textValue);
    } else if (isFunction(formatter)) {
      return isMinMax ? formatter(value[0], value[1]) : formatter(value);
    }
    if (isMinMax) {
      if (value[0] === dataBound[0]) {
        return edgeSymbols[0] + " " + textValue[1];
      } else if (value[1] === dataBound[1]) {
        return edgeSymbols[1] + " " + textValue[0];
      } else {
        return textValue[0] + " - " + textValue[1];
      }
    } else {
      return textValue;
    }
    function toFixed(val) {
      return val === dataBound[0] ? "min" : val === dataBound[1] ? "max" : (+val).toFixed(Math.min(precision, 20));
    }
  }
  resetExtent() {
    const thisOption = this.option;
    const extent = asc3([thisOption.min, thisOption.max]);
    this._dataExtent = extent;
  }
  getDataDimensionIndex(data) {
    const optDim = this.option.dimension;
    if (optDim != null) {
      return data.getDimensionIndex(optDim);
    }
    const dimNames = data.dimensions;
    for (let i = dimNames.length - 1; i >= 0; i--) {
      const dimName = dimNames[i];
      const dimInfo = data.getDimensionInfo(dimName);
      if (!dimInfo.isCalculationCoord) {
        return dimInfo.storeDimIndex;
      }
    }
  }
  getExtent() {
    return this._dataExtent.slice();
  }
  completeVisualOption() {
    const ecModel = this.ecModel;
    const thisOption = this.option;
    const base2 = {
      inRange: thisOption.inRange,
      outOfRange: thisOption.outOfRange
    };
    const target = thisOption.target || (thisOption.target = {});
    const controller = thisOption.controller || (thisOption.controller = {});
    merge(target, base2);
    merge(controller, base2);
    const isCategory2 = this.isCategory();
    completeSingle.call(this, target);
    completeSingle.call(this, controller);
    completeInactive.call(this, target, "inRange", "outOfRange");
    completeController.call(this, controller);
    function completeSingle(base3) {
      if (isArray2(thisOption.color) && !base3.inRange) {
        base3.inRange = {color: thisOption.color.slice().reverse()};
      }
      base3.inRange = base3.inRange || {color: ecModel.get("gradientColor")};
    }
    function completeInactive(base3, stateExist, stateAbsent) {
      const optExist = base3[stateExist];
      let optAbsent = base3[stateAbsent];
      if (optExist && !optAbsent) {
        optAbsent = base3[stateAbsent] = {};
        each14(optExist, function(visualData, visualType) {
          if (!VisualMapping_default.isValidType(visualType)) {
            return;
          }
          const defa = visualDefault_default.get(visualType, "inactive", isCategory2);
          if (defa != null) {
            optAbsent[visualType] = defa;
            if (visualType === "color" && !optAbsent.hasOwnProperty("opacity") && !optAbsent.hasOwnProperty("colorAlpha")) {
              optAbsent.opacity = [0, 0];
            }
          }
        });
      }
    }
    function completeController(controller2) {
      const symbolExists = (controller2.inRange || {}).symbol || (controller2.outOfRange || {}).symbol;
      const symbolSizeExists = (controller2.inRange || {}).symbolSize || (controller2.outOfRange || {}).symbolSize;
      const inactiveColor = this.get("inactiveColor");
      const itemSymbol = this.getItemSymbol();
      const defaultSymbol = itemSymbol || "roundRect";
      each14(this.stateList, function(state) {
        const itemSize = this.itemSize;
        let visuals = controller2[state];
        if (!visuals) {
          visuals = controller2[state] = {
            color: isCategory2 ? inactiveColor : [inactiveColor]
          };
        }
        if (visuals.symbol == null) {
          visuals.symbol = symbolExists && clone(symbolExists) || (isCategory2 ? defaultSymbol : [defaultSymbol]);
        }
        if (visuals.symbolSize == null) {
          visuals.symbolSize = symbolSizeExists && clone(symbolSizeExists) || (isCategory2 ? itemSize[0] : [itemSize[0], itemSize[0]]);
        }
        visuals.symbol = mapVisual2(visuals.symbol, function(symbol) {
          return symbol === "none" ? defaultSymbol : symbol;
        });
        const symbolSize = visuals.symbolSize;
        if (symbolSize != null) {
          let max3 = -Infinity;
          eachVisual(symbolSize, function(value) {
            value > max3 && (max3 = value);
          });
          visuals.symbolSize = mapVisual2(symbolSize, function(value) {
            return linearMap2(value, [0, max3], [0, itemSize[0]], true);
          });
        }
      }, this);
    }
  }
  resetItemSize() {
    this.itemSize = [
      parseFloat(this.get("itemWidth")),
      parseFloat(this.get("itemHeight"))
    ];
  }
  isCategory() {
    return !!this.option.categories;
  }
  setSelected(selected) {
  }
  getSelected() {
    return null;
  }
  getValueState(value) {
    return null;
  }
  getVisualMeta(getColorVisual2) {
    return null;
  }
};
var VisualMapModel = VisualMapModel2;
VisualMapModel.type = "visualMap";
VisualMapModel.dependencies = ["series"];
VisualMapModel.defaultOption = {
  show: true,
  z: 4,
  min: 0,
  max: 200,
  left: 0,
  right: null,
  top: null,
  bottom: 0,
  itemWidth: null,
  itemHeight: null,
  inverse: false,
  orient: "vertical",
  backgroundColor: tokens_default.color.transparent,
  borderColor: tokens_default.color.borderTint,
  contentColor: tokens_default.color.theme[0],
  inactiveColor: tokens_default.color.disabled,
  borderWidth: 0,
  padding: tokens_default.size.m,
  textGap: 10,
  precision: 0,
  textStyle: {
    color: tokens_default.color.secondary
  }
};
var VisualMapModel_default = VisualMapModel;

// src/component/visualMap/ContinuousModel.ts
var DEFAULT_BAR_BOUND = [20, 140];
var ContinuousModel2 = class extends VisualMapModel_default {
  constructor() {
    super(...arguments);
    this.type = ContinuousModel2.type;
  }
  optionUpdated(newOption, isInit) {
    super.optionUpdated.apply(this, arguments);
    this.resetExtent();
    this.resetVisual(function(mappingOption) {
      mappingOption.mappingMethod = "linear";
      mappingOption.dataExtent = this.getExtent();
    });
    this._resetRange();
  }
  resetItemSize() {
    super.resetItemSize.apply(this, arguments);
    const itemSize = this.itemSize;
    (itemSize[0] == null || isNaN(itemSize[0])) && (itemSize[0] = DEFAULT_BAR_BOUND[0]);
    (itemSize[1] == null || isNaN(itemSize[1])) && (itemSize[1] = DEFAULT_BAR_BOUND[1]);
  }
  _resetRange() {
    const dataExtent = this.getExtent();
    const range = this.option.range;
    if (!range || range.auto) {
      dataExtent.auto = 1;
      this.option.range = dataExtent;
    } else if (isArray(range)) {
      if (range[0] > range[1]) {
        range.reverse();
      }
      range[0] = Math.max(range[0], dataExtent[0]);
      range[1] = Math.min(range[1], dataExtent[1]);
    }
  }
  completeVisualOption() {
    super.completeVisualOption.apply(this, arguments);
    each(this.stateList, function(state) {
      const symbolSize = this.option.controller[state].symbolSize;
      if (symbolSize && symbolSize[0] !== symbolSize[1]) {
        symbolSize[0] = symbolSize[1] / 3;
      }
    }, this);
  }
  setSelected(selected) {
    this.option.range = selected.slice();
    this._resetRange();
  }
  getSelected() {
    const dataExtent = this.getExtent();
    const dataInterval = asc((this.get("range") || []).slice());
    dataInterval[0] > dataExtent[1] && (dataInterval[0] = dataExtent[1]);
    dataInterval[1] > dataExtent[1] && (dataInterval[1] = dataExtent[1]);
    dataInterval[0] < dataExtent[0] && (dataInterval[0] = dataExtent[0]);
    dataInterval[1] < dataExtent[0] && (dataInterval[1] = dataExtent[0]);
    return dataInterval;
  }
  getValueState(value) {
    const range = this.option.range;
    const dataExtent = this.getExtent();
    return (range[0] <= dataExtent[0] || range[0] <= value) && (range[1] >= dataExtent[1] || value <= range[1]) ? "inRange" : "outOfRange";
  }
  findTargetDataIndices(range) {
    const result = [];
    this.eachTargetSeries(function(seriesModel) {
      const dataIndices = [];
      const data = seriesModel.getData();
      data.each(this.getDataDimensionIndex(data), function(value, dataIndex) {
        range[0] <= value && value <= range[1] && dataIndices.push(dataIndex);
      }, this);
      result.push({
        seriesId: seriesModel.id,
        dataIndex: dataIndices
      });
    }, this);
    return result;
  }
  getVisualMeta(getColorVisual2) {
    const oVals = getColorStopValues(this, "outOfRange", this.getExtent());
    const iVals = getColorStopValues(this, "inRange", this.option.range.slice());
    const stops = [];
    function setStop(value, valueState) {
      stops.push({
        value,
        color: getColorVisual2(value, valueState)
      });
    }
    let iIdx = 0;
    let oIdx = 0;
    const iLen = iVals.length;
    const oLen = oVals.length;
    for (; oIdx < oLen && (!iVals.length || oVals[oIdx] <= iVals[0]); oIdx++) {
      if (oVals[oIdx] < iVals[iIdx]) {
        setStop(oVals[oIdx], "outOfRange");
      }
    }
    for (let first = 1; iIdx < iLen; iIdx++, first = 0) {
      first && stops.length && setStop(iVals[iIdx], "outOfRange");
      setStop(iVals[iIdx], "inRange");
    }
    for (let first = 1; oIdx < oLen; oIdx++) {
      if (!iVals.length || iVals[iVals.length - 1] < oVals[oIdx]) {
        if (first) {
          stops.length && setStop(stops[stops.length - 1].value, "outOfRange");
          first = 0;
        }
        setStop(oVals[oIdx], "outOfRange");
      }
    }
    const stopsLen = stops.length;
    return {
      stops,
      outerColors: [
        stopsLen ? stops[0].color : "transparent",
        stopsLen ? stops[stopsLen - 1].color : "transparent"
      ]
    };
  }
};
var ContinuousModel = ContinuousModel2;
ContinuousModel.type = "visualMap.continuous";
ContinuousModel.defaultOption = inheritDefaultOption(VisualMapModel_default.defaultOption, {
  align: "auto",
  calculable: false,
  hoverLink: true,
  realtime: true,
  handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
  handleSize: "120%",
  handleStyle: {
    borderColor: tokens_default.color.neutral00,
    borderWidth: 1
  },
  indicatorIcon: "circle",
  indicatorSize: "50%",
  indicatorStyle: {
    borderColor: tokens_default.color.neutral00,
    borderWidth: 2,
    shadowBlur: 2,
    shadowOffsetX: 1,
    shadowOffsetY: 1,
    shadowColor: tokens_default.color.shadow
  }
});
function getColorStopValues(visualMapModel, valueState, dataExtent) {
  if (dataExtent[0] === dataExtent[1]) {
    return dataExtent.slice();
  }
  const count2 = 200;
  const step = (dataExtent[1] - dataExtent[0]) / count2;
  let value = dataExtent[0];
  const stopValues = [];
  for (let i = 0; i <= count2 && value < dataExtent[1]; i++) {
    stopValues.push(value);
    value += step;
  }
  stopValues.push(dataExtent[1]);
  return stopValues;
}
var ContinuousModel_default = ContinuousModel;

// src/component/visualMap/VisualMapView.ts
var VisualMapView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = VisualMapView2.type;
    this.autoPositionValues = {left: 1, right: 1, top: 1, bottom: 1};
  }
  init(ecModel, api2) {
    this.ecModel = ecModel;
    this.api = api2;
  }
  render(visualMapModel, ecModel, api2, payload) {
    this.visualMapModel = visualMapModel;
    if (visualMapModel.get("show") === false) {
      this.group.removeAll();
      return;
    }
    this.doRender(visualMapModel, ecModel, api2, payload);
  }
  renderBackground(group) {
    const visualMapModel = this.visualMapModel;
    const padding = normalizeCssArray2(visualMapModel.get("padding") || 0);
    const rect = group.getBoundingRect();
    group.add(new Rect_default({
      z2: -1,
      silent: true,
      shape: {
        x: rect.x - padding[3],
        y: rect.y - padding[0],
        width: rect.width + padding[3] + padding[1],
        height: rect.height + padding[0] + padding[2]
      },
      style: {
        fill: visualMapModel.get("backgroundColor"),
        stroke: visualMapModel.get("borderColor"),
        lineWidth: visualMapModel.get("borderWidth")
      }
    }));
  }
  getControllerVisual(targetValue, visualCluster, opts) {
    opts = opts || {};
    const forceState = opts.forceState;
    const visualMapModel = this.visualMapModel;
    const visualObj = {};
    if (visualCluster === "color") {
      const defaultColor = visualMapModel.get("contentColor");
      visualObj.color = defaultColor;
    }
    function getter(key) {
      return visualObj[key];
    }
    function setter(key, value) {
      visualObj[key] = value;
    }
    const mappings = visualMapModel.controllerVisuals[forceState || visualMapModel.getValueState(targetValue)];
    const visualTypes = VisualMapping_default.prepareVisualTypes(mappings);
    each(visualTypes, function(type) {
      let visualMapping = mappings[type];
      if (opts.convertOpacityToAlpha && type === "opacity") {
        type = "colorAlpha";
        visualMapping = mappings.__alphaForOpacity;
      }
      if (VisualMapping_default.dependsOn(type, visualCluster)) {
        visualMapping && visualMapping.applyVisual(targetValue, getter, setter);
      }
    });
    return visualObj[visualCluster];
  }
  positionGroup(group) {
    const model = this.visualMapModel;
    const api2 = this.api;
    const refContainer = createBoxLayoutReference(model, api2).refContainer;
    positionElement(group, model.getBoxLayoutParams(), refContainer);
  }
  doRender(visualMapModel, ecModel, api2, payload) {
  }
};
var VisualMapView = VisualMapView2;
VisualMapView.type = "visualMap";
var VisualMapView_default = VisualMapView;

// src/component/visualMap/helper.ts
var paramsSet = [
  ["left", "right", "width"],
  ["top", "bottom", "height"]
];
function getItemAlign(visualMapModel, api2, itemSize) {
  const modelOption = visualMapModel.option;
  const itemAlign = modelOption.align;
  if (itemAlign != null && itemAlign !== "auto") {
    return itemAlign;
  }
  const ecSize = {width: api2.getWidth(), height: api2.getHeight()};
  const realIndex = modelOption.orient === "horizontal" ? 1 : 0;
  const reals = paramsSet[realIndex];
  const fakeValue = [0, null, 10];
  const layoutInput = {};
  for (let i = 0; i < 3; i++) {
    layoutInput[paramsSet[1 - realIndex][i]] = fakeValue[i];
    layoutInput[reals[i]] = i === 2 ? itemSize[0] : modelOption[reals[i]];
  }
  const rParam = [["x", "width", 3], ["y", "height", 0]][realIndex];
  const rect = getLayoutRect(layoutInput, ecSize, modelOption.padding);
  return reals[(rect.margin[rParam[2]] || 0) + rect[rParam[0]] + rect[rParam[1]] * 0.5 < ecSize[rParam[1]] * 0.5 ? 0 : 1];
}
function makeHighDownBatch(batch, visualMapModel) {
  each(batch || [], function(batchItem) {
    if (batchItem.dataIndex != null) {
      batchItem.dataIndexInside = batchItem.dataIndex;
      batchItem.dataIndex = null;
    }
    batchItem.highlightKey = "visualMap" + (visualMapModel ? visualMapModel.componentIndex : "");
  });
  return batch;
}

// src/component/visualMap/ContinuousView.ts
var linearMap3 = linearMap;
var each15 = each;
var mathMin12 = Math.min;
var mathMax12 = Math.max;
var HOVER_LINK_SIZE = 12;
var HOVER_LINK_OUT = 6;
var ContinuousView2 = class extends VisualMapView_default {
  constructor() {
    super(...arguments);
    this.type = ContinuousView2.type;
    this._shapes = {};
    this._dataInterval = [];
    this._handleEnds = [];
    this._hoverLinkDataIndices = [];
  }
  init(ecModel, api2) {
    super.init(ecModel, api2);
    this._hoverLinkFromSeriesMouseOver = bind(this._hoverLinkFromSeriesMouseOver, this);
    this._hideIndicator = bind(this._hideIndicator, this);
  }
  doRender(visualMapModel, ecModel, api2, payload) {
    if (!payload || payload.type !== "selectDataRange" || payload.from !== this.uid) {
      this._buildView();
    }
  }
  _buildView() {
    this.group.removeAll();
    const visualMapModel = this.visualMapModel;
    const thisGroup = this.group;
    this._orient = visualMapModel.get("orient");
    this._useHandle = visualMapModel.get("calculable");
    this._resetInterval();
    this._renderBar(thisGroup);
    const dataRangeText = visualMapModel.get("text");
    this._renderEndsText(thisGroup, dataRangeText, 0);
    this._renderEndsText(thisGroup, dataRangeText, 1);
    this._updateView(true);
    this.renderBackground(thisGroup);
    this._updateView();
    this._enableHoverLinkToSeries();
    this._enableHoverLinkFromSeries();
    this.positionGroup(thisGroup);
  }
  _renderEndsText(group, dataRangeText, endsIndex) {
    if (!dataRangeText) {
      return;
    }
    let text = dataRangeText[1 - endsIndex];
    text = text != null ? text + "" : "";
    const visualMapModel = this.visualMapModel;
    const textGap = visualMapModel.get("textGap");
    const itemSize = visualMapModel.itemSize;
    const barGroup = this._shapes.mainGroup;
    const position2 = this._applyTransform([
      itemSize[0] / 2,
      endsIndex === 0 ? -textGap : itemSize[1] + textGap
    ], barGroup);
    const align = this._applyTransform(endsIndex === 0 ? "bottom" : "top", barGroup);
    const orient = this._orient;
    const textStyleModel = this.visualMapModel.textStyleModel;
    this.group.add(new Text_default({
      style: createTextStyle(textStyleModel, {
        x: position2[0],
        y: position2[1],
        verticalAlign: textStyleModel.get("verticalAlign") || (orient === "horizontal" ? "middle" : align),
        align: textStyleModel.get("align") || (orient === "horizontal" ? align : "center"),
        text
      })
    }));
  }
  _renderBar(targetGroup) {
    const visualMapModel = this.visualMapModel;
    const shapes = this._shapes;
    const itemSize = visualMapModel.itemSize;
    const orient = this._orient;
    const useHandle = this._useHandle;
    const itemAlign = getItemAlign(visualMapModel, this.api, itemSize);
    const mainGroup = shapes.mainGroup = this._createBarGroup(itemAlign);
    const gradientBarGroup = new Group_default();
    mainGroup.add(gradientBarGroup);
    gradientBarGroup.add(shapes.outOfRange = createPolygon());
    gradientBarGroup.add(shapes.inRange = createPolygon(null, useHandle ? getCursor2(this._orient) : null, bind(this._dragHandle, this, "all", false), bind(this._dragHandle, this, "all", true)));
    gradientBarGroup.setClipPath(new Rect_default({
      shape: {
        x: 0,
        y: 0,
        width: itemSize[0],
        height: itemSize[1],
        r: 3
      }
    }));
    const textRect = visualMapModel.textStyleModel.getTextRect("\u56FD");
    const textSize = mathMax12(textRect.width, textRect.height);
    if (useHandle) {
      shapes.handleThumbs = [];
      shapes.handleLabels = [];
      shapes.handleLabelPoints = [];
      this._createHandle(visualMapModel, mainGroup, 0, itemSize, textSize, orient);
      this._createHandle(visualMapModel, mainGroup, 1, itemSize, textSize, orient);
    }
    this._createIndicator(visualMapModel, mainGroup, itemSize, textSize, orient);
    targetGroup.add(mainGroup);
  }
  _createHandle(visualMapModel, mainGroup, handleIndex, itemSize, textSize, orient) {
    const onDrift = bind(this._dragHandle, this, handleIndex, false);
    const onDragEnd = bind(this._dragHandle, this, handleIndex, true);
    const handleSize = parsePercent(visualMapModel.get("handleSize"), itemSize[0]);
    const handleThumb = createSymbol(visualMapModel.get("handleIcon"), -handleSize / 2, -handleSize / 2, handleSize, handleSize, null, true);
    const cursor = getCursor2(this._orient);
    handleThumb.attr({
      cursor,
      draggable: true,
      drift: onDrift,
      ondragend: onDragEnd,
      onmousemove(e2) {
        stop(e2.event);
      }
    });
    handleThumb.x = itemSize[0] / 2;
    handleThumb.useStyle(visualMapModel.getModel("handleStyle").getItemStyle());
    handleThumb.setStyle({
      strokeNoScale: true,
      strokeFirst: true
    });
    handleThumb.style.lineWidth *= 2;
    handleThumb.ensureState("emphasis").style = visualMapModel.getModel(["emphasis", "handleStyle"]).getItemStyle();
    setAsHighDownDispatcher(handleThumb, true);
    mainGroup.add(handleThumb);
    const textStyleModel = this.visualMapModel.textStyleModel;
    const handleLabel = new Text_default({
      cursor,
      draggable: true,
      drift: onDrift,
      onmousemove(e2) {
        stop(e2.event);
      },
      ondragend: onDragEnd,
      style: createTextStyle(textStyleModel, {
        x: 0,
        y: 0,
        text: ""
      })
    });
    handleLabel.ensureState("blur").style = {
      opacity: 0.1
    };
    handleLabel.stateTransition = {duration: 200};
    this.group.add(handleLabel);
    const handleLabelPoint = [handleSize, 0];
    const shapes = this._shapes;
    shapes.handleThumbs[handleIndex] = handleThumb;
    shapes.handleLabelPoints[handleIndex] = handleLabelPoint;
    shapes.handleLabels[handleIndex] = handleLabel;
  }
  _createIndicator(visualMapModel, mainGroup, itemSize, textSize, orient) {
    const scale4 = parsePercent(visualMapModel.get("indicatorSize"), itemSize[0]);
    const indicator = createSymbol(visualMapModel.get("indicatorIcon"), -scale4 / 2, -scale4 / 2, scale4, scale4, null, true);
    indicator.attr({
      cursor: "move",
      invisible: true,
      silent: true,
      x: itemSize[0] / 2
    });
    const indicatorStyle = visualMapModel.getModel("indicatorStyle").getItemStyle();
    if (indicator instanceof Image_default) {
      const pathStyle = indicator.style;
      indicator.useStyle(extend({
        image: pathStyle.image,
        x: pathStyle.x,
        y: pathStyle.y,
        width: pathStyle.width,
        height: pathStyle.height
      }, indicatorStyle));
    } else {
      indicator.useStyle(indicatorStyle);
    }
    mainGroup.add(indicator);
    const textStyleModel = this.visualMapModel.textStyleModel;
    const indicatorLabel = new Text_default({
      silent: true,
      invisible: true,
      style: createTextStyle(textStyleModel, {
        x: 0,
        y: 0,
        text: ""
      })
    });
    this.group.add(indicatorLabel);
    const indicatorLabelPoint = [
      (orient === "horizontal" ? textSize / 2 : HOVER_LINK_OUT) + itemSize[0] / 2,
      0
    ];
    const shapes = this._shapes;
    shapes.indicator = indicator;
    shapes.indicatorLabel = indicatorLabel;
    shapes.indicatorLabelPoint = indicatorLabelPoint;
    this._firstShowIndicator = true;
  }
  _dragHandle(handleIndex, isEnd, dx, dy) {
    if (!this._useHandle) {
      return;
    }
    this._dragging = !isEnd;
    if (!isEnd) {
      const vertex = this._applyTransform([dx, dy], this._shapes.mainGroup, true);
      this._updateInterval(handleIndex, vertex[1]);
      this._hideIndicator();
      this._updateView();
    }
    if (isEnd === !this.visualMapModel.get("realtime")) {
      this.api.dispatchAction({
        type: "selectDataRange",
        from: this.uid,
        visualMapId: this.visualMapModel.id,
        selected: this._dataInterval.slice()
      });
    }
    if (isEnd) {
      !this._hovering && this._clearHoverLinkToSeries();
    } else if (useHoverLinkOnHandle(this.visualMapModel)) {
      this._doHoverLinkToSeries(this._handleEnds[handleIndex], false);
    }
  }
  _resetInterval() {
    const visualMapModel = this.visualMapModel;
    const dataInterval = this._dataInterval = visualMapModel.getSelected();
    const dataExtent = visualMapModel.getExtent();
    const sizeExtent = [0, visualMapModel.itemSize[1]];
    this._handleEnds = [
      linearMap3(dataInterval[0], dataExtent, sizeExtent, true),
      linearMap3(dataInterval[1], dataExtent, sizeExtent, true)
    ];
  }
  _updateInterval(handleIndex, delta) {
    delta = delta || 0;
    const visualMapModel = this.visualMapModel;
    const handleEnds = this._handleEnds;
    const sizeExtent = [0, visualMapModel.itemSize[1]];
    sliderMove(delta, handleEnds, sizeExtent, handleIndex, 0);
    const dataExtent = visualMapModel.getExtent();
    this._dataInterval = [
      linearMap3(handleEnds[0], sizeExtent, dataExtent, true),
      linearMap3(handleEnds[1], sizeExtent, dataExtent, true)
    ];
  }
  _updateView(forSketch) {
    const visualMapModel = this.visualMapModel;
    const dataExtent = visualMapModel.getExtent();
    const shapes = this._shapes;
    const outOfRangeHandleEnds = [0, visualMapModel.itemSize[1]];
    const inRangeHandleEnds = forSketch ? outOfRangeHandleEnds : this._handleEnds;
    const visualInRange = this._createBarVisual(this._dataInterval, dataExtent, inRangeHandleEnds, "inRange");
    const visualOutOfRange = this._createBarVisual(dataExtent, dataExtent, outOfRangeHandleEnds, "outOfRange");
    shapes.inRange.setStyle({
      fill: visualInRange.barColor
    }).setShape("points", visualInRange.barPoints);
    shapes.outOfRange.setStyle({
      fill: visualOutOfRange.barColor
    }).setShape("points", visualOutOfRange.barPoints);
    this._updateHandle(inRangeHandleEnds, visualInRange);
  }
  _createBarVisual(dataInterval, dataExtent, handleEnds, forceState) {
    const opts = {
      forceState,
      convertOpacityToAlpha: true
    };
    const colorStops = this._makeColorGradient(dataInterval, opts);
    const symbolSizes = [
      this.getControllerVisual(dataInterval[0], "symbolSize", opts),
      this.getControllerVisual(dataInterval[1], "symbolSize", opts)
    ];
    const barPoints = this._createBarPoints(handleEnds, symbolSizes);
    return {
      barColor: new LinearGradient_default(0, 0, 0, 1, colorStops),
      barPoints,
      handlesColor: [
        colorStops[0].color,
        colorStops[colorStops.length - 1].color
      ]
    };
  }
  _makeColorGradient(dataInterval, opts) {
    const sampleNumber = 100;
    const colorStops = [];
    const step = (dataInterval[1] - dataInterval[0]) / sampleNumber;
    colorStops.push({
      color: this.getControllerVisual(dataInterval[0], "color", opts),
      offset: 0
    });
    for (let i = 1; i < sampleNumber; i++) {
      const currValue = dataInterval[0] + step * i;
      if (currValue > dataInterval[1]) {
        break;
      }
      colorStops.push({
        color: this.getControllerVisual(currValue, "color", opts),
        offset: i / sampleNumber
      });
    }
    colorStops.push({
      color: this.getControllerVisual(dataInterval[1], "color", opts),
      offset: 1
    });
    return colorStops;
  }
  _createBarPoints(handleEnds, symbolSizes) {
    const itemSize = this.visualMapModel.itemSize;
    return [
      [itemSize[0] - symbolSizes[0], handleEnds[0]],
      [itemSize[0], handleEnds[0]],
      [itemSize[0], handleEnds[1]],
      [itemSize[0] - symbolSizes[1], handleEnds[1]]
    ];
  }
  _createBarGroup(itemAlign) {
    const orient = this._orient;
    const inverse = this.visualMapModel.get("inverse");
    return new Group_default(orient === "horizontal" && !inverse ? {scaleX: itemAlign === "bottom" ? 1 : -1, rotation: Math.PI / 2} : orient === "horizontal" && inverse ? {scaleX: itemAlign === "bottom" ? -1 : 1, rotation: -Math.PI / 2} : orient === "vertical" && !inverse ? {scaleX: itemAlign === "left" ? 1 : -1, scaleY: -1} : {scaleX: itemAlign === "left" ? 1 : -1});
  }
  _updateHandle(handleEnds, visualInRange) {
    if (!this._useHandle) {
      return;
    }
    const shapes = this._shapes;
    const visualMapModel = this.visualMapModel;
    const handleThumbs = shapes.handleThumbs;
    const handleLabels = shapes.handleLabels;
    const itemSize = visualMapModel.itemSize;
    const dataExtent = visualMapModel.getExtent();
    const align = this._applyTransform("left", shapes.mainGroup);
    each15([0, 1], function(handleIndex) {
      const handleThumb = handleThumbs[handleIndex];
      handleThumb.setStyle("fill", visualInRange.handlesColor[handleIndex]);
      handleThumb.y = handleEnds[handleIndex];
      const val = linearMap3(handleEnds[handleIndex], [0, itemSize[1]], dataExtent, true);
      const symbolSize = this.getControllerVisual(val, "symbolSize");
      handleThumb.scaleX = handleThumb.scaleY = symbolSize / itemSize[0];
      handleThumb.x = itemSize[0] - symbolSize / 2;
      const textPoint = applyTransform2(shapes.handleLabelPoints[handleIndex], getTransform(handleThumb, this.group));
      if (this._orient === "horizontal") {
        const minimumOffset = align === "left" || align === "top" ? (itemSize[0] - symbolSize) / 2 : (itemSize[0] - symbolSize) / -2;
        textPoint[1] += minimumOffset;
      }
      handleLabels[handleIndex].setStyle({
        x: textPoint[0],
        y: textPoint[1],
        text: visualMapModel.formatValueText(this._dataInterval[handleIndex]),
        verticalAlign: "middle",
        align: this._orient === "vertical" ? this._applyTransform("left", shapes.mainGroup) : "center"
      });
    }, this);
  }
  _showIndicator(cursorValue, textValue, rangeSymbol, halfHoverLinkSize) {
    const visualMapModel = this.visualMapModel;
    const dataExtent = visualMapModel.getExtent();
    const itemSize = visualMapModel.itemSize;
    const sizeExtent = [0, itemSize[1]];
    const shapes = this._shapes;
    const indicator = shapes.indicator;
    if (!indicator) {
      return;
    }
    indicator.attr("invisible", false);
    const opts = {convertOpacityToAlpha: true};
    const color4 = this.getControllerVisual(cursorValue, "color", opts);
    const symbolSize = this.getControllerVisual(cursorValue, "symbolSize");
    const y = linearMap3(cursorValue, dataExtent, sizeExtent, true);
    const x = itemSize[0] - symbolSize / 2;
    const oldIndicatorPos = {x: indicator.x, y: indicator.y};
    indicator.y = y;
    indicator.x = x;
    const textPoint = applyTransform2(shapes.indicatorLabelPoint, getTransform(indicator, this.group));
    const indicatorLabel = shapes.indicatorLabel;
    indicatorLabel.attr("invisible", false);
    const align = this._applyTransform("left", shapes.mainGroup);
    const orient = this._orient;
    const isHorizontal = orient === "horizontal";
    indicatorLabel.setStyle({
      text: (rangeSymbol ? rangeSymbol : "") + visualMapModel.formatValueText(textValue),
      verticalAlign: isHorizontal ? align : "middle",
      align: isHorizontal ? "center" : align
    });
    const indicatorNewProps = {
      x,
      y,
      style: {
        fill: color4
      }
    };
    const labelNewProps = {
      style: {
        x: textPoint[0],
        y: textPoint[1]
      }
    };
    if (visualMapModel.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
      const animationCfg = {
        duration: 100,
        easing: "cubicInOut",
        additive: true
      };
      indicator.x = oldIndicatorPos.x;
      indicator.y = oldIndicatorPos.y;
      indicator.animateTo(indicatorNewProps, animationCfg);
      indicatorLabel.animateTo(labelNewProps, animationCfg);
    } else {
      indicator.attr(indicatorNewProps);
      indicatorLabel.attr(labelNewProps);
    }
    this._firstShowIndicator = false;
    const handleLabels = this._shapes.handleLabels;
    if (handleLabels) {
      for (let i = 0; i < handleLabels.length; i++) {
        this.api.enterBlur(handleLabels[i]);
      }
    }
  }
  _enableHoverLinkToSeries() {
    const self2 = this;
    this._shapes.mainGroup.on("mousemove", function(e2) {
      self2._hovering = true;
      if (!self2._dragging) {
        const itemSize = self2.visualMapModel.itemSize;
        const pos = self2._applyTransform([e2.offsetX, e2.offsetY], self2._shapes.mainGroup, true, true);
        pos[1] = mathMin12(mathMax12(0, pos[1]), itemSize[1]);
        self2._doHoverLinkToSeries(pos[1], 0 <= pos[0] && pos[0] <= itemSize[0]);
      }
    }).on("mouseout", function() {
      self2._hovering = false;
      !self2._dragging && self2._clearHoverLinkToSeries();
    });
  }
  _enableHoverLinkFromSeries() {
    const zr = this.api.getZr();
    if (this.visualMapModel.option.hoverLink) {
      zr.on("mouseover", this._hoverLinkFromSeriesMouseOver, this);
      zr.on("mouseout", this._hideIndicator, this);
    } else {
      this._clearHoverLinkFromSeries();
    }
  }
  _doHoverLinkToSeries(cursorPos, hoverOnBar) {
    const visualMapModel = this.visualMapModel;
    const itemSize = visualMapModel.itemSize;
    if (!visualMapModel.option.hoverLink) {
      return;
    }
    const sizeExtent = [0, itemSize[1]];
    const dataExtent = visualMapModel.getExtent();
    cursorPos = mathMin12(mathMax12(sizeExtent[0], cursorPos), sizeExtent[1]);
    const halfHoverLinkSize = getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent);
    const hoverRange = [cursorPos - halfHoverLinkSize, cursorPos + halfHoverLinkSize];
    const cursorValue = linearMap3(cursorPos, sizeExtent, dataExtent, true);
    const valueRange = [
      linearMap3(hoverRange[0], sizeExtent, dataExtent, true),
      linearMap3(hoverRange[1], sizeExtent, dataExtent, true)
    ];
    hoverRange[0] < sizeExtent[0] && (valueRange[0] = -Infinity);
    hoverRange[1] > sizeExtent[1] && (valueRange[1] = Infinity);
    if (hoverOnBar) {
      if (valueRange[0] === -Infinity) {
        this._showIndicator(cursorValue, valueRange[1], "< ", halfHoverLinkSize);
      } else if (valueRange[1] === Infinity) {
        this._showIndicator(cursorValue, valueRange[0], "> ", halfHoverLinkSize);
      } else {
        this._showIndicator(cursorValue, cursorValue, "\u2248 ", halfHoverLinkSize);
      }
    }
    const oldBatch = this._hoverLinkDataIndices;
    let newBatch = [];
    if (hoverOnBar || useHoverLinkOnHandle(visualMapModel)) {
      newBatch = this._hoverLinkDataIndices = visualMapModel.findTargetDataIndices(valueRange);
    }
    const resultBatches = compressBatches(oldBatch, newBatch);
    this._dispatchHighDown("downplay", makeHighDownBatch(resultBatches[0], visualMapModel));
    this._dispatchHighDown("highlight", makeHighDownBatch(resultBatches[1], visualMapModel));
  }
  _hoverLinkFromSeriesMouseOver(e2) {
    let ecData;
    findEventDispatcher(e2.target, (target) => {
      const currECData = getECData(target);
      if (currECData.dataIndex != null) {
        ecData = currECData;
        return true;
      }
    }, true);
    if (!ecData) {
      return;
    }
    const dataModel = this.ecModel.getSeriesByIndex(ecData.seriesIndex);
    const visualMapModel = this.visualMapModel;
    if (!visualMapModel.isTargetSeries(dataModel)) {
      return;
    }
    const data = dataModel.getData(ecData.dataType);
    const value = data.getStore().get(visualMapModel.getDataDimensionIndex(data), ecData.dataIndex);
    if (!isNaN(value)) {
      this._showIndicator(value, value);
    }
  }
  _hideIndicator() {
    const shapes = this._shapes;
    shapes.indicator && shapes.indicator.attr("invisible", true);
    shapes.indicatorLabel && shapes.indicatorLabel.attr("invisible", true);
    const handleLabels = this._shapes.handleLabels;
    if (handleLabels) {
      for (let i = 0; i < handleLabels.length; i++) {
        this.api.leaveBlur(handleLabels[i]);
      }
    }
  }
  _clearHoverLinkToSeries() {
    this._hideIndicator();
    const indices = this._hoverLinkDataIndices;
    this._dispatchHighDown("downplay", makeHighDownBatch(indices, this.visualMapModel));
    indices.length = 0;
  }
  _clearHoverLinkFromSeries() {
    this._hideIndicator();
    const zr = this.api.getZr();
    zr.off("mouseover", this._hoverLinkFromSeriesMouseOver);
    zr.off("mouseout", this._hideIndicator);
  }
  _applyTransform(vertex, element, inverse, global2) {
    const transform2 = getTransform(element, global2 ? null : this.group);
    return isArray(vertex) ? applyTransform2(vertex, transform2, inverse) : transformDirection(vertex, transform2, inverse);
  }
  _dispatchHighDown(type, batch) {
    batch && batch.length && this.api.dispatchAction({
      type,
      batch
    });
  }
  dispose() {
    this._clearHoverLinkFromSeries();
    this._clearHoverLinkToSeries();
  }
};
var ContinuousView = ContinuousView2;
ContinuousView.type = "visualMap.continuous";
function createPolygon(points4, cursor, onDrift, onDragEnd) {
  return new Polygon_default({
    shape: {points: points4},
    draggable: !!onDrift,
    cursor,
    drift: onDrift,
    onmousemove(e2) {
      stop(e2.event);
    },
    ondragend: onDragEnd
  });
}
function getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent) {
  let halfHoverLinkSize = HOVER_LINK_SIZE / 2;
  const hoverLinkDataSize = visualMapModel.get("hoverLinkDataSize");
  if (hoverLinkDataSize) {
    halfHoverLinkSize = linearMap3(hoverLinkDataSize, dataExtent, sizeExtent, true) / 2;
  }
  return halfHoverLinkSize;
}
function useHoverLinkOnHandle(visualMapModel) {
  const hoverLinkOnHandle = visualMapModel.get("hoverLinkOnHandle");
  return !!(hoverLinkOnHandle == null ? visualMapModel.get("realtime") : hoverLinkOnHandle);
}
function getCursor2(orient) {
  return orient === "vertical" ? "ns-resize" : "ew-resize";
}
var ContinuousView_default = ContinuousView;

// src/component/visualMap/visualMapAction.ts
var visualMapActionInfo = {
  type: "selectDataRange",
  event: "dataRangeSelected",
  update: "update"
};
var visualMapActionHander = function(payload, ecModel) {
  ecModel.eachComponent({mainType: "visualMap", query: payload}, function(model) {
    model.setSelected(payload.selected);
  });
};

// src/component/visualMap/visualEncoding.ts
var visualMapEncodingHandlers = [
  {
    createOnAllSeries: true,
    reset: function(seriesModel, ecModel) {
      const resetDefines = [];
      ecModel.eachComponent("visualMap", function(visualMapModel) {
        const pipelineContext = seriesModel.pipelineContext;
        if (!visualMapModel.isTargetSeries(seriesModel) || pipelineContext && pipelineContext.large) {
          return;
        }
        resetDefines.push(incrementalApplyVisual(visualMapModel.stateList, visualMapModel.targetVisuals, bind(visualMapModel.getValueState, visualMapModel), visualMapModel.getDataDimensionIndex(seriesModel.getData())));
      });
      return resetDefines;
    }
  },
  {
    createOnAllSeries: true,
    reset: function(seriesModel, ecModel) {
      const data = seriesModel.getData();
      const visualMetaList = [];
      ecModel.eachComponent("visualMap", function(visualMapModel) {
        if (visualMapModel.isTargetSeries(seriesModel)) {
          const visualMeta = visualMapModel.getVisualMeta(bind(getColorVisual, null, seriesModel, visualMapModel)) || {
            stops: [],
            outerColors: []
          };
          const dimIdx = visualMapModel.getDataDimensionIndex(data);
          if (dimIdx >= 0) {
            visualMeta.dimension = dimIdx;
            visualMetaList.push(visualMeta);
          }
        }
      });
      seriesModel.getData().setVisual("visualMeta", visualMetaList);
    }
  }
];
function getColorVisual(seriesModel, visualMapModel, value, valueState) {
  const mappings = visualMapModel.targetVisuals[valueState];
  const visualTypes = VisualMapping_default.prepareVisualTypes(mappings);
  const resultVisual = {
    color: getVisualFromData(seriesModel.getData(), "color")
  };
  for (let i = 0, len2 = visualTypes.length; i < len2; i++) {
    const type = visualTypes[i];
    const mapping = mappings[type === "opacity" ? "__alphaForOpacity" : type];
    mapping && mapping.applyVisual(value, getVisual, setVisual);
  }
  return resultVisual.color;
  function getVisual(key) {
    return resultVisual[key];
  }
  function setVisual(key, value2) {
    resultVisual[key] = value2;
  }
}

// src/component/visualMap/preprocessor.ts
var each16 = each;
function visualMapPreprocessor(option) {
  let visualMap = option && option.visualMap;
  if (!isArray(visualMap)) {
    visualMap = visualMap ? [visualMap] : [];
  }
  each16(visualMap, function(opt) {
    if (!opt) {
      return;
    }
    if (has2(opt, "splitList") && !has2(opt, "pieces")) {
      opt.pieces = opt.splitList;
      delete opt.splitList;
    }
    const pieces = opt.pieces;
    if (pieces && isArray(pieces)) {
      each16(pieces, function(piece) {
        if (isObject(piece)) {
          if (has2(piece, "start") && !has2(piece, "min")) {
            piece.min = piece.start;
          }
          if (has2(piece, "end") && !has2(piece, "max")) {
            piece.max = piece.end;
          }
        }
      });
    }
  });
}
function has2(obj, name) {
  return obj && obj.hasOwnProperty && obj.hasOwnProperty(name);
}

// src/component/visualMap/installCommon.ts
var installed2 = false;
function installCommon2(registers) {
  if (installed2) {
    return;
  }
  installed2 = true;
  registers.registerSubTypeDefaulter("visualMap", function(option) {
    return !option.categories && (!(option.pieces ? option.pieces.length > 0 : option.splitNumber > 0) || option.calculable) ? "continuous" : "piecewise";
  });
  registers.registerAction(visualMapActionInfo, visualMapActionHander);
  each(visualMapEncodingHandlers, (handler) => {
    registers.registerVisual(registers.PRIORITY.VISUAL.COMPONENT, handler);
  });
  registers.registerPreprocessor(visualMapPreprocessor);
}

// src/component/visualMap/installVisualMapContinuous.ts
function install52(registers) {
  registers.registerComponentModel(ContinuousModel_default);
  registers.registerComponentView(ContinuousView_default);
  installCommon2(registers);
}

// src/component/visualMap/PiecewiseModel.ts
var PiecewiseModel2 = class extends VisualMapModel_default {
  constructor() {
    super(...arguments);
    this.type = PiecewiseModel2.type;
    this._pieceList = [];
  }
  optionUpdated(newOption, isInit) {
    super.optionUpdated.apply(this, arguments);
    this.resetExtent();
    const mode = this._mode = this._determineMode();
    this._pieceList = [];
    resetMethods[this._mode].call(this, this._pieceList);
    this._resetSelected(newOption, isInit);
    const categories = this.option.categories;
    this.resetVisual(function(mappingOption, state) {
      if (mode === "categories") {
        mappingOption.mappingMethod = "category";
        mappingOption.categories = clone(categories);
      } else {
        mappingOption.dataExtent = this.getExtent();
        mappingOption.mappingMethod = "piecewise";
        mappingOption.pieceList = map(this._pieceList, function(piece) {
          piece = clone(piece);
          if (state !== "inRange") {
            piece.visual = null;
          }
          return piece;
        });
      }
    });
  }
  completeVisualOption() {
    const option = this.option;
    const visualTypesInPieces = {};
    const visualTypes = VisualMapping_default.listVisualTypes();
    const isCategory2 = this.isCategory();
    each(option.pieces, function(piece) {
      each(visualTypes, function(visualType) {
        if (piece.hasOwnProperty(visualType)) {
          visualTypesInPieces[visualType] = 1;
        }
      });
    });
    each(visualTypesInPieces, function(v, visualType) {
      let exists = false;
      each(this.stateList, function(state) {
        exists = exists || has3(option, state, visualType) || has3(option.target, state, visualType);
      }, this);
      !exists && each(this.stateList, function(state) {
        (option[state] || (option[state] = {}))[visualType] = visualDefault_default.get(visualType, state === "inRange" ? "active" : "inactive", isCategory2);
      });
    }, this);
    function has3(obj, state, visualType) {
      return obj && obj[state] && obj[state].hasOwnProperty(visualType);
    }
    super.completeVisualOption.apply(this, arguments);
  }
  _resetSelected(newOption, isInit) {
    const thisOption = this.option;
    const pieceList = this._pieceList;
    const selected = (isInit ? thisOption : newOption).selected || {};
    thisOption.selected = selected;
    each(pieceList, function(piece, index) {
      const key = this.getSelectedMapKey(piece);
      if (!selected.hasOwnProperty(key)) {
        selected[key] = true;
      }
    }, this);
    if (thisOption.selectedMode === "single") {
      let hasSel = false;
      each(pieceList, function(piece, index) {
        const key = this.getSelectedMapKey(piece);
        if (selected[key]) {
          hasSel ? selected[key] = false : hasSel = true;
        }
      }, this);
    }
  }
  getItemSymbol() {
    return this.get("itemSymbol");
  }
  getSelectedMapKey(piece) {
    return this._mode === "categories" ? piece.value + "" : piece.index + "";
  }
  getPieceList() {
    return this._pieceList;
  }
  _determineMode() {
    const option = this.option;
    return option.pieces && option.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
  }
  setSelected(selected) {
    this.option.selected = clone(selected);
  }
  getValueState(value) {
    const index = VisualMapping_default.findPieceIndex(value, this._pieceList);
    return index != null ? this.option.selected[this.getSelectedMapKey(this._pieceList[index])] ? "inRange" : "outOfRange" : "outOfRange";
  }
  findTargetDataIndices(pieceIndex) {
    const result = [];
    const pieceList = this._pieceList;
    this.eachTargetSeries(function(seriesModel) {
      const dataIndices = [];
      const data = seriesModel.getData();
      data.each(this.getDataDimensionIndex(data), function(value, dataIndex) {
        const pIdx = VisualMapping_default.findPieceIndex(value, pieceList);
        pIdx === pieceIndex && dataIndices.push(dataIndex);
      }, this);
      result.push({seriesId: seriesModel.id, dataIndex: dataIndices});
    }, this);
    return result;
  }
  getRepresentValue(piece) {
    let representValue;
    if (this.isCategory()) {
      representValue = piece.value;
    } else {
      if (piece.value != null) {
        representValue = piece.value;
      } else {
        const pieceInterval = piece.interval || [];
        representValue = pieceInterval[0] === -Infinity && pieceInterval[1] === Infinity ? 0 : (pieceInterval[0] + pieceInterval[1]) / 2;
      }
    }
    return representValue;
  }
  getVisualMeta(getColorVisual2) {
    if (this.isCategory()) {
      return;
    }
    const stops = [];
    const outerColors = ["", ""];
    const visualMapModel = this;
    function setStop(interval, valueState) {
      const representValue = visualMapModel.getRepresentValue({
        interval
      });
      if (!valueState) {
        valueState = visualMapModel.getValueState(representValue);
      }
      const color4 = getColorVisual2(representValue, valueState);
      if (interval[0] === -Infinity) {
        outerColors[0] = color4;
      } else if (interval[1] === Infinity) {
        outerColors[1] = color4;
      } else {
        stops.push({value: interval[0], color: color4}, {value: interval[1], color: color4});
      }
    }
    const pieceList = this._pieceList.slice();
    if (!pieceList.length) {
      pieceList.push({interval: [-Infinity, Infinity]});
    } else {
      let edge = pieceList[0].interval[0];
      edge !== -Infinity && pieceList.unshift({interval: [-Infinity, edge]});
      edge = pieceList[pieceList.length - 1].interval[1];
      edge !== Infinity && pieceList.push({interval: [edge, Infinity]});
    }
    let curr = -Infinity;
    each(pieceList, function(piece) {
      const interval = piece.interval;
      if (interval) {
        interval[0] > curr && setStop([curr, interval[0]], "outOfRange");
        setStop(interval.slice());
        curr = interval[1];
      }
    }, this);
    return {stops, outerColors};
  }
};
var PiecewiseModel = PiecewiseModel2;
PiecewiseModel.type = "visualMap.piecewise";
PiecewiseModel.defaultOption = inheritDefaultOption(VisualMapModel_default.defaultOption, {
  selected: null,
  minOpen: false,
  maxOpen: false,
  align: "auto",
  itemWidth: 20,
  itemHeight: 14,
  itemSymbol: "roundRect",
  pieces: null,
  categories: null,
  splitNumber: 5,
  selectedMode: "multiple",
  itemGap: 10,
  hoverLink: true
});
var resetMethods = {
  splitNumber(outPieceList) {
    const thisOption = this.option;
    let precision = Math.min(thisOption.precision, 20);
    const dataExtent = this.getExtent();
    let splitNumber = thisOption.splitNumber;
    splitNumber = Math.max(parseInt(splitNumber, 10), 1);
    thisOption.splitNumber = splitNumber;
    let splitStep = (dataExtent[1] - dataExtent[0]) / splitNumber;
    while (+splitStep.toFixed(precision) !== splitStep && precision < 5) {
      precision++;
    }
    thisOption.precision = precision;
    splitStep = +splitStep.toFixed(precision);
    if (thisOption.minOpen) {
      outPieceList.push({
        interval: [-Infinity, dataExtent[0]],
        close: [0, 0]
      });
    }
    for (let index = 0, curr = dataExtent[0]; index < splitNumber; curr += splitStep, index++) {
      const max3 = index === splitNumber - 1 ? dataExtent[1] : curr + splitStep;
      outPieceList.push({
        interval: [curr, max3],
        close: [1, 1]
      });
    }
    if (thisOption.maxOpen) {
      outPieceList.push({
        interval: [dataExtent[1], Infinity],
        close: [0, 0]
      });
    }
    reformIntervals(outPieceList);
    each(outPieceList, function(piece, index) {
      piece.index = index;
      piece.text = this.formatValueText(piece.interval);
    }, this);
  },
  categories(outPieceList) {
    const thisOption = this.option;
    each(thisOption.categories, function(cate) {
      outPieceList.push({
        text: this.formatValueText(cate, true),
        value: cate
      });
    }, this);
    normalizeReverse(thisOption, outPieceList);
  },
  pieces(outPieceList) {
    const thisOption = this.option;
    each(thisOption.pieces, function(pieceListItem, index) {
      if (!isObject(pieceListItem)) {
        pieceListItem = {value: pieceListItem};
      }
      const item = {text: "", index};
      if (pieceListItem.label != null) {
        item.text = pieceListItem.label;
      }
      if (pieceListItem.hasOwnProperty("value")) {
        const value = item.value = pieceListItem.value;
        item.interval = [value, value];
        item.close = [1, 1];
      } else {
        const interval = item.interval = [];
        const close = item.close = [0, 0];
        const closeList = [1, 0, 1];
        const infinityList = [-Infinity, Infinity];
        const useMinMax = [];
        for (let lg = 0; lg < 2; lg++) {
          const names = [["gte", "gt", "min"], ["lte", "lt", "max"]][lg];
          for (let i = 0; i < 3 && interval[lg] == null; i++) {
            interval[lg] = pieceListItem[names[i]];
            close[lg] = closeList[i];
            useMinMax[lg] = i === 2;
          }
          interval[lg] == null && (interval[lg] = infinityList[lg]);
        }
        useMinMax[0] && interval[1] === Infinity && (close[0] = 0);
        useMinMax[1] && interval[0] === -Infinity && (close[1] = 0);
        if (true) {
          if (interval[0] > interval[1]) {
            console.warn("Piece " + index + "is illegal: " + interval + " lower bound should not greater then uppper bound.");
          }
        }
        if (interval[0] === interval[1] && close[0] && close[1]) {
          item.value = interval[0];
        }
      }
      item.visual = VisualMapping_default.retrieveVisuals(pieceListItem);
      outPieceList.push(item);
    }, this);
    normalizeReverse(thisOption, outPieceList);
    reformIntervals(outPieceList);
    each(outPieceList, function(piece) {
      const close = piece.close;
      const edgeSymbols = [["<", "\u2264"][close[1]], [">", "\u2265"][close[0]]];
      piece.text = piece.text || this.formatValueText(piece.value != null ? piece.value : piece.interval, false, edgeSymbols);
    }, this);
  }
};
function normalizeReverse(thisOption, pieceList) {
  const inverse = thisOption.inverse;
  if (thisOption.orient === "vertical" ? !inverse : inverse) {
    pieceList.reverse();
  }
}
var PiecewiseModel_default = PiecewiseModel;

// src/component/visualMap/PiecewiseView.ts
var PiecewiseVisualMapView2 = class extends VisualMapView_default {
  constructor() {
    super(...arguments);
    this.type = PiecewiseVisualMapView2.type;
  }
  doRender() {
    const thisGroup = this.group;
    thisGroup.removeAll();
    const visualMapModel = this.visualMapModel;
    const textGap = visualMapModel.get("textGap");
    const textStyleModel = visualMapModel.textStyleModel;
    const itemAlign = this._getItemAlign();
    const itemSize = visualMapModel.itemSize;
    const viewData = this._getViewData();
    const endsText = viewData.endsText;
    const showLabel = retrieve(visualMapModel.get("showLabel", true), !endsText);
    const silent = !visualMapModel.get("selectedMode");
    endsText && this._renderEndsText(thisGroup, endsText[0], itemSize, showLabel, itemAlign);
    each(viewData.viewPieceList, function(item) {
      const piece = item.piece;
      const itemGroup = new Group_default();
      itemGroup.onclick = bind(this._onItemClick, this, piece);
      this._enableHoverLink(itemGroup, item.indexInModelPieceList);
      const representValue = visualMapModel.getRepresentValue(piece);
      this._createItemSymbol(itemGroup, representValue, [0, 0, itemSize[0], itemSize[1]], silent);
      if (showLabel) {
        const visualState = this.visualMapModel.getValueState(representValue);
        const align = textStyleModel.get("align") || itemAlign;
        itemGroup.add(new Text_default({
          style: createTextStyle(textStyleModel, {
            x: align === "right" ? -textGap : itemSize[0] + textGap,
            y: itemSize[1] / 2,
            text: piece.text,
            verticalAlign: textStyleModel.get("verticalAlign") || "middle",
            align,
            opacity: retrieve2(textStyleModel.get("opacity"), visualState === "outOfRange" ? 0.5 : 1)
          }),
          silent
        }));
      }
      thisGroup.add(itemGroup);
    }, this);
    endsText && this._renderEndsText(thisGroup, endsText[1], itemSize, showLabel, itemAlign);
    box(visualMapModel.get("orient"), thisGroup, visualMapModel.get("itemGap"));
    this.renderBackground(thisGroup);
    this.positionGroup(thisGroup);
  }
  _enableHoverLink(itemGroup, pieceIndex) {
    itemGroup.on("mouseover", () => onHoverLink("highlight")).on("mouseout", () => onHoverLink("downplay"));
    const onHoverLink = (method) => {
      const visualMapModel = this.visualMapModel;
      visualMapModel.option.hoverLink && this.api.dispatchAction({
        type: method,
        batch: makeHighDownBatch(visualMapModel.findTargetDataIndices(pieceIndex), visualMapModel)
      });
    };
  }
  _getItemAlign() {
    const visualMapModel = this.visualMapModel;
    const modelOption = visualMapModel.option;
    if (modelOption.orient === "vertical") {
      return getItemAlign(visualMapModel, this.api, visualMapModel.itemSize);
    } else {
      let align = modelOption.align;
      if (!align || align === "auto") {
        align = "left";
      }
      return align;
    }
  }
  _renderEndsText(group, text, itemSize, showLabel, itemAlign) {
    if (!text) {
      return;
    }
    const itemGroup = new Group_default();
    const textStyleModel = this.visualMapModel.textStyleModel;
    itemGroup.add(new Text_default({
      style: createTextStyle(textStyleModel, {
        x: showLabel ? itemAlign === "right" ? itemSize[0] : 0 : itemSize[0] / 2,
        y: itemSize[1] / 2,
        verticalAlign: "middle",
        align: showLabel ? itemAlign : "center",
        text
      })
    }));
    group.add(itemGroup);
  }
  _getViewData() {
    const visualMapModel = this.visualMapModel;
    const viewPieceList = map(visualMapModel.getPieceList(), function(piece, index) {
      return {piece, indexInModelPieceList: index};
    });
    let endsText = visualMapModel.get("text");
    const orient = visualMapModel.get("orient");
    const inverse = visualMapModel.get("inverse");
    if (orient === "horizontal" ? inverse : !inverse) {
      viewPieceList.reverse();
    } else if (endsText) {
      endsText = endsText.slice().reverse();
    }
    return {viewPieceList, endsText};
  }
  _createItemSymbol(group, representValue, shapeParam, silent) {
    const itemSymbol = createSymbol(this.getControllerVisual(representValue, "symbol"), shapeParam[0], shapeParam[1], shapeParam[2], shapeParam[3], this.getControllerVisual(representValue, "color"));
    itemSymbol.silent = silent;
    group.add(itemSymbol);
  }
  _onItemClick(piece) {
    const visualMapModel = this.visualMapModel;
    const option = visualMapModel.option;
    const selectedMode = option.selectedMode;
    if (!selectedMode) {
      return;
    }
    const selected = clone(option.selected);
    const newKey = visualMapModel.getSelectedMapKey(piece);
    if (selectedMode === "single" || selectedMode === true) {
      selected[newKey] = true;
      each(selected, function(o, key) {
        selected[key] = key === newKey;
      });
    } else {
      selected[newKey] = !selected[newKey];
    }
    this.api.dispatchAction({
      type: "selectDataRange",
      from: this.uid,
      visualMapId: this.visualMapModel.id,
      selected
    });
  }
};
var PiecewiseVisualMapView = PiecewiseVisualMapView2;
PiecewiseVisualMapView.type = "visualMap.piecewise";
var PiecewiseView_default = PiecewiseVisualMapView;

// src/component/visualMap/installVisualMapPiecewise.ts
function install53(registers) {
  registers.registerComponentModel(PiecewiseModel_default);
  registers.registerComponentView(PiecewiseView_default);
  installCommon2(registers);
}

// src/component/visualMap/install.ts
function install54(registers) {
  use(install52);
  use(install53);
}

// src/component/thumbnail/ThumbnailBridgeImpl.ts
var ThumbnailBridgeImpl = class {
  constructor(thumbnailModel) {
    this._thumbnailModel = thumbnailModel;
  }
  reset(api2) {
    this._renderVersion = api2.getMainProcessVersion();
  }
  renderContent(opt) {
    const thumbnailView = opt.api.getViewOfComponentModel(this._thumbnailModel);
    if (!thumbnailView) {
      return;
    }
    opt.group.silent = true;
    thumbnailView.renderContent({
      group: opt.group,
      targetTrans: opt.targetTrans,
      z2Range: calcZ2Range(opt.group),
      roamType: opt.roamType,
      viewportRect: opt.viewportRect,
      renderVersion: this._renderVersion
    });
  }
  updateWindow(targetTrans, api2) {
    const thumbnailView = api2.getViewOfComponentModel(this._thumbnailModel);
    if (!thumbnailView) {
      return;
    }
    thumbnailView.updateWindow({
      targetTrans,
      renderVersion: this._renderVersion
    });
  }
};

// src/component/thumbnail/ThumbnailModel.ts
var ThumbnailModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = ThumbnailModel2.type;
    this.preventAutoZ = true;
  }
  optionUpdated(newCptOption, isInit) {
    this._updateBridge();
  }
  _updateBridge() {
    const bridge = this._birdge = this._birdge || new ThumbnailBridgeImpl(this);
    this._target = null;
    this.ecModel.eachSeries((series) => {
      injectThumbnailBridge(series, null);
    });
    if (this.shouldShow()) {
      const target = this.getTarget();
      injectThumbnailBridge(target.baseMapProvider, bridge);
    }
  }
  shouldShow() {
    return this.getShallow("show", true);
  }
  getBridge() {
    return this._birdge;
  }
  getTarget() {
    if (this._target) {
      return this._target;
    }
    let series = this.getReferringComponents("series", {
      useDefault: false,
      enableAll: false,
      enableNone: false
    }).models[0];
    if (series) {
      if (series.subType !== "graph") {
        series = null;
        if (true) {
          error(`series.${series.subType} is not supported in thumbnail.`, true);
        }
      }
    } else {
      series = this.ecModel.queryComponents({mainType: "series", subType: "graph"})[0];
    }
    this._target = {
      baseMapProvider: series
    };
    return this._target;
  }
};
var ThumbnailModel = ThumbnailModel2;
ThumbnailModel.type = "thumbnail";
ThumbnailModel.layoutMode = "box";
ThumbnailModel.dependencies = ["series", "geo"];
ThumbnailModel.defaultOption = {
  show: true,
  right: 1,
  bottom: 1,
  height: "25%",
  width: "25%",
  itemStyle: {
    borderColor: tokens_default.color.border,
    borderWidth: 2
  },
  windowStyle: {
    borderWidth: 1,
    color: tokens_default.color.neutral30,
    borderColor: tokens_default.color.neutral40,
    opacity: 0.3
  },
  z: 10
};

// src/component/thumbnail/ThumbnailView.ts
var ThumbnailView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = ThumbnailView2.type;
  }
  render(thumbnailModel, ecModel, api2) {
    this._api = api2;
    this._model = thumbnailModel;
    if (!this._coordSys) {
      this._coordSys = new View_default();
    }
    if (!this._isEnabled()) {
      this._clear();
      return;
    }
    this._renderVersion = api2.getMainProcessVersion();
    const group = this.group;
    group.removeAll();
    const itemStyleModel = thumbnailModel.getModel("itemStyle");
    const itemStyle = itemStyleModel.getItemStyle();
    if (itemStyle.fill == null) {
      itemStyle.fill = ecModel.get("backgroundColor") || tokens_default.color.neutral00;
    }
    const refContainer = createBoxLayoutReference(thumbnailModel, api2).refContainer;
    const boxRect = getLayoutRect(getBoxLayoutParams(thumbnailModel, true), refContainer);
    const boxBorderWidth = itemStyle.lineWidth || 0;
    const contentRect = this._contentRect = expandOrShrinkRect(boxRect.clone(), boxBorderWidth / 2, true, true);
    const contentGroup = new Group_default();
    group.add(contentGroup);
    contentGroup.setClipPath(new Rect_default({shape: contentRect.plain()}));
    const targetGroup = this._targetGroup = new Group_default();
    contentGroup.add(targetGroup);
    const borderShape = boxRect.plain();
    borderShape.r = itemStyleModel.getShallow("borderRadius", true);
    group.add(this._bgRect = new Rect_default({
      style: itemStyle,
      shape: borderShape,
      silent: false,
      cursor: "grab"
    }));
    const windowStyleModel = thumbnailModel.getModel("windowStyle");
    const windowR = windowStyleModel.getShallow("borderRadius", true);
    contentGroup.add(this._windowRect = new Rect_default({
      shape: {x: 0, y: 0, width: 0, height: 0, r: windowR},
      style: windowStyleModel.getItemStyle(),
      silent: false,
      cursor: "grab"
    }));
    this._dealRenderContent();
    this._dealUpdateWindow();
    updateZ3(thumbnailModel, this);
  }
  renderContent(bridgeRendered) {
    this._bridgeRendered = bridgeRendered;
    if (this._isEnabled()) {
      this._dealRenderContent();
      this._dealUpdateWindow();
      updateZ3(this._model, this);
    }
  }
  _dealRenderContent() {
    const bridgeRendered = this._bridgeRendered;
    if (!bridgeRendered || bridgeRendered.renderVersion !== this._renderVersion) {
      return;
    }
    const targetGroup = this._targetGroup;
    const coordSys = this._coordSys;
    const contentRect = this._contentRect;
    targetGroup.removeAll();
    if (!bridgeRendered) {
      return;
    }
    const bridgeGroup = bridgeRendered.group;
    const bridgeRect = bridgeGroup.getBoundingRect();
    targetGroup.add(bridgeGroup);
    this._bgRect.z2 = bridgeRendered.z2Range.min - 10;
    coordSys.setBoundingRect(bridgeRect.x, bridgeRect.y, bridgeRect.width, bridgeRect.height);
    const viewRect2 = getLayoutRect({
      left: "center",
      top: "center",
      aspect: bridgeRect.width / bridgeRect.height
    }, contentRect);
    coordSys.setViewRect(viewRect2.x, viewRect2.y, viewRect2.width, viewRect2.height);
    bridgeGroup.attr(coordSys.getTransformInfo().raw);
    this._windowRect.z2 = bridgeRendered.z2Range.max + 10;
    this._resetRoamController(bridgeRendered.roamType);
  }
  updateWindow(param) {
    const bridgeRendered = this._bridgeRendered;
    if (bridgeRendered && bridgeRendered.renderVersion === param.renderVersion) {
      bridgeRendered.targetTrans = param.targetTrans;
    }
    if (this._isEnabled()) {
      this._dealUpdateWindow();
    }
  }
  _dealUpdateWindow() {
    const bridgeRendered = this._bridgeRendered;
    if (!bridgeRendered || bridgeRendered.renderVersion !== this._renderVersion) {
      return;
    }
    const invTargetTrans = invert([], bridgeRendered.targetTrans);
    const transTargetToThis = mul2([], this._coordSys.transform, invTargetTrans);
    this._transThisToTarget = invert([], transTargetToThis);
    let viewportRect = bridgeRendered.viewportRect;
    if (!viewportRect) {
      viewportRect = new BoundingRect_default(0, 0, this._api.getWidth(), this._api.getHeight());
    } else {
      viewportRect = viewportRect.clone();
    }
    viewportRect.applyTransform(transTargetToThis);
    const windowRect = this._windowRect;
    const r = windowRect.shape.r;
    windowRect.setShape(defaults({r}, viewportRect));
  }
  _resetRoamController(roamType) {
    const api2 = this._api;
    let roamController = this._roamController;
    if (!roamController) {
      roamController = this._roamController = new RoamController_default(api2.getZr());
    }
    if (!roamType || !this._isEnabled()) {
      roamController.disable();
      return;
    }
    roamController.enable(roamType, {
      api: api2,
      zInfo: {component: this._model},
      triggerInfo: {
        roamTrigger: null,
        isInSelf: (e2, x, y) => this._contentRect.contain(x, y)
      }
    });
    roamController.off("pan").off("zoom").on("pan", bind(this._onPan, this)).on("zoom", bind(this._onZoom, this));
  }
  _onPan(event) {
    const trans = this._transThisToTarget;
    if (!this._isEnabled() || !trans) {
      return;
    }
    const oldOffset = applyTransform([], [event.oldX, event.oldY], trans);
    const newOffset = applyTransform([], [event.oldX - event.dx, event.oldY - event.dy], trans);
    this._api.dispatchAction(makeRoamPayload(this._model.getTarget().baseMapProvider, {
      dx: newOffset[0] - oldOffset[0],
      dy: newOffset[1] - oldOffset[1]
    }));
  }
  _onZoom(event) {
    const trans = this._transThisToTarget;
    if (!this._isEnabled() || !trans) {
      return;
    }
    const offset = applyTransform([], [event.originX, event.originY], trans);
    this._api.dispatchAction(makeRoamPayload(this._model.getTarget().baseMapProvider, {
      zoom: 1 / event.scale,
      originX: offset[0],
      originY: offset[1]
    }));
  }
  _isEnabled() {
    const thumbnailModel = this._model;
    if (!thumbnailModel || !thumbnailModel.shouldShow()) {
      return false;
    }
    const baseMapProvider = thumbnailModel.getTarget().baseMapProvider;
    if (!baseMapProvider) {
      return false;
    }
    return true;
  }
  _clear() {
    this.group.removeAll();
    this._bridgeRendered = null;
    if (this._roamController) {
      this._roamController.disable();
    }
  }
  remove() {
    this._clear();
  }
  dispose() {
    this._clear();
  }
};
var ThumbnailView = ThumbnailView2;
ThumbnailView.type = "thumbnail";
function makeRoamPayload(baseMapProvider, params) {
  const type = baseMapProvider.mainType === "series" ? `${baseMapProvider.subType}Roam` : `${baseMapProvider.mainType}Roam`;
  const payload = {type};
  payload[`${baseMapProvider.mainType}Id`] = baseMapProvider.id;
  extend(payload, params);
  return payload;
}
function updateZ3(thumbnailModel, thumbnailView) {
  const zInfo = retrieveZInfo(thumbnailModel);
  traverseUpdateZ(thumbnailView.group, zInfo.z, zInfo.zlevel);
}

// src/component/thumbnail/install.ts
function install55(registers) {
  registers.registerComponentModel(ThumbnailModel);
  registers.registerComponentView(ThumbnailView);
}

// src/visual/aria.ts
var DEFAULT_OPTION = {
  label: {
    enabled: true
  },
  decal: {
    show: false
  }
};
var inner24 = makeInner();
var decalPaletteScope = {};
function ariaVisual(ecModel, api2) {
  const ariaModel = ecModel.getModel("aria");
  if (!ariaModel.get("enabled")) {
    return;
  }
  const defaultOption3 = clone(DEFAULT_OPTION);
  merge(defaultOption3.label, ecModel.getLocaleModel().get("aria"), false);
  merge(ariaModel.option, defaultOption3, false);
  setDecal();
  setLabel();
  function setDecal() {
    const decalModel = ariaModel.getModel("decal");
    const useDecal = decalModel.get("show");
    if (useDecal) {
      const paletteScopeGroupByType = createHashMap();
      ecModel.eachSeries((seriesModel) => {
        if (seriesModel.isColorBySeries()) {
          return;
        }
        let decalScope = paletteScopeGroupByType.get(seriesModel.type);
        if (!decalScope) {
          decalScope = {};
          paletteScopeGroupByType.set(seriesModel.type, decalScope);
        }
        inner24(seriesModel).scope = decalScope;
      });
      ecModel.eachRawSeries((seriesModel) => {
        if (ecModel.isSeriesFiltered(seriesModel)) {
          return;
        }
        if (isFunction(seriesModel.enableAriaDecal)) {
          seriesModel.enableAriaDecal();
          return;
        }
        const data = seriesModel.getData();
        if (!seriesModel.isColorBySeries()) {
          const dataAll = seriesModel.getRawData();
          const idxMap = {};
          const decalScope = inner24(seriesModel).scope;
          data.each(function(idx) {
            const rawIdx = data.getRawIndex(idx);
            idxMap[rawIdx] = idx;
          });
          const dataCount = dataAll.count();
          dataAll.each((rawIdx) => {
            const idx = idxMap[rawIdx];
            const name = dataAll.getName(rawIdx) || rawIdx + "";
            const paletteDecal = getDecalFromPalette(seriesModel.ecModel, name, decalScope, dataCount);
            const specifiedDecal = data.getItemVisual(idx, "decal");
            data.setItemVisual(idx, "decal", mergeDecal(specifiedDecal, paletteDecal));
          });
        } else {
          const paletteDecal = getDecalFromPalette(seriesModel.ecModel, seriesModel.name, decalPaletteScope, ecModel.getSeriesCount());
          const specifiedDecal = data.getVisual("decal");
          data.setVisual("decal", mergeDecal(specifiedDecal, paletteDecal));
        }
        function mergeDecal(specifiedDecal, paletteDecal) {
          const resultDecal = specifiedDecal ? extend(extend({}, paletteDecal), specifiedDecal) : paletteDecal;
          resultDecal.dirty = true;
          return resultDecal;
        }
      });
    }
  }
  function setLabel() {
    const dom = api2.getZr().dom;
    if (!dom) {
      return;
    }
    const labelLocale = ecModel.getLocaleModel().get("aria");
    const labelModel = ariaModel.getModel("label");
    labelModel.option = defaults(labelModel.option, labelLocale);
    if (!labelModel.get("enabled")) {
      return;
    }
    dom.setAttribute("role", "img");
    if (labelModel.get("description")) {
      dom.setAttribute("aria-label", labelModel.get("description"));
      return;
    }
    const seriesCnt = ecModel.getSeriesCount();
    const maxDataCnt = labelModel.get(["data", "maxCount"]) || 10;
    const maxSeriesCnt = labelModel.get(["series", "maxCount"]) || 10;
    const displaySeriesCnt = Math.min(seriesCnt, maxSeriesCnt);
    let ariaLabel;
    if (seriesCnt < 1) {
      return;
    } else {
      const title = getTitle();
      if (title) {
        const withTitle = labelModel.get(["general", "withTitle"]);
        ariaLabel = replace(withTitle, {
          title
        });
      } else {
        ariaLabel = labelModel.get(["general", "withoutTitle"]);
      }
      const seriesLabels = [];
      const prefix = seriesCnt > 1 ? labelModel.get(["series", "multiple", "prefix"]) : labelModel.get(["series", "single", "prefix"]);
      ariaLabel += replace(prefix, {seriesCount: seriesCnt});
      ecModel.eachSeries(function(seriesModel, idx) {
        if (idx < displaySeriesCnt) {
          let seriesLabel;
          const seriesName = seriesModel.get("name");
          const withName = seriesName ? "withName" : "withoutName";
          seriesLabel = seriesCnt > 1 ? labelModel.get(["series", "multiple", withName]) : labelModel.get(["series", "single", withName]);
          seriesLabel = replace(seriesLabel, {
            seriesId: seriesModel.seriesIndex,
            seriesName: seriesModel.get("name"),
            seriesType: getSeriesTypeName(seriesModel.subType)
          });
          const data = seriesModel.getData();
          if (data.count() > maxDataCnt) {
            const partialLabel = labelModel.get(["data", "partialData"]);
            seriesLabel += replace(partialLabel, {
              displayCnt: maxDataCnt
            });
          } else {
            seriesLabel += labelModel.get(["data", "allData"]);
          }
          const middleSeparator2 = labelModel.get(["data", "separator", "middle"]);
          const endSeparator2 = labelModel.get(["data", "separator", "end"]);
          const excludeDimensionId = labelModel.get(["data", "excludeDimensionId"]);
          const dataLabels = [];
          for (let i = 0; i < data.count(); i++) {
            if (i < maxDataCnt) {
              const name = data.getName(i);
              const value = !excludeDimensionId ? data.getValues(i) : filter(data.getValues(i), (v, j) => indexOf(excludeDimensionId, j) === -1);
              const dataLabel = labelModel.get(["data", name ? "withName" : "withoutName"]);
              dataLabels.push(replace(dataLabel, {
                name,
                value: value.join(middleSeparator2)
              }));
            }
          }
          seriesLabel += dataLabels.join(middleSeparator2) + endSeparator2;
          seriesLabels.push(seriesLabel);
        }
      });
      const separatorModel = labelModel.getModel(["series", "multiple", "separator"]);
      const middleSeparator = separatorModel.get("middle");
      const endSeparator = separatorModel.get("end");
      ariaLabel += seriesLabels.join(middleSeparator) + endSeparator;
      dom.setAttribute("aria-label", ariaLabel);
    }
  }
  function replace(str, keyValues) {
    if (!isString(str)) {
      return str;
    }
    let result = str;
    each(keyValues, function(value, key) {
      result = result.replace(new RegExp("\\{\\s*" + key + "\\s*\\}", "g"), value);
    });
    return result;
  }
  function getTitle() {
    let title = ecModel.get("title");
    if (title && title.length) {
      title = title[0];
    }
    return title && title.text;
  }
  function getSeriesTypeName(type) {
    const typeNames = ecModel.getLocaleModel().get(["series", "typeNames"]);
    return typeNames[type] || typeNames.chart;
  }
}

// src/component/aria/preprocessor.ts
function ariaPreprocessor(option) {
  if (!option || !option.aria) {
    return;
  }
  const aria = option.aria;
  if (aria.show != null) {
    aria.enabled = aria.show;
  }
  aria.label = aria.label || {};
  each(["description", "general", "series", "data"], (name) => {
    if (aria[name] != null) {
      aria.label[name] = aria[name];
    }
  });
}

// src/component/aria/install.ts
function install56(registers) {
  registers.registerPreprocessor(ariaPreprocessor);
  registers.registerVisual(registers.PRIORITY.VISUAL.ARIA, ariaVisual);
}

// src/util/conditionalExpression.ts
var RELATIONAL_EXPRESSION_OP_ALIAS_MAP = {
  value: "eq",
  "<": "lt",
  "<=": "lte",
  ">": "gt",
  ">=": "gte",
  "=": "eq",
  "!=": "ne",
  "<>": "ne"
};
var RegExpEvaluator = class {
  constructor(rVal) {
    const condValue = this._condVal = isString(rVal) ? new RegExp(rVal) : isRegExp(rVal) ? rVal : null;
    if (condValue == null) {
      let errMsg = "";
      if (true) {
        errMsg = makePrintable("Illegal regexp", rVal, "in");
      }
      throwError(errMsg);
    }
  }
  evaluate(lVal) {
    const type = typeof lVal;
    return isString(type) ? this._condVal.test(lVal) : isNumber(type) ? this._condVal.test(lVal + "") : false;
  }
};
var ConstConditionInternal = class {
  evaluate() {
    return this.value;
  }
};
var AndConditionInternal = class {
  evaluate() {
    const children = this.children;
    for (let i = 0; i < children.length; i++) {
      if (!children[i].evaluate()) {
        return false;
      }
    }
    return true;
  }
};
var OrConditionInternal = class {
  evaluate() {
    const children = this.children;
    for (let i = 0; i < children.length; i++) {
      if (children[i].evaluate()) {
        return true;
      }
    }
    return false;
  }
};
var NotConditionInternal = class {
  evaluate() {
    return !this.child.evaluate();
  }
};
var RelationalConditionInternal = class {
  evaluate() {
    const needParse = !!this.valueParser;
    const getValue = this.getValue;
    const tarValRaw = getValue(this.valueGetterParam);
    const tarValParsed = needParse ? this.valueParser(tarValRaw) : null;
    for (let i = 0; i < this.subCondList.length; i++) {
      if (!this.subCondList[i].evaluate(needParse ? tarValParsed : tarValRaw)) {
        return false;
      }
    }
    return true;
  }
};
function parseOption(exprOption, getters) {
  if (exprOption === true || exprOption === false) {
    const cond = new ConstConditionInternal();
    cond.value = exprOption;
    return cond;
  }
  let errMsg = "";
  if (!isObjectNotArray(exprOption)) {
    if (true) {
      errMsg = makePrintable("Illegal config. Expect a plain object but actually", exprOption);
    }
    throwError(errMsg);
  }
  if (exprOption.and) {
    return parseAndOrOption("and", exprOption, getters);
  } else if (exprOption.or) {
    return parseAndOrOption("or", exprOption, getters);
  } else if (exprOption.not) {
    return parseNotOption(exprOption, getters);
  }
  return parseRelationalOption(exprOption, getters);
}
function parseAndOrOption(op, exprOption, getters) {
  const subOptionArr = exprOption[op];
  let errMsg = "";
  if (true) {
    errMsg = makePrintable('"and"/"or" condition should only be `' + op + ": [...]` and must not be empty array.", "Illegal condition:", exprOption);
  }
  if (!isArray(subOptionArr)) {
    throwError(errMsg);
  }
  if (!subOptionArr.length) {
    throwError(errMsg);
  }
  const cond = op === "and" ? new AndConditionInternal() : new OrConditionInternal();
  cond.children = map(subOptionArr, (subOption) => parseOption(subOption, getters));
  if (!cond.children.length) {
    throwError(errMsg);
  }
  return cond;
}
function parseNotOption(exprOption, getters) {
  const subOption = exprOption.not;
  let errMsg = "";
  if (true) {
    errMsg = makePrintable('"not" condition should only be `not: {}`.', "Illegal condition:", exprOption);
  }
  if (!isObjectNotArray(subOption)) {
    throwError(errMsg);
  }
  const cond = new NotConditionInternal();
  cond.child = parseOption(subOption, getters);
  if (!cond.child) {
    throwError(errMsg);
  }
  return cond;
}
function parseRelationalOption(exprOption, getters) {
  let errMsg = "";
  const valueGetterParam = getters.prepareGetValue(exprOption);
  const subCondList = [];
  const exprKeys = keys(exprOption);
  const parserName = exprOption.parser;
  const valueParser = parserName ? getRawValueParser(parserName) : null;
  for (let i = 0; i < exprKeys.length; i++) {
    const keyRaw = exprKeys[i];
    if (keyRaw === "parser" || getters.valueGetterAttrMap.get(keyRaw)) {
      continue;
    }
    const op = hasOwn(RELATIONAL_EXPRESSION_OP_ALIAS_MAP, keyRaw) ? RELATIONAL_EXPRESSION_OP_ALIAS_MAP[keyRaw] : keyRaw;
    const condValueRaw = exprOption[keyRaw];
    const condValueParsed = valueParser ? valueParser(condValueRaw) : condValueRaw;
    const evaluator = createFilterComparator(op, condValueParsed) || op === "reg" && new RegExpEvaluator(condValueParsed);
    if (!evaluator) {
      if (true) {
        errMsg = makePrintable('Illegal relational operation: "' + keyRaw + '" in condition:', exprOption);
      }
      throwError(errMsg);
    }
    subCondList.push(evaluator);
  }
  if (!subCondList.length) {
    if (true) {
      errMsg = makePrintable("Relational condition must have at least one operator.", "Illegal condition:", exprOption);
    }
    throwError(errMsg);
  }
  const cond = new RelationalConditionInternal();
  cond.valueGetterParam = valueGetterParam;
  cond.valueParser = valueParser;
  cond.getValue = getters.getValue;
  cond.subCondList = subCondList;
  return cond;
}
function isObjectNotArray(val) {
  return isObject(val) && !isArrayLike(val);
}
var ConditionalExpressionParsed = class {
  constructor(exprOption, getters) {
    this._cond = parseOption(exprOption, getters);
  }
  evaluate() {
    return this._cond.evaluate();
  }
};
function parseConditionalExpression(exprOption, getters) {
  return new ConditionalExpressionParsed(exprOption, getters);
}

// src/component/transform/filterTransform.ts
var filterTransform = {
  type: "echarts:filter",
  transform: function(params) {
    const upstream = params.upstream;
    let rawItem;
    const condition = parseConditionalExpression(params.config, {
      valueGetterAttrMap: createHashMap({dimension: true}),
      prepareGetValue: function(exprOption) {
        let errMsg = "";
        const dimLoose = exprOption.dimension;
        if (!hasOwn(exprOption, "dimension")) {
          if (true) {
            errMsg = makePrintable('Relation condition must has prop "dimension" specified.', "Illegal condition:", exprOption);
          }
          throwError(errMsg);
        }
        const dimInfo = upstream.getDimensionInfo(dimLoose);
        if (!dimInfo) {
          if (true) {
            errMsg = makePrintable("Can not find dimension info via: " + dimLoose + ".\n", "Existing dimensions: ", upstream.cloneAllDimensionInfo(), ".\n", "Illegal condition:", exprOption, ".\n");
          }
          throwError(errMsg);
        }
        return {dimIdx: dimInfo.index};
      },
      getValue: function(param) {
        return upstream.retrieveValueFromItem(rawItem, param.dimIdx);
      }
    });
    const resultData = [];
    for (let i = 0, len2 = upstream.count(); i < len2; i++) {
      rawItem = upstream.getRawDataItem(i);
      if (condition.evaluate()) {
        resultData.push(rawItem);
      }
    }
    return {
      data: resultData
    };
  }
};

// src/component/transform/sortTransform.ts
var sampleLog = "";
if (true) {
  sampleLog = [
    "Valid config is like:",
    '{ dimension: "age", order: "asc" }',
    'or [{ dimension: "age", order: "asc"], { dimension: "date", order: "desc" }]'
  ].join(" ");
}
var sortTransform = {
  type: "echarts:sort",
  transform: function(params) {
    const upstream = params.upstream;
    const config = params.config;
    let errMsg = "";
    const orderExprList = normalizeToArray(config);
    if (!orderExprList.length) {
      if (true) {
        errMsg = "Empty `config` in sort transform.";
      }
      throwError(errMsg);
    }
    const orderDefList = [];
    each(orderExprList, function(orderExpr) {
      const dimLoose = orderExpr.dimension;
      const order = orderExpr.order;
      const parserName = orderExpr.parser;
      const incomparable = orderExpr.incomparable;
      if (dimLoose == null) {
        if (true) {
          errMsg = 'Sort transform config must has "dimension" specified.' + sampleLog;
        }
        throwError(errMsg);
      }
      if (order !== "asc" && order !== "desc") {
        if (true) {
          errMsg = 'Sort transform config must has "order" specified.' + sampleLog;
        }
        throwError(errMsg);
      }
      if (incomparable && (incomparable !== "min" && incomparable !== "max")) {
        let errMsg2 = "";
        if (true) {
          errMsg2 = 'incomparable must be "min" or "max" rather than "' + incomparable + '".';
        }
        throwError(errMsg2);
      }
      if (order !== "asc" && order !== "desc") {
        let errMsg2 = "";
        if (true) {
          errMsg2 = 'order must be "asc" or "desc" rather than "' + order + '".';
        }
        throwError(errMsg2);
      }
      const dimInfo = upstream.getDimensionInfo(dimLoose);
      if (!dimInfo) {
        if (true) {
          errMsg = makePrintable("Can not find dimension info via: " + dimLoose + ".\n", "Existing dimensions: ", upstream.cloneAllDimensionInfo(), ".\n", "Illegal config:", orderExpr, ".\n");
        }
        throwError(errMsg);
      }
      const parser = parserName ? getRawValueParser(parserName) : null;
      if (parserName && !parser) {
        if (true) {
          errMsg = makePrintable("Invalid parser name " + parserName + ".\n", "Illegal config:", orderExpr, ".\n");
        }
        throwError(errMsg);
      }
      orderDefList.push({
        dimIdx: dimInfo.index,
        parser,
        comparator: new SortOrderComparator(order, incomparable)
      });
    });
    const sourceFormat = upstream.sourceFormat;
    if (sourceFormat !== SOURCE_FORMAT_ARRAY_ROWS && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {
      if (true) {
        errMsg = 'sourceFormat "' + sourceFormat + '" is not supported yet';
      }
      throwError(errMsg);
    }
    const resultData = [];
    for (let i = 0, len2 = upstream.count(); i < len2; i++) {
      resultData.push(upstream.getRawDataItem(i));
    }
    resultData.sort(function(item0, item1) {
      for (let i = 0; i < orderDefList.length; i++) {
        const orderDef = orderDefList[i];
        let val0 = upstream.retrieveValueFromItem(item0, orderDef.dimIdx);
        let val1 = upstream.retrieveValueFromItem(item1, orderDef.dimIdx);
        if (orderDef.parser) {
          val0 = orderDef.parser(val0);
          val1 = orderDef.parser(val1);
        }
        const result = orderDef.comparator.evaluate(val0, val1);
        if (result !== 0) {
          return result;
        }
      }
      return 0;
    });
    return {
      data: resultData
    };
  }
};

// src/component/transform/install.ts
function install57(registers) {
  registers.registerTransform(filterTransform);
  registers.registerTransform(sortTransform);
}

// src/component/dataset/install.ts
var DatasetModel = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = "dataset";
  }
  init(option, parentModel, ecModel) {
    super.init(option, parentModel, ecModel);
    this._sourceManager = new SourceManager(this);
    disableTransformOptionMerge(this);
  }
  mergeOption(newOption, ecModel) {
    super.mergeOption(newOption, ecModel);
    disableTransformOptionMerge(this);
  }
  optionUpdated() {
    this._sourceManager.dirty();
  }
  getSourceManager() {
    return this._sourceManager;
  }
};
DatasetModel.type = "dataset";
DatasetModel.defaultOption = {
  seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN
};
var DatasetView = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = "dataset";
  }
};
DatasetView.type = "dataset";
function install58(registers) {
  registers.registerComponentModel(DatasetModel);
  registers.registerComponentView(DatasetView);
}

// ../zrender/src/tool/convertPath.ts
var CMD5 = PathProxy_default.CMD;
function aroundEqual(a, b) {
  return Math.abs(a - b) < 1e-5;
}
function pathToBezierCurves(path) {
  const data = path.data;
  const len2 = path.len();
  const bezierArrayGroups = [];
  let currentSubpath;
  let xi = 0;
  let yi = 0;
  let x0 = 0;
  let y0 = 0;
  function createNewSubpath(x, y) {
    if (currentSubpath && currentSubpath.length > 2) {
      bezierArrayGroups.push(currentSubpath);
    }
    currentSubpath = [x, y];
  }
  function addLine(x02, y02, x12, y12) {
    if (!(aroundEqual(x02, x12) && aroundEqual(y02, y12))) {
      currentSubpath.push(x02, y02, x12, y12, x12, y12);
    }
  }
  function addArc(startAngle, endAngle, cx, cy, rx, ry) {
    const delta = Math.abs(endAngle - startAngle);
    const len3 = Math.tan(delta / 4) * 4 / 3;
    const dir3 = endAngle < startAngle ? -1 : 1;
    const c1 = Math.cos(startAngle);
    const s1 = Math.sin(startAngle);
    const c2 = Math.cos(endAngle);
    const s2 = Math.sin(endAngle);
    const x12 = c1 * rx + cx;
    const y12 = s1 * ry + cy;
    const x4 = c2 * rx + cx;
    const y4 = s2 * ry + cy;
    const hx = rx * len3 * dir3;
    const hy = ry * len3 * dir3;
    currentSubpath.push(x12 - hx * s1, y12 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);
  }
  let x1;
  let y1;
  let x2;
  let y2;
  for (let i = 0; i < len2; ) {
    const cmd = data[i++];
    const isFirst = i === 1;
    if (isFirst) {
      xi = data[i];
      yi = data[i + 1];
      x0 = xi;
      y0 = yi;
      if (cmd === CMD5.L || cmd === CMD5.C || cmd === CMD5.Q) {
        currentSubpath = [x0, y0];
      }
    }
    switch (cmd) {
      case CMD5.M:
        xi = x0 = data[i++];
        yi = y0 = data[i++];
        createNewSubpath(x0, y0);
        break;
      case CMD5.L:
        x1 = data[i++];
        y1 = data[i++];
        addLine(xi, yi, x1, y1);
        xi = x1;
        yi = y1;
        break;
      case CMD5.C:
        currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);
        break;
      case CMD5.Q:
        x1 = data[i++];
        y1 = data[i++];
        x2 = data[i++];
        y2 = data[i++];
        currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);
        xi = x2;
        yi = y2;
        break;
      case CMD5.A:
        const cx = data[i++];
        const cy = data[i++];
        const rx = data[i++];
        const ry = data[i++];
        const startAngle = data[i++];
        const endAngle = data[i++] + startAngle;
        i += 1;
        const anticlockwise = !data[i++];
        x1 = Math.cos(startAngle) * rx + cx;
        y1 = Math.sin(startAngle) * ry + cy;
        if (isFirst) {
          x0 = x1;
          y0 = y1;
          createNewSubpath(x0, y0);
        } else {
          addLine(xi, yi, x1, y1);
        }
        xi = Math.cos(endAngle) * rx + cx;
        yi = Math.sin(endAngle) * ry + cy;
        const step = (anticlockwise ? -1 : 1) * Math.PI / 2;
        for (let angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {
          const nextAngle = anticlockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);
          addArc(angle, nextAngle, cx, cy, rx, ry);
        }
        break;
      case CMD5.R:
        x0 = xi = data[i++];
        y0 = yi = data[i++];
        x1 = x0 + data[i++];
        y1 = y0 + data[i++];
        createNewSubpath(x1, y0);
        addLine(x1, y0, x1, y1);
        addLine(x1, y1, x0, y1);
        addLine(x0, y1, x0, y0);
        addLine(x0, y0, x1, y0);
        break;
      case CMD5.Z:
        currentSubpath && addLine(xi, yi, x0, y0);
        xi = x0;
        yi = y0;
        break;
    }
  }
  if (currentSubpath && currentSubpath.length > 2) {
    bezierArrayGroups.push(currentSubpath);
  }
  return bezierArrayGroups;
}
function adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, out2, scale4) {
  if (aroundEqual(x0, x1) && aroundEqual(y0, y1) && aroundEqual(x2, x3) && aroundEqual(y2, y3)) {
    out2.push(x3, y3);
    return;
  }
  const PIXEL_DISTANCE = 2 / scale4;
  const PIXEL_DISTANCE_SQR = PIXEL_DISTANCE * PIXEL_DISTANCE;
  let dx = x3 - x0;
  let dy = y3 - y0;
  const d = Math.sqrt(dx * dx + dy * dy);
  dx /= d;
  dy /= d;
  const dx1 = x1 - x0;
  const dy1 = y1 - y0;
  const dx2 = x2 - x3;
  const dy2 = y2 - y3;
  const cp1LenSqr = dx1 * dx1 + dy1 * dy1;
  const cp2LenSqr = dx2 * dx2 + dy2 * dy2;
  if (cp1LenSqr < PIXEL_DISTANCE_SQR && cp2LenSqr < PIXEL_DISTANCE_SQR) {
    out2.push(x3, y3);
    return;
  }
  const projLen1 = dx * dx1 + dy * dy1;
  const projLen2 = -dx * dx2 - dy * dy2;
  const d1Sqr = cp1LenSqr - projLen1 * projLen1;
  const d2Sqr = cp2LenSqr - projLen2 * projLen2;
  if (d1Sqr < PIXEL_DISTANCE_SQR && projLen1 >= 0 && d2Sqr < PIXEL_DISTANCE_SQR && projLen2 >= 0) {
    out2.push(x3, y3);
    return;
  }
  const tmpSegX = [];
  const tmpSegY = [];
  cubicSubdivide(x0, x1, x2, x3, 0.5, tmpSegX);
  cubicSubdivide(y0, y1, y2, y3, 0.5, tmpSegY);
  adpativeBezier(tmpSegX[0], tmpSegY[0], tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], tmpSegX[3], tmpSegY[3], out2, scale4);
  adpativeBezier(tmpSegX[4], tmpSegY[4], tmpSegX[5], tmpSegY[5], tmpSegX[6], tmpSegY[6], tmpSegX[7], tmpSegY[7], out2, scale4);
}
function pathToPolygons(path, scale4) {
  const bezierArrayGroups = pathToBezierCurves(path);
  const polygons = [];
  scale4 = scale4 || 1;
  for (let i = 0; i < bezierArrayGroups.length; i++) {
    const beziers = bezierArrayGroups[i];
    const polygon = [];
    let x0 = beziers[0];
    let y0 = beziers[1];
    polygon.push(x0, y0);
    for (let k = 2; k < beziers.length; ) {
      const x1 = beziers[k++];
      const y1 = beziers[k++];
      const x2 = beziers[k++];
      const y2 = beziers[k++];
      const x3 = beziers[k++];
      const y3 = beziers[k++];
      adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, polygon, scale4);
      x0 = x3;
      y0 = y3;
    }
    polygons.push(polygon);
  }
  return polygons;
}

// ../zrender/src/tool/dividePath.ts
function getDividingGrids(dimSize, rowDim, count2) {
  const rowSize = dimSize[rowDim];
  const columnSize = dimSize[1 - rowDim];
  const ratio = Math.abs(rowSize / columnSize);
  let rowCount = Math.ceil(Math.sqrt(ratio * count2));
  let columnCount = Math.floor(count2 / rowCount);
  if (columnCount === 0) {
    columnCount = 1;
    rowCount = count2;
  }
  const grids = [];
  for (let i = 0; i < rowCount; i++) {
    grids.push(columnCount);
  }
  const currentCount = rowCount * columnCount;
  const remained = count2 - currentCount;
  if (remained > 0) {
    for (let i = 0; i < remained; i++) {
      grids[i % rowCount] += 1;
    }
  }
  return grids;
}
function divideSector(sectorShape, count2, outShapes) {
  const r0 = sectorShape.r0;
  const r = sectorShape.r;
  const startAngle = sectorShape.startAngle;
  const endAngle = sectorShape.endAngle;
  const angle = Math.abs(endAngle - startAngle);
  const arcLen = angle * r;
  const deltaR = r - r0;
  const isAngleRow = arcLen > Math.abs(deltaR);
  const grids = getDividingGrids([arcLen, deltaR], isAngleRow ? 0 : 1, count2);
  const rowSize = (isAngleRow ? angle : deltaR) / grids.length;
  for (let row = 0; row < grids.length; row++) {
    const columnSize = (isAngleRow ? deltaR : angle) / grids[row];
    for (let column = 0; column < grids[row]; column++) {
      const newShape = {};
      if (isAngleRow) {
        newShape.startAngle = startAngle + rowSize * row;
        newShape.endAngle = startAngle + rowSize * (row + 1);
        newShape.r0 = r0 + columnSize * column;
        newShape.r = r0 + columnSize * (column + 1);
      } else {
        newShape.startAngle = startAngle + columnSize * column;
        newShape.endAngle = startAngle + columnSize * (column + 1);
        newShape.r0 = r0 + rowSize * row;
        newShape.r = r0 + rowSize * (row + 1);
      }
      newShape.clockwise = sectorShape.clockwise;
      newShape.cx = sectorShape.cx;
      newShape.cy = sectorShape.cy;
      outShapes.push(newShape);
    }
  }
}
function divideRect(rectShape, count2, outShapes) {
  const width = rectShape.width;
  const height = rectShape.height;
  const isHorizontalRow = width > height;
  const grids = getDividingGrids([width, height], isHorizontalRow ? 0 : 1, count2);
  const rowSizeDim = isHorizontalRow ? "width" : "height";
  const columnSizeDim = isHorizontalRow ? "height" : "width";
  const rowDim = isHorizontalRow ? "x" : "y";
  const columnDim = isHorizontalRow ? "y" : "x";
  const rowSize = rectShape[rowSizeDim] / grids.length;
  for (let row = 0; row < grids.length; row++) {
    const columnSize = rectShape[columnSizeDim] / grids[row];
    for (let column = 0; column < grids[row]; column++) {
      const newShape = {};
      newShape[rowDim] = row * rowSize;
      newShape[columnDim] = column * columnSize;
      newShape[rowSizeDim] = rowSize;
      newShape[columnSizeDim] = columnSize;
      newShape.x += rectShape.x;
      newShape.y += rectShape.y;
      outShapes.push(newShape);
    }
  }
}
function crossProduct2d2(x1, y1, x2, y2) {
  return x1 * y2 - x2 * y1;
}
function lineLineIntersect2(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
  const mx = a2x - a1x;
  const my = a2y - a1y;
  const nx = b2x - b1x;
  const ny = b2y - b1y;
  const nmCrossProduct = crossProduct2d2(nx, ny, mx, my);
  if (Math.abs(nmCrossProduct) < 1e-6) {
    return null;
  }
  const b1a1x = a1x - b1x;
  const b1a1y = a1y - b1y;
  const p = crossProduct2d2(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
  if (p < 0 || p > 1) {
    return null;
  }
  return new Point_default(p * mx + a1x, p * my + a1y);
}
function projPtOnLine(pt, lineA, lineB) {
  const dir3 = new Point_default();
  Point_default.sub(dir3, lineB, lineA);
  dir3.normalize();
  const dir22 = new Point_default();
  Point_default.sub(dir22, pt, lineA);
  const len2 = dir22.dot(dir3);
  return len2;
}
function addToPoly(poly, pt) {
  const last = poly[poly.length - 1];
  if (last && last[0] === pt[0] && last[1] === pt[1]) {
    return;
  }
  poly.push(pt);
}
function splitPolygonByLine(points4, lineA, lineB) {
  const len2 = points4.length;
  const intersections = [];
  for (let i = 0; i < len2; i++) {
    const p0 = points4[i];
    const p1 = points4[(i + 1) % len2];
    const intersectionPt = lineLineIntersect2(p0[0], p0[1], p1[0], p1[1], lineA.x, lineA.y, lineB.x, lineB.y);
    if (intersectionPt) {
      intersections.push({
        projPt: projPtOnLine(intersectionPt, lineA, lineB),
        pt: intersectionPt,
        idx: i
      });
    }
  }
  if (intersections.length < 2) {
    return [{points: points4}, {points: points4}];
  }
  intersections.sort((a, b) => {
    return a.projPt - b.projPt;
  });
  let splitPt0 = intersections[0];
  let splitPt1 = intersections[intersections.length - 1];
  if (splitPt1.idx < splitPt0.idx) {
    const tmp = splitPt0;
    splitPt0 = splitPt1;
    splitPt1 = tmp;
  }
  const splitPt0Arr = [splitPt0.pt.x, splitPt0.pt.y];
  const splitPt1Arr = [splitPt1.pt.x, splitPt1.pt.y];
  const newPolyA = [splitPt0Arr];
  const newPolyB = [splitPt1Arr];
  for (let i = splitPt0.idx + 1; i <= splitPt1.idx; i++) {
    addToPoly(newPolyA, points4[i].slice());
  }
  addToPoly(newPolyA, splitPt1Arr);
  addToPoly(newPolyA, splitPt0Arr);
  for (let i = splitPt1.idx + 1; i <= splitPt0.idx + len2; i++) {
    addToPoly(newPolyB, points4[i % len2].slice());
  }
  addToPoly(newPolyB, splitPt0Arr);
  addToPoly(newPolyB, splitPt1Arr);
  return [{
    points: newPolyA
  }, {
    points: newPolyB
  }];
}
function binaryDividePolygon(polygonShape) {
  const points4 = polygonShape.points;
  const min3 = [];
  const max3 = [];
  fromPoints(points4, min3, max3);
  const boundingRect = new BoundingRect_default(min3[0], min3[1], max3[0] - min3[0], max3[1] - min3[1]);
  const width = boundingRect.width;
  const height = boundingRect.height;
  const x = boundingRect.x;
  const y = boundingRect.y;
  const pt02 = new Point_default();
  const pt12 = new Point_default();
  if (width > height) {
    pt02.x = pt12.x = x + width / 2;
    pt02.y = y;
    pt12.y = y + height;
  } else {
    pt02.y = pt12.y = y + height / 2;
    pt02.x = x;
    pt12.x = x + width;
  }
  return splitPolygonByLine(points4, pt02, pt12);
}
function binaryDivideRecursive(divider, shape, count2, out2) {
  if (count2 === 1) {
    out2.push(shape);
  } else {
    const mid = Math.floor(count2 / 2);
    const sub2 = divider(shape);
    binaryDivideRecursive(divider, sub2[0], mid, out2);
    binaryDivideRecursive(divider, sub2[1], count2 - mid, out2);
  }
  return out2;
}
function clone5(path, count2) {
  const paths = [];
  for (let i = 0; i < count2; i++) {
    paths.push(clonePath(path));
  }
  return paths;
}
function copyPathProps(source, target) {
  target.setStyle(source.style);
  target.z = source.z;
  target.z2 = source.z2;
  target.zlevel = source.zlevel;
}
function polygonConvert(points4) {
  const out2 = [];
  for (let i = 0; i < points4.length; ) {
    out2.push([points4[i++], points4[i++]]);
  }
  return out2;
}
function split(path, count2) {
  const outShapes = [];
  const shape = path.shape;
  let OutShapeCtor;
  switch (path.type) {
    case "rect":
      divideRect(shape, count2, outShapes);
      OutShapeCtor = Rect_default;
      break;
    case "sector":
      divideSector(shape, count2, outShapes);
      OutShapeCtor = Sector_default;
      break;
    case "circle":
      divideSector({
        r0: 0,
        r: shape.r,
        startAngle: 0,
        endAngle: Math.PI * 2,
        cx: shape.cx,
        cy: shape.cy
      }, count2, outShapes);
      OutShapeCtor = Sector_default;
      break;
    default:
      const m2 = path.getComputedTransform();
      const scale4 = m2 ? Math.sqrt(Math.max(m2[0] * m2[0] + m2[1] * m2[1], m2[2] * m2[2] + m2[3] * m2[3])) : 1;
      const polygons = map(pathToPolygons(path.getUpdatedPathProxy(), scale4), (poly) => polygonConvert(poly));
      const polygonCount = polygons.length;
      if (polygonCount === 0) {
        binaryDivideRecursive(binaryDividePolygon, {
          points: polygons[0]
        }, count2, outShapes);
      } else if (polygonCount === count2) {
        for (let i = 0; i < polygonCount; i++) {
          outShapes.push({
            points: polygons[i]
          });
        }
      } else {
        let totalArea = 0;
        const items = map(polygons, (poly) => {
          const min3 = [];
          const max3 = [];
          fromPoints(poly, min3, max3);
          const area = (max3[1] - min3[1]) * (max3[0] - min3[0]);
          totalArea += area;
          return {poly, area};
        });
        items.sort((a, b) => b.area - a.area);
        let left = count2;
        for (let i = 0; i < polygonCount; i++) {
          const item = items[i];
          if (left <= 0) {
            break;
          }
          const selfCount = i === polygonCount - 1 ? left : Math.ceil(item.area / totalArea * count2);
          if (selfCount < 0) {
            continue;
          }
          binaryDivideRecursive(binaryDividePolygon, {
            points: item.poly
          }, selfCount, outShapes);
          left -= selfCount;
        }
        ;
      }
      OutShapeCtor = Polygon_default;
      break;
  }
  if (!OutShapeCtor) {
    return clone5(path, count2);
  }
  const out2 = [];
  for (let i = 0; i < outShapes.length; i++) {
    const subPath = new OutShapeCtor();
    subPath.setShape(outShapes[i]);
    copyPathProps(path, subPath);
    out2.push(subPath);
  }
  return out2;
}

// ../zrender/src/tool/morphPath.ts
function alignSubpath(subpath1, subpath2) {
  const len1 = subpath1.length;
  const len2 = subpath2.length;
  if (len1 === len2) {
    return [subpath1, subpath2];
  }
  const tmpSegX = [];
  const tmpSegY = [];
  const shorterPath = len1 < len2 ? subpath1 : subpath2;
  const shorterLen = Math.min(len1, len2);
  const diff = Math.abs(len2 - len1) / 6;
  const shorterBezierCount = (shorterLen - 2) / 6;
  const eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;
  const newSubpath = [shorterPath[0], shorterPath[1]];
  let remained = diff;
  for (let i = 2; i < shorterLen; ) {
    let x0 = shorterPath[i - 2];
    let y0 = shorterPath[i - 1];
    let x1 = shorterPath[i++];
    let y1 = shorterPath[i++];
    let x2 = shorterPath[i++];
    let y2 = shorterPath[i++];
    let x3 = shorterPath[i++];
    let y3 = shorterPath[i++];
    if (remained <= 0) {
      newSubpath.push(x1, y1, x2, y2, x3, y3);
      continue;
    }
    let actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;
    for (let k = 1; k <= actualSubDivCount; k++) {
      const p = k / actualSubDivCount;
      cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);
      cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);
      x0 = tmpSegX[3];
      y0 = tmpSegY[3];
      newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);
      x1 = tmpSegX[5];
      y1 = tmpSegY[5];
      x2 = tmpSegX[6];
      y2 = tmpSegY[6];
    }
    remained -= actualSubDivCount - 1;
  }
  return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];
}
function createSubpath(lastSubpathSubpath, otherSubpath) {
  const len2 = lastSubpathSubpath.length;
  const lastX = lastSubpathSubpath[len2 - 2];
  const lastY = lastSubpathSubpath[len2 - 1];
  const newSubpath = [];
  for (let i = 0; i < otherSubpath.length; ) {
    newSubpath[i++] = lastX;
    newSubpath[i++] = lastY;
  }
  return newSubpath;
}
function alignBezierCurves(array1, array2) {
  let lastSubpath1;
  let lastSubpath2;
  let newArray1 = [];
  let newArray2 = [];
  for (let i = 0; i < Math.max(array1.length, array2.length); i++) {
    const subpath1 = array1[i];
    const subpath2 = array2[i];
    let newSubpath1;
    let newSubpath2;
    if (!subpath1) {
      newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);
      newSubpath2 = subpath2;
    } else if (!subpath2) {
      newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);
      newSubpath1 = subpath1;
    } else {
      [newSubpath1, newSubpath2] = alignSubpath(subpath1, subpath2);
      lastSubpath1 = newSubpath1;
      lastSubpath2 = newSubpath2;
    }
    newArray1.push(newSubpath1);
    newArray2.push(newSubpath2);
  }
  return [newArray1, newArray2];
}
function centroid2(array) {
  let signedArea = 0;
  let cx = 0;
  let cy = 0;
  const len2 = array.length;
  for (let i = 0, j = len2 - 2; i < len2; j = i, i += 2) {
    const x0 = array[j];
    const y0 = array[j + 1];
    const x1 = array[i];
    const y1 = array[i + 1];
    const a = x0 * y1 - x1 * y0;
    signedArea += a;
    cx += (x0 + x1) * a;
    cy += (y0 + y1) * a;
  }
  if (signedArea === 0) {
    return [array[0] || 0, array[1] || 0];
  }
  return [cx / signedArea / 3, cy / signedArea / 3, signedArea];
}
function findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {
  const bezierCount = (fromSubBeziers.length - 2) / 6;
  let bestScore = Infinity;
  let bestOffset = 0;
  const len2 = fromSubBeziers.length;
  const len22 = len2 - 2;
  for (let offset = 0; offset < bezierCount; offset++) {
    const cursorOffset = offset * 6;
    let score = 0;
    for (let k = 0; k < len2; k += 2) {
      let idx = k === 0 ? cursorOffset : (cursorOffset + k - 2) % len22 + 2;
      const x0 = fromSubBeziers[idx] - fromCp[0];
      const y0 = fromSubBeziers[idx + 1] - fromCp[1];
      const x1 = toSubBeziers[k] - toCp[0];
      const y1 = toSubBeziers[k + 1] - toCp[1];
      const dx = x1 - x0;
      const dy = y1 - y0;
      score += dx * dx + dy * dy;
    }
    if (score < bestScore) {
      bestScore = score;
      bestOffset = offset;
    }
  }
  return bestOffset;
}
function reverse(array) {
  const newArr = [];
  const len2 = array.length;
  for (let i = 0; i < len2; i += 2) {
    newArr[i] = array[len2 - i - 2];
    newArr[i + 1] = array[len2 - i - 1];
  }
  return newArr;
}
function findBestMorphingRotation(fromArr, toArr2, searchAngleIteration, searchAngleRange) {
  const result = [];
  let fromNeedsReverse;
  for (let i = 0; i < fromArr.length; i++) {
    let fromSubpathBezier = fromArr[i];
    const toSubpathBezier = toArr2[i];
    const fromCp = centroid2(fromSubpathBezier);
    const toCp = centroid2(toSubpathBezier);
    if (fromNeedsReverse == null) {
      fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;
    }
    const newFromSubpathBezier = [];
    const newToSubpathBezier = [];
    let bestAngle = 0;
    let bestScore = Infinity;
    let tmpArr2 = [];
    const len2 = fromSubpathBezier.length;
    if (fromNeedsReverse) {
      fromSubpathBezier = reverse(fromSubpathBezier);
    }
    const offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;
    const len22 = len2 - 2;
    for (let k = 0; k < len22; k += 2) {
      const idx = (offset + k) % len22 + 2;
      newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];
      newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];
    }
    newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];
    newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];
    if (searchAngleIteration > 0) {
      const step = searchAngleRange / searchAngleIteration;
      for (let angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {
        const sa = Math.sin(angle);
        const ca = Math.cos(angle);
        let score = 0;
        for (let k = 0; k < fromSubpathBezier.length; k += 2) {
          const x0 = newFromSubpathBezier[k];
          const y0 = newFromSubpathBezier[k + 1];
          const x1 = toSubpathBezier[k] - toCp[0];
          const y1 = toSubpathBezier[k + 1] - toCp[1];
          const newX1 = x1 * ca - y1 * sa;
          const newY1 = x1 * sa + y1 * ca;
          tmpArr2[k] = newX1;
          tmpArr2[k + 1] = newY1;
          const dx = newX1 - x0;
          const dy = newY1 - y0;
          score += dx * dx + dy * dy;
        }
        if (score < bestScore) {
          bestScore = score;
          bestAngle = angle;
          for (let m2 = 0; m2 < tmpArr2.length; m2++) {
            newToSubpathBezier[m2] = tmpArr2[m2];
          }
        }
      }
    } else {
      for (let i2 = 0; i2 < len2; i2 += 2) {
        newToSubpathBezier[i2] = toSubpathBezier[i2] - toCp[0];
        newToSubpathBezier[i2 + 1] = toSubpathBezier[i2 + 1] - toCp[1];
      }
    }
    result.push({
      from: newFromSubpathBezier,
      to: newToSubpathBezier,
      fromCp,
      toCp,
      rotation: -bestAngle
    });
  }
  return result;
}
function isCombineMorphing(path) {
  return path.__isCombineMorphing;
}
var SAVED_METHOD_PREFIX = "__mOriginal_";
function saveAndModifyMethod(obj, methodName, modifiers) {
  const savedMethodName = SAVED_METHOD_PREFIX + methodName;
  const originalMethod = obj[savedMethodName] || obj[methodName];
  if (!obj[savedMethodName]) {
    obj[savedMethodName] = obj[methodName];
  }
  const replace = modifiers.replace;
  const after = modifiers.after;
  const before = modifiers.before;
  obj[methodName] = function() {
    const args = arguments;
    let res;
    before && before.apply(this, args);
    if (replace) {
      res = replace.apply(this, args);
    } else {
      res = originalMethod.apply(this, args);
    }
    after && after.apply(this, args);
    return res;
  };
}
function restoreMethod(obj, methodName) {
  const savedMethodName = SAVED_METHOD_PREFIX + methodName;
  if (obj[savedMethodName]) {
    obj[methodName] = obj[savedMethodName];
    obj[savedMethodName] = null;
  }
}
function applyTransformOnBeziers(bezierCurves, mm) {
  for (let i = 0; i < bezierCurves.length; i++) {
    const subBeziers = bezierCurves[i];
    for (let k = 0; k < subBeziers.length; ) {
      const x = subBeziers[k];
      const y = subBeziers[k + 1];
      subBeziers[k++] = mm[0] * x + mm[2] * y + mm[4];
      subBeziers[k++] = mm[1] * x + mm[3] * y + mm[5];
    }
  }
}
function prepareMorphPath(fromPath, toPath) {
  const fromPathProxy = fromPath.getUpdatedPathProxy();
  const toPathProxy = toPath.getUpdatedPathProxy();
  const [fromBezierCurves, toBezierCurves] = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy));
  const fromPathTransform = fromPath.getComputedTransform();
  const toPathTransform = toPath.getComputedTransform();
  function updateIdentityTransform() {
    this.transform = null;
  }
  fromPathTransform && applyTransformOnBeziers(fromBezierCurves, fromPathTransform);
  toPathTransform && applyTransformOnBeziers(toBezierCurves, toPathTransform);
  saveAndModifyMethod(toPath, "updateTransform", {replace: updateIdentityTransform});
  toPath.transform = null;
  const morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);
  const tmpArr2 = [];
  saveAndModifyMethod(toPath, "buildPath", {replace(path) {
    const t = toPath.__morphT;
    const onet = 1 - t;
    const newCp = [];
    for (let i = 0; i < morphingData.length; i++) {
      const item = morphingData[i];
      const from = item.from;
      const to = item.to;
      const angle = item.rotation * t;
      const fromCp = item.fromCp;
      const toCp = item.toCp;
      const sa = Math.sin(angle);
      const ca = Math.cos(angle);
      lerp(newCp, fromCp, toCp, t);
      for (let m2 = 0; m2 < from.length; m2 += 2) {
        const x02 = from[m2];
        const y02 = from[m2 + 1];
        const x1 = to[m2];
        const y1 = to[m2 + 1];
        const x = x02 * onet + x1 * t;
        const y = y02 * onet + y1 * t;
        tmpArr2[m2] = x * ca - y * sa + newCp[0];
        tmpArr2[m2 + 1] = x * sa + y * ca + newCp[1];
      }
      let x0 = tmpArr2[0];
      let y0 = tmpArr2[1];
      path.moveTo(x0, y0);
      for (let m2 = 2; m2 < from.length; ) {
        const x1 = tmpArr2[m2++];
        const y1 = tmpArr2[m2++];
        const x2 = tmpArr2[m2++];
        const y2 = tmpArr2[m2++];
        const x3 = tmpArr2[m2++];
        const y3 = tmpArr2[m2++];
        if (x0 === x1 && y0 === y1 && x2 === x3 && y2 === y3) {
          path.lineTo(x3, y3);
        } else {
          path.bezierCurveTo(x1, y1, x2, y2, x3, y3);
        }
        x0 = x3;
        y0 = y3;
      }
    }
  }});
}
function morphPath(fromPath, toPath, animationOpts) {
  if (!fromPath || !toPath) {
    return toPath;
  }
  const oldDone = animationOpts.done;
  const oldDuring = animationOpts.during;
  prepareMorphPath(fromPath, toPath);
  toPath.__morphT = 0;
  function restoreToPath() {
    restoreMethod(toPath, "buildPath");
    restoreMethod(toPath, "updateTransform");
    toPath.__morphT = -1;
    toPath.createPathProxy();
    toPath.dirtyShape();
  }
  toPath.animateTo({
    __morphT: 1
  }, defaults({
    during(p) {
      toPath.dirtyShape();
      oldDuring && oldDuring(p);
    },
    done() {
      restoreToPath();
      oldDone && oldDone();
    }
  }, animationOpts));
  return toPath;
}
function hilbert(x, y, minX, minY, maxX, maxY) {
  const bits = 16;
  x = maxX === minX ? 0 : Math.round(32767 * (x - minX) / (maxX - minX));
  y = maxY === minY ? 0 : Math.round(32767 * (y - minY) / (maxY - minY));
  let d = 0;
  let tmp;
  for (let s = (1 << bits) / 2; s > 0; s /= 2) {
    let rx = 0;
    let ry = 0;
    if ((x & s) > 0) {
      rx = 1;
    }
    if ((y & s) > 0) {
      ry = 1;
    }
    d += s * s * (3 * rx ^ ry);
    if (ry === 0) {
      if (rx === 1) {
        x = s - 1 - x;
        y = s - 1 - y;
      }
      tmp = x;
      x = y;
      y = tmp;
    }
  }
  return d;
}
function sortPaths(pathList) {
  let xMin = Infinity;
  let yMin = Infinity;
  let xMax = -Infinity;
  let yMax = -Infinity;
  const cps = map(pathList, (path) => {
    const rect = path.getBoundingRect();
    const m2 = path.getComputedTransform();
    const x = rect.x + rect.width / 2 + (m2 ? m2[4] : 0);
    const y = rect.y + rect.height / 2 + (m2 ? m2[5] : 0);
    xMin = Math.min(x, xMin);
    yMin = Math.min(y, yMin);
    xMax = Math.max(x, xMax);
    yMax = Math.max(y, yMax);
    return [x, y];
  });
  const items = map(cps, (cp, idx) => {
    return {
      cp,
      z: hilbert(cp[0], cp[1], xMin, yMin, xMax, yMax),
      path: pathList[idx]
    };
  });
  return items.sort((a, b) => a.z - b.z).map((item) => item.path);
}
function defaultDividePath(param) {
  return split(param.path, param.count);
}
function createEmptyReturn() {
  return {
    fromIndividuals: [],
    toIndividuals: [],
    count: 0
  };
}
function combineMorph(fromList, toPath, animationOpts) {
  let fromPathList = [];
  function addFromPath(fromList2) {
    for (let i = 0; i < fromList2.length; i++) {
      const from = fromList2[i];
      if (isCombineMorphing(from)) {
        addFromPath(from.childrenRef());
      } else if (from instanceof Path_default) {
        fromPathList.push(from);
      }
    }
  }
  addFromPath(fromList);
  const separateCount = fromPathList.length;
  if (!separateCount) {
    return createEmptyReturn();
  }
  const dividePath = animationOpts.dividePath || defaultDividePath;
  let toSubPathList = dividePath({
    path: toPath,
    count: separateCount
  });
  if (toSubPathList.length !== separateCount) {
    console.error("Invalid morphing: unmatched splitted path");
    return createEmptyReturn();
  }
  fromPathList = sortPaths(fromPathList);
  toSubPathList = sortPaths(toSubPathList);
  const oldDone = animationOpts.done;
  const oldDuring = animationOpts.during;
  const individualDelay = animationOpts.individualDelay;
  const identityTransform = new Transformable_default();
  for (let i = 0; i < separateCount; i++) {
    const from = fromPathList[i];
    const to = toSubPathList[i];
    to.parent = toPath;
    to.copyTransform(identityTransform);
    if (!individualDelay) {
      prepareMorphPath(from, to);
    }
  }
  toPath.__isCombineMorphing = true;
  toPath.childrenRef = function() {
    return toSubPathList;
  };
  function addToSubPathListToZr(zr) {
    for (let i = 0; i < toSubPathList.length; i++) {
      toSubPathList[i].addSelfToZr(zr);
    }
  }
  saveAndModifyMethod(toPath, "addSelfToZr", {
    after(zr) {
      addToSubPathListToZr(zr);
    }
  });
  saveAndModifyMethod(toPath, "removeSelfFromZr", {
    after(zr) {
      for (let i = 0; i < toSubPathList.length; i++) {
        toSubPathList[i].removeSelfFromZr(zr);
      }
    }
  });
  function restoreToPath() {
    toPath.__isCombineMorphing = false;
    toPath.__morphT = -1;
    toPath.childrenRef = null;
    restoreMethod(toPath, "addSelfToZr");
    restoreMethod(toPath, "removeSelfFromZr");
  }
  const toLen = toSubPathList.length;
  if (individualDelay) {
    let animating = toLen;
    const eachDone = () => {
      animating--;
      if (animating === 0) {
        restoreToPath();
        oldDone && oldDone();
      }
    };
    for (let i = 0; i < toLen; i++) {
      const indivdualAnimationOpts = individualDelay ? defaults({
        delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toSubPathList[i]),
        done: eachDone
      }, animationOpts) : animationOpts;
      morphPath(fromPathList[i], toSubPathList[i], indivdualAnimationOpts);
    }
  } else {
    toPath.__morphT = 0;
    toPath.animateTo({
      __morphT: 1
    }, defaults({
      during(p) {
        for (let i = 0; i < toLen; i++) {
          const child = toSubPathList[i];
          child.__morphT = toPath.__morphT;
          child.dirtyShape();
        }
        oldDuring && oldDuring(p);
      },
      done() {
        restoreToPath();
        for (let i = 0; i < fromList.length; i++) {
          restoreMethod(fromList[i], "updateTransform");
        }
        oldDone && oldDone();
      }
    }, animationOpts));
  }
  if (toPath.__zr) {
    addToSubPathListToZr(toPath.__zr);
  }
  return {
    fromIndividuals: fromPathList,
    toIndividuals: toSubPathList,
    count: toLen
  };
}
function separateMorph(fromPath, toPathList, animationOpts) {
  const toLen = toPathList.length;
  let fromPathList = [];
  const dividePath = animationOpts.dividePath || defaultDividePath;
  function addFromPath(fromList) {
    for (let i = 0; i < fromList.length; i++) {
      const from = fromList[i];
      if (isCombineMorphing(from)) {
        addFromPath(from.childrenRef());
      } else if (from instanceof Path_default) {
        fromPathList.push(from);
      }
    }
  }
  if (isCombineMorphing(fromPath)) {
    addFromPath(fromPath.childrenRef());
    const fromLen = fromPathList.length;
    if (fromLen < toLen) {
      let k = 0;
      for (let i = fromLen; i < toLen; i++) {
        fromPathList.push(clonePath(fromPathList[k++ % fromLen]));
      }
    }
    fromPathList.length = toLen;
  } else {
    fromPathList = dividePath({path: fromPath, count: toLen});
    const fromPathTransform = fromPath.getComputedTransform();
    for (let i = 0; i < fromPathList.length; i++) {
      fromPathList[i].setLocalTransform(fromPathTransform);
    }
    if (fromPathList.length !== toLen) {
      console.error("Invalid morphing: unmatched splitted path");
      return createEmptyReturn();
    }
  }
  fromPathList = sortPaths(fromPathList);
  toPathList = sortPaths(toPathList);
  const individualDelay = animationOpts.individualDelay;
  for (let i = 0; i < toLen; i++) {
    const indivdualAnimationOpts = individualDelay ? defaults({
      delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toPathList[i])
    }, animationOpts) : animationOpts;
    morphPath(fromPathList[i], toPathList[i], indivdualAnimationOpts);
  }
  return {
    fromIndividuals: fromPathList,
    toIndividuals: toPathList,
    count: toPathList.length
  };
}

// src/animation/morphTransitionHelper.ts
function isMultiple(elements) {
  return isArray(elements[0]);
}
function prepareMorphBatches(one, many) {
  const batches = [];
  const batchCount = one.length;
  for (let i = 0; i < batchCount; i++) {
    batches.push({
      one: one[i],
      many: []
    });
  }
  for (let i = 0; i < many.length; i++) {
    const len2 = many[i].length;
    let k;
    for (k = 0; k < len2; k++) {
      batches[k % batchCount].many.push(many[i][k]);
    }
  }
  let off = 0;
  for (let i = batchCount - 1; i >= 0; i--) {
    if (!batches[i].many.length) {
      const moveFrom = batches[off].many;
      if (moveFrom.length <= 1) {
        if (off) {
          off = 0;
        } else {
          return batches;
        }
      }
      const len2 = moveFrom.length;
      const mid = Math.ceil(len2 / 2);
      batches[i].many = moveFrom.slice(mid, len2);
      batches[off].many = moveFrom.slice(0, mid);
      off++;
    }
  }
  return batches;
}
var pathDividers = {
  clone(params) {
    const ret = [];
    const approxOpacity = 1 - Math.pow(1 - params.path.style.opacity, 1 / params.count);
    for (let i = 0; i < params.count; i++) {
      const cloned = clonePath(params.path);
      cloned.setStyle("opacity", approxOpacity);
      ret.push(cloned);
    }
    return ret;
  },
  split: null
};
function applyMorphAnimation(from, to, divideShape, seriesModel, dataIndex, animateOtherProps) {
  if (!from.length || !to.length) {
    return;
  }
  const updateAnimationCfg = getAnimationConfig("update", seriesModel, dataIndex);
  if (!(updateAnimationCfg && updateAnimationCfg.duration > 0)) {
    return;
  }
  const animationDelay = seriesModel.getModel("universalTransition").get("delay");
  const animationCfg = Object.assign({
    setToFinal: true
  }, updateAnimationCfg);
  let many;
  let one;
  if (isMultiple(from)) {
    many = from;
    one = to;
  }
  if (isMultiple(to)) {
    many = to;
    one = from;
  }
  function morphOneBatch(batch, fromIsMany2, animateIndex2, animateCount2, forceManyOne) {
    const batchMany = batch.many;
    const batchOne = batch.one;
    if (batchMany.length === 1 && !forceManyOne) {
      const batchFrom = fromIsMany2 ? batchMany[0] : batchOne;
      const batchTo = fromIsMany2 ? batchOne : batchMany[0];
      if (isCombineMorphing(batchFrom)) {
        morphOneBatch({
          many: [batchFrom],
          one: batchTo
        }, true, animateIndex2, animateCount2, true);
      } else {
        const individualAnimationCfg = animationDelay ? defaults({
          delay: animationDelay(animateIndex2, animateCount2)
        }, animationCfg) : animationCfg;
        morphPath(batchFrom, batchTo, individualAnimationCfg);
        animateOtherProps(batchFrom, batchTo, batchFrom, batchTo, individualAnimationCfg);
      }
    } else {
      const separateAnimationCfg = defaults({
        dividePath: pathDividers[divideShape],
        individualDelay: animationDelay && function(idx, count3, fromPath, toPath) {
          return animationDelay(idx + animateIndex2, animateCount2);
        }
      }, animationCfg);
      const {
        fromIndividuals,
        toIndividuals
      } = fromIsMany2 ? combineMorph(batchMany, batchOne, separateAnimationCfg) : separateMorph(batchOne, batchMany, separateAnimationCfg);
      const count2 = fromIndividuals.length;
      for (let k = 0; k < count2; k++) {
        const individualAnimationCfg = animationDelay ? defaults({
          delay: animationDelay(k, count2)
        }, animationCfg) : animationCfg;
        animateOtherProps(fromIndividuals[k], toIndividuals[k], fromIsMany2 ? batchMany[k] : batch.one, fromIsMany2 ? batch.one : batchMany[k], individualAnimationCfg);
      }
    }
  }
  const fromIsMany = many ? many === from : from.length > to.length;
  const morphBatches = many ? prepareMorphBatches(one, many) : prepareMorphBatches(fromIsMany ? to : from, [fromIsMany ? from : to]);
  let animateCount = 0;
  for (let i = 0; i < morphBatches.length; i++) {
    animateCount += morphBatches[i].many.length;
  }
  let animateIndex = 0;
  for (let i = 0; i < morphBatches.length; i++) {
    morphOneBatch(morphBatches[i], fromIsMany, animateIndex, animateCount);
    animateIndex += morphBatches[i].many.length;
  }
}
function getPathList(elements) {
  if (!elements) {
    return [];
  }
  if (isArray(elements)) {
    const pathList2 = [];
    for (let i = 0; i < elements.length; i++) {
      pathList2.push(getPathList(elements[i]));
    }
    return pathList2;
  }
  const pathList = [];
  elements.traverse((el) => {
    if (el instanceof Path_default && !el.disableMorphing && !el.invisible && !el.ignore) {
      pathList.push(el);
    }
  });
  return pathList;
}

// src/animation/universalTransition.ts
var DATA_COUNT_THRESHOLD = 1e4;
var TRANSITION_NONE = 0;
var TRANSITION_P2C = 1;
var TRANSITION_C2P = 2;
var getUniversalTransitionGlobalStore = makeInner();
function getDimension(data, visualDimension) {
  const dimensions = data.dimensions;
  for (let i = 0; i < dimensions.length; i++) {
    const dimInfo = data.getDimensionInfo(dimensions[i]);
    if (dimInfo && dimInfo.otherDims[visualDimension] === 0) {
      return dimensions[i];
    }
  }
}
function getValueByDimension(data, dataIndex, dimension) {
  const dimInfo = data.getDimensionInfo(dimension);
  const dimOrdinalMeta = dimInfo && dimInfo.ordinalMeta;
  if (dimInfo) {
    const value = data.get(dimInfo.name, dataIndex);
    if (dimOrdinalMeta) {
      return dimOrdinalMeta.categories[value] || value + "";
    }
    return value + "";
  }
}
function getGroupId(data, dataIndex, dataGroupId, isChild) {
  const visualDimension = isChild ? "itemChildGroupId" : "itemGroupId";
  const groupIdDim = getDimension(data, visualDimension);
  if (groupIdDim) {
    const groupId = getValueByDimension(data, dataIndex, groupIdDim);
    return groupId;
  }
  const rawDataItem = data.getRawDataItem(dataIndex);
  const property = isChild ? "childGroupId" : "groupId";
  if (rawDataItem && rawDataItem[property]) {
    return rawDataItem[property] + "";
  }
  if (isChild) {
    return;
  }
  return dataGroupId || data.getId(dataIndex);
}
function flattenDataDiffItems(list) {
  const items = [];
  each(list, (seriesInfo) => {
    const data = seriesInfo.data;
    const dataGroupId = seriesInfo.dataGroupId;
    if (data.count() > DATA_COUNT_THRESHOLD) {
      if (true) {
        warn("Universal transition is disabled on large data > 10k.");
      }
      return;
    }
    const indices = data.getIndices();
    for (let dataIndex = 0; dataIndex < indices.length; dataIndex++) {
      items.push({
        data,
        groupId: getGroupId(data, dataIndex, dataGroupId, false),
        childGroupId: getGroupId(data, dataIndex, dataGroupId, true),
        divide: seriesInfo.divide,
        dataIndex
      });
    }
  });
  return items;
}
function fadeInElement(newEl2, newSeries, newIndex) {
  newEl2.traverse((el) => {
    if (el instanceof Path_default) {
      initProps(el, {
        style: {
          opacity: 0
        }
      }, newSeries, {
        dataIndex: newIndex,
        isFrom: true
      });
    }
  });
}
function removeEl2(el) {
  if (el.parent) {
    const computedTransform = el.getComputedTransform();
    el.setLocalTransform(computedTransform);
    el.parent.remove(el);
  }
}
function stopAnimation(el) {
  el.stopAnimation();
  if (el.isGroup) {
    el.traverse((child) => {
      child.stopAnimation();
    });
  }
}
function animateElementStyles(el, dataIndex, seriesModel) {
  const animationConfig = getAnimationConfig("update", seriesModel, dataIndex);
  animationConfig && el.traverse((child) => {
    if (child instanceof Displayable_default) {
      const oldStyle = getOldStyle(child);
      if (oldStyle) {
        child.animateFrom({
          style: oldStyle
        }, animationConfig);
      }
    }
  });
}
function isAllIdSame(oldDiffItems, newDiffItems) {
  const len2 = oldDiffItems.length;
  if (len2 !== newDiffItems.length) {
    return false;
  }
  for (let i = 0; i < len2; i++) {
    const oldItem = oldDiffItems[i];
    const newItem = newDiffItems[i];
    if (oldItem.data.getId(oldItem.dataIndex) !== newItem.data.getId(newItem.dataIndex)) {
      return false;
    }
  }
  return true;
}
function transitionBetween(oldList, newList, api2) {
  const oldDiffItems = flattenDataDiffItems(oldList);
  const newDiffItems = flattenDataDiffItems(newList);
  function updateMorphingPathProps(from, to, rawFrom, rawTo, animationCfg) {
    if (rawFrom || from) {
      to.animateFrom({
        style: rawFrom && rawFrom !== from ? extend(extend({}, rawFrom.style), from.style) : from.style
      }, animationCfg);
    }
  }
  let hasMorphAnimation = false;
  let direction = TRANSITION_NONE;
  const oldGroupIds = createHashMap();
  const oldChildGroupIds = createHashMap();
  oldDiffItems.forEach((item) => {
    item.groupId && oldGroupIds.set(item.groupId, true);
    item.childGroupId && oldChildGroupIds.set(item.childGroupId, true);
  });
  for (let i = 0; i < newDiffItems.length; i++) {
    const newGroupId = newDiffItems[i].groupId;
    if (oldChildGroupIds.get(newGroupId)) {
      direction = TRANSITION_P2C;
      break;
    }
    const newChildGroupId = newDiffItems[i].childGroupId;
    if (newChildGroupId && oldGroupIds.get(newChildGroupId)) {
      direction = TRANSITION_C2P;
      break;
    }
  }
  function createKeyGetter(isOld, onlyGetId) {
    return function(diffItem) {
      const data = diffItem.data;
      const dataIndex = diffItem.dataIndex;
      if (onlyGetId) {
        return data.getId(dataIndex);
      }
      if (isOld) {
        return direction === TRANSITION_P2C ? diffItem.childGroupId : diffItem.groupId;
      } else {
        return direction === TRANSITION_C2P ? diffItem.childGroupId : diffItem.groupId;
      }
    };
  }
  const useId = isAllIdSame(oldDiffItems, newDiffItems);
  const isElementStillInChart = {};
  if (!useId) {
    for (let i = 0; i < newDiffItems.length; i++) {
      const newItem = newDiffItems[i];
      const el = newItem.data.getItemGraphicEl(newItem.dataIndex);
      if (el) {
        isElementStillInChart[el.id] = true;
      }
    }
  }
  function updateOneToOne(newIndex, oldIndex) {
    const oldItem = oldDiffItems[oldIndex];
    const newItem = newDiffItems[newIndex];
    const newSeries = newItem.data.hostModel;
    const oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);
    const newEl2 = newItem.data.getItemGraphicEl(newItem.dataIndex);
    if (oldEl === newEl2) {
      newEl2 && animateElementStyles(newEl2, newItem.dataIndex, newSeries);
      return;
    }
    if (oldEl && isElementStillInChart[oldEl.id]) {
      return;
    }
    if (newEl2) {
      stopAnimation(newEl2);
      if (oldEl) {
        stopAnimation(oldEl);
        removeEl2(oldEl);
        hasMorphAnimation = true;
        applyMorphAnimation(getPathList(oldEl), getPathList(newEl2), newItem.divide, newSeries, newIndex, updateMorphingPathProps);
      } else {
        fadeInElement(newEl2, newSeries, newIndex);
      }
    }
  }
  new DataDiffer_default(oldDiffItems, newDiffItems, createKeyGetter(true, useId), createKeyGetter(false, useId), null, "multiple").update(updateOneToOne).updateManyToOne(function(newIndex, oldIndices) {
    const newItem = newDiffItems[newIndex];
    const newData = newItem.data;
    const newSeries = newData.hostModel;
    const newEl2 = newData.getItemGraphicEl(newItem.dataIndex);
    const oldElsList = filter(map(oldIndices, (idx) => oldDiffItems[idx].data.getItemGraphicEl(oldDiffItems[idx].dataIndex)), (oldEl) => oldEl && oldEl !== newEl2 && !isElementStillInChart[oldEl.id]);
    if (newEl2) {
      stopAnimation(newEl2);
      if (oldElsList.length) {
        each(oldElsList, (oldEl) => {
          stopAnimation(oldEl);
          removeEl2(oldEl);
        });
        hasMorphAnimation = true;
        applyMorphAnimation(getPathList(oldElsList), getPathList(newEl2), newItem.divide, newSeries, newIndex, updateMorphingPathProps);
      } else {
        fadeInElement(newEl2, newSeries, newItem.dataIndex);
      }
    }
  }).updateOneToMany(function(newIndices, oldIndex) {
    const oldItem = oldDiffItems[oldIndex];
    const oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);
    if (oldEl && isElementStillInChart[oldEl.id]) {
      return;
    }
    const newElsList = filter(map(newIndices, (idx) => newDiffItems[idx].data.getItemGraphicEl(newDiffItems[idx].dataIndex)), (el) => el && el !== oldEl);
    const newSeris = newDiffItems[newIndices[0]].data.hostModel;
    if (newElsList.length) {
      each(newElsList, (newEl2) => stopAnimation(newEl2));
      if (oldEl) {
        stopAnimation(oldEl);
        removeEl2(oldEl);
        hasMorphAnimation = true;
        applyMorphAnimation(getPathList(oldEl), getPathList(newElsList), oldItem.divide, newSeris, newIndices[0], updateMorphingPathProps);
      } else {
        each(newElsList, (newEl2) => fadeInElement(newEl2, newSeris, newIndices[0]));
      }
    }
  }).updateManyToMany(function(newIndices, oldIndices) {
    new DataDiffer_default(oldIndices, newIndices, (rawIdx) => oldDiffItems[rawIdx].data.getId(oldDiffItems[rawIdx].dataIndex), (rawIdx) => newDiffItems[rawIdx].data.getId(newDiffItems[rawIdx].dataIndex)).update((newIndex, oldIndex) => {
      updateOneToOne(newIndices[newIndex], oldIndices[oldIndex]);
    }).execute();
  }).execute();
  if (hasMorphAnimation) {
    each(newList, ({data}) => {
      const seriesModel = data.hostModel;
      const view = seriesModel && api2.getViewOfSeriesModel(seriesModel);
      const animationCfg = getAnimationConfig("update", seriesModel, 0);
      if (view && seriesModel.isAnimationEnabled() && animationCfg && animationCfg.duration > 0) {
        view.group.traverse((el) => {
          if (el instanceof Path_default && !el.animators.length) {
            el.animateFrom({
              style: {
                opacity: 0
              }
            }, animationCfg);
          }
        });
      }
    });
  }
}
function getSeriesTransitionKey(series) {
  const seriesKey = series.getModel("universalTransition").get("seriesKey");
  if (!seriesKey) {
    return series.id;
  }
  return seriesKey;
}
function convertArraySeriesKeyToString(seriesKey) {
  if (isArray(seriesKey)) {
    return seriesKey.sort().join(",");
  }
  return seriesKey;
}
function getDivideShapeFromData(data) {
  if (data.hostModel) {
    return data.hostModel.getModel("universalTransition").get("divideShape");
  }
}
function findTransitionSeriesBatches(globalStore, params) {
  const updateBatches = createHashMap();
  const oldDataMap = createHashMap();
  const oldDataMapForSplit = createHashMap();
  each(globalStore.oldSeries, (series, idx) => {
    const oldDataGroupId = globalStore.oldDataGroupIds[idx];
    const oldData = globalStore.oldData[idx];
    const transitionKey = getSeriesTransitionKey(series);
    const transitionKeyStr = convertArraySeriesKeyToString(transitionKey);
    oldDataMap.set(transitionKeyStr, {
      dataGroupId: oldDataGroupId,
      data: oldData
    });
    if (isArray(transitionKey)) {
      each(transitionKey, (key) => {
        oldDataMapForSplit.set(key, {
          key: transitionKeyStr,
          dataGroupId: oldDataGroupId,
          data: oldData
        });
      });
    }
  });
  function checkTransitionSeriesKeyDuplicated(transitionKeyStr) {
    if (updateBatches.get(transitionKeyStr)) {
      warn(`Duplicated seriesKey in universalTransition ${transitionKeyStr}`);
    }
  }
  each(params.updatedSeries, (series) => {
    if (series.isUniversalTransitionEnabled() && series.isAnimationEnabled()) {
      const newDataGroupId = series.get("dataGroupId");
      const newData = series.getData();
      const transitionKey = getSeriesTransitionKey(series);
      const transitionKeyStr = convertArraySeriesKeyToString(transitionKey);
      const oldData = oldDataMap.get(transitionKeyStr);
      if (oldData) {
        if (true) {
          checkTransitionSeriesKeyDuplicated(transitionKeyStr);
        }
        updateBatches.set(transitionKeyStr, {
          oldSeries: [{
            dataGroupId: oldData.dataGroupId,
            divide: getDivideShapeFromData(oldData.data),
            data: oldData.data
          }],
          newSeries: [{
            dataGroupId: newDataGroupId,
            divide: getDivideShapeFromData(newData),
            data: newData
          }]
        });
      } else {
        if (isArray(transitionKey)) {
          if (true) {
            checkTransitionSeriesKeyDuplicated(transitionKeyStr);
          }
          const oldSeries = [];
          each(transitionKey, (key) => {
            const oldData2 = oldDataMap.get(key);
            if (oldData2.data) {
              oldSeries.push({
                dataGroupId: oldData2.dataGroupId,
                divide: getDivideShapeFromData(oldData2.data),
                data: oldData2.data
              });
            }
          });
          if (oldSeries.length) {
            updateBatches.set(transitionKeyStr, {
              oldSeries,
              newSeries: [{
                dataGroupId: newDataGroupId,
                data: newData,
                divide: getDivideShapeFromData(newData)
              }]
            });
          }
        } else {
          const oldData2 = oldDataMapForSplit.get(transitionKey);
          if (oldData2) {
            let batch = updateBatches.get(oldData2.key);
            if (!batch) {
              batch = {
                oldSeries: [{
                  dataGroupId: oldData2.dataGroupId,
                  data: oldData2.data,
                  divide: getDivideShapeFromData(oldData2.data)
                }],
                newSeries: []
              };
              updateBatches.set(oldData2.key, batch);
            }
            batch.newSeries.push({
              dataGroupId: newDataGroupId,
              data: newData,
              divide: getDivideShapeFromData(newData)
            });
          }
        }
      }
    }
  });
  return updateBatches;
}
function querySeries(series, finder) {
  for (let i = 0; i < series.length; i++) {
    const found = finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id;
    if (found) {
      return i;
    }
  }
}
function transitionSeriesFromOpt(transitionOpt, globalStore, params, api2) {
  const from = [];
  const to = [];
  each(normalizeToArray(transitionOpt.from), (finder) => {
    const idx = querySeries(globalStore.oldSeries, finder);
    if (idx >= 0) {
      from.push({
        dataGroupId: globalStore.oldDataGroupIds[idx],
        data: globalStore.oldData[idx],
        divide: getDivideShapeFromData(globalStore.oldData[idx]),
        groupIdDim: finder.dimension
      });
    }
  });
  each(normalizeToArray(transitionOpt.to), (finder) => {
    const idx = querySeries(params.updatedSeries, finder);
    if (idx >= 0) {
      const data = params.updatedSeries[idx].getData();
      to.push({
        dataGroupId: globalStore.oldDataGroupIds[idx],
        data,
        divide: getDivideShapeFromData(data),
        groupIdDim: finder.dimension
      });
    }
  });
  if (from.length > 0 && to.length > 0) {
    transitionBetween(from, to, api2);
  }
}
function installUniversalTransition(registers) {
  registers.registerUpdateLifecycle("series:beforeupdate", (ecMOdel, api2, params) => {
    each(normalizeToArray(params.seriesTransition), (transOpt) => {
      each(normalizeToArray(transOpt.to), (finder) => {
        const series = params.updatedSeries;
        for (let i = 0; i < series.length; i++) {
          if (finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id) {
            series[i][SERIES_UNIVERSAL_TRANSITION_PROP] = true;
          }
        }
      });
    });
  });
  registers.registerUpdateLifecycle("series:transition", (ecModel, api2, params) => {
    const globalStore = getUniversalTransitionGlobalStore(api2);
    if (globalStore.oldSeries && params.updatedSeries && params.optionChanged) {
      const transitionOpt = params.seriesTransition;
      if (transitionOpt) {
        each(normalizeToArray(transitionOpt), (opt) => {
          transitionSeriesFromOpt(opt, globalStore, params, api2);
        });
      } else {
        const updateBatches = findTransitionSeriesBatches(globalStore, params);
        each(updateBatches.keys(), (key) => {
          const batch = updateBatches.get(key);
          transitionBetween(batch.oldSeries, batch.newSeries, api2);
        });
      }
      each(params.updatedSeries, (series) => {
        if (series[SERIES_UNIVERSAL_TRANSITION_PROP]) {
          series[SERIES_UNIVERSAL_TRANSITION_PROP] = false;
        }
      });
    }
    const allSeries = ecModel.getSeries();
    const savedSeries = globalStore.oldSeries = [];
    const savedDataGroupIds = globalStore.oldDataGroupIds = [];
    const savedData = globalStore.oldData = [];
    for (let i = 0; i < allSeries.length; i++) {
      const data = allSeries[i].getData();
      if (data.count() < DATA_COUNT_THRESHOLD) {
        savedSeries.push(allSeries[i]);
        savedDataGroupIds.push(allSeries[i].get("dataGroupId"));
        savedData.push(data);
      }
    }
  });
}

// src/scale/breakImpl.ts
var ScaleBreakContextImpl = class {
  constructor() {
    this.breaks = [];
    this._elapsedExtent = [Infinity, -Infinity];
  }
  setBreaks(parsed) {
    this.breaks = parsed.breaks;
  }
  update(scaleExtent) {
    updateAxisBreakGapReal(this, scaleExtent);
    const elapsedExtent = this._elapsedExtent;
    elapsedExtent[0] = this.elapse(scaleExtent[0]);
    elapsedExtent[1] = this.elapse(scaleExtent[1]);
  }
  hasBreaks() {
    return !!this.breaks.length;
  }
  calcNiceTickMultiple(tickVal, estimateNiceMultiple) {
    for (let idx = 0; idx < this.breaks.length; idx++) {
      const brk = this.breaks[idx];
      if (brk.vmin < tickVal && tickVal < brk.vmax) {
        const multiple = estimateNiceMultiple(tickVal, brk.vmax);
        if (true) {
          assert(multiple >= 0 && Math.round(multiple) === multiple);
        }
        return multiple;
      }
    }
    return 0;
  }
  getExtentSpan() {
    return this._elapsedExtent[1] - this._elapsedExtent[0];
  }
  normalize(val) {
    const elapsedSpan = this._elapsedExtent[1] - this._elapsedExtent[0];
    if (elapsedSpan === 0) {
      return 0.5;
    }
    return (this.elapse(val) - this._elapsedExtent[0]) / elapsedSpan;
  }
  scale(val) {
    return this.unelapse(val * (this._elapsedExtent[1] - this._elapsedExtent[0]) + this._elapsedExtent[0]);
  }
  elapse(val) {
    let elapsedVal = AXIS_BREAK_ELAPSED_BASE;
    let lastBreakEnd = AXIS_BREAK_LAST_BREAK_END_BASE;
    let stillOver = true;
    for (let i = 0; i < this.breaks.length; i++) {
      const brk = this.breaks[i];
      if (val <= brk.vmax) {
        if (val > brk.vmin) {
          elapsedVal += brk.vmin - lastBreakEnd + (val - brk.vmin) / (brk.vmax - brk.vmin) * brk.gapReal;
        } else {
          elapsedVal += val - lastBreakEnd;
        }
        lastBreakEnd = brk.vmax;
        stillOver = false;
        break;
      }
      elapsedVal += brk.vmin - lastBreakEnd + brk.gapReal;
      lastBreakEnd = brk.vmax;
    }
    if (stillOver) {
      elapsedVal += val - lastBreakEnd;
    }
    return elapsedVal;
  }
  unelapse(elapsedVal) {
    let lastElapsedEnd = AXIS_BREAK_ELAPSED_BASE;
    let lastBreakEnd = AXIS_BREAK_LAST_BREAK_END_BASE;
    let stillOver = true;
    let unelapsedVal = 0;
    for (let i = 0; i < this.breaks.length; i++) {
      const brk = this.breaks[i];
      const elapsedStart = lastElapsedEnd + brk.vmin - lastBreakEnd;
      const elapsedEnd = elapsedStart + brk.gapReal;
      if (elapsedVal <= elapsedEnd) {
        if (elapsedVal > elapsedStart) {
          unelapsedVal = brk.vmin + (elapsedVal - elapsedStart) / (elapsedEnd - elapsedStart) * (brk.vmax - brk.vmin);
        } else {
          unelapsedVal = lastBreakEnd + elapsedVal - lastElapsedEnd;
        }
        lastBreakEnd = brk.vmax;
        stillOver = false;
        break;
      }
      lastElapsedEnd = elapsedEnd;
      lastBreakEnd = brk.vmax;
    }
    if (stillOver) {
      unelapsedVal = lastBreakEnd + elapsedVal - lastElapsedEnd;
    }
    return unelapsedVal;
  }
};
function createScaleBreakContext() {
  return new ScaleBreakContextImpl();
}
var AXIS_BREAK_ELAPSED_BASE = 0;
var AXIS_BREAK_LAST_BREAK_END_BASE = 0;
function updateAxisBreakGapReal(brkCtx, scaleExtent) {
  let gapPrctSum = 0;
  const fullyInExtBrksSum = {
    tpAbs: {span: 0, val: 0},
    tpPrct: {span: 0, val: 0}
  };
  const init4 = () => ({has: false, span: NaN, inExtFrac: NaN, val: NaN});
  const semiInExtBrk = {
    S: {tpAbs: init4(), tpPrct: init4()},
    E: {tpAbs: init4(), tpPrct: init4()}
  };
  each(brkCtx.breaks, (brk) => {
    const gapParsed = brk.gapParsed;
    if (gapParsed.type === "tpPrct") {
      gapPrctSum += gapParsed.val;
    }
    const clampedBrk = clampBreakByExtent(brk, scaleExtent);
    if (clampedBrk) {
      const vminClamped = clampedBrk.vmin !== brk.vmin;
      const vmaxClamped = clampedBrk.vmax !== brk.vmax;
      const clampedSpan = clampedBrk.vmax - clampedBrk.vmin;
      if (vminClamped && vmaxClamped) {
      } else if (vminClamped || vmaxClamped) {
        const sOrE = vminClamped ? "S" : "E";
        semiInExtBrk[sOrE][gapParsed.type].has = true;
        semiInExtBrk[sOrE][gapParsed.type].span = clampedSpan;
        semiInExtBrk[sOrE][gapParsed.type].inExtFrac = clampedSpan / (brk.vmax - brk.vmin);
        semiInExtBrk[sOrE][gapParsed.type].val = gapParsed.val;
      } else {
        fullyInExtBrksSum[gapParsed.type].span += clampedSpan;
        fullyInExtBrksSum[gapParsed.type].val += gapParsed.val;
      }
    }
  });
  const prctBrksGapRealSum = gapPrctSum * (0 + (scaleExtent[1] - scaleExtent[0]) + (fullyInExtBrksSum.tpAbs.val - fullyInExtBrksSum.tpAbs.span) + (semiInExtBrk.S.tpAbs.has ? (semiInExtBrk.S.tpAbs.val - semiInExtBrk.S.tpAbs.span) * semiInExtBrk.S.tpAbs.inExtFrac : 0) + (semiInExtBrk.E.tpAbs.has ? (semiInExtBrk.E.tpAbs.val - semiInExtBrk.E.tpAbs.span) * semiInExtBrk.E.tpAbs.inExtFrac : 0) - fullyInExtBrksSum.tpPrct.span - (semiInExtBrk.S.tpPrct.has ? semiInExtBrk.S.tpPrct.span * semiInExtBrk.S.tpPrct.inExtFrac : 0) - (semiInExtBrk.E.tpPrct.has ? semiInExtBrk.E.tpPrct.span * semiInExtBrk.E.tpPrct.inExtFrac : 0)) / (1 - fullyInExtBrksSum.tpPrct.val - (semiInExtBrk.S.tpPrct.has ? semiInExtBrk.S.tpPrct.val * semiInExtBrk.S.tpPrct.inExtFrac : 0) - (semiInExtBrk.E.tpPrct.has ? semiInExtBrk.E.tpPrct.val * semiInExtBrk.E.tpPrct.inExtFrac : 0));
  each(brkCtx.breaks, (brk) => {
    const gapParsed = brk.gapParsed;
    if (gapParsed.type === "tpPrct") {
      brk.gapReal = gapPrctSum !== 0 ? Math.max(prctBrksGapRealSum, 0) * gapParsed.val / gapPrctSum : 0;
    }
    if (gapParsed.type === "tpAbs") {
      brk.gapReal = gapParsed.val;
    }
    if (brk.gapReal == null) {
      brk.gapReal = 0;
    }
  });
}
function pruneTicksByBreak(pruneByBreak, ticks, breaks, getValue, interval, scaleExtent) {
  if (pruneByBreak === "no") {
    return;
  }
  each(breaks, (brk) => {
    const clampedBrk = clampBreakByExtent(brk, scaleExtent);
    if (!clampedBrk) {
      return;
    }
    for (let j = ticks.length - 1; j >= 0; j--) {
      const tick = ticks[j];
      const val = getValue(tick);
      const gap = interval * 3 / 4;
      if (val > clampedBrk.vmin - gap && val < clampedBrk.vmax + gap && (pruneByBreak !== "preserve_extent_bound" || val !== scaleExtent[0] && val !== scaleExtent[1])) {
        ticks.splice(j, 1);
      }
    }
  });
}
function addBreaksToTicks(ticks, breaks, scaleExtent, getTimeProps) {
  each(breaks, (brk) => {
    const clampedBrk = clampBreakByExtent(brk, scaleExtent);
    if (!clampedBrk) {
      return;
    }
    ticks.push({
      value: clampedBrk.vmin,
      break: {
        type: "vmin",
        parsedBreak: clampedBrk
      },
      time: getTimeProps ? getTimeProps(clampedBrk) : void 0
    });
    ticks.push({
      value: clampedBrk.vmax,
      break: {
        type: "vmax",
        parsedBreak: clampedBrk
      },
      time: getTimeProps ? getTimeProps(clampedBrk) : void 0
    });
  });
  if (breaks.length) {
    ticks.sort((a, b) => a.value - b.value);
  }
}
function clampBreakByExtent(brk, scaleExtent) {
  const vmin = Math.max(brk.vmin, scaleExtent[0]);
  const vmax = Math.min(brk.vmax, scaleExtent[1]);
  return vmin < vmax || vmin === vmax && vmin > scaleExtent[0] && vmin < scaleExtent[1] ? {
    vmin,
    vmax,
    breakOption: brk.breakOption,
    gapParsed: brk.gapParsed,
    gapReal: brk.gapReal
  } : null;
}
function parseAxisBreakOption(breakOptionList, parse2, opt) {
  const parsedBreaks = [];
  if (!breakOptionList) {
    return {breaks: parsedBreaks};
  }
  function validatePercent(normalizedPercent, msg) {
    if (normalizedPercent >= 0 && normalizedPercent < 1 - 1e-5) {
      return true;
    }
    if (true) {
      error(`${msg} must be >= 0 and < 1, rather than ${normalizedPercent} .`);
    }
    return false;
  }
  each(breakOptionList, (brkOption) => {
    if (!brkOption || brkOption.start == null || brkOption.end == null) {
      if (true) {
        error("The input axis breaks start/end should not be empty.");
      }
      return;
    }
    if (brkOption.isExpanded) {
      return;
    }
    const parsedBrk = {
      breakOption: clone(brkOption),
      vmin: parse2(brkOption.start),
      vmax: parse2(brkOption.end),
      gapParsed: {type: "tpAbs", val: 0},
      gapReal: null
    };
    if (brkOption.gap != null) {
      let isPrct = false;
      if (isString(brkOption.gap)) {
        const trimmedGap = trim(brkOption.gap);
        if (trimmedGap.match(/%$/)) {
          let normalizedPercent = parseFloat(trimmedGap) / 100;
          if (!validatePercent(normalizedPercent, "Percent gap")) {
            normalizedPercent = 0;
          }
          parsedBrk.gapParsed.type = "tpPrct";
          parsedBrk.gapParsed.val = normalizedPercent;
          isPrct = true;
        }
      }
      if (!isPrct) {
        let absolute = parse2(brkOption.gap);
        if (!isFinite(absolute) || absolute < 0) {
          if (true) {
            error(`Axis breaks gap must positive finite rather than (${brkOption.gap}).`);
          }
          absolute = 0;
        }
        parsedBrk.gapParsed.type = "tpAbs";
        parsedBrk.gapParsed.val = absolute;
      }
    }
    if (parsedBrk.vmin === parsedBrk.vmax) {
      parsedBrk.gapParsed.type = "tpAbs";
      parsedBrk.gapParsed.val = 0;
    }
    if (opt && opt.noNegative) {
      each(["vmin", "vmax"], (se) => {
        if (parsedBrk[se] < 0) {
          if (true) {
            error(`Axis break.${se} must not be negative.`);
          }
          parsedBrk[se] = 0;
        }
      });
    }
    if (parsedBrk.vmin > parsedBrk.vmax) {
      const tmp = parsedBrk.vmax;
      parsedBrk.vmax = parsedBrk.vmin;
      parsedBrk.vmin = tmp;
    }
    parsedBreaks.push(parsedBrk);
  });
  parsedBreaks.sort((item1, item2) => item1.vmin - item2.vmin);
  let lastEnd = -Infinity;
  each(parsedBreaks, (brk, idx) => {
    if (lastEnd > brk.vmin) {
      if (true) {
        error("Axis breaks must not overlap.");
      }
      parsedBreaks[idx] = null;
    }
    lastEnd = brk.vmax;
  });
  return {
    breaks: parsedBreaks.filter((brk) => !!brk)
  };
}
function identifyAxisBreak(brk, identifier) {
  return serializeAxisBreakIdentifier(identifier) === serializeAxisBreakIdentifier(brk);
}
function serializeAxisBreakIdentifier(identifier) {
  return identifier.start + "_\0_" + identifier.end;
}
function retrieveAxisBreakPairs(itemList, getVisualAxisBreak, returnIdx) {
  const idxPairList = [];
  each(itemList, (el, idx) => {
    const vBreak = getVisualAxisBreak(el);
    if (vBreak && vBreak.type === "vmin") {
      idxPairList.push([idx]);
    }
  });
  each(itemList, (el, idx) => {
    const vBreak = getVisualAxisBreak(el);
    if (vBreak && vBreak.type === "vmax") {
      const idxPair = find(idxPairList, (pr) => identifyAxisBreak(getVisualAxisBreak(itemList[pr[0]]).parsedBreak.breakOption, vBreak.parsedBreak.breakOption));
      idxPair && idxPair.push(idx);
    }
  });
  const result = [];
  each(idxPairList, (idxPair) => {
    if (idxPair.length === 2) {
      result.push(returnIdx ? idxPair : [itemList[idxPair[0]], itemList[idxPair[1]]]);
    }
  });
  return result;
}
function getTicksLogTransformBreak(tick, logBase, logOriginalBreaks, fixRoundingError2) {
  let vBreak;
  let brkRoundingCriterion;
  if (tick.break) {
    const brk = tick.break.parsedBreak;
    const originalBreak = find(logOriginalBreaks, (brk2) => identifyAxisBreak(brk2.breakOption, tick.break.parsedBreak.breakOption));
    const vmin = fixRoundingError2(Math.pow(logBase, brk.vmin), originalBreak.vmin);
    const vmax = fixRoundingError2(Math.pow(logBase, brk.vmax), originalBreak.vmax);
    const gapParsed = {
      type: brk.gapParsed.type,
      val: brk.gapParsed.type === "tpAbs" ? round(Math.pow(logBase, brk.vmin + brk.gapParsed.val)) - vmin : brk.gapParsed.val
    };
    vBreak = {
      type: tick.break.type,
      parsedBreak: {
        breakOption: brk.breakOption,
        vmin,
        vmax,
        gapParsed,
        gapReal: brk.gapReal
      }
    };
    brkRoundingCriterion = originalBreak[tick.break.type];
  }
  return {
    brkRoundingCriterion,
    vBreak
  };
}
function logarithmicParseBreaksFromOption(breakOptionList, logBase, parse2) {
  const opt = {noNegative: true};
  const parsedOriginal = parseAxisBreakOption(breakOptionList, parse2, opt);
  const parsedLogged = parseAxisBreakOption(breakOptionList, parse2, opt);
  const loggedBase = Math.log(logBase);
  parsedLogged.breaks = map(parsedLogged.breaks, (brk) => {
    const vmin = Math.log(brk.vmin) / loggedBase;
    const vmax = Math.log(brk.vmax) / loggedBase;
    const gapParsed = {
      type: brk.gapParsed.type,
      val: brk.gapParsed.type === "tpAbs" ? Math.log(brk.vmin + brk.gapParsed.val) / loggedBase - vmin : brk.gapParsed.val
    };
    return {
      vmin,
      vmax,
      gapParsed,
      gapReal: brk.gapReal,
      breakOption: brk.breakOption
    };
  });
  return {parsedOriginal, parsedLogged};
}
var BREAK_MIN_MAX_TO_PARAM = {vmin: "start", vmax: "end"};
function makeAxisLabelFormatterParamBreak(extraParam, vBreak) {
  if (vBreak) {
    extraParam = extraParam || {};
    extraParam.break = {
      type: BREAK_MIN_MAX_TO_PARAM[vBreak.type],
      start: vBreak.parsedBreak.vmin,
      end: vBreak.parsedBreak.vmax
    };
  }
  return extraParam;
}
function installScaleBreakHelper() {
  registerScaleBreakHelperImpl({
    createScaleBreakContext,
    pruneTicksByBreak,
    addBreaksToTicks,
    parseAxisBreakOption,
    identifyAxisBreak,
    serializeAxisBreakIdentifier,
    retrieveAxisBreakPairs,
    getTicksLogTransformBreak,
    logarithmicParseBreaksFromOption,
    makeAxisLabelFormatterParamBreak
  });
}

// src/component/axis/axisBreakHelperImpl.ts
var viewCache = makeInner();
function ensureVisualInCache(visualList, targetBreak) {
  let visual = find(visualList, (item) => getScaleBreakHelper().identifyAxisBreak(item.parsedBreak.breakOption, targetBreak.breakOption));
  if (!visual) {
    visualList.push(visual = {
      zigzagRandomList: [],
      parsedBreak: targetBreak,
      shouldRemove: false
    });
  }
  return visual;
}
function resetCacheVisualRemoveFlag(visualList) {
  each(visualList, (item) => item.shouldRemove = true);
}
function removeUnusedCacheVisual(visualList) {
  for (let i = visualList.length - 1; i >= 0; i--) {
    if (visualList[i].shouldRemove) {
      visualList.splice(i, 1);
    }
  }
}
function rectCoordBuildBreakAxis(axisGroup, axisView, axisModel, coordSysRect, api2) {
  const axis = axisModel.axis;
  if (axis.scale.isBlank() || !getScaleBreakHelper()) {
    return;
  }
  const breakPairs = getScaleBreakHelper().retrieveAxisBreakPairs(axis.scale.getTicks({breakTicks: "only_break"}), (tick) => tick.break, false);
  if (!breakPairs.length) {
    return;
  }
  const breakAreaModel = axisModel.getModel("breakArea");
  const zigzagAmplitude = breakAreaModel.get("zigzagAmplitude");
  let zigzagMinSpan = breakAreaModel.get("zigzagMinSpan");
  let zigzagMaxSpan = breakAreaModel.get("zigzagMaxSpan");
  zigzagMinSpan = Math.max(2, zigzagMinSpan || 0);
  zigzagMaxSpan = Math.max(zigzagMinSpan, zigzagMaxSpan || 0);
  const expandOnClick = breakAreaModel.get("expandOnClick");
  const zigzagZ = breakAreaModel.get("zigzagZ");
  const itemStyleModel = breakAreaModel.getModel("itemStyle");
  const itemStyle = itemStyleModel.getItemStyle();
  const borderColor = itemStyle.stroke;
  const borderWidth = itemStyle.lineWidth;
  const borderType = itemStyle.lineDash;
  const color4 = itemStyle.fill;
  const group = new Group_default({
    ignoreModelZ: true
  });
  const isAxisHorizontal = axis.isHorizontal();
  const cachedVisualList = viewCache(axisView).visualList || (viewCache(axisView).visualList = []);
  resetCacheVisualRemoveFlag(cachedVisualList);
  for (let i = 0; i < breakPairs.length; i++) {
    const parsedBreak = breakPairs[i][0].break.parsedBreak;
    const coords = [];
    coords[0] = axis.toGlobalCoord(axis.dataToCoord(parsedBreak.vmin, true));
    coords[1] = axis.toGlobalCoord(axis.dataToCoord(parsedBreak.vmax, true));
    if (coords[1] < coords[0]) {
      coords.reverse();
    }
    const cachedVisual = ensureVisualInCache(cachedVisualList, parsedBreak);
    cachedVisual.shouldRemove = false;
    const breakGroup = new Group_default();
    addZigzagShapes(cachedVisual.zigzagRandomList, breakGroup, coords[0], coords[1], isAxisHorizontal, parsedBreak);
    if (expandOnClick) {
      breakGroup.on("click", () => {
        const payload = {
          type: AXIS_BREAK_EXPAND_ACTION_TYPE,
          breaks: [{
            start: parsedBreak.breakOption.start,
            end: parsedBreak.breakOption.end
          }]
        };
        payload[`${axis.dim}AxisIndex`] = axisModel.componentIndex;
        api2.dispatchAction(payload);
      });
    }
    breakGroup.silent = !expandOnClick;
    group.add(breakGroup);
  }
  axisGroup.add(group);
  removeUnusedCacheVisual(cachedVisualList);
  function addZigzagShapes(zigzagRandomList, breakGroup, startCoord, endCoord, isAxisHorizontal2, trimmedBreak) {
    const polylineStyle = {
      stroke: borderColor,
      lineWidth: borderWidth,
      lineDash: borderType,
      fill: "none"
    };
    const dimBrk = isAxisHorizontal2 ? 0 : 1;
    const dimZigzag = 1 - dimBrk;
    const zigzagCoordMax = coordSysRect[XY2[dimZigzag]] + coordSysRect[WH2[dimZigzag]];
    function subPixelOpt(brkCoord) {
      const pBrk = [];
      const dummyP = [];
      pBrk[dimBrk] = dummyP[dimBrk] = brkCoord;
      pBrk[dimZigzag] = coordSysRect[XY2[dimZigzag]];
      dummyP[dimZigzag] = zigzagCoordMax;
      const dummyShape = {x1: pBrk[0], y1: pBrk[1], x2: dummyP[0], y2: dummyP[1]};
      subPixelOptimizeLine(dummyShape, dummyShape, {lineWidth: 1});
      pBrk[0] = dummyShape.x1;
      pBrk[1] = dummyShape.y1;
      return pBrk[dimBrk];
    }
    startCoord = subPixelOpt(startCoord);
    endCoord = subPixelOpt(endCoord);
    const pointsA = [];
    const pointsB = [];
    let isSwap = true;
    let current = coordSysRect[XY2[dimZigzag]];
    for (let idx = 0; ; idx++) {
      const isFirstPoint = current === coordSysRect[XY2[dimZigzag]];
      const isLastPoint = current >= zigzagCoordMax;
      if (isLastPoint) {
        current = zigzagCoordMax;
      }
      const pA = [];
      const pB = [];
      pA[dimBrk] = startCoord;
      pB[dimBrk] = endCoord;
      if (!isFirstPoint && !isLastPoint) {
        pA[dimBrk] += isSwap ? -zigzagAmplitude : zigzagAmplitude;
        pB[dimBrk] -= !isSwap ? -zigzagAmplitude : zigzagAmplitude;
      }
      pA[dimZigzag] = current;
      pB[dimZigzag] = current;
      pointsA.push(pA);
      pointsB.push(pB);
      let randomVal;
      if (idx < zigzagRandomList.length) {
        randomVal = zigzagRandomList[idx];
      } else {
        randomVal = Math.random();
        zigzagRandomList.push(randomVal);
      }
      current += randomVal * (zigzagMaxSpan - zigzagMinSpan) + zigzagMinSpan;
      isSwap = !isSwap;
      if (isLastPoint) {
        break;
      }
    }
    const anidSuffix = getScaleBreakHelper().serializeAxisBreakIdentifier(trimmedBreak.breakOption);
    breakGroup.add(new Polyline_default({
      anid: `break_a_${anidSuffix}`,
      shape: {
        points: pointsA
      },
      style: polylineStyle,
      z: zigzagZ
    }));
    if (trimmedBreak.gapReal !== 0) {
      breakGroup.add(new Polyline_default({
        anid: `break_b_${anidSuffix}`,
        shape: {
          points: pointsB
        },
        style: polylineStyle,
        z: zigzagZ
      }));
      const pointsB2 = pointsB.slice();
      pointsB2.reverse();
      const polygonPoints = pointsA.concat(pointsB2);
      breakGroup.add(new Polygon_default({
        anid: `break_c_${anidSuffix}`,
        shape: {
          points: polygonPoints
        },
        style: {
          fill: color4,
          opacity: itemStyle.opacity
        },
        z: zigzagZ
      }));
    }
  }
}
function buildAxisBreakLine(axisModel, group, transformGroup, pathBaseProp) {
  const axis = axisModel.axis;
  const transform2 = transformGroup.transform;
  assert(pathBaseProp.style);
  let extent = axis.getExtent();
  if (axis.inverse) {
    extent = extent.slice();
    extent.reverse();
  }
  const breakPairs = getScaleBreakHelper().retrieveAxisBreakPairs(axis.scale.getTicks({breakTicks: "only_break"}), (tick) => tick.break, false);
  const brkLayoutList = map(breakPairs, (breakPair) => {
    const parsedBreak = breakPair[0].break.parsedBreak;
    const coordPair = [
      axis.dataToCoord(parsedBreak.vmin, true),
      axis.dataToCoord(parsedBreak.vmax, true)
    ];
    coordPair[0] > coordPair[1] && coordPair.reverse();
    return {
      coordPair,
      brkId: getScaleBreakHelper().serializeAxisBreakIdentifier(parsedBreak.breakOption)
    };
  });
  brkLayoutList.sort((layout1, layout22) => layout1.coordPair[0] - layout22.coordPair[0]);
  let ySegMin = extent[0];
  let lastLayout = null;
  for (let idx = 0; idx < brkLayoutList.length; idx++) {
    const layout14 = brkLayoutList[idx];
    const brkTirmmedMin = Math.max(layout14.coordPair[0], extent[0]);
    const brkTirmmedMax = Math.min(layout14.coordPair[1], extent[1]);
    if (ySegMin <= brkTirmmedMin) {
      addSeg(ySegMin, brkTirmmedMin, lastLayout, layout14);
    }
    ySegMin = brkTirmmedMax;
    lastLayout = layout14;
  }
  if (ySegMin <= extent[1]) {
    addSeg(ySegMin, extent[1], lastLayout, null);
  }
  function addSeg(min3, max3, layout1, layout22) {
    function trans(p1, p2) {
      if (transform2) {
        applyTransform(p1, p1, transform2);
        applyTransform(p2, p2, transform2);
      }
    }
    function subPixelOptimizePP(p1, p2) {
      const shape = {x1: p1[0], y1: p1[1], x2: p2[0], y2: p2[1]};
      subPixelOptimizeLine(shape, shape, pathBaseProp.style);
      p1[0] = shape.x1;
      p1[1] = shape.y1;
      p2[0] = shape.x2;
      p2[1] = shape.y2;
    }
    const lineP1 = [min3, 0];
    const lineP2 = [max3, 0];
    const dummyTickEnd1 = [min3, 5];
    const dummyTickEnd2 = [max3, 5];
    trans(lineP1, dummyTickEnd1);
    subPixelOptimizePP(lineP1, dummyTickEnd1);
    trans(lineP2, dummyTickEnd2);
    subPixelOptimizePP(lineP2, dummyTickEnd2);
    subPixelOptimizePP(lineP1, lineP2);
    const seg = new Line_default(extend({shape: {
      x1: lineP1[0],
      y1: lineP1[1],
      x2: lineP2[0],
      y2: lineP2[1]
    }}, pathBaseProp));
    group.add(seg);
    seg.anid = `breakLine_${layout1 ? layout1.brkId : "\0"}_\0_${layout22 ? layout22.brkId : "\0"}`;
  }
}
function adjustBreakLabelPair(axisInverse, axisRotation, layoutPair) {
  if (find(layoutPair, (item) => !item)) {
    return;
  }
  const mtv = new Point_default();
  if (!labelIntersect(layoutPair[0], layoutPair[1], mtv, {
    direction: -(axisInverse ? axisRotation + Math.PI : axisRotation),
    touchThreshold: 0,
    bidirectional: false
  })) {
    return;
  }
  const axisStTrans = create2();
  rotate(axisStTrans, axisStTrans, -axisRotation);
  const labelPairStTrans = map(layoutPair, (layout14) => layout14.transform ? mul2(create2(), axisStTrans, layout14.transform) : axisStTrans);
  function isParallelToAxis(whIdx) {
    const localRect = layoutPair[0].localRect;
    const labelVec0 = new Point_default(localRect[WH2[whIdx]] * labelPairStTrans[0][0], localRect[WH2[whIdx]] * labelPairStTrans[0][1]);
    return Math.abs(labelVec0.y) < 1e-5;
  }
  let k = 0.5;
  if (isParallelToAxis(0) || isParallelToAxis(1)) {
    const rectSt = map(layoutPair, (layout14, idx) => {
      const rect = layout14.localRect.clone();
      rect.applyTransform(labelPairStTrans[idx]);
      return rect;
    });
    const brkCenterSt = new Point_default();
    brkCenterSt.copy(layoutPair[0].label).add(layoutPair[1].label).scale(0.5);
    brkCenterSt.transform(axisStTrans);
    const mtvSt = mtv.clone().transform(axisStTrans);
    const insidePtSum = rectSt[0].x + rectSt[1].x + (mtvSt.x >= 0 ? rectSt[0].width : rectSt[1].width);
    const qval = (insidePtSum + mtvSt.x) / 2 - brkCenterSt.x;
    const uvalMin = Math.min(qval, qval - mtvSt.x);
    const uvalMax = Math.max(qval, qval - mtvSt.x);
    const uval = uvalMax < 0 ? uvalMax : uvalMin > 0 ? uvalMin : 0;
    k = (qval - uval) / mtvSt.x;
  }
  Point_default.scaleAndAdd(layoutPair[0].label, layoutPair[0].label, mtv, -k);
  Point_default.scaleAndAdd(layoutPair[1].label, layoutPair[1].label, mtv, 1 - k);
}
function updateModelAxisBreak(model, payload) {
  const result = {breaks: []};
  each(payload.breaks, (inputBrk) => {
    if (!inputBrk) {
      return;
    }
    const breakOption = find(model.get("breaks", true), (brkOption) => getScaleBreakHelper().identifyAxisBreak(brkOption, inputBrk));
    if (!breakOption) {
      if (true) {
        warn(`Can not find axis break by start: ${inputBrk.start}, end: ${inputBrk.end}`);
      }
      return;
    }
    const actionType = payload.type;
    const old = {
      isExpanded: !!breakOption.isExpanded
    };
    breakOption.isExpanded = actionType === AXIS_BREAK_EXPAND_ACTION_TYPE ? true : actionType === AXIS_BREAK_COLLAPSE_ACTION_TYPE ? false : actionType === AXIS_BREAK_TOGGLE_ACTION_TYPE ? !breakOption.isExpanded : breakOption.isExpanded;
    result.breaks.push({
      start: breakOption.start,
      end: breakOption.end,
      isExpanded: !!breakOption.isExpanded,
      old
    });
  });
  return result;
}
function installAxisBreakHelper() {
  registerAxisBreakHelperImpl({
    adjustBreakLabelPair,
    buildAxisBreakLine,
    rectCoordBuildBreakAxis,
    updateModelAxisBreak
  });
}

// src/component/axis/installBreak.ts
function installAxisBreak(registers) {
  registerAction2(registers);
  installScaleBreakHelper();
  installAxisBreakHelper();
}

// src/coord/cartesian/legacyContainLabel.ts
function installLegacyGridContainLabel() {
  registerLegacyGridContainLabelImpl(legacyLayOutGridByContained);
}
function legacyLayOutGridByContained(axesList, gridRect) {
  each(axesList, function(axis) {
    if (!axis.model.get(["axisLabel", "inside"])) {
      const labelUnionRect = estimateLabelUnionRect(axis);
      if (labelUnionRect) {
        const dim = axis.isHorizontal() ? "height" : "width";
        const margin = axis.model.get(["axisLabel", "margin"]);
        gridRect[dim] -= labelUnionRect[dim] + margin;
        if (axis.position === "top") {
          gridRect.y += labelUnionRect.height + margin;
        } else if (axis.position === "left") {
          gridRect.x += labelUnionRect.width + margin;
        }
      }
    }
  });
}
function estimateLabelUnionRect(axis) {
  const axisModel = axis.model;
  const scale4 = axis.scale;
  if (!axisModel.get(["axisLabel", "show"]) || scale4.isBlank()) {
    return;
  }
  let realNumberScaleTicks;
  let tickCount;
  const categoryScaleExtent = scale4.getExtent();
  if (scale4 instanceof Ordinal_default) {
    tickCount = scale4.count();
  } else {
    realNumberScaleTicks = scale4.getTicks();
    tickCount = realNumberScaleTicks.length;
  }
  const axisLabelModel = axis.getLabelModel();
  const labelFormatter = makeLabelFormatter(axis);
  let rect;
  let step = 1;
  if (tickCount > 40) {
    step = Math.ceil(tickCount / 40);
  }
  for (let i = 0; i < tickCount; i += step) {
    const tick = realNumberScaleTicks ? realNumberScaleTicks[i] : {
      value: categoryScaleExtent[0] + i
    };
    const label = labelFormatter(tick, i);
    const unrotatedSingleRect = axisLabelModel.getTextRect(label);
    const singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get("rotate") || 0);
    rect ? rect.union(singleRect) : rect = singleRect;
  }
  return rect;
  function rotateTextRect(textRect, rotate2) {
    const rotateRadians = rotate2 * Math.PI / 180;
    const beforeWidth = textRect.width;
    const beforeHeight = textRect.height;
    const afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));
    const afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));
    const rotatedRect = new BoundingRect_default(textRect.x, textRect.y, afterWidth, afterHeight);
    return rotatedRect;
  }
}

// src/echarts.all.ts
use([install2]);
use([install]);
use([
  install3,
  install4,
  install5,
  install7,
  install9,
  install11,
  install12,
  install13,
  install14,
  install15,
  install16,
  install17,
  install19,
  install20,
  install21,
  install22,
  install23,
  install24,
  install25,
  install26,
  install27,
  install28,
  install29
]);
use(install31);
use(install32);
use(install10);
use(install33);
use(install18);
use(install34);
use(install35);
use(install36);
use(install38);
use(install39);
use(install30);
use(install40);
use(install41);
use(install42);
use(install43);
use(install44);
use(install45);
use(install48);
use(install51);
use(install49);
use(install50);
use(install54);
use(install52);
use(install53);
use(install55);
use(install56);
use(install57);
use(install58);
use(installUniversalTransition);
use(installLabelLayout);
use(installAxisBreak);
use(installLegacyGridContainLabel);
use(installScatterJitter);

}));
//# sourceMappingURL=echarts.js.map
