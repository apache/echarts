(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(['exports'], factory);
    } else if (typeof exports === 'object' && typeof exports.nodeName !== 'string') {
        // CommonJS
        factory(exports);
    } else {
        // Browser globals
        factory((root.echarts = {}));
    }
}(typeof self !== 'undefined' ? self : this, function (exports, b) {

var __defProp = Object.defineProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};

// src/echarts.all.ts
__export(exports, {
  Axis: () => Axis_default,
  ChartView: () => Chart_default,
  ComponentModel: () => Component_default,
  ComponentView: () => Component_default2,
  List: () => SeriesData_default,
  Model: () => Model_default,
  PRIORITY: () => PRIORITY,
  SeriesModel: () => Series_default,
  color: () => color_exports,
  connect: () => connect,
  dataTool: () => dataTool,
  dependencies: () => dependencies,
  disConnect: () => disConnect,
  disconnect: () => disconnect,
  dispose: () => dispose2,
  env: () => env_default,
  extendChartView: () => extendChartView,
  extendComponentModel: () => extendComponentModel,
  extendComponentView: () => extendComponentView,
  extendSeriesModel: () => extendSeriesModel,
  format: () => format_exports,
  getCoordinateSystemDimensions: () => getCoordinateSystemDimensions,
  getInstanceByDom: () => getInstanceByDom,
  getInstanceById: () => getInstanceById,
  getMap: () => getMap,
  graphic: () => graphic_exports2,
  helper: () => helper_exports,
  init: () => init2,
  innerDrawElementOnCanvas: () => brushSingle,
  matrix: () => matrix_exports,
  number: () => number_exports,
  parseGeoJSON: () => parseGeoJSON,
  parseGeoJson: () => parseGeoJSON,
  registerAction: () => registerAction,
  registerCoordinateSystem: () => registerCoordinateSystem,
  registerLayout: () => registerLayout,
  registerLoading: () => registerLoading,
  registerLocale: () => registerLocale,
  registerMap: () => registerMap,
  registerPostInit: () => registerPostInit,
  registerPostUpdate: () => registerPostUpdate,
  registerPreprocessor: () => registerPreprocessor,
  registerProcessor: () => registerProcessor,
  registerTheme: () => registerTheme,
  registerTransform: () => registerTransform,
  registerUpdateLifecycle: () => registerUpdateLifecycle,
  registerVisual: () => registerVisual,
  setCanvasCreator: () => setCanvasCreator,
  setPlatformAPI: () => setPlatformAPI,
  throttle: () => throttle,
  time: () => time_exports,
  use: () => use,
  util: () => util_exports2,
  vector: () => vector_exports,
  version: () => version2,
  zrUtil: () => util_exports,
  zrender: () => zrender_exports
});

// node_modules/zrender/src/zrender.ts
var zrender_exports = {};
__export(zrender_exports, {
  dispose: () => dispose,
  disposeAll: () => disposeAll,
  getElementSSRData: () => getElementSSRData,
  getInstance: () => getInstance,
  init: () => init,
  registerPainter: () => registerPainter,
  registerSSRDataGetter: () => registerSSRDataGetter,
  version: () => version
});

// node_modules/zrender/src/core/env.ts
var Browser = class {
  constructor() {
    this.firefox = false;
    this.ie = false;
    this.edge = false;
    this.newEdge = false;
    this.weChat = false;
  }
};
var Env = class {
  constructor() {
    this.browser = new Browser();
    this.node = false;
    this.wxa = false;
    this.worker = false;
    this.svgSupported = false;
    this.touchEventsSupported = false;
    this.pointerEventsSupported = false;
    this.domSupported = false;
    this.transformSupported = false;
    this.transform3dSupported = false;
    this.hasGlobalWindow = typeof window !== "undefined";
  }
};
var env = new Env();
if (typeof wx === "object" && typeof wx.getSystemInfoSync === "function") {
  env.wxa = true;
  env.touchEventsSupported = true;
} else if (typeof document === "undefined" && typeof self !== "undefined") {
  env.worker = true;
} else if (typeof navigator === "undefined" || navigator.userAgent.indexOf("Node.js") === 0) {
  env.node = true;
  env.svgSupported = true;
} else {
  detect(navigator.userAgent, env);
}
function detect(ua, env2) {
  const browser = env2.browser;
  const firefox = ua.match(/Firefox\/([\d.]+)/);
  const ie = ua.match(/MSIE\s([\d.]+)/) || ua.match(/Trident\/.+?rv:(([\d.]+))/);
  const edge = ua.match(/Edge?\/([\d.]+)/);
  const weChat = /micromessenger/i.test(ua);
  if (firefox) {
    browser.firefox = true;
    browser.version = firefox[1];
  }
  if (ie) {
    browser.ie = true;
    browser.version = ie[1];
  }
  if (edge) {
    browser.edge = true;
    browser.version = edge[1];
    browser.newEdge = +edge[1].split(".")[0] > 18;
  }
  if (weChat) {
    browser.weChat = true;
  }
  env2.svgSupported = typeof SVGRect !== "undefined";
  env2.touchEventsSupported = "ontouchstart" in window && !browser.ie && !browser.edge;
  env2.pointerEventsSupported = "onpointerdown" in window && (browser.edge || browser.ie && +browser.version >= 11);
  env2.domSupported = typeof document !== "undefined";
  const style = document.documentElement.style;
  env2.transform3dSupported = (browser.ie && "transition" in style || browser.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in style) && !("OTransition" in style);
  env2.transformSupported = env2.transform3dSupported || browser.ie && +browser.version >= 9;
}
var env_default = env;

// node_modules/zrender/src/core/util.ts
var util_exports = {};
__export(util_exports, {
  HashMap: () => HashMap,
  RADIAN_TO_DEGREE: () => RADIAN_TO_DEGREE,
  assert: () => assert,
  bind: () => bind,
  clone: () => clone,
  concatArray: () => concatArray,
  createCanvas: () => createCanvas,
  createHashMap: () => createHashMap,
  createObject: () => createObject,
  curry: () => curry,
  defaults: () => defaults,
  disableUserSelect: () => disableUserSelect,
  each: () => each,
  eqNaN: () => eqNaN,
  extend: () => extend,
  filter: () => filter,
  find: () => find,
  guid: () => guid,
  hasOwn: () => hasOwn,
  indexOf: () => indexOf,
  inherits: () => inherits,
  isArray: () => isArray,
  isArrayLike: () => isArrayLike,
  isBuiltInObject: () => isBuiltInObject,
  isDom: () => isDom,
  isFunction: () => isFunction,
  isGradientObject: () => isGradientObject,
  isImagePatternObject: () => isImagePatternObject,
  isNumber: () => isNumber,
  isObject: () => isObject,
  isPrimitive: () => isPrimitive,
  isRegExp: () => isRegExp,
  isString: () => isString,
  isStringSafe: () => isStringSafe,
  isTypedArray: () => isTypedArray,
  keys: () => keys,
  logError: () => logError,
  map: () => map,
  merge: () => merge,
  mergeAll: () => mergeAll,
  mixin: () => mixin,
  noop: () => noop,
  normalizeCssArray: () => normalizeCssArray,
  reduce: () => reduce,
  retrieve: () => retrieve,
  retrieve2: () => retrieve2,
  retrieve3: () => retrieve3,
  setAsPrimitive: () => setAsPrimitive,
  slice: () => slice,
  trim: () => trim
});

// node_modules/zrender/src/core/platform.ts
var DEFAULT_FONT_SIZE = 12;
var DEFAULT_FONT_FAMILY = "sans-serif";
var DEFAULT_FONT = `${DEFAULT_FONT_SIZE}px ${DEFAULT_FONT_FAMILY}`;
var OFFSET = 20;
var SCALE = 100;
var defaultWidthMapStr = `007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N`;
function getTextWidthMap(mapStr) {
  const map3 = {};
  if (typeof JSON === "undefined") {
    return map3;
  }
  for (let i = 0; i < mapStr.length; i++) {
    const char = String.fromCharCode(i + 32);
    const size = (mapStr.charCodeAt(i) - OFFSET) / SCALE;
    map3[char] = size;
  }
  return map3;
}
var DEFAULT_TEXT_WIDTH_MAP = getTextWidthMap(defaultWidthMapStr);
var platformApi = {
  createCanvas() {
    return typeof document !== "undefined" && document.createElement("canvas");
  },
  measureText: function() {
    let _ctx;
    let _cachedFont;
    return (text, font) => {
      if (!_ctx) {
        const canvas = platformApi.createCanvas();
        _ctx = canvas && canvas.getContext("2d");
      }
      if (_ctx) {
        if (_cachedFont !== font) {
          _cachedFont = _ctx.font = font || DEFAULT_FONT;
        }
        return _ctx.measureText(text);
      } else {
        text = text || "";
        font = font || DEFAULT_FONT;
        const res = /(\d+)px/.exec(font);
        const fontSize = res && +res[1] || DEFAULT_FONT_SIZE;
        let width = 0;
        if (font.indexOf("mono") >= 0) {
          width = fontSize * text.length;
        } else {
          for (let i = 0; i < text.length; i++) {
            const preCalcWidth = DEFAULT_TEXT_WIDTH_MAP[text[i]];
            width += preCalcWidth == null ? fontSize : preCalcWidth * fontSize;
          }
        }
        return {width};
      }
    };
  }(),
  loadImage(src, onload, onerror) {
    const image = new Image();
    image.onload = onload;
    image.onerror = onerror;
    image.src = src;
    return image;
  }
};
function setPlatformAPI(newPlatformApis) {
  for (let key in platformApi) {
    if (newPlatformApis[key]) {
      platformApi[key] = newPlatformApis[key];
    }
  }
}

// node_modules/zrender/src/core/util.ts
var BUILTIN_OBJECT = reduce([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], (obj, val) => {
  obj["[object " + val + "]"] = true;
  return obj;
}, {});
var TYPED_ARRAY = reduce([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], (obj, val) => {
  obj["[object " + val + "Array]"] = true;
  return obj;
}, {});
var objToString = Object.prototype.toString;
var arrayProto = Array.prototype;
var nativeForEach = arrayProto.forEach;
var nativeFilter = arrayProto.filter;
var nativeSlice = arrayProto.slice;
var nativeMap = arrayProto.map;
var ctorFunction = function() {
}.constructor;
var protoFunction = ctorFunction ? ctorFunction.prototype : null;
var protoKey = "__proto__";
var idStart = 2311;
function guid() {
  return idStart++;
}
function logError(...args) {
  if (typeof console !== "undefined") {
    console.error.apply(console, args);
  }
}
function clone(source) {
  if (source == null || typeof source !== "object") {
    return source;
  }
  let result = source;
  const typeStr = objToString.call(source);
  if (typeStr === "[object Array]") {
    if (!isPrimitive(source)) {
      result = [];
      for (let i = 0, len2 = source.length; i < len2; i++) {
        result[i] = clone(source[i]);
      }
    }
  } else if (TYPED_ARRAY[typeStr]) {
    if (!isPrimitive(source)) {
      const Ctor = source.constructor;
      if (Ctor.from) {
        result = Ctor.from(source);
      } else {
        result = new Ctor(source.length);
        for (let i = 0, len2 = source.length; i < len2; i++) {
          result[i] = source[i];
        }
      }
    }
  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
    result = {};
    for (let key in source) {
      if (source.hasOwnProperty(key) && key !== protoKey) {
        result[key] = clone(source[key]);
      }
    }
  }
  return result;
}
function merge(target, source, overwrite) {
  if (!isObject(source) || !isObject(target)) {
    return overwrite ? clone(source) : target;
  }
  for (let key in source) {
    if (source.hasOwnProperty(key) && key !== protoKey) {
      const targetProp = target[key];
      const sourceProp = source[key];
      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {
        merge(targetProp, sourceProp, overwrite);
      } else if (overwrite || !(key in target)) {
        target[key] = clone(source[key]);
      }
    }
  }
  return target;
}
function mergeAll(targetAndSources, overwrite) {
  let result = targetAndSources[0];
  for (let i = 1, len2 = targetAndSources.length; i < len2; i++) {
    result = merge(result, targetAndSources[i], overwrite);
  }
  return result;
}
function extend(target, source) {
  if (Object.assign) {
    Object.assign(target, source);
  } else {
    for (let key in source) {
      if (source.hasOwnProperty(key) && key !== protoKey) {
        target[key] = source[key];
      }
    }
  }
  return target;
}
function defaults(target, source, overlay) {
  const keysArr = keys(source);
  for (let i = 0; i < keysArr.length; i++) {
    let key = keysArr[i];
    if (overlay ? source[key] != null : target[key] == null) {
      target[key] = source[key];
    }
  }
  return target;
}
var createCanvas = platformApi.createCanvas;
function indexOf(array, value) {
  if (array) {
    if (array.indexOf) {
      return array.indexOf(value);
    }
    for (let i = 0, len2 = array.length; i < len2; i++) {
      if (array[i] === value) {
        return i;
      }
    }
  }
  return -1;
}
function inherits(clazz, baseClazz) {
  const clazzPrototype = clazz.prototype;
  function F() {
  }
  F.prototype = baseClazz.prototype;
  clazz.prototype = new F();
  for (let prop in clazzPrototype) {
    if (clazzPrototype.hasOwnProperty(prop)) {
      clazz.prototype[prop] = clazzPrototype[prop];
    }
  }
  clazz.prototype.constructor = clazz;
  clazz.superClass = baseClazz;
}
function mixin(target, source, override) {
  target = "prototype" in target ? target.prototype : target;
  source = "prototype" in source ? source.prototype : source;
  if (Object.getOwnPropertyNames) {
    const keyList = Object.getOwnPropertyNames(source);
    for (let i = 0; i < keyList.length; i++) {
      const key = keyList[i];
      if (key !== "constructor") {
        if (override ? source[key] != null : target[key] == null) {
          target[key] = source[key];
        }
      }
    }
  } else {
    defaults(target, source, override);
  }
}
function isArrayLike(data) {
  if (!data) {
    return false;
  }
  if (typeof data === "string") {
    return false;
  }
  return typeof data.length === "number";
}
function each(arr, cb, context) {
  if (!(arr && cb)) {
    return;
  }
  if (arr.forEach && arr.forEach === nativeForEach) {
    arr.forEach(cb, context);
  } else if (arr.length === +arr.length) {
    for (let i = 0, len2 = arr.length; i < len2; i++) {
      cb.call(context, arr[i], i, arr);
    }
  } else {
    for (let key in arr) {
      if (arr.hasOwnProperty(key)) {
        cb.call(context, arr[key], key, arr);
      }
    }
  }
}
function map(arr, cb, context) {
  if (!arr) {
    return [];
  }
  if (!cb) {
    return slice(arr);
  }
  if (arr.map && arr.map === nativeMap) {
    return arr.map(cb, context);
  } else {
    const result = [];
    for (let i = 0, len2 = arr.length; i < len2; i++) {
      result.push(cb.call(context, arr[i], i, arr));
    }
    return result;
  }
}
function reduce(arr, cb, memo, context) {
  if (!(arr && cb)) {
    return;
  }
  for (let i = 0, len2 = arr.length; i < len2; i++) {
    memo = cb.call(context, memo, arr[i], i, arr);
  }
  return memo;
}
function filter(arr, cb, context) {
  if (!arr) {
    return [];
  }
  if (!cb) {
    return slice(arr);
  }
  if (arr.filter && arr.filter === nativeFilter) {
    return arr.filter(cb, context);
  } else {
    const result = [];
    for (let i = 0, len2 = arr.length; i < len2; i++) {
      if (cb.call(context, arr[i], i, arr)) {
        result.push(arr[i]);
      }
    }
    return result;
  }
}
function find(arr, cb, context) {
  if (!(arr && cb)) {
    return;
  }
  for (let i = 0, len2 = arr.length; i < len2; i++) {
    if (cb.call(context, arr[i], i, arr)) {
      return arr[i];
    }
  }
}
function keys(obj) {
  if (!obj) {
    return [];
  }
  if (Object.keys) {
    return Object.keys(obj);
  }
  let keyList = [];
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      keyList.push(key);
    }
  }
  return keyList;
}
function bindPolyfill(func, context, ...args) {
  return function() {
    return func.apply(context, args.concat(nativeSlice.call(arguments)));
  };
}
var bind = protoFunction && isFunction(protoFunction.bind) ? protoFunction.call.bind(protoFunction.bind) : bindPolyfill;
function curry(func, ...args) {
  return function() {
    return func.apply(this, args.concat(nativeSlice.call(arguments)));
  };
}
function isArray(value) {
  if (Array.isArray) {
    return Array.isArray(value);
  }
  return objToString.call(value) === "[object Array]";
}
function isFunction(value) {
  return typeof value === "function";
}
function isString(value) {
  return typeof value === "string";
}
function isStringSafe(value) {
  return objToString.call(value) === "[object String]";
}
function isNumber(value) {
  return typeof value === "number";
}
function isObject(value) {
  const type = typeof value;
  return type === "function" || !!value && type === "object";
}
function isBuiltInObject(value) {
  return !!BUILTIN_OBJECT[objToString.call(value)];
}
function isTypedArray(value) {
  return !!TYPED_ARRAY[objToString.call(value)];
}
function isDom(value) {
  return typeof value === "object" && typeof value.nodeType === "number" && typeof value.ownerDocument === "object";
}
function isGradientObject(value) {
  return value.colorStops != null;
}
function isImagePatternObject(value) {
  return value.image != null;
}
function isRegExp(value) {
  return objToString.call(value) === "[object RegExp]";
}
function eqNaN(value) {
  return value !== value;
}
function retrieve(...args) {
  for (let i = 0, len2 = args.length; i < len2; i++) {
    if (args[i] != null) {
      return args[i];
    }
  }
}
function retrieve2(value0, value1) {
  return value0 != null ? value0 : value1;
}
function retrieve3(value0, value1, value2) {
  return value0 != null ? value0 : value1 != null ? value1 : value2;
}
function slice(arr, ...args) {
  return nativeSlice.apply(arr, args);
}
function normalizeCssArray(val) {
  if (typeof val === "number") {
    return [val, val, val, val];
  }
  const len2 = val.length;
  if (len2 === 2) {
    return [val[0], val[1], val[0], val[1]];
  } else if (len2 === 3) {
    return [val[0], val[1], val[2], val[1]];
  }
  return val;
}
function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
function trim(str) {
  if (str == null) {
    return null;
  } else if (typeof str.trim === "function") {
    return str.trim();
  } else {
    return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  }
}
var primitiveKey = "__ec_primitive__";
function setAsPrimitive(obj) {
  obj[primitiveKey] = true;
}
function isPrimitive(obj) {
  return obj[primitiveKey];
}
var MapPolyfill = class {
  constructor() {
    this.data = {};
  }
  delete(key) {
    const existed = this.has(key);
    if (existed) {
      delete this.data[key];
    }
    return existed;
  }
  has(key) {
    return this.data.hasOwnProperty(key);
  }
  get(key) {
    return this.data[key];
  }
  set(key, value) {
    this.data[key] = value;
    return this;
  }
  keys() {
    return keys(this.data);
  }
  forEach(callback) {
    const data = this.data;
    for (const key in data) {
      if (data.hasOwnProperty(key)) {
        callback(data[key], key);
      }
    }
  }
};
var isNativeMapSupported = typeof Map === "function";
function maybeNativeMap() {
  return isNativeMapSupported ? new Map() : new MapPolyfill();
}
var HashMap = class {
  constructor(obj) {
    const isArr = isArray(obj);
    this.data = maybeNativeMap();
    const thisMap = this;
    obj instanceof HashMap ? obj.each(visit) : obj && each(obj, visit);
    function visit(value, key) {
      isArr ? thisMap.set(value, key) : thisMap.set(key, value);
    }
  }
  hasKey(key) {
    return this.data.has(key);
  }
  get(key) {
    return this.data.get(key);
  }
  set(key, value) {
    this.data.set(key, value);
    return value;
  }
  each(cb, context) {
    this.data.forEach((value, key) => {
      cb.call(context, value, key);
    });
  }
  keys() {
    const keys2 = this.data.keys();
    return isNativeMapSupported ? Array.from(keys2) : keys2;
  }
  removeKey(key) {
    this.data.delete(key);
  }
};
function createHashMap(obj) {
  return new HashMap(obj);
}
function concatArray(a, b) {
  const newArray = new a.constructor(a.length + b.length);
  for (let i = 0; i < a.length; i++) {
    newArray[i] = a[i];
  }
  const offset = a.length;
  for (let i = 0; i < b.length; i++) {
    newArray[i + offset] = b[i];
  }
  return newArray;
}
function createObject(proto2, properties) {
  let obj;
  if (Object.create) {
    obj = Object.create(proto2);
  } else {
    const StyleCtor = function() {
    };
    StyleCtor.prototype = proto2;
    obj = new StyleCtor();
  }
  if (properties) {
    extend(obj, properties);
  }
  return obj;
}
function disableUserSelect(dom) {
  const domStyle = dom.style;
  domStyle.webkitUserSelect = "none";
  domStyle.userSelect = "none";
  domStyle.webkitTapHighlightColor = "rgba(0,0,0,0)";
  domStyle["-webkit-touch-callout"] = "none";
}
function hasOwn(own, prop) {
  return own.hasOwnProperty(prop);
}
function noop() {
}
var RADIAN_TO_DEGREE = 180 / Math.PI;

// node_modules/zrender/src/core/vector.ts
var vector_exports = {};
__export(vector_exports, {
  add: () => add,
  applyTransform: () => applyTransform,
  clone: () => clone2,
  copy: () => copy,
  create: () => create,
  dist: () => dist,
  distSquare: () => distSquare,
  distance: () => distance,
  distanceSquare: () => distanceSquare,
  div: () => div,
  dot: () => dot,
  len: () => len,
  lenSquare: () => lenSquare,
  length: () => length,
  lengthSquare: () => lengthSquare,
  lerp: () => lerp,
  max: () => max,
  min: () => min,
  mul: () => mul,
  negate: () => negate,
  normalize: () => normalize,
  scale: () => scale,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set,
  sub: () => sub
});
function create(x, y) {
  if (x == null) {
    x = 0;
  }
  if (y == null) {
    y = 0;
  }
  return [x, y];
}
function copy(out2, v) {
  out2[0] = v[0];
  out2[1] = v[1];
  return out2;
}
function clone2(v) {
  return [v[0], v[1]];
}
function set(out2, a, b) {
  out2[0] = a;
  out2[1] = b;
  return out2;
}
function add(out2, v12, v22) {
  out2[0] = v12[0] + v22[0];
  out2[1] = v12[1] + v22[1];
  return out2;
}
function scaleAndAdd(out2, v12, v22, a) {
  out2[0] = v12[0] + v22[0] * a;
  out2[1] = v12[1] + v22[1] * a;
  return out2;
}
function sub(out2, v12, v22) {
  out2[0] = v12[0] - v22[0];
  out2[1] = v12[1] - v22[1];
  return out2;
}
function len(v) {
  return Math.sqrt(lenSquare(v));
}
var length = len;
function lenSquare(v) {
  return v[0] * v[0] + v[1] * v[1];
}
var lengthSquare = lenSquare;
function mul(out2, v12, v22) {
  out2[0] = v12[0] * v22[0];
  out2[1] = v12[1] * v22[1];
  return out2;
}
function div(out2, v12, v22) {
  out2[0] = v12[0] / v22[0];
  out2[1] = v12[1] / v22[1];
  return out2;
}
function dot(v12, v22) {
  return v12[0] * v22[0] + v12[1] * v22[1];
}
function scale(out2, v, s) {
  out2[0] = v[0] * s;
  out2[1] = v[1] * s;
  return out2;
}
function normalize(out2, v) {
  const d = len(v);
  if (d === 0) {
    out2[0] = 0;
    out2[1] = 0;
  } else {
    out2[0] = v[0] / d;
    out2[1] = v[1] / d;
  }
  return out2;
}
function distance(v12, v22) {
  return Math.sqrt((v12[0] - v22[0]) * (v12[0] - v22[0]) + (v12[1] - v22[1]) * (v12[1] - v22[1]));
}
var dist = distance;
function distanceSquare(v12, v22) {
  return (v12[0] - v22[0]) * (v12[0] - v22[0]) + (v12[1] - v22[1]) * (v12[1] - v22[1]);
}
var distSquare = distanceSquare;
function negate(out2, v) {
  out2[0] = -v[0];
  out2[1] = -v[1];
  return out2;
}
function lerp(out2, v12, v22, t) {
  out2[0] = v12[0] + t * (v22[0] - v12[0]);
  out2[1] = v12[1] + t * (v22[1] - v12[1]);
  return out2;
}
function applyTransform(out2, v, m2) {
  const x = v[0];
  const y = v[1];
  out2[0] = m2[0] * x + m2[2] * y + m2[4];
  out2[1] = m2[1] * x + m2[3] * y + m2[5];
  return out2;
}
function min(out2, v12, v22) {
  out2[0] = Math.min(v12[0], v22[0]);
  out2[1] = Math.min(v12[1], v22[1]);
  return out2;
}
function max(out2, v12, v22) {
  out2[0] = Math.max(v12[0], v22[0]);
  out2[1] = Math.max(v12[1], v22[1]);
  return out2;
}

// node_modules/zrender/src/mixin/Draggable.ts
var Param = class {
  constructor(target, e2) {
    this.target = target;
    this.topTarget = e2 && e2.topTarget;
  }
};
var Draggable = class {
  constructor(handler) {
    this.handler = handler;
    handler.on("mousedown", this._dragStart, this);
    handler.on("mousemove", this._drag, this);
    handler.on("mouseup", this._dragEnd, this);
  }
  _dragStart(e2) {
    let draggingTarget = e2.target;
    while (draggingTarget && !draggingTarget.draggable) {
      draggingTarget = draggingTarget.parent || draggingTarget.__hostTarget;
    }
    if (draggingTarget) {
      this._draggingTarget = draggingTarget;
      draggingTarget.dragging = true;
      this._x = e2.offsetX;
      this._y = e2.offsetY;
      this.handler.dispatchToElement(new Param(draggingTarget, e2), "dragstart", e2.event);
    }
  }
  _drag(e2) {
    const draggingTarget = this._draggingTarget;
    if (draggingTarget) {
      const x = e2.offsetX;
      const y = e2.offsetY;
      const dx = x - this._x;
      const dy = y - this._y;
      this._x = x;
      this._y = y;
      draggingTarget.drift(dx, dy, e2);
      this.handler.dispatchToElement(new Param(draggingTarget, e2), "drag", e2.event);
      const dropTarget = this.handler.findHover(x, y, draggingTarget).target;
      const lastDropTarget = this._dropTarget;
      this._dropTarget = dropTarget;
      if (draggingTarget !== dropTarget) {
        if (lastDropTarget && dropTarget !== lastDropTarget) {
          this.handler.dispatchToElement(new Param(lastDropTarget, e2), "dragleave", e2.event);
        }
        if (dropTarget && dropTarget !== lastDropTarget) {
          this.handler.dispatchToElement(new Param(dropTarget, e2), "dragenter", e2.event);
        }
      }
    }
  }
  _dragEnd(e2) {
    const draggingTarget = this._draggingTarget;
    if (draggingTarget) {
      draggingTarget.dragging = false;
    }
    this.handler.dispatchToElement(new Param(draggingTarget, e2), "dragend", e2.event);
    if (this._dropTarget) {
      this.handler.dispatchToElement(new Param(this._dropTarget, e2), "drop", e2.event);
    }
    this._draggingTarget = null;
    this._dropTarget = null;
  }
};
var Draggable_default = Draggable;

// node_modules/zrender/src/core/Eventful.ts
var Eventful = class {
  constructor(eventProcessors) {
    if (eventProcessors) {
      this._$eventProcessor = eventProcessors;
    }
  }
  on(event, query, handler, context) {
    if (!this._$handlers) {
      this._$handlers = {};
    }
    const _h = this._$handlers;
    if (typeof query === "function") {
      context = handler;
      handler = query;
      query = null;
    }
    if (!handler || !event) {
      return this;
    }
    const eventProcessor = this._$eventProcessor;
    if (query != null && eventProcessor && eventProcessor.normalizeQuery) {
      query = eventProcessor.normalizeQuery(query);
    }
    if (!_h[event]) {
      _h[event] = [];
    }
    for (let i = 0; i < _h[event].length; i++) {
      if (_h[event][i].h === handler) {
        return this;
      }
    }
    const wrap = {
      h: handler,
      query,
      ctx: context || this,
      callAtLast: handler.zrEventfulCallAtLast
    };
    const lastIndex = _h[event].length - 1;
    const lastWrap = _h[event][lastIndex];
    lastWrap && lastWrap.callAtLast ? _h[event].splice(lastIndex, 0, wrap) : _h[event].push(wrap);
    return this;
  }
  isSilent(eventName) {
    const _h = this._$handlers;
    return !_h || !_h[eventName] || !_h[eventName].length;
  }
  off(eventType, handler) {
    const _h = this._$handlers;
    if (!_h) {
      return this;
    }
    if (!eventType) {
      this._$handlers = {};
      return this;
    }
    if (handler) {
      if (_h[eventType]) {
        const newList = [];
        for (let i = 0, l = _h[eventType].length; i < l; i++) {
          if (_h[eventType][i].h !== handler) {
            newList.push(_h[eventType][i]);
          }
        }
        _h[eventType] = newList;
      }
      if (_h[eventType] && _h[eventType].length === 0) {
        delete _h[eventType];
      }
    } else {
      delete _h[eventType];
    }
    return this;
  }
  trigger(eventType, ...args) {
    if (!this._$handlers) {
      return this;
    }
    const _h = this._$handlers[eventType];
    const eventProcessor = this._$eventProcessor;
    if (_h) {
      const argLen = args.length;
      const len2 = _h.length;
      for (let i = 0; i < len2; i++) {
        const hItem = _h[i];
        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(eventType, hItem.query)) {
          continue;
        }
        switch (argLen) {
          case 0:
            hItem.h.call(hItem.ctx);
            break;
          case 1:
            hItem.h.call(hItem.ctx, args[0]);
            break;
          case 2:
            hItem.h.call(hItem.ctx, args[0], args[1]);
            break;
          default:
            hItem.h.apply(hItem.ctx, args);
            break;
        }
      }
    }
    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(eventType);
    return this;
  }
  triggerWithContext(type, ...args) {
    if (!this._$handlers) {
      return this;
    }
    const _h = this._$handlers[type];
    const eventProcessor = this._$eventProcessor;
    if (_h) {
      const argLen = args.length;
      const ctx = args[argLen - 1];
      const len2 = _h.length;
      for (let i = 0; i < len2; i++) {
        const hItem = _h[i];
        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {
          continue;
        }
        switch (argLen) {
          case 0:
            hItem.h.call(ctx);
            break;
          case 1:
            hItem.h.call(ctx, args[0]);
            break;
          case 2:
            hItem.h.call(ctx, args[0], args[1]);
            break;
          default:
            hItem.h.apply(ctx, args.slice(1, argLen - 1));
            break;
        }
      }
    }
    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);
    return this;
  }
};
var Eventful_default = Eventful;

// node_modules/zrender/src/core/fourPointsTransform.ts
var LN2 = Math.log(2);
function determinant(rows, rank, rowStart, rowMask, colMask, detCache) {
  const cacheKey = rowMask + "-" + colMask;
  const fullRank = rows.length;
  if (detCache.hasOwnProperty(cacheKey)) {
    return detCache[cacheKey];
  }
  if (rank === 1) {
    const colStart = Math.round(Math.log((1 << fullRank) - 1 & ~colMask) / LN2);
    return rows[rowStart][colStart];
  }
  const subRowMask = rowMask | 1 << rowStart;
  let subRowStart = rowStart + 1;
  while (rowMask & 1 << subRowStart) {
    subRowStart++;
  }
  let sum2 = 0;
  for (let j = 0, colLocalIdx = 0; j < fullRank; j++) {
    const colTag = 1 << j;
    if (!(colTag & colMask)) {
      sum2 += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j] * determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache);
      colLocalIdx++;
    }
  }
  detCache[cacheKey] = sum2;
  return sum2;
}
function buildTransformer(src, dest) {
  const mA = [
    [src[0], src[1], 1, 0, 0, 0, -dest[0] * src[0], -dest[0] * src[1]],
    [0, 0, 0, src[0], src[1], 1, -dest[1] * src[0], -dest[1] * src[1]],
    [src[2], src[3], 1, 0, 0, 0, -dest[2] * src[2], -dest[2] * src[3]],
    [0, 0, 0, src[2], src[3], 1, -dest[3] * src[2], -dest[3] * src[3]],
    [src[4], src[5], 1, 0, 0, 0, -dest[4] * src[4], -dest[4] * src[5]],
    [0, 0, 0, src[4], src[5], 1, -dest[5] * src[4], -dest[5] * src[5]],
    [src[6], src[7], 1, 0, 0, 0, -dest[6] * src[6], -dest[6] * src[7]],
    [0, 0, 0, src[6], src[7], 1, -dest[7] * src[6], -dest[7] * src[7]]
  ];
  const detCache = {};
  const det = determinant(mA, 8, 0, 0, 0, detCache);
  if (det === 0) {
    return;
  }
  const vh = [];
  for (let i = 0; i < 8; i++) {
    for (let j = 0; j < 8; j++) {
      vh[j] == null && (vh[j] = 0);
      vh[j] += ((i + j) % 2 ? -1 : 1) * determinant(mA, 7, i === 0 ? 1 : 0, 1 << i, 1 << j, detCache) / det * dest[i];
    }
  }
  return function(out2, srcPointX, srcPointY) {
    const pk = srcPointX * vh[6] + srcPointY * vh[7] + 1;
    out2[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk;
    out2[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk;
  };
}

// node_modules/zrender/src/core/dom.ts
var EVENT_SAVED_PROP = "___zrEVENTSAVED";
var _calcOut = [];
function transformLocalCoord(out2, elFrom, elTarget, inX, inY) {
  return transformCoordWithViewport(_calcOut, elFrom, inX, inY, true) && transformCoordWithViewport(out2, elTarget, _calcOut[0], _calcOut[1]);
}
function transformCoordWithViewport(out2, el, inX, inY, inverse) {
  if (el.getBoundingClientRect && env_default.domSupported && !isCanvasEl(el)) {
    const saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});
    const markers = prepareCoordMarkers(el, saved);
    const transformer = preparePointerTransformer(markers, saved, inverse);
    if (transformer) {
      transformer(out2, inX, inY);
      return true;
    }
  }
  return false;
}
function prepareCoordMarkers(el, saved) {
  let markers = saved.markers;
  if (markers) {
    return markers;
  }
  markers = saved.markers = [];
  const propLR = ["left", "right"];
  const propTB = ["top", "bottom"];
  for (let i = 0; i < 4; i++) {
    const marker = document.createElement("div");
    const stl = marker.style;
    const idxLR = i % 2;
    const idxTB = (i >> 1) % 2;
    stl.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      propLR[idxLR] + ":0",
      propTB[idxTB] + ":0",
      propLR[1 - idxLR] + ":auto",
      propTB[1 - idxTB] + ":auto",
      ""
    ].join("!important;");
    el.appendChild(marker);
    markers.push(marker);
  }
  return markers;
}
function preparePointerTransformer(markers, saved, inverse) {
  const transformerName = inverse ? "invTrans" : "trans";
  const transformer = saved[transformerName];
  const oldSrcCoords = saved.srcCoords;
  const srcCoords = [];
  const destCoords = [];
  let oldCoordTheSame = true;
  for (let i = 0; i < 4; i++) {
    const rect = markers[i].getBoundingClientRect();
    const ii = 2 * i;
    const x = rect.left;
    const y = rect.top;
    srcCoords.push(x, y);
    oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1];
    destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);
  }
  return oldCoordTheSame && transformer ? transformer : (saved.srcCoords = srcCoords, saved[transformerName] = inverse ? buildTransformer(destCoords, srcCoords) : buildTransformer(srcCoords, destCoords));
}
function isCanvasEl(el) {
  return el.nodeName.toUpperCase() === "CANVAS";
}
var replaceReg = /([&<>"'])/g;
var replaceMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function encodeHTML(source) {
  return source == null ? "" : (source + "").replace(replaceReg, function(str, c) {
    return replaceMap[c];
  });
}

// node_modules/zrender/src/core/event.ts
var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
var _calcOut2 = [];
var firefoxNotSupportOffsetXY = env_default.browser.firefox && +env_default.browser.version.split(".")[0] < 39;
function clientToLocal(el, e2, out2, calculate) {
  out2 = out2 || {};
  if (calculate) {
    calculateZrXY(el, e2, out2);
  } else if (firefoxNotSupportOffsetXY && e2.layerX != null && e2.layerX !== e2.offsetX) {
    out2.zrX = e2.layerX;
    out2.zrY = e2.layerY;
  } else if (e2.offsetX != null) {
    out2.zrX = e2.offsetX;
    out2.zrY = e2.offsetY;
  } else {
    calculateZrXY(el, e2, out2);
  }
  return out2;
}
function calculateZrXY(el, e2, out2) {
  if (env_default.domSupported && el.getBoundingClientRect) {
    const ex = e2.clientX;
    const ey = e2.clientY;
    if (isCanvasEl(el)) {
      const box2 = el.getBoundingClientRect();
      out2.zrX = ex - box2.left;
      out2.zrY = ey - box2.top;
      return;
    } else {
      if (transformCoordWithViewport(_calcOut2, el, ex, ey)) {
        out2.zrX = _calcOut2[0];
        out2.zrY = _calcOut2[1];
        return;
      }
    }
  }
  out2.zrX = out2.zrY = 0;
}
function getNativeEvent(e2) {
  return e2 || window.event;
}
function normalizeEvent(el, e2, calculate) {
  e2 = getNativeEvent(e2);
  if (e2.zrX != null) {
    return e2;
  }
  const eventType = e2.type;
  const isTouch = eventType && eventType.indexOf("touch") >= 0;
  if (!isTouch) {
    clientToLocal(el, e2, e2, calculate);
    const wheelDelta = getWheelDeltaMayPolyfill(e2);
    e2.zrDelta = wheelDelta ? wheelDelta / 120 : -(e2.detail || 0) / 3;
  } else {
    const touch = eventType !== "touchend" ? e2.targetTouches[0] : e2.changedTouches[0];
    touch && clientToLocal(el, touch, e2, calculate);
  }
  const button = e2.button;
  if (e2.which == null && button !== void 0 && MOUSE_EVENT_REG.test(e2.type)) {
    e2.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
  }
  return e2;
}
function getWheelDeltaMayPolyfill(e2) {
  const rawWheelDelta = e2.wheelDelta;
  if (rawWheelDelta) {
    return rawWheelDelta;
  }
  const deltaX = e2.deltaX;
  const deltaY = e2.deltaY;
  if (deltaX == null || deltaY == null) {
    return rawWheelDelta;
  }
  const delta = deltaY !== 0 ? Math.abs(deltaY) : Math.abs(deltaX);
  const sign = deltaY > 0 ? -1 : deltaY < 0 ? 1 : deltaX > 0 ? -1 : 1;
  return 3 * delta * sign;
}
function addEventListener(el, name, handler, opt) {
  el.addEventListener(name, handler, opt);
}
function removeEventListener(el, name, handler, opt) {
  el.removeEventListener(name, handler, opt);
}
var stop = function(e2) {
  e2.preventDefault();
  e2.stopPropagation();
  e2.cancelBubble = true;
};
function isMiddleOrRightButtonOnMouseUpDown(e2) {
  return e2.which === 2 || e2.which === 3;
}

// node_modules/zrender/src/core/GestureMgr.ts
var GestureMgr = class {
  constructor() {
    this._track = [];
  }
  recognize(event, target, root) {
    this._doTrack(event, target, root);
    return this._recognize(event);
  }
  clear() {
    this._track.length = 0;
    return this;
  }
  _doTrack(event, target, root) {
    const touches = event.touches;
    if (!touches) {
      return;
    }
    const trackItem = {
      points: [],
      touches: [],
      target,
      event
    };
    for (let i = 0, len2 = touches.length; i < len2; i++) {
      const touch = touches[i];
      const pos = clientToLocal(root, touch, {});
      trackItem.points.push([pos.zrX, pos.zrY]);
      trackItem.touches.push(touch);
    }
    this._track.push(trackItem);
  }
  _recognize(event) {
    for (let eventName in recognizers) {
      if (recognizers.hasOwnProperty(eventName)) {
        const gestureInfo = recognizers[eventName](this._track, event);
        if (gestureInfo) {
          return gestureInfo;
        }
      }
    }
  }
};
function dist2(pointPair) {
  const dx = pointPair[1][0] - pointPair[0][0];
  const dy = pointPair[1][1] - pointPair[0][1];
  return Math.sqrt(dx * dx + dy * dy);
}
function center(pointPair) {
  return [
    (pointPair[0][0] + pointPair[1][0]) / 2,
    (pointPair[0][1] + pointPair[1][1]) / 2
  ];
}
var recognizers = {
  pinch: function(tracks, event) {
    const trackLen = tracks.length;
    if (!trackLen) {
      return;
    }
    const pinchEnd = (tracks[trackLen - 1] || {}).points;
    const pinchPre = (tracks[trackLen - 2] || {}).points || pinchEnd;
    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
      let pinchScale = dist2(pinchEnd) / dist2(pinchPre);
      !isFinite(pinchScale) && (pinchScale = 1);
      event.pinchScale = pinchScale;
      const pinchCenter = center(pinchEnd);
      event.pinchX = pinchCenter[0];
      event.pinchY = pinchCenter[1];
      return {
        type: "pinch",
        target: tracks[0].target,
        event
      };
    }
  }
};

// node_modules/zrender/src/core/matrix.ts
var matrix_exports = {};
__export(matrix_exports, {
  clone: () => clone3,
  copy: () => copy2,
  create: () => create2,
  identity: () => identity,
  invert: () => invert,
  mul: () => mul2,
  rotate: () => rotate,
  scale: () => scale2,
  translate: () => translate
});
function create2() {
  return [1, 0, 0, 1, 0, 0];
}
function identity(out2) {
  out2[0] = 1;
  out2[1] = 0;
  out2[2] = 0;
  out2[3] = 1;
  out2[4] = 0;
  out2[5] = 0;
  return out2;
}
function copy2(out2, m2) {
  out2[0] = m2[0];
  out2[1] = m2[1];
  out2[2] = m2[2];
  out2[3] = m2[3];
  out2[4] = m2[4];
  out2[5] = m2[5];
  return out2;
}
function mul2(out2, m1, m2) {
  const out0 = m1[0] * m2[0] + m1[2] * m2[1];
  const out1 = m1[1] * m2[0] + m1[3] * m2[1];
  const out22 = m1[0] * m2[2] + m1[2] * m2[3];
  const out3 = m1[1] * m2[2] + m1[3] * m2[3];
  const out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
  const out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
  out2[0] = out0;
  out2[1] = out1;
  out2[2] = out22;
  out2[3] = out3;
  out2[4] = out4;
  out2[5] = out5;
  return out2;
}
function translate(out2, a, v) {
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  out2[3] = a[3];
  out2[4] = a[4] + v[0];
  out2[5] = a[5] + v[1];
  return out2;
}
function rotate(out2, a, rad, pivot = [0, 0]) {
  const aa = a[0];
  const ac = a[2];
  const atx = a[4];
  const ab = a[1];
  const ad = a[3];
  const aty = a[5];
  const st = Math.sin(rad);
  const ct = Math.cos(rad);
  out2[0] = aa * ct + ab * st;
  out2[1] = -aa * st + ab * ct;
  out2[2] = ac * ct + ad * st;
  out2[3] = -ac * st + ct * ad;
  out2[4] = ct * (atx - pivot[0]) + st * (aty - pivot[1]) + pivot[0];
  out2[5] = ct * (aty - pivot[1]) - st * (atx - pivot[0]) + pivot[1];
  return out2;
}
function scale2(out2, a, v) {
  const vx = v[0];
  const vy = v[1];
  out2[0] = a[0] * vx;
  out2[1] = a[1] * vy;
  out2[2] = a[2] * vx;
  out2[3] = a[3] * vy;
  out2[4] = a[4] * vx;
  out2[5] = a[5] * vy;
  return out2;
}
function invert(out2, a) {
  const aa = a[0];
  const ac = a[2];
  const atx = a[4];
  const ab = a[1];
  const ad = a[3];
  const aty = a[5];
  let det = aa * ad - ab * ac;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out2[0] = ad * det;
  out2[1] = -ab * det;
  out2[2] = -ac * det;
  out2[3] = aa * det;
  out2[4] = (ac * aty - ad * atx) * det;
  out2[5] = (ab * atx - aa * aty) * det;
  return out2;
}
function clone3(a) {
  const b = create2();
  copy2(b, a);
  return b;
}

// node_modules/zrender/src/core/Point.ts
var Point = class {
  constructor(x, y) {
    this.x = x || 0;
    this.y = y || 0;
  }
  copy(other) {
    this.x = other.x;
    this.y = other.y;
    return this;
  }
  clone() {
    return new Point(this.x, this.y);
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  equal(other) {
    return other.x === this.x && other.y === this.y;
  }
  add(other) {
    this.x += other.x;
    this.y += other.y;
    return this;
  }
  scale(scalar) {
    this.x *= scalar;
    this.y *= scalar;
  }
  scaleAndAdd(other, scalar) {
    this.x += other.x * scalar;
    this.y += other.y * scalar;
  }
  sub(other) {
    this.x -= other.x;
    this.y -= other.y;
    return this;
  }
  dot(other) {
    return this.x * other.x + this.y * other.y;
  }
  len() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  lenSquare() {
    return this.x * this.x + this.y * this.y;
  }
  normalize() {
    const len2 = this.len();
    this.x /= len2;
    this.y /= len2;
    return this;
  }
  distance(other) {
    const dx = this.x - other.x;
    const dy = this.y - other.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
  distanceSquare(other) {
    const dx = this.x - other.x;
    const dy = this.y - other.y;
    return dx * dx + dy * dy;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  transform(m2) {
    if (!m2) {
      return;
    }
    const x = this.x;
    const y = this.y;
    this.x = m2[0] * x + m2[2] * y + m2[4];
    this.y = m2[1] * x + m2[3] * y + m2[5];
    return this;
  }
  toArray(out2) {
    out2[0] = this.x;
    out2[1] = this.y;
    return out2;
  }
  fromArray(input) {
    this.x = input[0];
    this.y = input[1];
  }
  static set(p, x, y) {
    p.x = x;
    p.y = y;
  }
  static copy(p, p2) {
    p.x = p2.x;
    p.y = p2.y;
  }
  static len(p) {
    return Math.sqrt(p.x * p.x + p.y * p.y);
  }
  static lenSquare(p) {
    return p.x * p.x + p.y * p.y;
  }
  static dot(p0, p1) {
    return p0.x * p1.x + p0.y * p1.y;
  }
  static add(out2, p0, p1) {
    out2.x = p0.x + p1.x;
    out2.y = p0.y + p1.y;
  }
  static sub(out2, p0, p1) {
    out2.x = p0.x - p1.x;
    out2.y = p0.y - p1.y;
  }
  static scale(out2, p0, scalar) {
    out2.x = p0.x * scalar;
    out2.y = p0.y * scalar;
  }
  static scaleAndAdd(out2, p0, p1, scalar) {
    out2.x = p0.x + p1.x * scalar;
    out2.y = p0.y + p1.y * scalar;
  }
  static lerp(out2, p0, p1, t) {
    const onet = 1 - t;
    out2.x = onet * p0.x + t * p1.x;
    out2.y = onet * p0.y + t * p1.y;
  }
};
var Point_default = Point;

// node_modules/zrender/src/core/BoundingRect.ts
var mathMin = Math.min;
var mathMax = Math.max;
var lt = new Point_default();
var rb = new Point_default();
var lb = new Point_default();
var rt = new Point_default();
var minTv = new Point_default();
var maxTv = new Point_default();
var BoundingRect = class {
  constructor(x, y, width, height) {
    if (width < 0) {
      x = x + width;
      width = -width;
    }
    if (height < 0) {
      y = y + height;
      height = -height;
    }
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
  }
  union(other) {
    const x = mathMin(other.x, this.x);
    const y = mathMin(other.y, this.y);
    if (isFinite(this.x) && isFinite(this.width)) {
      this.width = mathMax(other.x + other.width, this.x + this.width) - x;
    } else {
      this.width = other.width;
    }
    if (isFinite(this.y) && isFinite(this.height)) {
      this.height = mathMax(other.y + other.height, this.y + this.height) - y;
    } else {
      this.height = other.height;
    }
    this.x = x;
    this.y = y;
  }
  applyTransform(m2) {
    BoundingRect.applyTransform(this, this, m2);
  }
  calculateTransform(b) {
    const a = this;
    const sx = b.width / a.width;
    const sy = b.height / a.height;
    const m2 = create2();
    translate(m2, m2, [-a.x, -a.y]);
    scale2(m2, m2, [sx, sy]);
    translate(m2, m2, [b.x, b.y]);
    return m2;
  }
  intersect(b, mtv) {
    if (!b) {
      return false;
    }
    if (!(b instanceof BoundingRect)) {
      b = BoundingRect.create(b);
    }
    const a = this;
    const ax0 = a.x;
    const ax1 = a.x + a.width;
    const ay0 = a.y;
    const ay1 = a.y + a.height;
    const bx0 = b.x;
    const bx1 = b.x + b.width;
    const by0 = b.y;
    const by1 = b.y + b.height;
    let overlap = !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
    if (mtv) {
      let dMin = Infinity;
      let dMax = 0;
      const d0 = Math.abs(ax1 - bx0);
      const d1 = Math.abs(bx1 - ax0);
      const d2 = Math.abs(ay1 - by0);
      const d3 = Math.abs(by1 - ay0);
      const dx = Math.min(d0, d1);
      const dy = Math.min(d2, d3);
      if (ax1 < bx0 || bx1 < ax0) {
        if (dx > dMax) {
          dMax = dx;
          if (d0 < d1) {
            Point_default.set(maxTv, -d0, 0);
          } else {
            Point_default.set(maxTv, d1, 0);
          }
        }
      } else {
        if (dx < dMin) {
          dMin = dx;
          if (d0 < d1) {
            Point_default.set(minTv, d0, 0);
          } else {
            Point_default.set(minTv, -d1, 0);
          }
        }
      }
      if (ay1 < by0 || by1 < ay0) {
        if (dy > dMax) {
          dMax = dy;
          if (d2 < d3) {
            Point_default.set(maxTv, 0, -d2);
          } else {
            Point_default.set(maxTv, 0, d3);
          }
        }
      } else {
        if (dx < dMin) {
          dMin = dx;
          if (d2 < d3) {
            Point_default.set(minTv, 0, d2);
          } else {
            Point_default.set(minTv, 0, -d3);
          }
        }
      }
    }
    if (mtv) {
      Point_default.copy(mtv, overlap ? minTv : maxTv);
    }
    return overlap;
  }
  contain(x, y) {
    const rect = this;
    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
  }
  clone() {
    return new BoundingRect(this.x, this.y, this.width, this.height);
  }
  copy(other) {
    BoundingRect.copy(this, other);
  }
  plain() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }
  isFinite() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  }
  isZero() {
    return this.width === 0 || this.height === 0;
  }
  static create(rect) {
    return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
  }
  static copy(target, source) {
    target.x = source.x;
    target.y = source.y;
    target.width = source.width;
    target.height = source.height;
  }
  static applyTransform(target, source, m2) {
    if (!m2) {
      if (target !== source) {
        BoundingRect.copy(target, source);
      }
      return;
    }
    if (m2[1] < 1e-5 && m2[1] > -1e-5 && m2[2] < 1e-5 && m2[2] > -1e-5) {
      const sx = m2[0];
      const sy = m2[3];
      const tx = m2[4];
      const ty = m2[5];
      target.x = source.x * sx + tx;
      target.y = source.y * sy + ty;
      target.width = source.width * sx;
      target.height = source.height * sy;
      if (target.width < 0) {
        target.x += target.width;
        target.width = -target.width;
      }
      if (target.height < 0) {
        target.y += target.height;
        target.height = -target.height;
      }
      return;
    }
    lt.x = lb.x = source.x;
    lt.y = rt.y = source.y;
    rb.x = rt.x = source.x + source.width;
    rb.y = lb.y = source.y + source.height;
    lt.transform(m2);
    rt.transform(m2);
    rb.transform(m2);
    lb.transform(m2);
    target.x = mathMin(lt.x, rb.x, lb.x, rt.x);
    target.y = mathMin(lt.y, rb.y, lb.y, rt.y);
    const maxX = mathMax(lt.x, rb.x, lb.x, rt.x);
    const maxY = mathMax(lt.y, rb.y, lb.y, rt.y);
    target.width = maxX - target.x;
    target.height = maxY - target.y;
  }
};
var BoundingRect_default = BoundingRect;

// node_modules/zrender/src/Handler.ts
var SILENT = "silent";
function makeEventPacket(eveType, targetInfo, event) {
  return {
    type: eveType,
    event,
    target: targetInfo.target,
    topTarget: targetInfo.topTarget,
    cancelBubble: false,
    offsetX: event.zrX,
    offsetY: event.zrY,
    gestureEvent: event.gestureEvent,
    pinchX: event.pinchX,
    pinchY: event.pinchY,
    pinchScale: event.pinchScale,
    wheelDelta: event.zrDelta,
    zrByTouch: event.zrByTouch,
    which: event.which,
    stop: stopEvent
  };
}
function stopEvent() {
  stop(this.event);
}
var EmptyProxy = class extends Eventful_default {
  constructor() {
    super(...arguments);
    this.handler = null;
  }
  dispose() {
  }
  setCursor() {
  }
};
var HoveredResult = class {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
};
var handlerNames = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
];
var tmpRect = new BoundingRect_default(0, 0, 0, 0);
var Handler = class extends Eventful_default {
  constructor(storage2, painter, proxy, painterRoot, pointerSize) {
    super();
    this._hovered = new HoveredResult(0, 0);
    this.storage = storage2;
    this.painter = painter;
    this.painterRoot = painterRoot;
    this._pointerSize = pointerSize;
    proxy = proxy || new EmptyProxy();
    this.proxy = null;
    this.setHandlerProxy(proxy);
    this._draggingMgr = new Draggable_default(this);
  }
  setHandlerProxy(proxy) {
    if (this.proxy) {
      this.proxy.dispose();
    }
    if (proxy) {
      each(handlerNames, function(name) {
        proxy.on && proxy.on(name, this[name], this);
      }, this);
      proxy.handler = this;
    }
    this.proxy = proxy;
  }
  mousemove(event) {
    const x = event.zrX;
    const y = event.zrY;
    const isOutside = isOutsideBoundary(this, x, y);
    let lastHovered = this._hovered;
    let lastHoveredTarget = lastHovered.target;
    if (lastHoveredTarget && !lastHoveredTarget.__zr) {
      lastHovered = this.findHover(lastHovered.x, lastHovered.y);
      lastHoveredTarget = lastHovered.target;
    }
    const hovered = this._hovered = isOutside ? new HoveredResult(x, y) : this.findHover(x, y);
    const hoveredTarget = hovered.target;
    const proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : "default");
    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(lastHovered, "mouseout", event);
    }
    this.dispatchToElement(hovered, "mousemove", event);
    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
      this.dispatchToElement(hovered, "mouseover", event);
    }
  }
  mouseout(event) {
    const eventControl = event.zrEventControl;
    if (eventControl !== "only_globalout") {
      this.dispatchToElement(this._hovered, "mouseout", event);
    }
    if (eventControl !== "no_globalout") {
      this.trigger("globalout", {type: "globalout", event});
    }
  }
  resize() {
    this._hovered = new HoveredResult(0, 0);
  }
  dispatch(eventName, eventArgs) {
    const handler = this[eventName];
    handler && handler.call(this, eventArgs);
  }
  dispose() {
    this.proxy.dispose();
    this.storage = null;
    this.proxy = null;
    this.painter = null;
  }
  setCursorStyle(cursorStyle) {
    const proxy = this.proxy;
    proxy.setCursor && proxy.setCursor(cursorStyle);
  }
  dispatchToElement(targetInfo, eventName, event) {
    targetInfo = targetInfo || {};
    let el = targetInfo.target;
    if (el && el.silent) {
      return;
    }
    const eventKey = "on" + eventName;
    const eventPacket = makeEventPacket(eventName, targetInfo, event);
    while (el) {
      el[eventKey] && (eventPacket.cancelBubble = !!el[eventKey].call(el, eventPacket));
      el.trigger(eventName, eventPacket);
      el = el.__hostTarget ? el.__hostTarget : el.parent;
      if (eventPacket.cancelBubble) {
        break;
      }
    }
    if (!eventPacket.cancelBubble) {
      this.trigger(eventName, eventPacket);
      if (this.painter && this.painter.eachOtherLayer) {
        this.painter.eachOtherLayer(function(layer) {
          if (typeof layer[eventKey] === "function") {
            layer[eventKey].call(layer, eventPacket);
          }
          if (layer.trigger) {
            layer.trigger(eventName, eventPacket);
          }
        });
      }
    }
  }
  findHover(x, y, exclude) {
    const list = this.storage.getDisplayList();
    const out2 = new HoveredResult(x, y);
    setHoverTarget(list, out2, x, y, exclude);
    if (this._pointerSize && !out2.target) {
      const candidates = [];
      const pointerSize = this._pointerSize;
      const targetSizeHalf = pointerSize / 2;
      const pointerRect = new BoundingRect_default(x - targetSizeHalf, y - targetSizeHalf, pointerSize, pointerSize);
      for (let i = list.length - 1; i >= 0; i--) {
        const el = list[i];
        if (el !== exclude && !el.ignore && !el.ignoreCoarsePointer && (!el.parent || !el.parent.ignoreCoarsePointer)) {
          tmpRect.copy(el.getBoundingRect());
          if (el.transform) {
            tmpRect.applyTransform(el.transform);
          }
          if (tmpRect.intersect(pointerRect)) {
            candidates.push(el);
          }
        }
      }
      if (candidates.length) {
        const rStep = 4;
        const thetaStep = Math.PI / 12;
        const PI210 = Math.PI * 2;
        for (let r = 0; r < targetSizeHalf; r += rStep) {
          for (let theta = 0; theta < PI210; theta += thetaStep) {
            const x1 = x + r * Math.cos(theta);
            const y1 = y + r * Math.sin(theta);
            setHoverTarget(candidates, out2, x1, y1, exclude);
            if (out2.target) {
              return out2;
            }
          }
        }
      }
    }
    return out2;
  }
  processGesture(event, stage) {
    if (!this._gestureMgr) {
      this._gestureMgr = new GestureMgr();
    }
    const gestureMgr = this._gestureMgr;
    stage === "start" && gestureMgr.clear();
    const gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);
    stage === "end" && gestureMgr.clear();
    if (gestureInfo) {
      const type = gestureInfo.type;
      event.gestureEvent = type;
      let res = new HoveredResult();
      res.target = gestureInfo.target;
      this.dispatchToElement(res, type, gestureInfo.event);
    }
  }
};
each(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(name) {
  Handler.prototype[name] = function(event) {
    const x = event.zrX;
    const y = event.zrY;
    const isOutside = isOutsideBoundary(this, x, y);
    let hovered;
    let hoveredTarget;
    if (name !== "mouseup" || !isOutside) {
      hovered = this.findHover(x, y);
      hoveredTarget = hovered.target;
    }
    if (name === "mousedown") {
      this._downEl = hoveredTarget;
      this._downPoint = [event.zrX, event.zrY];
      this._upEl = hoveredTarget;
    } else if (name === "mouseup") {
      this._upEl = hoveredTarget;
    } else if (name === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || dist(this._downPoint, [event.zrX, event.zrY]) > 4) {
        return;
      }
      this._downPoint = null;
    }
    this.dispatchToElement(hovered, name, event);
  };
});
function isHover(displayable, x, y) {
  if (displayable[displayable.rectHover ? "rectContain" : "contain"](x, y)) {
    let el = displayable;
    let isSilent;
    let ignoreClip = false;
    while (el) {
      if (el.ignoreClip) {
        ignoreClip = true;
      }
      if (!ignoreClip) {
        let clipPath = el.getClipPath();
        if (clipPath && !clipPath.contain(x, y)) {
          return false;
        }
      }
      if (el.silent) {
        isSilent = true;
      }
      const hostEl = el.__hostTarget;
      el = hostEl ? hostEl : el.parent;
    }
    return isSilent ? SILENT : true;
  }
  return false;
}
function setHoverTarget(list, out2, x, y, exclude) {
  for (let i = list.length - 1; i >= 0; i--) {
    const el = list[i];
    let hoverCheckResult;
    if (el !== exclude && !el.ignore && (hoverCheckResult = isHover(el, x, y))) {
      !out2.topTarget && (out2.topTarget = el);
      if (hoverCheckResult !== SILENT) {
        out2.target = el;
        break;
      }
    }
  }
}
function isOutsideBoundary(handlerInstance, x, y) {
  const painter = handlerInstance.painter;
  return x < 0 || x > painter.getWidth() || y < 0 || y > painter.getHeight();
}
var Handler_default = Handler;

// node_modules/zrender/src/core/timsort.ts
var DEFAULT_MIN_MERGE = 32;
var DEFAULT_MIN_GALLOPING = 7;
function minRunLength(n) {
  var r = 0;
  while (n >= DEFAULT_MIN_MERGE) {
    r |= n & 1;
    n >>= 1;
  }
  return n + r;
}
function makeAscendingRun(array, lo, hi, compare2) {
  var runHi = lo + 1;
  if (runHi === hi) {
    return 1;
  }
  if (compare2(array[runHi++], array[lo]) < 0) {
    while (runHi < hi && compare2(array[runHi], array[runHi - 1]) < 0) {
      runHi++;
    }
    reverseRun(array, lo, runHi);
  } else {
    while (runHi < hi && compare2(array[runHi], array[runHi - 1]) >= 0) {
      runHi++;
    }
  }
  return runHi - lo;
}
function reverseRun(array, lo, hi) {
  hi--;
  while (lo < hi) {
    var t = array[lo];
    array[lo++] = array[hi];
    array[hi--] = t;
  }
}
function binaryInsertionSort(array, lo, hi, start2, compare2) {
  if (start2 === lo) {
    start2++;
  }
  for (; start2 < hi; start2++) {
    var pivot = array[start2];
    var left = lo;
    var right = start2;
    var mid;
    while (left < right) {
      mid = left + right >>> 1;
      if (compare2(pivot, array[mid]) < 0) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }
    var n = start2 - left;
    switch (n) {
      case 3:
        array[left + 3] = array[left + 2];
      case 2:
        array[left + 2] = array[left + 1];
      case 1:
        array[left + 1] = array[left];
        break;
      default:
        while (n > 0) {
          array[left + n] = array[left + n - 1];
          n--;
        }
    }
    array[left] = pivot;
  }
}
function gallopLeft(value, array, start2, length2, hint, compare2) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset = 1;
  if (compare2(value, array[start2 + hint]) > 0) {
    maxOffset = length2 - hint;
    while (offset < maxOffset && compare2(value, array[start2 + hint + offset]) > 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    lastOffset += hint;
    offset += hint;
  } else {
    maxOffset = hint + 1;
    while (offset < maxOffset && compare2(value, array[start2 + hint - offset]) <= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    var tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  }
  lastOffset++;
  while (lastOffset < offset) {
    var m2 = lastOffset + (offset - lastOffset >>> 1);
    if (compare2(value, array[start2 + m2]) > 0) {
      lastOffset = m2 + 1;
    } else {
      offset = m2;
    }
  }
  return offset;
}
function gallopRight(value, array, start2, length2, hint, compare2) {
  var lastOffset = 0;
  var maxOffset = 0;
  var offset = 1;
  if (compare2(value, array[start2 + hint]) < 0) {
    maxOffset = hint + 1;
    while (offset < maxOffset && compare2(value, array[start2 + hint - offset]) < 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    var tmp = lastOffset;
    lastOffset = hint - offset;
    offset = hint - tmp;
  } else {
    maxOffset = length2 - hint;
    while (offset < maxOffset && compare2(value, array[start2 + hint + offset]) >= 0) {
      lastOffset = offset;
      offset = (offset << 1) + 1;
      if (offset <= 0) {
        offset = maxOffset;
      }
    }
    if (offset > maxOffset) {
      offset = maxOffset;
    }
    lastOffset += hint;
    offset += hint;
  }
  lastOffset++;
  while (lastOffset < offset) {
    var m2 = lastOffset + (offset - lastOffset >>> 1);
    if (compare2(value, array[start2 + m2]) < 0) {
      offset = m2;
    } else {
      lastOffset = m2 + 1;
    }
  }
  return offset;
}
function TimSort(array, compare2) {
  let minGallop = DEFAULT_MIN_GALLOPING;
  let runStart;
  let runLength;
  let stackSize = 0;
  var tmp = [];
  runStart = [];
  runLength = [];
  function pushRun(_runStart, _runLength) {
    runStart[stackSize] = _runStart;
    runLength[stackSize] = _runLength;
    stackSize += 1;
  }
  function mergeRuns() {
    while (stackSize > 1) {
      var n = stackSize - 2;
      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
        if (runLength[n - 1] < runLength[n + 1]) {
          n--;
        }
      } else if (runLength[n] > runLength[n + 1]) {
        break;
      }
      mergeAt(n);
    }
  }
  function forceMergeRuns() {
    while (stackSize > 1) {
      var n = stackSize - 2;
      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
        n--;
      }
      mergeAt(n);
    }
  }
  function mergeAt(i) {
    var start1 = runStart[i];
    var length1 = runLength[i];
    var start2 = runStart[i + 1];
    var length2 = runLength[i + 1];
    runLength[i] = length1 + length2;
    if (i === stackSize - 3) {
      runStart[i + 1] = runStart[i + 2];
      runLength[i + 1] = runLength[i + 2];
    }
    stackSize--;
    var k = gallopRight(array[start2], array, start1, length1, 0, compare2);
    start1 += k;
    length1 -= k;
    if (length1 === 0) {
      return;
    }
    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare2);
    if (length2 === 0) {
      return;
    }
    if (length1 <= length2) {
      mergeLow(start1, length1, start2, length2);
    } else {
      mergeHigh(start1, length1, start2, length2);
    }
  }
  function mergeLow(start1, length1, start2, length2) {
    var i = 0;
    for (i = 0; i < length1; i++) {
      tmp[i] = array[start1 + i];
    }
    var cursor1 = 0;
    var cursor2 = start2;
    var dest = start1;
    array[dest++] = array[cursor2++];
    if (--length2 === 0) {
      for (i = 0; i < length1; i++) {
        array[dest + i] = tmp[cursor1 + i];
      }
      return;
    }
    if (length1 === 1) {
      for (i = 0; i < length2; i++) {
        array[dest + i] = array[cursor2 + i];
      }
      array[dest + length2] = tmp[cursor1];
      return;
    }
    var _minGallop = minGallop;
    var count1;
    var count2;
    var exit;
    while (1) {
      count1 = 0;
      count2 = 0;
      exit = false;
      do {
        if (compare2(array[cursor2], tmp[cursor1]) < 0) {
          array[dest++] = array[cursor2++];
          count2++;
          count1 = 0;
          if (--length2 === 0) {
            exit = true;
            break;
          }
        } else {
          array[dest++] = tmp[cursor1++];
          count1++;
          count2 = 0;
          if (--length1 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < _minGallop);
      if (exit) {
        break;
      }
      do {
        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare2);
        if (count1 !== 0) {
          for (i = 0; i < count1; i++) {
            array[dest + i] = tmp[cursor1 + i];
          }
          dest += count1;
          cursor1 += count1;
          length1 -= count1;
          if (length1 <= 1) {
            exit = true;
            break;
          }
        }
        array[dest++] = array[cursor2++];
        if (--length2 === 0) {
          exit = true;
          break;
        }
        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare2);
        if (count2 !== 0) {
          for (i = 0; i < count2; i++) {
            array[dest + i] = array[cursor2 + i];
          }
          dest += count2;
          cursor2 += count2;
          length2 -= count2;
          if (length2 === 0) {
            exit = true;
            break;
          }
        }
        array[dest++] = tmp[cursor1++];
        if (--length1 === 1) {
          exit = true;
          break;
        }
        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
      if (exit) {
        break;
      }
      if (_minGallop < 0) {
        _minGallop = 0;
      }
      _minGallop += 2;
    }
    minGallop = _minGallop;
    minGallop < 1 && (minGallop = 1);
    if (length1 === 1) {
      for (i = 0; i < length2; i++) {
        array[dest + i] = array[cursor2 + i];
      }
      array[dest + length2] = tmp[cursor1];
    } else if (length1 === 0) {
      throw new Error();
    } else {
      for (i = 0; i < length1; i++) {
        array[dest + i] = tmp[cursor1 + i];
      }
    }
  }
  function mergeHigh(start1, length1, start2, length2) {
    var i = 0;
    for (i = 0; i < length2; i++) {
      tmp[i] = array[start2 + i];
    }
    var cursor1 = start1 + length1 - 1;
    var cursor2 = length2 - 1;
    var dest = start2 + length2 - 1;
    var customCursor = 0;
    var customDest = 0;
    array[dest--] = array[cursor1--];
    if (--length1 === 0) {
      customCursor = dest - (length2 - 1);
      for (i = 0; i < length2; i++) {
        array[customCursor + i] = tmp[i];
      }
      return;
    }
    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;
      for (i = length1 - 1; i >= 0; i--) {
        array[customDest + i] = array[customCursor + i];
      }
      array[dest] = tmp[cursor2];
      return;
    }
    var _minGallop = minGallop;
    while (true) {
      var count1 = 0;
      var count2 = 0;
      var exit = false;
      do {
        if (compare2(tmp[cursor2], array[cursor1]) < 0) {
          array[dest--] = array[cursor1--];
          count1++;
          count2 = 0;
          if (--length1 === 0) {
            exit = true;
            break;
          }
        } else {
          array[dest--] = tmp[cursor2--];
          count2++;
          count1 = 0;
          if (--length2 === 1) {
            exit = true;
            break;
          }
        }
      } while ((count1 | count2) < _minGallop);
      if (exit) {
        break;
      }
      do {
        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare2);
        if (count1 !== 0) {
          dest -= count1;
          cursor1 -= count1;
          length1 -= count1;
          customDest = dest + 1;
          customCursor = cursor1 + 1;
          for (i = count1 - 1; i >= 0; i--) {
            array[customDest + i] = array[customCursor + i];
          }
          if (length1 === 0) {
            exit = true;
            break;
          }
        }
        array[dest--] = tmp[cursor2--];
        if (--length2 === 1) {
          exit = true;
          break;
        }
        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare2);
        if (count2 !== 0) {
          dest -= count2;
          cursor2 -= count2;
          length2 -= count2;
          customDest = dest + 1;
          customCursor = cursor2 + 1;
          for (i = 0; i < count2; i++) {
            array[customDest + i] = tmp[customCursor + i];
          }
          if (length2 <= 1) {
            exit = true;
            break;
          }
        }
        array[dest--] = array[cursor1--];
        if (--length1 === 0) {
          exit = true;
          break;
        }
        _minGallop--;
      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
      if (exit) {
        break;
      }
      if (_minGallop < 0) {
        _minGallop = 0;
      }
      _minGallop += 2;
    }
    minGallop = _minGallop;
    if (minGallop < 1) {
      minGallop = 1;
    }
    if (length2 === 1) {
      dest -= length1;
      cursor1 -= length1;
      customDest = dest + 1;
      customCursor = cursor1 + 1;
      for (i = length1 - 1; i >= 0; i--) {
        array[customDest + i] = array[customCursor + i];
      }
      array[dest] = tmp[cursor2];
    } else if (length2 === 0) {
      throw new Error();
    } else {
      customCursor = dest - (length2 - 1);
      for (i = 0; i < length2; i++) {
        array[customCursor + i] = tmp[i];
      }
    }
  }
  return {
    mergeRuns,
    forceMergeRuns,
    pushRun
  };
}
function sort(array, compare2, lo, hi) {
  if (!lo) {
    lo = 0;
  }
  if (!hi) {
    hi = array.length;
  }
  var remaining = hi - lo;
  if (remaining < 2) {
    return;
  }
  var runLength = 0;
  if (remaining < DEFAULT_MIN_MERGE) {
    runLength = makeAscendingRun(array, lo, hi, compare2);
    binaryInsertionSort(array, lo, hi, lo + runLength, compare2);
    return;
  }
  var ts = TimSort(array, compare2);
  var minRun = minRunLength(remaining);
  do {
    runLength = makeAscendingRun(array, lo, hi, compare2);
    if (runLength < minRun) {
      var force = remaining;
      if (force > minRun) {
        force = minRun;
      }
      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare2);
      runLength = force;
    }
    ts.pushRun(lo, runLength);
    ts.mergeRuns();
    remaining -= runLength;
    lo += runLength;
  } while (remaining !== 0);
  ts.forceMergeRuns();
}

// node_modules/zrender/src/graphic/constants.ts
var REDRAW_BIT = 1;
var STYLE_CHANGED_BIT = 2;
var SHAPE_CHANGED_BIT = 4;

// node_modules/zrender/src/Storage.ts
var invalidZErrorLogged = false;
function logInvalidZError() {
  if (invalidZErrorLogged) {
    return;
  }
  invalidZErrorLogged = true;
  console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors");
}
function shapeCompareFunc(a, b) {
  if (a.zlevel === b.zlevel) {
    if (a.z === b.z) {
      return a.z2 - b.z2;
    }
    return a.z - b.z;
  }
  return a.zlevel - b.zlevel;
}
var Storage = class {
  constructor() {
    this._roots = [];
    this._displayList = [];
    this._displayListLen = 0;
    this.displayableSortFunc = shapeCompareFunc;
  }
  traverse(cb, context) {
    for (let i = 0; i < this._roots.length; i++) {
      this._roots[i].traverse(cb, context);
    }
  }
  getDisplayList(update, includeIgnore) {
    includeIgnore = includeIgnore || false;
    const displayList = this._displayList;
    if (update || !displayList.length) {
      this.updateDisplayList(includeIgnore);
    }
    return displayList;
  }
  updateDisplayList(includeIgnore) {
    this._displayListLen = 0;
    const roots2 = this._roots;
    const displayList = this._displayList;
    for (let i = 0, len2 = roots2.length; i < len2; i++) {
      this._updateAndAddDisplayable(roots2[i], null, includeIgnore);
    }
    displayList.length = this._displayListLen;
    sort(displayList, shapeCompareFunc);
  }
  _updateAndAddDisplayable(el, clipPaths, includeIgnore) {
    if (el.ignore && !includeIgnore) {
      return;
    }
    el.beforeUpdate();
    el.update();
    el.afterUpdate();
    const userSetClipPath = el.getClipPath();
    if (el.ignoreClip) {
      clipPaths = null;
    } else if (userSetClipPath) {
      if (clipPaths) {
        clipPaths = clipPaths.slice();
      } else {
        clipPaths = [];
      }
      let currentClipPath = userSetClipPath;
      let parentClipPath = el;
      while (currentClipPath) {
        currentClipPath.parent = parentClipPath;
        currentClipPath.updateTransform();
        clipPaths.push(currentClipPath);
        parentClipPath = currentClipPath;
        currentClipPath = currentClipPath.getClipPath();
      }
    }
    if (el.childrenRef) {
      const children = el.childrenRef();
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        if (el.__dirty) {
          child.__dirty |= REDRAW_BIT;
        }
        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
      }
      el.__dirty = 0;
    } else {
      const disp = el;
      if (clipPaths && clipPaths.length) {
        disp.__clipPaths = clipPaths;
      } else if (disp.__clipPaths && disp.__clipPaths.length > 0) {
        disp.__clipPaths = [];
      }
      if (isNaN(disp.z)) {
        logInvalidZError();
        disp.z = 0;
      }
      if (isNaN(disp.z2)) {
        logInvalidZError();
        disp.z2 = 0;
      }
      if (isNaN(disp.zlevel)) {
        logInvalidZError();
        disp.zlevel = 0;
      }
      this._displayList[this._displayListLen++] = disp;
    }
    const decalEl = el.getDecalElement && el.getDecalElement();
    if (decalEl) {
      this._updateAndAddDisplayable(decalEl, clipPaths, includeIgnore);
    }
    const textGuide = el.getTextGuideLine();
    if (textGuide) {
      this._updateAndAddDisplayable(textGuide, clipPaths, includeIgnore);
    }
    const textEl = el.getTextContent();
    if (textEl) {
      this._updateAndAddDisplayable(textEl, clipPaths, includeIgnore);
    }
  }
  addRoot(el) {
    if (el.__zr && el.__zr.storage === this) {
      return;
    }
    this._roots.push(el);
  }
  delRoot(el) {
    if (el instanceof Array) {
      for (let i = 0, l = el.length; i < l; i++) {
        this.delRoot(el[i]);
      }
      return;
    }
    const idx = indexOf(this._roots, el);
    if (idx >= 0) {
      this._roots.splice(idx, 1);
    }
  }
  delAllRoots() {
    this._roots = [];
    this._displayList = [];
    this._displayListLen = 0;
    return;
  }
  getRoots() {
    return this._roots;
  }
  dispose() {
    this._displayList = null;
    this._roots = null;
  }
};
var Storage_default = Storage;

// node_modules/zrender/src/animation/requestAnimationFrame.ts
var requestAnimationFrame;
requestAnimationFrame = env_default.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(func) {
  return setTimeout(func, 16);
};
var requestAnimationFrame_default = requestAnimationFrame;

// node_modules/zrender/src/animation/easing.ts
var easingFuncs = {
  linear(k) {
    return k;
  },
  quadraticIn(k) {
    return k * k;
  },
  quadraticOut(k) {
    return k * (2 - k);
  },
  quadraticInOut(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k;
    }
    return -0.5 * (--k * (k - 2) - 1);
  },
  cubicIn(k) {
    return k * k * k;
  },
  cubicOut(k) {
    return --k * k * k + 1;
  },
  cubicInOut(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k;
    }
    return 0.5 * ((k -= 2) * k * k + 2);
  },
  quarticIn(k) {
    return k * k * k * k;
  },
  quarticOut(k) {
    return 1 - --k * k * k * k;
  },
  quarticInOut(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k * k;
    }
    return -0.5 * ((k -= 2) * k * k * k - 2);
  },
  quinticIn(k) {
    return k * k * k * k * k;
  },
  quinticOut(k) {
    return --k * k * k * k * k + 1;
  },
  quinticInOut(k) {
    if ((k *= 2) < 1) {
      return 0.5 * k * k * k * k * k;
    }
    return 0.5 * ((k -= 2) * k * k * k * k + 2);
  },
  sinusoidalIn(k) {
    return 1 - Math.cos(k * Math.PI / 2);
  },
  sinusoidalOut(k) {
    return Math.sin(k * Math.PI / 2);
  },
  sinusoidalInOut(k) {
    return 0.5 * (1 - Math.cos(Math.PI * k));
  },
  exponentialIn(k) {
    return k === 0 ? 0 : Math.pow(1024, k - 1);
  },
  exponentialOut(k) {
    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
  },
  exponentialInOut(k) {
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if ((k *= 2) < 1) {
      return 0.5 * Math.pow(1024, k - 1);
    }
    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
  },
  circularIn(k) {
    return 1 - Math.sqrt(1 - k * k);
  },
  circularOut(k) {
    return Math.sqrt(1 - --k * k);
  },
  circularInOut(k) {
    if ((k *= 2) < 1) {
      return -0.5 * (Math.sqrt(1 - k * k) - 1);
    }
    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
  },
  elasticIn(k) {
    let s;
    let a = 0.1;
    let p = 0.4;
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }
    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
  },
  elasticOut(k) {
    let s;
    let a = 0.1;
    let p = 0.4;
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }
    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
  },
  elasticInOut(k) {
    let s;
    let a = 0.1;
    let p = 0.4;
    if (k === 0) {
      return 0;
    }
    if (k === 1) {
      return 1;
    }
    if (!a || a < 1) {
      a = 1;
      s = p / 4;
    } else {
      s = p * Math.asin(1 / a) / (2 * Math.PI);
    }
    if ((k *= 2) < 1) {
      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
    }
    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
  },
  backIn(k) {
    let s = 1.70158;
    return k * k * ((s + 1) * k - s);
  },
  backOut(k) {
    let s = 1.70158;
    return --k * k * ((s + 1) * k + s) + 1;
  },
  backInOut(k) {
    let s = 1.70158 * 1.525;
    if ((k *= 2) < 1) {
      return 0.5 * (k * k * ((s + 1) * k - s));
    }
    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
  },
  bounceIn(k) {
    return 1 - easingFuncs.bounceOut(1 - k);
  },
  bounceOut(k) {
    if (k < 1 / 2.75) {
      return 7.5625 * k * k;
    } else if (k < 2 / 2.75) {
      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
    } else if (k < 2.5 / 2.75) {
      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
    } else {
      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
    }
  },
  bounceInOut(k) {
    if (k < 0.5) {
      return easingFuncs.bounceIn(k * 2) * 0.5;
    }
    return easingFuncs.bounceOut(k * 2 - 1) * 0.5 + 0.5;
  }
};
var easing_default = easingFuncs;

// node_modules/zrender/src/core/curve.ts
var mathPow = Math.pow;
var mathSqrt = Math.sqrt;
var EPSILON = 1e-8;
var EPSILON_NUMERIC = 1e-4;
var THREE_SQRT = mathSqrt(3);
var ONE_THIRD = 1 / 3;
var _v0 = create();
var _v1 = create();
var _v2 = create();
function isAroundZero(val) {
  return val > -EPSILON && val < EPSILON;
}
function isNotAroundZero(val) {
  return val > EPSILON || val < -EPSILON;
}
function cubicAt(p0, p1, p2, p3, t) {
  const onet = 1 - t;
  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
}
function cubicDerivativeAt(p0, p1, p2, p3, t) {
  const onet = 1 - t;
  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
}
function cubicRootAt(p0, p1, p2, p3, val, roots2) {
  const a = p3 + 3 * (p1 - p2) - p0;
  const b = 3 * (p2 - p1 * 2 + p0);
  const c = 3 * (p1 - p0);
  const d = p0 - val;
  const A = b * b - 3 * a * c;
  const B = b * c - 9 * a * d;
  const C = c * c - 3 * b * d;
  let n = 0;
  if (isAroundZero(A) && isAroundZero(B)) {
    if (isAroundZero(b)) {
      roots2[0] = 0;
    } else {
      const t1 = -c / b;
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    }
  } else {
    const disc = B * B - 4 * A * C;
    if (isAroundZero(disc)) {
      const K = B / A;
      const t1 = -b / a + K;
      const t2 = -K / 2;
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        roots2[n++] = t2;
      }
    } else if (disc > 0) {
      const discSqrt = mathSqrt(disc);
      let Y1 = A * b + 1.5 * a * (-B + discSqrt);
      let Y2 = A * b + 1.5 * a * (-B - discSqrt);
      if (Y1 < 0) {
        Y1 = -mathPow(-Y1, ONE_THIRD);
      } else {
        Y1 = mathPow(Y1, ONE_THIRD);
      }
      if (Y2 < 0) {
        Y2 = -mathPow(-Y2, ONE_THIRD);
      } else {
        Y2 = mathPow(Y2, ONE_THIRD);
      }
      const t1 = (-b - (Y1 + Y2)) / (3 * a);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    } else {
      const T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
      const theta = Math.acos(T) / 3;
      const ASqrt = mathSqrt(A);
      const tmp = Math.cos(theta);
      const t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
      const t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
      const t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        roots2[n++] = t2;
      }
      if (t3 >= 0 && t3 <= 1) {
        roots2[n++] = t3;
      }
    }
  }
  return n;
}
function cubicExtrema(p0, p1, p2, p3, extrema2) {
  const b = 6 * p2 - 12 * p1 + 6 * p0;
  const a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
  const c = 3 * p1 - 3 * p0;
  let n = 0;
  if (isAroundZero(a)) {
    if (isNotAroundZero(b)) {
      const t1 = -c / b;
      if (t1 >= 0 && t1 <= 1) {
        extrema2[n++] = t1;
      }
    }
  } else {
    const disc = b * b - 4 * a * c;
    if (isAroundZero(disc)) {
      extrema2[0] = -b / (2 * a);
    } else if (disc > 0) {
      const discSqrt = mathSqrt(disc);
      const t1 = (-b + discSqrt) / (2 * a);
      const t2 = (-b - discSqrt) / (2 * a);
      if (t1 >= 0 && t1 <= 1) {
        extrema2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        extrema2[n++] = t2;
      }
    }
  }
  return n;
}
function cubicSubdivide(p0, p1, p2, p3, t, out2) {
  const p01 = (p1 - p0) * t + p0;
  const p12 = (p2 - p1) * t + p1;
  const p23 = (p3 - p2) * t + p2;
  const p012 = (p12 - p01) * t + p01;
  const p123 = (p23 - p12) * t + p12;
  const p0123 = (p123 - p012) * t + p012;
  out2[0] = p0;
  out2[1] = p01;
  out2[2] = p012;
  out2[3] = p0123;
  out2[4] = p0123;
  out2[5] = p123;
  out2[6] = p23;
  out2[7] = p3;
}
function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out2) {
  let t;
  let interval = 5e-3;
  let d = Infinity;
  let prev;
  let next;
  let d1;
  let d2;
  _v0[0] = x;
  _v0[1] = y;
  for (let _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = cubicAt(x0, x1, x2, x3, _t);
    _v1[1] = cubicAt(y0, y1, y2, y3, _t);
    d1 = distSquare(_v0, _v1);
    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }
  d = Infinity;
  for (let i = 0; i < 32; i++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }
    prev = t - interval;
    next = t + interval;
    _v1[0] = cubicAt(x0, x1, x2, x3, prev);
    _v1[1] = cubicAt(y0, y1, y2, y3, prev);
    d1 = distSquare(_v1, _v0);
    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      _v2[0] = cubicAt(x0, x1, x2, x3, next);
      _v2[1] = cubicAt(y0, y1, y2, y3, next);
      d2 = distSquare(_v2, _v0);
      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval *= 0.5;
      }
    }
  }
  if (out2) {
    out2[0] = cubicAt(x0, x1, x2, x3, t);
    out2[1] = cubicAt(y0, y1, y2, y3, t);
  }
  return mathSqrt(d);
}
function cubicLength(x0, y0, x1, y1, x2, y2, x3, y3, iteration) {
  let px = x0;
  let py = y0;
  let d = 0;
  const step = 1 / iteration;
  for (let i = 1; i <= iteration; i++) {
    let t = i * step;
    const x = cubicAt(x0, x1, x2, x3, t);
    const y = cubicAt(y0, y1, y2, y3, t);
    const dx = x - px;
    const dy = y - py;
    d += Math.sqrt(dx * dx + dy * dy);
    px = x;
    py = y;
  }
  return d;
}
function quadraticAt(p0, p1, p2, t) {
  const onet = 1 - t;
  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
}
function quadraticDerivativeAt(p0, p1, p2, t) {
  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
}
function quadraticRootAt(p0, p1, p2, val, roots2) {
  const a = p0 - 2 * p1 + p2;
  const b = 2 * (p1 - p0);
  const c = p0 - val;
  let n = 0;
  if (isAroundZero(a)) {
    if (isNotAroundZero(b)) {
      const t1 = -c / b;
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    }
  } else {
    const disc = b * b - 4 * a * c;
    if (isAroundZero(disc)) {
      const t1 = -b / (2 * a);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
    } else if (disc > 0) {
      const discSqrt = mathSqrt(disc);
      const t1 = (-b + discSqrt) / (2 * a);
      const t2 = (-b - discSqrt) / (2 * a);
      if (t1 >= 0 && t1 <= 1) {
        roots2[n++] = t1;
      }
      if (t2 >= 0 && t2 <= 1) {
        roots2[n++] = t2;
      }
    }
  }
  return n;
}
function quadraticExtremum(p0, p1, p2) {
  const divider = p0 + p2 - 2 * p1;
  if (divider === 0) {
    return 0.5;
  } else {
    return (p0 - p1) / divider;
  }
}
function quadraticSubdivide(p0, p1, p2, t, out2) {
  const p01 = (p1 - p0) * t + p0;
  const p12 = (p2 - p1) * t + p1;
  const p012 = (p12 - p01) * t + p01;
  out2[0] = p0;
  out2[1] = p01;
  out2[2] = p012;
  out2[3] = p012;
  out2[4] = p12;
  out2[5] = p2;
}
function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out2) {
  let t;
  let interval = 5e-3;
  let d = Infinity;
  _v0[0] = x;
  _v0[1] = y;
  for (let _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = quadraticAt(x0, x1, x2, _t);
    _v1[1] = quadraticAt(y0, y1, y2, _t);
    const d1 = distSquare(_v0, _v1);
    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }
  d = Infinity;
  for (let i = 0; i < 32; i++) {
    if (interval < EPSILON_NUMERIC) {
      break;
    }
    const prev = t - interval;
    const next = t + interval;
    _v1[0] = quadraticAt(x0, x1, x2, prev);
    _v1[1] = quadraticAt(y0, y1, y2, prev);
    const d1 = distSquare(_v1, _v0);
    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      _v2[0] = quadraticAt(x0, x1, x2, next);
      _v2[1] = quadraticAt(y0, y1, y2, next);
      const d2 = distSquare(_v2, _v0);
      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval *= 0.5;
      }
    }
  }
  if (out2) {
    out2[0] = quadraticAt(x0, x1, x2, t);
    out2[1] = quadraticAt(y0, y1, y2, t);
  }
  return mathSqrt(d);
}
function quadraticLength(x0, y0, x1, y1, x2, y2, iteration) {
  let px = x0;
  let py = y0;
  let d = 0;
  const step = 1 / iteration;
  for (let i = 1; i <= iteration; i++) {
    let t = i * step;
    const x = quadraticAt(x0, x1, x2, t);
    const y = quadraticAt(y0, y1, y2, t);
    const dx = x - px;
    const dy = y - py;
    d += Math.sqrt(dx * dx + dy * dy);
    px = x;
    py = y;
  }
  return d;
}

// node_modules/zrender/src/animation/cubicEasing.ts
var regexp = /cubic-bezier\(([0-9,\.e ]+)\)/;
function createCubicEasingFunc(cubicEasingStr) {
  const cubic2 = cubicEasingStr && regexp.exec(cubicEasingStr);
  if (cubic2) {
    const points4 = cubic2[1].split(",");
    const a = +trim(points4[0]);
    const b = +trim(points4[1]);
    const c = +trim(points4[2]);
    const d = +trim(points4[3]);
    if (isNaN(a + b + c + d)) {
      return;
    }
    const roots2 = [];
    return (p) => {
      return p <= 0 ? 0 : p >= 1 ? 1 : cubicRootAt(0, a, c, 1, p, roots2) && cubicAt(0, b, d, 1, roots2[0]);
    };
  }
}

// node_modules/zrender/src/animation/Clip.ts
var Clip = class {
  constructor(opts) {
    this._inited = false;
    this._startTime = 0;
    this._pausedTime = 0;
    this._paused = false;
    this._life = opts.life || 1e3;
    this._delay = opts.delay || 0;
    this.loop = opts.loop || false;
    this.onframe = opts.onframe || noop;
    this.ondestroy = opts.ondestroy || noop;
    this.onrestart = opts.onrestart || noop;
    opts.easing && this.setEasing(opts.easing);
  }
  step(globalTime, deltaTime) {
    if (!this._inited) {
      this._startTime = globalTime + this._delay;
      this._inited = true;
    }
    if (this._paused) {
      this._pausedTime += deltaTime;
      return;
    }
    const life = this._life;
    let elapsedTime = globalTime - this._startTime - this._pausedTime;
    let percent = elapsedTime / life;
    if (percent < 0) {
      percent = 0;
    }
    percent = Math.min(percent, 1);
    const easingFunc = this.easingFunc;
    const schedule = easingFunc ? easingFunc(percent) : percent;
    this.onframe(schedule);
    if (percent === 1) {
      if (this.loop) {
        const remainder = elapsedTime % life;
        this._startTime = globalTime - remainder;
        this._pausedTime = 0;
        this.onrestart();
      } else {
        return true;
      }
    }
    return false;
  }
  pause() {
    this._paused = true;
  }
  resume() {
    this._paused = false;
  }
  setEasing(easing) {
    this.easing = easing;
    this.easingFunc = isFunction(easing) ? easing : easing_default[easing] || createCubicEasingFunc(easing);
  }
};
var Clip_default = Clip;

// node_modules/zrender/src/tool/color.ts
var color_exports = {};
__export(color_exports, {
  fastLerp: () => fastLerp,
  fastMapToColor: () => fastMapToColor,
  lerp: () => lerp2,
  lift: () => lift,
  liftColor: () => liftColor,
  lum: () => lum,
  mapToColor: () => mapToColor,
  modifyAlpha: () => modifyAlpha,
  modifyHSL: () => modifyHSL,
  parse: () => parse,
  random: () => random,
  stringify: () => stringify,
  toHex: () => toHex
});

// node_modules/zrender/src/core/LRU.ts
var Entry = class {
  constructor(val) {
    this.value = val;
  }
};
var LinkedList = class {
  constructor() {
    this._len = 0;
  }
  insert(val) {
    const entry = new Entry(val);
    this.insertEntry(entry);
    return entry;
  }
  insertEntry(entry) {
    if (!this.head) {
      this.head = this.tail = entry;
    } else {
      this.tail.next = entry;
      entry.prev = this.tail;
      entry.next = null;
      this.tail = entry;
    }
    this._len++;
  }
  remove(entry) {
    const prev = entry.prev;
    const next = entry.next;
    if (prev) {
      prev.next = next;
    } else {
      this.head = next;
    }
    if (next) {
      next.prev = prev;
    } else {
      this.tail = prev;
    }
    entry.next = entry.prev = null;
    this._len--;
  }
  len() {
    return this._len;
  }
  clear() {
    this.head = this.tail = null;
    this._len = 0;
  }
};
var LRU = class {
  constructor(maxSize) {
    this._list = new LinkedList();
    this._maxSize = 10;
    this._map = {};
    this._maxSize = maxSize;
  }
  put(key, value) {
    const list = this._list;
    const map3 = this._map;
    let removed = null;
    if (map3[key] == null) {
      const len2 = list.len();
      let entry = this._lastRemovedEntry;
      if (len2 >= this._maxSize && len2 > 0) {
        const leastUsedEntry = list.head;
        list.remove(leastUsedEntry);
        delete map3[leastUsedEntry.key];
        removed = leastUsedEntry.value;
        this._lastRemovedEntry = leastUsedEntry;
      }
      if (entry) {
        entry.value = value;
      } else {
        entry = new Entry(value);
      }
      entry.key = key;
      list.insertEntry(entry);
      map3[key] = entry;
    }
    return removed;
  }
  get(key) {
    const entry = this._map[key];
    const list = this._list;
    if (entry != null) {
      if (entry !== list.tail) {
        list.remove(entry);
        list.insertEntry(entry);
      }
      return entry.value;
    }
  }
  clear() {
    this._list.clear();
    this._map = {};
  }
  len() {
    return this._list.len();
  }
};
var LRU_default = LRU;

// node_modules/zrender/src/tool/color.ts
var kCSSColorTable = {
  transparent: [0, 0, 0, 0],
  aliceblue: [240, 248, 255, 1],
  antiquewhite: [250, 235, 215, 1],
  aqua: [0, 255, 255, 1],
  aquamarine: [127, 255, 212, 1],
  azure: [240, 255, 255, 1],
  beige: [245, 245, 220, 1],
  bisque: [255, 228, 196, 1],
  black: [0, 0, 0, 1],
  blanchedalmond: [255, 235, 205, 1],
  blue: [0, 0, 255, 1],
  blueviolet: [138, 43, 226, 1],
  brown: [165, 42, 42, 1],
  burlywood: [222, 184, 135, 1],
  cadetblue: [95, 158, 160, 1],
  chartreuse: [127, 255, 0, 1],
  chocolate: [210, 105, 30, 1],
  coral: [255, 127, 80, 1],
  cornflowerblue: [100, 149, 237, 1],
  cornsilk: [255, 248, 220, 1],
  crimson: [220, 20, 60, 1],
  cyan: [0, 255, 255, 1],
  darkblue: [0, 0, 139, 1],
  darkcyan: [0, 139, 139, 1],
  darkgoldenrod: [184, 134, 11, 1],
  darkgray: [169, 169, 169, 1],
  darkgreen: [0, 100, 0, 1],
  darkgrey: [169, 169, 169, 1],
  darkkhaki: [189, 183, 107, 1],
  darkmagenta: [139, 0, 139, 1],
  darkolivegreen: [85, 107, 47, 1],
  darkorange: [255, 140, 0, 1],
  darkorchid: [153, 50, 204, 1],
  darkred: [139, 0, 0, 1],
  darksalmon: [233, 150, 122, 1],
  darkseagreen: [143, 188, 143, 1],
  darkslateblue: [72, 61, 139, 1],
  darkslategray: [47, 79, 79, 1],
  darkslategrey: [47, 79, 79, 1],
  darkturquoise: [0, 206, 209, 1],
  darkviolet: [148, 0, 211, 1],
  deeppink: [255, 20, 147, 1],
  deepskyblue: [0, 191, 255, 1],
  dimgray: [105, 105, 105, 1],
  dimgrey: [105, 105, 105, 1],
  dodgerblue: [30, 144, 255, 1],
  firebrick: [178, 34, 34, 1],
  floralwhite: [255, 250, 240, 1],
  forestgreen: [34, 139, 34, 1],
  fuchsia: [255, 0, 255, 1],
  gainsboro: [220, 220, 220, 1],
  ghostwhite: [248, 248, 255, 1],
  gold: [255, 215, 0, 1],
  goldenrod: [218, 165, 32, 1],
  gray: [128, 128, 128, 1],
  green: [0, 128, 0, 1],
  greenyellow: [173, 255, 47, 1],
  grey: [128, 128, 128, 1],
  honeydew: [240, 255, 240, 1],
  hotpink: [255, 105, 180, 1],
  indianred: [205, 92, 92, 1],
  indigo: [75, 0, 130, 1],
  ivory: [255, 255, 240, 1],
  khaki: [240, 230, 140, 1],
  lavender: [230, 230, 250, 1],
  lavenderblush: [255, 240, 245, 1],
  lawngreen: [124, 252, 0, 1],
  lemonchiffon: [255, 250, 205, 1],
  lightblue: [173, 216, 230, 1],
  lightcoral: [240, 128, 128, 1],
  lightcyan: [224, 255, 255, 1],
  lightgoldenrodyellow: [250, 250, 210, 1],
  lightgray: [211, 211, 211, 1],
  lightgreen: [144, 238, 144, 1],
  lightgrey: [211, 211, 211, 1],
  lightpink: [255, 182, 193, 1],
  lightsalmon: [255, 160, 122, 1],
  lightseagreen: [32, 178, 170, 1],
  lightskyblue: [135, 206, 250, 1],
  lightslategray: [119, 136, 153, 1],
  lightslategrey: [119, 136, 153, 1],
  lightsteelblue: [176, 196, 222, 1],
  lightyellow: [255, 255, 224, 1],
  lime: [0, 255, 0, 1],
  limegreen: [50, 205, 50, 1],
  linen: [250, 240, 230, 1],
  magenta: [255, 0, 255, 1],
  maroon: [128, 0, 0, 1],
  mediumaquamarine: [102, 205, 170, 1],
  mediumblue: [0, 0, 205, 1],
  mediumorchid: [186, 85, 211, 1],
  mediumpurple: [147, 112, 219, 1],
  mediumseagreen: [60, 179, 113, 1],
  mediumslateblue: [123, 104, 238, 1],
  mediumspringgreen: [0, 250, 154, 1],
  mediumturquoise: [72, 209, 204, 1],
  mediumvioletred: [199, 21, 133, 1],
  midnightblue: [25, 25, 112, 1],
  mintcream: [245, 255, 250, 1],
  mistyrose: [255, 228, 225, 1],
  moccasin: [255, 228, 181, 1],
  navajowhite: [255, 222, 173, 1],
  navy: [0, 0, 128, 1],
  oldlace: [253, 245, 230, 1],
  olive: [128, 128, 0, 1],
  olivedrab: [107, 142, 35, 1],
  orange: [255, 165, 0, 1],
  orangered: [255, 69, 0, 1],
  orchid: [218, 112, 214, 1],
  palegoldenrod: [238, 232, 170, 1],
  palegreen: [152, 251, 152, 1],
  paleturquoise: [175, 238, 238, 1],
  palevioletred: [219, 112, 147, 1],
  papayawhip: [255, 239, 213, 1],
  peachpuff: [255, 218, 185, 1],
  peru: [205, 133, 63, 1],
  pink: [255, 192, 203, 1],
  plum: [221, 160, 221, 1],
  powderblue: [176, 224, 230, 1],
  purple: [128, 0, 128, 1],
  red: [255, 0, 0, 1],
  rosybrown: [188, 143, 143, 1],
  royalblue: [65, 105, 225, 1],
  saddlebrown: [139, 69, 19, 1],
  salmon: [250, 128, 114, 1],
  sandybrown: [244, 164, 96, 1],
  seagreen: [46, 139, 87, 1],
  seashell: [255, 245, 238, 1],
  sienna: [160, 82, 45, 1],
  silver: [192, 192, 192, 1],
  skyblue: [135, 206, 235, 1],
  slateblue: [106, 90, 205, 1],
  slategray: [112, 128, 144, 1],
  slategrey: [112, 128, 144, 1],
  snow: [255, 250, 250, 1],
  springgreen: [0, 255, 127, 1],
  steelblue: [70, 130, 180, 1],
  tan: [210, 180, 140, 1],
  teal: [0, 128, 128, 1],
  thistle: [216, 191, 216, 1],
  tomato: [255, 99, 71, 1],
  turquoise: [64, 224, 208, 1],
  violet: [238, 130, 238, 1],
  wheat: [245, 222, 179, 1],
  white: [255, 255, 255, 1],
  whitesmoke: [245, 245, 245, 1],
  yellow: [255, 255, 0, 1],
  yellowgreen: [154, 205, 50, 1]
};
function clampCssByte(i) {
  i = Math.round(i);
  return i < 0 ? 0 : i > 255 ? 255 : i;
}
function clampCssAngle(i) {
  i = Math.round(i);
  return i < 0 ? 0 : i > 360 ? 360 : i;
}
function clampCssFloat(f) {
  return f < 0 ? 0 : f > 1 ? 1 : f;
}
function parseCssInt(val) {
  let str = val;
  if (str.length && str.charAt(str.length - 1) === "%") {
    return clampCssByte(parseFloat(str) / 100 * 255);
  }
  return clampCssByte(parseInt(str, 10));
}
function parseCssFloat(val) {
  let str = val;
  if (str.length && str.charAt(str.length - 1) === "%") {
    return clampCssFloat(parseFloat(str) / 100);
  }
  return clampCssFloat(parseFloat(str));
}
function cssHueToRgb(m1, m2, h) {
  if (h < 0) {
    h += 1;
  } else if (h > 1) {
    h -= 1;
  }
  if (h * 6 < 1) {
    return m1 + (m2 - m1) * h * 6;
  }
  if (h * 2 < 1) {
    return m2;
  }
  if (h * 3 < 2) {
    return m1 + (m2 - m1) * (2 / 3 - h) * 6;
  }
  return m1;
}
function lerpNumber(a, b, p) {
  return a + (b - a) * p;
}
function setRgba(out2, r, g, b, a) {
  out2[0] = r;
  out2[1] = g;
  out2[2] = b;
  out2[3] = a;
  return out2;
}
function copyRgba(out2, a) {
  out2[0] = a[0];
  out2[1] = a[1];
  out2[2] = a[2];
  out2[3] = a[3];
  return out2;
}
var colorCache = new LRU_default(20);
var lastRemovedArr = null;
function putToCache(colorStr, rgbaArr) {
  if (lastRemovedArr) {
    copyRgba(lastRemovedArr, rgbaArr);
  }
  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());
}
function parse(colorStr, rgbaArr) {
  if (!colorStr) {
    return;
  }
  rgbaArr = rgbaArr || [];
  let cached = colorCache.get(colorStr);
  if (cached) {
    return copyRgba(rgbaArr, cached);
  }
  colorStr = colorStr + "";
  let str = colorStr.replace(/ /g, "").toLowerCase();
  if (str in kCSSColorTable) {
    copyRgba(rgbaArr, kCSSColorTable[str]);
    putToCache(colorStr, rgbaArr);
    return rgbaArr;
  }
  const strLen = str.length;
  if (str.charAt(0) === "#") {
    if (strLen === 4 || strLen === 5) {
      const iv = parseInt(str.slice(1, 4), 16);
      if (!(iv >= 0 && iv <= 4095)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return;
      }
      setRgba(rgbaArr, (iv & 3840) >> 4 | (iv & 3840) >> 8, iv & 240 | (iv & 240) >> 4, iv & 15 | (iv & 15) << 4, strLen === 5 ? parseInt(str.slice(4), 16) / 15 : 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    } else if (strLen === 7 || strLen === 9) {
      const iv = parseInt(str.slice(1, 7), 16);
      if (!(iv >= 0 && iv <= 16777215)) {
        setRgba(rgbaArr, 0, 0, 0, 1);
        return;
      }
      setRgba(rgbaArr, (iv & 16711680) >> 16, (iv & 65280) >> 8, iv & 255, strLen === 9 ? parseInt(str.slice(7), 16) / 255 : 1);
      putToCache(colorStr, rgbaArr);
      return rgbaArr;
    }
    return;
  }
  let op = str.indexOf("(");
  let ep = str.indexOf(")");
  if (op !== -1 && ep + 1 === strLen) {
    let fname = str.substr(0, op);
    let params = str.substr(op + 1, ep - (op + 1)).split(",");
    let alpha = 1;
    switch (fname) {
      case "rgba":
        if (params.length !== 4) {
          return params.length === 3 ? setRgba(rgbaArr, +params[0], +params[1], +params[2], 1) : setRgba(rgbaArr, 0, 0, 0, 1);
        }
        alpha = parseCssFloat(params.pop());
      case "rgb":
        if (params.length >= 3) {
          setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), params.length === 3 ? alpha : parseCssFloat(params[3]));
          putToCache(colorStr, rgbaArr);
          return rgbaArr;
        } else {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
      case "hsla":
        if (params.length !== 4) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        params[3] = parseCssFloat(params[3]);
        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      case "hsl":
        if (params.length !== 3) {
          setRgba(rgbaArr, 0, 0, 0, 1);
          return;
        }
        hsla2rgba(params, rgbaArr);
        putToCache(colorStr, rgbaArr);
        return rgbaArr;
      default:
        return;
    }
  }
  setRgba(rgbaArr, 0, 0, 0, 1);
  return;
}
function hsla2rgba(hsla, rgba) {
  const h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;
  const s = parseCssFloat(hsla[1]);
  const l = parseCssFloat(hsla[2]);
  const m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
  const m1 = l * 2 - m2;
  rgba = rgba || [];
  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);
  if (hsla.length === 4) {
    rgba[3] = hsla[3];
  }
  return rgba;
}
function rgba2hsla(rgba) {
  if (!rgba) {
    return;
  }
  const R = rgba[0] / 255;
  const G = rgba[1] / 255;
  const B = rgba[2] / 255;
  const vMin = Math.min(R, G, B);
  const vMax = Math.max(R, G, B);
  const delta = vMax - vMin;
  const L = (vMax + vMin) / 2;
  let H;
  let S;
  if (delta === 0) {
    H = 0;
    S = 0;
  } else {
    if (L < 0.5) {
      S = delta / (vMax + vMin);
    } else {
      S = delta / (2 - vMax - vMin);
    }
    const deltaR = ((vMax - R) / 6 + delta / 2) / delta;
    const deltaG = ((vMax - G) / 6 + delta / 2) / delta;
    const deltaB = ((vMax - B) / 6 + delta / 2) / delta;
    if (R === vMax) {
      H = deltaB - deltaG;
    } else if (G === vMax) {
      H = 1 / 3 + deltaR - deltaB;
    } else if (B === vMax) {
      H = 2 / 3 + deltaG - deltaR;
    }
    if (H < 0) {
      H += 1;
    }
    if (H > 1) {
      H -= 1;
    }
  }
  const hsla = [H * 360, S, L];
  if (rgba[3] != null) {
    hsla.push(rgba[3]);
  }
  return hsla;
}
function lift(color2, level) {
  const colorArr = parse(color2);
  if (colorArr) {
    for (let i = 0; i < 3; i++) {
      if (level < 0) {
        colorArr[i] = colorArr[i] * (1 - level) | 0;
      } else {
        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
      }
      if (colorArr[i] > 255) {
        colorArr[i] = 255;
      } else if (colorArr[i] < 0) {
        colorArr[i] = 0;
      }
    }
    return stringify(colorArr, colorArr.length === 4 ? "rgba" : "rgb");
  }
}
function toHex(color2) {
  const colorArr = parse(color2);
  if (colorArr) {
    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
  }
}
function fastLerp(normalizedValue, colors, out2) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }
  out2 = out2 || [];
  const value = normalizedValue * (colors.length - 1);
  const leftIndex = Math.floor(value);
  const rightIndex = Math.ceil(value);
  const leftColor = colors[leftIndex];
  const rightColor = colors[rightIndex];
  const dv = value - leftIndex;
  out2[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
  out2[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
  out2[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
  out2[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
  return out2;
}
var fastMapToColor = fastLerp;
function lerp2(normalizedValue, colors, fullOutput) {
  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
    return;
  }
  const value = normalizedValue * (colors.length - 1);
  const leftIndex = Math.floor(value);
  const rightIndex = Math.ceil(value);
  const leftColor = parse(colors[leftIndex]);
  const rightColor = parse(colors[rightIndex]);
  const dv = value - leftIndex;
  const color2 = stringify([
    clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),
    clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),
    clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),
    clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))
  ], "rgba");
  return fullOutput ? {
    color: color2,
    leftIndex,
    rightIndex,
    value
  } : color2;
}
var mapToColor = lerp2;
function modifyHSL(color2, h, s, l) {
  let colorArr = parse(color2);
  if (color2) {
    colorArr = rgba2hsla(colorArr);
    h != null && (colorArr[0] = clampCssAngle(h));
    s != null && (colorArr[1] = parseCssFloat(s));
    l != null && (colorArr[2] = parseCssFloat(l));
    return stringify(hsla2rgba(colorArr), "rgba");
  }
}
function modifyAlpha(color2, alpha) {
  const colorArr = parse(color2);
  if (colorArr && alpha != null) {
    colorArr[3] = clampCssFloat(alpha);
    return stringify(colorArr, "rgba");
  }
}
function stringify(arrColor, type) {
  if (!arrColor || !arrColor.length) {
    return;
  }
  let colorStr = arrColor[0] + "," + arrColor[1] + "," + arrColor[2];
  if (type === "rgba" || type === "hsva" || type === "hsla") {
    colorStr += "," + arrColor[3];
  }
  return type + "(" + colorStr + ")";
}
function lum(color2, backgroundLum) {
  const arr = parse(color2);
  return arr ? (0.299 * arr[0] + 0.587 * arr[1] + 0.114 * arr[2]) * arr[3] / 255 + (1 - arr[3]) * backgroundLum : 0;
}
function random() {
  return stringify([
    Math.round(Math.random() * 255),
    Math.round(Math.random() * 255),
    Math.round(Math.random() * 255)
  ], "rgb");
}
var liftedColorCache = new LRU_default(100);
function liftColor(color2) {
  if (isString(color2)) {
    let liftedColor = liftedColorCache.get(color2);
    if (!liftedColor) {
      liftedColor = lift(color2, -0.1);
      liftedColorCache.put(color2, liftedColor);
    }
    return liftedColor;
  } else if (isGradientObject(color2)) {
    const ret = extend({}, color2);
    ret.colorStops = map(color2.colorStops, (stop2) => ({
      offset: stop2.offset,
      color: lift(stop2.color, -0.1)
    }));
    return ret;
  }
  return color2;
}

// node_modules/zrender/src/svg/helper.ts
var mathRound = Math.round;
function normalizeColor(color2) {
  let opacity;
  if (!color2 || color2 === "transparent") {
    color2 = "none";
  } else if (typeof color2 === "string" && color2.indexOf("rgba") > -1) {
    const arr = parse(color2);
    if (arr) {
      color2 = "rgb(" + arr[0] + "," + arr[1] + "," + arr[2] + ")";
      opacity = arr[3];
    }
  }
  return {
    color: color2,
    opacity: opacity == null ? 1 : opacity
  };
}
var EPSILON2 = 1e-4;
function isAroundZero2(transform2) {
  return transform2 < EPSILON2 && transform2 > -EPSILON2;
}
function round3(transform2) {
  return mathRound(transform2 * 1e3) / 1e3;
}
function round4(transform2) {
  return mathRound(transform2 * 1e4) / 1e4;
}
function getMatrixStr(m2) {
  return "matrix(" + round3(m2[0]) + "," + round3(m2[1]) + "," + round3(m2[2]) + "," + round3(m2[3]) + "," + round4(m2[4]) + "," + round4(m2[5]) + ")";
}
var TEXT_ALIGN_TO_ANCHOR = {
  left: "start",
  right: "end",
  center: "middle",
  middle: "middle"
};
function adjustTextY(y, lineHeight, textBaseline) {
  if (textBaseline === "top") {
    y += lineHeight / 2;
  } else if (textBaseline === "bottom") {
    y -= lineHeight / 2;
  }
  return y;
}
function hasShadow(style) {
  return style && (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY);
}
function getShadowKey(displayable) {
  const style = displayable.style;
  const globalScale = displayable.getGlobalScale();
  return [
    style.shadowColor,
    (style.shadowBlur || 0).toFixed(2),
    (style.shadowOffsetX || 0).toFixed(2),
    (style.shadowOffsetY || 0).toFixed(2),
    globalScale[0],
    globalScale[1]
  ].join(",");
}
function isImagePattern(val) {
  return val && !!val.image;
}
function isSVGPattern(val) {
  return val && !!val.svgElement;
}
function isPattern(val) {
  return isImagePattern(val) || isSVGPattern(val);
}
function isLinearGradient(val) {
  return val.type === "linear";
}
function isRadialGradient(val) {
  return val.type === "radial";
}
function isGradient(val) {
  return val && (val.type === "linear" || val.type === "radial");
}
function getIdURL(id) {
  return `url(#${id})`;
}
function getPathPrecision(el) {
  const scale4 = el.getGlobalScale();
  const size = Math.max(scale4[0], scale4[1]);
  return Math.max(Math.ceil(Math.log(size) / Math.log(10)), 1);
}
function getSRTTransformString(transform2) {
  const x = transform2.x || 0;
  const y = transform2.y || 0;
  const rotation = (transform2.rotation || 0) * RADIAN_TO_DEGREE;
  const scaleX = retrieve2(transform2.scaleX, 1);
  const scaleY = retrieve2(transform2.scaleY, 1);
  const skewX = transform2.skewX || 0;
  const skewY = transform2.skewY || 0;
  const res = [];
  if (x || y) {
    res.push(`translate(${x}px,${y}px)`);
  }
  if (rotation) {
    res.push(`rotate(${rotation})`);
  }
  if (scaleX !== 1 || scaleY !== 1) {
    res.push(`scale(${scaleX},${scaleY})`);
  }
  if (skewX || skewY) {
    res.push(`skew(${mathRound(skewX * RADIAN_TO_DEGREE)}deg, ${mathRound(skewY * RADIAN_TO_DEGREE)}deg)`);
  }
  return res.join(" ");
}
var encodeBase64 = function() {
  if (env_default.hasGlobalWindow && isFunction(window.btoa)) {
    return function(str) {
      return window.btoa(unescape(encodeURIComponent(str)));
    };
  }
  if (typeof Buffer !== "undefined") {
    return function(str) {
      return Buffer.from(str).toString("base64");
    };
  }
  return function(str) {
    if (true) {
      logError("Base64 isn't natively supported in the current environment.");
    }
    return null;
  };
}();

// node_modules/zrender/src/animation/Animator.ts
var arraySlice = Array.prototype.slice;
function interpolateNumber(p0, p1, percent) {
  return (p1 - p0) * percent + p0;
}
function interpolate1DArray(out2, p0, p1, percent) {
  const len2 = p0.length;
  for (let i = 0; i < len2; i++) {
    out2[i] = interpolateNumber(p0[i], p1[i], percent);
  }
  return out2;
}
function interpolate2DArray(out2, p0, p1, percent) {
  const len2 = p0.length;
  const len22 = len2 && p0[0].length;
  for (let i = 0; i < len2; i++) {
    if (!out2[i]) {
      out2[i] = [];
    }
    for (let j = 0; j < len22; j++) {
      out2[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
    }
  }
  return out2;
}
function add1DArray(out2, p0, p1, sign) {
  const len2 = p0.length;
  for (let i = 0; i < len2; i++) {
    out2[i] = p0[i] + p1[i] * sign;
  }
  return out2;
}
function add2DArray(out2, p0, p1, sign) {
  const len2 = p0.length;
  const len22 = len2 && p0[0].length;
  for (let i = 0; i < len2; i++) {
    if (!out2[i]) {
      out2[i] = [];
    }
    for (let j = 0; j < len22; j++) {
      out2[i][j] = p0[i][j] + p1[i][j] * sign;
    }
  }
  return out2;
}
function fillColorStops(val0, val1) {
  const len0 = val0.length;
  const len1 = val1.length;
  const shorterArr = len0 > len1 ? val1 : val0;
  const shorterLen = Math.min(len0, len1);
  const last = shorterArr[shorterLen - 1] || {color: [0, 0, 0, 0], offset: 0};
  for (let i = shorterLen; i < Math.max(len0, len1); i++) {
    shorterArr.push({
      offset: last.offset,
      color: last.color.slice()
    });
  }
}
function fillArray(val0, val1, arrDim) {
  let arr0 = val0;
  let arr1 = val1;
  if (!arr0.push || !arr1.push) {
    return;
  }
  const arr0Len = arr0.length;
  const arr1Len = arr1.length;
  if (arr0Len !== arr1Len) {
    const isPreviousLarger = arr0Len > arr1Len;
    if (isPreviousLarger) {
      arr0.length = arr1Len;
    } else {
      for (let i = arr0Len; i < arr1Len; i++) {
        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
      }
    }
  }
  const len2 = arr0[0] && arr0[0].length;
  for (let i = 0; i < arr0.length; i++) {
    if (arrDim === 1) {
      if (isNaN(arr0[i])) {
        arr0[i] = arr1[i];
      }
    } else {
      for (let j = 0; j < len2; j++) {
        if (isNaN(arr0[i][j])) {
          arr0[i][j] = arr1[i][j];
        }
      }
    }
  }
}
function cloneValue(value) {
  if (isArrayLike(value)) {
    const len2 = value.length;
    if (isArrayLike(value[0])) {
      const ret = [];
      for (let i = 0; i < len2; i++) {
        ret.push(arraySlice.call(value[i]));
      }
      return ret;
    }
    return arraySlice.call(value);
  }
  return value;
}
function rgba2String(rgba) {
  rgba[0] = Math.floor(rgba[0]) || 0;
  rgba[1] = Math.floor(rgba[1]) || 0;
  rgba[2] = Math.floor(rgba[2]) || 0;
  rgba[3] = rgba[3] == null ? 1 : rgba[3];
  return "rgba(" + rgba.join(",") + ")";
}
function guessArrayDim(value) {
  return isArrayLike(value && value[0]) ? 2 : 1;
}
var VALUE_TYPE_NUMBER = 0;
var VALUE_TYPE_1D_ARRAY = 1;
var VALUE_TYPE_2D_ARRAY = 2;
var VALUE_TYPE_COLOR = 3;
var VALUE_TYPE_LINEAR_GRADIENT = 4;
var VALUE_TYPE_RADIAL_GRADIENT = 5;
var VALUE_TYPE_UNKOWN = 6;
function isGradientValueType(valType) {
  return valType === VALUE_TYPE_LINEAR_GRADIENT || valType === VALUE_TYPE_RADIAL_GRADIENT;
}
function isArrayValueType(valType) {
  return valType === VALUE_TYPE_1D_ARRAY || valType === VALUE_TYPE_2D_ARRAY;
}
var tmpRgba = [0, 0, 0, 0];
var Track = class {
  constructor(propName) {
    this.keyframes = [];
    this.discrete = false;
    this._invalid = false;
    this._needsSort = false;
    this._lastFr = 0;
    this._lastFrP = 0;
    this.propName = propName;
  }
  isFinished() {
    return this._finished;
  }
  setFinished() {
    this._finished = true;
    if (this._additiveTrack) {
      this._additiveTrack.setFinished();
    }
  }
  needsAnimate() {
    return this.keyframes.length >= 1;
  }
  getAdditiveTrack() {
    return this._additiveTrack;
  }
  addKeyframe(time, rawValue, easing) {
    this._needsSort = true;
    let keyframes = this.keyframes;
    let len2 = keyframes.length;
    let discrete = false;
    let valType = VALUE_TYPE_UNKOWN;
    let value = rawValue;
    if (isArrayLike(rawValue)) {
      let arrayDim = guessArrayDim(rawValue);
      valType = arrayDim;
      if (arrayDim === 1 && !isNumber(rawValue[0]) || arrayDim === 2 && !isNumber(rawValue[0][0])) {
        discrete = true;
      }
    } else {
      if (isNumber(rawValue) && !eqNaN(rawValue)) {
        valType = VALUE_TYPE_NUMBER;
      } else if (isString(rawValue)) {
        if (!isNaN(+rawValue)) {
          valType = VALUE_TYPE_NUMBER;
        } else {
          const colorArray = parse(rawValue);
          if (colorArray) {
            value = colorArray;
            valType = VALUE_TYPE_COLOR;
          }
        }
      } else if (isGradientObject(rawValue)) {
        const parsedGradient = extend({}, value);
        parsedGradient.colorStops = map(rawValue.colorStops, (colorStop) => ({
          offset: colorStop.offset,
          color: parse(colorStop.color)
        }));
        if (isLinearGradient(rawValue)) {
          valType = VALUE_TYPE_LINEAR_GRADIENT;
        } else if (isRadialGradient(rawValue)) {
          valType = VALUE_TYPE_RADIAL_GRADIENT;
        }
        value = parsedGradient;
      }
    }
    if (len2 === 0) {
      this.valType = valType;
    } else if (valType !== this.valType || valType === VALUE_TYPE_UNKOWN) {
      discrete = true;
    }
    this.discrete = this.discrete || discrete;
    const kf = {
      time,
      value,
      rawValue,
      percent: 0
    };
    if (easing) {
      kf.easing = easing;
      kf.easingFunc = isFunction(easing) ? easing : easing_default[easing] || createCubicEasingFunc(easing);
    }
    keyframes.push(kf);
    return kf;
  }
  prepare(maxTime, additiveTrack) {
    let kfs = this.keyframes;
    if (this._needsSort) {
      kfs.sort(function(a, b) {
        return a.time - b.time;
      });
    }
    const valType = this.valType;
    const kfsLen = kfs.length;
    const lastKf = kfs[kfsLen - 1];
    const isDiscrete = this.discrete;
    const isArr = isArrayValueType(valType);
    const isGradient2 = isGradientValueType(valType);
    for (let i = 0; i < kfsLen; i++) {
      const kf = kfs[i];
      const value = kf.value;
      const lastValue = lastKf.value;
      kf.percent = kf.time / maxTime;
      if (!isDiscrete) {
        if (isArr && i !== kfsLen - 1) {
          fillArray(value, lastValue, valType);
        } else if (isGradient2) {
          fillColorStops(value.colorStops, lastValue.colorStops);
        }
      }
    }
    if (!isDiscrete && valType !== VALUE_TYPE_RADIAL_GRADIENT && additiveTrack && this.needsAnimate() && additiveTrack.needsAnimate() && valType === additiveTrack.valType && !additiveTrack._finished) {
      this._additiveTrack = additiveTrack;
      const startValue = kfs[0].value;
      for (let i = 0; i < kfsLen; i++) {
        if (valType === VALUE_TYPE_NUMBER) {
          kfs[i].additiveValue = kfs[i].value - startValue;
        } else if (valType === VALUE_TYPE_COLOR) {
          kfs[i].additiveValue = add1DArray([], kfs[i].value, startValue, -1);
        } else if (isArrayValueType(valType)) {
          kfs[i].additiveValue = valType === VALUE_TYPE_1D_ARRAY ? add1DArray([], kfs[i].value, startValue, -1) : add2DArray([], kfs[i].value, startValue, -1);
        }
      }
    }
  }
  step(target, percent) {
    if (this._finished) {
      return;
    }
    if (this._additiveTrack && this._additiveTrack._finished) {
      this._additiveTrack = null;
    }
    const isAdditive = this._additiveTrack != null;
    const valueKey = isAdditive ? "additiveValue" : "value";
    const valType = this.valType;
    const keyframes = this.keyframes;
    const kfsNum = keyframes.length;
    const propName = this.propName;
    const isValueColor = valType === VALUE_TYPE_COLOR;
    let frameIdx;
    const lastFrame = this._lastFr;
    const mathMin12 = Math.min;
    let frame;
    let nextFrame;
    if (kfsNum === 1) {
      frame = nextFrame = keyframes[0];
    } else {
      if (percent < 0) {
        frameIdx = 0;
      } else if (percent < this._lastFrP) {
        const start2 = mathMin12(lastFrame + 1, kfsNum - 1);
        for (frameIdx = start2; frameIdx >= 0; frameIdx--) {
          if (keyframes[frameIdx].percent <= percent) {
            break;
          }
        }
        frameIdx = mathMin12(frameIdx, kfsNum - 2);
      } else {
        for (frameIdx = lastFrame; frameIdx < kfsNum; frameIdx++) {
          if (keyframes[frameIdx].percent > percent) {
            break;
          }
        }
        frameIdx = mathMin12(frameIdx - 1, kfsNum - 2);
      }
      nextFrame = keyframes[frameIdx + 1];
      frame = keyframes[frameIdx];
    }
    if (!(frame && nextFrame)) {
      return;
    }
    this._lastFr = frameIdx;
    this._lastFrP = percent;
    const interval = nextFrame.percent - frame.percent;
    let w = interval === 0 ? 1 : mathMin12((percent - frame.percent) / interval, 1);
    if (nextFrame.easingFunc) {
      w = nextFrame.easingFunc(w);
    }
    let targetArr = isAdditive ? this._additiveValue : isValueColor ? tmpRgba : target[propName];
    if ((isArrayValueType(valType) || isValueColor) && !targetArr) {
      targetArr = this._additiveValue = [];
    }
    if (this.discrete) {
      target[propName] = w < 1 ? frame.rawValue : nextFrame.rawValue;
    } else if (isArrayValueType(valType)) {
      valType === VALUE_TYPE_1D_ARRAY ? interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w) : interpolate2DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);
    } else if (isGradientValueType(valType)) {
      const val = frame[valueKey];
      const nextVal = nextFrame[valueKey];
      const isLinearGradient2 = valType === VALUE_TYPE_LINEAR_GRADIENT;
      target[propName] = {
        type: isLinearGradient2 ? "linear" : "radial",
        x: interpolateNumber(val.x, nextVal.x, w),
        y: interpolateNumber(val.y, nextVal.y, w),
        colorStops: map(val.colorStops, (colorStop, idx) => {
          const nextColorStop = nextVal.colorStops[idx];
          return {
            offset: interpolateNumber(colorStop.offset, nextColorStop.offset, w),
            color: rgba2String(interpolate1DArray([], colorStop.color, nextColorStop.color, w))
          };
        }),
        global: nextVal.global
      };
      if (isLinearGradient2) {
        target[propName].x2 = interpolateNumber(val.x2, nextVal.x2, w);
        target[propName].y2 = interpolateNumber(val.y2, nextVal.y2, w);
      } else {
        target[propName].r = interpolateNumber(val.r, nextVal.r, w);
      }
    } else if (isValueColor) {
      interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);
      if (!isAdditive) {
        target[propName] = rgba2String(targetArr);
      }
    } else {
      const value = interpolateNumber(frame[valueKey], nextFrame[valueKey], w);
      if (isAdditive) {
        this._additiveValue = value;
      } else {
        target[propName] = value;
      }
    }
    if (isAdditive) {
      this._addToTarget(target);
    }
  }
  _addToTarget(target) {
    const valType = this.valType;
    const propName = this.propName;
    const additiveValue = this._additiveValue;
    if (valType === VALUE_TYPE_NUMBER) {
      target[propName] = target[propName] + additiveValue;
    } else if (valType === VALUE_TYPE_COLOR) {
      parse(target[propName], tmpRgba);
      add1DArray(tmpRgba, tmpRgba, additiveValue, 1);
      target[propName] = rgba2String(tmpRgba);
    } else if (valType === VALUE_TYPE_1D_ARRAY) {
      add1DArray(target[propName], target[propName], additiveValue, 1);
    } else if (valType === VALUE_TYPE_2D_ARRAY) {
      add2DArray(target[propName], target[propName], additiveValue, 1);
    }
  }
};
var Animator = class {
  constructor(target, loop, allowDiscreteAnimation, additiveTo) {
    this._tracks = {};
    this._trackKeys = [];
    this._maxTime = 0;
    this._started = 0;
    this._clip = null;
    this._target = target;
    this._loop = loop;
    if (loop && additiveTo) {
      logError("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = additiveTo;
    this._allowDiscrete = allowDiscreteAnimation;
  }
  getMaxTime() {
    return this._maxTime;
  }
  getDelay() {
    return this._delay;
  }
  getLoop() {
    return this._loop;
  }
  getTarget() {
    return this._target;
  }
  changeTarget(target) {
    this._target = target;
  }
  when(time, props, easing) {
    return this.whenWithKeys(time, props, keys(props), easing);
  }
  whenWithKeys(time, props, propNames, easing) {
    const tracks = this._tracks;
    for (let i = 0; i < propNames.length; i++) {
      const propName = propNames[i];
      let track = tracks[propName];
      if (!track) {
        track = tracks[propName] = new Track(propName);
        let initialValue;
        const additiveTrack = this._getAdditiveTrack(propName);
        if (additiveTrack) {
          const addtiveTrackKfs = additiveTrack.keyframes;
          const lastFinalKf = addtiveTrackKfs[addtiveTrackKfs.length - 1];
          initialValue = lastFinalKf && lastFinalKf.value;
          if (additiveTrack.valType === VALUE_TYPE_COLOR && initialValue) {
            initialValue = rgba2String(initialValue);
          }
        } else {
          initialValue = this._target[propName];
        }
        if (initialValue == null) {
          continue;
        }
        if (time > 0) {
          track.addKeyframe(0, cloneValue(initialValue), easing);
        }
        this._trackKeys.push(propName);
      }
      track.addKeyframe(time, cloneValue(props[propName]), easing);
    }
    this._maxTime = Math.max(this._maxTime, time);
    return this;
  }
  pause() {
    this._clip.pause();
    this._paused = true;
  }
  resume() {
    this._clip.resume();
    this._paused = false;
  }
  isPaused() {
    return !!this._paused;
  }
  duration(duration) {
    this._maxTime = duration;
    this._force = true;
    return this;
  }
  _doneCallback() {
    this._setTracksFinished();
    this._clip = null;
    const doneList = this._doneCbs;
    if (doneList) {
      const len2 = doneList.length;
      for (let i = 0; i < len2; i++) {
        doneList[i].call(this);
      }
    }
  }
  _abortedCallback() {
    this._setTracksFinished();
    const animation = this.animation;
    const abortedList = this._abortedCbs;
    if (animation) {
      animation.removeClip(this._clip);
    }
    this._clip = null;
    if (abortedList) {
      for (let i = 0; i < abortedList.length; i++) {
        abortedList[i].call(this);
      }
    }
  }
  _setTracksFinished() {
    const tracks = this._tracks;
    const tracksKeys = this._trackKeys;
    for (let i = 0; i < tracksKeys.length; i++) {
      tracks[tracksKeys[i]].setFinished();
    }
  }
  _getAdditiveTrack(trackName) {
    let additiveTrack;
    const additiveAnimators = this._additiveAnimators;
    if (additiveAnimators) {
      for (let i = 0; i < additiveAnimators.length; i++) {
        const track = additiveAnimators[i].getTrack(trackName);
        if (track) {
          additiveTrack = track;
        }
      }
    }
    return additiveTrack;
  }
  start(easing) {
    if (this._started > 0) {
      return;
    }
    this._started = 1;
    const self2 = this;
    const tracks = [];
    const maxTime = this._maxTime || 0;
    for (let i = 0; i < this._trackKeys.length; i++) {
      const propName = this._trackKeys[i];
      const track = this._tracks[propName];
      const additiveTrack = this._getAdditiveTrack(propName);
      const kfs = track.keyframes;
      const kfsNum = kfs.length;
      track.prepare(maxTime, additiveTrack);
      if (track.needsAnimate()) {
        if (!this._allowDiscrete && track.discrete) {
          const lastKf = kfs[kfsNum - 1];
          if (lastKf) {
            self2._target[track.propName] = lastKf.rawValue;
          }
          track.setFinished();
        } else {
          tracks.push(track);
        }
      }
    }
    if (tracks.length || this._force) {
      const clip2 = new Clip_default({
        life: maxTime,
        loop: this._loop,
        delay: this._delay || 0,
        onframe(percent) {
          self2._started = 2;
          const additiveAnimators = self2._additiveAnimators;
          if (additiveAnimators) {
            let stillHasAdditiveAnimator = false;
            for (let i = 0; i < additiveAnimators.length; i++) {
              if (additiveAnimators[i]._clip) {
                stillHasAdditiveAnimator = true;
                break;
              }
            }
            if (!stillHasAdditiveAnimator) {
              self2._additiveAnimators = null;
            }
          }
          for (let i = 0; i < tracks.length; i++) {
            tracks[i].step(self2._target, percent);
          }
          const onframeList = self2._onframeCbs;
          if (onframeList) {
            for (let i = 0; i < onframeList.length; i++) {
              onframeList[i](self2._target, percent);
            }
          }
        },
        ondestroy() {
          self2._doneCallback();
        }
      });
      this._clip = clip2;
      if (this.animation) {
        this.animation.addClip(clip2);
      }
      if (easing) {
        clip2.setEasing(easing);
      }
    } else {
      this._doneCallback();
    }
    return this;
  }
  stop(forwardToLast) {
    if (!this._clip) {
      return;
    }
    const clip2 = this._clip;
    if (forwardToLast) {
      clip2.onframe(1);
    }
    this._abortedCallback();
  }
  delay(time) {
    this._delay = time;
    return this;
  }
  during(cb) {
    if (cb) {
      if (!this._onframeCbs) {
        this._onframeCbs = [];
      }
      this._onframeCbs.push(cb);
    }
    return this;
  }
  done(cb) {
    if (cb) {
      if (!this._doneCbs) {
        this._doneCbs = [];
      }
      this._doneCbs.push(cb);
    }
    return this;
  }
  aborted(cb) {
    if (cb) {
      if (!this._abortedCbs) {
        this._abortedCbs = [];
      }
      this._abortedCbs.push(cb);
    }
    return this;
  }
  getClip() {
    return this._clip;
  }
  getTrack(propName) {
    return this._tracks[propName];
  }
  getTracks() {
    return map(this._trackKeys, (key) => this._tracks[key]);
  }
  stopTracks(propNames, forwardToLast) {
    if (!propNames.length || !this._clip) {
      return true;
    }
    const tracks = this._tracks;
    const tracksKeys = this._trackKeys;
    for (let i = 0; i < propNames.length; i++) {
      const track = tracks[propNames[i]];
      if (track && !track.isFinished()) {
        if (forwardToLast) {
          track.step(this._target, 1);
        } else if (this._started === 1) {
          track.step(this._target, 0);
        }
        track.setFinished();
      }
    }
    let allAborted = true;
    for (let i = 0; i < tracksKeys.length; i++) {
      if (!tracks[tracksKeys[i]].isFinished()) {
        allAborted = false;
        break;
      }
    }
    if (allAborted) {
      this._abortedCallback();
    }
    return allAborted;
  }
  saveTo(target, trackKeys, firstOrLast) {
    if (!target) {
      return;
    }
    trackKeys = trackKeys || this._trackKeys;
    for (let i = 0; i < trackKeys.length; i++) {
      const propName = trackKeys[i];
      const track = this._tracks[propName];
      if (!track || track.isFinished()) {
        continue;
      }
      const kfs = track.keyframes;
      const kf = kfs[firstOrLast ? 0 : kfs.length - 1];
      if (kf) {
        target[propName] = cloneValue(kf.rawValue);
      }
    }
  }
  __changeFinalValue(finalProps, trackKeys) {
    trackKeys = trackKeys || keys(finalProps);
    for (let i = 0; i < trackKeys.length; i++) {
      const propName = trackKeys[i];
      const track = this._tracks[propName];
      if (!track) {
        continue;
      }
      const kfs = track.keyframes;
      if (kfs.length > 1) {
        const lastKf = kfs.pop();
        track.addKeyframe(lastKf.time, finalProps[propName]);
        track.prepare(this._maxTime, track.getAdditiveTrack());
      }
    }
  }
};
var Animator_default = Animator;

// node_modules/zrender/src/animation/Animation.ts
function getTime() {
  return new Date().getTime();
}
var Animation = class extends Eventful_default {
  constructor(opts) {
    super();
    this._running = false;
    this._time = 0;
    this._pausedTime = 0;
    this._pauseStart = 0;
    this._paused = false;
    opts = opts || {};
    this.stage = opts.stage || {};
  }
  addClip(clip2) {
    if (clip2.animation) {
      this.removeClip(clip2);
    }
    if (!this._head) {
      this._head = this._tail = clip2;
    } else {
      this._tail.next = clip2;
      clip2.prev = this._tail;
      clip2.next = null;
      this._tail = clip2;
    }
    clip2.animation = this;
  }
  addAnimator(animator) {
    animator.animation = this;
    const clip2 = animator.getClip();
    if (clip2) {
      this.addClip(clip2);
    }
  }
  removeClip(clip2) {
    if (!clip2.animation) {
      return;
    }
    const prev = clip2.prev;
    const next = clip2.next;
    if (prev) {
      prev.next = next;
    } else {
      this._head = next;
    }
    if (next) {
      next.prev = prev;
    } else {
      this._tail = prev;
    }
    clip2.next = clip2.prev = clip2.animation = null;
  }
  removeAnimator(animator) {
    const clip2 = animator.getClip();
    if (clip2) {
      this.removeClip(clip2);
    }
    animator.animation = null;
  }
  update(notTriggerFrameAndStageUpdate) {
    const time = getTime() - this._pausedTime;
    const delta = time - this._time;
    let clip2 = this._head;
    while (clip2) {
      const nextClip = clip2.next;
      let finished = clip2.step(time, delta);
      if (finished) {
        clip2.ondestroy();
        this.removeClip(clip2);
        clip2 = nextClip;
      } else {
        clip2 = nextClip;
      }
    }
    this._time = time;
    if (!notTriggerFrameAndStageUpdate) {
      this.trigger("frame", delta);
      this.stage.update && this.stage.update();
    }
  }
  _startLoop() {
    const self2 = this;
    this._running = true;
    function step() {
      if (self2._running) {
        requestAnimationFrame_default(step);
        !self2._paused && self2.update();
      }
    }
    requestAnimationFrame_default(step);
  }
  start() {
    if (this._running) {
      return;
    }
    this._time = getTime();
    this._pausedTime = 0;
    this._startLoop();
  }
  stop() {
    this._running = false;
  }
  pause() {
    if (!this._paused) {
      this._pauseStart = getTime();
      this._paused = true;
    }
  }
  resume() {
    if (this._paused) {
      this._pausedTime += getTime() - this._pauseStart;
      this._paused = false;
    }
  }
  clear() {
    let clip2 = this._head;
    while (clip2) {
      let nextClip = clip2.next;
      clip2.prev = clip2.next = clip2.animation = null;
      clip2 = nextClip;
    }
    this._head = this._tail = null;
  }
  isFinished() {
    return this._head == null;
  }
  animate(target, options) {
    options = options || {};
    this.start();
    const animator = new Animator_default(target, options.loop);
    this.addAnimator(animator);
    return animator;
  }
};
var Animation_default = Animation;

// node_modules/zrender/src/dom/HandlerProxy.ts
var TOUCH_CLICK_DELAY = 300;
var globalEventSupported = env_default.domSupported;
var localNativeListenerNames = function() {
  const mouseHandlerNames = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ];
  const touchHandlerNames = [
    "touchstart",
    "touchend",
    "touchmove"
  ];
  const pointerEventNameMap = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  };
  const pointerHandlerNames = map(mouseHandlerNames, function(name) {
    const nm = name.replace("mouse", "pointer");
    return pointerEventNameMap.hasOwnProperty(nm) ? nm : name;
  });
  return {
    mouse: mouseHandlerNames,
    touch: touchHandlerNames,
    pointer: pointerHandlerNames
  };
}();
var globalNativeListenerNames = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
};
var wheelEventSupported = false;
function isPointerFromTouch(event) {
  const pointerType = event.pointerType;
  return pointerType === "pen" || pointerType === "touch";
}
function setTouchTimer(scope) {
  scope.touching = true;
  if (scope.touchTimer != null) {
    clearTimeout(scope.touchTimer);
    scope.touchTimer = null;
  }
  scope.touchTimer = setTimeout(function() {
    scope.touching = false;
    scope.touchTimer = null;
  }, 700);
}
function markTouch(event) {
  event && (event.zrByTouch = true);
}
function normalizeGlobalEvent(instance, event) {
  return normalizeEvent(instance.dom, new FakeGlobalEvent(instance, event), true);
}
function isLocalEl(instance, el) {
  let elTmp = el;
  let isLocal = false;
  while (elTmp && elTmp.nodeType !== 9 && !(isLocal = elTmp.domBelongToZr || elTmp !== el && elTmp === instance.painterRoot)) {
    elTmp = elTmp.parentNode;
  }
  return isLocal;
}
var FakeGlobalEvent = class {
  constructor(instance, event) {
    this.stopPropagation = noop;
    this.stopImmediatePropagation = noop;
    this.preventDefault = noop;
    this.type = event.type;
    this.target = this.currentTarget = instance.dom;
    this.pointerType = event.pointerType;
    this.clientX = event.clientX;
    this.clientY = event.clientY;
  }
};
var localDOMHandlers = {
  mousedown(event) {
    event = normalizeEvent(this.dom, event);
    this.__mayPointerCapture = [event.zrX, event.zrY];
    this.trigger("mousedown", event);
  },
  mousemove(event) {
    event = normalizeEvent(this.dom, event);
    const downPoint = this.__mayPointerCapture;
    if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {
      this.__togglePointerCapture(true);
    }
    this.trigger("mousemove", event);
  },
  mouseup(event) {
    event = normalizeEvent(this.dom, event);
    this.__togglePointerCapture(false);
    this.trigger("mouseup", event);
  },
  mouseout(event) {
    event = normalizeEvent(this.dom, event);
    const element = event.toElement || event.relatedTarget;
    if (!isLocalEl(this, element)) {
      if (this.__pointerCapturing) {
        event.zrEventControl = "no_globalout";
      }
      this.trigger("mouseout", event);
    }
  },
  wheel(event) {
    wheelEventSupported = true;
    event = normalizeEvent(this.dom, event);
    this.trigger("mousewheel", event);
  },
  mousewheel(event) {
    if (wheelEventSupported) {
      return;
    }
    event = normalizeEvent(this.dom, event);
    this.trigger("mousewheel", event);
  },
  touchstart(event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.__lastTouchMoment = new Date();
    this.handler.processGesture(event, "start");
    localDOMHandlers.mousemove.call(this, event);
    localDOMHandlers.mousedown.call(this, event);
  },
  touchmove(event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.handler.processGesture(event, "change");
    localDOMHandlers.mousemove.call(this, event);
  },
  touchend(event) {
    event = normalizeEvent(this.dom, event);
    markTouch(event);
    this.handler.processGesture(event, "end");
    localDOMHandlers.mouseup.call(this, event);
    if (+new Date() - +this.__lastTouchMoment < TOUCH_CLICK_DELAY) {
      localDOMHandlers.click.call(this, event);
    }
  },
  pointerdown(event) {
    localDOMHandlers.mousedown.call(this, event);
  },
  pointermove(event) {
    if (!isPointerFromTouch(event)) {
      localDOMHandlers.mousemove.call(this, event);
    }
  },
  pointerup(event) {
    localDOMHandlers.mouseup.call(this, event);
  },
  pointerout(event) {
    if (!isPointerFromTouch(event)) {
      localDOMHandlers.mouseout.call(this, event);
    }
  }
};
each(["click", "dblclick", "contextmenu"], function(name) {
  localDOMHandlers[name] = function(event) {
    event = normalizeEvent(this.dom, event);
    this.trigger(name, event);
  };
});
var globalDOMHandlers = {
  pointermove: function(event) {
    if (!isPointerFromTouch(event)) {
      globalDOMHandlers.mousemove.call(this, event);
    }
  },
  pointerup: function(event) {
    globalDOMHandlers.mouseup.call(this, event);
  },
  mousemove: function(event) {
    this.trigger("mousemove", event);
  },
  mouseup: function(event) {
    const pointerCaptureReleasing = this.__pointerCapturing;
    this.__togglePointerCapture(false);
    this.trigger("mouseup", event);
    if (pointerCaptureReleasing) {
      event.zrEventControl = "only_globalout";
      this.trigger("mouseout", event);
    }
  }
};
function mountLocalDOMEventListeners(instance, scope) {
  const domHandlers = scope.domHandlers;
  if (env_default.pointerEventsSupported) {
    each(localNativeListenerNames.pointer, function(nativeEventName) {
      mountSingleDOMEventListener(scope, nativeEventName, function(event) {
        domHandlers[nativeEventName].call(instance, event);
      });
    });
  } else {
    if (env_default.touchEventsSupported) {
      each(localNativeListenerNames.touch, function(nativeEventName) {
        mountSingleDOMEventListener(scope, nativeEventName, function(event) {
          domHandlers[nativeEventName].call(instance, event);
          setTouchTimer(scope);
        });
      });
    }
    each(localNativeListenerNames.mouse, function(nativeEventName) {
      mountSingleDOMEventListener(scope, nativeEventName, function(event) {
        event = getNativeEvent(event);
        if (!scope.touching) {
          domHandlers[nativeEventName].call(instance, event);
        }
      });
    });
  }
}
function mountGlobalDOMEventListeners(instance, scope) {
  if (env_default.pointerEventsSupported) {
    each(globalNativeListenerNames.pointer, mount);
  } else if (!env_default.touchEventsSupported) {
    each(globalNativeListenerNames.mouse, mount);
  }
  function mount(nativeEventName) {
    function nativeEventListener(event) {
      event = getNativeEvent(event);
      if (!isLocalEl(instance, event.target)) {
        event = normalizeGlobalEvent(instance, event);
        scope.domHandlers[nativeEventName].call(instance, event);
      }
    }
    mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, {capture: true});
  }
}
function mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {
  scope.mounted[nativeEventName] = listener;
  scope.listenerOpts[nativeEventName] = opt;
  addEventListener(scope.domTarget, nativeEventName, listener, opt);
}
function unmountDOMEventListeners(scope) {
  const mounted = scope.mounted;
  for (let nativeEventName in mounted) {
    if (mounted.hasOwnProperty(nativeEventName)) {
      removeEventListener(scope.domTarget, nativeEventName, mounted[nativeEventName], scope.listenerOpts[nativeEventName]);
    }
  }
  scope.mounted = {};
}
var DOMHandlerScope = class {
  constructor(domTarget, domHandlers) {
    this.mounted = {};
    this.listenerOpts = {};
    this.touching = false;
    this.domTarget = domTarget;
    this.domHandlers = domHandlers;
  }
};
var HandlerDomProxy = class extends Eventful_default {
  constructor(dom, painterRoot) {
    super();
    this.__pointerCapturing = false;
    this.dom = dom;
    this.painterRoot = painterRoot;
    this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);
    if (globalEventSupported) {
      this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);
    }
    mountLocalDOMEventListeners(this, this._localHandlerScope);
  }
  dispose() {
    unmountDOMEventListeners(this._localHandlerScope);
    if (globalEventSupported) {
      unmountDOMEventListeners(this._globalHandlerScope);
    }
  }
  setCursor(cursorStyle) {
    this.dom.style && (this.dom.style.cursor = cursorStyle || "default");
  }
  __togglePointerCapture(isPointerCapturing) {
    this.__mayPointerCapture = null;
    if (globalEventSupported && +this.__pointerCapturing ^ +isPointerCapturing) {
      this.__pointerCapturing = isPointerCapturing;
      const globalHandlerScope = this._globalHandlerScope;
      isPointerCapturing ? mountGlobalDOMEventListeners(this, globalHandlerScope) : unmountDOMEventListeners(globalHandlerScope);
    }
  }
};
var HandlerProxy_default = HandlerDomProxy;

// node_modules/zrender/src/config.ts
var dpr = 1;
if (env_default.hasGlobalWindow) {
  dpr = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1);
}
var devicePixelRatio = dpr;
var DARK_MODE_THRESHOLD = 0.4;
var DARK_LABEL_COLOR = "#333";
var LIGHT_LABEL_COLOR = "#ccc";
var LIGHTER_LABEL_COLOR = "#eee";

// node_modules/zrender/src/core/Transformable.ts
var mIdentity = identity;
var EPSILON3 = 5e-5;
function isNotAroundZero2(val) {
  return val > EPSILON3 || val < -EPSILON3;
}
var scaleTmp = [];
var tmpTransform = [];
var originTransform = create2();
var abs = Math.abs;
var Transformable2 = class {
  getLocalTransform(m2) {
    return Transformable2.getLocalTransform(this, m2);
  }
  setPosition(arr) {
    this.x = arr[0];
    this.y = arr[1];
  }
  setScale(arr) {
    this.scaleX = arr[0];
    this.scaleY = arr[1];
  }
  setSkew(arr) {
    this.skewX = arr[0];
    this.skewY = arr[1];
  }
  setOrigin(arr) {
    this.originX = arr[0];
    this.originY = arr[1];
  }
  needLocalTransform() {
    return isNotAroundZero2(this.rotation) || isNotAroundZero2(this.x) || isNotAroundZero2(this.y) || isNotAroundZero2(this.scaleX - 1) || isNotAroundZero2(this.scaleY - 1) || isNotAroundZero2(this.skewX) || isNotAroundZero2(this.skewY);
  }
  updateTransform() {
    const parentTransform = this.parent && this.parent.transform;
    const needLocalTransform = this.needLocalTransform();
    let m2 = this.transform;
    if (!(needLocalTransform || parentTransform)) {
      if (m2) {
        mIdentity(m2);
        this.invTransform = null;
      }
      return;
    }
    m2 = m2 || create2();
    if (needLocalTransform) {
      this.getLocalTransform(m2);
    } else {
      mIdentity(m2);
    }
    if (parentTransform) {
      if (needLocalTransform) {
        mul2(m2, parentTransform, m2);
      } else {
        copy2(m2, parentTransform);
      }
    }
    this.transform = m2;
    this._resolveGlobalScaleRatio(m2);
  }
  _resolveGlobalScaleRatio(m2) {
    const globalScaleRatio = this.globalScaleRatio;
    if (globalScaleRatio != null && globalScaleRatio !== 1) {
      this.getGlobalScale(scaleTmp);
      const relX = scaleTmp[0] < 0 ? -1 : 1;
      const relY = scaleTmp[1] < 0 ? -1 : 1;
      const sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;
      const sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;
      m2[0] *= sx;
      m2[1] *= sx;
      m2[2] *= sy;
      m2[3] *= sy;
    }
    this.invTransform = this.invTransform || create2();
    invert(this.invTransform, m2);
  }
  getComputedTransform() {
    let transformNode = this;
    const ancestors = [];
    while (transformNode) {
      ancestors.push(transformNode);
      transformNode = transformNode.parent;
    }
    while (transformNode = ancestors.pop()) {
      transformNode.updateTransform();
    }
    return this.transform;
  }
  setLocalTransform(m2) {
    if (!m2) {
      return;
    }
    let sx = m2[0] * m2[0] + m2[1] * m2[1];
    let sy = m2[2] * m2[2] + m2[3] * m2[3];
    const rotation = Math.atan2(m2[1], m2[0]);
    const shearX = Math.PI / 2 + rotation - Math.atan2(m2[3], m2[2]);
    sy = Math.sqrt(sy) * Math.cos(shearX);
    sx = Math.sqrt(sx);
    this.skewX = shearX;
    this.skewY = 0;
    this.rotation = -rotation;
    this.x = +m2[4];
    this.y = +m2[5];
    this.scaleX = sx;
    this.scaleY = sy;
    this.originX = 0;
    this.originY = 0;
  }
  decomposeTransform() {
    if (!this.transform) {
      return;
    }
    const parent = this.parent;
    let m2 = this.transform;
    if (parent && parent.transform) {
      parent.invTransform = parent.invTransform || create2();
      mul2(tmpTransform, parent.invTransform, m2);
      m2 = tmpTransform;
    }
    const ox = this.originX;
    const oy = this.originY;
    if (ox || oy) {
      originTransform[4] = ox;
      originTransform[5] = oy;
      mul2(tmpTransform, m2, originTransform);
      tmpTransform[4] -= ox;
      tmpTransform[5] -= oy;
      m2 = tmpTransform;
    }
    this.setLocalTransform(m2);
  }
  getGlobalScale(out2) {
    const m2 = this.transform;
    out2 = out2 || [];
    if (!m2) {
      out2[0] = 1;
      out2[1] = 1;
      return out2;
    }
    out2[0] = Math.sqrt(m2[0] * m2[0] + m2[1] * m2[1]);
    out2[1] = Math.sqrt(m2[2] * m2[2] + m2[3] * m2[3]);
    if (m2[0] < 0) {
      out2[0] = -out2[0];
    }
    if (m2[3] < 0) {
      out2[1] = -out2[1];
    }
    return out2;
  }
  transformCoordToLocal(x, y) {
    const v22 = [x, y];
    const invTransform = this.invTransform;
    if (invTransform) {
      applyTransform(v22, v22, invTransform);
    }
    return v22;
  }
  transformCoordToGlobal(x, y) {
    const v22 = [x, y];
    const transform2 = this.transform;
    if (transform2) {
      applyTransform(v22, v22, transform2);
    }
    return v22;
  }
  getLineScale() {
    const m2 = this.transform;
    return m2 && abs(m2[0] - 1) > 1e-10 && abs(m2[3] - 1) > 1e-10 ? Math.sqrt(abs(m2[0] * m2[3] - m2[2] * m2[1])) : 1;
  }
  copyTransform(source) {
    copyTransform(this, source);
  }
  static getLocalTransform(target, m2) {
    m2 = m2 || [];
    const ox = target.originX || 0;
    const oy = target.originY || 0;
    const sx = target.scaleX;
    const sy = target.scaleY;
    const ax = target.anchorX;
    const ay = target.anchorY;
    const rotation = target.rotation || 0;
    const x = target.x;
    const y = target.y;
    const skewX = target.skewX ? Math.tan(target.skewX) : 0;
    const skewY = target.skewY ? Math.tan(-target.skewY) : 0;
    if (ox || oy || ax || ay) {
      const dx = ox + ax;
      const dy = oy + ay;
      m2[4] = -dx * sx - skewX * dy * sy;
      m2[5] = -dy * sy - skewY * dx * sx;
    } else {
      m2[4] = m2[5] = 0;
    }
    m2[0] = sx;
    m2[3] = sy;
    m2[1] = skewY * sx;
    m2[2] = skewX * sy;
    rotation && rotate(m2, m2, rotation);
    m2[4] += ox + x;
    m2[5] += oy + y;
    return m2;
  }
};
var Transformable = Transformable2;
Transformable.initDefaultProps = function() {
  const proto2 = Transformable2.prototype;
  proto2.scaleX = proto2.scaleY = proto2.globalScaleRatio = 1;
  proto2.x = proto2.y = proto2.originX = proto2.originY = proto2.skewX = proto2.skewY = proto2.rotation = proto2.anchorX = proto2.anchorY = 0;
}();
var TRANSFORMABLE_PROPS = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function copyTransform(target, source) {
  for (let i = 0; i < TRANSFORMABLE_PROPS.length; i++) {
    const propName = TRANSFORMABLE_PROPS[i];
    target[propName] = source[propName];
  }
}
var Transformable_default = Transformable;

// node_modules/zrender/src/contain/text.ts
var textWidthCache = {};
function getWidth(text, font) {
  font = font || DEFAULT_FONT;
  let cacheOfFont = textWidthCache[font];
  if (!cacheOfFont) {
    cacheOfFont = textWidthCache[font] = new LRU_default(500);
  }
  let width = cacheOfFont.get(text);
  if (width == null) {
    width = platformApi.measureText(text, font).width;
    cacheOfFont.put(text, width);
  }
  return width;
}
function innerGetBoundingRect(text, font, textAlign, textBaseline) {
  const width = getWidth(text, font);
  const height = getLineHeight(font);
  const x = adjustTextX(0, width, textAlign);
  const y = adjustTextY2(0, height, textBaseline);
  const rect = new BoundingRect_default(x, y, width, height);
  return rect;
}
function getBoundingRect(text, font, textAlign, textBaseline) {
  const textLines = ((text || "") + "").split("\n");
  const len2 = textLines.length;
  if (len2 === 1) {
    return innerGetBoundingRect(textLines[0], font, textAlign, textBaseline);
  } else {
    const uniondRect = new BoundingRect_default(0, 0, 0, 0);
    for (let i = 0; i < textLines.length; i++) {
      const rect = innerGetBoundingRect(textLines[i], font, textAlign, textBaseline);
      i === 0 ? uniondRect.copy(rect) : uniondRect.union(rect);
    }
    return uniondRect;
  }
}
function adjustTextX(x, width, textAlign) {
  if (textAlign === "right") {
    x -= width;
  } else if (textAlign === "center") {
    x -= width / 2;
  }
  return x;
}
function adjustTextY2(y, height, verticalAlign) {
  if (verticalAlign === "middle") {
    y -= height / 2;
  } else if (verticalAlign === "bottom") {
    y -= height;
  }
  return y;
}
function getLineHeight(font) {
  return getWidth("\u56FD", font);
}
function parsePercent(value, maxValue) {
  if (typeof value === "string") {
    if (value.lastIndexOf("%") >= 0) {
      return parseFloat(value) / 100 * maxValue;
    }
    return parseFloat(value);
  }
  return value;
}
function calculateTextPosition(out2, opts, rect) {
  const textPosition = opts.position || "inside";
  const distance2 = opts.distance != null ? opts.distance : 5;
  const height = rect.height;
  const width = rect.width;
  const halfHeight = height / 2;
  let x = rect.x;
  let y = rect.y;
  let textAlign = "left";
  let textVerticalAlign = "top";
  if (textPosition instanceof Array) {
    x += parsePercent(textPosition[0], rect.width);
    y += parsePercent(textPosition[1], rect.height);
    textAlign = null;
    textVerticalAlign = null;
  } else {
    switch (textPosition) {
      case "left":
        x -= distance2;
        y += halfHeight;
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      case "right":
        x += distance2 + width;
        y += halfHeight;
        textVerticalAlign = "middle";
        break;
      case "top":
        x += width / 2;
        y -= distance2;
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "bottom":
        x += width / 2;
        y += height + distance2;
        textAlign = "center";
        break;
      case "inside":
        x += width / 2;
        y += halfHeight;
        textAlign = "center";
        textVerticalAlign = "middle";
        break;
      case "insideLeft":
        x += distance2;
        y += halfHeight;
        textVerticalAlign = "middle";
        break;
      case "insideRight":
        x += width - distance2;
        y += halfHeight;
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      case "insideTop":
        x += width / 2;
        y += distance2;
        textAlign = "center";
        break;
      case "insideBottom":
        x += width / 2;
        y += height - distance2;
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "insideTopLeft":
        x += distance2;
        y += distance2;
        break;
      case "insideTopRight":
        x += width - distance2;
        y += distance2;
        textAlign = "right";
        break;
      case "insideBottomLeft":
        x += distance2;
        y += height - distance2;
        textVerticalAlign = "bottom";
        break;
      case "insideBottomRight":
        x += width - distance2;
        y += height - distance2;
        textAlign = "right";
        textVerticalAlign = "bottom";
        break;
    }
  }
  out2 = out2 || {};
  out2.x = x;
  out2.y = y;
  out2.align = textAlign;
  out2.verticalAlign = textVerticalAlign;
  return out2;
}

// node_modules/zrender/src/Element.ts
var PRESERVED_NORMAL_STATE = "__zr_normal__";
var PRIMARY_STATES_KEYS = TRANSFORMABLE_PROPS.concat(["ignore"]);
var DEFAULT_ANIMATABLE_MAP = reduce(TRANSFORMABLE_PROPS, (obj, key) => {
  obj[key] = true;
  return obj;
}, {ignore: false});
var tmpTextPosCalcRes = {};
var tmpBoundingRect = new BoundingRect_default(0, 0, 0, 0);
var Element2 = class {
  constructor(props) {
    this.id = guid();
    this.animators = [];
    this.currentStates = [];
    this.states = {};
    this._init(props);
  }
  _init(props) {
    this.attr(props);
  }
  drift(dx, dy, e2) {
    switch (this.draggable) {
      case "horizontal":
        dy = 0;
        break;
      case "vertical":
        dx = 0;
        break;
    }
    let m2 = this.transform;
    if (!m2) {
      m2 = this.transform = [1, 0, 0, 1, 0, 0];
    }
    m2[4] += dx;
    m2[5] += dy;
    this.decomposeTransform();
    this.markRedraw();
  }
  beforeUpdate() {
  }
  afterUpdate() {
  }
  update() {
    this.updateTransform();
    if (this.__dirty) {
      this.updateInnerText();
    }
  }
  updateInnerText(forceUpdate) {
    const textEl = this._textContent;
    if (textEl && (!textEl.ignore || forceUpdate)) {
      if (!this.textConfig) {
        this.textConfig = {};
      }
      const textConfig = this.textConfig;
      const isLocal = textConfig.local;
      const innerTransformable = textEl.innerTransformable;
      let textAlign;
      let textVerticalAlign;
      let textStyleChanged = false;
      innerTransformable.parent = isLocal ? this : null;
      let innerOrigin = false;
      innerTransformable.copyTransform(textEl);
      if (textConfig.position != null) {
        let layoutRect = tmpBoundingRect;
        if (textConfig.layoutRect) {
          layoutRect.copy(textConfig.layoutRect);
        } else {
          layoutRect.copy(this.getBoundingRect());
        }
        if (!isLocal) {
          layoutRect.applyTransform(this.transform);
        }
        if (this.calculateTextPosition) {
          this.calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
        } else {
          calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
        }
        innerTransformable.x = tmpTextPosCalcRes.x;
        innerTransformable.y = tmpTextPosCalcRes.y;
        textAlign = tmpTextPosCalcRes.align;
        textVerticalAlign = tmpTextPosCalcRes.verticalAlign;
        const textOrigin = textConfig.origin;
        if (textOrigin && textConfig.rotation != null) {
          let relOriginX;
          let relOriginY;
          if (textOrigin === "center") {
            relOriginX = layoutRect.width * 0.5;
            relOriginY = layoutRect.height * 0.5;
          } else {
            relOriginX = parsePercent(textOrigin[0], layoutRect.width);
            relOriginY = parsePercent(textOrigin[1], layoutRect.height);
          }
          innerOrigin = true;
          innerTransformable.originX = -innerTransformable.x + relOriginX + (isLocal ? 0 : layoutRect.x);
          innerTransformable.originY = -innerTransformable.y + relOriginY + (isLocal ? 0 : layoutRect.y);
        }
      }
      if (textConfig.rotation != null) {
        innerTransformable.rotation = textConfig.rotation;
      }
      const textOffset = textConfig.offset;
      if (textOffset) {
        innerTransformable.x += textOffset[0];
        innerTransformable.y += textOffset[1];
        if (!innerOrigin) {
          innerTransformable.originX = -textOffset[0];
          innerTransformable.originY = -textOffset[1];
        }
      }
      const isInside = textConfig.inside == null ? typeof textConfig.position === "string" && textConfig.position.indexOf("inside") >= 0 : textConfig.inside;
      const innerTextDefaultStyle = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});
      let textFill;
      let textStroke;
      let autoStroke;
      if (isInside && this.canBeInsideText()) {
        textFill = textConfig.insideFill;
        textStroke = textConfig.insideStroke;
        if (textFill == null || textFill === "auto") {
          textFill = this.getInsideTextFill();
        }
        if (textStroke == null || textStroke === "auto") {
          textStroke = this.getInsideTextStroke(textFill);
          autoStroke = true;
        }
      } else {
        textFill = textConfig.outsideFill;
        textStroke = textConfig.outsideStroke;
        if (textFill == null || textFill === "auto") {
          textFill = this.getOutsideFill();
        }
        if (textStroke == null || textStroke === "auto") {
          textStroke = this.getOutsideStroke(textFill);
          autoStroke = true;
        }
      }
      textFill = textFill || "#000";
      if (textFill !== innerTextDefaultStyle.fill || textStroke !== innerTextDefaultStyle.stroke || autoStroke !== innerTextDefaultStyle.autoStroke || textAlign !== innerTextDefaultStyle.align || textVerticalAlign !== innerTextDefaultStyle.verticalAlign) {
        textStyleChanged = true;
        innerTextDefaultStyle.fill = textFill;
        innerTextDefaultStyle.stroke = textStroke;
        innerTextDefaultStyle.autoStroke = autoStroke;
        innerTextDefaultStyle.align = textAlign;
        innerTextDefaultStyle.verticalAlign = textVerticalAlign;
        textEl.setDefaultTextStyle(innerTextDefaultStyle);
      }
      textEl.__dirty |= REDRAW_BIT;
      if (textStyleChanged) {
        textEl.dirtyStyle(true);
      }
    }
  }
  canBeInsideText() {
    return true;
  }
  getInsideTextFill() {
    return "#fff";
  }
  getInsideTextStroke(textFill) {
    return "#000";
  }
  getOutsideFill() {
    return this.__zr && this.__zr.isDarkMode() ? LIGHT_LABEL_COLOR : DARK_LABEL_COLOR;
  }
  getOutsideStroke(textFill) {
    const backgroundColor2 = this.__zr && this.__zr.getBackgroundColor();
    let colorArr = typeof backgroundColor2 === "string" && parse(backgroundColor2);
    if (!colorArr) {
      colorArr = [255, 255, 255, 1];
    }
    const alpha = colorArr[3];
    const isDark = this.__zr.isDarkMode();
    for (let i = 0; i < 3; i++) {
      colorArr[i] = colorArr[i] * alpha + (isDark ? 0 : 255) * (1 - alpha);
    }
    colorArr[3] = 1;
    return stringify(colorArr, "rgba");
  }
  traverse(cb, context) {
  }
  attrKV(key, value) {
    if (key === "textConfig") {
      this.setTextConfig(value);
    } else if (key === "textContent") {
      this.setTextContent(value);
    } else if (key === "clipPath") {
      this.setClipPath(value);
    } else if (key === "extra") {
      this.extra = this.extra || {};
      extend(this.extra, value);
    } else {
      this[key] = value;
    }
  }
  hide() {
    this.ignore = true;
    this.markRedraw();
  }
  show() {
    this.ignore = false;
    this.markRedraw();
  }
  attr(keyOrObj, value) {
    if (typeof keyOrObj === "string") {
      this.attrKV(keyOrObj, value);
    } else if (isObject(keyOrObj)) {
      let obj = keyOrObj;
      let keysArr = keys(obj);
      for (let i = 0; i < keysArr.length; i++) {
        let key = keysArr[i];
        this.attrKV(key, keyOrObj[key]);
      }
    }
    this.markRedraw();
    return this;
  }
  saveCurrentToNormalState(toState) {
    this._innerSaveToNormal(toState);
    const normalState = this._normalState;
    for (let i = 0; i < this.animators.length; i++) {
      const animator = this.animators[i];
      const fromStateTransition = animator.__fromStateTransition;
      if (animator.getLoop() || fromStateTransition && fromStateTransition !== PRESERVED_NORMAL_STATE) {
        continue;
      }
      const targetName = animator.targetName;
      const target = targetName ? normalState[targetName] : normalState;
      animator.saveTo(target);
    }
  }
  _innerSaveToNormal(toState) {
    let normalState = this._normalState;
    if (!normalState) {
      normalState = this._normalState = {};
    }
    if (toState.textConfig && !normalState.textConfig) {
      normalState.textConfig = this.textConfig;
    }
    this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS);
  }
  _savePrimaryToNormal(toState, normalState, primaryKeys) {
    for (let i = 0; i < primaryKeys.length; i++) {
      let key = primaryKeys[i];
      if (toState[key] != null && !(key in normalState)) {
        normalState[key] = this[key];
      }
    }
  }
  hasState() {
    return this.currentStates.length > 0;
  }
  getState(name) {
    return this.states[name];
  }
  ensureState(name) {
    const states = this.states;
    if (!states[name]) {
      states[name] = {};
    }
    return states[name];
  }
  clearStates(noAnimation) {
    this.useState(PRESERVED_NORMAL_STATE, false, noAnimation);
  }
  useState(stateName, keepCurrentStates, noAnimation, forceUseHoverLayer) {
    const toNormalState = stateName === PRESERVED_NORMAL_STATE;
    const hasStates = this.hasState();
    if (!hasStates && toNormalState) {
      return;
    }
    const currentStates = this.currentStates;
    const animationCfg = this.stateTransition;
    if (indexOf(currentStates, stateName) >= 0 && (keepCurrentStates || currentStates.length === 1)) {
      return;
    }
    let state;
    if (this.stateProxy && !toNormalState) {
      state = this.stateProxy(stateName);
    }
    if (!state) {
      state = this.states && this.states[stateName];
    }
    if (!state && !toNormalState) {
      logError(`State ${stateName} not exists.`);
      return;
    }
    if (!toNormalState) {
      this.saveCurrentToNormalState(state);
    }
    const useHoverLayer = !!(state && state.hoverLayer || forceUseHoverLayer);
    if (useHoverLayer) {
      this._toggleHoverLayerFlag(true);
    }
    this._applyStateObj(stateName, state, this._normalState, keepCurrentStates, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
    const textContent = this._textContent;
    const textGuide = this._textGuide;
    if (textContent) {
      textContent.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
    }
    if (textGuide) {
      textGuide.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer);
    }
    if (toNormalState) {
      this.currentStates = [];
      this._normalState = {};
    } else {
      if (!keepCurrentStates) {
        this.currentStates = [stateName];
      } else {
        this.currentStates.push(stateName);
      }
    }
    this._updateAnimationTargets();
    this.markRedraw();
    if (!useHoverLayer && this.__inHover) {
      this._toggleHoverLayerFlag(false);
      this.__dirty &= ~REDRAW_BIT;
    }
    return state;
  }
  useStates(states, noAnimation, forceUseHoverLayer) {
    if (!states.length) {
      this.clearStates();
    } else {
      const stateObjects = [];
      const currentStates = this.currentStates;
      const len2 = states.length;
      let notChange = len2 === currentStates.length;
      if (notChange) {
        for (let i = 0; i < len2; i++) {
          if (states[i] !== currentStates[i]) {
            notChange = false;
            break;
          }
        }
      }
      if (notChange) {
        return;
      }
      for (let i = 0; i < len2; i++) {
        const stateName = states[i];
        let stateObj;
        if (this.stateProxy) {
          stateObj = this.stateProxy(stateName, states);
        }
        if (!stateObj) {
          stateObj = this.states[stateName];
        }
        if (stateObj) {
          stateObjects.push(stateObj);
        }
      }
      const lastStateObj = stateObjects[len2 - 1];
      const useHoverLayer = !!(lastStateObj && lastStateObj.hoverLayer || forceUseHoverLayer);
      if (useHoverLayer) {
        this._toggleHoverLayerFlag(true);
      }
      const mergedState = this._mergeStates(stateObjects);
      const animationCfg = this.stateTransition;
      this.saveCurrentToNormalState(mergedState);
      this._applyStateObj(states.join(","), mergedState, this._normalState, false, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
      const textContent = this._textContent;
      const textGuide = this._textGuide;
      if (textContent) {
        textContent.useStates(states, noAnimation, useHoverLayer);
      }
      if (textGuide) {
        textGuide.useStates(states, noAnimation, useHoverLayer);
      }
      this._updateAnimationTargets();
      this.currentStates = states.slice();
      this.markRedraw();
      if (!useHoverLayer && this.__inHover) {
        this._toggleHoverLayerFlag(false);
        this.__dirty &= ~REDRAW_BIT;
      }
    }
  }
  isSilent() {
    let isSilent = this.silent;
    let ancestor = this.parent;
    while (!isSilent && ancestor) {
      if (ancestor.silent) {
        isSilent = true;
        break;
      }
      ancestor = ancestor.parent;
    }
    return isSilent;
  }
  _updateAnimationTargets() {
    for (let i = 0; i < this.animators.length; i++) {
      const animator = this.animators[i];
      if (animator.targetName) {
        animator.changeTarget(this[animator.targetName]);
      }
    }
  }
  removeState(state) {
    const idx = indexOf(this.currentStates, state);
    if (idx >= 0) {
      const currentStates = this.currentStates.slice();
      currentStates.splice(idx, 1);
      this.useStates(currentStates);
    }
  }
  replaceState(oldState, newState, forceAdd) {
    const currentStates = this.currentStates.slice();
    const idx = indexOf(currentStates, oldState);
    const newStateExists = indexOf(currentStates, newState) >= 0;
    if (idx >= 0) {
      if (!newStateExists) {
        currentStates[idx] = newState;
      } else {
        currentStates.splice(idx, 1);
      }
    } else if (forceAdd && !newStateExists) {
      currentStates.push(newState);
    }
    this.useStates(currentStates);
  }
  toggleState(state, enable) {
    if (enable) {
      this.useState(state, true);
    } else {
      this.removeState(state);
    }
  }
  _mergeStates(states) {
    const mergedState = {};
    let mergedTextConfig;
    for (let i = 0; i < states.length; i++) {
      const state = states[i];
      extend(mergedState, state);
      if (state.textConfig) {
        mergedTextConfig = mergedTextConfig || {};
        extend(mergedTextConfig, state.textConfig);
      }
    }
    if (mergedTextConfig) {
      mergedState.textConfig = mergedTextConfig;
    }
    return mergedState;
  }
  _applyStateObj(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
    const needsRestoreToNormal = !(state && keepCurrentStates);
    if (state && state.textConfig) {
      this.textConfig = extend({}, keepCurrentStates ? this.textConfig : normalState.textConfig);
      extend(this.textConfig, state.textConfig);
    } else if (needsRestoreToNormal) {
      if (normalState.textConfig) {
        this.textConfig = normalState.textConfig;
      }
    }
    const transitionTarget = {};
    let hasTransition = false;
    for (let i = 0; i < PRIMARY_STATES_KEYS.length; i++) {
      const key = PRIMARY_STATES_KEYS[i];
      const propNeedsTransition = transition && DEFAULT_ANIMATABLE_MAP[key];
      if (state && state[key] != null) {
        if (propNeedsTransition) {
          hasTransition = true;
          transitionTarget[key] = state[key];
        } else {
          this[key] = state[key];
        }
      } else if (needsRestoreToNormal) {
        if (normalState[key] != null) {
          if (propNeedsTransition) {
            hasTransition = true;
            transitionTarget[key] = normalState[key];
          } else {
            this[key] = normalState[key];
          }
        }
      }
    }
    if (!transition) {
      for (let i = 0; i < this.animators.length; i++) {
        const animator = this.animators[i];
        const targetName = animator.targetName;
        if (!animator.getLoop()) {
          animator.__changeFinalValue(targetName ? (state || normalState)[targetName] : state || normalState);
        }
      }
    }
    if (hasTransition) {
      this._transitionState(stateName, transitionTarget, animationCfg);
    }
  }
  _attachComponent(componentEl) {
    if (componentEl.__zr && !componentEl.__hostTarget) {
      if (true) {
        throw new Error("Text element has been added to zrender.");
      }
      return;
    }
    if (componentEl === this) {
      if (true) {
        throw new Error("Recursive component attachment.");
      }
      return;
    }
    const zr = this.__zr;
    if (zr) {
      componentEl.addSelfToZr(zr);
    }
    componentEl.__zr = zr;
    componentEl.__hostTarget = this;
  }
  _detachComponent(componentEl) {
    if (componentEl.__zr) {
      componentEl.removeSelfFromZr(componentEl.__zr);
    }
    componentEl.__zr = null;
    componentEl.__hostTarget = null;
  }
  getClipPath() {
    return this._clipPath;
  }
  setClipPath(clipPath) {
    if (this._clipPath && this._clipPath !== clipPath) {
      this.removeClipPath();
    }
    this._attachComponent(clipPath);
    this._clipPath = clipPath;
    this.markRedraw();
  }
  removeClipPath() {
    const clipPath = this._clipPath;
    if (clipPath) {
      this._detachComponent(clipPath);
      this._clipPath = null;
      this.markRedraw();
    }
  }
  getTextContent() {
    return this._textContent;
  }
  setTextContent(textEl) {
    const previousTextContent = this._textContent;
    if (previousTextContent === textEl) {
      return;
    }
    if (previousTextContent && previousTextContent !== textEl) {
      this.removeTextContent();
    }
    if (true) {
      if (textEl.__zr && !textEl.__hostTarget) {
        throw new Error("Text element has been added to zrender.");
      }
    }
    textEl.innerTransformable = new Transformable_default();
    this._attachComponent(textEl);
    this._textContent = textEl;
    this.markRedraw();
  }
  setTextConfig(cfg) {
    if (!this.textConfig) {
      this.textConfig = {};
    }
    extend(this.textConfig, cfg);
    this.markRedraw();
  }
  removeTextConfig() {
    this.textConfig = null;
    this.markRedraw();
  }
  removeTextContent() {
    const textEl = this._textContent;
    if (textEl) {
      textEl.innerTransformable = null;
      this._detachComponent(textEl);
      this._textContent = null;
      this._innerTextDefaultStyle = null;
      this.markRedraw();
    }
  }
  getTextGuideLine() {
    return this._textGuide;
  }
  setTextGuideLine(guideLine) {
    if (this._textGuide && this._textGuide !== guideLine) {
      this.removeTextGuideLine();
    }
    this._attachComponent(guideLine);
    this._textGuide = guideLine;
    this.markRedraw();
  }
  removeTextGuideLine() {
    const textGuide = this._textGuide;
    if (textGuide) {
      this._detachComponent(textGuide);
      this._textGuide = null;
      this.markRedraw();
    }
  }
  markRedraw() {
    this.__dirty |= REDRAW_BIT;
    const zr = this.__zr;
    if (zr) {
      if (this.__inHover) {
        zr.refreshHover();
      } else {
        zr.refresh();
      }
    }
    if (this.__hostTarget) {
      this.__hostTarget.markRedraw();
    }
  }
  dirty() {
    this.markRedraw();
  }
  _toggleHoverLayerFlag(inHover) {
    this.__inHover = inHover;
    const textContent = this._textContent;
    const textGuide = this._textGuide;
    if (textContent) {
      textContent.__inHover = inHover;
    }
    if (textGuide) {
      textGuide.__inHover = inHover;
    }
  }
  addSelfToZr(zr) {
    if (this.__zr === zr) {
      return;
    }
    this.__zr = zr;
    const animators = this.animators;
    if (animators) {
      for (let i = 0; i < animators.length; i++) {
        zr.animation.addAnimator(animators[i]);
      }
    }
    if (this._clipPath) {
      this._clipPath.addSelfToZr(zr);
    }
    if (this._textContent) {
      this._textContent.addSelfToZr(zr);
    }
    if (this._textGuide) {
      this._textGuide.addSelfToZr(zr);
    }
  }
  removeSelfFromZr(zr) {
    if (!this.__zr) {
      return;
    }
    this.__zr = null;
    const animators = this.animators;
    if (animators) {
      for (let i = 0; i < animators.length; i++) {
        zr.animation.removeAnimator(animators[i]);
      }
    }
    if (this._clipPath) {
      this._clipPath.removeSelfFromZr(zr);
    }
    if (this._textContent) {
      this._textContent.removeSelfFromZr(zr);
    }
    if (this._textGuide) {
      this._textGuide.removeSelfFromZr(zr);
    }
  }
  animate(key, loop, allowDiscreteAnimation) {
    let target = key ? this[key] : this;
    if (true) {
      if (!target) {
        logError('Property "' + key + '" is not existed in element ' + this.id);
        return;
      }
    }
    const animator = new Animator_default(target, loop, allowDiscreteAnimation);
    key && (animator.targetName = key);
    this.addAnimator(animator, key);
    return animator;
  }
  addAnimator(animator, key) {
    const zr = this.__zr;
    const el = this;
    animator.during(function() {
      el.updateDuringAnimation(key);
    }).done(function() {
      const animators = el.animators;
      const idx = indexOf(animators, animator);
      if (idx >= 0) {
        animators.splice(idx, 1);
      }
    });
    this.animators.push(animator);
    if (zr) {
      zr.animation.addAnimator(animator);
    }
    zr && zr.wakeUp();
  }
  updateDuringAnimation(key) {
    this.markRedraw();
  }
  stopAnimation(scope, forwardToLast) {
    const animators = this.animators;
    const len2 = animators.length;
    const leftAnimators = [];
    for (let i = 0; i < len2; i++) {
      const animator = animators[i];
      if (!scope || scope === animator.scope) {
        animator.stop(forwardToLast);
      } else {
        leftAnimators.push(animator);
      }
    }
    this.animators = leftAnimators;
    return this;
  }
  animateTo(target, cfg, animationProps) {
    animateTo(this, target, cfg, animationProps);
  }
  animateFrom(target, cfg, animationProps) {
    animateTo(this, target, cfg, animationProps, true);
  }
  _transitionState(stateName, target, cfg, animationProps) {
    const animators = animateTo(this, target, cfg, animationProps);
    for (let i = 0; i < animators.length; i++) {
      animators[i].__fromStateTransition = stateName;
    }
  }
  getBoundingRect() {
    return null;
  }
  getPaintRect() {
    return null;
  }
};
var Element = Element2;
Element.initDefaultProps = function() {
  const elProto = Element2.prototype;
  elProto.type = "element";
  elProto.name = "";
  elProto.ignore = elProto.silent = elProto.isGroup = elProto.draggable = elProto.dragging = elProto.ignoreClip = elProto.__inHover = false;
  elProto.__dirty = REDRAW_BIT;
  const logs = {};
  function logDeprecatedError(key, xKey, yKey) {
    if (!logs[key + xKey + yKey]) {
      console.warn(`DEPRECATED: '${key}' has been deprecated. use '${xKey}', '${yKey}' instead`);
      logs[key + xKey + yKey] = true;
    }
  }
  function createLegacyProperty(key, privateKey, xKey, yKey) {
    Object.defineProperty(elProto, key, {
      get() {
        if (true) {
          logDeprecatedError(key, xKey, yKey);
        }
        if (!this[privateKey]) {
          const pos = this[privateKey] = [];
          enhanceArray(this, pos);
        }
        return this[privateKey];
      },
      set(pos) {
        if (true) {
          logDeprecatedError(key, xKey, yKey);
        }
        this[xKey] = pos[0];
        this[yKey] = pos[1];
        this[privateKey] = pos;
        enhanceArray(this, pos);
      }
    });
    function enhanceArray(self2, pos) {
      Object.defineProperty(pos, 0, {
        get() {
          return self2[xKey];
        },
        set(val) {
          self2[xKey] = val;
        }
      });
      Object.defineProperty(pos, 1, {
        get() {
          return self2[yKey];
        },
        set(val) {
          self2[yKey] = val;
        }
      });
    }
  }
  if (Object.defineProperty) {
    createLegacyProperty("position", "_legacyPos", "x", "y");
    createLegacyProperty("scale", "_legacyScale", "scaleX", "scaleY");
    createLegacyProperty("origin", "_legacyOrigin", "originX", "originY");
  }
}();
mixin(Element, Eventful_default);
mixin(Element, Transformable_default);
function animateTo(animatable, target, cfg, animationProps, reverse2) {
  cfg = cfg || {};
  const animators = [];
  animateToShallow(animatable, "", animatable, target, cfg, animationProps, animators, reverse2);
  let finishCount = animators.length;
  let doneHappened = false;
  const cfgDone = cfg.done;
  const cfgAborted = cfg.aborted;
  const doneCb = () => {
    doneHappened = true;
    finishCount--;
    if (finishCount <= 0) {
      doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();
    }
  };
  const abortedCb = () => {
    finishCount--;
    if (finishCount <= 0) {
      doneHappened ? cfgDone && cfgDone() : cfgAborted && cfgAborted();
    }
  };
  if (!finishCount) {
    cfgDone && cfgDone();
  }
  if (animators.length > 0 && cfg.during) {
    animators[0].during((target2, percent) => {
      cfg.during(percent);
    });
  }
  for (let i = 0; i < animators.length; i++) {
    const animator = animators[i];
    if (doneCb) {
      animator.done(doneCb);
    }
    if (abortedCb) {
      animator.aborted(abortedCb);
    }
    if (cfg.force) {
      animator.duration(cfg.duration);
    }
    animator.start(cfg.easing);
  }
  return animators;
}
function copyArrShallow(source, target, len2) {
  for (let i = 0; i < len2; i++) {
    source[i] = target[i];
  }
}
function is2DArray(value) {
  return isArrayLike(value[0]);
}
function copyValue(target, source, key) {
  if (isArrayLike(source[key])) {
    if (!isArrayLike(target[key])) {
      target[key] = [];
    }
    if (isTypedArray(source[key])) {
      const len2 = source[key].length;
      if (target[key].length !== len2) {
        target[key] = new source[key].constructor(len2);
        copyArrShallow(target[key], source[key], len2);
      }
    } else {
      const sourceArr = source[key];
      const targetArr = target[key];
      const len0 = sourceArr.length;
      if (is2DArray(sourceArr)) {
        const len1 = sourceArr[0].length;
        for (let i = 0; i < len0; i++) {
          if (!targetArr[i]) {
            targetArr[i] = Array.prototype.slice.call(sourceArr[i]);
          } else {
            copyArrShallow(targetArr[i], sourceArr[i], len1);
          }
        }
      } else {
        copyArrShallow(targetArr, sourceArr, len0);
      }
      targetArr.length = sourceArr.length;
    }
  } else {
    target[key] = source[key];
  }
}
function isValueSame(val1, val2) {
  return val1 === val2 || isArrayLike(val1) && isArrayLike(val2) && is1DArraySame(val1, val2);
}
function is1DArraySame(arr0, arr1) {
  const len2 = arr0.length;
  if (len2 !== arr1.length) {
    return false;
  }
  for (let i = 0; i < len2; i++) {
    if (arr0[i] !== arr1[i]) {
      return false;
    }
  }
  return true;
}
function animateToShallow(animatable, topKey, animateObj, target, cfg, animationProps, animators, reverse2) {
  const targetKeys = keys(target);
  const duration = cfg.duration;
  const delay = cfg.delay;
  const additive = cfg.additive;
  const setToFinal = cfg.setToFinal;
  const animateAll = !isObject(animationProps);
  const existsAnimators = animatable.animators;
  let animationKeys = [];
  for (let k = 0; k < targetKeys.length; k++) {
    const innerKey = targetKeys[k];
    const targetVal = target[innerKey];
    if (targetVal != null && animateObj[innerKey] != null && (animateAll || animationProps[innerKey])) {
      if (isObject(targetVal) && !isArrayLike(targetVal) && !isGradientObject(targetVal)) {
        if (topKey) {
          if (!reverse2) {
            animateObj[innerKey] = targetVal;
            animatable.updateDuringAnimation(topKey);
          }
          continue;
        }
        animateToShallow(animatable, innerKey, animateObj[innerKey], targetVal, cfg, animationProps && animationProps[innerKey], animators, reverse2);
      } else {
        animationKeys.push(innerKey);
      }
    } else if (!reverse2) {
      animateObj[innerKey] = targetVal;
      animatable.updateDuringAnimation(topKey);
      animationKeys.push(innerKey);
    }
  }
  let keyLen = animationKeys.length;
  if (!additive && keyLen) {
    for (let i = 0; i < existsAnimators.length; i++) {
      const animator = existsAnimators[i];
      if (animator.targetName === topKey) {
        const allAborted = animator.stopTracks(animationKeys);
        if (allAborted) {
          const idx = indexOf(existsAnimators, animator);
          existsAnimators.splice(idx, 1);
        }
      }
    }
  }
  if (!cfg.force) {
    animationKeys = filter(animationKeys, (key) => !isValueSame(target[key], animateObj[key]));
    keyLen = animationKeys.length;
  }
  if (keyLen > 0 || cfg.force && !animators.length) {
    let revertedSource;
    let reversedTarget;
    let sourceClone;
    if (reverse2) {
      reversedTarget = {};
      if (setToFinal) {
        revertedSource = {};
      }
      for (let i = 0; i < keyLen; i++) {
        const innerKey = animationKeys[i];
        reversedTarget[innerKey] = animateObj[innerKey];
        if (setToFinal) {
          revertedSource[innerKey] = target[innerKey];
        } else {
          animateObj[innerKey] = target[innerKey];
        }
      }
    } else if (setToFinal) {
      sourceClone = {};
      for (let i = 0; i < keyLen; i++) {
        const innerKey = animationKeys[i];
        sourceClone[innerKey] = cloneValue(animateObj[innerKey]);
        copyValue(animateObj, target, innerKey);
      }
    }
    const animator = new Animator_default(animateObj, false, false, additive ? filter(existsAnimators, (animator2) => animator2.targetName === topKey) : null);
    animator.targetName = topKey;
    if (cfg.scope) {
      animator.scope = cfg.scope;
    }
    if (setToFinal && revertedSource) {
      animator.whenWithKeys(0, revertedSource, animationKeys);
    }
    if (sourceClone) {
      animator.whenWithKeys(0, sourceClone, animationKeys);
    }
    animator.whenWithKeys(duration == null ? 500 : duration, reverse2 ? reversedTarget : target, animationKeys).delay(delay || 0);
    animatable.addAnimator(animator, topKey);
    animators.push(animator);
  }
}
var Element_default = Element;

// node_modules/zrender/src/graphic/Group.ts
var Group = class extends Element_default {
  constructor(opts) {
    super();
    this.isGroup = true;
    this._children = [];
    this.attr(opts);
  }
  childrenRef() {
    return this._children;
  }
  children() {
    return this._children.slice();
  }
  childAt(idx) {
    return this._children[idx];
  }
  childOfName(name) {
    const children = this._children;
    for (let i = 0; i < children.length; i++) {
      if (children[i].name === name) {
        return children[i];
      }
    }
  }
  childCount() {
    return this._children.length;
  }
  add(child) {
    if (child) {
      if (child !== this && child.parent !== this) {
        this._children.push(child);
        this._doAdd(child);
      }
      if (true) {
        if (child.__hostTarget) {
          throw "This elemenet has been used as an attachment";
        }
      }
    }
    return this;
  }
  addBefore(child, nextSibling2) {
    if (child && child !== this && child.parent !== this && nextSibling2 && nextSibling2.parent === this) {
      const children = this._children;
      const idx = children.indexOf(nextSibling2);
      if (idx >= 0) {
        children.splice(idx, 0, child);
        this._doAdd(child);
      }
    }
    return this;
  }
  replace(oldChild, newChild) {
    const idx = indexOf(this._children, oldChild);
    if (idx >= 0) {
      this.replaceAt(newChild, idx);
    }
    return this;
  }
  replaceAt(child, index) {
    const children = this._children;
    const old = children[index];
    if (child && child !== this && child.parent !== this && child !== old) {
      children[index] = child;
      old.parent = null;
      const zr = this.__zr;
      if (zr) {
        old.removeSelfFromZr(zr);
      }
      this._doAdd(child);
    }
    return this;
  }
  _doAdd(child) {
    if (child.parent) {
      child.parent.remove(child);
    }
    child.parent = this;
    const zr = this.__zr;
    if (zr && zr !== child.__zr) {
      child.addSelfToZr(zr);
    }
    zr && zr.refresh();
  }
  remove(child) {
    const zr = this.__zr;
    const children = this._children;
    const idx = indexOf(children, child);
    if (idx < 0) {
      return this;
    }
    children.splice(idx, 1);
    child.parent = null;
    if (zr) {
      child.removeSelfFromZr(zr);
    }
    zr && zr.refresh();
    return this;
  }
  removeAll() {
    const children = this._children;
    const zr = this.__zr;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (zr) {
        child.removeSelfFromZr(zr);
      }
      child.parent = null;
    }
    children.length = 0;
    return this;
  }
  eachChild(cb, context) {
    const children = this._children;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      cb.call(context, child, i);
    }
    return this;
  }
  traverse(cb, context) {
    for (let i = 0; i < this._children.length; i++) {
      const child = this._children[i];
      const stopped = cb.call(context, child);
      if (child.isGroup && !stopped) {
        child.traverse(cb, context);
      }
    }
    return this;
  }
  addSelfToZr(zr) {
    super.addSelfToZr(zr);
    for (let i = 0; i < this._children.length; i++) {
      const child = this._children[i];
      child.addSelfToZr(zr);
    }
  }
  removeSelfFromZr(zr) {
    super.removeSelfFromZr(zr);
    for (let i = 0; i < this._children.length; i++) {
      const child = this._children[i];
      child.removeSelfFromZr(zr);
    }
  }
  getBoundingRect(includeChildren) {
    const tmpRect3 = new BoundingRect_default(0, 0, 0, 0);
    const children = includeChildren || this._children;
    const tmpMat = [];
    let rect = null;
    for (let i = 0; i < children.length; i++) {
      const child = children[i];
      if (child.ignore || child.invisible) {
        continue;
      }
      const childRect = child.getBoundingRect();
      const transform2 = child.getLocalTransform(tmpMat);
      if (transform2) {
        BoundingRect_default.applyTransform(tmpRect3, childRect, transform2);
        rect = rect || tmpRect3.clone();
        rect.union(tmpRect3);
      } else {
        rect = rect || childRect.clone();
        rect.union(childRect);
      }
    }
    return rect || tmpRect3;
  }
};
Group.prototype.type = "group";
var Group_default = Group;

// node_modules/zrender/src/zrender.ts
/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var painterCtors = {};
var instances = {};
function delInstance(id) {
  delete instances[id];
}
function isDarkMode(backgroundColor2) {
  if (!backgroundColor2) {
    return false;
  }
  if (typeof backgroundColor2 === "string") {
    return lum(backgroundColor2, 1) < DARK_MODE_THRESHOLD;
  } else if (backgroundColor2.colorStops) {
    const colorStops = backgroundColor2.colorStops;
    let totalLum = 0;
    const len2 = colorStops.length;
    for (let i = 0; i < len2; i++) {
      totalLum += lum(colorStops[i].color, 1);
    }
    totalLum /= len2;
    return totalLum < DARK_MODE_THRESHOLD;
  }
  return false;
}
var ZRender = class {
  constructor(id, dom, opts) {
    this._sleepAfterStill = 10;
    this._stillFrameAccum = 0;
    this._needsRefresh = true;
    this._needsRefreshHover = true;
    this._darkMode = false;
    opts = opts || {};
    this.dom = dom;
    this.id = id;
    const storage2 = new Storage_default();
    let rendererType = opts.renderer || "canvas";
    if (!painterCtors[rendererType]) {
      rendererType = keys(painterCtors)[0];
    }
    if (true) {
      if (!painterCtors[rendererType]) {
        throw new Error(`Renderer '${rendererType}' is not imported. Please import it first.`);
      }
    }
    opts.useDirtyRect = opts.useDirtyRect == null ? false : opts.useDirtyRect;
    const painter = new painterCtors[rendererType](dom, storage2, opts, id);
    const ssrMode = opts.ssr || painter.ssrOnly;
    this.storage = storage2;
    this.painter = painter;
    const handlerProxy = !env_default.node && !env_default.worker && !ssrMode ? new HandlerProxy_default(painter.getViewportRoot(), painter.root) : null;
    const useCoarsePointer = opts.useCoarsePointer;
    const usePointerSize = useCoarsePointer == null || useCoarsePointer === "auto" ? env_default.touchEventsSupported : !!useCoarsePointer;
    const defaultPointerSize = 44;
    let pointerSize;
    if (usePointerSize) {
      pointerSize = retrieve2(opts.pointerSize, defaultPointerSize);
    }
    this.handler = new Handler_default(storage2, painter, handlerProxy, painter.root, pointerSize);
    this.animation = new Animation_default({
      stage: {
        update: ssrMode ? null : () => this._flush(true)
      }
    });
    if (!ssrMode) {
      this.animation.start();
    }
  }
  add(el) {
    if (this._disposed || !el) {
      return;
    }
    this.storage.addRoot(el);
    el.addSelfToZr(this);
    this.refresh();
  }
  remove(el) {
    if (this._disposed || !el) {
      return;
    }
    this.storage.delRoot(el);
    el.removeSelfFromZr(this);
    this.refresh();
  }
  configLayer(zLevel, config) {
    if (this._disposed) {
      return;
    }
    if (this.painter.configLayer) {
      this.painter.configLayer(zLevel, config);
    }
    this.refresh();
  }
  setBackgroundColor(backgroundColor2) {
    if (this._disposed) {
      return;
    }
    if (this.painter.setBackgroundColor) {
      this.painter.setBackgroundColor(backgroundColor2);
    }
    this.refresh();
    this._backgroundColor = backgroundColor2;
    this._darkMode = isDarkMode(backgroundColor2);
  }
  getBackgroundColor() {
    return this._backgroundColor;
  }
  setDarkMode(darkMode) {
    this._darkMode = darkMode;
  }
  isDarkMode() {
    return this._darkMode;
  }
  refreshImmediately(fromInside) {
    if (this._disposed) {
      return;
    }
    if (!fromInside) {
      this.animation.update(true);
    }
    this._needsRefresh = false;
    this.painter.refresh();
    this._needsRefresh = false;
  }
  refresh() {
    if (this._disposed) {
      return;
    }
    this._needsRefresh = true;
    this.animation.start();
  }
  flush() {
    if (this._disposed) {
      return;
    }
    this._flush(false);
  }
  _flush(fromInside) {
    let triggerRendered;
    const start2 = getTime();
    if (this._needsRefresh) {
      triggerRendered = true;
      this.refreshImmediately(fromInside);
    }
    if (this._needsRefreshHover) {
      triggerRendered = true;
      this.refreshHoverImmediately();
    }
    const end2 = getTime();
    if (triggerRendered) {
      this._stillFrameAccum = 0;
      this.trigger("rendered", {
        elapsedTime: end2 - start2
      });
    } else if (this._sleepAfterStill > 0) {
      this._stillFrameAccum++;
      if (this._stillFrameAccum > this._sleepAfterStill) {
        this.animation.stop();
      }
    }
  }
  setSleepAfterStill(stillFramesCount) {
    this._sleepAfterStill = stillFramesCount;
  }
  wakeUp() {
    if (this._disposed) {
      return;
    }
    this.animation.start();
    this._stillFrameAccum = 0;
  }
  refreshHover() {
    this._needsRefreshHover = true;
  }
  refreshHoverImmediately() {
    if (this._disposed) {
      return;
    }
    this._needsRefreshHover = false;
    if (this.painter.refreshHover && this.painter.getType() === "canvas") {
      this.painter.refreshHover();
    }
  }
  resize(opts) {
    if (this._disposed) {
      return;
    }
    opts = opts || {};
    this.painter.resize(opts.width, opts.height);
    this.handler.resize();
  }
  clearAnimation() {
    if (this._disposed) {
      return;
    }
    this.animation.clear();
  }
  getWidth() {
    if (this._disposed) {
      return;
    }
    return this.painter.getWidth();
  }
  getHeight() {
    if (this._disposed) {
      return;
    }
    return this.painter.getHeight();
  }
  setCursorStyle(cursorStyle) {
    if (this._disposed) {
      return;
    }
    this.handler.setCursorStyle(cursorStyle);
  }
  findHover(x, y) {
    if (this._disposed) {
      return;
    }
    return this.handler.findHover(x, y);
  }
  on(eventName, eventHandler, context) {
    if (!this._disposed) {
      this.handler.on(eventName, eventHandler, context);
    }
    return this;
  }
  off(eventName, eventHandler) {
    if (this._disposed) {
      return;
    }
    this.handler.off(eventName, eventHandler);
  }
  trigger(eventName, event) {
    if (this._disposed) {
      return;
    }
    this.handler.trigger(eventName, event);
  }
  clear() {
    if (this._disposed) {
      return;
    }
    const roots2 = this.storage.getRoots();
    for (let i = 0; i < roots2.length; i++) {
      if (roots2[i] instanceof Group_default) {
        roots2[i].removeSelfFromZr(this);
      }
    }
    this.storage.delAllRoots();
    this.painter.clear();
  }
  dispose() {
    if (this._disposed) {
      return;
    }
    this.animation.stop();
    this.clear();
    this.storage.dispose();
    this.painter.dispose();
    this.handler.dispose();
    this.animation = this.storage = this.painter = this.handler = null;
    this._disposed = true;
    delInstance(this.id);
  }
};
function init(dom, opts) {
  const zr = new ZRender(guid(), dom, opts);
  instances[zr.id] = zr;
  return zr;
}
function dispose(zr) {
  zr.dispose();
}
function disposeAll() {
  for (let key in instances) {
    if (instances.hasOwnProperty(key)) {
      instances[key].dispose();
    }
  }
  instances = {};
}
function getInstance(id) {
  return instances[id];
}
function registerPainter(name, Ctor) {
  painterCtors[name] = Ctor;
}
var ssrDataGetter;
function getElementSSRData(el) {
  if (typeof ssrDataGetter === "function") {
    return ssrDataGetter(el);
  }
}
function registerSSRDataGetter(getter) {
  ssrDataGetter = getter;
}
var version = "5.5.0";

// src/util/number.ts
var RADIAN_EPSILON = 1e-4;
var ROUND_SUPPORTED_PRECISION_MAX = 20;
function _trim(str) {
  return str.replace(/^\s+|\s+$/g, "");
}
function linearMap(val, domain, range, clamp2) {
  const d0 = domain[0];
  const d1 = domain[1];
  const r0 = range[0];
  const r1 = range[1];
  const subDomain = d1 - d0;
  const subRange = r1 - r0;
  if (subDomain === 0) {
    return subRange === 0 ? r0 : (r0 + r1) / 2;
  }
  if (clamp2) {
    if (subDomain > 0) {
      if (val <= d0) {
        return r0;
      } else if (val >= d1) {
        return r1;
      }
    } else {
      if (val >= d0) {
        return r0;
      } else if (val <= d1) {
        return r1;
      }
    }
  } else {
    if (val === d0) {
      return r0;
    }
    if (val === d1) {
      return r1;
    }
  }
  return (val - d0) / subDomain * subRange + r0;
}
function parsePercent2(percent, all) {
  switch (percent) {
    case "center":
    case "middle":
      percent = "50%";
      break;
    case "left":
    case "top":
      percent = "0%";
      break;
    case "right":
    case "bottom":
      percent = "100%";
      break;
  }
  if (isString(percent)) {
    if (_trim(percent).match(/%$/)) {
      return parseFloat(percent) / 100 * all;
    }
    return parseFloat(percent);
  }
  return percent == null ? NaN : +percent;
}
function round(x, precision, returnStr) {
  if (precision == null) {
    precision = 10;
  }
  precision = Math.min(Math.max(0, precision), ROUND_SUPPORTED_PRECISION_MAX);
  x = (+x).toFixed(precision);
  return returnStr ? x : +x;
}
function asc(arr) {
  arr.sort(function(a, b) {
    return a - b;
  });
  return arr;
}
function getPrecision(val) {
  val = +val;
  if (isNaN(val)) {
    return 0;
  }
  if (val > 1e-14) {
    let e2 = 1;
    for (let i = 0; i < 15; i++, e2 *= 10) {
      if (Math.round(val * e2) / e2 === val) {
        return i;
      }
    }
  }
  return getPrecisionSafe(val);
}
function getPrecisionSafe(val) {
  const str = val.toString().toLowerCase();
  const eIndex = str.indexOf("e");
  const exp = eIndex > 0 ? +str.slice(eIndex + 1) : 0;
  const significandPartLen = eIndex > 0 ? eIndex : str.length;
  const dotIndex = str.indexOf(".");
  const decimalPartLen = dotIndex < 0 ? 0 : significandPartLen - 1 - dotIndex;
  return Math.max(0, decimalPartLen - exp);
}
function getPixelPrecision(dataExtent, pixelExtent) {
  const log2 = Math.log;
  const LN10 = Math.LN10;
  const dataQuantity = Math.floor(log2(dataExtent[1] - dataExtent[0]) / LN10);
  const sizeQuantity = Math.round(log2(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);
  const precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
  return !isFinite(precision) ? 20 : precision;
}
function getPercentWithPrecision(valueList, idx, precision) {
  if (!valueList[idx]) {
    return 0;
  }
  const seats = getPercentSeats(valueList, precision);
  return seats[idx] || 0;
}
function getPercentSeats(valueList, precision) {
  const sum2 = reduce(valueList, function(acc, val) {
    return acc + (isNaN(val) ? 0 : val);
  }, 0);
  if (sum2 === 0) {
    return [];
  }
  const digits = Math.pow(10, precision);
  const votesPerQuota = map(valueList, function(val) {
    return (isNaN(val) ? 0 : val) / sum2 * digits * 100;
  });
  const targetSeats = digits * 100;
  const seats = map(votesPerQuota, function(votes) {
    return Math.floor(votes);
  });
  let currentSum = reduce(seats, function(acc, val) {
    return acc + val;
  }, 0);
  const remainder = map(votesPerQuota, function(votes, idx) {
    return votes - seats[idx];
  });
  while (currentSum < targetSeats) {
    let max3 = Number.NEGATIVE_INFINITY;
    let maxId = null;
    for (let i = 0, len2 = remainder.length; i < len2; ++i) {
      if (remainder[i] > max3) {
        max3 = remainder[i];
        maxId = i;
      }
    }
    ++seats[maxId];
    remainder[maxId] = 0;
    ++currentSum;
  }
  return map(seats, function(seat) {
    return seat / digits;
  });
}
function addSafe(val0, val1) {
  const maxPrecision = Math.max(getPrecision(val0), getPrecision(val1));
  const sum2 = val0 + val1;
  return maxPrecision > ROUND_SUPPORTED_PRECISION_MAX ? sum2 : round(sum2, maxPrecision);
}
var MAX_SAFE_INTEGER = 9007199254740991;
function remRadian(radian) {
  const pi2 = Math.PI * 2;
  return (radian % pi2 + pi2) % pi2;
}
function isRadianAroundZero(val) {
  return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
}
var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function parseDate(value) {
  if (value instanceof Date) {
    return value;
  } else if (isString(value)) {
    const match = TIME_REG.exec(value);
    if (!match) {
      return new Date(NaN);
    }
    if (!match[8]) {
      return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0);
    } else {
      let hour = +match[4] || 0;
      if (match[8].toUpperCase() !== "Z") {
        hour -= +match[8].slice(0, 3);
      }
      return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0));
    }
  } else if (value == null) {
    return new Date(NaN);
  }
  return new Date(Math.round(value));
}
function quantity(val) {
  return Math.pow(10, quantityExponent(val));
}
function quantityExponent(val) {
  if (val === 0) {
    return 0;
  }
  let exp = Math.floor(Math.log(val) / Math.LN10);
  if (val / Math.pow(10, exp) >= 10) {
    exp++;
  }
  return exp;
}
function nice(val, round7) {
  const exponent = quantityExponent(val);
  const exp10 = Math.pow(10, exponent);
  const f = val / exp10;
  let nf;
  if (round7) {
    if (f < 1.5) {
      nf = 1;
    } else if (f < 2.5) {
      nf = 2;
    } else if (f < 4) {
      nf = 3;
    } else if (f < 7) {
      nf = 5;
    } else {
      nf = 10;
    }
  } else {
    if (f < 1) {
      nf = 1;
    } else if (f < 2) {
      nf = 2;
    } else if (f < 3) {
      nf = 3;
    } else if (f < 5) {
      nf = 5;
    } else {
      nf = 10;
    }
  }
  val = nf * exp10;
  return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
}
function quantile(ascArr, p) {
  const H = (ascArr.length - 1) * p + 1;
  const h = Math.floor(H);
  const v = +ascArr[h - 1];
  const e2 = H - h;
  return e2 ? v + e2 * (ascArr[h] - v) : v;
}
function reformIntervals(list) {
  list.sort(function(a, b) {
    return littleThan2(a, b, 0) ? -1 : 1;
  });
  let curr = -Infinity;
  let currClose = 1;
  for (let i = 0; i < list.length; ) {
    const interval = list[i].interval;
    const close = list[i].close;
    for (let lg = 0; lg < 2; lg++) {
      if (interval[lg] <= curr) {
        interval[lg] = curr;
        close[lg] = !lg ? 1 - currClose : 1;
      }
      curr = interval[lg];
      currClose = close[lg];
    }
    if (interval[0] === interval[1] && close[0] * close[1] !== 1) {
      list.splice(i, 1);
    } else {
      i++;
    }
  }
  return list;
  function littleThan2(a, b, lg) {
    return a.interval[lg] < b.interval[lg] || a.interval[lg] === b.interval[lg] && (a.close[lg] - b.close[lg] === (!lg ? 1 : -1) || !lg && littleThan2(a, b, 1));
  }
}
function numericToNumber(val) {
  const valFloat = parseFloat(val);
  return valFloat == val && (valFloat !== 0 || !isString(val) || val.indexOf("x") <= 0) ? valFloat : NaN;
}
function isNumeric(val) {
  return !isNaN(numericToNumber(val));
}
function getRandomIdBase() {
  return Math.round(Math.random() * 9);
}
function getGreatestCommonDividor(a, b) {
  if (b === 0) {
    return a;
  }
  return getGreatestCommonDividor(b, a % b);
}
function getLeastCommonMultiple(a, b) {
  if (a == null) {
    return b;
  }
  if (b == null) {
    return a;
  }
  return a * b / getGreatestCommonDividor(a, b);
}

// src/util/log.ts
var ECHARTS_PREFIX = "[ECharts] ";
var storedLogs = {};
var hasConsole = typeof console !== "undefined" && console.warn && console.log;
function outputLog(type, str, onlyOnce) {
  if (hasConsole) {
    if (onlyOnce) {
      if (storedLogs[str]) {
        return;
      }
      storedLogs[str] = true;
    }
    console[type](ECHARTS_PREFIX + str);
  }
}
function log(str, onlyOnce) {
  outputLog("log", str, onlyOnce);
}
function warn(str, onlyOnce) {
  outputLog("warn", str, onlyOnce);
}
function error(str, onlyOnce) {
  outputLog("error", str, onlyOnce);
}
function deprecateLog(str) {
  if (true) {
    outputLog("warn", "DEPRECATED: " + str, true);
  }
}
function deprecateReplaceLog(oldOpt, newOpt, scope) {
  if (true) {
    deprecateLog((scope ? `[${scope}]` : "") + `${oldOpt} is deprecated, use ${newOpt} instead.`);
  }
}
function makePrintable(...hintInfo) {
  let msg = "";
  if (true) {
    const makePrintableStringIfPossible = (val) => {
      return val === void 0 ? "undefined" : val === Infinity ? "Infinity" : val === -Infinity ? "-Infinity" : eqNaN(val) ? "NaN" : val instanceof Date ? "Date(" + val.toISOString() + ")" : isFunction(val) ? "function () { ... }" : isRegExp(val) ? val + "" : null;
    };
    msg = map(hintInfo, (arg) => {
      if (isString(arg)) {
        return arg;
      } else {
        const printableStr = makePrintableStringIfPossible(arg);
        if (printableStr != null) {
          return printableStr;
        } else if (typeof JSON !== "undefined" && JSON.stringify) {
          try {
            return JSON.stringify(arg, function(n, val) {
              const printableStr2 = makePrintableStringIfPossible(val);
              return printableStr2 == null ? val : printableStr2;
            });
          } catch (err) {
            return "?";
          }
        } else {
          return "?";
        }
      }
    }).join(" ");
  }
  return msg;
}
function throwError(msg) {
  throw new Error(msg);
}

// src/util/model.ts
function interpolateNumber2(p0, p1, percent) {
  return (p1 - p0) * percent + p0;
}
var DUMMY_COMPONENT_NAME_PREFIX = "series\0";
var INTERNAL_COMPONENT_ID_PREFIX = "\0_ec_\0";
function normalizeToArray(value) {
  return value instanceof Array ? value : value == null ? [] : [value];
}
function defaultEmphasis(opt, key, subOpts) {
  if (opt) {
    opt[key] = opt[key] || {};
    opt.emphasis = opt.emphasis || {};
    opt.emphasis[key] = opt.emphasis[key] || {};
    for (let i = 0, len2 = subOpts.length; i < len2; i++) {
      const subOptName = subOpts[i];
      if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {
        opt.emphasis[key][subOptName] = opt[key][subOptName];
      }
    }
  }
}
var TEXT_STYLE_OPTIONS = [
  "fontStyle",
  "fontWeight",
  "fontSize",
  "fontFamily",
  "rich",
  "tag",
  "color",
  "textBorderColor",
  "textBorderWidth",
  "width",
  "height",
  "lineHeight",
  "align",
  "verticalAlign",
  "baseline",
  "shadowColor",
  "shadowBlur",
  "shadowOffsetX",
  "shadowOffsetY",
  "textShadowColor",
  "textShadowBlur",
  "textShadowOffsetX",
  "textShadowOffsetY",
  "backgroundColor",
  "borderColor",
  "borderWidth",
  "borderRadius",
  "padding"
];
function getDataItemValue(dataItem) {
  return isObject(dataItem) && !isArray(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;
}
function isDataItemOption(dataItem) {
  return isObject(dataItem) && !(dataItem instanceof Array);
}
function mappingToExists(existings, newCmptOptions, mode) {
  const isNormalMergeMode = mode === "normalMerge";
  const isReplaceMergeMode = mode === "replaceMerge";
  const isReplaceAllMode = mode === "replaceAll";
  existings = existings || [];
  newCmptOptions = (newCmptOptions || []).slice();
  const existingIdIdxMap = createHashMap();
  each(newCmptOptions, function(cmptOption, index) {
    if (!isObject(cmptOption)) {
      newCmptOptions[index] = null;
      return;
    }
    if (true) {
      if (cmptOption.id != null && !isValidIdOrName(cmptOption.id)) {
        warnInvalidateIdOrName(cmptOption.id);
      }
      if (cmptOption.name != null && !isValidIdOrName(cmptOption.name)) {
        warnInvalidateIdOrName(cmptOption.name);
      }
    }
  });
  const result = prepareResult(existings, existingIdIdxMap, mode);
  if (isNormalMergeMode || isReplaceMergeMode) {
    mappingById(result, existings, existingIdIdxMap, newCmptOptions);
  }
  if (isNormalMergeMode) {
    mappingByName(result, newCmptOptions);
  }
  if (isNormalMergeMode || isReplaceMergeMode) {
    mappingByIndex(result, newCmptOptions, isReplaceMergeMode);
  } else if (isReplaceAllMode) {
    mappingInReplaceAllMode(result, newCmptOptions);
  }
  makeIdAndName(result);
  return result;
}
function prepareResult(existings, existingIdIdxMap, mode) {
  const result = [];
  if (mode === "replaceAll") {
    return result;
  }
  for (let index = 0; index < existings.length; index++) {
    const existing = existings[index];
    if (existing && existing.id != null) {
      existingIdIdxMap.set(existing.id, index);
    }
    result.push({
      existing: mode === "replaceMerge" || isComponentIdInternal(existing) ? null : existing,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return result;
}
function mappingById(result, existings, existingIdIdxMap, newCmptOptions) {
  each(newCmptOptions, function(cmptOption, index) {
    if (!cmptOption || cmptOption.id == null) {
      return;
    }
    const optionId = makeComparableKey(cmptOption.id);
    const existingIdx = existingIdIdxMap.get(optionId);
    if (existingIdx != null) {
      const resultItem = result[existingIdx];
      assert(!resultItem.newOption, 'Duplicated option on id "' + optionId + '".');
      resultItem.newOption = cmptOption;
      resultItem.existing = existings[existingIdx];
      newCmptOptions[index] = null;
    }
  });
}
function mappingByName(result, newCmptOptions) {
  each(newCmptOptions, function(cmptOption, index) {
    if (!cmptOption || cmptOption.name == null) {
      return;
    }
    for (let i = 0; i < result.length; i++) {
      const existing = result[i].existing;
      if (!result[i].newOption && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual("name", existing, cmptOption)) {
        result[i].newOption = cmptOption;
        newCmptOptions[index] = null;
        return;
      }
    }
  });
}
function mappingByIndex(result, newCmptOptions, brandNew) {
  each(newCmptOptions, function(cmptOption) {
    if (!cmptOption) {
      return;
    }
    let resultItem;
    let nextIdx = 0;
    while ((resultItem = result[nextIdx]) && (resultItem.newOption || isComponentIdInternal(resultItem.existing) || resultItem.existing && cmptOption.id != null && !keyExistAndEqual("id", cmptOption, resultItem.existing))) {
      nextIdx++;
    }
    if (resultItem) {
      resultItem.newOption = cmptOption;
      resultItem.brandNew = brandNew;
    } else {
      result.push({
        newOption: cmptOption,
        brandNew,
        existing: null,
        keyInfo: null
      });
    }
    nextIdx++;
  });
}
function mappingInReplaceAllMode(result, newCmptOptions) {
  each(newCmptOptions, function(cmptOption) {
    result.push({
      newOption: cmptOption,
      brandNew: true,
      existing: null,
      keyInfo: null
    });
  });
}
function makeIdAndName(mapResult) {
  const idMap = createHashMap();
  each(mapResult, function(item) {
    const existing = item.existing;
    existing && idMap.set(existing.id, item);
  });
  each(mapResult, function(item) {
    const opt = item.newOption;
    assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, "id duplicates: " + (opt && opt.id));
    opt && opt.id != null && idMap.set(opt.id, item);
    !item.keyInfo && (item.keyInfo = {});
  });
  each(mapResult, function(item, index) {
    const existing = item.existing;
    const opt = item.newOption;
    const keyInfo = item.keyInfo;
    if (!isObject(opt)) {
      return;
    }
    keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name : DUMMY_COMPONENT_NAME_PREFIX + index;
    if (existing) {
      keyInfo.id = makeComparableKey(existing.id);
    } else if (opt.id != null) {
      keyInfo.id = makeComparableKey(opt.id);
    } else {
      let idNum = 0;
      do {
        keyInfo.id = "\0" + keyInfo.name + "\0" + idNum++;
      } while (idMap.get(keyInfo.id));
    }
    idMap.set(keyInfo.id, item);
  });
}
function keyExistAndEqual(attr, obj1, obj2) {
  const key1 = convertOptionIdName(obj1[attr], null);
  const key2 = convertOptionIdName(obj2[attr], null);
  return key1 != null && key2 != null && key1 === key2;
}
function makeComparableKey(val) {
  if (true) {
    if (val == null) {
      throw new Error();
    }
  }
  return convertOptionIdName(val, "");
}
function convertOptionIdName(idOrName, defaultValue) {
  if (idOrName == null) {
    return defaultValue;
  }
  return isString(idOrName) ? idOrName : isNumber(idOrName) || isStringSafe(idOrName) ? idOrName + "" : defaultValue;
}
function warnInvalidateIdOrName(idOrName) {
  if (true) {
    warn("`" + idOrName + "` is invalid id or name. Must be a string or number.");
  }
}
function isValidIdOrName(idOrName) {
  return isStringSafe(idOrName) || isNumeric(idOrName);
}
function isNameSpecified(componentModel) {
  const name = componentModel.name;
  return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
}
function isComponentIdInternal(cmptOption) {
  return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;
}
function makeInternalComponentId(idSuffix) {
  return INTERNAL_COMPONENT_ID_PREFIX + idSuffix;
}
function setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {
  each(mappingResult, function(item) {
    const newOption = item.newOption;
    if (isObject(newOption)) {
      item.keyInfo.mainType = mainType;
      item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);
    }
  });
}
function determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {
  const subType = newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType : componentModelCtor.determineSubType(mainType, newCmptOption);
  return subType;
}
function compressBatches(batchA, batchB) {
  const mapA = {};
  const mapB = {};
  makeMap(batchA || [], mapA);
  makeMap(batchB || [], mapB, mapA);
  return [mapToArray(mapA), mapToArray(mapB)];
  function makeMap(sourceBatch, map3, otherMap) {
    for (let i = 0, len2 = sourceBatch.length; i < len2; i++) {
      const seriesId = convertOptionIdName(sourceBatch[i].seriesId, null);
      if (seriesId == null) {
        return;
      }
      const dataIndices = normalizeToArray(sourceBatch[i].dataIndex);
      const otherDataIndices = otherMap && otherMap[seriesId];
      for (let j = 0, lenj = dataIndices.length; j < lenj; j++) {
        const dataIndex = dataIndices[j];
        if (otherDataIndices && otherDataIndices[dataIndex]) {
          otherDataIndices[dataIndex] = null;
        } else {
          (map3[seriesId] || (map3[seriesId] = {}))[dataIndex] = 1;
        }
      }
    }
  }
  function mapToArray(map3, isData) {
    const result = [];
    for (const i in map3) {
      if (map3.hasOwnProperty(i) && map3[i] != null) {
        if (isData) {
          result.push(+i);
        } else {
          const dataIndices = mapToArray(map3[i], true);
          dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});
        }
      }
    }
    return result;
  }
}
function queryDataIndex(data, payload) {
  if (payload.dataIndexInside != null) {
    return payload.dataIndexInside;
  } else if (payload.dataIndex != null) {
    return isArray(payload.dataIndex) ? map(payload.dataIndex, function(value) {
      return data.indexOfRawIndex(value);
    }) : data.indexOfRawIndex(payload.dataIndex);
  } else if (payload.name != null) {
    return isArray(payload.name) ? map(payload.name, function(value) {
      return data.indexOfName(value);
    }) : data.indexOfName(payload.name);
  }
}
function makeInner() {
  const key = "__ec_inner_" + innerUniqueIndex++;
  return function(hostObj) {
    return hostObj[key] || (hostObj[key] = {});
  };
}
var innerUniqueIndex = getRandomIdBase();
function parseFinder(ecModel, finderInput, opt) {
  const {mainTypeSpecified, queryOptionMap, others} = preParseFinder(finderInput, opt);
  const result = others;
  const defaultMainType = opt ? opt.defaultMainType : null;
  if (!mainTypeSpecified && defaultMainType) {
    queryOptionMap.set(defaultMainType, {});
  }
  queryOptionMap.each(function(queryOption, mainType) {
    const queryResult = queryReferringComponents(ecModel, mainType, queryOption, {
      useDefault: defaultMainType === mainType,
      enableAll: opt && opt.enableAll != null ? opt.enableAll : true,
      enableNone: opt && opt.enableNone != null ? opt.enableNone : true
    });
    result[mainType + "Models"] = queryResult.models;
    result[mainType + "Model"] = queryResult.models[0];
  });
  return result;
}
function preParseFinder(finderInput, opt) {
  let finder;
  if (isString(finderInput)) {
    const obj = {};
    obj[finderInput + "Index"] = 0;
    finder = obj;
  } else {
    finder = finderInput;
  }
  const queryOptionMap = createHashMap();
  const others = {};
  let mainTypeSpecified = false;
  each(finder, function(value, key) {
    if (key === "dataIndex" || key === "dataIndexInside") {
      others[key] = value;
      return;
    }
    const parsedKey = key.match(/^(\w+)(Index|Id|Name)$/) || [];
    const mainType = parsedKey[1];
    const queryType = (parsedKey[2] || "").toLowerCase();
    if (!mainType || !queryType || opt && opt.includeMainTypes && indexOf(opt.includeMainTypes, mainType) < 0) {
      return;
    }
    mainTypeSpecified = mainTypeSpecified || !!mainType;
    const queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});
    queryOption[queryType] = value;
  });
  return {mainTypeSpecified, queryOptionMap, others};
}
var SINGLE_REFERRING = {useDefault: true, enableAll: false, enableNone: false};
var MULTIPLE_REFERRING = {useDefault: false, enableAll: true, enableNone: true};
function queryReferringComponents(ecModel, mainType, userOption, opt) {
  opt = opt || SINGLE_REFERRING;
  let indexOption = userOption.index;
  let idOption = userOption.id;
  let nameOption = userOption.name;
  const result = {
    models: null,
    specified: indexOption != null || idOption != null || nameOption != null
  };
  if (!result.specified) {
    let firstCmpt;
    result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];
    return result;
  }
  if (indexOption === "none" || indexOption === false) {
    assert(opt.enableNone, '`"none"` or `false` is not a valid value on index option.');
    result.models = [];
    return result;
  }
  if (indexOption === "all") {
    assert(opt.enableAll, '`"all"` is not a valid value on index option.');
    indexOption = idOption = nameOption = null;
  }
  result.models = ecModel.queryComponents({
    mainType,
    index: indexOption,
    id: idOption,
    name: nameOption
  });
  return result;
}
function setAttribute(dom, key, value) {
  dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;
}
function getAttribute(dom, key) {
  return dom.getAttribute ? dom.getAttribute(key) : dom[key];
}
function getTooltipRenderMode(renderModeOption) {
  if (renderModeOption === "auto") {
    return env_default.domSupported ? "html" : "richText";
  } else {
    return renderModeOption || "html";
  }
}
function groupData(array, getKey2) {
  const buckets = createHashMap();
  const keys2 = [];
  each(array, function(item) {
    const key = getKey2(item);
    (buckets.get(key) || (keys2.push(key), buckets.set(key, []))).push(item);
  });
  return {
    keys: keys2,
    buckets
  };
}
function interpolateRawValues(data, precision, sourceValue, targetValue, percent) {
  const isAutoPrecision = precision == null || precision === "auto";
  if (targetValue == null) {
    return targetValue;
  }
  if (isNumber(targetValue)) {
    const value = interpolateNumber2(sourceValue || 0, targetValue, percent);
    return round(value, isAutoPrecision ? Math.max(getPrecision(sourceValue || 0), getPrecision(targetValue)) : precision);
  } else if (isString(targetValue)) {
    return percent < 1 ? sourceValue : targetValue;
  } else {
    const interpolated = [];
    const leftArr = sourceValue;
    const rightArr = targetValue;
    const length2 = Math.max(leftArr ? leftArr.length : 0, rightArr.length);
    for (let i = 0; i < length2; ++i) {
      const info = data.getDimensionInfo(i);
      if (info && info.type === "ordinal") {
        interpolated[i] = (percent < 1 && leftArr ? leftArr : rightArr)[i];
      } else {
        const leftVal = leftArr && leftArr[i] ? leftArr[i] : 0;
        const rightVal = rightArr[i];
        const value = interpolateNumber2(leftVal, rightVal, percent);
        interpolated[i] = round(value, isAutoPrecision ? Math.max(getPrecision(leftVal), getPrecision(rightVal)) : precision);
      }
    }
    return interpolated;
  }
}

// src/util/clazz.ts
var TYPE_DELIMITER = ".";
var IS_CONTAINER = "___EC__COMPONENT__CONTAINER___";
var IS_EXTENDED_CLASS = "___EC__EXTENDED_CLASS___";
function parseClassType(componentType) {
  const ret = {main: "", sub: ""};
  if (componentType) {
    const typeArr = componentType.split(TYPE_DELIMITER);
    ret.main = typeArr[0] || "";
    ret.sub = typeArr[1] || "";
  }
  return ret;
}
function checkClassType(componentType) {
  assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal');
}
function isExtendedClass(clz) {
  return !!(clz && clz[IS_EXTENDED_CLASS]);
}
function enableClassExtend(rootClz, mandatoryMethods) {
  rootClz.$constructor = rootClz;
  rootClz.extend = function(proto2) {
    if (true) {
      each(mandatoryMethods, function(method) {
        if (!proto2[method]) {
          console.warn("Method `" + method + "` should be implemented" + (proto2.type ? " in " + proto2.type : "") + ".");
        }
      });
    }
    const superClass = this;
    let ExtendedClass;
    if (isESClass(superClass)) {
      ExtendedClass = class extends superClass {
        constructor() {
          super(...arguments);
        }
      };
    } else {
      ExtendedClass = function() {
        (proto2.$constructor || superClass).apply(this, arguments);
      };
      inherits(ExtendedClass, this);
    }
    extend(ExtendedClass.prototype, proto2);
    ExtendedClass[IS_EXTENDED_CLASS] = true;
    ExtendedClass.extend = this.extend;
    ExtendedClass.superCall = superCall;
    ExtendedClass.superApply = superApply;
    ExtendedClass.superClass = superClass;
    return ExtendedClass;
  };
}
function isESClass(fn) {
  return isFunction(fn) && /^class\s/.test(Function.prototype.toString.call(fn));
}
function mountExtend(SubClz, SupperClz) {
  SubClz.extend = SupperClz.extend;
}
var classBase = Math.round(Math.random() * 10);
function enableClassCheck(target) {
  const classAttr = ["__\0is_clz", classBase++].join("_");
  target.prototype[classAttr] = true;
  if (true) {
    assert(!target.isInstance, 'The method "is" can not be defined.');
  }
  target.isInstance = function(obj) {
    return !!(obj && obj[classAttr]);
  };
}
function superCall(context, methodName, ...args) {
  return this.superClass.prototype[methodName].apply(context, args);
}
function superApply(context, methodName, args) {
  return this.superClass.prototype[methodName].apply(context, args);
}
function enableClassManagement(target) {
  const storage2 = {};
  target.registerClass = function(clz) {
    const componentFullType = clz.type || clz.prototype.type;
    if (componentFullType) {
      checkClassType(componentFullType);
      clz.prototype.type = componentFullType;
      const componentTypeInfo = parseClassType(componentFullType);
      if (!componentTypeInfo.sub) {
        if (true) {
          if (storage2[componentTypeInfo.main]) {
            console.warn(componentTypeInfo.main + " exists.");
          }
        }
        storage2[componentTypeInfo.main] = clz;
      } else if (componentTypeInfo.sub !== IS_CONTAINER) {
        const container = makeContainer(componentTypeInfo);
        container[componentTypeInfo.sub] = clz;
      }
    }
    return clz;
  };
  target.getClass = function(mainType, subType, throwWhenNotFound) {
    let clz = storage2[mainType];
    if (clz && clz[IS_CONTAINER]) {
      clz = subType ? clz[subType] : null;
    }
    if (throwWhenNotFound && !clz) {
      throw new Error(!subType ? mainType + ".type should be specified." : "Component " + mainType + "." + (subType || "") + " is used but not imported.");
    }
    return clz;
  };
  target.getClassesByMainType = function(componentType) {
    const componentTypeInfo = parseClassType(componentType);
    const result = [];
    const obj = storage2[componentTypeInfo.main];
    if (obj && obj[IS_CONTAINER]) {
      each(obj, function(o, type) {
        type !== IS_CONTAINER && result.push(o);
      });
    } else {
      result.push(obj);
    }
    return result;
  };
  target.hasClass = function(componentType) {
    const componentTypeInfo = parseClassType(componentType);
    return !!storage2[componentTypeInfo.main];
  };
  target.getAllClassMainTypes = function() {
    const types = [];
    each(storage2, function(obj, type) {
      types.push(type);
    });
    return types;
  };
  target.hasSubTypes = function(componentType) {
    const componentTypeInfo = parseClassType(componentType);
    const obj = storage2[componentTypeInfo.main];
    return obj && obj[IS_CONTAINER];
  };
  function makeContainer(componentTypeInfo) {
    let container = storage2[componentTypeInfo.main];
    if (!container || !container[IS_CONTAINER]) {
      container = storage2[componentTypeInfo.main] = {};
      container[IS_CONTAINER] = true;
    }
    return container;
  }
}

// src/model/mixin/makeStyleMapper.ts
function makeStyleMapper(properties, ignoreParent) {
  for (let i = 0; i < properties.length; i++) {
    if (!properties[i][1]) {
      properties[i][1] = properties[i][0];
    }
  }
  ignoreParent = ignoreParent || false;
  return function(model, excludes, includes) {
    const style = {};
    for (let i = 0; i < properties.length; i++) {
      const propName = properties[i][1];
      if (excludes && indexOf(excludes, propName) >= 0 || includes && indexOf(includes, propName) < 0) {
        continue;
      }
      const val = model.getShallow(propName, ignoreParent);
      if (val != null) {
        style[properties[i][0]] = val;
      }
    }
    return style;
  };
}

// src/model/mixin/areaStyle.ts
var AREA_STYLE_KEY_MAP = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
];
var getAreaStyle = makeStyleMapper(AREA_STYLE_KEY_MAP);
var AreaStyleMixin = class {
  getAreaStyle(excludes, includes) {
    return getAreaStyle(this, excludes, includes);
  }
};

// node_modules/zrender/src/graphic/helper/image.ts
var globalImageCache = new LRU_default(50);
function findExistImage(newImageOrSrc) {
  if (typeof newImageOrSrc === "string") {
    const cachedImgObj = globalImageCache.get(newImageOrSrc);
    return cachedImgObj && cachedImgObj.image;
  } else {
    return newImageOrSrc;
  }
}
function createOrUpdateImage(newImageOrSrc, image, hostEl, onload, cbPayload) {
  if (!newImageOrSrc) {
    return image;
  } else if (typeof newImageOrSrc === "string") {
    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {
      return image;
    }
    const cachedImgObj = globalImageCache.get(newImageOrSrc);
    const pendingWrap = {hostEl, cb: onload, cbPayload};
    if (cachedImgObj) {
      image = cachedImgObj.image;
      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
    } else {
      image = platformApi.loadImage(newImageOrSrc, imageOnLoad, imageOnLoad);
      image.__zrImageSrc = newImageOrSrc;
      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
        image,
        pending: [pendingWrap]
      });
    }
    return image;
  } else {
    return newImageOrSrc;
  }
}
function imageOnLoad() {
  const cachedImgObj = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (let i = 0; i < cachedImgObj.pending.length; i++) {
    const pendingWrap = cachedImgObj.pending[i];
    const cb = pendingWrap.cb;
    cb && cb(this, pendingWrap.cbPayload);
    pendingWrap.hostEl.dirty();
  }
  cachedImgObj.pending.length = 0;
}
function isImageReady(image) {
  return image && image.width && image.height;
}

// node_modules/zrender/src/graphic/helper/parseText.ts
var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function truncateText(text, containerWidth, font, ellipsis, options) {
  if (!containerWidth) {
    return "";
  }
  const textLines = (text + "").split("\n");
  options = prepareTruncateOptions(containerWidth, font, ellipsis, options);
  for (let i = 0, len2 = textLines.length; i < len2; i++) {
    textLines[i] = truncateSingleLine(textLines[i], options);
  }
  return textLines.join("\n");
}
function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
  options = options || {};
  let preparedOpts = extend({}, options);
  preparedOpts.font = font;
  ellipsis = retrieve2(ellipsis, "...");
  preparedOpts.maxIterations = retrieve2(options.maxIterations, 2);
  const minChar = preparedOpts.minChar = retrieve2(options.minChar, 0);
  preparedOpts.cnCharWidth = getWidth("\u56FD", font);
  const ascCharWidth = preparedOpts.ascCharWidth = getWidth("a", font);
  preparedOpts.placeholder = retrieve2(options.placeholder, "");
  let contentWidth = containerWidth = Math.max(0, containerWidth - 1);
  for (let i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
    contentWidth -= ascCharWidth;
  }
  let ellipsisWidth = getWidth(ellipsis, font);
  if (ellipsisWidth > contentWidth) {
    ellipsis = "";
    ellipsisWidth = 0;
  }
  contentWidth = containerWidth - ellipsisWidth;
  preparedOpts.ellipsis = ellipsis;
  preparedOpts.ellipsisWidth = ellipsisWidth;
  preparedOpts.contentWidth = contentWidth;
  preparedOpts.containerWidth = containerWidth;
  return preparedOpts;
}
function truncateSingleLine(textLine, options) {
  const containerWidth = options.containerWidth;
  const font = options.font;
  const contentWidth = options.contentWidth;
  if (!containerWidth) {
    return "";
  }
  let lineWidth = getWidth(textLine, font);
  if (lineWidth <= containerWidth) {
    return textLine;
  }
  for (let j = 0; ; j++) {
    if (lineWidth <= contentWidth || j >= options.maxIterations) {
      textLine += options.ellipsis;
      break;
    }
    const subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;
    textLine = textLine.substr(0, subLength);
    lineWidth = getWidth(textLine, font);
  }
  if (textLine === "") {
    textLine = options.placeholder;
  }
  return textLine;
}
function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
  let width = 0;
  let i = 0;
  for (let len2 = text.length; i < len2 && width < contentWidth; i++) {
    const charCode = text.charCodeAt(i);
    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;
  }
  return i;
}
function parsePlainText(text, style) {
  text != null && (text += "");
  const overflow = style.overflow;
  const padding = style.padding;
  const font = style.font;
  const truncate = overflow === "truncate";
  const calculatedLineHeight = getLineHeight(font);
  const lineHeight = retrieve2(style.lineHeight, calculatedLineHeight);
  const bgColorDrawn = !!style.backgroundColor;
  const truncateLineOverflow = style.lineOverflow === "truncate";
  let width = style.width;
  let lines;
  if (width != null && (overflow === "break" || overflow === "breakAll")) {
    lines = text ? wrapText(text, style.font, width, overflow === "breakAll", 0).lines : [];
  } else {
    lines = text ? text.split("\n") : [];
  }
  const contentHeight = lines.length * lineHeight;
  const height = retrieve2(style.height, contentHeight);
  if (contentHeight > height && truncateLineOverflow) {
    const lineCount = Math.floor(height / lineHeight);
    lines = lines.slice(0, lineCount);
  }
  if (text && truncate && width != null) {
    const options = prepareTruncateOptions(width, font, style.ellipsis, {
      minChar: style.truncateMinChar,
      placeholder: style.placeholder
    });
    for (let i = 0; i < lines.length; i++) {
      lines[i] = truncateSingleLine(lines[i], options);
    }
  }
  let outerHeight = height;
  let contentWidth = 0;
  for (let i = 0; i < lines.length; i++) {
    contentWidth = Math.max(getWidth(lines[i], font), contentWidth);
  }
  if (width == null) {
    width = contentWidth;
  }
  let outerWidth = contentWidth;
  if (padding) {
    outerHeight += padding[0] + padding[2];
    outerWidth += padding[1] + padding[3];
    width += padding[1] + padding[3];
  }
  if (bgColorDrawn) {
    outerWidth = width;
  }
  return {
    lines,
    height,
    outerWidth,
    outerHeight,
    lineHeight,
    calculatedLineHeight,
    contentWidth,
    contentHeight,
    width
  };
}
var RichTextToken = class {
};
var RichTextLine = class {
  constructor(tokens) {
    this.tokens = [];
    if (tokens) {
      this.tokens = tokens;
    }
  }
};
var RichTextContentBlock = class {
  constructor() {
    this.width = 0;
    this.height = 0;
    this.contentWidth = 0;
    this.contentHeight = 0;
    this.outerWidth = 0;
    this.outerHeight = 0;
    this.lines = [];
  }
};
function parseRichText(text, style) {
  const contentBlock = new RichTextContentBlock();
  text != null && (text += "");
  if (!text) {
    return contentBlock;
  }
  const topWidth = style.width;
  const topHeight = style.height;
  const overflow = style.overflow;
  let wrapInfo = (overflow === "break" || overflow === "breakAll") && topWidth != null ? {width: topWidth, accumWidth: 0, breakAll: overflow === "breakAll"} : null;
  let lastIndex = STYLE_REG.lastIndex = 0;
  let result;
  while ((result = STYLE_REG.exec(text)) != null) {
    const matchedIndex = result.index;
    if (matchedIndex > lastIndex) {
      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex), style, wrapInfo);
    }
    pushTokens(contentBlock, result[2], style, wrapInfo, result[1]);
    lastIndex = STYLE_REG.lastIndex;
  }
  if (lastIndex < text.length) {
    pushTokens(contentBlock, text.substring(lastIndex, text.length), style, wrapInfo);
  }
  let pendingList = [];
  let calculatedHeight = 0;
  let calculatedWidth = 0;
  const stlPadding = style.padding;
  const truncate = overflow === "truncate";
  const truncateLine = style.lineOverflow === "truncate";
  function finishLine(line2, lineWidth, lineHeight) {
    line2.width = lineWidth;
    line2.lineHeight = lineHeight;
    calculatedHeight += lineHeight;
    calculatedWidth = Math.max(calculatedWidth, lineWidth);
  }
  outer:
    for (let i = 0; i < contentBlock.lines.length; i++) {
      const line2 = contentBlock.lines[i];
      let lineHeight = 0;
      let lineWidth = 0;
      for (let j = 0; j < line2.tokens.length; j++) {
        const token = line2.tokens[j];
        const tokenStyle = token.styleName && style.rich[token.styleName] || {};
        const textPadding = token.textPadding = tokenStyle.padding;
        const paddingH = textPadding ? textPadding[1] + textPadding[3] : 0;
        const font = token.font = tokenStyle.font || style.font;
        token.contentHeight = getLineHeight(font);
        let tokenHeight = retrieve2(tokenStyle.height, token.contentHeight);
        token.innerHeight = tokenHeight;
        textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
        token.height = tokenHeight;
        token.lineHeight = retrieve3(tokenStyle.lineHeight, style.lineHeight, tokenHeight);
        token.align = tokenStyle && tokenStyle.align || style.align;
        token.verticalAlign = tokenStyle && tokenStyle.verticalAlign || "middle";
        if (truncateLine && topHeight != null && calculatedHeight + token.lineHeight > topHeight) {
          if (j > 0) {
            line2.tokens = line2.tokens.slice(0, j);
            finishLine(line2, lineWidth, lineHeight);
            contentBlock.lines = contentBlock.lines.slice(0, i + 1);
          } else {
            contentBlock.lines = contentBlock.lines.slice(0, i);
          }
          break outer;
        }
        let styleTokenWidth = tokenStyle.width;
        let tokenWidthNotSpecified = styleTokenWidth == null || styleTokenWidth === "auto";
        if (typeof styleTokenWidth === "string" && styleTokenWidth.charAt(styleTokenWidth.length - 1) === "%") {
          token.percentWidth = styleTokenWidth;
          pendingList.push(token);
          token.contentWidth = getWidth(token.text, font);
        } else {
          if (tokenWidthNotSpecified) {
            const textBackgroundColor = tokenStyle.backgroundColor;
            let bgImg = textBackgroundColor && textBackgroundColor.image;
            if (bgImg) {
              bgImg = findExistImage(bgImg);
              if (isImageReady(bgImg)) {
                token.width = Math.max(token.width, bgImg.width * tokenHeight / bgImg.height);
              }
            }
          }
          const remainTruncWidth = truncate && topWidth != null ? topWidth - lineWidth : null;
          if (remainTruncWidth != null && remainTruncWidth < token.width) {
            if (!tokenWidthNotSpecified || remainTruncWidth < paddingH) {
              token.text = "";
              token.width = token.contentWidth = 0;
            } else {
              token.text = truncateText(token.text, remainTruncWidth - paddingH, font, style.ellipsis, {minChar: style.truncateMinChar});
              token.width = token.contentWidth = getWidth(token.text, font);
            }
          } else {
            token.contentWidth = getWidth(token.text, font);
          }
        }
        token.width += paddingH;
        lineWidth += token.width;
        tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
      }
      finishLine(line2, lineWidth, lineHeight);
    }
  contentBlock.outerWidth = contentBlock.width = retrieve2(topWidth, calculatedWidth);
  contentBlock.outerHeight = contentBlock.height = retrieve2(topHeight, calculatedHeight);
  contentBlock.contentHeight = calculatedHeight;
  contentBlock.contentWidth = calculatedWidth;
  if (stlPadding) {
    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
  }
  for (let i = 0; i < pendingList.length; i++) {
    const token = pendingList[i];
    const percentWidth = token.percentWidth;
    token.width = parseInt(percentWidth, 10) / 100 * contentBlock.width;
  }
  return contentBlock;
}
function pushTokens(block, str, style, wrapInfo, styleName) {
  const isEmptyStr = str === "";
  const tokenStyle = styleName && style.rich[styleName] || {};
  const lines = block.lines;
  const font = tokenStyle.font || style.font;
  let newLine = false;
  let strLines;
  let linesWidths;
  if (wrapInfo) {
    const tokenPadding = tokenStyle.padding;
    let tokenPaddingH = tokenPadding ? tokenPadding[1] + tokenPadding[3] : 0;
    if (tokenStyle.width != null && tokenStyle.width !== "auto") {
      const outerWidth = parsePercent(tokenStyle.width, wrapInfo.width) + tokenPaddingH;
      if (lines.length > 0) {
        if (outerWidth + wrapInfo.accumWidth > wrapInfo.width) {
          strLines = str.split("\n");
          newLine = true;
        }
      }
      wrapInfo.accumWidth = outerWidth;
    } else {
      const res = wrapText(str, font, wrapInfo.width, wrapInfo.breakAll, wrapInfo.accumWidth);
      wrapInfo.accumWidth = res.accumWidth + tokenPaddingH;
      linesWidths = res.linesWidths;
      strLines = res.lines;
    }
  } else {
    strLines = str.split("\n");
  }
  for (let i = 0; i < strLines.length; i++) {
    const text = strLines[i];
    const token = new RichTextToken();
    token.styleName = styleName;
    token.text = text;
    token.isLineHolder = !text && !isEmptyStr;
    if (typeof tokenStyle.width === "number") {
      token.width = tokenStyle.width;
    } else {
      token.width = linesWidths ? linesWidths[i] : getWidth(text, font);
    }
    if (!i && !newLine) {
      const tokens = (lines[lines.length - 1] || (lines[0] = new RichTextLine())).tokens;
      const tokensLen = tokens.length;
      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : (text || !tokensLen || isEmptyStr) && tokens.push(token);
    } else {
      lines.push(new RichTextLine([token]));
    }
  }
}
function isAlphabeticLetter(ch) {
  let code = ch.charCodeAt(0);
  return code >= 32 && code <= 591 || code >= 880 && code <= 4351 || code >= 4608 && code <= 5119 || code >= 7680 && code <= 8303;
}
var breakCharMap = reduce(",&?/;] ".split(""), function(obj, ch) {
  obj[ch] = true;
  return obj;
}, {});
function isWordBreakChar(ch) {
  if (isAlphabeticLetter(ch)) {
    if (breakCharMap[ch]) {
      return true;
    }
    return false;
  }
  return true;
}
function wrapText(text, font, lineWidth, isBreakAll, lastAccumWidth) {
  let lines = [];
  let linesWidths = [];
  let line2 = "";
  let currentWord = "";
  let currentWordWidth = 0;
  let accumWidth = 0;
  for (let i = 0; i < text.length; i++) {
    const ch = text.charAt(i);
    if (ch === "\n") {
      if (currentWord) {
        line2 += currentWord;
        accumWidth += currentWordWidth;
      }
      lines.push(line2);
      linesWidths.push(accumWidth);
      line2 = "";
      currentWord = "";
      currentWordWidth = 0;
      accumWidth = 0;
      continue;
    }
    const chWidth = getWidth(ch, font);
    const inWord = isBreakAll ? false : !isWordBreakChar(ch);
    if (!lines.length ? lastAccumWidth + accumWidth + chWidth > lineWidth : accumWidth + chWidth > lineWidth) {
      if (!accumWidth) {
        if (inWord) {
          lines.push(currentWord);
          linesWidths.push(currentWordWidth);
          currentWord = ch;
          currentWordWidth = chWidth;
        } else {
          lines.push(ch);
          linesWidths.push(chWidth);
        }
      } else if (line2 || currentWord) {
        if (inWord) {
          if (!line2) {
            line2 = currentWord;
            currentWord = "";
            currentWordWidth = 0;
            accumWidth = currentWordWidth;
          }
          lines.push(line2);
          linesWidths.push(accumWidth - currentWordWidth);
          currentWord += ch;
          currentWordWidth += chWidth;
          line2 = "";
          accumWidth = currentWordWidth;
        } else {
          if (currentWord) {
            line2 += currentWord;
            currentWord = "";
            currentWordWidth = 0;
          }
          lines.push(line2);
          linesWidths.push(accumWidth);
          line2 = ch;
          accumWidth = chWidth;
        }
      }
      continue;
    }
    accumWidth += chWidth;
    if (inWord) {
      currentWord += ch;
      currentWordWidth += chWidth;
    } else {
      if (currentWord) {
        line2 += currentWord;
        currentWord = "";
        currentWordWidth = 0;
      }
      line2 += ch;
    }
  }
  if (!lines.length && !line2) {
    line2 = text;
    currentWord = "";
    currentWordWidth = 0;
  }
  if (currentWord) {
    line2 += currentWord;
  }
  if (line2) {
    lines.push(line2);
    linesWidths.push(accumWidth);
  }
  if (lines.length === 1) {
    accumWidth += lastAccumWidth;
  }
  return {
    accumWidth,
    lines,
    linesWidths
  };
}

// node_modules/zrender/src/graphic/Displayable.ts
var STYLE_MAGIC_KEY = "__zr_style_" + Math.round(Math.random() * 10);
var DEFAULT_COMMON_STYLE = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
};
var DEFAULT_COMMON_ANIMATION_PROPS = {
  style: {
    shadowBlur: true,
    shadowOffsetX: true,
    shadowOffsetY: true,
    shadowColor: true,
    opacity: true
  }
};
DEFAULT_COMMON_STYLE[STYLE_MAGIC_KEY] = true;
var PRIMARY_STATES_KEYS2 = ["z", "z2", "invisible"];
var PRIMARY_STATES_KEYS_IN_HOVER_LAYER = ["invisible"];
var Displayable2 = class extends Element_default {
  constructor(props) {
    super(props);
  }
  _init(props) {
    const keysArr = keys(props);
    for (let i = 0; i < keysArr.length; i++) {
      const key = keysArr[i];
      if (key === "style") {
        this.useStyle(props[key]);
      } else {
        super.attrKV(key, props[key]);
      }
    }
    if (!this.style) {
      this.useStyle({});
    }
  }
  beforeBrush() {
  }
  afterBrush() {
  }
  innerBeforeBrush() {
  }
  innerAfterBrush() {
  }
  shouldBePainted(viewWidth, viewHeight, considerClipPath, considerAncestors) {
    const m2 = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && isDisplayableCulled(this, viewWidth, viewHeight) || m2 && !m2[0] && !m2[3]) {
      return false;
    }
    if (considerClipPath && this.__clipPaths) {
      for (let i = 0; i < this.__clipPaths.length; ++i) {
        if (this.__clipPaths[i].isZeroArea()) {
          return false;
        }
      }
    }
    if (considerAncestors && this.parent) {
      let parent = this.parent;
      while (parent) {
        if (parent.ignore) {
          return false;
        }
        parent = parent.parent;
      }
    }
    return true;
  }
  contain(x, y) {
    return this.rectContain(x, y);
  }
  traverse(cb, context) {
    cb.call(context, this);
  }
  rectContain(x, y) {
    const coord = this.transformCoordToLocal(x, y);
    const rect = this.getBoundingRect();
    return rect.contain(coord[0], coord[1]);
  }
  getPaintRect() {
    let rect = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      const transform2 = this.transform;
      const elRect = this.getBoundingRect();
      const style = this.style;
      const shadowSize = style.shadowBlur || 0;
      const shadowOffsetX = style.shadowOffsetX || 0;
      const shadowOffsetY = style.shadowOffsetY || 0;
      rect = this._paintRect || (this._paintRect = new BoundingRect_default(0, 0, 0, 0));
      if (transform2) {
        BoundingRect_default.applyTransform(rect, elRect, transform2);
      } else {
        rect.copy(elRect);
      }
      if (shadowSize || shadowOffsetX || shadowOffsetY) {
        rect.width += shadowSize * 2 + Math.abs(shadowOffsetX);
        rect.height += shadowSize * 2 + Math.abs(shadowOffsetY);
        rect.x = Math.min(rect.x, rect.x + shadowOffsetX - shadowSize);
        rect.y = Math.min(rect.y, rect.y + shadowOffsetY - shadowSize);
      }
      const tolerance = this.dirtyRectTolerance;
      if (!rect.isZero()) {
        rect.x = Math.floor(rect.x - tolerance);
        rect.y = Math.floor(rect.y - tolerance);
        rect.width = Math.ceil(rect.width + 1 + tolerance * 2);
        rect.height = Math.ceil(rect.height + 1 + tolerance * 2);
      }
    }
    return rect;
  }
  setPrevPaintRect(paintRect) {
    if (paintRect) {
      this._prevPaintRect = this._prevPaintRect || new BoundingRect_default(0, 0, 0, 0);
      this._prevPaintRect.copy(paintRect);
    } else {
      this._prevPaintRect = null;
    }
  }
  getPrevPaintRect() {
    return this._prevPaintRect;
  }
  animateStyle(loop) {
    return this.animate("style", loop);
  }
  updateDuringAnimation(targetKey) {
    if (targetKey === "style") {
      this.dirtyStyle();
    } else {
      this.markRedraw();
    }
  }
  attrKV(key, value) {
    if (key !== "style") {
      super.attrKV(key, value);
    } else {
      if (!this.style) {
        this.useStyle(value);
      } else {
        this.setStyle(value);
      }
    }
  }
  setStyle(keyOrObj, value) {
    if (typeof keyOrObj === "string") {
      this.style[keyOrObj] = value;
    } else {
      extend(this.style, keyOrObj);
    }
    this.dirtyStyle();
    return this;
  }
  dirtyStyle(notRedraw) {
    if (!notRedraw) {
      this.markRedraw();
    }
    this.__dirty |= STYLE_CHANGED_BIT;
    if (this._rect) {
      this._rect = null;
    }
  }
  dirty() {
    this.dirtyStyle();
  }
  styleChanged() {
    return !!(this.__dirty & STYLE_CHANGED_BIT);
  }
  styleUpdated() {
    this.__dirty &= ~STYLE_CHANGED_BIT;
  }
  createStyle(obj) {
    return createObject(DEFAULT_COMMON_STYLE, obj);
  }
  useStyle(obj) {
    if (!obj[STYLE_MAGIC_KEY]) {
      obj = this.createStyle(obj);
    }
    if (this.__inHover) {
      this.__hoverStyle = obj;
    } else {
      this.style = obj;
    }
    this.dirtyStyle();
  }
  isStyleObject(obj) {
    return obj[STYLE_MAGIC_KEY];
  }
  _innerSaveToNormal(toState) {
    super._innerSaveToNormal(toState);
    const normalState = this._normalState;
    if (toState.style && !normalState.style) {
      normalState.style = this._mergeStyle(this.createStyle(), this.style);
    }
    this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS2);
  }
  _applyStateObj(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
    super._applyStateObj(stateName, state, normalState, keepCurrentStates, transition, animationCfg);
    const needsRestoreToNormal = !(state && keepCurrentStates);
    let targetStyle;
    if (state && state.style) {
      if (transition) {
        if (keepCurrentStates) {
          targetStyle = state.style;
        } else {
          targetStyle = this._mergeStyle(this.createStyle(), normalState.style);
          this._mergeStyle(targetStyle, state.style);
        }
      } else {
        targetStyle = this._mergeStyle(this.createStyle(), keepCurrentStates ? this.style : normalState.style);
        this._mergeStyle(targetStyle, state.style);
      }
    } else if (needsRestoreToNormal) {
      targetStyle = normalState.style;
    }
    if (targetStyle) {
      if (transition) {
        const sourceStyle = this.style;
        this.style = this.createStyle(needsRestoreToNormal ? {} : sourceStyle);
        if (needsRestoreToNormal) {
          const changedKeys = keys(sourceStyle);
          for (let i = 0; i < changedKeys.length; i++) {
            const key = changedKeys[i];
            if (key in targetStyle) {
              targetStyle[key] = targetStyle[key];
              this.style[key] = sourceStyle[key];
            }
          }
        }
        const targetKeys = keys(targetStyle);
        for (let i = 0; i < targetKeys.length; i++) {
          const key = targetKeys[i];
          this.style[key] = this.style[key];
        }
        this._transitionState(stateName, {
          style: targetStyle
        }, animationCfg, this.getAnimationStyleProps());
      } else {
        this.useStyle(targetStyle);
      }
    }
    const statesKeys = this.__inHover ? PRIMARY_STATES_KEYS_IN_HOVER_LAYER : PRIMARY_STATES_KEYS2;
    for (let i = 0; i < statesKeys.length; i++) {
      let key = statesKeys[i];
      if (state && state[key] != null) {
        this[key] = state[key];
      } else if (needsRestoreToNormal) {
        if (normalState[key] != null) {
          this[key] = normalState[key];
        }
      }
    }
  }
  _mergeStates(states) {
    const mergedState = super._mergeStates(states);
    let mergedStyle;
    for (let i = 0; i < states.length; i++) {
      const state = states[i];
      if (state.style) {
        mergedStyle = mergedStyle || {};
        this._mergeStyle(mergedStyle, state.style);
      }
    }
    if (mergedStyle) {
      mergedState.style = mergedStyle;
    }
    return mergedState;
  }
  _mergeStyle(targetStyle, sourceStyle) {
    extend(targetStyle, sourceStyle);
    return targetStyle;
  }
  getAnimationStyleProps() {
    return DEFAULT_COMMON_ANIMATION_PROPS;
  }
};
var Displayable = Displayable2;
Displayable.initDefaultProps = function() {
  const dispProto = Displayable2.prototype;
  dispProto.type = "displayable";
  dispProto.invisible = false;
  dispProto.z = 0;
  dispProto.z2 = 0;
  dispProto.zlevel = 0;
  dispProto.culling = false;
  dispProto.cursor = "pointer";
  dispProto.rectHover = false;
  dispProto.incremental = false;
  dispProto._rect = null;
  dispProto.dirtyRectTolerance = 0;
  dispProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT;
}();
var tmpRect2 = new BoundingRect_default(0, 0, 0, 0);
var viewRect = new BoundingRect_default(0, 0, 0, 0);
function isDisplayableCulled(el, width, height) {
  tmpRect2.copy(el.getBoundingRect());
  if (el.transform) {
    tmpRect2.applyTransform(el.transform);
  }
  viewRect.width = width;
  viewRect.height = height;
  return !tmpRect2.intersect(viewRect);
}
var Displayable_default = Displayable;

// node_modules/zrender/src/core/bbox.ts
var mathMin2 = Math.min;
var mathMax2 = Math.max;
var mathSin = Math.sin;
var mathCos = Math.cos;
var PI2 = Math.PI * 2;
var start = create();
var end = create();
var extremity = create();
function fromPoints(points4, min3, max3) {
  if (points4.length === 0) {
    return;
  }
  let p = points4[0];
  let left = p[0];
  let right = p[0];
  let top = p[1];
  let bottom = p[1];
  for (let i = 1; i < points4.length; i++) {
    p = points4[i];
    left = mathMin2(left, p[0]);
    right = mathMax2(right, p[0]);
    top = mathMin2(top, p[1]);
    bottom = mathMax2(bottom, p[1]);
  }
  min3[0] = left;
  min3[1] = top;
  max3[0] = right;
  max3[1] = bottom;
}
function fromLine(x0, y0, x1, y1, min3, max3) {
  min3[0] = mathMin2(x0, x1);
  min3[1] = mathMin2(y0, y1);
  max3[0] = mathMax2(x0, x1);
  max3[1] = mathMax2(y0, y1);
}
var xDim = [];
var yDim = [];
function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min3, max3) {
  const cubicExtrema2 = cubicExtrema;
  const cubicAt2 = cubicAt;
  let n = cubicExtrema2(x0, x1, x2, x3, xDim);
  min3[0] = Infinity;
  min3[1] = Infinity;
  max3[0] = -Infinity;
  max3[1] = -Infinity;
  for (let i = 0; i < n; i++) {
    const x = cubicAt2(x0, x1, x2, x3, xDim[i]);
    min3[0] = mathMin2(x, min3[0]);
    max3[0] = mathMax2(x, max3[0]);
  }
  n = cubicExtrema2(y0, y1, y2, y3, yDim);
  for (let i = 0; i < n; i++) {
    const y = cubicAt2(y0, y1, y2, y3, yDim[i]);
    min3[1] = mathMin2(y, min3[1]);
    max3[1] = mathMax2(y, max3[1]);
  }
  min3[0] = mathMin2(x0, min3[0]);
  max3[0] = mathMax2(x0, max3[0]);
  min3[0] = mathMin2(x3, min3[0]);
  max3[0] = mathMax2(x3, max3[0]);
  min3[1] = mathMin2(y0, min3[1]);
  max3[1] = mathMax2(y0, max3[1]);
  min3[1] = mathMin2(y3, min3[1]);
  max3[1] = mathMax2(y3, max3[1]);
}
function fromQuadratic(x0, y0, x1, y1, x2, y2, min3, max3) {
  const quadraticExtremum2 = quadraticExtremum;
  const quadraticAt3 = quadraticAt;
  const tx = mathMax2(mathMin2(quadraticExtremum2(x0, x1, x2), 1), 0);
  const ty = mathMax2(mathMin2(quadraticExtremum2(y0, y1, y2), 1), 0);
  const x = quadraticAt3(x0, x1, x2, tx);
  const y = quadraticAt3(y0, y1, y2, ty);
  min3[0] = mathMin2(x0, x2, x);
  min3[1] = mathMin2(y0, y2, y);
  max3[0] = mathMax2(x0, x2, x);
  max3[1] = mathMax2(y0, y2, y);
}
function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min3, max3) {
  const vec2Min = min;
  const vec2Max = max;
  const diff = Math.abs(startAngle - endAngle);
  if (diff % PI2 < 1e-4 && diff > 1e-4) {
    min3[0] = x - rx;
    min3[1] = y - ry;
    max3[0] = x + rx;
    max3[1] = y + ry;
    return;
  }
  start[0] = mathCos(startAngle) * rx + x;
  start[1] = mathSin(startAngle) * ry + y;
  end[0] = mathCos(endAngle) * rx + x;
  end[1] = mathSin(endAngle) * ry + y;
  vec2Min(min3, start, end);
  vec2Max(max3, start, end);
  startAngle = startAngle % PI2;
  if (startAngle < 0) {
    startAngle = startAngle + PI2;
  }
  endAngle = endAngle % PI2;
  if (endAngle < 0) {
    endAngle = endAngle + PI2;
  }
  if (startAngle > endAngle && !anticlockwise) {
    endAngle += PI2;
  } else if (startAngle < endAngle && anticlockwise) {
    startAngle += PI2;
  }
  if (anticlockwise) {
    const tmp = endAngle;
    endAngle = startAngle;
    startAngle = tmp;
  }
  for (let angle = 0; angle < endAngle; angle += Math.PI / 2) {
    if (angle > startAngle) {
      extremity[0] = mathCos(angle) * rx + x;
      extremity[1] = mathSin(angle) * ry + y;
      vec2Min(min3, extremity, min3);
      vec2Max(max3, extremity, max3);
    }
  }
}

// node_modules/zrender/src/core/PathProxy.ts
var CMD = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
};
var tmpOutX = [];
var tmpOutY = [];
var min2 = [];
var max2 = [];
var min22 = [];
var max22 = [];
var mathMin3 = Math.min;
var mathMax3 = Math.max;
var mathCos2 = Math.cos;
var mathSin2 = Math.sin;
var mathAbs = Math.abs;
var PI = Math.PI;
var PI22 = PI * 2;
var hasTypedArray = typeof Float32Array !== "undefined";
var tmpAngles = [];
function modPI2(radian) {
  const n = Math.round(radian / PI * 1e8) / 1e8;
  return n % 2 * PI;
}
function normalizeArcAngles(angles, anticlockwise) {
  let newStartAngle = modPI2(angles[0]);
  if (newStartAngle < 0) {
    newStartAngle += PI22;
  }
  let delta = newStartAngle - angles[0];
  let newEndAngle = angles[1];
  newEndAngle += delta;
  if (!anticlockwise && newEndAngle - newStartAngle >= PI22) {
    newEndAngle = newStartAngle + PI22;
  } else if (anticlockwise && newStartAngle - newEndAngle >= PI22) {
    newEndAngle = newStartAngle - PI22;
  } else if (!anticlockwise && newStartAngle > newEndAngle) {
    newEndAngle = newStartAngle + (PI22 - modPI2(newStartAngle - newEndAngle));
  } else if (anticlockwise && newStartAngle < newEndAngle) {
    newEndAngle = newStartAngle - (PI22 - modPI2(newEndAngle - newStartAngle));
  }
  angles[0] = newStartAngle;
  angles[1] = newEndAngle;
}
var PathProxy2 = class {
  constructor(notSaveData) {
    this.dpr = 1;
    this._xi = 0;
    this._yi = 0;
    this._x0 = 0;
    this._y0 = 0;
    this._len = 0;
    if (notSaveData) {
      this._saveData = false;
    }
    if (this._saveData) {
      this.data = [];
    }
  }
  increaseVersion() {
    this._version++;
  }
  getVersion() {
    return this._version;
  }
  setScale(sx, sy, segmentIgnoreThreshold) {
    segmentIgnoreThreshold = segmentIgnoreThreshold || 0;
    if (segmentIgnoreThreshold > 0) {
      this._ux = mathAbs(segmentIgnoreThreshold / devicePixelRatio / sx) || 0;
      this._uy = mathAbs(segmentIgnoreThreshold / devicePixelRatio / sy) || 0;
    }
  }
  setDPR(dpr2) {
    this.dpr = dpr2;
  }
  setContext(ctx) {
    this._ctx = ctx;
  }
  getContext() {
    return this._ctx;
  }
  beginPath() {
    this._ctx && this._ctx.beginPath();
    this.reset();
    return this;
  }
  reset() {
    if (this._saveData) {
      this._len = 0;
    }
    if (this._pathSegLen) {
      this._pathSegLen = null;
      this._pathLen = 0;
    }
    this._version++;
  }
  moveTo(x, y) {
    this._drawPendingPt();
    this.addData(CMD.M, x, y);
    this._ctx && this._ctx.moveTo(x, y);
    this._x0 = x;
    this._y0 = y;
    this._xi = x;
    this._yi = y;
    return this;
  }
  lineTo(x, y) {
    const dx = mathAbs(x - this._xi);
    const dy = mathAbs(y - this._yi);
    const exceedUnit = dx > this._ux || dy > this._uy;
    this.addData(CMD.L, x, y);
    if (this._ctx && exceedUnit) {
      this._ctx.lineTo(x, y);
    }
    if (exceedUnit) {
      this._xi = x;
      this._yi = y;
      this._pendingPtDist = 0;
    } else {
      const d2 = dx * dx + dy * dy;
      if (d2 > this._pendingPtDist) {
        this._pendingPtX = x;
        this._pendingPtY = y;
        this._pendingPtDist = d2;
      }
    }
    return this;
  }
  bezierCurveTo(x1, y1, x2, y2, x3, y3) {
    this._drawPendingPt();
    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
    if (this._ctx) {
      this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
    }
    this._xi = x3;
    this._yi = y3;
    return this;
  }
  quadraticCurveTo(x1, y1, x2, y2) {
    this._drawPendingPt();
    this.addData(CMD.Q, x1, y1, x2, y2);
    if (this._ctx) {
      this._ctx.quadraticCurveTo(x1, y1, x2, y2);
    }
    this._xi = x2;
    this._yi = y2;
    return this;
  }
  arc(cx, cy, r, startAngle, endAngle, anticlockwise) {
    this._drawPendingPt();
    tmpAngles[0] = startAngle;
    tmpAngles[1] = endAngle;
    normalizeArcAngles(tmpAngles, anticlockwise);
    startAngle = tmpAngles[0];
    endAngle = tmpAngles[1];
    let delta = endAngle - startAngle;
    this.addData(CMD.A, cx, cy, r, r, startAngle, delta, 0, anticlockwise ? 0 : 1);
    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
    this._xi = mathCos2(endAngle) * r + cx;
    this._yi = mathSin2(endAngle) * r + cy;
    return this;
  }
  arcTo(x1, y1, x2, y2, radius) {
    this._drawPendingPt();
    if (this._ctx) {
      this._ctx.arcTo(x1, y1, x2, y2, radius);
    }
    return this;
  }
  rect(x, y, w, h) {
    this._drawPendingPt();
    this._ctx && this._ctx.rect(x, y, w, h);
    this.addData(CMD.R, x, y, w, h);
    return this;
  }
  closePath() {
    this._drawPendingPt();
    this.addData(CMD.Z);
    const ctx = this._ctx;
    const x0 = this._x0;
    const y0 = this._y0;
    if (ctx) {
      ctx.closePath();
    }
    this._xi = x0;
    this._yi = y0;
    return this;
  }
  fill(ctx) {
    ctx && ctx.fill();
    this.toStatic();
  }
  stroke(ctx) {
    ctx && ctx.stroke();
    this.toStatic();
  }
  len() {
    return this._len;
  }
  setData(data) {
    const len2 = data.length;
    if (!(this.data && this.data.length === len2) && hasTypedArray) {
      this.data = new Float32Array(len2);
    }
    for (let i = 0; i < len2; i++) {
      this.data[i] = data[i];
    }
    this._len = len2;
  }
  appendPath(path) {
    if (!(path instanceof Array)) {
      path = [path];
    }
    const len2 = path.length;
    let appendSize = 0;
    let offset = this._len;
    for (let i = 0; i < len2; i++) {
      appendSize += path[i].len();
    }
    if (hasTypedArray && this.data instanceof Float32Array) {
      this.data = new Float32Array(offset + appendSize);
    }
    for (let i = 0; i < len2; i++) {
      const appendPathData = path[i].data;
      for (let k = 0; k < appendPathData.length; k++) {
        this.data[offset++] = appendPathData[k];
      }
    }
    this._len = offset;
  }
  addData(cmd, a, b, c, d, e2, f, g, h) {
    if (!this._saveData) {
      return;
    }
    let data = this.data;
    if (this._len + arguments.length > data.length) {
      this._expandData();
      data = this.data;
    }
    for (let i = 0; i < arguments.length; i++) {
      data[this._len++] = arguments[i];
    }
  }
  _drawPendingPt() {
    if (this._pendingPtDist > 0) {
      this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY);
      this._pendingPtDist = 0;
    }
  }
  _expandData() {
    if (!(this.data instanceof Array)) {
      const newData = [];
      for (let i = 0; i < this._len; i++) {
        newData[i] = this.data[i];
      }
      this.data = newData;
    }
  }
  toStatic() {
    if (!this._saveData) {
      return;
    }
    this._drawPendingPt();
    const data = this.data;
    if (data instanceof Array) {
      data.length = this._len;
      if (hasTypedArray && this._len > 11) {
        this.data = new Float32Array(data);
      }
    }
  }
  getBoundingRect() {
    min2[0] = min2[1] = min22[0] = min22[1] = Number.MAX_VALUE;
    max2[0] = max2[1] = max22[0] = max22[1] = -Number.MAX_VALUE;
    const data = this.data;
    let xi = 0;
    let yi = 0;
    let x0 = 0;
    let y0 = 0;
    let i;
    for (i = 0; i < this._len; ) {
      const cmd = data[i++];
      const isFirst = i === 1;
      if (isFirst) {
        xi = data[i];
        yi = data[i + 1];
        x0 = xi;
        y0 = yi;
      }
      switch (cmd) {
        case CMD.M:
          xi = x0 = data[i++];
          yi = y0 = data[i++];
          min22[0] = x0;
          min22[1] = y0;
          max22[0] = x0;
          max22[1] = y0;
          break;
        case CMD.L:
          fromLine(xi, yi, data[i], data[i + 1], min22, max22);
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD.C:
          fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min22, max22);
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD.Q:
          fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min22, max22);
          xi = data[i++];
          yi = data[i++];
          break;
        case CMD.A:
          const cx = data[i++];
          const cy = data[i++];
          const rx = data[i++];
          const ry = data[i++];
          const startAngle = data[i++];
          const endAngle = data[i++] + startAngle;
          i += 1;
          const anticlockwise = !data[i++];
          if (isFirst) {
            x0 = mathCos2(startAngle) * rx + cx;
            y0 = mathSin2(startAngle) * ry + cy;
          }
          fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min22, max22);
          xi = mathCos2(endAngle) * rx + cx;
          yi = mathSin2(endAngle) * ry + cy;
          break;
        case CMD.R:
          x0 = xi = data[i++];
          y0 = yi = data[i++];
          const width = data[i++];
          const height = data[i++];
          fromLine(x0, y0, x0 + width, y0 + height, min22, max22);
          break;
        case CMD.Z:
          xi = x0;
          yi = y0;
          break;
      }
      min(min2, min2, min22);
      max(max2, max2, max22);
    }
    if (i === 0) {
      min2[0] = min2[1] = max2[0] = max2[1] = 0;
    }
    return new BoundingRect_default(min2[0], min2[1], max2[0] - min2[0], max2[1] - min2[1]);
  }
  _calculateLength() {
    const data = this.data;
    const len2 = this._len;
    const ux = this._ux;
    const uy = this._uy;
    let xi = 0;
    let yi = 0;
    let x0 = 0;
    let y0 = 0;
    if (!this._pathSegLen) {
      this._pathSegLen = [];
    }
    const pathSegLen = this._pathSegLen;
    let pathTotalLen = 0;
    let segCount = 0;
    for (let i = 0; i < len2; ) {
      const cmd = data[i++];
      const isFirst = i === 1;
      if (isFirst) {
        xi = data[i];
        yi = data[i + 1];
        x0 = xi;
        y0 = yi;
      }
      let l = -1;
      switch (cmd) {
        case CMD.M:
          xi = x0 = data[i++];
          yi = y0 = data[i++];
          break;
        case CMD.L: {
          const x2 = data[i++];
          const y2 = data[i++];
          const dx = x2 - xi;
          const dy = y2 - yi;
          if (mathAbs(dx) > ux || mathAbs(dy) > uy || i === len2 - 1) {
            l = Math.sqrt(dx * dx + dy * dy);
            xi = x2;
            yi = y2;
          }
          break;
        }
        case CMD.C: {
          const x1 = data[i++];
          const y1 = data[i++];
          const x2 = data[i++];
          const y2 = data[i++];
          const x3 = data[i++];
          const y3 = data[i++];
          l = cubicLength(xi, yi, x1, y1, x2, y2, x3, y3, 10);
          xi = x3;
          yi = y3;
          break;
        }
        case CMD.Q: {
          const x1 = data[i++];
          const y1 = data[i++];
          const x2 = data[i++];
          const y2 = data[i++];
          l = quadraticLength(xi, yi, x1, y1, x2, y2, 10);
          xi = x2;
          yi = y2;
          break;
        }
        case CMD.A:
          const cx = data[i++];
          const cy = data[i++];
          const rx = data[i++];
          const ry = data[i++];
          const startAngle = data[i++];
          let delta = data[i++];
          const endAngle = delta + startAngle;
          i += 1;
          if (isFirst) {
            x0 = mathCos2(startAngle) * rx + cx;
            y0 = mathSin2(startAngle) * ry + cy;
          }
          l = mathMax3(rx, ry) * mathMin3(PI22, Math.abs(delta));
          xi = mathCos2(endAngle) * rx + cx;
          yi = mathSin2(endAngle) * ry + cy;
          break;
        case CMD.R: {
          x0 = xi = data[i++];
          y0 = yi = data[i++];
          const width = data[i++];
          const height = data[i++];
          l = width * 2 + height * 2;
          break;
        }
        case CMD.Z: {
          const dx = x0 - xi;
          const dy = y0 - yi;
          l = Math.sqrt(dx * dx + dy * dy);
          xi = x0;
          yi = y0;
          break;
        }
      }
      if (l >= 0) {
        pathSegLen[segCount++] = l;
        pathTotalLen += l;
      }
    }
    this._pathLen = pathTotalLen;
    return pathTotalLen;
  }
  rebuildPath(ctx, percent) {
    const d = this.data;
    const ux = this._ux;
    const uy = this._uy;
    const len2 = this._len;
    let x0;
    let y0;
    let xi;
    let yi;
    let x;
    let y;
    const drawPart = percent < 1;
    let pathSegLen;
    let pathTotalLen;
    let accumLength = 0;
    let segCount = 0;
    let displayedLength;
    let pendingPtDist = 0;
    let pendingPtX;
    let pendingPtY;
    if (drawPart) {
      if (!this._pathSegLen) {
        this._calculateLength();
      }
      pathSegLen = this._pathSegLen;
      pathTotalLen = this._pathLen;
      displayedLength = percent * pathTotalLen;
      if (!displayedLength) {
        return;
      }
    }
    lo:
      for (let i = 0; i < len2; ) {
        const cmd = d[i++];
        const isFirst = i === 1;
        if (isFirst) {
          xi = d[i];
          yi = d[i + 1];
          x0 = xi;
          y0 = yi;
        }
        if (cmd !== CMD.L && pendingPtDist > 0) {
          ctx.lineTo(pendingPtX, pendingPtY);
          pendingPtDist = 0;
        }
        switch (cmd) {
          case CMD.M:
            x0 = xi = d[i++];
            y0 = yi = d[i++];
            ctx.moveTo(xi, yi);
            break;
          case CMD.L: {
            x = d[i++];
            y = d[i++];
            const dx = mathAbs(x - xi);
            const dy = mathAbs(y - yi);
            if (dx > ux || dy > uy) {
              if (drawPart) {
                const l = pathSegLen[segCount++];
                if (accumLength + l > displayedLength) {
                  const t = (displayedLength - accumLength) / l;
                  ctx.lineTo(xi * (1 - t) + x * t, yi * (1 - t) + y * t);
                  break lo;
                }
                accumLength += l;
              }
              ctx.lineTo(x, y);
              xi = x;
              yi = y;
              pendingPtDist = 0;
            } else {
              const d2 = dx * dx + dy * dy;
              if (d2 > pendingPtDist) {
                pendingPtX = x;
                pendingPtY = y;
                pendingPtDist = d2;
              }
            }
            break;
          }
          case CMD.C: {
            const x1 = d[i++];
            const y1 = d[i++];
            const x2 = d[i++];
            const y2 = d[i++];
            const x3 = d[i++];
            const y3 = d[i++];
            if (drawPart) {
              const l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                const t = (displayedLength - accumLength) / l;
                cubicSubdivide(xi, x1, x2, x3, t, tmpOutX);
                cubicSubdivide(yi, y1, y2, y3, t, tmpOutY);
                ctx.bezierCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2], tmpOutX[3], tmpOutY[3]);
                break lo;
              }
              accumLength += l;
            }
            ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
            xi = x3;
            yi = y3;
            break;
          }
          case CMD.Q: {
            const x1 = d[i++];
            const y1 = d[i++];
            const x2 = d[i++];
            const y2 = d[i++];
            if (drawPart) {
              const l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                const t = (displayedLength - accumLength) / l;
                quadraticSubdivide(xi, x1, x2, t, tmpOutX);
                quadraticSubdivide(yi, y1, y2, t, tmpOutY);
                ctx.quadraticCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2]);
                break lo;
              }
              accumLength += l;
            }
            ctx.quadraticCurveTo(x1, y1, x2, y2);
            xi = x2;
            yi = y2;
            break;
          }
          case CMD.A:
            const cx = d[i++];
            const cy = d[i++];
            const rx = d[i++];
            const ry = d[i++];
            let startAngle = d[i++];
            let delta = d[i++];
            const psi = d[i++];
            const anticlockwise = !d[i++];
            const r = rx > ry ? rx : ry;
            const isEllipse = mathAbs(rx - ry) > 1e-3;
            let endAngle = startAngle + delta;
            let breakBuild = false;
            if (drawPart) {
              const l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                endAngle = startAngle + delta * (displayedLength - accumLength) / l;
                breakBuild = true;
              }
              accumLength += l;
            }
            if (isEllipse && ctx.ellipse) {
              ctx.ellipse(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise);
            } else {
              ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
            }
            if (breakBuild) {
              break lo;
            }
            if (isFirst) {
              x0 = mathCos2(startAngle) * rx + cx;
              y0 = mathSin2(startAngle) * ry + cy;
            }
            xi = mathCos2(endAngle) * rx + cx;
            yi = mathSin2(endAngle) * ry + cy;
            break;
          case CMD.R:
            x0 = xi = d[i];
            y0 = yi = d[i + 1];
            x = d[i++];
            y = d[i++];
            const width = d[i++];
            const height = d[i++];
            if (drawPart) {
              const l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                let d2 = displayedLength - accumLength;
                ctx.moveTo(x, y);
                ctx.lineTo(x + mathMin3(d2, width), y);
                d2 -= width;
                if (d2 > 0) {
                  ctx.lineTo(x + width, y + mathMin3(d2, height));
                }
                d2 -= height;
                if (d2 > 0) {
                  ctx.lineTo(x + mathMax3(width - d2, 0), y + height);
                }
                d2 -= width;
                if (d2 > 0) {
                  ctx.lineTo(x, y + mathMax3(height - d2, 0));
                }
                break lo;
              }
              accumLength += l;
            }
            ctx.rect(x, y, width, height);
            break;
          case CMD.Z:
            if (drawPart) {
              const l = pathSegLen[segCount++];
              if (accumLength + l > displayedLength) {
                const t = (displayedLength - accumLength) / l;
                ctx.lineTo(xi * (1 - t) + x0 * t, yi * (1 - t) + y0 * t);
                break lo;
              }
              accumLength += l;
            }
            ctx.closePath();
            xi = x0;
            yi = y0;
        }
      }
  }
  clone() {
    const newProxy = new PathProxy2();
    const data = this.data;
    newProxy.data = data.slice ? data.slice() : Array.prototype.slice.call(data);
    newProxy._len = this._len;
    return newProxy;
  }
};
var PathProxy = PathProxy2;
PathProxy.CMD = CMD;
PathProxy.initDefaultProps = function() {
  const proto2 = PathProxy2.prototype;
  proto2._saveData = true;
  proto2._ux = 0;
  proto2._uy = 0;
  proto2._pendingPtDist = 0;
  proto2._version = 0;
}();
var PathProxy_default = PathProxy;

// node_modules/zrender/src/contain/line.ts
function containStroke(x0, y0, x1, y1, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }
  const _l = lineWidth;
  let _a = 0;
  let _b = x0;
  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
    return false;
  }
  if (x0 !== x1) {
    _a = (y0 - y1) / (x0 - x1);
    _b = (x0 * y1 - x1 * y0) / (x0 - x1);
  } else {
    return Math.abs(x - x0) <= _l / 2;
  }
  const tmp = _a * x - y + _b;
  const _s = tmp * tmp / (_a * _a + 1);
  return _s <= _l / 2 * _l / 2;
}

// node_modules/zrender/src/contain/cubic.ts
function containStroke2(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }
  const _l = lineWidth;
  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
    return false;
  }
  const d = cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
  return d <= _l / 2;
}

// node_modules/zrender/src/contain/quadratic.ts
function containStroke3(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }
  const _l = lineWidth;
  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
    return false;
  }
  const d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
  return d <= _l / 2;
}

// node_modules/zrender/src/contain/util.ts
var PI23 = Math.PI * 2;
function normalizeRadian(angle) {
  angle %= PI23;
  if (angle < 0) {
    angle += PI23;
  }
  return angle;
}

// node_modules/zrender/src/contain/arc.ts
var PI24 = Math.PI * 2;
function containStroke4(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
  if (lineWidth === 0) {
    return false;
  }
  const _l = lineWidth;
  x -= cx;
  y -= cy;
  const d = Math.sqrt(x * x + y * y);
  if (d - _l > r || d + _l < r) {
    return false;
  }
  if (Math.abs(startAngle - endAngle) % PI24 < 1e-4) {
    return true;
  }
  if (anticlockwise) {
    const tmp = startAngle;
    startAngle = normalizeRadian(endAngle);
    endAngle = normalizeRadian(tmp);
  } else {
    startAngle = normalizeRadian(startAngle);
    endAngle = normalizeRadian(endAngle);
  }
  if (startAngle > endAngle) {
    endAngle += PI24;
  }
  let angle = Math.atan2(y, x);
  if (angle < 0) {
    angle += PI24;
  }
  return angle >= startAngle && angle <= endAngle || angle + PI24 >= startAngle && angle + PI24 <= endAngle;
}

// node_modules/zrender/src/contain/windingLine.ts
function windingLine(x0, y0, x1, y1, x, y) {
  if (y > y0 && y > y1 || y < y0 && y < y1) {
    return 0;
  }
  if (y1 === y0) {
    return 0;
  }
  const t = (y - y0) / (y1 - y0);
  let dir3 = y1 < y0 ? 1 : -1;
  if (t === 1 || t === 0) {
    dir3 = y1 < y0 ? 0.5 : -0.5;
  }
  const x_ = t * (x1 - x0) + x0;
  return x_ === x ? Infinity : x_ > x ? dir3 : 0;
}

// node_modules/zrender/src/contain/path.ts
var CMD2 = PathProxy_default.CMD;
var PI25 = Math.PI * 2;
var EPSILON4 = 1e-4;
function isAroundEqual(a, b) {
  return Math.abs(a - b) < EPSILON4;
}
var roots = [-1, -1, -1];
var extrema = [-1, -1];
function swapExtrema() {
  const tmp = extrema[0];
  extrema[0] = extrema[1];
  extrema[1] = tmp;
}
function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
    return 0;
  }
  const nRoots = cubicRootAt(y0, y1, y2, y3, y, roots);
  if (nRoots === 0) {
    return 0;
  } else {
    let w = 0;
    let nExtrema = -1;
    let y0_;
    let y1_;
    for (let i = 0; i < nRoots; i++) {
      let t = roots[i];
      let unit = t === 0 || t === 1 ? 0.5 : 1;
      let x_ = cubicAt(x0, x1, x2, x3, t);
      if (x_ < x) {
        continue;
      }
      if (nExtrema < 0) {
        nExtrema = cubicExtrema(y0, y1, y2, y3, extrema);
        if (extrema[1] < extrema[0] && nExtrema > 1) {
          swapExtrema();
        }
        y0_ = cubicAt(y0, y1, y2, y3, extrema[0]);
        if (nExtrema > 1) {
          y1_ = cubicAt(y0, y1, y2, y3, extrema[1]);
        }
      }
      if (nExtrema === 2) {
        if (t < extrema[0]) {
          w += y0_ < y0 ? unit : -unit;
        } else if (t < extrema[1]) {
          w += y1_ < y0_ ? unit : -unit;
        } else {
          w += y3 < y1_ ? unit : -unit;
        }
      } else {
        if (t < extrema[0]) {
          w += y0_ < y0 ? unit : -unit;
        } else {
          w += y3 < y0_ ? unit : -unit;
        }
      }
    }
    return w;
  }
}
function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
    return 0;
  }
  const nRoots = quadraticRootAt(y0, y1, y2, y, roots);
  if (nRoots === 0) {
    return 0;
  } else {
    const t = quadraticExtremum(y0, y1, y2);
    if (t >= 0 && t <= 1) {
      let w = 0;
      let y_ = quadraticAt(y0, y1, y2, t);
      for (let i = 0; i < nRoots; i++) {
        let unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;
        let x_ = quadraticAt(x0, x1, x2, roots[i]);
        if (x_ < x) {
          continue;
        }
        if (roots[i] < t) {
          w += y_ < y0 ? unit : -unit;
        } else {
          w += y2 < y_ ? unit : -unit;
        }
      }
      return w;
    } else {
      const unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;
      const x_ = quadraticAt(x0, x1, x2, roots[0]);
      if (x_ < x) {
        return 0;
      }
      return y2 < y0 ? unit : -unit;
    }
  }
}
function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
  y -= cy;
  if (y > r || y < -r) {
    return 0;
  }
  const tmp = Math.sqrt(r * r - y * y);
  roots[0] = -tmp;
  roots[1] = tmp;
  const dTheta = Math.abs(startAngle - endAngle);
  if (dTheta < 1e-4) {
    return 0;
  }
  if (dTheta >= PI25 - 1e-4) {
    startAngle = 0;
    endAngle = PI25;
    const dir3 = anticlockwise ? 1 : -1;
    if (x >= roots[0] + cx && x <= roots[1] + cx) {
      return dir3;
    } else {
      return 0;
    }
  }
  if (startAngle > endAngle) {
    const tmp2 = startAngle;
    startAngle = endAngle;
    endAngle = tmp2;
  }
  if (startAngle < 0) {
    startAngle += PI25;
    endAngle += PI25;
  }
  let w = 0;
  for (let i = 0; i < 2; i++) {
    const x_ = roots[i];
    if (x_ + cx > x) {
      let angle = Math.atan2(y, x_);
      let dir3 = anticlockwise ? 1 : -1;
      if (angle < 0) {
        angle = PI25 + angle;
      }
      if (angle >= startAngle && angle <= endAngle || angle + PI25 >= startAngle && angle + PI25 <= endAngle) {
        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
          dir3 = -dir3;
        }
        w += dir3;
      }
    }
  }
  return w;
}
function containPath(path, lineWidth, isStroke, x, y) {
  const data = path.data;
  const len2 = path.len();
  let w = 0;
  let xi = 0;
  let yi = 0;
  let x0 = 0;
  let y0 = 0;
  let x1;
  let y1;
  for (let i = 0; i < len2; ) {
    const cmd = data[i++];
    const isFirst = i === 1;
    if (cmd === CMD2.M && i > 1) {
      if (!isStroke) {
        w += windingLine(xi, yi, x0, y0, x, y);
      }
    }
    if (isFirst) {
      xi = data[i];
      yi = data[i + 1];
      x0 = xi;
      y0 = yi;
    }
    switch (cmd) {
      case CMD2.M:
        x0 = data[i++];
        y0 = data[i++];
        xi = x0;
        yi = y0;
        break;
      case CMD2.L:
        if (isStroke) {
          if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
        }
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD2.C:
        if (isStroke) {
          if (containStroke2(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
        }
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD2.Q:
        if (isStroke) {
          if (containStroke3(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
        }
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD2.A:
        const cx = data[i++];
        const cy = data[i++];
        const rx = data[i++];
        const ry = data[i++];
        const theta = data[i++];
        const dTheta = data[i++];
        i += 1;
        const anticlockwise = !!(1 - data[i++]);
        x1 = Math.cos(theta) * rx + cx;
        y1 = Math.sin(theta) * ry + cy;
        if (!isFirst) {
          w += windingLine(xi, yi, x1, y1, x, y);
        } else {
          x0 = x1;
          y0 = y1;
        }
        const _x = (x - cx) * ry / rx + cx;
        if (isStroke) {
          if (containStroke4(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
            return true;
          }
        } else {
          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
        }
        xi = Math.cos(theta + dTheta) * rx + cx;
        yi = Math.sin(theta + dTheta) * ry + cy;
        break;
      case CMD2.R:
        x0 = xi = data[i++];
        y0 = yi = data[i++];
        const width = data[i++];
        const height = data[i++];
        x1 = x0 + width;
        y1 = y0 + height;
        if (isStroke) {
          if (containStroke(x0, y0, x1, y0, lineWidth, x, y) || containStroke(x1, y0, x1, y1, lineWidth, x, y) || containStroke(x1, y1, x0, y1, lineWidth, x, y) || containStroke(x0, y1, x0, y0, lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingLine(x1, y0, x1, y1, x, y);
          w += windingLine(x0, y1, x0, y0, x, y);
        }
        break;
      case CMD2.Z:
        if (isStroke) {
          if (containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
            return true;
          }
        } else {
          w += windingLine(xi, yi, x0, y0, x, y);
        }
        xi = x0;
        yi = y0;
        break;
    }
  }
  if (!isStroke && !isAroundEqual(yi, y0)) {
    w += windingLine(xi, yi, x0, y0, x, y) || 0;
  }
  return w !== 0;
}
function contain(pathProxy, x, y) {
  return containPath(pathProxy, 0, false, x, y);
}
function containStroke5(pathProxy, lineWidth, x, y) {
  return containPath(pathProxy, lineWidth, true, x, y);
}

// node_modules/zrender/src/graphic/Path.ts
var DEFAULT_PATH_STYLE = defaults({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: false,
  strokeFirst: false
}, DEFAULT_COMMON_STYLE);
var DEFAULT_PATH_ANIMATION_PROPS = {
  style: defaults({
    fill: true,
    stroke: true,
    strokePercent: true,
    fillOpacity: true,
    strokeOpacity: true,
    lineDashOffset: true,
    lineWidth: true,
    miterLimit: true
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
var pathCopyParams = TRANSFORMABLE_PROPS.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]);
var Path2 = class extends Displayable_default {
  constructor(opts) {
    super(opts);
  }
  update() {
    super.update();
    const style = this.style;
    if (style.decal) {
      const decalEl = this._decalEl = this._decalEl || new Path2();
      if (decalEl.buildPath === Path2.prototype.buildPath) {
        decalEl.buildPath = (ctx) => {
          this.buildPath(ctx, this.shape);
        };
      }
      decalEl.silent = true;
      const decalElStyle = decalEl.style;
      for (let key in style) {
        if (decalElStyle[key] !== style[key]) {
          decalElStyle[key] = style[key];
        }
      }
      decalElStyle.fill = style.fill ? style.decal : null;
      decalElStyle.decal = null;
      decalElStyle.shadowColor = null;
      style.strokeFirst && (decalElStyle.stroke = null);
      for (let i = 0; i < pathCopyParams.length; ++i) {
        decalEl[pathCopyParams[i]] = this[pathCopyParams[i]];
      }
      decalEl.__dirty |= REDRAW_BIT;
    } else if (this._decalEl) {
      this._decalEl = null;
    }
  }
  getDecalElement() {
    return this._decalEl;
  }
  _init(props) {
    const keysArr = keys(props);
    this.shape = this.getDefaultShape();
    const defaultStyle = this.getDefaultStyle();
    if (defaultStyle) {
      this.useStyle(defaultStyle);
    }
    for (let i = 0; i < keysArr.length; i++) {
      const key = keysArr[i];
      const value = props[key];
      if (key === "style") {
        if (!this.style) {
          this.useStyle(value);
        } else {
          extend(this.style, value);
        }
      } else if (key === "shape") {
        extend(this.shape, value);
      } else {
        super.attrKV(key, value);
      }
    }
    if (!this.style) {
      this.useStyle({});
    }
  }
  getDefaultStyle() {
    return null;
  }
  getDefaultShape() {
    return {};
  }
  canBeInsideText() {
    return this.hasFill();
  }
  getInsideTextFill() {
    const pathFill = this.style.fill;
    if (pathFill !== "none") {
      if (isString(pathFill)) {
        const fillLum = lum(pathFill, 0);
        if (fillLum > 0.5) {
          return DARK_LABEL_COLOR;
        } else if (fillLum > 0.2) {
          return LIGHTER_LABEL_COLOR;
        }
        return LIGHT_LABEL_COLOR;
      } else if (pathFill) {
        return LIGHT_LABEL_COLOR;
      }
    }
    return DARK_LABEL_COLOR;
  }
  getInsideTextStroke(textFill) {
    const pathFill = this.style.fill;
    if (isString(pathFill)) {
      const zr = this.__zr;
      const isDarkMode2 = !!(zr && zr.isDarkMode());
      const isDarkLabel = lum(textFill, 0) < DARK_MODE_THRESHOLD;
      if (isDarkMode2 === isDarkLabel) {
        return pathFill;
      }
    }
  }
  buildPath(ctx, shapeCfg, inBatch) {
  }
  pathUpdated() {
    this.__dirty &= ~SHAPE_CHANGED_BIT;
  }
  getUpdatedPathProxy(inBatch) {
    !this.path && this.createPathProxy();
    this.path.beginPath();
    this.buildPath(this.path, this.shape, inBatch);
    return this.path;
  }
  createPathProxy() {
    this.path = new PathProxy_default(false);
  }
  hasStroke() {
    const style = this.style;
    const stroke = style.stroke;
    return !(stroke == null || stroke === "none" || !(style.lineWidth > 0));
  }
  hasFill() {
    const style = this.style;
    const fill = style.fill;
    return fill != null && fill !== "none";
  }
  getBoundingRect() {
    let rect = this._rect;
    const style = this.style;
    const needsUpdateRect = !rect;
    if (needsUpdateRect) {
      let firstInvoke = false;
      if (!this.path) {
        firstInvoke = true;
        this.createPathProxy();
      }
      let path = this.path;
      if (firstInvoke || this.__dirty & SHAPE_CHANGED_BIT) {
        path.beginPath();
        this.buildPath(path, this.shape, false);
        this.pathUpdated();
      }
      rect = path.getBoundingRect();
    }
    this._rect = rect;
    if (this.hasStroke() && this.path && this.path.len() > 0) {
      const rectStroke = this._rectStroke || (this._rectStroke = rect.clone());
      if (this.__dirty || needsUpdateRect) {
        rectStroke.copy(rect);
        const lineScale = style.strokeNoScale ? this.getLineScale() : 1;
        let w = style.lineWidth;
        if (!this.hasFill()) {
          const strokeContainThreshold = this.strokeContainThreshold;
          w = Math.max(w, strokeContainThreshold == null ? 4 : strokeContainThreshold);
        }
        if (lineScale > 1e-10) {
          rectStroke.width += w / lineScale;
          rectStroke.height += w / lineScale;
          rectStroke.x -= w / lineScale / 2;
          rectStroke.y -= w / lineScale / 2;
        }
      }
      return rectStroke;
    }
    return rect;
  }
  contain(x, y) {
    const localPos = this.transformCoordToLocal(x, y);
    const rect = this.getBoundingRect();
    const style = this.style;
    x = localPos[0];
    y = localPos[1];
    if (rect.contain(x, y)) {
      const pathProxy = this.path;
      if (this.hasStroke()) {
        let lineWidth = style.lineWidth;
        let lineScale = style.strokeNoScale ? this.getLineScale() : 1;
        if (lineScale > 1e-10) {
          if (!this.hasFill()) {
            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
          }
          if (containStroke5(pathProxy, lineWidth / lineScale, x, y)) {
            return true;
          }
        }
      }
      if (this.hasFill()) {
        return contain(pathProxy, x, y);
      }
    }
    return false;
  }
  dirtyShape() {
    this.__dirty |= SHAPE_CHANGED_BIT;
    if (this._rect) {
      this._rect = null;
    }
    if (this._decalEl) {
      this._decalEl.dirtyShape();
    }
    this.markRedraw();
  }
  dirty() {
    this.dirtyStyle();
    this.dirtyShape();
  }
  animateShape(loop) {
    return this.animate("shape", loop);
  }
  updateDuringAnimation(targetKey) {
    if (targetKey === "style") {
      this.dirtyStyle();
    } else if (targetKey === "shape") {
      this.dirtyShape();
    } else {
      this.markRedraw();
    }
  }
  attrKV(key, value) {
    if (key === "shape") {
      this.setShape(value);
    } else {
      super.attrKV(key, value);
    }
  }
  setShape(keyOrObj, value) {
    let shape = this.shape;
    if (!shape) {
      shape = this.shape = {};
    }
    if (typeof keyOrObj === "string") {
      shape[keyOrObj] = value;
    } else {
      extend(shape, keyOrObj);
    }
    this.dirtyShape();
    return this;
  }
  shapeChanged() {
    return !!(this.__dirty & SHAPE_CHANGED_BIT);
  }
  createStyle(obj) {
    return createObject(DEFAULT_PATH_STYLE, obj);
  }
  _innerSaveToNormal(toState) {
    super._innerSaveToNormal(toState);
    const normalState = this._normalState;
    if (toState.shape && !normalState.shape) {
      normalState.shape = extend({}, this.shape);
    }
  }
  _applyStateObj(stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
    super._applyStateObj(stateName, state, normalState, keepCurrentStates, transition, animationCfg);
    const needsRestoreToNormal = !(state && keepCurrentStates);
    let targetShape;
    if (state && state.shape) {
      if (transition) {
        if (keepCurrentStates) {
          targetShape = state.shape;
        } else {
          targetShape = extend({}, normalState.shape);
          extend(targetShape, state.shape);
        }
      } else {
        targetShape = extend({}, keepCurrentStates ? this.shape : normalState.shape);
        extend(targetShape, state.shape);
      }
    } else if (needsRestoreToNormal) {
      targetShape = normalState.shape;
    }
    if (targetShape) {
      if (transition) {
        this.shape = extend({}, this.shape);
        const targetShapePrimaryProps = {};
        const shapeKeys = keys(targetShape);
        for (let i = 0; i < shapeKeys.length; i++) {
          const key = shapeKeys[i];
          if (typeof targetShape[key] === "object") {
            this.shape[key] = targetShape[key];
          } else {
            targetShapePrimaryProps[key] = targetShape[key];
          }
        }
        this._transitionState(stateName, {
          shape: targetShapePrimaryProps
        }, animationCfg);
      } else {
        this.shape = targetShape;
        this.dirtyShape();
      }
    }
  }
  _mergeStates(states) {
    const mergedState = super._mergeStates(states);
    let mergedShape;
    for (let i = 0; i < states.length; i++) {
      const state = states[i];
      if (state.shape) {
        mergedShape = mergedShape || {};
        this._mergeStyle(mergedShape, state.shape);
      }
    }
    if (mergedShape) {
      mergedState.shape = mergedShape;
    }
    return mergedState;
  }
  getAnimationStyleProps() {
    return DEFAULT_PATH_ANIMATION_PROPS;
  }
  isZeroArea() {
    return false;
  }
  static extend(defaultProps) {
    class Sub extends Path2 {
      getDefaultStyle() {
        return clone(defaultProps.style);
      }
      getDefaultShape() {
        return clone(defaultProps.shape);
      }
      constructor(opts) {
        super(opts);
        defaultProps.init && defaultProps.init.call(this, opts);
      }
    }
    for (let key in defaultProps) {
      if (typeof defaultProps[key] === "function") {
        Sub.prototype[key] = defaultProps[key];
      }
    }
    return Sub;
  }
};
var Path = Path2;
Path.initDefaultProps = function() {
  const pathProto = Path2.prototype;
  pathProto.type = "path";
  pathProto.strokeContainThreshold = 5;
  pathProto.segmentIgnoreThreshold = 0;
  pathProto.subPixelOptimize = false;
  pathProto.autoBatch = false;
  pathProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT | SHAPE_CHANGED_BIT;
}();
var Path_default = Path;

// node_modules/zrender/src/graphic/TSpan.ts
var DEFAULT_TSPAN_STYLE = defaults({
  strokeFirst: true,
  font: DEFAULT_FONT,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, DEFAULT_PATH_STYLE);
var TSpan2 = class extends Displayable_default {
  hasStroke() {
    const style = this.style;
    const stroke = style.stroke;
    return stroke != null && stroke !== "none" && style.lineWidth > 0;
  }
  hasFill() {
    const style = this.style;
    const fill = style.fill;
    return fill != null && fill !== "none";
  }
  createStyle(obj) {
    return createObject(DEFAULT_TSPAN_STYLE, obj);
  }
  setBoundingRect(rect) {
    this._rect = rect;
  }
  getBoundingRect() {
    const style = this.style;
    if (!this._rect) {
      let text = style.text;
      text != null ? text += "" : text = "";
      const rect = getBoundingRect(text, style.font, style.textAlign, style.textBaseline);
      rect.x += style.x || 0;
      rect.y += style.y || 0;
      if (this.hasStroke()) {
        const w = style.lineWidth;
        rect.x -= w / 2;
        rect.y -= w / 2;
        rect.width += w;
        rect.height += w;
      }
      this._rect = rect;
    }
    return this._rect;
  }
};
var TSpan = TSpan2;
TSpan.initDefaultProps = function() {
  const tspanProto = TSpan2.prototype;
  tspanProto.dirtyRectTolerance = 10;
}();
TSpan.prototype.type = "tspan";
var TSpan_default = TSpan;

// node_modules/zrender/src/graphic/Image.ts
var DEFAULT_IMAGE_STYLE = defaults({
  x: 0,
  y: 0
}, DEFAULT_COMMON_STYLE);
var DEFAULT_IMAGE_ANIMATION_PROPS = {
  style: defaults({
    x: true,
    y: true,
    width: true,
    height: true,
    sx: true,
    sy: true,
    sWidth: true,
    sHeight: true
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
function isImageLike(source) {
  return !!(source && typeof source !== "string" && source.width && source.height);
}
var ZRImage = class extends Displayable_default {
  createStyle(obj) {
    return createObject(DEFAULT_IMAGE_STYLE, obj);
  }
  _getSize(dim) {
    const style = this.style;
    let size = style[dim];
    if (size != null) {
      return size;
    }
    const imageSource = isImageLike(style.image) ? style.image : this.__image;
    if (!imageSource) {
      return 0;
    }
    const otherDim = dim === "width" ? "height" : "width";
    let otherDimSize = style[otherDim];
    if (otherDimSize == null) {
      return imageSource[dim];
    } else {
      return imageSource[dim] / imageSource[otherDim] * otherDimSize;
    }
  }
  getWidth() {
    return this._getSize("width");
  }
  getHeight() {
    return this._getSize("height");
  }
  getAnimationStyleProps() {
    return DEFAULT_IMAGE_ANIMATION_PROPS;
  }
  getBoundingRect() {
    const style = this.style;
    if (!this._rect) {
      this._rect = new BoundingRect_default(style.x || 0, style.y || 0, this.getWidth(), this.getHeight());
    }
    return this._rect;
  }
};
ZRImage.prototype.type = "image";
var Image_default = ZRImage;

// node_modules/zrender/src/graphic/helper/roundRect.ts
function buildPath(ctx, shape) {
  let x = shape.x;
  let y = shape.y;
  let width = shape.width;
  let height = shape.height;
  let r = shape.r;
  let r1;
  let r2;
  let r3;
  let r4;
  if (width < 0) {
    x = x + width;
    width = -width;
  }
  if (height < 0) {
    y = y + height;
    height = -height;
  }
  if (typeof r === "number") {
    r1 = r2 = r3 = r4 = r;
  } else if (r instanceof Array) {
    if (r.length === 1) {
      r1 = r2 = r3 = r4 = r[0];
    } else if (r.length === 2) {
      r1 = r3 = r[0];
      r2 = r4 = r[1];
    } else if (r.length === 3) {
      r1 = r[0];
      r2 = r4 = r[1];
      r3 = r[2];
    } else {
      r1 = r[0];
      r2 = r[1];
      r3 = r[2];
      r4 = r[3];
    }
  } else {
    r1 = r2 = r3 = r4 = 0;
  }
  let total;
  if (r1 + r2 > width) {
    total = r1 + r2;
    r1 *= width / total;
    r2 *= width / total;
  }
  if (r3 + r4 > width) {
    total = r3 + r4;
    r3 *= width / total;
    r4 *= width / total;
  }
  if (r2 + r3 > height) {
    total = r2 + r3;
    r2 *= height / total;
    r3 *= height / total;
  }
  if (r1 + r4 > height) {
    total = r1 + r4;
    r1 *= height / total;
    r4 *= height / total;
  }
  ctx.moveTo(x + r1, y);
  ctx.lineTo(x + width - r2, y);
  r2 !== 0 && ctx.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
  ctx.lineTo(x + width, y + height - r3);
  r3 !== 0 && ctx.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
  ctx.lineTo(x + r4, y + height);
  r4 !== 0 && ctx.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
  ctx.lineTo(x, y + r1);
  r1 !== 0 && ctx.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
}

// node_modules/zrender/src/graphic/helper/subPixelOptimize.ts
var round2 = Math.round;
function subPixelOptimizeLine(outputShape, inputShape, style) {
  if (!inputShape) {
    return;
  }
  const x1 = inputShape.x1;
  const x2 = inputShape.x2;
  const y1 = inputShape.y1;
  const y2 = inputShape.y2;
  outputShape.x1 = x1;
  outputShape.x2 = x2;
  outputShape.y1 = y1;
  outputShape.y2 = y2;
  const lineWidth = style && style.lineWidth;
  if (!lineWidth) {
    return outputShape;
  }
  if (round2(x1 * 2) === round2(x2 * 2)) {
    outputShape.x1 = outputShape.x2 = subPixelOptimize(x1, lineWidth, true);
  }
  if (round2(y1 * 2) === round2(y2 * 2)) {
    outputShape.y1 = outputShape.y2 = subPixelOptimize(y1, lineWidth, true);
  }
  return outputShape;
}
function subPixelOptimizeRect(outputShape, inputShape, style) {
  if (!inputShape) {
    return;
  }
  const originX = inputShape.x;
  const originY = inputShape.y;
  const originWidth = inputShape.width;
  const originHeight = inputShape.height;
  outputShape.x = originX;
  outputShape.y = originY;
  outputShape.width = originWidth;
  outputShape.height = originHeight;
  const lineWidth = style && style.lineWidth;
  if (!lineWidth) {
    return outputShape;
  }
  outputShape.x = subPixelOptimize(originX, lineWidth, true);
  outputShape.y = subPixelOptimize(originY, lineWidth, true);
  outputShape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);
  outputShape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);
  return outputShape;
}
function subPixelOptimize(position2, lineWidth, positiveOrNegative) {
  if (!lineWidth) {
    return position2;
  }
  const doubledPosition = round2(position2 * 2);
  return (doubledPosition + round2(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
}

// node_modules/zrender/src/graphic/shape/Rect.ts
var RectShape = class {
  constructor() {
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
  }
};
var subPixelOptimizeOutputShape = {};
var Rect = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultShape() {
    return new RectShape();
  }
  buildPath(ctx, shape) {
    let x;
    let y;
    let width;
    let height;
    if (this.subPixelOptimize) {
      const optimizedShape = subPixelOptimizeRect(subPixelOptimizeOutputShape, shape, this.style);
      x = optimizedShape.x;
      y = optimizedShape.y;
      width = optimizedShape.width;
      height = optimizedShape.height;
      optimizedShape.r = shape.r;
      shape = optimizedShape;
    } else {
      x = shape.x;
      y = shape.y;
      width = shape.width;
      height = shape.height;
    }
    if (!shape.r) {
      ctx.rect(x, y, width, height);
    } else {
      buildPath(ctx, shape);
    }
  }
  isZeroArea() {
    return !this.shape.width || !this.shape.height;
  }
};
Rect.prototype.type = "rect";
var Rect_default = Rect;

// node_modules/zrender/src/graphic/Text.ts
var DEFAULT_RICH_TEXT_COLOR = {
  fill: "#000"
};
var DEFAULT_STROKE_LINE_WIDTH = 2;
var DEFAULT_TEXT_ANIMATION_PROPS = {
  style: defaults({
    fill: true,
    stroke: true,
    fillOpacity: true,
    strokeOpacity: true,
    lineWidth: true,
    fontSize: true,
    lineHeight: true,
    width: true,
    height: true,
    textShadowColor: true,
    textShadowBlur: true,
    textShadowOffsetX: true,
    textShadowOffsetY: true,
    backgroundColor: true,
    padding: true,
    borderColor: true,
    borderWidth: true,
    borderRadius: true
  }, DEFAULT_COMMON_ANIMATION_PROPS.style)
};
var ZRText = class extends Displayable_default {
  constructor(opts) {
    super();
    this.type = "text";
    this._children = [];
    this._defaultStyle = DEFAULT_RICH_TEXT_COLOR;
    this.attr(opts);
  }
  childrenRef() {
    return this._children;
  }
  update() {
    super.update();
    if (this.styleChanged()) {
      this._updateSubTexts();
    }
    for (let i = 0; i < this._children.length; i++) {
      const child = this._children[i];
      child.zlevel = this.zlevel;
      child.z = this.z;
      child.z2 = this.z2;
      child.culling = this.culling;
      child.cursor = this.cursor;
      child.invisible = this.invisible;
    }
  }
  updateTransform() {
    const innerTransformable = this.innerTransformable;
    if (innerTransformable) {
      innerTransformable.updateTransform();
      if (innerTransformable.transform) {
        this.transform = innerTransformable.transform;
      }
    } else {
      super.updateTransform();
    }
  }
  getLocalTransform(m2) {
    const innerTransformable = this.innerTransformable;
    return innerTransformable ? innerTransformable.getLocalTransform(m2) : super.getLocalTransform(m2);
  }
  getComputedTransform() {
    if (this.__hostTarget) {
      this.__hostTarget.getComputedTransform();
      this.__hostTarget.updateInnerText(true);
    }
    return super.getComputedTransform();
  }
  _updateSubTexts() {
    this._childCursor = 0;
    normalizeTextStyle(this.style);
    this.style.rich ? this._updateRichTexts() : this._updatePlainTexts();
    this._children.length = this._childCursor;
    this.styleUpdated();
  }
  addSelfToZr(zr) {
    super.addSelfToZr(zr);
    for (let i = 0; i < this._children.length; i++) {
      this._children[i].__zr = zr;
    }
  }
  removeSelfFromZr(zr) {
    super.removeSelfFromZr(zr);
    for (let i = 0; i < this._children.length; i++) {
      this._children[i].__zr = null;
    }
  }
  getBoundingRect() {
    if (this.styleChanged()) {
      this._updateSubTexts();
    }
    if (!this._rect) {
      const tmpRect3 = new BoundingRect_default(0, 0, 0, 0);
      const children = this._children;
      const tmpMat = [];
      let rect = null;
      for (let i = 0; i < children.length; i++) {
        const child = children[i];
        const childRect = child.getBoundingRect();
        const transform2 = child.getLocalTransform(tmpMat);
        if (transform2) {
          tmpRect3.copy(childRect);
          tmpRect3.applyTransform(transform2);
          rect = rect || tmpRect3.clone();
          rect.union(tmpRect3);
        } else {
          rect = rect || childRect.clone();
          rect.union(childRect);
        }
      }
      this._rect = rect || tmpRect3;
    }
    return this._rect;
  }
  setDefaultTextStyle(defaultTextStyle) {
    this._defaultStyle = defaultTextStyle || DEFAULT_RICH_TEXT_COLOR;
  }
  setTextContent(textContent) {
    if (true) {
      throw new Error("Can't attach text on another text");
    }
  }
  _mergeStyle(targetStyle, sourceStyle) {
    if (!sourceStyle) {
      return targetStyle;
    }
    const sourceRich = sourceStyle.rich;
    const targetRich = targetStyle.rich || sourceRich && {};
    extend(targetStyle, sourceStyle);
    if (sourceRich && targetRich) {
      this._mergeRich(targetRich, sourceRich);
      targetStyle.rich = targetRich;
    } else if (targetRich) {
      targetStyle.rich = targetRich;
    }
    return targetStyle;
  }
  _mergeRich(targetRich, sourceRich) {
    const richNames = keys(sourceRich);
    for (let i = 0; i < richNames.length; i++) {
      const richName = richNames[i];
      targetRich[richName] = targetRich[richName] || {};
      extend(targetRich[richName], sourceRich[richName]);
    }
  }
  getAnimationStyleProps() {
    return DEFAULT_TEXT_ANIMATION_PROPS;
  }
  _getOrCreateChild(Ctor) {
    let child = this._children[this._childCursor];
    if (!child || !(child instanceof Ctor)) {
      child = new Ctor();
    }
    this._children[this._childCursor++] = child;
    child.__zr = this.__zr;
    child.parent = this;
    return child;
  }
  _updatePlainTexts() {
    const style = this.style;
    const textFont = style.font || DEFAULT_FONT;
    const textPadding = style.padding;
    const text = getStyleText(style);
    const contentBlock = parsePlainText(text, style);
    const needDrawBg = needDrawBackground(style);
    const bgColorDrawn = !!style.backgroundColor;
    const outerHeight = contentBlock.outerHeight;
    const outerWidth = contentBlock.outerWidth;
    const contentWidth = contentBlock.contentWidth;
    const textLines = contentBlock.lines;
    const lineHeight = contentBlock.lineHeight;
    const defaultStyle = this._defaultStyle;
    const baseX = style.x || 0;
    const baseY = style.y || 0;
    const textAlign = style.align || defaultStyle.align || "left";
    const verticalAlign = style.verticalAlign || defaultStyle.verticalAlign || "top";
    let textX = baseX;
    let textY = adjustTextY2(baseY, contentBlock.contentHeight, verticalAlign);
    if (needDrawBg || textPadding) {
      const boxX = adjustTextX(baseX, outerWidth, textAlign);
      const boxY = adjustTextY2(baseY, outerHeight, verticalAlign);
      needDrawBg && this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
    }
    textY += lineHeight / 2;
    if (textPadding) {
      textX = getTextXForPadding(baseX, textAlign, textPadding);
      if (verticalAlign === "top") {
        textY += textPadding[0];
      } else if (verticalAlign === "bottom") {
        textY -= textPadding[2];
      }
    }
    let defaultLineWidth = 0;
    let useDefaultFill = false;
    const textFill = getFill("fill" in style ? style.fill : (useDefaultFill = true, defaultStyle.fill));
    const textStroke = getStroke("stroke" in style ? style.stroke : !bgColorDrawn && (!defaultStyle.autoStroke || useDefaultFill) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke) : null);
    const hasShadow2 = style.textShadowBlur > 0;
    const fixedBoundingRect = style.width != null && (style.overflow === "truncate" || style.overflow === "break" || style.overflow === "breakAll");
    const calculatedLineHeight = contentBlock.calculatedLineHeight;
    for (let i = 0; i < textLines.length; i++) {
      const el = this._getOrCreateChild(TSpan_default);
      const subElStyle = el.createStyle();
      el.useStyle(subElStyle);
      subElStyle.text = textLines[i];
      subElStyle.x = textX;
      subElStyle.y = textY;
      if (textAlign) {
        subElStyle.textAlign = textAlign;
      }
      subElStyle.textBaseline = "middle";
      subElStyle.opacity = style.opacity;
      subElStyle.strokeFirst = true;
      if (hasShadow2) {
        subElStyle.shadowBlur = style.textShadowBlur || 0;
        subElStyle.shadowColor = style.textShadowColor || "transparent";
        subElStyle.shadowOffsetX = style.textShadowOffsetX || 0;
        subElStyle.shadowOffsetY = style.textShadowOffsetY || 0;
      }
      subElStyle.stroke = textStroke;
      subElStyle.fill = textFill;
      if (textStroke) {
        subElStyle.lineWidth = style.lineWidth || defaultLineWidth;
        subElStyle.lineDash = style.lineDash;
        subElStyle.lineDashOffset = style.lineDashOffset || 0;
      }
      subElStyle.font = textFont;
      setSeparateFont(subElStyle, style);
      textY += lineHeight;
      if (fixedBoundingRect) {
        el.setBoundingRect(new BoundingRect_default(adjustTextX(subElStyle.x, style.width, subElStyle.textAlign), adjustTextY2(subElStyle.y, calculatedLineHeight, subElStyle.textBaseline), contentWidth, calculatedLineHeight));
      }
    }
  }
  _updateRichTexts() {
    const style = this.style;
    const text = getStyleText(style);
    const contentBlock = parseRichText(text, style);
    const contentWidth = contentBlock.width;
    const outerWidth = contentBlock.outerWidth;
    const outerHeight = contentBlock.outerHeight;
    const textPadding = style.padding;
    const baseX = style.x || 0;
    const baseY = style.y || 0;
    const defaultStyle = this._defaultStyle;
    const textAlign = style.align || defaultStyle.align;
    const verticalAlign = style.verticalAlign || defaultStyle.verticalAlign;
    const boxX = adjustTextX(baseX, outerWidth, textAlign);
    const boxY = adjustTextY2(baseY, outerHeight, verticalAlign);
    let xLeft = boxX;
    let lineTop = boxY;
    if (textPadding) {
      xLeft += textPadding[3];
      lineTop += textPadding[0];
    }
    let xRight = xLeft + contentWidth;
    if (needDrawBackground(style)) {
      this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
    }
    const bgColorDrawn = !!style.backgroundColor;
    for (let i = 0; i < contentBlock.lines.length; i++) {
      const line2 = contentBlock.lines[i];
      const tokens = line2.tokens;
      const tokenCount = tokens.length;
      const lineHeight = line2.lineHeight;
      let remainedWidth = line2.width;
      let leftIndex = 0;
      let lineXLeft = xLeft;
      let lineXRight = xRight;
      let rightIndex = tokenCount - 1;
      let token;
      while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.align || token.align === "left")) {
        this._placeToken(token, style, lineHeight, lineTop, lineXLeft, "left", bgColorDrawn);
        remainedWidth -= token.width;
        lineXLeft += token.width;
        leftIndex++;
      }
      while (rightIndex >= 0 && (token = tokens[rightIndex], token.align === "right")) {
        this._placeToken(token, style, lineHeight, lineTop, lineXRight, "right", bgColorDrawn);
        remainedWidth -= token.width;
        lineXRight -= token.width;
        rightIndex--;
      }
      lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - remainedWidth) / 2;
      while (leftIndex <= rightIndex) {
        token = tokens[leftIndex];
        this._placeToken(token, style, lineHeight, lineTop, lineXLeft + token.width / 2, "center", bgColorDrawn);
        lineXLeft += token.width;
        leftIndex++;
      }
      lineTop += lineHeight;
    }
  }
  _placeToken(token, style, lineHeight, lineTop, x, textAlign, parentBgColorDrawn) {
    const tokenStyle = style.rich[token.styleName] || {};
    tokenStyle.text = token.text;
    const verticalAlign = token.verticalAlign;
    let y = lineTop + lineHeight / 2;
    if (verticalAlign === "top") {
      y = lineTop + token.height / 2;
    } else if (verticalAlign === "bottom") {
      y = lineTop + lineHeight - token.height / 2;
    }
    const needDrawBg = !token.isLineHolder && needDrawBackground(tokenStyle);
    needDrawBg && this._renderBackground(tokenStyle, style, textAlign === "right" ? x - token.width : textAlign === "center" ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);
    const bgColorDrawn = !!tokenStyle.backgroundColor;
    const textPadding = token.textPadding;
    if (textPadding) {
      x = getTextXForPadding(x, textAlign, textPadding);
      y -= token.height / 2 - textPadding[0] - token.innerHeight / 2;
    }
    const el = this._getOrCreateChild(TSpan_default);
    const subElStyle = el.createStyle();
    el.useStyle(subElStyle);
    const defaultStyle = this._defaultStyle;
    let useDefaultFill = false;
    let defaultLineWidth = 0;
    const textFill = getFill("fill" in tokenStyle ? tokenStyle.fill : "fill" in style ? style.fill : (useDefaultFill = true, defaultStyle.fill));
    const textStroke = getStroke("stroke" in tokenStyle ? tokenStyle.stroke : "stroke" in style ? style.stroke : !bgColorDrawn && !parentBgColorDrawn && (!defaultStyle.autoStroke || useDefaultFill) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke) : null);
    const hasShadow2 = tokenStyle.textShadowBlur > 0 || style.textShadowBlur > 0;
    subElStyle.text = token.text;
    subElStyle.x = x;
    subElStyle.y = y;
    if (hasShadow2) {
      subElStyle.shadowBlur = tokenStyle.textShadowBlur || style.textShadowBlur || 0;
      subElStyle.shadowColor = tokenStyle.textShadowColor || style.textShadowColor || "transparent";
      subElStyle.shadowOffsetX = tokenStyle.textShadowOffsetX || style.textShadowOffsetX || 0;
      subElStyle.shadowOffsetY = tokenStyle.textShadowOffsetY || style.textShadowOffsetY || 0;
    }
    subElStyle.textAlign = textAlign;
    subElStyle.textBaseline = "middle";
    subElStyle.font = token.font || DEFAULT_FONT;
    subElStyle.opacity = retrieve3(tokenStyle.opacity, style.opacity, 1);
    setSeparateFont(subElStyle, tokenStyle);
    if (textStroke) {
      subElStyle.lineWidth = retrieve3(tokenStyle.lineWidth, style.lineWidth, defaultLineWidth);
      subElStyle.lineDash = retrieve2(tokenStyle.lineDash, style.lineDash);
      subElStyle.lineDashOffset = style.lineDashOffset || 0;
      subElStyle.stroke = textStroke;
    }
    if (textFill) {
      subElStyle.fill = textFill;
    }
    const textWidth = token.contentWidth;
    const textHeight = token.contentHeight;
    el.setBoundingRect(new BoundingRect_default(adjustTextX(subElStyle.x, textWidth, subElStyle.textAlign), adjustTextY2(subElStyle.y, textHeight, subElStyle.textBaseline), textWidth, textHeight));
  }
  _renderBackground(style, topStyle, x, y, width, height) {
    const textBackgroundColor = style.backgroundColor;
    const textBorderWidth = style.borderWidth;
    const textBorderColor = style.borderColor;
    const isImageBg = textBackgroundColor && textBackgroundColor.image;
    const isPlainOrGradientBg = textBackgroundColor && !isImageBg;
    const textBorderRadius = style.borderRadius;
    const self2 = this;
    let rectEl;
    let imgEl;
    if (isPlainOrGradientBg || style.lineHeight || textBorderWidth && textBorderColor) {
      rectEl = this._getOrCreateChild(Rect_default);
      rectEl.useStyle(rectEl.createStyle());
      rectEl.style.fill = null;
      const rectShape = rectEl.shape;
      rectShape.x = x;
      rectShape.y = y;
      rectShape.width = width;
      rectShape.height = height;
      rectShape.r = textBorderRadius;
      rectEl.dirtyShape();
    }
    if (isPlainOrGradientBg) {
      const rectStyle = rectEl.style;
      rectStyle.fill = textBackgroundColor || null;
      rectStyle.fillOpacity = retrieve2(style.fillOpacity, 1);
    } else if (isImageBg) {
      imgEl = this._getOrCreateChild(Image_default);
      imgEl.onload = function() {
        self2.dirtyStyle();
      };
      const imgStyle = imgEl.style;
      imgStyle.image = textBackgroundColor.image;
      imgStyle.x = x;
      imgStyle.y = y;
      imgStyle.width = width;
      imgStyle.height = height;
    }
    if (textBorderWidth && textBorderColor) {
      const rectStyle = rectEl.style;
      rectStyle.lineWidth = textBorderWidth;
      rectStyle.stroke = textBorderColor;
      rectStyle.strokeOpacity = retrieve2(style.strokeOpacity, 1);
      rectStyle.lineDash = style.borderDash;
      rectStyle.lineDashOffset = style.borderDashOffset || 0;
      rectEl.strokeContainThreshold = 0;
      if (rectEl.hasFill() && rectEl.hasStroke()) {
        rectStyle.strokeFirst = true;
        rectStyle.lineWidth *= 2;
      }
    }
    const commonStyle = (rectEl || imgEl).style;
    commonStyle.shadowBlur = style.shadowBlur || 0;
    commonStyle.shadowColor = style.shadowColor || "transparent";
    commonStyle.shadowOffsetX = style.shadowOffsetX || 0;
    commonStyle.shadowOffsetY = style.shadowOffsetY || 0;
    commonStyle.opacity = retrieve3(style.opacity, topStyle.opacity, 1);
  }
  static makeFont(style) {
    let font = "";
    if (hasSeparateFont(style)) {
      font = [
        style.fontStyle,
        style.fontWeight,
        parseFontSize(style.fontSize),
        style.fontFamily || "sans-serif"
      ].join(" ");
    }
    return font && trim(font) || style.textFont || style.font;
  }
};
var VALID_TEXT_ALIGN = {left: true, right: 1, center: 1};
var VALID_TEXT_VERTICAL_ALIGN = {top: 1, bottom: 1, middle: 1};
var FONT_PARTS = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function parseFontSize(fontSize) {
  if (typeof fontSize === "string" && (fontSize.indexOf("px") !== -1 || fontSize.indexOf("rem") !== -1 || fontSize.indexOf("em") !== -1)) {
    return fontSize;
  } else if (!isNaN(+fontSize)) {
    return fontSize + "px";
  } else {
    return DEFAULT_FONT_SIZE + "px";
  }
}
function setSeparateFont(targetStyle, sourceStyle) {
  for (let i = 0; i < FONT_PARTS.length; i++) {
    const fontProp = FONT_PARTS[i];
    const val = sourceStyle[fontProp];
    if (val != null) {
      targetStyle[fontProp] = val;
    }
  }
}
function hasSeparateFont(style) {
  return style.fontSize != null || style.fontFamily || style.fontWeight;
}
function normalizeTextStyle(style) {
  normalizeStyle(style);
  each(style.rich, normalizeStyle);
  return style;
}
function normalizeStyle(style) {
  if (style) {
    style.font = ZRText.makeFont(style);
    let textAlign = style.align;
    textAlign === "middle" && (textAlign = "center");
    style.align = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : "left";
    let verticalAlign = style.verticalAlign;
    verticalAlign === "center" && (verticalAlign = "middle");
    style.verticalAlign = verticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[verticalAlign] ? verticalAlign : "top";
    const textPadding = style.padding;
    if (textPadding) {
      style.padding = normalizeCssArray(style.padding);
    }
  }
}
function getStroke(stroke, lineWidth) {
  return stroke == null || lineWidth <= 0 || stroke === "transparent" || stroke === "none" ? null : stroke.image || stroke.colorStops ? "#000" : stroke;
}
function getFill(fill) {
  return fill == null || fill === "none" ? null : fill.image || fill.colorStops ? "#000" : fill;
}
function getTextXForPadding(x, textAlign, textPadding) {
  return textAlign === "right" ? x - textPadding[1] : textAlign === "center" ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];
}
function getStyleText(style) {
  let text = style.text;
  text != null && (text += "");
  return text;
}
function needDrawBackground(style) {
  return !!(style.backgroundColor || style.lineHeight || style.borderWidth && style.borderColor);
}
var Text_default = ZRText;

// src/util/innerStore.ts
var getECData = makeInner();
var setCommonECData = (seriesIndex, dataType, dataIdx, el) => {
  if (el) {
    const ecData = getECData(el);
    ecData.dataIndex = dataIdx;
    ecData.dataType = dataType;
    ecData.seriesIndex = seriesIndex;
    ecData.ssrType = "chart";
    if (el.type === "group") {
      el.traverse(function(child) {
        const childECData = getECData(child);
        childECData.seriesIndex = seriesIndex;
        childECData.dataIndex = dataIdx;
        childECData.dataType = dataType;
        childECData.ssrType = "chart";
      });
    }
  }
};

// src/util/states.ts
var _highlightNextDigit = 1;
var _highlightKeyMap = {};
var getSavedStates = makeInner();
var getComponentStates = makeInner();
var HOVER_STATE_NORMAL = 0;
var HOVER_STATE_BLUR = 1;
var HOVER_STATE_EMPHASIS = 2;
var SPECIAL_STATES = ["emphasis", "blur", "select"];
var DISPLAY_STATES = ["normal", "emphasis", "blur", "select"];
var Z2_EMPHASIS_LIFT = 10;
var Z2_SELECT_LIFT = 9;
var HIGHLIGHT_ACTION_TYPE = "highlight";
var DOWNPLAY_ACTION_TYPE = "downplay";
var SELECT_ACTION_TYPE = "select";
var UNSELECT_ACTION_TYPE = "unselect";
var TOGGLE_SELECT_ACTION_TYPE = "toggleSelect";
function hasFillOrStroke(fillOrStroke) {
  return fillOrStroke != null && fillOrStroke !== "none";
}
function doChangeHoverState(el, stateName, hoverStateEnum) {
  if (el.onHoverStateChange && (el.hoverState || 0) !== hoverStateEnum) {
    el.onHoverStateChange(stateName);
  }
  el.hoverState = hoverStateEnum;
}
function singleEnterEmphasis(el) {
  doChangeHoverState(el, "emphasis", HOVER_STATE_EMPHASIS);
}
function singleLeaveEmphasis(el) {
  if (el.hoverState === HOVER_STATE_EMPHASIS) {
    doChangeHoverState(el, "normal", HOVER_STATE_NORMAL);
  }
}
function singleEnterBlur(el) {
  doChangeHoverState(el, "blur", HOVER_STATE_BLUR);
}
function singleLeaveBlur(el) {
  if (el.hoverState === HOVER_STATE_BLUR) {
    doChangeHoverState(el, "normal", HOVER_STATE_NORMAL);
  }
}
function singleEnterSelect(el) {
  el.selected = true;
}
function singleLeaveSelect(el) {
  el.selected = false;
}
function updateElementState(el, updater, commonParam) {
  updater(el, commonParam);
}
function traverseUpdateState(el, updater, commonParam) {
  updateElementState(el, updater, commonParam);
  el.isGroup && el.traverse(function(child) {
    updateElementState(child, updater, commonParam);
  });
}
function setStatesFlag(el, stateName) {
  switch (stateName) {
    case "emphasis":
      el.hoverState = HOVER_STATE_EMPHASIS;
      break;
    case "normal":
      el.hoverState = HOVER_STATE_NORMAL;
      break;
    case "blur":
      el.hoverState = HOVER_STATE_BLUR;
      break;
    case "select":
      el.selected = true;
  }
}
function getFromStateStyle(el, props, toStateName, defaultValue) {
  const style = el.style;
  const fromState = {};
  for (let i = 0; i < props.length; i++) {
    const propName = props[i];
    const val = style[propName];
    fromState[propName] = val == null ? defaultValue && defaultValue[propName] : val;
  }
  for (let i = 0; i < el.animators.length; i++) {
    const animator = el.animators[i];
    if (animator.__fromStateTransition && animator.__fromStateTransition.indexOf(toStateName) < 0 && animator.targetName === "style") {
      animator.saveTo(fromState, props);
    }
  }
  return fromState;
}
function createEmphasisDefaultState(el, stateName, targetStates, state) {
  const hasSelect = targetStates && indexOf(targetStates, "select") >= 0;
  let cloned = false;
  if (el instanceof Path_default) {
    const store = getSavedStates(el);
    const fromFill = hasSelect ? store.selectFill || store.normalFill : store.normalFill;
    const fromStroke = hasSelect ? store.selectStroke || store.normalStroke : store.normalStroke;
    if (hasFillOrStroke(fromFill) || hasFillOrStroke(fromStroke)) {
      state = state || {};
      let emphasisStyle = state.style || {};
      if (emphasisStyle.fill === "inherit") {
        cloned = true;
        state = extend({}, state);
        emphasisStyle = extend({}, emphasisStyle);
        emphasisStyle.fill = fromFill;
      } else if (!hasFillOrStroke(emphasisStyle.fill) && hasFillOrStroke(fromFill)) {
        cloned = true;
        state = extend({}, state);
        emphasisStyle = extend({}, emphasisStyle);
        emphasisStyle.fill = liftColor(fromFill);
      } else if (!hasFillOrStroke(emphasisStyle.stroke) && hasFillOrStroke(fromStroke)) {
        if (!cloned) {
          state = extend({}, state);
          emphasisStyle = extend({}, emphasisStyle);
        }
        emphasisStyle.stroke = liftColor(fromStroke);
      }
      state.style = emphasisStyle;
    }
  }
  if (state) {
    if (state.z2 == null) {
      if (!cloned) {
        state = extend({}, state);
      }
      const z2EmphasisLift = el.z2EmphasisLift;
      state.z2 = el.z2 + (z2EmphasisLift != null ? z2EmphasisLift : Z2_EMPHASIS_LIFT);
    }
  }
  return state;
}
function createSelectDefaultState(el, stateName, state) {
  if (state) {
    if (state.z2 == null) {
      state = extend({}, state);
      const z2SelectLift = el.z2SelectLift;
      state.z2 = el.z2 + (z2SelectLift != null ? z2SelectLift : Z2_SELECT_LIFT);
    }
  }
  return state;
}
function createBlurDefaultState(el, stateName, state) {
  const hasBlur = indexOf(el.currentStates, stateName) >= 0;
  const currentOpacity = el.style.opacity;
  const fromState = !hasBlur ? getFromStateStyle(el, ["opacity"], stateName, {
    opacity: 1
  }) : null;
  state = state || {};
  let blurStyle = state.style || {};
  if (blurStyle.opacity == null) {
    state = extend({}, state);
    blurStyle = extend({
      opacity: hasBlur ? currentOpacity : fromState.opacity * 0.1
    }, blurStyle);
    state.style = blurStyle;
  }
  return state;
}
function elementStateProxy(stateName, targetStates) {
  const state = this.states[stateName];
  if (this.style) {
    if (stateName === "emphasis") {
      return createEmphasisDefaultState(this, stateName, targetStates, state);
    } else if (stateName === "blur") {
      return createBlurDefaultState(this, stateName, state);
    } else if (stateName === "select") {
      return createSelectDefaultState(this, stateName, state);
    }
  }
  return state;
}
function setDefaultStateProxy(el) {
  el.stateProxy = elementStateProxy;
  const textContent = el.getTextContent();
  const textGuide = el.getTextGuideLine();
  if (textContent) {
    textContent.stateProxy = elementStateProxy;
  }
  if (textGuide) {
    textGuide.stateProxy = elementStateProxy;
  }
}
function enterEmphasisWhenMouseOver(el, e2) {
  !shouldSilent(el, e2) && !el.__highByOuter && traverseUpdateState(el, singleEnterEmphasis);
}
function leaveEmphasisWhenMouseOut(el, e2) {
  !shouldSilent(el, e2) && !el.__highByOuter && traverseUpdateState(el, singleLeaveEmphasis);
}
function enterEmphasis(el, highlightDigit) {
  el.__highByOuter |= 1 << (highlightDigit || 0);
  traverseUpdateState(el, singleEnterEmphasis);
}
function leaveEmphasis(el, highlightDigit) {
  !(el.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdateState(el, singleLeaveEmphasis);
}
function enterBlur(el) {
  traverseUpdateState(el, singleEnterBlur);
}
function leaveBlur(el) {
  traverseUpdateState(el, singleLeaveBlur);
}
function enterSelect(el) {
  traverseUpdateState(el, singleEnterSelect);
}
function leaveSelect(el) {
  traverseUpdateState(el, singleLeaveSelect);
}
function shouldSilent(el, e2) {
  return el.__highDownSilentOnTouch && e2.zrByTouch;
}
function allLeaveBlur(api2) {
  const model = api2.getModel();
  const leaveBlurredSeries = [];
  const allComponentViews = [];
  model.eachComponent(function(componentType, componentModel) {
    const componentStates = getComponentStates(componentModel);
    const isSeries2 = componentType === "series";
    const view = isSeries2 ? api2.getViewOfSeriesModel(componentModel) : api2.getViewOfComponentModel(componentModel);
    !isSeries2 && allComponentViews.push(view);
    if (componentStates.isBlured) {
      view.group.traverse(function(child) {
        singleLeaveBlur(child);
      });
      isSeries2 && leaveBlurredSeries.push(componentModel);
    }
    componentStates.isBlured = false;
  });
  each(allComponentViews, function(view) {
    if (view && view.toggleBlurSeries) {
      view.toggleBlurSeries(leaveBlurredSeries, false, model);
    }
  });
}
function blurSeries(targetSeriesIndex, focus, blurScope, api2) {
  const ecModel = api2.getModel();
  blurScope = blurScope || "coordinateSystem";
  function leaveBlurOfIndices(data, dataIndices) {
    for (let i = 0; i < dataIndices.length; i++) {
      const itemEl = data.getItemGraphicEl(dataIndices[i]);
      itemEl && leaveBlur(itemEl);
    }
  }
  if (targetSeriesIndex == null) {
    return;
  }
  if (!focus || focus === "none") {
    return;
  }
  const targetSeriesModel = ecModel.getSeriesByIndex(targetSeriesIndex);
  let targetCoordSys = targetSeriesModel.coordinateSystem;
  if (targetCoordSys && targetCoordSys.master) {
    targetCoordSys = targetCoordSys.master;
  }
  const blurredSeries = [];
  ecModel.eachSeries(function(seriesModel) {
    const sameSeries = targetSeriesModel === seriesModel;
    let coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.master) {
      coordSys = coordSys.master;
    }
    const sameCoordSys = coordSys && targetCoordSys ? coordSys === targetCoordSys : sameSeries;
    if (!(blurScope === "series" && !sameSeries || blurScope === "coordinateSystem" && !sameCoordSys || focus === "series" && sameSeries)) {
      const view = api2.getViewOfSeriesModel(seriesModel);
      view.group.traverse(function(child) {
        if (child.__highByOuter && sameSeries && focus === "self") {
          return;
        }
        singleEnterBlur(child);
      });
      if (isArrayLike(focus)) {
        leaveBlurOfIndices(seriesModel.getData(), focus);
      } else if (isObject(focus)) {
        const dataTypes = keys(focus);
        for (let d = 0; d < dataTypes.length; d++) {
          leaveBlurOfIndices(seriesModel.getData(dataTypes[d]), focus[dataTypes[d]]);
        }
      }
      blurredSeries.push(seriesModel);
      getComponentStates(seriesModel).isBlured = true;
    }
  });
  ecModel.eachComponent(function(componentType, componentModel) {
    if (componentType === "series") {
      return;
    }
    const view = api2.getViewOfComponentModel(componentModel);
    if (view && view.toggleBlurSeries) {
      view.toggleBlurSeries(blurredSeries, true, ecModel);
    }
  });
}
function blurComponent(componentMainType, componentIndex, api2) {
  if (componentMainType == null || componentIndex == null) {
    return;
  }
  const componentModel = api2.getModel().getComponent(componentMainType, componentIndex);
  if (!componentModel) {
    return;
  }
  getComponentStates(componentModel).isBlured = true;
  const view = api2.getViewOfComponentModel(componentModel);
  if (!view || !view.focusBlurEnabled) {
    return;
  }
  view.group.traverse(function(child) {
    singleEnterBlur(child);
  });
}
function blurSeriesFromHighlightPayload(seriesModel, payload, api2) {
  const seriesIndex = seriesModel.seriesIndex;
  const data = seriesModel.getData(payload.dataType);
  if (!data) {
    if (true) {
      error(`Unknown dataType ${payload.dataType}`);
    }
    return;
  }
  let dataIndex = queryDataIndex(data, payload);
  dataIndex = (isArray(dataIndex) ? dataIndex[0] : dataIndex) || 0;
  let el = data.getItemGraphicEl(dataIndex);
  if (!el) {
    const count2 = data.count();
    let current = 0;
    while (!el && current < count2) {
      el = data.getItemGraphicEl(current++);
    }
  }
  if (el) {
    const ecData = getECData(el);
    blurSeries(seriesIndex, ecData.focus, ecData.blurScope, api2);
  } else {
    const focus = seriesModel.get(["emphasis", "focus"]);
    const blurScope = seriesModel.get(["emphasis", "blurScope"]);
    if (focus != null) {
      blurSeries(seriesIndex, focus, blurScope, api2);
    }
  }
}
function findComponentHighDownDispatchers(componentMainType, componentIndex, name, api2) {
  const ret = {
    focusSelf: false,
    dispatchers: null
  };
  if (componentMainType == null || componentMainType === "series" || componentIndex == null || name == null) {
    return ret;
  }
  const componentModel = api2.getModel().getComponent(componentMainType, componentIndex);
  if (!componentModel) {
    return ret;
  }
  const view = api2.getViewOfComponentModel(componentModel);
  if (!view || !view.findHighDownDispatchers) {
    return ret;
  }
  const dispatchers = view.findHighDownDispatchers(name);
  let focusSelf;
  for (let i = 0; i < dispatchers.length; i++) {
    if (!isHighDownDispatcher(dispatchers[i])) {
      error("param should be highDownDispatcher");
    }
    if (getECData(dispatchers[i]).focus === "self") {
      focusSelf = true;
      break;
    }
  }
  return {focusSelf, dispatchers};
}
function handleGlobalMouseOverForHighDown(dispatcher, e2, api2) {
  if (!isHighDownDispatcher(dispatcher)) {
    error("param should be highDownDispatcher");
  }
  const ecData = getECData(dispatcher);
  const {dispatchers, focusSelf} = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api2);
  if (dispatchers) {
    if (focusSelf) {
      blurComponent(ecData.componentMainType, ecData.componentIndex, api2);
    }
    each(dispatchers, (dispatcher2) => enterEmphasisWhenMouseOver(dispatcher2, e2));
  } else {
    blurSeries(ecData.seriesIndex, ecData.focus, ecData.blurScope, api2);
    if (ecData.focus === "self") {
      blurComponent(ecData.componentMainType, ecData.componentIndex, api2);
    }
    enterEmphasisWhenMouseOver(dispatcher, e2);
  }
}
function handleGlobalMouseOutForHighDown(dispatcher, e2, api2) {
  if (!isHighDownDispatcher(dispatcher)) {
    error("param should be highDownDispatcher");
  }
  allLeaveBlur(api2);
  const ecData = getECData(dispatcher);
  const {dispatchers} = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api2);
  if (dispatchers) {
    each(dispatchers, (dispatcher2) => leaveEmphasisWhenMouseOut(dispatcher2, e2));
  } else {
    leaveEmphasisWhenMouseOut(dispatcher, e2);
  }
}
function toggleSelectionFromPayload(seriesModel, payload, api2) {
  if (!isSelectChangePayload(payload)) {
    return;
  }
  const dataType = payload.dataType;
  const data = seriesModel.getData(dataType);
  let dataIndex = queryDataIndex(data, payload);
  if (!isArray(dataIndex)) {
    dataIndex = [dataIndex];
  }
  seriesModel[payload.type === TOGGLE_SELECT_ACTION_TYPE ? "toggleSelect" : payload.type === SELECT_ACTION_TYPE ? "select" : "unselect"](dataIndex, dataType);
}
function updateSeriesElementSelection(seriesModel) {
  const allData = seriesModel.getAllData();
  each(allData, function({data, type}) {
    data.eachItemGraphicEl(function(el, idx) {
      seriesModel.isSelected(idx, type) ? enterSelect(el) : leaveSelect(el);
    });
  });
}
function getAllSelectedIndices(ecModel) {
  const ret = [];
  ecModel.eachSeries(function(seriesModel) {
    const allData = seriesModel.getAllData();
    each(allData, function({data, type}) {
      const dataIndices = seriesModel.getSelectedDataIndices();
      if (dataIndices.length > 0) {
        const item = {
          dataIndex: dataIndices,
          seriesIndex: seriesModel.seriesIndex
        };
        if (type != null) {
          item.dataType = type;
        }
        ret.push(item);
      }
    });
  });
  return ret;
}
function enableHoverEmphasis(el, focus, blurScope) {
  setAsHighDownDispatcher(el, true);
  traverseUpdateState(el, setDefaultStateProxy);
  enableHoverFocus(el, focus, blurScope);
}
function disableHoverEmphasis(el) {
  setAsHighDownDispatcher(el, false);
}
function toggleHoverEmphasis(el, focus, blurScope, isDisabled) {
  isDisabled ? disableHoverEmphasis(el) : enableHoverEmphasis(el, focus, blurScope);
}
function enableHoverFocus(el, focus, blurScope) {
  const ecData = getECData(el);
  if (focus != null) {
    ecData.focus = focus;
    ecData.blurScope = blurScope;
  } else if (ecData.focus) {
    ecData.focus = null;
  }
}
var OTHER_STATES = ["emphasis", "blur", "select"];
var defaultStyleGetterMap = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function setStatesStylesFromModel(el, itemModel, styleType, getter) {
  styleType = styleType || "itemStyle";
  for (let i = 0; i < OTHER_STATES.length; i++) {
    const stateName = OTHER_STATES[i];
    const model = itemModel.getModel([stateName, styleType]);
    const state = el.ensureState(stateName);
    state.style = getter ? getter(model) : model[defaultStyleGetterMap[styleType]]();
  }
}
function setAsHighDownDispatcher(el, asDispatcher) {
  const disable = asDispatcher === false;
  const extendedEl = el;
  if (el.highDownSilentOnTouch) {
    extendedEl.__highDownSilentOnTouch = el.highDownSilentOnTouch;
  }
  if (!disable || extendedEl.__highDownDispatcher) {
    extendedEl.__highByOuter = extendedEl.__highByOuter || 0;
    extendedEl.__highDownDispatcher = !disable;
  }
}
function isHighDownDispatcher(el) {
  return !!(el && el.__highDownDispatcher);
}
function enableComponentHighDownFeatures(el, componentModel, componentHighDownName) {
  const ecData = getECData(el);
  ecData.componentMainType = componentModel.mainType;
  ecData.componentIndex = componentModel.componentIndex;
  ecData.componentHighDownName = componentHighDownName;
}
function getHighlightDigit(highlightKey) {
  let highlightDigit = _highlightKeyMap[highlightKey];
  if (highlightDigit == null && _highlightNextDigit <= 32) {
    highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++;
  }
  return highlightDigit;
}
function isSelectChangePayload(payload) {
  const payloadType = payload.type;
  return payloadType === SELECT_ACTION_TYPE || payloadType === UNSELECT_ACTION_TYPE || payloadType === TOGGLE_SELECT_ACTION_TYPE;
}
function isHighDownPayload(payload) {
  const payloadType = payload.type;
  return payloadType === HIGHLIGHT_ACTION_TYPE || payloadType === DOWNPLAY_ACTION_TYPE;
}
function savePathStates(el) {
  const store = getSavedStates(el);
  store.normalFill = el.style.fill;
  store.normalStroke = el.style.stroke;
  const selectState = el.states.select || {};
  store.selectFill = selectState.style && selectState.style.fill || null;
  store.selectStroke = selectState.style && selectState.style.stroke || null;
}

// src/util/graphic.ts
var graphic_exports = {};
__export(graphic_exports, {
  Arc: () => Arc_default,
  BezierCurve: () => BezierCurve_default,
  BoundingRect: () => BoundingRect_default,
  Circle: () => Circle_default,
  CompoundPath: () => CompoundPath_default,
  Ellipse: () => Ellipse_default,
  Group: () => Group_default,
  Image: () => Image_default,
  IncrementalDisplayable: () => IncrementalDisplayable_default,
  Line: () => Line_default,
  LinearGradient: () => LinearGradient_default,
  OrientedBoundingRect: () => OrientedBoundingRect_default,
  Path: () => Path_default,
  Point: () => Point_default,
  Polygon: () => Polygon_default,
  Polyline: () => Polyline_default,
  RadialGradient: () => RadialGradient_default,
  Rect: () => Rect_default,
  Ring: () => Ring_default,
  Sector: () => Sector_default,
  Text: () => Text_default,
  applyTransform: () => applyTransform2,
  clipPointsByRect: () => clipPointsByRect,
  clipRectByRect: () => clipRectByRect,
  createIcon: () => createIcon,
  extendPath: () => extendPath,
  extendShape: () => extendShape,
  getShapeClass: () => getShapeClass,
  getTransform: () => getTransform,
  groupTransition: () => groupTransition,
  initProps: () => initProps,
  isElementRemoved: () => isElementRemoved,
  lineLineIntersect: () => lineLineIntersect,
  linePolygonIntersect: () => linePolygonIntersect,
  makeImage: () => makeImage,
  makePath: () => makePath,
  mergePath: () => mergePath2,
  registerShape: () => registerShape,
  removeElement: () => removeElement,
  removeElementWithFadeOut: () => removeElementWithFadeOut,
  resizePath: () => resizePath,
  setTooltipConfig: () => setTooltipConfig,
  subPixelOptimize: () => subPixelOptimize2,
  subPixelOptimizeLine: () => subPixelOptimizeLine2,
  subPixelOptimizeRect: () => subPixelOptimizeRect2,
  transformDirection: () => transformDirection,
  traverseElements: () => traverseElements,
  updateProps: () => updateProps
});

// node_modules/zrender/src/tool/transformPath.ts
var CMD3 = PathProxy_default.CMD;
var points = [[], [], []];
var mathSqrt2 = Math.sqrt;
var mathAtan2 = Math.atan2;
function transformPath(path, m2) {
  if (!m2) {
    return;
  }
  let data = path.data;
  const len2 = path.len();
  let cmd;
  let nPoint;
  let i;
  let j;
  let k;
  let p;
  const M = CMD3.M;
  const C = CMD3.C;
  const L = CMD3.L;
  const R = CMD3.R;
  const A = CMD3.A;
  const Q = CMD3.Q;
  for (i = 0, j = 0; i < len2; ) {
    cmd = data[i++];
    j = i;
    nPoint = 0;
    switch (cmd) {
      case M:
        nPoint = 1;
        break;
      case L:
        nPoint = 1;
        break;
      case C:
        nPoint = 3;
        break;
      case Q:
        nPoint = 2;
        break;
      case A:
        const x = m2[4];
        const y = m2[5];
        const sx = mathSqrt2(m2[0] * m2[0] + m2[1] * m2[1]);
        const sy = mathSqrt2(m2[2] * m2[2] + m2[3] * m2[3]);
        const angle = mathAtan2(-m2[1] / sy, m2[0] / sx);
        data[i] *= sx;
        data[i++] += x;
        data[i] *= sy;
        data[i++] += y;
        data[i++] *= sx;
        data[i++] *= sy;
        data[i++] += angle;
        data[i++] += angle;
        i += 2;
        j = i;
        break;
      case R:
        p[0] = data[i++];
        p[1] = data[i++];
        applyTransform(p, p, m2);
        data[j++] = p[0];
        data[j++] = p[1];
        p[0] += data[i++];
        p[1] += data[i++];
        applyTransform(p, p, m2);
        data[j++] = p[0];
        data[j++] = p[1];
    }
    for (k = 0; k < nPoint; k++) {
      let p2 = points[k];
      p2[0] = data[i++];
      p2[1] = data[i++];
      applyTransform(p2, p2, m2);
      data[j++] = p2[0];
      data[j++] = p2[1];
    }
  }
  path.increaseVersion();
}

// node_modules/zrender/src/tool/path.ts
var mathSqrt3 = Math.sqrt;
var mathSin3 = Math.sin;
var mathCos3 = Math.cos;
var PI3 = Math.PI;
function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio(u, v) {
  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
}
function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
  const psi = psiDeg * (PI3 / 180);
  const xp = mathCos3(psi) * (x1 - x2) / 2 + mathSin3(psi) * (y1 - y2) / 2;
  const yp = -1 * mathSin3(psi) * (x1 - x2) / 2 + mathCos3(psi) * (y1 - y2) / 2;
  const lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= mathSqrt3(lambda);
    ry *= mathSqrt3(lambda);
  }
  const f = (fa === fs ? -1 : 1) * mathSqrt3((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
  const cxp = f * rx * yp / ry;
  const cyp = f * -ry * xp / rx;
  const cx = (x1 + x2) / 2 + mathCos3(psi) * cxp - mathSin3(psi) * cyp;
  const cy = (y1 + y2) / 2 + mathSin3(psi) * cxp + mathCos3(psi) * cyp;
  const theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
  const u = [(xp - cxp) / rx, (yp - cyp) / ry];
  const v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  let dTheta = vAngle(u, v);
  if (vRatio(u, v) <= -1) {
    dTheta = PI3;
  }
  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }
  if (dTheta < 0) {
    const n = Math.round(dTheta / PI3 * 1e6) / 1e6;
    dTheta = PI3 * 2 + n % 2 * PI3;
  }
  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
}
var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig;
var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function createPathProxyFromString(data) {
  const path = new PathProxy_default();
  if (!data) {
    return path;
  }
  let cpx = 0;
  let cpy = 0;
  let subpathX = cpx;
  let subpathY = cpy;
  let prevCmd;
  const CMD6 = PathProxy_default.CMD;
  const cmdList = data.match(commandReg);
  if (!cmdList) {
    return path;
  }
  for (let l = 0; l < cmdList.length; l++) {
    const cmdText = cmdList[l];
    let cmdStr = cmdText.charAt(0);
    let cmd;
    const p = cmdText.match(numberReg) || [];
    const pLen = p.length;
    for (let i = 0; i < pLen; i++) {
      p[i] = parseFloat(p[i]);
    }
    let off = 0;
    while (off < pLen) {
      let ctlPtx;
      let ctlPty;
      let rx;
      let ry;
      let psi;
      let fa;
      let fs;
      let x1 = cpx;
      let y1 = cpy;
      let len2;
      let pathData;
      switch (cmdStr) {
        case "l":
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD6.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "L":
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD6.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "m":
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD6.M;
          path.addData(cmd, cpx, cpy);
          subpathX = cpx;
          subpathY = cpy;
          cmdStr = "l";
          break;
        case "M":
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD6.M;
          path.addData(cmd, cpx, cpy);
          subpathX = cpx;
          subpathY = cpy;
          cmdStr = "L";
          break;
        case "h":
          cpx += p[off++];
          cmd = CMD6.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "H":
          cpx = p[off++];
          cmd = CMD6.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "v":
          cpy += p[off++];
          cmd = CMD6.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "V":
          cpy = p[off++];
          cmd = CMD6.L;
          path.addData(cmd, cpx, cpy);
          break;
        case "C":
          cmd = CMD6.C;
          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
          cpx = p[off - 2];
          cpy = p[off - 1];
          break;
        case "c":
          cmd = CMD6.C;
          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
          cpx += p[off - 2];
          cpy += p[off - 1];
          break;
        case "S":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD6.C) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cmd = CMD6.C;
          x1 = p[off++];
          y1 = p[off++];
          cpx = p[off++];
          cpy = p[off++];
          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
          break;
        case "s":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD6.C) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cmd = CMD6.C;
          x1 = cpx + p[off++];
          y1 = cpy + p[off++];
          cpx += p[off++];
          cpy += p[off++];
          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
          break;
        case "Q":
          x1 = p[off++];
          y1 = p[off++];
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD6.Q;
          path.addData(cmd, x1, y1, cpx, cpy);
          break;
        case "q":
          x1 = p[off++] + cpx;
          y1 = p[off++] + cpy;
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD6.Q;
          path.addData(cmd, x1, y1, cpx, cpy);
          break;
        case "T":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD6.Q) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD6.Q;
          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;
        case "t":
          ctlPtx = cpx;
          ctlPty = cpy;
          len2 = path.len();
          pathData = path.data;
          if (prevCmd === CMD6.Q) {
            ctlPtx += cpx - pathData[len2 - 4];
            ctlPty += cpy - pathData[len2 - 3];
          }
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD6.Q;
          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
          break;
        case "A":
          rx = p[off++];
          ry = p[off++];
          psi = p[off++];
          fa = p[off++];
          fs = p[off++];
          x1 = cpx, y1 = cpy;
          cpx = p[off++];
          cpy = p[off++];
          cmd = CMD6.A;
          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
          break;
        case "a":
          rx = p[off++];
          ry = p[off++];
          psi = p[off++];
          fa = p[off++];
          fs = p[off++];
          x1 = cpx, y1 = cpy;
          cpx += p[off++];
          cpy += p[off++];
          cmd = CMD6.A;
          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
          break;
      }
    }
    if (cmdStr === "z" || cmdStr === "Z") {
      cmd = CMD6.Z;
      path.addData(cmd);
      cpx = subpathX;
      cpy = subpathY;
    }
    prevCmd = cmd;
  }
  path.toStatic();
  return path;
}
var SVGPath = class extends Path_default {
  applyTransform(m2) {
  }
};
function isPathProxy(path) {
  return path.setData != null;
}
function createPathOptions(str, opts) {
  const pathProxy = createPathProxyFromString(str);
  const innerOpts = extend({}, opts);
  innerOpts.buildPath = function(path) {
    if (isPathProxy(path)) {
      path.setData(pathProxy.data);
      const ctx = path.getContext();
      if (ctx) {
        path.rebuildPath(ctx, 1);
      }
    } else {
      const ctx = path;
      pathProxy.rebuildPath(ctx, 1);
    }
  };
  innerOpts.applyTransform = function(m2) {
    transformPath(pathProxy, m2);
    this.dirtyShape();
  };
  return innerOpts;
}
function createFromString(str, opts) {
  return new SVGPath(createPathOptions(str, opts));
}
function extendFromString(str, defaultOpts) {
  const innerOpts = createPathOptions(str, defaultOpts);
  class Sub extends SVGPath {
    constructor(opts) {
      super(opts);
      this.applyTransform = innerOpts.applyTransform;
      this.buildPath = innerOpts.buildPath;
    }
  }
  return Sub;
}
function mergePath(pathEls, opts) {
  const pathList = [];
  const len2 = pathEls.length;
  for (let i = 0; i < len2; i++) {
    const pathEl = pathEls[i];
    pathList.push(pathEl.getUpdatedPathProxy(true));
  }
  const pathBundle = new Path_default(opts);
  pathBundle.createPathProxy();
  pathBundle.buildPath = function(path) {
    if (isPathProxy(path)) {
      path.appendPath(pathList);
      const ctx = path.getContext();
      if (ctx) {
        path.rebuildPath(ctx, 1);
      }
    }
  };
  return pathBundle;
}
function clonePath(sourcePath, opts) {
  opts = opts || {};
  const path = new Path_default();
  if (sourcePath.shape) {
    path.setShape(sourcePath.shape);
  }
  path.setStyle(sourcePath.style);
  if (opts.bakeTransform) {
    transformPath(path.path, sourcePath.getComputedTransform());
  } else {
    if (opts.toLocal) {
      path.setLocalTransform(sourcePath.getComputedTransform());
    } else {
      path.copyTransform(sourcePath);
    }
  }
  path.buildPath = sourcePath.buildPath;
  path.applyTransform = path.applyTransform;
  path.z = sourcePath.z;
  path.z2 = sourcePath.z2;
  path.zlevel = sourcePath.zlevel;
  return path;
}

// node_modules/zrender/src/graphic/shape/Circle.ts
var CircleShape = class {
  constructor() {
    this.cx = 0;
    this.cy = 0;
    this.r = 0;
  }
};
var Circle = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultShape() {
    return new CircleShape();
  }
  buildPath(ctx, shape) {
    ctx.moveTo(shape.cx + shape.r, shape.cy);
    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2);
  }
};
Circle.prototype.type = "circle";
var Circle_default = Circle;

// node_modules/zrender/src/graphic/shape/Ellipse.ts
var EllipseShape = class {
  constructor() {
    this.cx = 0;
    this.cy = 0;
    this.rx = 0;
    this.ry = 0;
  }
};
var Ellipse = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultShape() {
    return new EllipseShape();
  }
  buildPath(ctx, shape) {
    const k = 0.5522848;
    const x = shape.cx;
    const y = shape.cy;
    const a = shape.rx;
    const b = shape.ry;
    const ox = a * k;
    const oy = b * k;
    ctx.moveTo(x - a, y);
    ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
    ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
    ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
    ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
    ctx.closePath();
  }
};
Ellipse.prototype.type = "ellipse";
var Ellipse_default = Ellipse;

// node_modules/zrender/src/graphic/helper/roundSector.ts
var PI4 = Math.PI;
var PI26 = PI4 * 2;
var mathSin4 = Math.sin;
var mathCos4 = Math.cos;
var mathACos = Math.acos;
var mathATan2 = Math.atan2;
var mathAbs2 = Math.abs;
var mathSqrt4 = Math.sqrt;
var mathMax4 = Math.max;
var mathMin4 = Math.min;
var e = 1e-4;
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  const dx10 = x1 - x0;
  const dy10 = y1 - y0;
  const dx32 = x3 - x2;
  const dy32 = y3 - y2;
  let t = dy32 * dx10 - dx32 * dy10;
  if (t * t < e) {
    return;
  }
  t = (dx32 * (y0 - y2) - dy32 * (x0 - x2)) / t;
  return [x0 + t * dx10, y0 + t * dy10];
}
function computeCornerTangents(x0, y0, x1, y1, radius, cr, clockwise) {
  const x01 = x0 - x1;
  const y01 = y0 - y1;
  const lo = (clockwise ? cr : -cr) / mathSqrt4(x01 * x01 + y01 * y01);
  const ox = lo * y01;
  const oy = -lo * x01;
  const x11 = x0 + ox;
  const y11 = y0 + oy;
  const x10 = x1 + ox;
  const y10 = y1 + oy;
  const x00 = (x11 + x10) / 2;
  const y00 = (y11 + y10) / 2;
  const dx = x10 - x11;
  const dy = y10 - y11;
  const d2 = dx * dx + dy * dy;
  const r = radius - cr;
  const s = x11 * y10 - x10 * y11;
  const d = (dy < 0 ? -1 : 1) * mathSqrt4(mathMax4(0, r * r * d2 - s * s));
  let cx0 = (s * dy - dx * d) / d2;
  let cy0 = (-s * dx - dy * d) / d2;
  const cx1 = (s * dy + dx * d) / d2;
  const cy1 = (-s * dx + dy * d) / d2;
  const dx0 = cx0 - x00;
  const dy0 = cy0 - y00;
  const dx1 = cx1 - x00;
  const dy1 = cy1 - y00;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
    cx0 = cx1;
    cy0 = cy1;
  }
  return {
    cx: cx0,
    cy: cy0,
    x0: -ox,
    y0: -oy,
    x1: cx0 * (radius / r - 1),
    y1: cy0 * (radius / r - 1)
  };
}
function normalizeCornerRadius(cr) {
  let arr;
  if (isArray(cr)) {
    const len2 = cr.length;
    if (!len2) {
      return cr;
    }
    if (len2 === 1) {
      arr = [cr[0], cr[0], 0, 0];
    } else if (len2 === 2) {
      arr = [cr[0], cr[0], cr[1], cr[1]];
    } else if (len2 === 3) {
      arr = cr.concat(cr[2]);
    } else {
      arr = cr;
    }
  } else {
    arr = [cr, cr, cr, cr];
  }
  return arr;
}
function buildPath2(ctx, shape) {
  let radius = mathMax4(shape.r, 0);
  let innerRadius = mathMax4(shape.r0 || 0, 0);
  const hasRadius = radius > 0;
  const hasInnerRadius = innerRadius > 0;
  if (!hasRadius && !hasInnerRadius) {
    return;
  }
  if (!hasRadius) {
    radius = innerRadius;
    innerRadius = 0;
  }
  if (innerRadius > radius) {
    const tmp = radius;
    radius = innerRadius;
    innerRadius = tmp;
  }
  const {startAngle, endAngle} = shape;
  if (isNaN(startAngle) || isNaN(endAngle)) {
    return;
  }
  const {cx, cy} = shape;
  const clockwise = !!shape.clockwise;
  let arc2 = mathAbs2(endAngle - startAngle);
  const mod = arc2 > PI26 && arc2 % PI26;
  mod > e && (arc2 = mod);
  if (!(radius > e)) {
    ctx.moveTo(cx, cy);
  } else if (arc2 > PI26 - e) {
    ctx.moveTo(cx + radius * mathCos4(startAngle), cy + radius * mathSin4(startAngle));
    ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
    if (innerRadius > e) {
      ctx.moveTo(cx + innerRadius * mathCos4(endAngle), cy + innerRadius * mathSin4(endAngle));
      ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
    }
  } else {
    let icrStart;
    let icrEnd;
    let ocrStart;
    let ocrEnd;
    let ocrs;
    let ocre;
    let icrs;
    let icre;
    let ocrMax;
    let icrMax;
    let limitedOcrMax;
    let limitedIcrMax;
    let xre;
    let yre;
    let xirs;
    let yirs;
    const xrs = radius * mathCos4(startAngle);
    const yrs = radius * mathSin4(startAngle);
    const xire = innerRadius * mathCos4(endAngle);
    const yire = innerRadius * mathSin4(endAngle);
    const hasArc = arc2 > e;
    if (hasArc) {
      const cornerRadius = shape.cornerRadius;
      if (cornerRadius) {
        [icrStart, icrEnd, ocrStart, ocrEnd] = normalizeCornerRadius(cornerRadius);
      }
      const halfRd = mathAbs2(radius - innerRadius) / 2;
      ocrs = mathMin4(halfRd, ocrStart);
      ocre = mathMin4(halfRd, ocrEnd);
      icrs = mathMin4(halfRd, icrStart);
      icre = mathMin4(halfRd, icrEnd);
      limitedOcrMax = ocrMax = mathMax4(ocrs, ocre);
      limitedIcrMax = icrMax = mathMax4(icrs, icre);
      if (ocrMax > e || icrMax > e) {
        xre = radius * mathCos4(endAngle);
        yre = radius * mathSin4(endAngle);
        xirs = innerRadius * mathCos4(startAngle);
        yirs = innerRadius * mathSin4(startAngle);
        if (arc2 < PI4) {
          const it = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire);
          if (it) {
            const x0 = xrs - it[0];
            const y0 = yrs - it[1];
            const x1 = xre - it[0];
            const y1 = yre - it[1];
            const a = 1 / mathSin4(mathACos((x0 * x1 + y0 * y1) / (mathSqrt4(x0 * x0 + y0 * y0) * mathSqrt4(x1 * x1 + y1 * y1))) / 2);
            const b = mathSqrt4(it[0] * it[0] + it[1] * it[1]);
            limitedOcrMax = mathMin4(ocrMax, (radius - b) / (a + 1));
            limitedIcrMax = mathMin4(icrMax, (innerRadius - b) / (a - 1));
          }
        }
      }
    }
    if (!hasArc) {
      ctx.moveTo(cx + xrs, cy + yrs);
    } else if (limitedOcrMax > e) {
      const crStart = mathMin4(ocrStart, limitedOcrMax);
      const crEnd = mathMin4(ocrEnd, limitedOcrMax);
      const ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, radius, crStart, clockwise);
      const ct1 = computeCornerTangents(xre, yre, xire, yire, radius, crEnd, clockwise);
      ctx.moveTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
      if (limitedOcrMax < ocrMax && crStart === crEnd) {
        ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedOcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
      } else {
        crStart > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crStart, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
        ctx.arc(cx, cy, radius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), !clockwise);
        crEnd > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crEnd, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
      }
    } else {
      ctx.moveTo(cx + xrs, cy + yrs);
      ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise);
    }
    if (!(innerRadius > e) || !hasArc) {
      ctx.lineTo(cx + xire, cy + yire);
    } else if (limitedIcrMax > e) {
      const crStart = mathMin4(icrStart, limitedIcrMax);
      const crEnd = mathMin4(icrEnd, limitedIcrMax);
      const ct0 = computeCornerTangents(xire, yire, xre, yre, innerRadius, -crEnd, clockwise);
      const ct1 = computeCornerTangents(xrs, yrs, xirs, yirs, innerRadius, -crStart, clockwise);
      ctx.lineTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0);
      if (limitedIcrMax < icrMax && crStart === crEnd) {
        ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedIcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise);
      } else {
        crEnd > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crEnd, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise);
        ctx.arc(cx, cy, innerRadius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), clockwise);
        crStart > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crStart, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise);
      }
    } else {
      ctx.lineTo(cx + xire, cy + yire);
      ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise);
    }
  }
  ctx.closePath();
}

// node_modules/zrender/src/graphic/shape/Sector.ts
var SectorShape = class {
  constructor() {
    this.cx = 0;
    this.cy = 0;
    this.r0 = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
    this.cornerRadius = 0;
  }
};
var Sector = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultShape() {
    return new SectorShape();
  }
  buildPath(ctx, shape) {
    buildPath2(ctx, shape);
  }
  isZeroArea() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  }
};
Sector.prototype.type = "sector";
var Sector_default = Sector;

// node_modules/zrender/src/graphic/shape/Ring.ts
var RingShape = class {
  constructor() {
    this.cx = 0;
    this.cy = 0;
    this.r = 0;
    this.r0 = 0;
  }
};
var Ring = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultShape() {
    return new RingShape();
  }
  buildPath(ctx, shape) {
    const x = shape.cx;
    const y = shape.cy;
    const PI210 = Math.PI * 2;
    ctx.moveTo(x + shape.r, y);
    ctx.arc(x, y, shape.r, 0, PI210, false);
    ctx.moveTo(x + shape.r0, y);
    ctx.arc(x, y, shape.r0, 0, PI210, true);
  }
};
Ring.prototype.type = "ring";
var Ring_default = Ring;

// node_modules/zrender/src/graphic/helper/smoothBezier.ts
function smoothBezier(points4, smooth, isLoop, constraint) {
  const cps = [];
  const v = [];
  const v12 = [];
  const v22 = [];
  let prevPoint;
  let nextPoint;
  let min3;
  let max3;
  if (constraint) {
    min3 = [Infinity, Infinity];
    max3 = [-Infinity, -Infinity];
    for (let i = 0, len2 = points4.length; i < len2; i++) {
      min(min3, min3, points4[i]);
      max(max3, max3, points4[i]);
    }
    min(min3, min3, constraint[0]);
    max(max3, max3, constraint[1]);
  }
  for (let i = 0, len2 = points4.length; i < len2; i++) {
    const point = points4[i];
    if (isLoop) {
      prevPoint = points4[i ? i - 1 : len2 - 1];
      nextPoint = points4[(i + 1) % len2];
    } else {
      if (i === 0 || i === len2 - 1) {
        cps.push(clone2(points4[i]));
        continue;
      } else {
        prevPoint = points4[i - 1];
        nextPoint = points4[i + 1];
      }
    }
    sub(v, nextPoint, prevPoint);
    scale(v, v, smooth);
    let d0 = distance(point, prevPoint);
    let d1 = distance(point, nextPoint);
    const sum2 = d0 + d1;
    if (sum2 !== 0) {
      d0 /= sum2;
      d1 /= sum2;
    }
    scale(v12, v, -d0);
    scale(v22, v, d1);
    const cp0 = add([], point, v12);
    const cp1 = add([], point, v22);
    if (constraint) {
      max(cp0, cp0, min3);
      min(cp0, cp0, max3);
      max(cp1, cp1, min3);
      min(cp1, cp1, max3);
    }
    cps.push(cp0);
    cps.push(cp1);
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
}

// node_modules/zrender/src/graphic/helper/poly.ts
function buildPath3(ctx, shape, closePath) {
  const smooth = shape.smooth;
  let points4 = shape.points;
  if (points4 && points4.length >= 2) {
    if (smooth) {
      const controlPoints = smoothBezier(points4, smooth, closePath, shape.smoothConstraint);
      ctx.moveTo(points4[0][0], points4[0][1]);
      const len2 = points4.length;
      for (let i = 0; i < (closePath ? len2 : len2 - 1); i++) {
        const cp1 = controlPoints[i * 2];
        const cp2 = controlPoints[i * 2 + 1];
        const p = points4[(i + 1) % len2];
        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
      }
    } else {
      ctx.moveTo(points4[0][0], points4[0][1]);
      for (let i = 1, l = points4.length; i < l; i++) {
        ctx.lineTo(points4[i][0], points4[i][1]);
      }
    }
    closePath && ctx.closePath();
  }
}

// node_modules/zrender/src/graphic/shape/Polygon.ts
var PolygonShape = class {
  constructor() {
    this.points = null;
    this.smooth = 0;
    this.smoothConstraint = null;
  }
};
var Polygon = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultShape() {
    return new PolygonShape();
  }
  buildPath(ctx, shape) {
    buildPath3(ctx, shape, true);
  }
};
Polygon.prototype.type = "polygon";
var Polygon_default = Polygon;

// node_modules/zrender/src/graphic/shape/Polyline.ts
var PolylineShape = class {
  constructor() {
    this.points = null;
    this.percent = 1;
    this.smooth = 0;
    this.smoothConstraint = null;
  }
};
var Polyline = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultStyle() {
    return {
      stroke: "#000",
      fill: null
    };
  }
  getDefaultShape() {
    return new PolylineShape();
  }
  buildPath(ctx, shape) {
    buildPath3(ctx, shape, false);
  }
};
Polyline.prototype.type = "polyline";
var Polyline_default = Polyline;

// node_modules/zrender/src/graphic/shape/Line.ts
var subPixelOptimizeOutputShape2 = {};
var LineShape = class {
  constructor() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.percent = 1;
  }
};
var Line = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultStyle() {
    return {
      stroke: "#000",
      fill: null
    };
  }
  getDefaultShape() {
    return new LineShape();
  }
  buildPath(ctx, shape) {
    let x1;
    let y1;
    let x2;
    let y2;
    if (this.subPixelOptimize) {
      const optimizedShape = subPixelOptimizeLine(subPixelOptimizeOutputShape2, shape, this.style);
      x1 = optimizedShape.x1;
      y1 = optimizedShape.y1;
      x2 = optimizedShape.x2;
      y2 = optimizedShape.y2;
    } else {
      x1 = shape.x1;
      y1 = shape.y1;
      x2 = shape.x2;
      y2 = shape.y2;
    }
    const percent = shape.percent;
    if (percent === 0) {
      return;
    }
    ctx.moveTo(x1, y1);
    if (percent < 1) {
      x2 = x1 * (1 - percent) + x2 * percent;
      y2 = y1 * (1 - percent) + y2 * percent;
    }
    ctx.lineTo(x2, y2);
  }
  pointAt(p) {
    const shape = this.shape;
    return [
      shape.x1 * (1 - p) + shape.x2 * p,
      shape.y1 * (1 - p) + shape.y2 * p
    ];
  }
};
Line.prototype.type = "line";
var Line_default = Line;

// node_modules/zrender/src/graphic/shape/BezierCurve.ts
var out = [];
var BezierCurveShape = class {
  constructor() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.cpx1 = 0;
    this.cpy1 = 0;
    this.percent = 1;
  }
};
function someVectorAt(shape, t, isTangent) {
  const cpx2 = shape.cpx2;
  const cpy2 = shape.cpy2;
  if (cpx2 != null || cpy2 != null) {
    return [
      (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),
      (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)
    ];
  } else {
    return [
      (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),
      (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)
    ];
  }
}
var BezierCurve = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultStyle() {
    return {
      stroke: "#000",
      fill: null
    };
  }
  getDefaultShape() {
    return new BezierCurveShape();
  }
  buildPath(ctx, shape) {
    let x1 = shape.x1;
    let y1 = shape.y1;
    let x2 = shape.x2;
    let y2 = shape.y2;
    let cpx1 = shape.cpx1;
    let cpy1 = shape.cpy1;
    let cpx2 = shape.cpx2;
    let cpy2 = shape.cpy2;
    let percent = shape.percent;
    if (percent === 0) {
      return;
    }
    ctx.moveTo(x1, y1);
    if (cpx2 == null || cpy2 == null) {
      if (percent < 1) {
        quadraticSubdivide(x1, cpx1, x2, percent, out);
        cpx1 = out[1];
        x2 = out[2];
        quadraticSubdivide(y1, cpy1, y2, percent, out);
        cpy1 = out[1];
        y2 = out[2];
      }
      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
    } else {
      if (percent < 1) {
        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
        cpx1 = out[1];
        cpx2 = out[2];
        x2 = out[3];
        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
        cpy1 = out[1];
        cpy2 = out[2];
        y2 = out[3];
      }
      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
    }
  }
  pointAt(t) {
    return someVectorAt(this.shape, t, false);
  }
  tangentAt(t) {
    const p = someVectorAt(this.shape, t, true);
    return normalize(p, p);
  }
};
BezierCurve.prototype.type = "bezier-curve";
var BezierCurve_default = BezierCurve;

// node_modules/zrender/src/graphic/shape/Arc.ts
var ArcShape = class {
  constructor() {
    this.cx = 0;
    this.cy = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
  }
};
var Arc = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultStyle() {
    return {
      stroke: "#000",
      fill: null
    };
  }
  getDefaultShape() {
    return new ArcShape();
  }
  buildPath(ctx, shape) {
    const x = shape.cx;
    const y = shape.cy;
    const r = Math.max(shape.r, 0);
    const startAngle = shape.startAngle;
    const endAngle = shape.endAngle;
    const clockwise = shape.clockwise;
    const unitX = Math.cos(startAngle);
    const unitY = Math.sin(startAngle);
    ctx.moveTo(unitX * r + x, unitY * r + y);
    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
  }
};
Arc.prototype.type = "arc";
var Arc_default = Arc;

// node_modules/zrender/src/graphic/CompoundPath.ts
var CompoundPath = class extends Path_default {
  constructor() {
    super(...arguments);
    this.type = "compound";
  }
  _updatePathDirty() {
    const paths = this.shape.paths;
    let dirtyPath = this.shapeChanged();
    for (let i = 0; i < paths.length; i++) {
      dirtyPath = dirtyPath || paths[i].shapeChanged();
    }
    if (dirtyPath) {
      this.dirtyShape();
    }
  }
  beforeBrush() {
    this._updatePathDirty();
    const paths = this.shape.paths || [];
    const scale4 = this.getGlobalScale();
    for (let i = 0; i < paths.length; i++) {
      if (!paths[i].path) {
        paths[i].createPathProxy();
      }
      paths[i].path.setScale(scale4[0], scale4[1], paths[i].segmentIgnoreThreshold);
    }
  }
  buildPath(ctx, shape) {
    const paths = shape.paths || [];
    for (let i = 0; i < paths.length; i++) {
      paths[i].buildPath(ctx, paths[i].shape, true);
    }
  }
  afterBrush() {
    const paths = this.shape.paths || [];
    for (let i = 0; i < paths.length; i++) {
      paths[i].pathUpdated();
    }
  }
  getBoundingRect() {
    this._updatePathDirty.call(this);
    return Path_default.prototype.getBoundingRect.call(this);
  }
};
var CompoundPath_default = CompoundPath;

// node_modules/zrender/src/graphic/Gradient.ts
var Gradient = class {
  constructor(colorStops) {
    this.colorStops = colorStops || [];
  }
  addColorStop(offset, color2) {
    this.colorStops.push({
      offset,
      color: color2
    });
  }
};
var Gradient_default = Gradient;

// node_modules/zrender/src/graphic/LinearGradient.ts
var LinearGradient = class extends Gradient_default {
  constructor(x, y, x2, y2, colorStops, globalCoord) {
    super(colorStops);
    this.x = x == null ? 0 : x;
    this.y = y == null ? 0 : y;
    this.x2 = x2 == null ? 1 : x2;
    this.y2 = y2 == null ? 0 : y2;
    this.type = "linear";
    this.global = globalCoord || false;
  }
};
var LinearGradient_default = LinearGradient;

// node_modules/zrender/src/graphic/RadialGradient.ts
var RadialGradient = class extends Gradient_default {
  constructor(x, y, r, colorStops, globalCoord) {
    super(colorStops);
    this.x = x == null ? 0.5 : x;
    this.y = y == null ? 0.5 : y;
    this.r = r == null ? 0.5 : r;
    this.type = "radial";
    this.global = globalCoord || false;
  }
};
var RadialGradient_default = RadialGradient;

// node_modules/zrender/src/core/OrientedBoundingRect.ts
var extent = [0, 0];
var extent2 = [0, 0];
var minTv2 = new Point_default();
var maxTv2 = new Point_default();
var OrientedBoundingRect = class {
  constructor(rect, transform2) {
    this._corners = [];
    this._axes = [];
    this._origin = [0, 0];
    for (let i = 0; i < 4; i++) {
      this._corners[i] = new Point_default();
    }
    for (let i = 0; i < 2; i++) {
      this._axes[i] = new Point_default();
    }
    if (rect) {
      this.fromBoundingRect(rect, transform2);
    }
  }
  fromBoundingRect(rect, transform2) {
    const corners = this._corners;
    const axes = this._axes;
    const x = rect.x;
    const y = rect.y;
    const x2 = x + rect.width;
    const y2 = y + rect.height;
    corners[0].set(x, y);
    corners[1].set(x2, y);
    corners[2].set(x2, y2);
    corners[3].set(x, y2);
    if (transform2) {
      for (let i = 0; i < 4; i++) {
        corners[i].transform(transform2);
      }
    }
    Point_default.sub(axes[0], corners[1], corners[0]);
    Point_default.sub(axes[1], corners[3], corners[0]);
    axes[0].normalize();
    axes[1].normalize();
    for (let i = 0; i < 2; i++) {
      this._origin[i] = axes[i].dot(corners[0]);
    }
  }
  intersect(other, mtv) {
    let overlapped = true;
    const noMtv = !mtv;
    minTv2.set(Infinity, Infinity);
    maxTv2.set(0, 0);
    if (!this._intersectCheckOneSide(this, other, minTv2, maxTv2, noMtv, 1)) {
      overlapped = false;
      if (noMtv) {
        return overlapped;
      }
    }
    if (!this._intersectCheckOneSide(other, this, minTv2, maxTv2, noMtv, -1)) {
      overlapped = false;
      if (noMtv) {
        return overlapped;
      }
    }
    if (!noMtv) {
      Point_default.copy(mtv, overlapped ? minTv2 : maxTv2);
    }
    return overlapped;
  }
  _intersectCheckOneSide(self2, other, minTv3, maxTv3, noMtv, inverse) {
    let overlapped = true;
    for (let i = 0; i < 2; i++) {
      const axis = this._axes[i];
      this._getProjMinMaxOnAxis(i, self2._corners, extent);
      this._getProjMinMaxOnAxis(i, other._corners, extent2);
      if (extent[1] < extent2[0] || extent[0] > extent2[1]) {
        overlapped = false;
        if (noMtv) {
          return overlapped;
        }
        const dist0 = Math.abs(extent2[0] - extent[1]);
        const dist1 = Math.abs(extent[0] - extent2[1]);
        if (Math.min(dist0, dist1) > maxTv3.len()) {
          if (dist0 < dist1) {
            Point_default.scale(maxTv3, axis, -dist0 * inverse);
          } else {
            Point_default.scale(maxTv3, axis, dist1 * inverse);
          }
        }
      } else if (minTv3) {
        const dist0 = Math.abs(extent2[0] - extent[1]);
        const dist1 = Math.abs(extent[0] - extent2[1]);
        if (Math.min(dist0, dist1) < minTv3.len()) {
          if (dist0 < dist1) {
            Point_default.scale(minTv3, axis, dist0 * inverse);
          } else {
            Point_default.scale(minTv3, axis, -dist1 * inverse);
          }
        }
      }
    }
    return overlapped;
  }
  _getProjMinMaxOnAxis(dim, corners, out2) {
    const axis = this._axes[dim];
    const origin = this._origin;
    const proj = corners[0].dot(axis) + origin[dim];
    let min3 = proj;
    let max3 = proj;
    for (let i = 1; i < corners.length; i++) {
      const proj2 = corners[i].dot(axis) + origin[dim];
      min3 = Math.min(proj2, min3);
      max3 = Math.max(proj2, max3);
    }
    out2[0] = min3;
    out2[1] = max3;
  }
};
var OrientedBoundingRect_default = OrientedBoundingRect;

// node_modules/zrender/src/graphic/IncrementalDisplayable.ts
var m = [];
var IncrementalDisplayable = class extends Displayable_default {
  constructor() {
    super(...arguments);
    this.notClear = true;
    this.incremental = true;
    this._displayables = [];
    this._temporaryDisplayables = [];
    this._cursor = 0;
  }
  traverse(cb, context) {
    cb.call(context, this);
  }
  useStyle() {
    this.style = {};
  }
  getCursor() {
    return this._cursor;
  }
  innerAfterBrush() {
    this._cursor = this._displayables.length;
  }
  clearDisplaybles() {
    this._displayables = [];
    this._temporaryDisplayables = [];
    this._cursor = 0;
    this.markRedraw();
    this.notClear = false;
  }
  clearTemporalDisplayables() {
    this._temporaryDisplayables = [];
  }
  addDisplayable(displayable, notPersistent) {
    if (notPersistent) {
      this._temporaryDisplayables.push(displayable);
    } else {
      this._displayables.push(displayable);
    }
    this.markRedraw();
  }
  addDisplayables(displayables, notPersistent) {
    notPersistent = notPersistent || false;
    for (let i = 0; i < displayables.length; i++) {
      this.addDisplayable(displayables[i], notPersistent);
    }
  }
  getDisplayables() {
    return this._displayables;
  }
  getTemporalDisplayables() {
    return this._temporaryDisplayables;
  }
  eachPendingDisplayable(cb) {
    for (let i = this._cursor; i < this._displayables.length; i++) {
      cb && cb(this._displayables[i]);
    }
    for (let i = 0; i < this._temporaryDisplayables.length; i++) {
      cb && cb(this._temporaryDisplayables[i]);
    }
  }
  update() {
    this.updateTransform();
    for (let i = this._cursor; i < this._displayables.length; i++) {
      const displayable = this._displayables[i];
      displayable.parent = this;
      displayable.update();
      displayable.parent = null;
    }
    for (let i = 0; i < this._temporaryDisplayables.length; i++) {
      const displayable = this._temporaryDisplayables[i];
      displayable.parent = this;
      displayable.update();
      displayable.parent = null;
    }
  }
  getBoundingRect() {
    if (!this._rect) {
      const rect = new BoundingRect_default(Infinity, Infinity, -Infinity, -Infinity);
      for (let i = 0; i < this._displayables.length; i++) {
        const displayable = this._displayables[i];
        const childRect = displayable.getBoundingRect().clone();
        if (displayable.needLocalTransform()) {
          childRect.applyTransform(displayable.getLocalTransform(m));
        }
        rect.union(childRect);
      }
      this._rect = rect;
    }
    return this._rect;
  }
  contain(x, y) {
    const localPos = this.transformCoordToLocal(x, y);
    const rect = this.getBoundingRect();
    if (rect.contain(localPos[0], localPos[1])) {
      for (let i = 0; i < this._displayables.length; i++) {
        const displayable = this._displayables[i];
        if (displayable.contain(x, y)) {
          return true;
        }
      }
    }
    return false;
  }
};
var IncrementalDisplayable_default = IncrementalDisplayable;

// src/animation/basicTransition.ts
var transitionStore = makeInner();
function getAnimationConfig(animationType, animatableModel, dataIndex, extraOpts, extraDelayParams) {
  let animationPayload;
  if (animatableModel && animatableModel.ecModel) {
    const updatePayload = animatableModel.ecModel.getUpdatePayload();
    animationPayload = updatePayload && updatePayload.animation;
  }
  const animationEnabled = animatableModel && animatableModel.isAnimationEnabled();
  const isUpdate = animationType === "update";
  if (animationEnabled) {
    let duration;
    let easing;
    let delay;
    if (extraOpts) {
      duration = retrieve2(extraOpts.duration, 200);
      easing = retrieve2(extraOpts.easing, "cubicOut");
      delay = 0;
    } else {
      duration = animatableModel.getShallow(isUpdate ? "animationDurationUpdate" : "animationDuration");
      easing = animatableModel.getShallow(isUpdate ? "animationEasingUpdate" : "animationEasing");
      delay = animatableModel.getShallow(isUpdate ? "animationDelayUpdate" : "animationDelay");
    }
    if (animationPayload) {
      animationPayload.duration != null && (duration = animationPayload.duration);
      animationPayload.easing != null && (easing = animationPayload.easing);
      animationPayload.delay != null && (delay = animationPayload.delay);
    }
    if (isFunction(delay)) {
      delay = delay(dataIndex, extraDelayParams);
    }
    if (isFunction(duration)) {
      duration = duration(dataIndex);
    }
    const config = {
      duration: duration || 0,
      delay,
      easing
    };
    return config;
  } else {
    return null;
  }
}
function animateOrSetProps(animationType, el, props, animatableModel, dataIndex, cb, during) {
  let isFrom = false;
  let removeOpt;
  if (isFunction(dataIndex)) {
    during = cb;
    cb = dataIndex;
    dataIndex = null;
  } else if (isObject(dataIndex)) {
    cb = dataIndex.cb;
    during = dataIndex.during;
    isFrom = dataIndex.isFrom;
    removeOpt = dataIndex.removeOpt;
    dataIndex = dataIndex.dataIndex;
  }
  const isRemove = animationType === "leave";
  if (!isRemove) {
    el.stopAnimation("leave");
  }
  const animationConfig = getAnimationConfig(animationType, animatableModel, dataIndex, isRemove ? removeOpt || {} : null, animatableModel && animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);
  if (animationConfig && animationConfig.duration > 0) {
    const duration = animationConfig.duration;
    const animationDelay = animationConfig.delay;
    const animationEasing = animationConfig.easing;
    const animateConfig = {
      duration,
      delay: animationDelay || 0,
      easing: animationEasing,
      done: cb,
      force: !!cb || !!during,
      setToFinal: !isRemove,
      scope: animationType,
      during
    };
    isFrom ? el.animateFrom(props, animateConfig) : el.animateTo(props, animateConfig);
  } else {
    el.stopAnimation();
    !isFrom && el.attr(props);
    during && during(1);
    cb && cb();
  }
}
function updateProps(el, props, animatableModel, dataIndex, cb, during) {
  animateOrSetProps("update", el, props, animatableModel, dataIndex, cb, during);
}
function initProps(el, props, animatableModel, dataIndex, cb, during) {
  animateOrSetProps("enter", el, props, animatableModel, dataIndex, cb, during);
}
function isElementRemoved(el) {
  if (!el.__zr) {
    return true;
  }
  for (let i = 0; i < el.animators.length; i++) {
    const animator = el.animators[i];
    if (animator.scope === "leave") {
      return true;
    }
  }
  return false;
}
function removeElement(el, props, animatableModel, dataIndex, cb, during) {
  if (isElementRemoved(el)) {
    return;
  }
  animateOrSetProps("leave", el, props, animatableModel, dataIndex, cb, during);
}
function fadeOutDisplayable(el, animatableModel, dataIndex, done) {
  el.removeTextContent();
  el.removeTextGuideLine();
  removeElement(el, {
    style: {
      opacity: 0
    }
  }, animatableModel, dataIndex, done);
}
function removeElementWithFadeOut(el, animatableModel, dataIndex) {
  function doRemove() {
    el.parent && el.parent.remove(el);
  }
  if (!el.isGroup) {
    fadeOutDisplayable(el, animatableModel, dataIndex, doRemove);
  } else {
    el.traverse(function(disp) {
      if (!disp.isGroup) {
        fadeOutDisplayable(disp, animatableModel, dataIndex, doRemove);
      }
    });
  }
}
function saveOldStyle(el) {
  transitionStore(el).oldStyle = el.style;
}
function getOldStyle(el) {
  return transitionStore(el).oldStyle;
}

// src/util/graphic.ts
var mathMax5 = Math.max;
var mathMin5 = Math.min;
var _customShapeMap = {};
function extendShape(opts) {
  return Path_default.extend(opts);
}
var extendPathFromString = extendFromString;
function extendPath(pathData, opts) {
  return extendPathFromString(pathData, opts);
}
function registerShape(name, ShapeClass) {
  _customShapeMap[name] = ShapeClass;
}
function getShapeClass(name) {
  if (_customShapeMap.hasOwnProperty(name)) {
    return _customShapeMap[name];
  }
}
function makePath(pathData, opts, rect, layout18) {
  const path = createFromString(pathData, opts);
  if (rect) {
    if (layout18 === "center") {
      rect = centerGraphic(rect, path.getBoundingRect());
    }
    resizePath(path, rect);
  }
  return path;
}
function makeImage(imageUrl, rect, layout18) {
  const zrImg = new Image_default({
    style: {
      image: imageUrl,
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    onload(img) {
      if (layout18 === "center") {
        const boundingRect = {
          width: img.width,
          height: img.height
        };
        zrImg.setStyle(centerGraphic(rect, boundingRect));
      }
    }
  });
  return zrImg;
}
function centerGraphic(rect, boundingRect) {
  const aspect = boundingRect.width / boundingRect.height;
  let width = rect.height * aspect;
  let height;
  if (width <= rect.width) {
    height = rect.height;
  } else {
    width = rect.width;
    height = width / aspect;
  }
  const cx = rect.x + rect.width / 2;
  const cy = rect.y + rect.height / 2;
  return {
    x: cx - width / 2,
    y: cy - height / 2,
    width,
    height
  };
}
var mergePath2 = mergePath;
function resizePath(path, rect) {
  if (!path.applyTransform) {
    return;
  }
  const pathRect = path.getBoundingRect();
  const m2 = pathRect.calculateTransform(rect);
  path.applyTransform(m2);
}
function subPixelOptimizeLine2(shape, lineWidth) {
  subPixelOptimizeLine(shape, shape, {lineWidth});
  return shape;
}
function subPixelOptimizeRect2(param) {
  subPixelOptimizeRect(param.shape, param.shape, param.style);
  return param;
}
var subPixelOptimize2 = subPixelOptimize;
function getTransform(target, ancestor) {
  const mat = identity([]);
  while (target && target !== ancestor) {
    mul2(mat, target.getLocalTransform(), mat);
    target = target.parent;
  }
  return mat;
}
function applyTransform2(target, transform2, invert2) {
  if (transform2 && !isArrayLike(transform2)) {
    transform2 = Transformable_default.getLocalTransform(transform2);
  }
  if (invert2) {
    transform2 = invert([], transform2);
  }
  return applyTransform([], target, transform2);
}
function transformDirection(direction, transform2, invert2) {
  const hBase = transform2[4] === 0 || transform2[5] === 0 || transform2[0] === 0 ? 1 : Math.abs(2 * transform2[4] / transform2[0]);
  const vBase = transform2[4] === 0 || transform2[5] === 0 || transform2[2] === 0 ? 1 : Math.abs(2 * transform2[4] / transform2[2]);
  let vertex = [
    direction === "left" ? -hBase : direction === "right" ? hBase : 0,
    direction === "top" ? -vBase : direction === "bottom" ? vBase : 0
  ];
  vertex = applyTransform2(vertex, transform2, invert2);
  return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? "right" : "left" : vertex[1] > 0 ? "bottom" : "top";
}
function isNotGroup(el) {
  return !el.isGroup;
}
function isPath(el) {
  return el.shape != null;
}
function groupTransition(g1, g2, animatableModel) {
  if (!g1 || !g2) {
    return;
  }
  function getElMap(g) {
    const elMap = {};
    g.traverse(function(el) {
      if (isNotGroup(el) && el.anid) {
        elMap[el.anid] = el;
      }
    });
    return elMap;
  }
  function getAnimatableProps(el) {
    const obj = {
      x: el.x,
      y: el.y,
      rotation: el.rotation
    };
    if (isPath(el)) {
      obj.shape = extend({}, el.shape);
    }
    return obj;
  }
  const elMap1 = getElMap(g1);
  g2.traverse(function(el) {
    if (isNotGroup(el) && el.anid) {
      const oldEl = elMap1[el.anid];
      if (oldEl) {
        const newProp = getAnimatableProps(el);
        el.attr(getAnimatableProps(oldEl));
        updateProps(el, newProp, animatableModel, getECData(el).dataIndex);
      }
    }
  });
}
function clipPointsByRect(points4, rect) {
  return map(points4, function(point) {
    let x = point[0];
    x = mathMax5(x, rect.x);
    x = mathMin5(x, rect.x + rect.width);
    let y = point[1];
    y = mathMax5(y, rect.y);
    y = mathMin5(y, rect.y + rect.height);
    return [x, y];
  });
}
function clipRectByRect(targetRect, rect) {
  const x = mathMax5(targetRect.x, rect.x);
  const x2 = mathMin5(targetRect.x + targetRect.width, rect.x + rect.width);
  const y = mathMax5(targetRect.y, rect.y);
  const y2 = mathMin5(targetRect.y + targetRect.height, rect.y + rect.height);
  if (x2 >= x && y2 >= y) {
    return {
      x,
      y,
      width: x2 - x,
      height: y2 - y
    };
  }
}
function createIcon(iconStr, opt, rect) {
  const innerOpts = extend({rectHover: true}, opt);
  const style = innerOpts.style = {strokeNoScale: true};
  rect = rect || {x: -1, y: -1, width: 2, height: 2};
  if (iconStr) {
    return iconStr.indexOf("image://") === 0 ? (style.image = iconStr.slice(8), defaults(style, rect), new Image_default(innerOpts)) : makePath(iconStr.replace("path://", ""), innerOpts, rect, "center");
  }
}
function linePolygonIntersect(a1x, a1y, a2x, a2y, points4) {
  for (let i = 0, p2 = points4[points4.length - 1]; i < points4.length; i++) {
    const p = points4[i];
    if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) {
      return true;
    }
    p2 = p;
  }
}
function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
  const mx = a2x - a1x;
  const my = a2y - a1y;
  const nx = b2x - b1x;
  const ny = b2y - b1y;
  const nmCrossProduct = crossProduct2d(nx, ny, mx, my);
  if (nearZero(nmCrossProduct)) {
    return false;
  }
  const b1a1x = a1x - b1x;
  const b1a1y = a1y - b1y;
  const q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;
  if (q < 0 || q > 1) {
    return false;
  }
  const p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
  if (p < 0 || p > 1) {
    return false;
  }
  return true;
}
function crossProduct2d(x1, y1, x2, y2) {
  return x1 * y2 - x2 * y1;
}
function nearZero(val) {
  return val <= 1e-6 && val >= -1e-6;
}
function setTooltipConfig(opt) {
  const itemTooltipOption = opt.itemTooltipOption;
  const componentModel = opt.componentModel;
  const itemName = opt.itemName;
  const itemTooltipOptionObj = isString(itemTooltipOption) ? {formatter: itemTooltipOption} : itemTooltipOption;
  const mainType = componentModel.mainType;
  const componentIndex = componentModel.componentIndex;
  const formatterParams = {
    componentType: mainType,
    name: itemName,
    $vars: ["name"]
  };
  formatterParams[mainType + "Index"] = componentIndex;
  const formatterParamsExtra = opt.formatterParamsExtra;
  if (formatterParamsExtra) {
    each(keys(formatterParamsExtra), (key) => {
      if (!hasOwn(formatterParams, key)) {
        formatterParams[key] = formatterParamsExtra[key];
        formatterParams.$vars.push(key);
      }
    });
  }
  const ecData = getECData(opt.el);
  ecData.componentMainType = mainType;
  ecData.componentIndex = componentIndex;
  ecData.tooltipConfig = {
    name: itemName,
    option: defaults({
      content: itemName,
      formatterParams
    }, itemTooltipOptionObj)
  };
}
function traverseElement(el, cb) {
  let stopped;
  if (el.isGroup) {
    stopped = cb(el);
  }
  if (!stopped) {
    el.traverse(cb);
  }
}
function traverseElements(els, cb) {
  if (els) {
    if (isArray(els)) {
      for (let i = 0; i < els.length; i++) {
        traverseElement(els[i], cb);
      }
    } else {
      traverseElement(els, cb);
    }
  }
}
registerShape("circle", Circle_default);
registerShape("ellipse", Ellipse_default);
registerShape("sector", Sector_default);
registerShape("ring", Ring_default);
registerShape("polygon", Polygon_default);
registerShape("polyline", Polyline_default);
registerShape("rect", Rect_default);
registerShape("line", Line_default);
registerShape("bezierCurve", BezierCurve_default);
registerShape("arc", Arc_default);

// src/label/labelStyle.ts
var EMPTY_OBJ = {};
function setLabelText(label, labelTexts) {
  for (let i = 0; i < SPECIAL_STATES.length; i++) {
    const stateName = SPECIAL_STATES[i];
    const text = labelTexts[stateName];
    const state = label.ensureState(stateName);
    state.style = state.style || {};
    state.style.text = text;
  }
  const oldStates = label.currentStates.slice();
  label.clearStates(true);
  label.setStyle({text: labelTexts.normal});
  label.useStates(oldStates, true);
}
function getLabelText(opt, stateModels, interpolatedValue) {
  const labelFetcher = opt.labelFetcher;
  const labelDataIndex = opt.labelDataIndex;
  const labelDimIndex = opt.labelDimIndex;
  const normalModel = stateModels.normal;
  let baseText;
  if (labelFetcher) {
    baseText = labelFetcher.getFormattedLabel(labelDataIndex, "normal", null, labelDimIndex, normalModel && normalModel.get("formatter"), interpolatedValue != null ? {
      interpolatedValue
    } : null);
  }
  if (baseText == null) {
    baseText = isFunction(opt.defaultText) ? opt.defaultText(labelDataIndex, opt, interpolatedValue) : opt.defaultText;
  }
  const statesText = {
    normal: baseText
  };
  for (let i = 0; i < SPECIAL_STATES.length; i++) {
    const stateName = SPECIAL_STATES[i];
    const stateModel = stateModels[stateName];
    statesText[stateName] = retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, stateName, null, labelDimIndex, stateModel && stateModel.get("formatter")) : null, baseText);
  }
  return statesText;
}
function setLabelStyle(targetEl, labelStatesModels, opt, stateSpecified) {
  opt = opt || EMPTY_OBJ;
  const isSetOnText = targetEl instanceof Text_default;
  let needsCreateText = false;
  for (let i = 0; i < DISPLAY_STATES.length; i++) {
    const stateModel = labelStatesModels[DISPLAY_STATES[i]];
    if (stateModel && stateModel.getShallow("show")) {
      needsCreateText = true;
      break;
    }
  }
  let textContent = isSetOnText ? targetEl : targetEl.getTextContent();
  if (needsCreateText) {
    if (!isSetOnText) {
      if (!textContent) {
        textContent = new Text_default();
        targetEl.setTextContent(textContent);
      }
      if (targetEl.stateProxy) {
        textContent.stateProxy = targetEl.stateProxy;
      }
    }
    const labelStatesTexts = getLabelText(opt, labelStatesModels);
    const normalModel = labelStatesModels.normal;
    const showNormal = !!normalModel.getShallow("show");
    const normalStyle = createTextStyle(normalModel, stateSpecified && stateSpecified.normal, opt, false, !isSetOnText);
    normalStyle.text = labelStatesTexts.normal;
    if (!isSetOnText) {
      targetEl.setTextConfig(createTextConfig(normalModel, opt, false));
    }
    for (let i = 0; i < SPECIAL_STATES.length; i++) {
      const stateName = SPECIAL_STATES[i];
      const stateModel = labelStatesModels[stateName];
      if (stateModel) {
        const stateObj = textContent.ensureState(stateName);
        const stateShow = !!retrieve2(stateModel.getShallow("show"), showNormal);
        if (stateShow !== showNormal) {
          stateObj.ignore = !stateShow;
        }
        stateObj.style = createTextStyle(stateModel, stateSpecified && stateSpecified[stateName], opt, true, !isSetOnText);
        stateObj.style.text = labelStatesTexts[stateName];
        if (!isSetOnText) {
          const targetElEmphasisState = targetEl.ensureState(stateName);
          targetElEmphasisState.textConfig = createTextConfig(stateModel, opt, true);
        }
      }
    }
    textContent.silent = !!normalModel.getShallow("silent");
    if (textContent.style.x != null) {
      normalStyle.x = textContent.style.x;
    }
    if (textContent.style.y != null) {
      normalStyle.y = textContent.style.y;
    }
    textContent.ignore = !showNormal;
    textContent.useStyle(normalStyle);
    textContent.dirty();
    if (opt.enableTextSetter) {
      labelInner(textContent).setLabelText = function(interpolatedValue) {
        const labelStatesTexts2 = getLabelText(opt, labelStatesModels, interpolatedValue);
        setLabelText(textContent, labelStatesTexts2);
      };
    }
  } else if (textContent) {
    textContent.ignore = true;
  }
  targetEl.dirty();
}
function getLabelStatesModels(itemModel, labelName) {
  labelName = labelName || "label";
  const statesModels = {
    normal: itemModel.getModel(labelName)
  };
  for (let i = 0; i < SPECIAL_STATES.length; i++) {
    const stateName = SPECIAL_STATES[i];
    statesModels[stateName] = itemModel.getModel([stateName, labelName]);
  }
  return statesModels;
}
function createTextStyle(textStyleModel, specifiedTextStyle, opt, isNotNormal, isAttached) {
  const textStyle = {};
  setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached);
  specifiedTextStyle && extend(textStyle, specifiedTextStyle);
  return textStyle;
}
function createTextConfig(textStyleModel, opt, isNotNormal) {
  opt = opt || {};
  const textConfig = {};
  let labelPosition;
  let labelRotate = textStyleModel.getShallow("rotate");
  const labelDistance = retrieve2(textStyleModel.getShallow("distance"), isNotNormal ? null : 5);
  const labelOffset = textStyleModel.getShallow("offset");
  labelPosition = textStyleModel.getShallow("position") || (isNotNormal ? null : "inside");
  labelPosition === "outside" && (labelPosition = opt.defaultOutsidePosition || "top");
  if (labelPosition != null) {
    textConfig.position = labelPosition;
  }
  if (labelOffset != null) {
    textConfig.offset = labelOffset;
  }
  if (labelRotate != null) {
    labelRotate *= Math.PI / 180;
    textConfig.rotation = labelRotate;
  }
  if (labelDistance != null) {
    textConfig.distance = labelDistance;
  }
  textConfig.outsideFill = textStyleModel.get("color") === "inherit" ? opt.inheritColor || null : "auto";
  return textConfig;
}
function setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached) {
  opt = opt || EMPTY_OBJ;
  const ecModel = textStyleModel.ecModel;
  const globalTextStyle = ecModel && ecModel.option.textStyle;
  const richItemNames = getRichItemNames(textStyleModel);
  let richResult;
  if (richItemNames) {
    richResult = {};
    for (const name in richItemNames) {
      if (richItemNames.hasOwnProperty(name)) {
        const richTextStyle = textStyleModel.getModel(["rich", name]);
        setTokenTextStyle(richResult[name] = {}, richTextStyle, globalTextStyle, opt, isNotNormal, isAttached, false, true);
      }
    }
  }
  if (richResult) {
    textStyle.rich = richResult;
  }
  const overflow = textStyleModel.get("overflow");
  if (overflow) {
    textStyle.overflow = overflow;
  }
  const margin = textStyleModel.get("minMargin");
  if (margin != null) {
    textStyle.margin = margin;
  }
  setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, true, false);
}
function getRichItemNames(textStyleModel) {
  let richItemNameMap;
  while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
    const rich = (textStyleModel.option || EMPTY_OBJ).rich;
    if (rich) {
      richItemNameMap = richItemNameMap || {};
      const richKeys = keys(rich);
      for (let i = 0; i < richKeys.length; i++) {
        const richKey = richKeys[i];
        richItemNameMap[richKey] = 1;
      }
    }
    textStyleModel = textStyleModel.parentModel;
  }
  return richItemNameMap;
}
var TEXT_PROPS_WITH_GLOBAL = [
  "fontStyle",
  "fontWeight",
  "fontSize",
  "fontFamily",
  "textShadowColor",
  "textShadowBlur",
  "textShadowOffsetX",
  "textShadowOffsetY"
];
var TEXT_PROPS_SELF = [
  "align",
  "lineHeight",
  "width",
  "height",
  "tag",
  "verticalAlign",
  "ellipsis"
];
var TEXT_PROPS_BOX = [
  "padding",
  "borderWidth",
  "borderRadius",
  "borderDashOffset",
  "backgroundColor",
  "borderColor",
  "shadowColor",
  "shadowBlur",
  "shadowOffsetX",
  "shadowOffsetY"
];
function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, isBlock, inRich) {
  globalTextStyle = !isNotNormal && globalTextStyle || EMPTY_OBJ;
  const inheritColor = opt && opt.inheritColor;
  let fillColor = textStyleModel.getShallow("color");
  let strokeColor = textStyleModel.getShallow("textBorderColor");
  let opacity = retrieve2(textStyleModel.getShallow("opacity"), globalTextStyle.opacity);
  if (fillColor === "inherit" || fillColor === "auto") {
    if (true) {
      if (fillColor === "auto") {
        deprecateReplaceLog("color: 'auto'", "color: 'inherit'");
      }
    }
    if (inheritColor) {
      fillColor = inheritColor;
    } else {
      fillColor = null;
    }
  }
  if (strokeColor === "inherit" || strokeColor === "auto") {
    if (true) {
      if (strokeColor === "auto") {
        deprecateReplaceLog("color: 'auto'", "color: 'inherit'");
      }
    }
    if (inheritColor) {
      strokeColor = inheritColor;
    } else {
      strokeColor = null;
    }
  }
  if (!isAttached) {
    fillColor = fillColor || globalTextStyle.color;
    strokeColor = strokeColor || globalTextStyle.textBorderColor;
  }
  if (fillColor != null) {
    textStyle.fill = fillColor;
  }
  if (strokeColor != null) {
    textStyle.stroke = strokeColor;
  }
  const textBorderWidth = retrieve2(textStyleModel.getShallow("textBorderWidth"), globalTextStyle.textBorderWidth);
  if (textBorderWidth != null) {
    textStyle.lineWidth = textBorderWidth;
  }
  const textBorderType = retrieve2(textStyleModel.getShallow("textBorderType"), globalTextStyle.textBorderType);
  if (textBorderType != null) {
    textStyle.lineDash = textBorderType;
  }
  const textBorderDashOffset = retrieve2(textStyleModel.getShallow("textBorderDashOffset"), globalTextStyle.textBorderDashOffset);
  if (textBorderDashOffset != null) {
    textStyle.lineDashOffset = textBorderDashOffset;
  }
  if (!isNotNormal && opacity == null && !inRich) {
    opacity = opt && opt.defaultOpacity;
  }
  if (opacity != null) {
    textStyle.opacity = opacity;
  }
  if (!isNotNormal && !isAttached) {
    if (textStyle.fill == null && opt.inheritColor) {
      textStyle.fill = opt.inheritColor;
    }
  }
  for (let i = 0; i < TEXT_PROPS_WITH_GLOBAL.length; i++) {
    const key = TEXT_PROPS_WITH_GLOBAL[i];
    const val = retrieve2(textStyleModel.getShallow(key), globalTextStyle[key]);
    if (val != null) {
      textStyle[key] = val;
    }
  }
  for (let i = 0; i < TEXT_PROPS_SELF.length; i++) {
    const key = TEXT_PROPS_SELF[i];
    const val = textStyleModel.getShallow(key);
    if (val != null) {
      textStyle[key] = val;
    }
  }
  if (textStyle.verticalAlign == null) {
    const baseline = textStyleModel.getShallow("baseline");
    if (baseline != null) {
      textStyle.verticalAlign = baseline;
    }
  }
  if (!isBlock || !opt.disableBox) {
    for (let i = 0; i < TEXT_PROPS_BOX.length; i++) {
      const key = TEXT_PROPS_BOX[i];
      const val = textStyleModel.getShallow(key);
      if (val != null) {
        textStyle[key] = val;
      }
    }
    const borderType = textStyleModel.getShallow("borderType");
    if (borderType != null) {
      textStyle.borderDash = borderType;
    }
    if ((textStyle.backgroundColor === "auto" || textStyle.backgroundColor === "inherit") && inheritColor) {
      if (true) {
        if (textStyle.backgroundColor === "auto") {
          deprecateReplaceLog("backgroundColor: 'auto'", "backgroundColor: 'inherit'");
        }
      }
      textStyle.backgroundColor = inheritColor;
    }
    if ((textStyle.borderColor === "auto" || textStyle.borderColor === "inherit") && inheritColor) {
      if (true) {
        if (textStyle.borderColor === "auto") {
          deprecateReplaceLog("borderColor: 'auto'", "borderColor: 'inherit'");
        }
      }
      textStyle.borderColor = inheritColor;
    }
  }
}
function getFont(opt, ecModel) {
  const gTextStyleModel = ecModel && ecModel.getModel("textStyle");
  return trim([
    opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow("fontStyle") || "",
    opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow("fontWeight") || "",
    (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow("fontSize") || 12) + "px",
    opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var labelInner = makeInner();
function setLabelValueAnimation(label, labelStatesModels, value, getDefaultText) {
  if (!label) {
    return;
  }
  const obj = labelInner(label);
  obj.prevValue = obj.value;
  obj.value = value;
  const normalLabelModel = labelStatesModels.normal;
  obj.valueAnimation = normalLabelModel.get("valueAnimation");
  if (obj.valueAnimation) {
    obj.precision = normalLabelModel.get("precision");
    obj.defaultInterpolatedText = getDefaultText;
    obj.statesModels = labelStatesModels;
  }
}
function animateLabelValue(textEl, dataIndex, data, animatableModel, labelFetcher) {
  const labelInnerStore = labelInner(textEl);
  if (!labelInnerStore.valueAnimation || labelInnerStore.prevValue === labelInnerStore.value) {
    return;
  }
  const defaultInterpolatedText = labelInnerStore.defaultInterpolatedText;
  const currValue = retrieve2(labelInnerStore.interpolatedValue, labelInnerStore.prevValue);
  const targetValue = labelInnerStore.value;
  function during(percent) {
    const interpolated = interpolateRawValues(data, labelInnerStore.precision, currValue, targetValue, percent);
    labelInnerStore.interpolatedValue = percent === 1 ? null : interpolated;
    const labelText = getLabelText({
      labelDataIndex: dataIndex,
      labelFetcher,
      defaultText: defaultInterpolatedText ? defaultInterpolatedText(interpolated) : interpolated + ""
    }, labelInnerStore.statesModels, interpolated);
    setLabelText(textEl, labelText);
  }
  textEl.percent = 0;
  (labelInnerStore.prevValue == null ? initProps : updateProps)(textEl, {
    percent: 1
  }, animatableModel, dataIndex, null, during);
}

// src/model/mixin/textStyle.ts
var PATH_COLOR = ["textStyle", "color"];
var textStyleParams = [
  "fontStyle",
  "fontWeight",
  "fontSize",
  "fontFamily",
  "padding",
  "lineHeight",
  "rich",
  "width",
  "height",
  "overflow"
];
var tmpText = new Text_default();
var TextStyleMixin = class {
  getTextColor(isEmphasis) {
    const ecModel = this.ecModel;
    return this.getShallow("color") || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
  }
  getFont() {
    return getFont({
      fontStyle: this.getShallow("fontStyle"),
      fontWeight: this.getShallow("fontWeight"),
      fontSize: this.getShallow("fontSize"),
      fontFamily: this.getShallow("fontFamily")
    }, this.ecModel);
  }
  getTextRect(text) {
    const style = {
      text,
      verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
    };
    for (let i = 0; i < textStyleParams.length; i++) {
      style[textStyleParams[i]] = this.getShallow(textStyleParams[i]);
    }
    tmpText.useStyle(style);
    tmpText.update();
    return tmpText.getBoundingRect();
  }
};
var textStyle_default = TextStyleMixin;

// src/model/mixin/lineStyle.ts
var LINE_STYLE_KEY_MAP = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
];
var getLineStyle = makeStyleMapper(LINE_STYLE_KEY_MAP);
var LineStyleMixin = class {
  getLineStyle(excludes) {
    return getLineStyle(this, excludes);
  }
};

// src/model/mixin/itemStyle.ts
var ITEM_STYLE_KEY_MAP = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
];
var getItemStyle = makeStyleMapper(ITEM_STYLE_KEY_MAP);
var ItemStyleMixin = class {
  getItemStyle(excludes, includes) {
    return getItemStyle(this, excludes, includes);
  }
};

// src/model/Model.ts
var Model = class {
  constructor(option, parentModel, ecModel) {
    this.parentModel = parentModel;
    this.ecModel = ecModel;
    this.option = option;
  }
  init(option, parentModel, ecModel, ...rest) {
  }
  mergeOption(option, ecModel) {
    merge(this.option, option, true);
  }
  get(path, ignoreParent) {
    if (path == null) {
      return this.option;
    }
    return this._doGet(this.parsePath(path), !ignoreParent && this.parentModel);
  }
  getShallow(key, ignoreParent) {
    const option = this.option;
    let val = option == null ? option : option[key];
    if (val == null && !ignoreParent) {
      const parentModel = this.parentModel;
      if (parentModel) {
        val = parentModel.getShallow(key);
      }
    }
    return val;
  }
  getModel(path, parentModel) {
    const hasPath = path != null;
    const pathFinal = hasPath ? this.parsePath(path) : null;
    const obj = hasPath ? this._doGet(pathFinal) : this.option;
    parentModel = parentModel || this.parentModel && this.parentModel.getModel(this.resolveParentPath(pathFinal));
    return new Model(obj, parentModel, this.ecModel);
  }
  isEmpty() {
    return this.option == null;
  }
  restoreData() {
  }
  clone() {
    const Ctor = this.constructor;
    return new Ctor(clone(this.option));
  }
  parsePath(path) {
    if (typeof path === "string") {
      return path.split(".");
    }
    return path;
  }
  resolveParentPath(path) {
    return path;
  }
  isAnimationEnabled() {
    if (!env_default.node && this.option) {
      if (this.option.animation != null) {
        return !!this.option.animation;
      } else if (this.parentModel) {
        return this.parentModel.isAnimationEnabled();
      }
    }
  }
  _doGet(pathArr, parentModel) {
    let obj = this.option;
    if (!pathArr) {
      return obj;
    }
    for (let i = 0; i < pathArr.length; i++) {
      if (!pathArr[i]) {
        continue;
      }
      obj = obj && typeof obj === "object" ? obj[pathArr[i]] : null;
      if (obj == null) {
        break;
      }
    }
    if (obj == null && parentModel) {
      obj = parentModel._doGet(this.resolveParentPath(pathArr), parentModel.parentModel);
    }
    return obj;
  }
};
enableClassExtend(Model);
enableClassCheck(Model);
mixin(Model, LineStyleMixin);
mixin(Model, ItemStyleMixin);
mixin(Model, AreaStyleMixin);
mixin(Model, textStyle_default);
var Model_default = Model;

// src/util/component.ts
var base = Math.round(Math.random() * 10);
function getUID(type) {
  return [type || "", base++].join("_");
}
function enableSubTypeDefaulter(target) {
  const subTypeDefaulters = {};
  target.registerSubTypeDefaulter = function(componentType, defaulter) {
    const componentTypeInfo = parseClassType(componentType);
    subTypeDefaulters[componentTypeInfo.main] = defaulter;
  };
  target.determineSubType = function(componentType, option) {
    let type = option.type;
    if (!type) {
      const componentTypeMain = parseClassType(componentType).main;
      if (target.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
        type = subTypeDefaulters[componentTypeMain](option);
      }
    }
    return type;
  };
}
function enableTopologicalTravel(entity, dependencyGetter) {
  entity.topologicalTravel = function(targetNameList, fullNameList, callback, context) {
    if (!targetNameList.length) {
      return;
    }
    const result = makeDepndencyGraph(fullNameList);
    const graph = result.graph;
    const noEntryList = result.noEntryList;
    const targetNameSet = {};
    each(targetNameList, function(name) {
      targetNameSet[name] = true;
    });
    while (noEntryList.length) {
      const currComponentType = noEntryList.pop();
      const currVertex = graph[currComponentType];
      const isInTargetNameSet = !!targetNameSet[currComponentType];
      if (isInTargetNameSet) {
        callback.call(context, currComponentType, currVertex.originalDeps.slice());
        delete targetNameSet[currComponentType];
      }
      each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
    }
    each(targetNameSet, function() {
      let errMsg = "";
      if (true) {
        errMsg = makePrintable("Circular dependency may exists: ", targetNameSet, targetNameList, fullNameList);
      }
      throw new Error(errMsg);
    });
    function removeEdge(succComponentType) {
      graph[succComponentType].entryCount--;
      if (graph[succComponentType].entryCount === 0) {
        noEntryList.push(succComponentType);
      }
    }
    function removeEdgeAndAdd(succComponentType) {
      targetNameSet[succComponentType] = true;
      removeEdge(succComponentType);
    }
  };
  function makeDepndencyGraph(fullNameList) {
    const graph = {};
    const noEntryList = [];
    each(fullNameList, function(name) {
      const thisItem = createDependencyGraphItem(graph, name);
      const originalDeps = thisItem.originalDeps = dependencyGetter(name);
      const availableDeps = getAvailableDependencies(originalDeps, fullNameList);
      thisItem.entryCount = availableDeps.length;
      if (thisItem.entryCount === 0) {
        noEntryList.push(name);
      }
      each(availableDeps, function(dependentName) {
        if (indexOf(thisItem.predecessor, dependentName) < 0) {
          thisItem.predecessor.push(dependentName);
        }
        const thatItem = createDependencyGraphItem(graph, dependentName);
        if (indexOf(thatItem.successor, dependentName) < 0) {
          thatItem.successor.push(name);
        }
      });
    });
    return {graph, noEntryList};
  }
  function createDependencyGraphItem(graph, name) {
    if (!graph[name]) {
      graph[name] = {predecessor: [], successor: []};
    }
    return graph[name];
  }
  function getAvailableDependencies(originalDeps, fullNameList) {
    const availableDeps = [];
    each(originalDeps, function(dep) {
      indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
    });
    return availableDeps;
  }
}
function inheritDefaultOption(superOption, subOption) {
  return merge(merge({}, superOption, true), subOption, true);
}

// src/i18n/langEN.ts
var langEN_default = {
  time: {
    month: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ],
    monthAbbr: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    dayOfWeek: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ],
    dayOfWeekAbbr: [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst",
      custom: "Custom chart",
      chart: "Chart"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
};

// src/i18n/langZH.ts
var langZH_default = {
  time: {
    month: [
      "\u4E00\u6708",
      "\u4E8C\u6708",
      "\u4E09\u6708",
      "\u56DB\u6708",
      "\u4E94\u6708",
      "\u516D\u6708",
      "\u4E03\u6708",
      "\u516B\u6708",
      "\u4E5D\u6708",
      "\u5341\u6708",
      "\u5341\u4E00\u6708",
      "\u5341\u4E8C\u6708"
    ],
    monthAbbr: [
      "1\u6708",
      "2\u6708",
      "3\u6708",
      "4\u6708",
      "5\u6708",
      "6\u6708",
      "7\u6708",
      "8\u6708",
      "9\u6708",
      "10\u6708",
      "11\u6708",
      "12\u6708"
    ],
    dayOfWeek: [
      "\u661F\u671F\u65E5",
      "\u661F\u671F\u4E00",
      "\u661F\u671F\u4E8C",
      "\u661F\u671F\u4E09",
      "\u661F\u671F\u56DB",
      "\u661F\u671F\u4E94",
      "\u661F\u671F\u516D"
    ],
    dayOfWeekAbbr: [
      "\u65E5",
      "\u4E00",
      "\u4E8C",
      "\u4E09",
      "\u56DB",
      "\u4E94",
      "\u516D"
    ]
  },
  legend: {
    selector: {
      all: "\u5168\u9009",
      inverse: "\u53CD\u9009"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "\u77E9\u5F62\u9009\u62E9",
        polygon: "\u5708\u9009",
        lineX: "\u6A2A\u5411\u9009\u62E9",
        lineY: "\u7EB5\u5411\u9009\u62E9",
        keep: "\u4FDD\u6301\u9009\u62E9",
        clear: "\u6E05\u9664\u9009\u62E9"
      }
    },
    dataView: {
      title: "\u6570\u636E\u89C6\u56FE",
      lang: ["\u6570\u636E\u89C6\u56FE", "\u5173\u95ED", "\u5237\u65B0"]
    },
    dataZoom: {
      title: {
        zoom: "\u533A\u57DF\u7F29\u653E",
        back: "\u533A\u57DF\u7F29\u653E\u8FD8\u539F"
      }
    },
    magicType: {
      title: {
        line: "\u5207\u6362\u4E3A\u6298\u7EBF\u56FE",
        bar: "\u5207\u6362\u4E3A\u67F1\u72B6\u56FE",
        stack: "\u5207\u6362\u4E3A\u5806\u53E0",
        tiled: "\u5207\u6362\u4E3A\u5E73\u94FA"
      }
    },
    restore: {
      title: "\u8FD8\u539F"
    },
    saveAsImage: {
      title: "\u4FDD\u5B58\u4E3A\u56FE\u7247",
      lang: ["\u53F3\u952E\u53E6\u5B58\u4E3A\u56FE\u7247"]
    }
  },
  series: {
    typeNames: {
      pie: "\u997C\u56FE",
      bar: "\u67F1\u72B6\u56FE",
      line: "\u6298\u7EBF\u56FE",
      scatter: "\u6563\u70B9\u56FE",
      effectScatter: "\u6D9F\u6F2A\u6563\u70B9\u56FE",
      radar: "\u96F7\u8FBE\u56FE",
      tree: "\u6811\u56FE",
      treemap: "\u77E9\u5F62\u6811\u56FE",
      boxplot: "\u7BB1\u578B\u56FE",
      candlestick: "K\u7EBF\u56FE",
      k: "K\u7EBF\u56FE",
      heatmap: "\u70ED\u529B\u56FE",
      map: "\u5730\u56FE",
      parallel: "\u5E73\u884C\u5750\u6807\u56FE",
      lines: "\u7EBF\u56FE",
      graph: "\u5173\u7CFB\u56FE",
      sankey: "\u6851\u57FA\u56FE",
      funnel: "\u6F0F\u6597\u56FE",
      gauge: "\u4EEA\u8868\u76D8\u56FE",
      pictorialBar: "\u8C61\u5F62\u67F1\u56FE",
      themeRiver: "\u4E3B\u9898\u6CB3\u6D41\u56FE",
      sunburst: "\u65ED\u65E5\u56FE",
      custom: "\u81EA\u5B9A\u4E49\u56FE\u8868",
      chart: "\u56FE\u8868"
    }
  },
  aria: {
    general: {
      withTitle: "\u8FD9\u662F\u4E00\u4E2A\u5173\u4E8E\u201C{title}\u201D\u7684\u56FE\u8868\u3002",
      withoutTitle: "\u8FD9\u662F\u4E00\u4E2A\u56FE\u8868\uFF0C"
    },
    series: {
      single: {
        prefix: "",
        withName: "\u56FE\u8868\u7C7B\u578B\u662F{seriesType}\uFF0C\u8868\u793A{seriesName}\u3002",
        withoutName: "\u56FE\u8868\u7C7B\u578B\u662F{seriesType}\u3002"
      },
      multiple: {
        prefix: "\u5B83\u7531{seriesCount}\u4E2A\u56FE\u8868\u7CFB\u5217\u7EC4\u6210\u3002",
        withName: "\u7B2C{seriesId}\u4E2A\u7CFB\u5217\u662F\u4E00\u4E2A\u8868\u793A{seriesName}\u7684{seriesType}\uFF0C",
        withoutName: "\u7B2C{seriesId}\u4E2A\u7CFB\u5217\u662F\u4E00\u4E2A{seriesType}\uFF0C",
        separator: {
          middle: "\uFF1B",
          end: "\u3002"
        }
      }
    },
    data: {
      allData: "\u5176\u6570\u636E\u662F\u2014\u2014",
      partialData: "\u5176\u4E2D\uFF0C\u524D{displayCnt}\u9879\u662F\u2014\u2014",
      withName: "{name}\u7684\u6570\u636E\u662F{value}",
      withoutName: "{value}",
      separator: {
        middle: "\uFF0C",
        end: ""
      }
    }
  }
};

// src/core/locale.ts
var LOCALE_ZH = "ZH";
var LOCALE_EN = "EN";
var DEFAULT_LOCALE = LOCALE_EN;
var localeStorage = {};
var localeModels = {};
var SYSTEM_LANG = !env_default.domSupported ? DEFAULT_LOCALE : function() {
  const langStr = (document.documentElement.lang || navigator.language || navigator.browserLanguage || DEFAULT_LOCALE).toUpperCase();
  return langStr.indexOf(LOCALE_ZH) > -1 ? LOCALE_ZH : DEFAULT_LOCALE;
}();
function registerLocale(locale, localeObj) {
  locale = locale.toUpperCase();
  localeModels[locale] = new Model_default(localeObj);
  localeStorage[locale] = localeObj;
}
function createLocaleObject(locale) {
  if (isString(locale)) {
    const localeObj = localeStorage[locale.toUpperCase()] || {};
    if (locale === LOCALE_ZH || locale === LOCALE_EN) {
      return clone(localeObj);
    } else {
      return merge(clone(localeObj), clone(localeStorage[DEFAULT_LOCALE]), false);
    }
  } else {
    return merge(clone(locale), clone(localeStorage[DEFAULT_LOCALE]), false);
  }
}
function getLocaleModel(lang) {
  return localeModels[lang];
}
function getDefaultLocaleModel() {
  return localeModels[DEFAULT_LOCALE];
}
registerLocale(LOCALE_EN, langEN_default);
registerLocale(LOCALE_ZH, langZH_default);

// src/util/time.ts
var ONE_SECOND = 1e3;
var ONE_MINUTE = ONE_SECOND * 60;
var ONE_HOUR = ONE_MINUTE * 60;
var ONE_DAY = ONE_HOUR * 24;
var ONE_YEAR = ONE_DAY * 365;
var defaultLeveledFormatter = {
  year: "{yyyy}",
  month: "{MMM}",
  day: "{d}",
  hour: "{HH}:{mm}",
  minute: "{HH}:{mm}",
  second: "{HH}:{mm}:{ss}",
  millisecond: "{HH}:{mm}:{ss} {SSS}",
  none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
};
var fullDayFormatter = "{yyyy}-{MM}-{dd}";
var fullLeveledFormatter = {
  year: "{yyyy}",
  month: "{yyyy}-{MM}",
  day: fullDayFormatter,
  hour: fullDayFormatter + " " + defaultLeveledFormatter.hour,
  minute: fullDayFormatter + " " + defaultLeveledFormatter.minute,
  second: fullDayFormatter + " " + defaultLeveledFormatter.second,
  millisecond: defaultLeveledFormatter.none
};
var primaryTimeUnits = [
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
var timeUnits = [
  "year",
  "half-year",
  "quarter",
  "month",
  "week",
  "half-week",
  "day",
  "half-day",
  "quarter-day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function pad(str, len2) {
  str += "";
  return "0000".substr(0, len2 - str.length) + str;
}
function getPrimaryTimeUnit(timeUnit) {
  switch (timeUnit) {
    case "half-year":
    case "quarter":
      return "month";
    case "week":
    case "half-week":
      return "day";
    case "half-day":
    case "quarter-day":
      return "hour";
    default:
      return timeUnit;
  }
}
function isPrimaryTimeUnit(timeUnit) {
  return timeUnit === getPrimaryTimeUnit(timeUnit);
}
function getDefaultFormatPrecisionOfInterval(timeUnit) {
  switch (timeUnit) {
    case "year":
    case "month":
      return "day";
    case "millisecond":
      return "millisecond";
    default:
      return "second";
  }
}
function format(time, template, isUTC, lang) {
  const date = parseDate(time);
  const y = date[fullYearGetterName(isUTC)]();
  const M = date[monthGetterName(isUTC)]() + 1;
  const q = Math.floor((M - 1) / 3) + 1;
  const d = date[dateGetterName(isUTC)]();
  const e2 = date["get" + (isUTC ? "UTC" : "") + "Day"]();
  const H = date[hoursGetterName(isUTC)]();
  const h = (H - 1) % 12 + 1;
  const m2 = date[minutesGetterName(isUTC)]();
  const s = date[secondsGetterName(isUTC)]();
  const S = date[millisecondsGetterName(isUTC)]();
  const localeModel = lang instanceof Model_default ? lang : getLocaleModel(lang || SYSTEM_LANG) || getDefaultLocaleModel();
  const timeModel = localeModel.getModel("time");
  const month = timeModel.get("month");
  const monthAbbr = timeModel.get("monthAbbr");
  const dayOfWeek = timeModel.get("dayOfWeek");
  const dayOfWeekAbbr = timeModel.get("dayOfWeekAbbr");
  return (template || "").replace(/{yyyy}/g, y + "").replace(/{yy}/g, pad(y % 100 + "", 2)).replace(/{Q}/g, q + "").replace(/{MMMM}/g, month[M - 1]).replace(/{MMM}/g, monthAbbr[M - 1]).replace(/{MM}/g, pad(M, 2)).replace(/{M}/g, M + "").replace(/{dd}/g, pad(d, 2)).replace(/{d}/g, d + "").replace(/{eeee}/g, dayOfWeek[e2]).replace(/{ee}/g, dayOfWeekAbbr[e2]).replace(/{e}/g, e2 + "").replace(/{HH}/g, pad(H, 2)).replace(/{H}/g, H + "").replace(/{hh}/g, pad(h + "", 2)).replace(/{h}/g, h + "").replace(/{mm}/g, pad(m2, 2)).replace(/{m}/g, m2 + "").replace(/{ss}/g, pad(s, 2)).replace(/{s}/g, s + "").replace(/{SSS}/g, pad(S, 3)).replace(/{S}/g, S + "");
}
function leveledFormat(tick, idx, formatter, lang, isUTC) {
  let template = null;
  if (isString(formatter)) {
    template = formatter;
  } else if (isFunction(formatter)) {
    template = formatter(tick.value, idx, {
      level: tick.level
    });
  } else {
    const defaults2 = extend({}, defaultLeveledFormatter);
    if (tick.level > 0) {
      for (let i = 0; i < primaryTimeUnits.length; ++i) {
        defaults2[primaryTimeUnits[i]] = `{primary|${defaults2[primaryTimeUnits[i]]}}`;
      }
    }
    const mergedFormatter = formatter ? formatter.inherit === false ? formatter : defaults(formatter, defaults2) : defaults2;
    const unit = getUnitFromValue(tick.value, isUTC);
    if (mergedFormatter[unit]) {
      template = mergedFormatter[unit];
    } else if (mergedFormatter.inherit) {
      const targetId = timeUnits.indexOf(unit);
      for (let i = targetId - 1; i >= 0; --i) {
        if (mergedFormatter[unit]) {
          template = mergedFormatter[unit];
          break;
        }
      }
      template = template || defaults2.none;
    }
    if (isArray(template)) {
      let levelId = tick.level == null ? 0 : tick.level >= 0 ? tick.level : template.length + tick.level;
      levelId = Math.min(levelId, template.length - 1);
      template = template[levelId];
    }
  }
  return format(new Date(tick.value), template, isUTC, lang);
}
function getUnitFromValue(value, isUTC) {
  const date = parseDate(value);
  const M = date[monthGetterName(isUTC)]() + 1;
  const d = date[dateGetterName(isUTC)]();
  const h = date[hoursGetterName(isUTC)]();
  const m2 = date[minutesGetterName(isUTC)]();
  const s = date[secondsGetterName(isUTC)]();
  const S = date[millisecondsGetterName(isUTC)]();
  const isSecond = S === 0;
  const isMinute = isSecond && s === 0;
  const isHour = isMinute && m2 === 0;
  const isDay = isHour && h === 0;
  const isMonth = isDay && d === 1;
  const isYear = isMonth && M === 1;
  if (isYear) {
    return "year";
  } else if (isMonth) {
    return "month";
  } else if (isDay) {
    return "day";
  } else if (isHour) {
    return "hour";
  } else if (isMinute) {
    return "minute";
  } else if (isSecond) {
    return "second";
  } else {
    return "millisecond";
  }
}
function getUnitValue(value, unit, isUTC) {
  const date = isNumber(value) ? parseDate(value) : value;
  unit = unit || getUnitFromValue(value, isUTC);
  switch (unit) {
    case "year":
      return date[fullYearGetterName(isUTC)]();
    case "half-year":
      return date[monthGetterName(isUTC)]() >= 6 ? 1 : 0;
    case "quarter":
      return Math.floor((date[monthGetterName(isUTC)]() + 1) / 4);
    case "month":
      return date[monthGetterName(isUTC)]();
    case "day":
      return date[dateGetterName(isUTC)]();
    case "half-day":
      return date[hoursGetterName(isUTC)]() / 24;
    case "hour":
      return date[hoursGetterName(isUTC)]();
    case "minute":
      return date[minutesGetterName(isUTC)]();
    case "second":
      return date[secondsGetterName(isUTC)]();
    case "millisecond":
      return date[millisecondsGetterName(isUTC)]();
  }
}
function fullYearGetterName(isUTC) {
  return isUTC ? "getUTCFullYear" : "getFullYear";
}
function monthGetterName(isUTC) {
  return isUTC ? "getUTCMonth" : "getMonth";
}
function dateGetterName(isUTC) {
  return isUTC ? "getUTCDate" : "getDate";
}
function hoursGetterName(isUTC) {
  return isUTC ? "getUTCHours" : "getHours";
}
function minutesGetterName(isUTC) {
  return isUTC ? "getUTCMinutes" : "getMinutes";
}
function secondsGetterName(isUTC) {
  return isUTC ? "getUTCSeconds" : "getSeconds";
}
function millisecondsGetterName(isUTC) {
  return isUTC ? "getUTCMilliseconds" : "getMilliseconds";
}
function fullYearSetterName(isUTC) {
  return isUTC ? "setUTCFullYear" : "setFullYear";
}
function monthSetterName(isUTC) {
  return isUTC ? "setUTCMonth" : "setMonth";
}
function dateSetterName(isUTC) {
  return isUTC ? "setUTCDate" : "setDate";
}
function hoursSetterName(isUTC) {
  return isUTC ? "setUTCHours" : "setHours";
}
function minutesSetterName(isUTC) {
  return isUTC ? "setUTCMinutes" : "setMinutes";
}
function secondsSetterName(isUTC) {
  return isUTC ? "setUTCSeconds" : "setSeconds";
}
function millisecondsSetterName(isUTC) {
  return isUTC ? "setUTCMilliseconds" : "setMilliseconds";
}

// src/legacy/getTextRect.ts
function getTextRect(text, font, align, verticalAlign, padding, rich, truncate, lineHeight) {
  const textEl = new Text_default({
    style: {
      text,
      font,
      align,
      verticalAlign,
      padding,
      rich,
      overflow: truncate ? "truncate" : null,
      lineHeight
    }
  });
  return textEl.getBoundingRect();
}

// src/util/format.ts
function addCommas(x) {
  if (!isNumeric(x)) {
    return isString(x) ? x : "-";
  }
  const parts = (x + "").split(".");
  return parts[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (parts.length > 1 ? "." + parts[1] : "");
}
function toCamelCase(str, upperCaseFirst) {
  str = (str || "").toLowerCase().replace(/-(.)/g, function(match, group1) {
    return group1.toUpperCase();
  });
  if (upperCaseFirst && str) {
    str = str.charAt(0).toUpperCase() + str.slice(1);
  }
  return str;
}
var normalizeCssArray2 = normalizeCssArray;
function makeValueReadable(value, valueType, useUTC) {
  const USER_READABLE_DEFUALT_TIME_PATTERN = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
  function stringToUserReadable(str) {
    return str && trim(str) ? str : "-";
  }
  function isNumberUserReadable(num) {
    return !!(num != null && !isNaN(num) && isFinite(num));
  }
  const isTypeTime = valueType === "time";
  const isValueDate = value instanceof Date;
  if (isTypeTime || isValueDate) {
    const date = isTypeTime ? parseDate(value) : value;
    if (!isNaN(+date)) {
      return format(date, USER_READABLE_DEFUALT_TIME_PATTERN, useUTC);
    } else if (isValueDate) {
      return "-";
    }
  }
  if (valueType === "ordinal") {
    return isStringSafe(value) ? stringToUserReadable(value) : isNumber(value) ? isNumberUserReadable(value) ? value + "" : "-" : "-";
  }
  const numericResult = numericToNumber(value);
  return isNumberUserReadable(numericResult) ? addCommas(numericResult) : isStringSafe(value) ? stringToUserReadable(value) : typeof value === "boolean" ? value + "" : "-";
}
var TPL_VAR_ALIAS = ["a", "b", "c", "d", "e", "f", "g"];
var wrapVar = function(varName, seriesIdx) {
  return "{" + varName + (seriesIdx == null ? "" : seriesIdx) + "}";
};
function formatTpl(tpl, paramsList, encode) {
  if (!isArray(paramsList)) {
    paramsList = [paramsList];
  }
  const seriesLen = paramsList.length;
  if (!seriesLen) {
    return "";
  }
  const $vars = paramsList[0].$vars || [];
  for (let i = 0; i < $vars.length; i++) {
    const alias = TPL_VAR_ALIAS[i];
    tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));
  }
  for (let seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
    for (let k = 0; k < $vars.length; k++) {
      const val = paramsList[seriesIdx][$vars[k]];
      tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val);
    }
  }
  return tpl;
}
function formatTplSimple(tpl, param, encode) {
  each(param, function(value, key) {
    tpl = tpl.replace("{" + key + "}", encode ? encodeHTML(value) : value);
  });
  return tpl;
}
function getTooltipMarker(inOpt, extraCssText) {
  const opt = isString(inOpt) ? {
    color: inOpt,
    extraCssText
  } : inOpt || {};
  const color2 = opt.color;
  const type = opt.type;
  extraCssText = opt.extraCssText;
  const renderMode = opt.renderMode || "html";
  if (!color2) {
    return "";
  }
  if (renderMode === "html") {
    return type === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + encodeHTML(color2) + ";" + (extraCssText || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + encodeHTML(color2) + ";" + (extraCssText || "") + '"></span>';
  } else {
    const markerId = opt.markerId || "markerX";
    return {
      renderMode,
      content: "{" + markerId + "|}  ",
      style: type === "subItem" ? {
        width: 4,
        height: 4,
        borderRadius: 2,
        backgroundColor: color2
      } : {
        width: 10,
        height: 10,
        borderRadius: 5,
        backgroundColor: color2
      }
    };
  }
}
function formatTime(tpl, value, isUTC) {
  if (true) {
    deprecateReplaceLog("echarts.format.formatTime", "echarts.time.format");
  }
  if (tpl === "week" || tpl === "month" || tpl === "quarter" || tpl === "half-year" || tpl === "year") {
    tpl = "MM-dd\nyyyy";
  }
  const date = parseDate(value);
  const getUTC = isUTC ? "getUTC" : "get";
  const y = date[getUTC + "FullYear"]();
  const M = date[getUTC + "Month"]() + 1;
  const d = date[getUTC + "Date"]();
  const h = date[getUTC + "Hours"]();
  const m2 = date[getUTC + "Minutes"]();
  const s = date[getUTC + "Seconds"]();
  const S = date[getUTC + "Milliseconds"]();
  tpl = tpl.replace("MM", pad(M, 2)).replace("M", M).replace("yyyy", y).replace("yy", pad(y % 100 + "", 2)).replace("dd", pad(d, 2)).replace("d", d).replace("hh", pad(h, 2)).replace("h", h).replace("mm", pad(m2, 2)).replace("m", m2).replace("ss", pad(s, 2)).replace("s", s).replace("SSS", pad(S, 3));
  return tpl;
}
function capitalFirst(str) {
  return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
}
function convertToColorString(color2, defaultColor) {
  defaultColor = defaultColor || "transparent";
  return isString(color2) ? color2 : isObject(color2) ? color2.colorStops && (color2.colorStops[0] || {}).color || defaultColor : defaultColor;
}
function windowOpen(link, target) {
  if (target === "_blank" || target === "blank") {
    const blank = window.open();
    blank.opener = null;
    blank.location.href = link;
  } else {
    window.open(link, target);
  }
}

// src/util/layout.ts
var each2 = each;
var LOCATION_PARAMS = [
  "left",
  "right",
  "top",
  "bottom",
  "width",
  "height"
];
var HV_NAMES = [
  ["width", "left", "right"],
  ["height", "top", "bottom"]
];
function boxLayout(orient, group, gap, maxWidth, maxHeight) {
  let x = 0;
  let y = 0;
  if (maxWidth == null) {
    maxWidth = Infinity;
  }
  if (maxHeight == null) {
    maxHeight = Infinity;
  }
  let currentLineMaxSize = 0;
  group.eachChild(function(child, idx) {
    const rect = child.getBoundingRect();
    const nextChild = group.childAt(idx + 1);
    const nextChildRect = nextChild && nextChild.getBoundingRect();
    let nextX;
    let nextY;
    if (orient === "horizontal") {
      const moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
      nextX = x + moveX;
      if (nextX > maxWidth || child.newline) {
        x = 0;
        nextX = moveX;
        y += currentLineMaxSize + gap;
        currentLineMaxSize = rect.height;
      } else {
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
      }
    } else {
      const moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
      nextY = y + moveY;
      if (nextY > maxHeight || child.newline) {
        x += currentLineMaxSize + gap;
        y = 0;
        nextY = moveY;
        currentLineMaxSize = rect.width;
      } else {
        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
      }
    }
    if (child.newline) {
      return;
    }
    child.x = x;
    child.y = y;
    child.markRedraw();
    orient === "horizontal" ? x = nextX + gap : y = nextY + gap;
  });
}
var box = boxLayout;
var vbox = curry(boxLayout, "vertical");
var hbox = curry(boxLayout, "horizontal");
function getAvailableSize(positionInfo, containerRect, margin) {
  const containerWidth = containerRect.width;
  const containerHeight = containerRect.height;
  let x = parsePercent2(positionInfo.left, containerWidth);
  let y = parsePercent2(positionInfo.top, containerHeight);
  let x2 = parsePercent2(positionInfo.right, containerWidth);
  let y2 = parsePercent2(positionInfo.bottom, containerHeight);
  (isNaN(x) || isNaN(parseFloat(positionInfo.left))) && (x = 0);
  (isNaN(x2) || isNaN(parseFloat(positionInfo.right))) && (x2 = containerWidth);
  (isNaN(y) || isNaN(parseFloat(positionInfo.top))) && (y = 0);
  (isNaN(y2) || isNaN(parseFloat(positionInfo.bottom))) && (y2 = containerHeight);
  margin = normalizeCssArray2(margin || 0);
  return {
    width: Math.max(x2 - x - margin[1] - margin[3], 0),
    height: Math.max(y2 - y - margin[0] - margin[2], 0)
  };
}
function getLayoutRect(positionInfo, containerRect, margin) {
  margin = normalizeCssArray2(margin || 0);
  const containerWidth = containerRect.width;
  const containerHeight = containerRect.height;
  let left = parsePercent2(positionInfo.left, containerWidth);
  let top = parsePercent2(positionInfo.top, containerHeight);
  const right = parsePercent2(positionInfo.right, containerWidth);
  const bottom = parsePercent2(positionInfo.bottom, containerHeight);
  let width = parsePercent2(positionInfo.width, containerWidth);
  let height = parsePercent2(positionInfo.height, containerHeight);
  const verticalMargin = margin[2] + margin[0];
  const horizontalMargin = margin[1] + margin[3];
  const aspect = positionInfo.aspect;
  if (isNaN(width)) {
    width = containerWidth - right - horizontalMargin - left;
  }
  if (isNaN(height)) {
    height = containerHeight - bottom - verticalMargin - top;
  }
  if (aspect != null) {
    if (isNaN(width) && isNaN(height)) {
      if (aspect > containerWidth / containerHeight) {
        width = containerWidth * 0.8;
      } else {
        height = containerHeight * 0.8;
      }
    }
    if (isNaN(width)) {
      width = aspect * height;
    }
    if (isNaN(height)) {
      height = width / aspect;
    }
  }
  if (isNaN(left)) {
    left = containerWidth - right - width - horizontalMargin;
  }
  if (isNaN(top)) {
    top = containerHeight - bottom - height - verticalMargin;
  }
  switch (positionInfo.left || positionInfo.right) {
    case "center":
      left = containerWidth / 2 - width / 2 - margin[3];
      break;
    case "right":
      left = containerWidth - width - horizontalMargin;
      break;
  }
  switch (positionInfo.top || positionInfo.bottom) {
    case "middle":
    case "center":
      top = containerHeight / 2 - height / 2 - margin[0];
      break;
    case "bottom":
      top = containerHeight - height - verticalMargin;
      break;
  }
  left = left || 0;
  top = top || 0;
  if (isNaN(width)) {
    width = containerWidth - horizontalMargin - left - (right || 0);
  }
  if (isNaN(height)) {
    height = containerHeight - verticalMargin - top - (bottom || 0);
  }
  const rect = new BoundingRect_default(left + margin[3], top + margin[0], width, height);
  rect.margin = margin;
  return rect;
}
function positionElement(el, positionInfo, containerRect, margin, opt, out2) {
  const h = !opt || !opt.hv || opt.hv[0];
  const v = !opt || !opt.hv || opt.hv[1];
  const boundingMode = opt && opt.boundingMode || "all";
  out2 = out2 || el;
  out2.x = el.x;
  out2.y = el.y;
  if (!h && !v) {
    return false;
  }
  let rect;
  if (boundingMode === "raw") {
    rect = el.type === "group" ? new BoundingRect_default(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();
  } else {
    rect = el.getBoundingRect();
    if (el.needLocalTransform()) {
      const transform2 = el.getLocalTransform();
      rect = rect.clone();
      rect.applyTransform(transform2);
    }
  }
  const layoutRect = getLayoutRect(defaults({width: rect.width, height: rect.height}, positionInfo), containerRect, margin);
  const dx = h ? layoutRect.x - rect.x : 0;
  const dy = v ? layoutRect.y - rect.y : 0;
  if (boundingMode === "raw") {
    out2.x = dx;
    out2.y = dy;
  } else {
    out2.x += dx;
    out2.y += dy;
  }
  if (out2 === el) {
    el.markRedraw();
  }
  return true;
}
function sizeCalculable(option, hvIdx) {
  return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null;
}
function fetchLayoutMode(ins) {
  const layoutMode = ins.layoutMode || ins.constructor.layoutMode;
  return isObject(layoutMode) ? layoutMode : layoutMode ? {type: layoutMode} : null;
}
function mergeLayoutParam(targetOption, newOption, opt) {
  let ignoreSize = opt && opt.ignoreSize;
  !isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);
  const hResult = merge2(HV_NAMES[0], 0);
  const vResult = merge2(HV_NAMES[1], 1);
  copy3(HV_NAMES[0], targetOption, hResult);
  copy3(HV_NAMES[1], targetOption, vResult);
  function merge2(names, hvIdx) {
    const newParams = {};
    let newValueCount = 0;
    const merged = {};
    let mergedValueCount = 0;
    const enoughParamNumber = 2;
    each2(names, function(name) {
      merged[name] = targetOption[name];
    });
    each2(names, function(name) {
      hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);
      hasValue(newParams, name) && newValueCount++;
      hasValue(merged, name) && mergedValueCount++;
    });
    if (ignoreSize[hvIdx]) {
      if (hasValue(newOption, names[1])) {
        merged[names[2]] = null;
      } else if (hasValue(newOption, names[2])) {
        merged[names[1]] = null;
      }
      return merged;
    }
    if (mergedValueCount === enoughParamNumber || !newValueCount) {
      return merged;
    } else if (newValueCount >= enoughParamNumber) {
      return newParams;
    } else {
      for (let i = 0; i < names.length; i++) {
        const name = names[i];
        if (!hasProp(newParams, name) && hasProp(targetOption, name)) {
          newParams[name] = targetOption[name];
          break;
        }
      }
      return newParams;
    }
  }
  function hasProp(obj, name) {
    return obj.hasOwnProperty(name);
  }
  function hasValue(obj, name) {
    return obj[name] != null && obj[name] !== "auto";
  }
  function copy3(names, target, source) {
    each2(names, function(name) {
      target[name] = source[name];
    });
  }
}
function getLayoutParams(source) {
  return copyLayoutParams({}, source);
}
function copyLayoutParams(target, source) {
  source && target && each2(LOCATION_PARAMS, function(name) {
    source.hasOwnProperty(name) && (target[name] = source[name]);
  });
  return target;
}

// src/model/Component.ts
var inner = makeInner();
var ComponentModel2 = class extends Model_default {
  constructor(option, parentModel, ecModel) {
    super(option, parentModel, ecModel);
    this.uid = getUID("ec_cpt_model");
  }
  init(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
  }
  mergeDefaultAndTheme(option, ecModel) {
    const layoutMode = fetchLayoutMode(this);
    const inputPositionParams = layoutMode ? getLayoutParams(option) : {};
    const themeModel = ecModel.getTheme();
    merge(option, themeModel.get(this.mainType));
    merge(option, this.getDefaultOption());
    if (layoutMode) {
      mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  }
  mergeOption(option, ecModel) {
    merge(this.option, option, true);
    const layoutMode = fetchLayoutMode(this);
    if (layoutMode) {
      mergeLayoutParam(this.option, option, layoutMode);
    }
  }
  optionUpdated(newCptOption, isInit) {
  }
  getDefaultOption() {
    const ctor = this.constructor;
    if (!isExtendedClass(ctor)) {
      return ctor.defaultOption;
    }
    const fields = inner(this);
    if (!fields.defaultOption) {
      const optList = [];
      let clz = ctor;
      while (clz) {
        const opt = clz.prototype.defaultOption;
        opt && optList.push(opt);
        clz = clz.superClass;
      }
      let defaultOption3 = {};
      for (let i = optList.length - 1; i >= 0; i--) {
        defaultOption3 = merge(defaultOption3, optList[i], true);
      }
      fields.defaultOption = defaultOption3;
    }
    return fields.defaultOption;
  }
  getReferringComponents(mainType, opt) {
    const indexKey = mainType + "Index";
    const idKey = mainType + "Id";
    return queryReferringComponents(this.ecModel, mainType, {
      index: this.get(indexKey, true),
      id: this.get(idKey, true)
    }, opt);
  }
  getBoxLayoutParams() {
    const boxLayoutModel = this;
    return {
      left: boxLayoutModel.get("left"),
      top: boxLayoutModel.get("top"),
      right: boxLayoutModel.get("right"),
      bottom: boxLayoutModel.get("bottom"),
      width: boxLayoutModel.get("width"),
      height: boxLayoutModel.get("height")
    };
  }
  getZLevelKey() {
    return "";
  }
  setZLevel(zlevel) {
    this.option.zlevel = zlevel;
  }
};
var ComponentModel = ComponentModel2;
ComponentModel.protoInitialize = function() {
  const proto2 = ComponentModel2.prototype;
  proto2.type = "component";
  proto2.id = "";
  proto2.name = "";
  proto2.mainType = "";
  proto2.subType = "";
  proto2.componentIndex = 0;
}();
mountExtend(ComponentModel, Model_default);
enableClassManagement(ComponentModel);
enableSubTypeDefaulter(ComponentModel);
enableTopologicalTravel(ComponentModel, getDependencies);
function getDependencies(componentType) {
  let deps = [];
  each(ComponentModel.getClassesByMainType(componentType), function(clz) {
    deps = deps.concat(clz.dependencies || clz.prototype.dependencies || []);
  });
  deps = map(deps, function(type) {
    return parseClassType(type).main;
  });
  if (componentType !== "dataset" && indexOf(deps, "dataset") <= 0) {
    deps.unshift("dataset");
  }
  return deps;
}
var Component_default = ComponentModel;

// src/model/globalDefault.ts
var platform = "";
if (typeof navigator !== "undefined") {
  platform = navigator.platform || "";
}
var decalColor = "rgba(0, 0, 0, 0.2)";
var globalDefault_default = {
  darkMode: "auto",
  colorBy: "series",
  color: [
    "#5470c6",
    "#91cc75",
    "#fac858",
    "#ee6666",
    "#73c0de",
    "#3ba272",
    "#fc8452",
    "#9a60b4",
    "#ea7ccc"
  ],
  gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
  aria: {
    decal: {
      decals: [{
        color: decalColor,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: decalColor,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: decalColor,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: decalColor,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: decalColor,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: decalColor,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  textStyle: {
    fontFamily: platform.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2e3,
  progressiveThreshold: 3e3,
  progressive: 400,
  hoverLayerThreshold: 3e3,
  useUTC: false
};

// src/util/types.ts
var VISUAL_DIMENSIONS = createHashMap([
  "tooltip",
  "label",
  "itemName",
  "itemId",
  "itemGroupId",
  "itemChildGroupId",
  "seriesName"
]);
var SOURCE_FORMAT_ORIGINAL = "original";
var SOURCE_FORMAT_ARRAY_ROWS = "arrayRows";
var SOURCE_FORMAT_OBJECT_ROWS = "objectRows";
var SOURCE_FORMAT_KEYED_COLUMNS = "keyedColumns";
var SOURCE_FORMAT_TYPED_ARRAY = "typedArray";
var SOURCE_FORMAT_UNKNOWN = "unknown";
var SERIES_LAYOUT_BY_COLUMN = "column";
var SERIES_LAYOUT_BY_ROW = "row";

// src/data/helper/sourceHelper.ts
var BE_ORDINAL = {
  Must: 1,
  Might: 2,
  Not: 3
};
var innerGlobalModel = makeInner();
function resetSourceDefaulter(ecModel) {
  innerGlobalModel(ecModel).datasetMap = createHashMap();
}
function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {
  const encode = {};
  const datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
  if (!datasetModel || !coordDimensions) {
    return encode;
  }
  const encodeItemName = [];
  const encodeSeriesName = [];
  const ecModel = seriesModel.ecModel;
  const datasetMap = innerGlobalModel(ecModel).datasetMap;
  const key = datasetModel.uid + "_" + source.seriesLayoutBy;
  let baseCategoryDimIndex;
  let categoryWayValueDimStart;
  coordDimensions = coordDimensions.slice();
  each(coordDimensions, function(coordDimInfoLoose, coordDimIdx) {
    const coordDimInfo = isObject(coordDimInfoLoose) ? coordDimInfoLoose : coordDimensions[coordDimIdx] = {name: coordDimInfoLoose};
    if (coordDimInfo.type === "ordinal" && baseCategoryDimIndex == null) {
      baseCategoryDimIndex = coordDimIdx;
      categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimInfo);
    }
    encode[coordDimInfo.name] = [];
  });
  const datasetRecord = datasetMap.get(key) || datasetMap.set(key, {categoryWayDim: categoryWayValueDimStart, valueWayDim: 0});
  each(coordDimensions, function(coordDimInfo, coordDimIdx) {
    const coordDimName = coordDimInfo.name;
    const count2 = getDataDimCountOnCoordDim(coordDimInfo);
    if (baseCategoryDimIndex == null) {
      const start2 = datasetRecord.valueWayDim;
      pushDim(encode[coordDimName], start2, count2);
      pushDim(encodeSeriesName, start2, count2);
      datasetRecord.valueWayDim += count2;
    } else if (baseCategoryDimIndex === coordDimIdx) {
      pushDim(encode[coordDimName], 0, count2);
      pushDim(encodeItemName, 0, count2);
    } else {
      const start2 = datasetRecord.categoryWayDim;
      pushDim(encode[coordDimName], start2, count2);
      pushDim(encodeSeriesName, start2, count2);
      datasetRecord.categoryWayDim += count2;
    }
  });
  function pushDim(dimIdxArr, idxFrom, idxCount) {
    for (let i = 0; i < idxCount; i++) {
      dimIdxArr.push(idxFrom + i);
    }
  }
  function getDataDimCountOnCoordDim(coordDimInfo) {
    const dimsDef = coordDimInfo.dimsDef;
    return dimsDef ? dimsDef.length : 1;
  }
  encodeItemName.length && (encode.itemName = encodeItemName);
  encodeSeriesName.length && (encode.seriesName = encodeSeriesName);
  return encode;
}
function makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {
  const encode = {};
  const datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
  if (!datasetModel) {
    return encode;
  }
  const sourceFormat = source.sourceFormat;
  const dimensionsDefine = source.dimensionsDefine;
  let potentialNameDimIndex;
  if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    each(dimensionsDefine, function(dim, idx) {
      if ((isObject(dim) ? dim.name : dim) === "name") {
        potentialNameDimIndex = idx;
      }
    });
  }
  const idxResult = function() {
    const idxRes0 = {};
    const idxRes1 = {};
    const guessRecords = [];
    for (let i = 0, len2 = Math.min(5, dimCount); i < len2; i++) {
      const guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i);
      guessRecords.push(guessResult);
      const isPureNumber = guessResult === BE_ORDINAL.Not;
      if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {
        idxRes0.v = i;
      }
      if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {
        idxRes0.n = i;
      }
      if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {
        return idxRes0;
      }
      if (!isPureNumber) {
        if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {
          idxRes1.v = i;
        }
        if (idxRes1.n == null || idxRes1.n === idxRes1.v) {
          idxRes1.n = i;
        }
      }
    }
    function fulfilled(idxResult2) {
      return idxResult2.v != null && idxResult2.n != null;
    }
    return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;
  }();
  if (idxResult) {
    encode.value = [idxResult.v];
    const nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n;
    encode.itemName = [nameDimIndex];
    encode.seriesName = [nameDimIndex];
  }
  return encode;
}
function querySeriesUpstreamDatasetModel(seriesModel) {
  const thisData = seriesModel.get("data", true);
  if (!thisData) {
    return queryReferringComponents(seriesModel.ecModel, "dataset", {
      index: seriesModel.get("datasetIndex", true),
      id: seriesModel.get("datasetId", true)
    }, SINGLE_REFERRING).models[0];
  }
}
function queryDatasetUpstreamDatasetModels(datasetModel) {
  if (!datasetModel.get("transform", true) && !datasetModel.get("fromTransformResult", true)) {
    return [];
  }
  return queryReferringComponents(datasetModel.ecModel, "dataset", {
    index: datasetModel.get("fromDatasetIndex", true),
    id: datasetModel.get("fromDatasetId", true)
  }, SINGLE_REFERRING).models;
}
function guessOrdinal(source, dimIndex) {
  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);
}
function doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {
  let result;
  const maxLoop = 5;
  if (isTypedArray(data)) {
    return BE_ORDINAL.Not;
  }
  let dimName;
  let dimType;
  if (dimensionsDefine) {
    const dimDefItem = dimensionsDefine[dimIndex];
    if (isObject(dimDefItem)) {
      dimName = dimDefItem.name;
      dimType = dimDefItem.type;
    } else if (isString(dimDefItem)) {
      dimName = dimDefItem;
    }
  }
  if (dimType != null) {
    return dimType === "ordinal" ? BE_ORDINAL.Must : BE_ORDINAL.Not;
  }
  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    const dataArrayRows = data;
    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
      const sample = dataArrayRows[dimIndex];
      for (let i = 0; i < (sample || []).length && i < maxLoop; i++) {
        if ((result = detectValue(sample[startIndex + i])) != null) {
          return result;
        }
      }
    } else {
      for (let i = 0; i < dataArrayRows.length && i < maxLoop; i++) {
        const row = dataArrayRows[startIndex + i];
        if (row && (result = detectValue(row[dimIndex])) != null) {
          return result;
        }
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    const dataObjectRows = data;
    if (!dimName) {
      return BE_ORDINAL.Not;
    }
    for (let i = 0; i < dataObjectRows.length && i < maxLoop; i++) {
      const item = dataObjectRows[i];
      if (item && (result = detectValue(item[dimName])) != null) {
        return result;
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    const dataKeyedColumns = data;
    if (!dimName) {
      return BE_ORDINAL.Not;
    }
    const sample = dataKeyedColumns[dimName];
    if (!sample || isTypedArray(sample)) {
      return BE_ORDINAL.Not;
    }
    for (let i = 0; i < sample.length && i < maxLoop; i++) {
      if ((result = detectValue(sample[i])) != null) {
        return result;
      }
    }
  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    const dataOriginal = data;
    for (let i = 0; i < dataOriginal.length && i < maxLoop; i++) {
      const item = dataOriginal[i];
      const val = getDataItemValue(item);
      if (!isArray(val)) {
        return BE_ORDINAL.Not;
      }
      if ((result = detectValue(val[dimIndex])) != null) {
        return result;
      }
    }
  }
  function detectValue(val) {
    const beStr = isString(val);
    if (val != null && isFinite(val) && val !== "") {
      return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not;
    } else if (beStr && val !== "-") {
      return BE_ORDINAL.Must;
    }
  }
  return BE_ORDINAL.Not;
}

// src/model/internalComponentCreator.ts
var internalOptionCreatorMap = createHashMap();
function registerInternalOptionCreator(mainType, creator) {
  assert(internalOptionCreatorMap.get(mainType) == null && creator);
  internalOptionCreatorMap.set(mainType, creator);
}
function concatInternalOptions(ecModel, mainType, newCmptOptionList) {
  const internalOptionCreator = internalOptionCreatorMap.get(mainType);
  if (!internalOptionCreator) {
    return newCmptOptionList;
  }
  const internalOptions = internalOptionCreator(ecModel);
  if (!internalOptions) {
    return newCmptOptionList;
  }
  if (true) {
    for (let i = 0; i < internalOptions.length; i++) {
      assert(isComponentIdInternal(internalOptions[i]));
    }
  }
  return newCmptOptionList.concat(internalOptions);
}

// src/model/mixin/palette.ts
var innerColor = makeInner();
var innerDecal = makeInner();
var PaletteMixin = class {
  getColorFromPalette(name, scope, requestNum) {
    const defaultPalette = normalizeToArray(this.get("color", true));
    const layeredPalette = this.get("colorLayer", true);
    return getFromPalette(this, innerColor, defaultPalette, layeredPalette, name, scope, requestNum);
  }
  clearColorPalette() {
    clearPalette(this, innerColor);
  }
};
function getDecalFromPalette(ecModel, name, scope, requestNum) {
  const defaultDecals = normalizeToArray(ecModel.get(["aria", "decal", "decals"]));
  return getFromPalette(ecModel, innerDecal, defaultDecals, null, name, scope, requestNum);
}
function getNearestPalette(palettes, requestColorNum) {
  const paletteNum = palettes.length;
  for (let i = 0; i < paletteNum; i++) {
    if (palettes[i].length > requestColorNum) {
      return palettes[i];
    }
  }
  return palettes[paletteNum - 1];
}
function getFromPalette(that, inner23, defaultPalette, layeredPalette, name, scope, requestNum) {
  scope = scope || that;
  const scopeFields = inner23(scope);
  const paletteIdx = scopeFields.paletteIdx || 0;
  const paletteNameMap = scopeFields.paletteNameMap = scopeFields.paletteNameMap || {};
  if (paletteNameMap.hasOwnProperty(name)) {
    return paletteNameMap[name];
  }
  let palette = requestNum == null || !layeredPalette ? defaultPalette : getNearestPalette(layeredPalette, requestNum);
  palette = palette || defaultPalette;
  if (!palette || !palette.length) {
    return;
  }
  const pickedPaletteItem = palette[paletteIdx];
  if (name) {
    paletteNameMap[name] = pickedPaletteItem;
  }
  scopeFields.paletteIdx = (paletteIdx + 1) % palette.length;
  return pickedPaletteItem;
}
function clearPalette(that, inner23) {
  inner23(that).paletteIdx = 0;
  inner23(that).paletteNameMap = {};
}

// src/model/Global.ts
var reCreateSeriesIndices;
var assertSeriesInitialized;
var initBase;
var OPTION_INNER_KEY = "\0_ec_inner";
var OPTION_INNER_VALUE = 1;
var BUITIN_COMPONENTS_MAP = {
  grid: "GridComponent",
  polar: "PolarComponent",
  geo: "GeoComponent",
  singleAxis: "SingleAxisComponent",
  parallel: "ParallelComponent",
  calendar: "CalendarComponent",
  graphic: "GraphicComponent",
  toolbox: "ToolboxComponent",
  tooltip: "TooltipComponent",
  axisPointer: "AxisPointerComponent",
  brush: "BrushComponent",
  title: "TitleComponent",
  timeline: "TimelineComponent",
  markPoint: "MarkPointComponent",
  markLine: "MarkLineComponent",
  markArea: "MarkAreaComponent",
  legend: "LegendComponent",
  dataZoom: "DataZoomComponent",
  visualMap: "VisualMapComponent",
  xAxis: "GridComponent",
  yAxis: "GridComponent",
  angleAxis: "PolarComponent",
  radiusAxis: "PolarComponent"
};
var BUILTIN_CHARTS_MAP = {
  line: "LineChart",
  bar: "BarChart",
  pie: "PieChart",
  scatter: "ScatterChart",
  radar: "RadarChart",
  map: "MapChart",
  tree: "TreeChart",
  treemap: "TreemapChart",
  graph: "GraphChart",
  gauge: "GaugeChart",
  funnel: "FunnelChart",
  parallel: "ParallelChart",
  sankey: "SankeyChart",
  boxplot: "BoxplotChart",
  candlestick: "CandlestickChart",
  effectScatter: "EffectScatterChart",
  lines: "LinesChart",
  heatmap: "HeatmapChart",
  pictorialBar: "PictorialBarChart",
  themeRiver: "ThemeRiverChart",
  sunburst: "SunburstChart",
  custom: "CustomChart"
};
var componetsMissingLogPrinted = {};
function checkMissingComponents(option) {
  each(option, function(componentOption, mainType) {
    if (!Component_default.hasClass(mainType)) {
      const componentImportName = BUITIN_COMPONENTS_MAP[mainType];
      if (componentImportName && !componetsMissingLogPrinted[componentImportName]) {
        error(`Component ${mainType} is used but not imported.
import { ${componentImportName} } from 'echarts/components';
echarts.use([${componentImportName}]);`);
        componetsMissingLogPrinted[componentImportName] = true;
      }
    }
  });
}
var GlobalModel = class extends Model_default {
  init(option, parentModel, ecModel, theme2, locale, optionManager) {
    theme2 = theme2 || {};
    this.option = null;
    this._theme = new Model_default(theme2);
    this._locale = new Model_default(locale);
    this._optionManager = optionManager;
  }
  setOption(option, opts, optionPreprocessorFuncs2) {
    if (true) {
      assert(option != null, "option is null/undefined");
      assert(option[OPTION_INNER_KEY] !== OPTION_INNER_VALUE, "please use chart.getOption()");
    }
    const innerOpt = normalizeSetOptionInput(opts);
    this._optionManager.setOption(option, optionPreprocessorFuncs2, innerOpt);
    this._resetOption(null, innerOpt);
  }
  resetOption(type, opt) {
    return this._resetOption(type, normalizeSetOptionInput(opt));
  }
  _resetOption(type, opt) {
    let optionChanged = false;
    const optionManager = this._optionManager;
    if (!type || type === "recreate") {
      const baseOption = optionManager.mountOption(type === "recreate");
      if (true) {
        checkMissingComponents(baseOption);
      }
      if (!this.option || type === "recreate") {
        initBase(this, baseOption);
      } else {
        this.restoreData();
        this._mergeOption(baseOption, opt);
      }
      optionChanged = true;
    }
    if (type === "timeline" || type === "media") {
      this.restoreData();
    }
    if (!type || type === "recreate" || type === "timeline") {
      const timelineOption = optionManager.getTimelineOption(this);
      if (timelineOption) {
        optionChanged = true;
        this._mergeOption(timelineOption, opt);
      }
    }
    if (!type || type === "recreate" || type === "media") {
      const mediaOptions = optionManager.getMediaOption(this);
      if (mediaOptions.length) {
        each(mediaOptions, function(mediaOption) {
          optionChanged = true;
          this._mergeOption(mediaOption, opt);
        }, this);
      }
    }
    return optionChanged;
  }
  mergeOption(option) {
    this._mergeOption(option, null);
  }
  _mergeOption(newOption, opt) {
    const option = this.option;
    const componentsMap = this._componentsMap;
    const componentsCount = this._componentsCount;
    const newCmptTypes = [];
    const newCmptTypeMap = createHashMap();
    const replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap;
    resetSourceDefaulter(this);
    each(newOption, function(componentOption, mainType) {
      if (componentOption == null) {
        return;
      }
      if (!Component_default.hasClass(mainType)) {
        option[mainType] = option[mainType] == null ? clone(componentOption) : merge(option[mainType], componentOption, true);
      } else if (mainType) {
        newCmptTypes.push(mainType);
        newCmptTypeMap.set(mainType, true);
      }
    });
    if (replaceMergeMainTypeMap) {
      replaceMergeMainTypeMap.each(function(val, mainTypeInReplaceMerge) {
        if (Component_default.hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {
          newCmptTypes.push(mainTypeInReplaceMerge);
          newCmptTypeMap.set(mainTypeInReplaceMerge, true);
        }
      });
    }
    Component_default.topologicalTravel(newCmptTypes, Component_default.getAllClassMainTypes(), visitComponent, this);
    function visitComponent(mainType) {
      const newCmptOptionList = concatInternalOptions(this, mainType, normalizeToArray(newOption[mainType]));
      const oldCmptList = componentsMap.get(mainType);
      const mergeMode = !oldCmptList ? "replaceAll" : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? "replaceMerge" : "normalMerge";
      const mappingResult = mappingToExists(oldCmptList, newCmptOptionList, mergeMode);
      setComponentTypeToKeyInfo(mappingResult, mainType, Component_default);
      option[mainType] = null;
      componentsMap.set(mainType, null);
      componentsCount.set(mainType, 0);
      const optionsByMainType = [];
      const cmptsByMainType = [];
      let cmptsCountByMainType = 0;
      let tooltipExists;
      let tooltipWarningLogged;
      each(mappingResult, function(resultItem, index) {
        let componentModel = resultItem.existing;
        const newCmptOption = resultItem.newOption;
        if (!newCmptOption) {
          if (componentModel) {
            componentModel.mergeOption({}, this);
            componentModel.optionUpdated({}, false);
          }
        } else {
          const isSeriesType = mainType === "series";
          const ComponentModelClass = Component_default.getClass(mainType, resultItem.keyInfo.subType, !isSeriesType);
          if (!ComponentModelClass) {
            if (true) {
              const subType = resultItem.keyInfo.subType;
              const seriesImportName = BUILTIN_CHARTS_MAP[subType];
              if (!componetsMissingLogPrinted[subType]) {
                componetsMissingLogPrinted[subType] = true;
                if (seriesImportName) {
                  error(`Series ${subType} is used but not imported.
import { ${seriesImportName} } from 'echarts/charts';
echarts.use([${seriesImportName}]);`);
                } else {
                  error(`Unknown series ${subType}`);
                }
              }
            }
            return;
          }
          if (mainType === "tooltip") {
            if (tooltipExists) {
              if (true) {
                if (!tooltipWarningLogged) {
                  warn("Currently only one tooltip component is allowed.");
                  tooltipWarningLogged = true;
                }
              }
              return;
            }
            tooltipExists = true;
          }
          if (componentModel && componentModel.constructor === ComponentModelClass) {
            componentModel.name = resultItem.keyInfo.name;
            componentModel.mergeOption(newCmptOption, this);
            componentModel.optionUpdated(newCmptOption, false);
          } else {
            const extraOpt = extend({
              componentIndex: index
            }, resultItem.keyInfo);
            componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt);
            extend(componentModel, extraOpt);
            if (resultItem.brandNew) {
              componentModel.__requireNewView = true;
            }
            componentModel.init(newCmptOption, this, this);
            componentModel.optionUpdated(null, true);
          }
        }
        if (componentModel) {
          optionsByMainType.push(componentModel.option);
          cmptsByMainType.push(componentModel);
          cmptsCountByMainType++;
        } else {
          optionsByMainType.push(void 0);
          cmptsByMainType.push(void 0);
        }
      }, this);
      option[mainType] = optionsByMainType;
      componentsMap.set(mainType, cmptsByMainType);
      componentsCount.set(mainType, cmptsCountByMainType);
      if (mainType === "series") {
        reCreateSeriesIndices(this);
      }
    }
    if (!this._seriesIndices) {
      reCreateSeriesIndices(this);
    }
  }
  getOption() {
    const option = clone(this.option);
    each(option, function(optInMainType, mainType) {
      if (Component_default.hasClass(mainType)) {
        const opts = normalizeToArray(optInMainType);
        let realLen = opts.length;
        let metNonInner = false;
        for (let i = realLen - 1; i >= 0; i--) {
          if (opts[i] && !isComponentIdInternal(opts[i])) {
            metNonInner = true;
          } else {
            opts[i] = null;
            !metNonInner && realLen--;
          }
        }
        opts.length = realLen;
        option[mainType] = opts;
      }
    });
    delete option[OPTION_INNER_KEY];
    return option;
  }
  getTheme() {
    return this._theme;
  }
  getLocaleModel() {
    return this._locale;
  }
  setUpdatePayload(payload) {
    this._payload = payload;
  }
  getUpdatePayload() {
    return this._payload;
  }
  getComponent(mainType, idx) {
    const list = this._componentsMap.get(mainType);
    if (list) {
      const cmpt = list[idx || 0];
      if (cmpt) {
        return cmpt;
      } else if (idx == null) {
        for (let i = 0; i < list.length; i++) {
          if (list[i]) {
            return list[i];
          }
        }
      }
    }
  }
  queryComponents(condition) {
    const mainType = condition.mainType;
    if (!mainType) {
      return [];
    }
    const index = condition.index;
    const id = condition.id;
    const name = condition.name;
    const cmpts = this._componentsMap.get(mainType);
    if (!cmpts || !cmpts.length) {
      return [];
    }
    let result;
    if (index != null) {
      result = [];
      each(normalizeToArray(index), function(idx) {
        cmpts[idx] && result.push(cmpts[idx]);
      });
    } else if (id != null) {
      result = queryByIdOrName("id", id, cmpts);
    } else if (name != null) {
      result = queryByIdOrName("name", name, cmpts);
    } else {
      result = filter(cmpts, (cmpt) => !!cmpt);
    }
    return filterBySubType(result, condition);
  }
  findComponents(condition) {
    const query = condition.query;
    const mainType = condition.mainType;
    const queryCond = getQueryCond(query);
    const result = queryCond ? this.queryComponents(queryCond) : filter(this._componentsMap.get(mainType), (cmpt) => !!cmpt);
    return doFilter(filterBySubType(result, condition));
    function getQueryCond(q) {
      const indexAttr = mainType + "Index";
      const idAttr = mainType + "Id";
      const nameAttr = mainType + "Name";
      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {
        mainType,
        index: q[indexAttr],
        id: q[idAttr],
        name: q[nameAttr]
      } : null;
    }
    function doFilter(res) {
      return condition.filter ? filter(res, condition.filter) : res;
    }
  }
  eachComponent(mainType, cb, context) {
    const componentsMap = this._componentsMap;
    if (isFunction(mainType)) {
      const ctxForAll = cb;
      const cbForAll = mainType;
      componentsMap.each(function(cmpts, componentType) {
        for (let i = 0; cmpts && i < cmpts.length; i++) {
          const cmpt = cmpts[i];
          cmpt && cbForAll.call(ctxForAll, componentType, cmpt, cmpt.componentIndex);
        }
      });
    } else {
      const cmpts = isString(mainType) ? componentsMap.get(mainType) : isObject(mainType) ? this.findComponents(mainType) : null;
      for (let i = 0; cmpts && i < cmpts.length; i++) {
        const cmpt = cmpts[i];
        cmpt && cb.call(context, cmpt, cmpt.componentIndex);
      }
    }
  }
  getSeriesByName(name) {
    const nameStr = convertOptionIdName(name, null);
    return filter(this._componentsMap.get("series"), (oneSeries) => !!oneSeries && nameStr != null && oneSeries.name === nameStr);
  }
  getSeriesByIndex(seriesIndex) {
    return this._componentsMap.get("series")[seriesIndex];
  }
  getSeriesByType(subType) {
    return filter(this._componentsMap.get("series"), (oneSeries) => !!oneSeries && oneSeries.subType === subType);
  }
  getSeries() {
    return filter(this._componentsMap.get("series"), (oneSeries) => !!oneSeries);
  }
  getSeriesCount() {
    return this._componentsCount.get("series");
  }
  eachSeries(cb, context) {
    assertSeriesInitialized(this);
    each(this._seriesIndices, function(rawSeriesIndex) {
      const series = this._componentsMap.get("series")[rawSeriesIndex];
      cb.call(context, series, rawSeriesIndex);
    }, this);
  }
  eachRawSeries(cb, context) {
    each(this._componentsMap.get("series"), function(series) {
      series && cb.call(context, series, series.componentIndex);
    });
  }
  eachSeriesByType(subType, cb, context) {
    assertSeriesInitialized(this);
    each(this._seriesIndices, function(rawSeriesIndex) {
      const series = this._componentsMap.get("series")[rawSeriesIndex];
      if (series.subType === subType) {
        cb.call(context, series, rawSeriesIndex);
      }
    }, this);
  }
  eachRawSeriesByType(subType, cb, context) {
    return each(this.getSeriesByType(subType), cb, context);
  }
  isSeriesFiltered(seriesModel) {
    assertSeriesInitialized(this);
    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;
  }
  getCurrentSeriesIndices() {
    return (this._seriesIndices || []).slice();
  }
  filterSeries(cb, context) {
    assertSeriesInitialized(this);
    const newSeriesIndices = [];
    each(this._seriesIndices, function(seriesRawIdx) {
      const series = this._componentsMap.get("series")[seriesRawIdx];
      cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx);
    }, this);
    this._seriesIndices = newSeriesIndices;
    this._seriesIndicesMap = createHashMap(newSeriesIndices);
  }
  restoreData(payload) {
    reCreateSeriesIndices(this);
    const componentsMap = this._componentsMap;
    const componentTypes = [];
    componentsMap.each(function(components, componentType) {
      if (Component_default.hasClass(componentType)) {
        componentTypes.push(componentType);
      }
    });
    Component_default.topologicalTravel(componentTypes, Component_default.getAllClassMainTypes(), function(componentType) {
      each(componentsMap.get(componentType), function(component) {
        if (component && (componentType !== "series" || !isNotTargetSeries(component, payload))) {
          component.restoreData();
        }
      });
    });
  }
};
GlobalModel.internalField = function() {
  reCreateSeriesIndices = function(ecModel) {
    const seriesIndices = ecModel._seriesIndices = [];
    each(ecModel._componentsMap.get("series"), function(series) {
      series && seriesIndices.push(series.componentIndex);
    });
    ecModel._seriesIndicesMap = createHashMap(seriesIndices);
  };
  assertSeriesInitialized = function(ecModel) {
    if (true) {
      if (!ecModel._seriesIndices) {
        throw new Error("Option should contains series.");
      }
    }
  };
  initBase = function(ecModel, baseOption) {
    ecModel.option = {};
    ecModel.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE;
    ecModel._componentsMap = createHashMap({series: []});
    ecModel._componentsCount = createHashMap();
    const airaOption = baseOption.aria;
    if (isObject(airaOption) && airaOption.enabled == null) {
      airaOption.enabled = true;
    }
    mergeTheme(baseOption, ecModel._theme.option);
    merge(baseOption, globalDefault_default, false);
    ecModel._mergeOption(baseOption, null);
  };
}();
function isNotTargetSeries(seriesModel, payload) {
  if (payload) {
    const index = payload.seriesIndex;
    const id = payload.seriesId;
    const name = payload.seriesName;
    return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name != null && seriesModel.name !== name;
  }
}
function mergeTheme(option, theme2) {
  const notMergeColorLayer = option.color && !option.colorLayer;
  each(theme2, function(themeItem, name) {
    if (name === "colorLayer" && notMergeColorLayer) {
      return;
    }
    if (!Component_default.hasClass(name)) {
      if (typeof themeItem === "object") {
        option[name] = !option[name] ? clone(themeItem) : merge(option[name], themeItem, false);
      } else {
        if (option[name] == null) {
          option[name] = themeItem;
        }
      }
    }
  });
}
function queryByIdOrName(attr, idOrName, cmpts) {
  if (isArray(idOrName)) {
    const keyMap = createHashMap();
    each(idOrName, function(idOrNameItem) {
      if (idOrNameItem != null) {
        const idName = convertOptionIdName(idOrNameItem, null);
        idName != null && keyMap.set(idOrNameItem, true);
      }
    });
    return filter(cmpts, (cmpt) => cmpt && keyMap.get(cmpt[attr]));
  } else {
    const idName = convertOptionIdName(idOrName, null);
    return filter(cmpts, (cmpt) => cmpt && idName != null && cmpt[attr] === idName);
  }
}
function filterBySubType(components, condition) {
  return condition.hasOwnProperty("subType") ? filter(components, (cmpt) => cmpt && cmpt.subType === condition.subType) : components;
}
function normalizeSetOptionInput(opts) {
  const replaceMergeMainTypeMap = createHashMap();
  opts && each(normalizeToArray(opts.replaceMerge), function(mainType) {
    if (true) {
      assert(Component_default.hasClass(mainType), '"' + mainType + '" is not valid component main type in "replaceMerge"');
    }
    replaceMergeMainTypeMap.set(mainType, true);
  });
  return {
    replaceMergeMainTypeMap
  };
}
mixin(GlobalModel, PaletteMixin);
var Global_default = GlobalModel;

// src/core/ExtensionAPI.ts
var availableMethods = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  "getOption",
  "getId",
  "updateLabelLayout"
];
var ExtensionAPI = class {
  constructor(ecInstance) {
    each(availableMethods, function(methodName) {
      this[methodName] = bind(ecInstance[methodName], ecInstance);
    }, this);
  }
};
var ExtensionAPI_default = ExtensionAPI;

// src/core/CoordinateSystem.ts
var coordinateSystemCreators = {};
var CoordinateSystemManager = class {
  constructor() {
    this._coordinateSystems = [];
  }
  create(ecModel, api2) {
    let coordinateSystems = [];
    each(coordinateSystemCreators, function(creator, type) {
      const list = creator.create(ecModel, api2);
      coordinateSystems = coordinateSystems.concat(list || []);
    });
    this._coordinateSystems = coordinateSystems;
  }
  update(ecModel, api2) {
    each(this._coordinateSystems, function(coordSys) {
      coordSys.update && coordSys.update(ecModel, api2);
    });
  }
  getCoordinateSystems() {
    return this._coordinateSystems.slice();
  }
};
CoordinateSystemManager.register = function(type, creator) {
  coordinateSystemCreators[type] = creator;
};
CoordinateSystemManager.get = function(type) {
  return coordinateSystemCreators[type];
};
var CoordinateSystem_default = CoordinateSystemManager;

// src/model/OptionManager.ts
var QUERY_REG = /^(min|max)?(.+)$/;
var OptionManager = class {
  constructor(api2) {
    this._timelineOptions = [];
    this._mediaList = [];
    this._currentMediaIndices = [];
    this._api = api2;
  }
  setOption(rawOption, optionPreprocessorFuncs2, opt) {
    if (rawOption) {
      each(normalizeToArray(rawOption.series), function(series) {
        series && series.data && isTypedArray(series.data) && setAsPrimitive(series.data);
      });
      each(normalizeToArray(rawOption.dataset), function(dataset) {
        dataset && dataset.source && isTypedArray(dataset.source) && setAsPrimitive(dataset.source);
      });
    }
    rawOption = clone(rawOption);
    const optionBackup = this._optionBackup;
    const newParsedOption = parseRawOption(rawOption, optionPreprocessorFuncs2, !optionBackup);
    this._newBaseOption = newParsedOption.baseOption;
    if (optionBackup) {
      if (newParsedOption.timelineOptions.length) {
        optionBackup.timelineOptions = newParsedOption.timelineOptions;
      }
      if (newParsedOption.mediaList.length) {
        optionBackup.mediaList = newParsedOption.mediaList;
      }
      if (newParsedOption.mediaDefault) {
        optionBackup.mediaDefault = newParsedOption.mediaDefault;
      }
    } else {
      this._optionBackup = newParsedOption;
    }
  }
  mountOption(isRecreate) {
    const optionBackup = this._optionBackup;
    this._timelineOptions = optionBackup.timelineOptions;
    this._mediaList = optionBackup.mediaList;
    this._mediaDefault = optionBackup.mediaDefault;
    this._currentMediaIndices = [];
    return clone(isRecreate ? optionBackup.baseOption : this._newBaseOption);
  }
  getTimelineOption(ecModel) {
    let option;
    const timelineOptions = this._timelineOptions;
    if (timelineOptions.length) {
      const timelineModel = ecModel.getComponent("timeline");
      if (timelineModel) {
        option = clone(timelineOptions[timelineModel.getCurrentIndex()]);
      }
    }
    return option;
  }
  getMediaOption(ecModel) {
    const ecWidth = this._api.getWidth();
    const ecHeight = this._api.getHeight();
    const mediaList = this._mediaList;
    const mediaDefault = this._mediaDefault;
    let indices = [];
    let result = [];
    if (!mediaList.length && !mediaDefault) {
      return result;
    }
    for (let i = 0, len2 = mediaList.length; i < len2; i++) {
      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
        indices.push(i);
      }
    }
    if (!indices.length && mediaDefault) {
      indices = [-1];
    }
    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
      result = map(indices, function(index) {
        return clone(index === -1 ? mediaDefault.option : mediaList[index].option);
      });
    }
    this._currentMediaIndices = indices;
    return result;
  }
};
function parseRawOption(rawOption, optionPreprocessorFuncs2, isNew) {
  const mediaList = [];
  let mediaDefault;
  let baseOption;
  const declaredBaseOption = rawOption.baseOption;
  const timelineOnRoot = rawOption.timeline;
  const timelineOptionsOnRoot = rawOption.options;
  const mediaOnRoot = rawOption.media;
  const hasMedia = !!rawOption.media;
  const hasTimeline = !!(timelineOptionsOnRoot || timelineOnRoot || declaredBaseOption && declaredBaseOption.timeline);
  if (declaredBaseOption) {
    baseOption = declaredBaseOption;
    if (!baseOption.timeline) {
      baseOption.timeline = timelineOnRoot;
    }
  } else {
    if (hasTimeline || hasMedia) {
      rawOption.options = rawOption.media = null;
    }
    baseOption = rawOption;
  }
  if (hasMedia) {
    if (isArray(mediaOnRoot)) {
      each(mediaOnRoot, function(singleMedia) {
        if (true) {
          if (singleMedia && !singleMedia.option && isObject(singleMedia.query) && isObject(singleMedia.query.option)) {
            error("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }");
          }
        }
        if (singleMedia && singleMedia.option) {
          if (singleMedia.query) {
            mediaList.push(singleMedia);
          } else if (!mediaDefault) {
            mediaDefault = singleMedia;
          }
        }
      });
    } else {
      if (true) {
        error("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }");
      }
    }
  }
  doPreprocess(baseOption);
  each(timelineOptionsOnRoot, (option) => doPreprocess(option));
  each(mediaList, (media) => doPreprocess(media.option));
  function doPreprocess(option) {
    each(optionPreprocessorFuncs2, function(preProcess) {
      preProcess(option, isNew);
    });
  }
  return {
    baseOption,
    timelineOptions: timelineOptionsOnRoot || [],
    mediaDefault,
    mediaList
  };
}
function applyMediaQuery(query, ecWidth, ecHeight) {
  const realMap = {
    width: ecWidth,
    height: ecHeight,
    aspectratio: ecWidth / ecHeight
  };
  let applicable = true;
  each(query, function(value, attr) {
    const matched = attr.match(QUERY_REG);
    if (!matched || !matched[1] || !matched[2]) {
      return;
    }
    const operator = matched[1];
    const realAttr = matched[2].toLowerCase();
    if (!compare(realMap[realAttr], value, operator)) {
      applicable = false;
    }
  });
  return applicable;
}
function compare(real, expect, operator) {
  if (operator === "min") {
    return real >= expect;
  } else if (operator === "max") {
    return real <= expect;
  } else {
    return real === expect;
  }
}
function indicesEquals(indices1, indices2) {
  return indices1.join(",") === indices2.join(",");
}
var OptionManager_default = OptionManager;

// src/preprocessor/helper/compatStyle.ts
var each3 = each;
var isObject2 = isObject;
var POSSIBLE_STYLES = [
  "areaStyle",
  "lineStyle",
  "nodeStyle",
  "linkStyle",
  "chordStyle",
  "label",
  "labelLine"
];
function compatEC2ItemStyle(opt) {
  const itemStyleOpt = opt && opt.itemStyle;
  if (!itemStyleOpt) {
    return;
  }
  for (let i = 0, len2 = POSSIBLE_STYLES.length; i < len2; i++) {
    const styleName = POSSIBLE_STYLES[i];
    const normalItemStyleOpt = itemStyleOpt.normal;
    const emphasisItemStyleOpt = itemStyleOpt.emphasis;
    if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
      if (true) {
        deprecateReplaceLog(`itemStyle.normal.${styleName}`, styleName);
      }
      opt[styleName] = opt[styleName] || {};
      if (!opt[styleName].normal) {
        opt[styleName].normal = normalItemStyleOpt[styleName];
      } else {
        merge(opt[styleName].normal, normalItemStyleOpt[styleName]);
      }
      normalItemStyleOpt[styleName] = null;
    }
    if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
      if (true) {
        deprecateReplaceLog(`itemStyle.emphasis.${styleName}`, `emphasis.${styleName}`);
      }
      opt[styleName] = opt[styleName] || {};
      if (!opt[styleName].emphasis) {
        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
      } else {
        merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
      }
      emphasisItemStyleOpt[styleName] = null;
    }
  }
}
function convertNormalEmphasis(opt, optType, useExtend) {
  if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {
    const normalOpt = opt[optType].normal;
    const emphasisOpt = opt[optType].emphasis;
    if (normalOpt) {
      if (true) {
        deprecateLog(`'normal' hierarchy in ${optType} has been removed since 4.0. All style properties are configured in ${optType} directly now.`);
      }
      if (useExtend) {
        opt[optType].normal = opt[optType].emphasis = null;
        defaults(opt[optType], normalOpt);
      } else {
        opt[optType] = normalOpt;
      }
    }
    if (emphasisOpt) {
      if (true) {
        deprecateLog(`${optType}.emphasis has been changed to emphasis.${optType} since 4.0`);
      }
      opt.emphasis = opt.emphasis || {};
      opt.emphasis[optType] = emphasisOpt;
      if (emphasisOpt.focus) {
        opt.emphasis.focus = emphasisOpt.focus;
      }
      if (emphasisOpt.blurScope) {
        opt.emphasis.blurScope = emphasisOpt.blurScope;
      }
    }
  }
}
function removeEC3NormalStatus(opt) {
  convertNormalEmphasis(opt, "itemStyle");
  convertNormalEmphasis(opt, "lineStyle");
  convertNormalEmphasis(opt, "areaStyle");
  convertNormalEmphasis(opt, "label");
  convertNormalEmphasis(opt, "labelLine");
  convertNormalEmphasis(opt, "upperLabel");
  convertNormalEmphasis(opt, "edgeLabel");
}
function compatTextStyle(opt, propName) {
  const labelOptSingle = isObject2(opt) && opt[propName];
  const textStyle = isObject2(labelOptSingle) && labelOptSingle.textStyle;
  if (textStyle) {
    if (true) {
      deprecateLog(`textStyle hierarchy in ${propName} has been removed since 4.0. All textStyle properties are configured in ${propName} directly now.`);
    }
    for (let i = 0, len2 = TEXT_STYLE_OPTIONS.length; i < len2; i++) {
      const textPropName = TEXT_STYLE_OPTIONS[i];
      if (textStyle.hasOwnProperty(textPropName)) {
        labelOptSingle[textPropName] = textStyle[textPropName];
      }
    }
  }
}
function compatEC3CommonStyles(opt) {
  if (opt) {
    removeEC3NormalStatus(opt);
    compatTextStyle(opt, "label");
    opt.emphasis && compatTextStyle(opt.emphasis, "label");
  }
}
function processSeries(seriesOpt) {
  if (!isObject2(seriesOpt)) {
    return;
  }
  compatEC2ItemStyle(seriesOpt);
  removeEC3NormalStatus(seriesOpt);
  compatTextStyle(seriesOpt, "label");
  compatTextStyle(seriesOpt, "upperLabel");
  compatTextStyle(seriesOpt, "edgeLabel");
  if (seriesOpt.emphasis) {
    compatTextStyle(seriesOpt.emphasis, "label");
    compatTextStyle(seriesOpt.emphasis, "upperLabel");
    compatTextStyle(seriesOpt.emphasis, "edgeLabel");
  }
  let markPoint = seriesOpt.markPoint;
  if (markPoint) {
    compatEC2ItemStyle(markPoint);
    compatEC3CommonStyles(markPoint);
  }
  let markLine = seriesOpt.markLine;
  if (markLine) {
    compatEC2ItemStyle(markLine);
    compatEC3CommonStyles(markLine);
  }
  const markArea = seriesOpt.markArea;
  if (markArea) {
    compatEC3CommonStyles(markArea);
  }
  let data = seriesOpt.data;
  if (seriesOpt.type === "graph") {
    data = data || seriesOpt.nodes;
    const edgeData = seriesOpt.links || seriesOpt.edges;
    if (edgeData && !isTypedArray(edgeData)) {
      for (let i = 0; i < edgeData.length; i++) {
        compatEC3CommonStyles(edgeData[i]);
      }
    }
    each(seriesOpt.categories, function(opt) {
      removeEC3NormalStatus(opt);
    });
  }
  if (data && !isTypedArray(data)) {
    for (let i = 0; i < data.length; i++) {
      compatEC3CommonStyles(data[i]);
    }
  }
  markPoint = seriesOpt.markPoint;
  if (markPoint && markPoint.data) {
    const mpData = markPoint.data;
    for (let i = 0; i < mpData.length; i++) {
      compatEC3CommonStyles(mpData[i]);
    }
  }
  markLine = seriesOpt.markLine;
  if (markLine && markLine.data) {
    const mlData = markLine.data;
    for (let i = 0; i < mlData.length; i++) {
      if (isArray(mlData[i])) {
        compatEC3CommonStyles(mlData[i][0]);
        compatEC3CommonStyles(mlData[i][1]);
      } else {
        compatEC3CommonStyles(mlData[i]);
      }
    }
  }
  if (seriesOpt.type === "gauge") {
    compatTextStyle(seriesOpt, "axisLabel");
    compatTextStyle(seriesOpt, "title");
    compatTextStyle(seriesOpt, "detail");
  } else if (seriesOpt.type === "treemap") {
    convertNormalEmphasis(seriesOpt.breadcrumb, "itemStyle");
    each(seriesOpt.levels, function(opt) {
      removeEC3NormalStatus(opt);
    });
  } else if (seriesOpt.type === "tree") {
    removeEC3NormalStatus(seriesOpt.leaves);
  }
}
function toArr(o) {
  return isArray(o) ? o : o ? [o] : [];
}
function toObj(o) {
  return (isArray(o) ? o[0] : o) || {};
}
function globalCompatStyle(option, isTheme) {
  each3(toArr(option.series), function(seriesOpt) {
    isObject2(seriesOpt) && processSeries(seriesOpt);
  });
  const axes = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  isTheme && axes.push("valueAxis", "categoryAxis", "logAxis", "timeAxis");
  each3(axes, function(axisName) {
    each3(toArr(option[axisName]), function(axisOpt) {
      if (axisOpt) {
        compatTextStyle(axisOpt, "axisLabel");
        compatTextStyle(axisOpt.axisPointer, "label");
      }
    });
  });
  each3(toArr(option.parallel), function(parallelOpt) {
    const parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
    compatTextStyle(parallelAxisDefault, "axisLabel");
    compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, "label");
  });
  each3(toArr(option.calendar), function(calendarOpt) {
    convertNormalEmphasis(calendarOpt, "itemStyle");
    compatTextStyle(calendarOpt, "dayLabel");
    compatTextStyle(calendarOpt, "monthLabel");
    compatTextStyle(calendarOpt, "yearLabel");
  });
  each3(toArr(option.radar), function(radarOpt) {
    compatTextStyle(radarOpt, "name");
    if (radarOpt.name && radarOpt.axisName == null) {
      radarOpt.axisName = radarOpt.name;
      delete radarOpt.name;
      if (true) {
        deprecateLog("name property in radar component has been changed to axisName");
      }
    }
    if (radarOpt.nameGap != null && radarOpt.axisNameGap == null) {
      radarOpt.axisNameGap = radarOpt.nameGap;
      delete radarOpt.nameGap;
      if (true) {
        deprecateLog("nameGap property in radar component has been changed to axisNameGap");
      }
    }
    if (true) {
      each3(radarOpt.indicator, function(indicatorOpt) {
        if (indicatorOpt.text) {
          deprecateReplaceLog("text", "name", "radar.indicator");
        }
      });
    }
  });
  each3(toArr(option.geo), function(geoOpt) {
    if (isObject2(geoOpt)) {
      compatEC3CommonStyles(geoOpt);
      each3(toArr(geoOpt.regions), function(regionObj) {
        compatEC3CommonStyles(regionObj);
      });
    }
  });
  each3(toArr(option.timeline), function(timelineOpt) {
    compatEC3CommonStyles(timelineOpt);
    convertNormalEmphasis(timelineOpt, "label");
    convertNormalEmphasis(timelineOpt, "itemStyle");
    convertNormalEmphasis(timelineOpt, "controlStyle", true);
    const data = timelineOpt.data;
    isArray(data) && each(data, function(item) {
      if (isObject(item)) {
        convertNormalEmphasis(item, "label");
        convertNormalEmphasis(item, "itemStyle");
      }
    });
  });
  each3(toArr(option.toolbox), function(toolboxOpt) {
    convertNormalEmphasis(toolboxOpt, "iconStyle");
    each3(toolboxOpt.feature, function(featureOpt) {
      convertNormalEmphasis(featureOpt, "iconStyle");
    });
  });
  compatTextStyle(toObj(option.axisPointer), "label");
  compatTextStyle(toObj(option.tooltip).axisPointer, "label");
}

// src/preprocessor/backwardCompat.ts
function get(opt, path) {
  const pathArr = path.split(",");
  let obj = opt;
  for (let i = 0; i < pathArr.length; i++) {
    obj = obj && obj[pathArr[i]];
    if (obj == null) {
      break;
    }
  }
  return obj;
}
function set2(opt, path, val, overwrite) {
  const pathArr = path.split(",");
  let obj = opt;
  let key;
  let i = 0;
  for (; i < pathArr.length - 1; i++) {
    key = pathArr[i];
    if (obj[key] == null) {
      obj[key] = {};
    }
    obj = obj[key];
  }
  if (overwrite || obj[pathArr[i]] == null) {
    obj[pathArr[i]] = val;
  }
}
function compatLayoutProperties(option) {
  option && each(LAYOUT_PROPERTIES, function(prop) {
    if (prop[0] in option && !(prop[1] in option)) {
      option[prop[1]] = option[prop[0]];
    }
  });
}
var LAYOUT_PROPERTIES = [
  ["x", "left"],
  ["y", "top"],
  ["x2", "right"],
  ["y2", "bottom"]
];
var COMPATITABLE_COMPONENTS = [
  "grid",
  "geo",
  "parallel",
  "legend",
  "toolbox",
  "title",
  "visualMap",
  "dataZoom",
  "timeline"
];
var BAR_ITEM_STYLE_MAP = [
  ["borderRadius", "barBorderRadius"],
  ["borderColor", "barBorderColor"],
  ["borderWidth", "barBorderWidth"]
];
function compatBarItemStyle(option) {
  const itemStyle = option && option.itemStyle;
  if (itemStyle) {
    for (let i = 0; i < BAR_ITEM_STYLE_MAP.length; i++) {
      const oldName = BAR_ITEM_STYLE_MAP[i][1];
      const newName = BAR_ITEM_STYLE_MAP[i][0];
      if (itemStyle[oldName] != null) {
        itemStyle[newName] = itemStyle[oldName];
        if (true) {
          deprecateReplaceLog(oldName, newName);
        }
      }
    }
  }
}
function compatPieLabel(option) {
  if (!option) {
    return;
  }
  if (option.alignTo === "edge" && option.margin != null && option.edgeDistance == null) {
    if (true) {
      deprecateReplaceLog("label.margin", "label.edgeDistance", "pie");
    }
    option.edgeDistance = option.margin;
  }
}
function compatSunburstState(option) {
  if (!option) {
    return;
  }
  if (option.downplay && !option.blur) {
    option.blur = option.downplay;
    if (true) {
      deprecateReplaceLog("downplay", "blur", "sunburst");
    }
  }
}
function compatGraphFocus(option) {
  if (!option) {
    return;
  }
  if (option.focusNodeAdjacency != null) {
    option.emphasis = option.emphasis || {};
    if (option.emphasis.focus == null) {
      if (true) {
        deprecateReplaceLog("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey");
      }
      option.emphasis.focus = "adjacency";
    }
  }
}
function traverseTree(data, cb) {
  if (data) {
    for (let i = 0; i < data.length; i++) {
      cb(data[i]);
      data[i] && traverseTree(data[i].children, cb);
    }
  }
}
function globalBackwardCompat(option, isTheme) {
  globalCompatStyle(option, isTheme);
  option.series = normalizeToArray(option.series);
  each(option.series, function(seriesOpt) {
    if (!isObject(seriesOpt)) {
      return;
    }
    const seriesType2 = seriesOpt.type;
    if (seriesType2 === "line") {
      if (seriesOpt.clipOverflow != null) {
        seriesOpt.clip = seriesOpt.clipOverflow;
        if (true) {
          deprecateReplaceLog("clipOverflow", "clip", "line");
        }
      }
    } else if (seriesType2 === "pie" || seriesType2 === "gauge") {
      if (seriesOpt.clockWise != null) {
        seriesOpt.clockwise = seriesOpt.clockWise;
        if (true) {
          deprecateReplaceLog("clockWise", "clockwise");
        }
      }
      compatPieLabel(seriesOpt.label);
      const data = seriesOpt.data;
      if (data && !isTypedArray(data)) {
        for (let i = 0; i < data.length; i++) {
          compatPieLabel(data[i]);
        }
      }
      if (seriesOpt.hoverOffset != null) {
        seriesOpt.emphasis = seriesOpt.emphasis || {};
        if (seriesOpt.emphasis.scaleSize = null) {
          if (true) {
            deprecateReplaceLog("hoverOffset", "emphasis.scaleSize");
          }
          seriesOpt.emphasis.scaleSize = seriesOpt.hoverOffset;
        }
      }
    } else if (seriesType2 === "gauge") {
      const pointerColor = get(seriesOpt, "pointer.color");
      pointerColor != null && set2(seriesOpt, "itemStyle.color", pointerColor);
    } else if (seriesType2 === "bar") {
      compatBarItemStyle(seriesOpt);
      compatBarItemStyle(seriesOpt.backgroundStyle);
      compatBarItemStyle(seriesOpt.emphasis);
      const data = seriesOpt.data;
      if (data && !isTypedArray(data)) {
        for (let i = 0; i < data.length; i++) {
          if (typeof data[i] === "object") {
            compatBarItemStyle(data[i]);
            compatBarItemStyle(data[i] && data[i].emphasis);
          }
        }
      }
    } else if (seriesType2 === "sunburst") {
      const highlightPolicy = seriesOpt.highlightPolicy;
      if (highlightPolicy) {
        seriesOpt.emphasis = seriesOpt.emphasis || {};
        if (!seriesOpt.emphasis.focus) {
          seriesOpt.emphasis.focus = highlightPolicy;
          if (true) {
            deprecateReplaceLog("highlightPolicy", "emphasis.focus", "sunburst");
          }
        }
      }
      compatSunburstState(seriesOpt);
      traverseTree(seriesOpt.data, compatSunburstState);
    } else if (seriesType2 === "graph" || seriesType2 === "sankey") {
      compatGraphFocus(seriesOpt);
    } else if (seriesType2 === "map") {
      if (seriesOpt.mapType && !seriesOpt.map) {
        if (true) {
          deprecateReplaceLog("mapType", "map", "map");
        }
        seriesOpt.map = seriesOpt.mapType;
      }
      if (seriesOpt.mapLocation) {
        if (true) {
          deprecateLog("`mapLocation` is not used anymore.");
        }
        defaults(seriesOpt, seriesOpt.mapLocation);
      }
    }
    if (seriesOpt.hoverAnimation != null) {
      seriesOpt.emphasis = seriesOpt.emphasis || {};
      if (seriesOpt.emphasis && seriesOpt.emphasis.scale == null) {
        if (true) {
          deprecateReplaceLog("hoverAnimation", "emphasis.scale");
        }
        seriesOpt.emphasis.scale = seriesOpt.hoverAnimation;
      }
    }
    compatLayoutProperties(seriesOpt);
  });
  if (option.dataRange) {
    option.visualMap = option.dataRange;
  }
  each(COMPATITABLE_COMPONENTS, function(componentName) {
    let options = option[componentName];
    if (options) {
      if (!isArray(options)) {
        options = [options];
      }
      each(options, function(option2) {
        compatLayoutProperties(option2);
      });
    }
  });
}

// src/processor/dataStack.ts
function dataStack(ecModel) {
  const stackInfoMap = createHashMap();
  ecModel.eachSeries(function(seriesModel) {
    const stack = seriesModel.get("stack");
    if (stack) {
      const stackInfoList = stackInfoMap.get(stack) || stackInfoMap.set(stack, []);
      const data = seriesModel.getData();
      const stackInfo = {
        stackResultDimension: data.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: data.getCalculationInfo("stackedOverDimension"),
        stackedDimension: data.getCalculationInfo("stackedDimension"),
        stackedByDimension: data.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: data.getCalculationInfo("isStackedByIndex"),
        data,
        seriesModel
      };
      if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) {
        return;
      }
      stackInfoList.length && data.setCalculationInfo("stackedOnSeries", stackInfoList[stackInfoList.length - 1].seriesModel);
      stackInfoList.push(stackInfo);
    }
  });
  stackInfoMap.each(calculateStack);
}
function calculateStack(stackInfoList) {
  each(stackInfoList, function(targetStackInfo, idxInStack) {
    const resultVal = [];
    const resultNaN = [NaN, NaN];
    const dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension];
    const targetData = targetStackInfo.data;
    const isStackedByIndex = targetStackInfo.isStackedByIndex;
    const stackStrategy = targetStackInfo.seriesModel.get("stackStrategy") || "samesign";
    targetData.modify(dims, function(v0, v12, dataIndex) {
      let sum2 = targetData.get(targetStackInfo.stackedDimension, dataIndex);
      if (isNaN(sum2)) {
        return resultNaN;
      }
      let byValue;
      let stackedDataRawIndex;
      if (isStackedByIndex) {
        stackedDataRawIndex = targetData.getRawIndex(dataIndex);
      } else {
        byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);
      }
      let stackedOver = NaN;
      for (let j = idxInStack - 1; j >= 0; j--) {
        const stackInfo = stackInfoList[j];
        if (!isStackedByIndex) {
          stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue);
        }
        if (stackedDataRawIndex >= 0) {
          const val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex);
          if (stackStrategy === "all" || stackStrategy === "positive" && val > 0 || stackStrategy === "negative" && val < 0 || stackStrategy === "samesign" && sum2 >= 0 && val > 0 || stackStrategy === "samesign" && sum2 <= 0 && val < 0) {
            sum2 = addSafe(sum2, val);
            stackedOver = val;
            break;
          }
        }
      }
      resultVal[0] = sum2;
      resultVal[1] = stackedOver;
      return resultVal;
    });
  });
}

// src/data/Source.ts
var SourceImpl = class {
  constructor(fields) {
    this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : []);
    this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN;
    this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN;
    this.startIndex = fields.startIndex || 0;
    this.dimensionsDetectedCount = fields.dimensionsDetectedCount;
    this.metaRawOption = fields.metaRawOption;
    const dimensionsDefine = this.dimensionsDefine = fields.dimensionsDefine;
    if (dimensionsDefine) {
      for (let i = 0; i < dimensionsDefine.length; i++) {
        const dim = dimensionsDefine[i];
        if (dim.type == null) {
          if (guessOrdinal(this, i) === BE_ORDINAL.Must) {
            dim.type = "ordinal";
          }
        }
      }
    }
  }
};
function isSourceInstance(val) {
  return val instanceof SourceImpl;
}
function createSource(sourceData, thisMetaRawOption, sourceFormat) {
  sourceFormat = sourceFormat || detectSourceFormat(sourceData);
  const seriesLayoutBy = thisMetaRawOption.seriesLayoutBy;
  const determined = determineSourceDimensions(sourceData, sourceFormat, seriesLayoutBy, thisMetaRawOption.sourceHeader, thisMetaRawOption.dimensions);
  const source = new SourceImpl({
    data: sourceData,
    sourceFormat,
    seriesLayoutBy,
    dimensionsDefine: determined.dimensionsDefine,
    startIndex: determined.startIndex,
    dimensionsDetectedCount: determined.dimensionsDetectedCount,
    metaRawOption: clone(thisMetaRawOption)
  });
  return source;
}
function createSourceFromSeriesDataOption(data) {
  return new SourceImpl({
    data,
    sourceFormat: isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL
  });
}
function cloneSourceShallow(source) {
  return new SourceImpl({
    data: source.data,
    sourceFormat: source.sourceFormat,
    seriesLayoutBy: source.seriesLayoutBy,
    dimensionsDefine: clone(source.dimensionsDefine),
    startIndex: source.startIndex,
    dimensionsDetectedCount: source.dimensionsDetectedCount
  });
}
function detectSourceFormat(data) {
  let sourceFormat = SOURCE_FORMAT_UNKNOWN;
  if (isTypedArray(data)) {
    sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;
  } else if (isArray(data)) {
    if (data.length === 0) {
      sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
    }
    for (let i = 0, len2 = data.length; i < len2; i++) {
      const item = data[i];
      if (item == null) {
        continue;
      } else if (isArray(item) || isTypedArray(item)) {
        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;
        break;
      } else if (isObject(item)) {
        sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;
        break;
      }
    }
  } else if (isObject(data)) {
    for (const key in data) {
      if (hasOwn(data, key) && isArrayLike(data[key])) {
        sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;
        break;
      }
    }
  }
  return sourceFormat;
}
function determineSourceDimensions(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {
  let dimensionsDetectedCount;
  let startIndex;
  if (!data) {
    return {
      dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
      startIndex,
      dimensionsDetectedCount
    };
  }
  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    const dataArrayRows = data;
    if (sourceHeader === "auto" || sourceHeader == null) {
      arrayRowsTravelFirst(function(val) {
        if (val != null && val !== "-") {
          if (isString(val)) {
            startIndex == null && (startIndex = 1);
          } else {
            startIndex = 0;
          }
        }
      }, seriesLayoutBy, dataArrayRows, 10);
    } else {
      startIndex = isNumber(sourceHeader) ? sourceHeader : sourceHeader ? 1 : 0;
    }
    if (!dimensionsDefine && startIndex === 1) {
      dimensionsDefine = [];
      arrayRowsTravelFirst(function(val, index) {
        dimensionsDefine[index] = val != null ? val + "" : "";
      }, seriesLayoutBy, dataArrayRows, Infinity);
    }
    dimensionsDetectedCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? dataArrayRows.length : dataArrayRows[0] ? dataArrayRows[0].length : null;
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    if (!dimensionsDefine) {
      dimensionsDefine = objectRowsCollectDimensions(data);
    }
  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
    if (!dimensionsDefine) {
      dimensionsDefine = [];
      each(data, function(colArr, key) {
        dimensionsDefine.push(key);
      });
    }
  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    const value0 = getDataItemValue(data[0]);
    dimensionsDetectedCount = isArray(value0) && value0.length || 1;
  } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
    if (true) {
      assert(!!dimensionsDefine, "dimensions must be given if data is TypedArray.");
    }
  }
  return {
    startIndex,
    dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
    dimensionsDetectedCount
  };
}
function objectRowsCollectDimensions(data) {
  let firstIndex = 0;
  let obj;
  while (firstIndex < data.length && !(obj = data[firstIndex++])) {
  }
  if (obj) {
    return keys(obj);
  }
}
function normalizeDimensionsOption(dimensionsDefine) {
  if (!dimensionsDefine) {
    return;
  }
  const nameMap = createHashMap();
  return map(dimensionsDefine, function(rawItem, index) {
    rawItem = isObject(rawItem) ? rawItem : {name: rawItem};
    const item = {
      name: rawItem.name,
      displayName: rawItem.displayName,
      type: rawItem.type
    };
    if (item.name == null) {
      return item;
    }
    item.name += "";
    if (item.displayName == null) {
      item.displayName = item.name;
    }
    const exist = nameMap.get(item.name);
    if (!exist) {
      nameMap.set(item.name, {count: 1});
    } else {
      item.name += "-" + exist.count++;
    }
    return item;
  });
}
function arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {
  if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
    for (let i = 0; i < data.length && i < maxLoop; i++) {
      cb(data[i] ? data[i][0] : null, i);
    }
  } else {
    const value0 = data[0] || [];
    for (let i = 0; i < value0.length && i < maxLoop; i++) {
      cb(value0[i], i);
    }
  }
}
function shouldRetrieveDataByName(source) {
  const sourceFormat = source.sourceFormat;
  return sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS;
}

// src/data/helper/dataProvider.ts
var providerMethods;
var mountMethods;
var DefaultDataProvider2 = class {
  constructor(sourceParam, dimSize) {
    const source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam;
    this._source = source;
    const data = this._data = source.data;
    if (source.sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
      if (true) {
        if (dimSize == null) {
          throw new Error("Typed array data must specify dimension size");
        }
      }
      this._offset = 0;
      this._dimSize = dimSize;
      this._data = data;
    }
    mountMethods(this, data, source);
  }
  getSource() {
    return this._source;
  }
  count() {
    return 0;
  }
  getItem(idx, out2) {
    return;
  }
  appendData(newData) {
  }
  clean() {
  }
};
var DefaultDataProvider = DefaultDataProvider2;
DefaultDataProvider.protoInitialize = function() {
  const proto2 = DefaultDataProvider2.prototype;
  proto2.pure = false;
  proto2.persistent = true;
}();
DefaultDataProvider.internalField = function() {
  mountMethods = function(provider, data, source) {
    const sourceFormat = source.sourceFormat;
    const seriesLayoutBy = source.seriesLayoutBy;
    const startIndex = source.startIndex;
    const dimsDef = source.dimensionsDefine;
    const methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];
    if (true) {
      assert(methods, "Invalide sourceFormat: " + sourceFormat);
    }
    extend(provider, methods);
    if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
      provider.getItem = getItemForTypedArray;
      provider.count = countForTypedArray;
      provider.fillStorage = fillStorageForTypedArray;
    } else {
      const rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);
      provider.getItem = bind(rawItemGetter, null, data, startIndex, dimsDef);
      const rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);
      provider.count = bind(rawCounter, null, data, startIndex, dimsDef);
    }
  };
  const getItemForTypedArray = function(idx, out2) {
    idx = idx - this._offset;
    out2 = out2 || [];
    const data = this._data;
    const dimSize = this._dimSize;
    const offset = dimSize * idx;
    for (let i = 0; i < dimSize; i++) {
      out2[i] = data[offset + i];
    }
    return out2;
  };
  const fillStorageForTypedArray = function(start2, end2, storage2, extent3) {
    const data = this._data;
    const dimSize = this._dimSize;
    for (let dim = 0; dim < dimSize; dim++) {
      const dimExtent = extent3[dim];
      let min3 = dimExtent[0] == null ? Infinity : dimExtent[0];
      let max3 = dimExtent[1] == null ? -Infinity : dimExtent[1];
      const count2 = end2 - start2;
      const arr = storage2[dim];
      for (let i = 0; i < count2; i++) {
        const val = data[i * dimSize + dim];
        arr[start2 + i] = val;
        val < min3 && (min3 = val);
        val > max3 && (max3 = val);
      }
      dimExtent[0] = min3;
      dimExtent[1] = max3;
    }
  };
  const countForTypedArray = function() {
    return this._data ? this._data.length / this._dimSize : 0;
  };
  providerMethods = {
    [SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN]: {
      pure: true,
      appendData: appendDataSimply
    },
    [SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW]: {
      pure: true,
      appendData: function() {
        throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
      }
    },
    [SOURCE_FORMAT_OBJECT_ROWS]: {
      pure: true,
      appendData: appendDataSimply
    },
    [SOURCE_FORMAT_KEYED_COLUMNS]: {
      pure: true,
      appendData: function(newData) {
        const data = this._data;
        each(newData, function(newCol, key) {
          const oldCol = data[key] || (data[key] = []);
          for (let i = 0; i < (newCol || []).length; i++) {
            oldCol.push(newCol[i]);
          }
        });
      }
    },
    [SOURCE_FORMAT_ORIGINAL]: {
      appendData: appendDataSimply
    },
    [SOURCE_FORMAT_TYPED_ARRAY]: {
      persistent: false,
      pure: true,
      appendData: function(newData) {
        if (true) {
          assert(isTypedArray(newData), "Added data must be TypedArray if data in initialization is TypedArray");
        }
        this._data = newData;
      },
      clean: function() {
        this._offset += this.count();
        this._data = null;
      }
    }
  };
  function appendDataSimply(newData) {
    for (let i = 0; i < newData.length; i++) {
      this._data.push(newData[i]);
    }
  }
}();
var getItemSimply = function(rawData, startIndex, dimsDef, idx) {
  return rawData[idx];
};
var rawSourceItemGetterMap = {
  [SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN]: function(rawData, startIndex, dimsDef, idx) {
    return rawData[idx + startIndex];
  },
  [SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW]: function(rawData, startIndex, dimsDef, idx, out2) {
    idx += startIndex;
    const item = out2 || [];
    const data = rawData;
    for (let i = 0; i < data.length; i++) {
      const row = data[i];
      item[i] = row ? row[idx] : null;
    }
    return item;
  },
  [SOURCE_FORMAT_OBJECT_ROWS]: getItemSimply,
  [SOURCE_FORMAT_KEYED_COLUMNS]: function(rawData, startIndex, dimsDef, idx, out2) {
    const item = out2 || [];
    for (let i = 0; i < dimsDef.length; i++) {
      const dimName = dimsDef[i].name;
      if (true) {
        if (dimName == null) {
          throw new Error();
        }
      }
      const col = rawData[dimName];
      item[i] = col ? col[idx] : null;
    }
    return item;
  },
  [SOURCE_FORMAT_ORIGINAL]: getItemSimply
};
function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {
  const method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
  if (true) {
    assert(method, 'Do not support get item on "' + sourceFormat + '", "' + seriesLayoutBy + '".');
  }
  return method;
}
var countSimply = function(rawData, startIndex, dimsDef) {
  return rawData.length;
};
var rawSourceDataCounterMap = {
  [SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_COLUMN]: function(rawData, startIndex, dimsDef) {
    return Math.max(0, rawData.length - startIndex);
  },
  [SOURCE_FORMAT_ARRAY_ROWS + "_" + SERIES_LAYOUT_BY_ROW]: function(rawData, startIndex, dimsDef) {
    const row = rawData[0];
    return row ? Math.max(0, row.length - startIndex) : 0;
  },
  [SOURCE_FORMAT_OBJECT_ROWS]: countSimply,
  [SOURCE_FORMAT_KEYED_COLUMNS]: function(rawData, startIndex, dimsDef) {
    const dimName = dimsDef[0].name;
    if (true) {
      if (dimName == null) {
        throw new Error();
      }
    }
    const col = rawData[dimName];
    return col ? col.length : 0;
  },
  [SOURCE_FORMAT_ORIGINAL]: countSimply
};
function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {
  const method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
  if (true) {
    assert(method, 'Do not support count on "' + sourceFormat + '", "' + seriesLayoutBy + '".');
  }
  return method;
}
var getRawValueSimply = function(dataItem, dimIndex, property) {
  return dataItem[dimIndex];
};
var rawSourceValueGetterMap = {
  [SOURCE_FORMAT_ARRAY_ROWS]: getRawValueSimply,
  [SOURCE_FORMAT_OBJECT_ROWS]: function(dataItem, dimIndex, property) {
    return dataItem[property];
  },
  [SOURCE_FORMAT_KEYED_COLUMNS]: getRawValueSimply,
  [SOURCE_FORMAT_ORIGINAL]: function(dataItem, dimIndex, property) {
    const value = getDataItemValue(dataItem);
    return !(value instanceof Array) ? value : value[dimIndex];
  },
  [SOURCE_FORMAT_TYPED_ARRAY]: getRawValueSimply
};
function getRawSourceValueGetter(sourceFormat) {
  const method = rawSourceValueGetterMap[sourceFormat];
  if (true) {
    assert(method, 'Do not support get value on "' + sourceFormat + '".');
  }
  return method;
}
function getMethodMapKey(sourceFormat, seriesLayoutBy) {
  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + "_" + seriesLayoutBy : sourceFormat;
}
function retrieveRawValue(data, dataIndex, dim) {
  if (!data) {
    return;
  }
  const dataItem = data.getRawDataItem(dataIndex);
  if (dataItem == null) {
    return;
  }
  const store = data.getStore();
  const sourceFormat = store.getSource().sourceFormat;
  if (dim != null) {
    const dimIndex = data.getDimensionIndex(dim);
    const property = store.getDimensionProperty(dimIndex);
    return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property);
  } else {
    let result = dataItem;
    if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
      result = getDataItemValue(dataItem);
    }
    return result;
  }
}

// src/model/mixin/dataFormat.ts
var DIMENSION_LABEL_REG = /\{@(.+?)\}/g;
var DataFormatMixin = class {
  getDataParams(dataIndex, dataType) {
    const data = this.getData(dataType);
    const rawValue = this.getRawValue(dataIndex, dataType);
    const rawDataIndex = data.getRawIndex(dataIndex);
    const name = data.getName(dataIndex);
    const itemOpt = data.getRawDataItem(dataIndex);
    const style = data.getItemVisual(dataIndex, "style");
    const color2 = style && style[data.getItemVisual(dataIndex, "drawType") || "fill"];
    const borderColor = style && style.stroke;
    const mainType = this.mainType;
    const isSeries2 = mainType === "series";
    const userOutput = data.userOutput && data.userOutput.get();
    return {
      componentType: mainType,
      componentSubType: this.subType,
      componentIndex: this.componentIndex,
      seriesType: isSeries2 ? this.subType : null,
      seriesIndex: this.seriesIndex,
      seriesId: isSeries2 ? this.id : null,
      seriesName: isSeries2 ? this.name : null,
      name,
      dataIndex: rawDataIndex,
      data: itemOpt,
      dataType,
      value: rawValue,
      color: color2,
      borderColor,
      dimensionNames: userOutput ? userOutput.fullDimensions : null,
      encode: userOutput ? userOutput.encode : null,
      $vars: ["seriesName", "name", "value"]
    };
  }
  getFormattedLabel(dataIndex, status, dataType, labelDimIndex, formatter, extendParams) {
    status = status || "normal";
    const data = this.getData(dataType);
    const params = this.getDataParams(dataIndex, dataType);
    if (extendParams) {
      params.value = extendParams.interpolatedValue;
    }
    if (labelDimIndex != null && isArray(params.value)) {
      params.value = params.value[labelDimIndex];
    }
    if (!formatter) {
      const itemModel = data.getItemModel(dataIndex);
      formatter = itemModel.get(status === "normal" ? ["label", "formatter"] : [status, "label", "formatter"]);
    }
    if (isFunction(formatter)) {
      params.status = status;
      params.dimensionIndex = labelDimIndex;
      return formatter(params);
    } else if (isString(formatter)) {
      const str = formatTpl(formatter, params);
      return str.replace(DIMENSION_LABEL_REG, function(origin, dimStr) {
        const len2 = dimStr.length;
        let dimLoose = dimStr;
        if (dimLoose.charAt(0) === "[" && dimLoose.charAt(len2 - 1) === "]") {
          dimLoose = +dimLoose.slice(1, len2 - 1);
          if (true) {
            if (isNaN(dimLoose)) {
              error(`Invalide label formatter: @${dimStr}, only support @[0], @[1], @[2], ...`);
            }
          }
        }
        let val = retrieveRawValue(data, dataIndex, dimLoose);
        if (extendParams && isArray(extendParams.interpolatedValue)) {
          const dimIndex = data.getDimensionIndex(dimLoose);
          if (dimIndex >= 0) {
            val = extendParams.interpolatedValue[dimIndex];
          }
        }
        return val != null ? val + "" : "";
      });
    }
  }
  getRawValue(idx, dataType) {
    return retrieveRawValue(this.getData(dataType), idx);
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    return;
  }
};
function normalizeTooltipFormatResult(result) {
  let markupText;
  let markupFragment;
  if (isObject(result)) {
    if (result.type) {
      markupFragment = result;
    } else {
      if (true) {
        console.warn("The return type of `formatTooltip` is not supported: " + makePrintable(result));
      }
    }
  } else {
    markupText = result;
  }
  return {
    text: markupText,
    frag: markupFragment
  };
}

// src/core/task.ts
function createTask(define) {
  return new Task(define);
}
var Task = class {
  constructor(define) {
    define = define || {};
    this._reset = define.reset;
    this._plan = define.plan;
    this._count = define.count;
    this._onDirty = define.onDirty;
    this._dirty = true;
  }
  perform(performArgs) {
    const upTask = this._upstream;
    const skip = performArgs && performArgs.skip;
    if (this._dirty && upTask) {
      const context = this.context;
      context.data = context.outputData = upTask.context.outputData;
    }
    if (this.__pipeline) {
      this.__pipeline.currentTask = this;
    }
    let planResult;
    if (this._plan && !skip) {
      planResult = this._plan(this.context);
    }
    const lastModBy = normalizeModBy(this._modBy);
    const lastModDataCount = this._modDataCount || 0;
    const modBy = normalizeModBy(performArgs && performArgs.modBy);
    const modDataCount = performArgs && performArgs.modDataCount || 0;
    if (lastModBy !== modBy || lastModDataCount !== modDataCount) {
      planResult = "reset";
    }
    function normalizeModBy(val) {
      !(val >= 1) && (val = 1);
      return val;
    }
    let forceFirstProgress;
    if (this._dirty || planResult === "reset") {
      this._dirty = false;
      forceFirstProgress = this._doReset(skip);
    }
    this._modBy = modBy;
    this._modDataCount = modDataCount;
    const step = performArgs && performArgs.step;
    if (upTask) {
      if (true) {
        assert(upTask._outputDueEnd != null);
      }
      this._dueEnd = upTask._outputDueEnd;
    } else {
      if (true) {
        assert(!this._progress || this._count);
      }
      this._dueEnd = this._count ? this._count(this.context) : Infinity;
    }
    if (this._progress) {
      const start2 = this._dueIndex;
      const end2 = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);
      if (!skip && (forceFirstProgress || start2 < end2)) {
        const progress = this._progress;
        if (isArray(progress)) {
          for (let i = 0; i < progress.length; i++) {
            this._doProgress(progress[i], start2, end2, modBy, modDataCount);
          }
        } else {
          this._doProgress(progress, start2, end2, modBy, modDataCount);
        }
      }
      this._dueIndex = end2;
      const outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end2;
      if (true) {
        assert(outputDueEnd >= this._outputDueEnd);
      }
      this._outputDueEnd = outputDueEnd;
    } else {
      this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
    }
    return this.unfinished();
  }
  dirty() {
    this._dirty = true;
    this._onDirty && this._onDirty(this.context);
  }
  _doProgress(progress, start2, end2, modBy, modDataCount) {
    iterator.reset(start2, end2, modBy, modDataCount);
    this._callingProgress = progress;
    this._callingProgress({
      start: start2,
      end: end2,
      count: end2 - start2,
      next: iterator.next
    }, this.context);
  }
  _doReset(skip) {
    this._dueIndex = this._outputDueEnd = this._dueEnd = 0;
    this._settedOutputEnd = null;
    let progress;
    let forceFirstProgress;
    if (!skip && this._reset) {
      progress = this._reset(this.context);
      if (progress && progress.progress) {
        forceFirstProgress = progress.forceFirstProgress;
        progress = progress.progress;
      }
      if (isArray(progress) && !progress.length) {
        progress = null;
      }
    }
    this._progress = progress;
    this._modBy = this._modDataCount = null;
    const downstream = this._downstream;
    downstream && downstream.dirty();
    return forceFirstProgress;
  }
  unfinished() {
    return this._progress && this._dueIndex < this._dueEnd;
  }
  pipe(downTask) {
    if (true) {
      assert(downTask && !downTask._disposed && downTask !== this);
    }
    if (this._downstream !== downTask || this._dirty) {
      this._downstream = downTask;
      downTask._upstream = this;
      downTask.dirty();
    }
  }
  dispose() {
    if (this._disposed) {
      return;
    }
    this._upstream && (this._upstream._downstream = null);
    this._downstream && (this._downstream._upstream = null);
    this._dirty = false;
    this._disposed = true;
  }
  getUpstream() {
    return this._upstream;
  }
  getDownstream() {
    return this._downstream;
  }
  setOutputEnd(end2) {
    this._outputDueEnd = this._settedOutputEnd = end2;
  }
};
var iterator = function() {
  let end2;
  let current;
  let modBy;
  let modDataCount;
  let winCount;
  const it = {
    reset: function(s, e2, sStep, sCount) {
      current = s;
      end2 = e2;
      modBy = sStep;
      modDataCount = sCount;
      winCount = Math.ceil(modDataCount / modBy);
      it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;
    }
  };
  return it;
  function sequentialNext() {
    return current < end2 ? current++ : null;
  }
  function modNext() {
    const dataIndex = current % winCount * modBy + Math.ceil(current / winCount);
    const result = current >= end2 ? null : dataIndex < modDataCount ? dataIndex : current;
    current++;
    return result;
  }
}();

// src/data/helper/dataValueHelper.ts
function parseDataValue(value, opt) {
  const dimType = opt && opt.type;
  if (dimType === "ordinal") {
    return value;
  }
  if (dimType === "time" && !isNumber(value) && value != null && value !== "-") {
    value = +parseDate(value);
  }
  return value == null || value === "" ? NaN : +value;
}
var valueParserMap = createHashMap({
  number: function(val) {
    return parseFloat(val);
  },
  time: function(val) {
    return +parseDate(val);
  },
  trim: function(val) {
    return isString(val) ? trim(val) : val;
  }
});
function getRawValueParser(type) {
  return valueParserMap.get(type);
}
var ORDER_COMPARISON_OP_MAP = {
  lt: (lval, rval) => lval < rval,
  lte: (lval, rval) => lval <= rval,
  gt: (lval, rval) => lval > rval,
  gte: (lval, rval) => lval >= rval
};
var FilterOrderComparator = class {
  constructor(op, rval) {
    if (!isNumber(rval)) {
      let errMsg = "";
      if (true) {
        errMsg = 'rvalue of "<", ">", "<=", ">=" can only be number in filter.';
      }
      throwError(errMsg);
    }
    this._opFn = ORDER_COMPARISON_OP_MAP[op];
    this._rvalFloat = numericToNumber(rval);
  }
  evaluate(lval) {
    return isNumber(lval) ? this._opFn(lval, this._rvalFloat) : this._opFn(numericToNumber(lval), this._rvalFloat);
  }
};
var SortOrderComparator = class {
  constructor(order, incomparable) {
    const isDesc = order === "desc";
    this._resultLT = isDesc ? 1 : -1;
    if (incomparable == null) {
      incomparable = isDesc ? "min" : "max";
    }
    this._incomparable = incomparable === "min" ? -Infinity : Infinity;
  }
  evaluate(lval, rval) {
    let lvalFloat = isNumber(lval) ? lval : numericToNumber(lval);
    let rvalFloat = isNumber(rval) ? rval : numericToNumber(rval);
    const lvalNotNumeric = isNaN(lvalFloat);
    const rvalNotNumeric = isNaN(rvalFloat);
    if (lvalNotNumeric) {
      lvalFloat = this._incomparable;
    }
    if (rvalNotNumeric) {
      rvalFloat = this._incomparable;
    }
    if (lvalNotNumeric && rvalNotNumeric) {
      const lvalIsStr = isString(lval);
      const rvalIsStr = isString(rval);
      if (lvalIsStr) {
        lvalFloat = rvalIsStr ? lval : 0;
      }
      if (rvalIsStr) {
        rvalFloat = lvalIsStr ? rval : 0;
      }
    }
    return lvalFloat < rvalFloat ? this._resultLT : lvalFloat > rvalFloat ? -this._resultLT : 0;
  }
};
var FilterEqualityComparator = class {
  constructor(isEq, rval) {
    this._rval = rval;
    this._isEQ = isEq;
    this._rvalTypeof = typeof rval;
    this._rvalFloat = numericToNumber(rval);
  }
  evaluate(lval) {
    let eqResult = lval === this._rval;
    if (!eqResult) {
      const lvalTypeof = typeof lval;
      if (lvalTypeof !== this._rvalTypeof && (lvalTypeof === "number" || this._rvalTypeof === "number")) {
        eqResult = numericToNumber(lval) === this._rvalFloat;
      }
    }
    return this._isEQ ? eqResult : !eqResult;
  }
};
function createFilterComparator(op, rval) {
  return op === "eq" || op === "ne" ? new FilterEqualityComparator(op === "eq", rval) : hasOwn(ORDER_COMPARISON_OP_MAP, op) ? new FilterOrderComparator(op, rval) : null;
}

// src/data/helper/transform.ts
var ExternalSource = class {
  getRawData() {
    throw new Error("not supported");
  }
  getRawDataItem(dataIndex) {
    throw new Error("not supported");
  }
  cloneRawData() {
    return;
  }
  getDimensionInfo(dim) {
    return;
  }
  cloneAllDimensionInfo() {
    return;
  }
  count() {
    return;
  }
  retrieveValue(dataIndex, dimIndex) {
    return;
  }
  retrieveValueFromItem(dataItem, dimIndex) {
    return;
  }
  convertValue(rawVal, dimInfo) {
    return parseDataValue(rawVal, dimInfo);
  }
};
function createExternalSource(internalSource, externalTransform) {
  const extSource = new ExternalSource();
  const data = internalSource.data;
  const sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;
  const sourceHeaderCount = internalSource.startIndex;
  let errMsg = "";
  if (internalSource.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN) {
    if (true) {
      errMsg = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.';
    }
    throwError(errMsg);
  }
  const dimensions = [];
  const dimsByName = {};
  const dimsDef = internalSource.dimensionsDefine;
  if (dimsDef) {
    each(dimsDef, function(dimDef, idx) {
      const name = dimDef.name;
      const dimDefExt = {
        index: idx,
        name,
        displayName: dimDef.displayName
      };
      dimensions.push(dimDefExt);
      if (name != null) {
        let errMsg2 = "";
        if (hasOwn(dimsByName, name)) {
          if (true) {
            errMsg2 = 'dimension name "' + name + '" duplicated.';
          }
          throwError(errMsg2);
        }
        dimsByName[name] = dimDefExt;
      }
    });
  } else {
    for (let i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {
      dimensions.push({index: i});
    }
  }
  const rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
  if (externalTransform.__isBuiltIn) {
    extSource.getRawDataItem = function(dataIndex) {
      return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
    };
    extSource.getRawData = bind(getRawData, null, internalSource);
  }
  extSource.cloneRawData = bind(cloneRawData, null, internalSource);
  const rawCounter = getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);
  extSource.count = bind(rawCounter, null, data, sourceHeaderCount, dimensions);
  const rawValueGetter = getRawSourceValueGetter(sourceFormat);
  extSource.retrieveValue = function(dataIndex, dimIndex) {
    const rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
    return retrieveValueFromItem(rawItem, dimIndex);
  };
  const retrieveValueFromItem = extSource.retrieveValueFromItem = function(dataItem, dimIndex) {
    if (dataItem == null) {
      return;
    }
    const dimDef = dimensions[dimIndex];
    if (dimDef) {
      return rawValueGetter(dataItem, dimIndex, dimDef.name);
    }
  };
  extSource.getDimensionInfo = bind(getDimensionInfo, null, dimensions, dimsByName);
  extSource.cloneAllDimensionInfo = bind(cloneAllDimensionInfo, null, dimensions);
  return extSource;
}
function getRawData(upstream) {
  const sourceFormat = upstream.sourceFormat;
  if (!isSupportedSourceFormat(sourceFormat)) {
    let errMsg = "";
    if (true) {
      errMsg = "`getRawData` is not supported in source format " + sourceFormat;
    }
    throwError(errMsg);
  }
  return upstream.data;
}
function cloneRawData(upstream) {
  const sourceFormat = upstream.sourceFormat;
  const data = upstream.data;
  if (!isSupportedSourceFormat(sourceFormat)) {
    let errMsg = "";
    if (true) {
      errMsg = "`cloneRawData` is not supported in source format " + sourceFormat;
    }
    throwError(errMsg);
  }
  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
    const result = [];
    for (let i = 0, len2 = data.length; i < len2; i++) {
      result.push(data[i].slice());
    }
    return result;
  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
    const result = [];
    for (let i = 0, len2 = data.length; i < len2; i++) {
      result.push(extend({}, data[i]));
    }
    return result;
  }
}
function getDimensionInfo(dimensions, dimsByName, dim) {
  if (dim == null) {
    return;
  }
  if (isNumber(dim) || !isNaN(dim) && !hasOwn(dimsByName, dim)) {
    return dimensions[dim];
  } else if (hasOwn(dimsByName, dim)) {
    return dimsByName[dim];
  }
}
function cloneAllDimensionInfo(dimensions) {
  return clone(dimensions);
}
var externalTransformMap = createHashMap();
function registerExternalTransform(externalTransform) {
  externalTransform = clone(externalTransform);
  let type = externalTransform.type;
  let errMsg = "";
  if (!type) {
    if (true) {
      errMsg = "Must have a `type` when `registerTransform`.";
    }
    throwError(errMsg);
  }
  const typeParsed = type.split(":");
  if (typeParsed.length !== 2) {
    if (true) {
      errMsg = 'Name must include namespace like "ns:regression".';
    }
    throwError(errMsg);
  }
  let isBuiltIn = false;
  if (typeParsed[0] === "echarts") {
    type = typeParsed[1];
    isBuiltIn = true;
  }
  externalTransform.__isBuiltIn = isBuiltIn;
  externalTransformMap.set(type, externalTransform);
}
function applyDataTransform(rawTransOption, sourceList, infoForPrint) {
  const pipedTransOption = normalizeToArray(rawTransOption);
  const pipeLen = pipedTransOption.length;
  let errMsg = "";
  if (!pipeLen) {
    if (true) {
      errMsg = "If `transform` declared, it should at least contain one transform.";
    }
    throwError(errMsg);
  }
  for (let i = 0, len2 = pipeLen; i < len2; i++) {
    const transOption = pipedTransOption[i];
    sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i);
    if (i !== len2 - 1) {
      sourceList.length = Math.max(sourceList.length, 1);
    }
  }
  return sourceList;
}
function applySingleDataTransform(transOption, upSourceList, infoForPrint, pipeIndex) {
  let errMsg = "";
  if (!upSourceList.length) {
    if (true) {
      errMsg = "Must have at least one upstream dataset.";
    }
    throwError(errMsg);
  }
  if (!isObject(transOption)) {
    if (true) {
      errMsg = "transform declaration must be an object rather than " + typeof transOption + ".";
    }
    throwError(errMsg);
  }
  const transType = transOption.type;
  const externalTransform = externalTransformMap.get(transType);
  if (!externalTransform) {
    if (true) {
      errMsg = 'Can not find transform on type "' + transType + '".';
    }
    throwError(errMsg);
  }
  const extUpSourceList = map(upSourceList, (upSource) => createExternalSource(upSource, externalTransform));
  const resultList = normalizeToArray(externalTransform.transform({
    upstream: extUpSourceList[0],
    upstreamList: extUpSourceList,
    config: clone(transOption.config)
  }));
  if (true) {
    if (transOption.print) {
      const printStrArr = map(resultList, (extSource) => {
        const pipeIndexStr = pipeIndex != null ? " === pipe index: " + pipeIndex : "";
        return [
          "=== dataset index: " + infoForPrint.datasetIndex + pipeIndexStr + " ===",
          "- transform result data:",
          makePrintable(extSource.data),
          "- transform result dimensions:",
          makePrintable(extSource.dimensions)
        ].join("\n");
      }).join("\n");
      log(printStrArr);
    }
  }
  return map(resultList, function(result, resultIndex) {
    let errMsg2 = "";
    if (!isObject(result)) {
      if (true) {
        errMsg2 = "A transform should not return some empty results.";
      }
      throwError(errMsg2);
    }
    if (!result.data) {
      if (true) {
        errMsg2 = "Transform result data should be not be null or undefined";
      }
      throwError(errMsg2);
    }
    const sourceFormat = detectSourceFormat(result.data);
    if (!isSupportedSourceFormat(sourceFormat)) {
      if (true) {
        errMsg2 = "Transform result data should be array rows or object rows.";
      }
      throwError(errMsg2);
    }
    let resultMetaRawOption;
    const firstUpSource = upSourceList[0];
    if (firstUpSource && resultIndex === 0 && !result.dimensions) {
      const startIndex = firstUpSource.startIndex;
      if (startIndex) {
        result.data = firstUpSource.data.slice(0, startIndex).concat(result.data);
      }
      resultMetaRawOption = {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
        sourceHeader: startIndex,
        dimensions: firstUpSource.metaRawOption.dimensions
      };
    } else {
      resultMetaRawOption = {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
        sourceHeader: 0,
        dimensions: result.dimensions
      };
    }
    return createSource(result.data, resultMetaRawOption, null);
  });
}
function isSupportedSourceFormat(sourceFormat) {
  return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS;
}

// src/data/DataStore.ts
var UNDEFINED = "undefined";
var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;
var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;
var CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;
var CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array;
var dataCtors = {
  float: CtorFloat64Array,
  int: CtorInt32Array,
  ordinal: Array,
  number: Array,
  time: CtorFloat64Array
};
var defaultDimValueGetters;
function getIndicesCtor(rawCount) {
  return rawCount > 65535 ? CtorUint32Array : CtorUint16Array;
}
function getInitialExtent() {
  return [Infinity, -Infinity];
}
function cloneChunk(originalChunk) {
  const Ctor = originalChunk.constructor;
  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);
}
function prepareStore(store, dimIdx, dimType, end2, append) {
  const DataCtor = dataCtors[dimType || "float"];
  if (append) {
    const oldStore = store[dimIdx];
    const oldLen = oldStore && oldStore.length;
    if (!(oldLen === end2)) {
      const newStore = new DataCtor(end2);
      for (let j = 0; j < oldLen; j++) {
        newStore[j] = oldStore[j];
      }
      store[dimIdx] = newStore;
    }
  } else {
    store[dimIdx] = new DataCtor(end2);
  }
}
var DataStore2 = class {
  constructor() {
    this._chunks = [];
    this._rawExtent = [];
    this._extent = [];
    this._count = 0;
    this._rawCount = 0;
    this._calcDimNameToIdx = createHashMap();
  }
  initData(provider, inputDimensions, dimValueGetter) {
    if (true) {
      assert(isFunction(provider.getItem) && isFunction(provider.count), "Invalid data provider.");
    }
    this._provider = provider;
    this._chunks = [];
    this._indices = null;
    this.getRawIndex = this._getRawIdxIdentity;
    const source = provider.getSource();
    const defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat];
    this._dimValueGetter = dimValueGetter || defaultGetter;
    this._rawExtent = [];
    const willRetrieveDataByName = shouldRetrieveDataByName(source);
    this._dimensions = map(inputDimensions, (dim) => {
      if (true) {
        if (willRetrieveDataByName) {
          assert(dim.property != null);
        }
      }
      return {
        type: dim.type,
        property: dim.property
      };
    });
    this._initDataFromProvider(0, provider.count());
  }
  getProvider() {
    return this._provider;
  }
  getSource() {
    return this._provider.getSource();
  }
  ensureCalculationDimension(dimName, type) {
    const calcDimNameToIdx = this._calcDimNameToIdx;
    const dimensions = this._dimensions;
    let calcDimIdx = calcDimNameToIdx.get(dimName);
    if (calcDimIdx != null) {
      if (dimensions[calcDimIdx].type === type) {
        return calcDimIdx;
      }
    } else {
      calcDimIdx = dimensions.length;
    }
    dimensions[calcDimIdx] = {type};
    calcDimNameToIdx.set(dimName, calcDimIdx);
    this._chunks[calcDimIdx] = new dataCtors[type || "float"](this._rawCount);
    this._rawExtent[calcDimIdx] = getInitialExtent();
    return calcDimIdx;
  }
  collectOrdinalMeta(dimIdx, ordinalMeta) {
    const chunk = this._chunks[dimIdx];
    const dim = this._dimensions[dimIdx];
    const rawExtents = this._rawExtent;
    const offset = dim.ordinalOffset || 0;
    const len2 = chunk.length;
    if (offset === 0) {
      rawExtents[dimIdx] = getInitialExtent();
    }
    const dimRawExtent = rawExtents[dimIdx];
    for (let i = offset; i < len2; i++) {
      const val = chunk[i] = ordinalMeta.parseAndCollect(chunk[i]);
      if (!isNaN(val)) {
        dimRawExtent[0] = Math.min(val, dimRawExtent[0]);
        dimRawExtent[1] = Math.max(val, dimRawExtent[1]);
      }
    }
    dim.ordinalMeta = ordinalMeta;
    dim.ordinalOffset = len2;
    dim.type = "ordinal";
  }
  getOrdinalMeta(dimIdx) {
    const dimInfo = this._dimensions[dimIdx];
    const ordinalMeta = dimInfo.ordinalMeta;
    return ordinalMeta;
  }
  getDimensionProperty(dimIndex) {
    const item = this._dimensions[dimIndex];
    return item && item.property;
  }
  appendData(data) {
    if (true) {
      assert(!this._indices, "appendData can only be called on raw data.");
    }
    const provider = this._provider;
    const start2 = this.count();
    provider.appendData(data);
    let end2 = provider.count();
    if (!provider.persistent) {
      end2 += start2;
    }
    if (start2 < end2) {
      this._initDataFromProvider(start2, end2, true);
    }
    return [start2, end2];
  }
  appendValues(values, minFillLen) {
    const chunks = this._chunks;
    const dimensions = this._dimensions;
    const dimLen = dimensions.length;
    const rawExtent = this._rawExtent;
    const start2 = this.count();
    const end2 = start2 + Math.max(values.length, minFillLen || 0);
    for (let i = 0; i < dimLen; i++) {
      const dim = dimensions[i];
      prepareStore(chunks, i, dim.type, end2, true);
    }
    const emptyDataItem = [];
    for (let idx = start2; idx < end2; idx++) {
      const sourceIdx = idx - start2;
      for (let dimIdx = 0; dimIdx < dimLen; dimIdx++) {
        const dim = dimensions[dimIdx];
        const val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx);
        chunks[dimIdx][idx] = val;
        const dimRawExtent = rawExtent[dimIdx];
        val < dimRawExtent[0] && (dimRawExtent[0] = val);
        val > dimRawExtent[1] && (dimRawExtent[1] = val);
      }
    }
    this._rawCount = this._count = end2;
    return {start: start2, end: end2};
  }
  _initDataFromProvider(start2, end2, append) {
    const provider = this._provider;
    const chunks = this._chunks;
    const dimensions = this._dimensions;
    const dimLen = dimensions.length;
    const rawExtent = this._rawExtent;
    const dimNames = map(dimensions, (dim) => dim.property);
    for (let i = 0; i < dimLen; i++) {
      const dim = dimensions[i];
      if (!rawExtent[i]) {
        rawExtent[i] = getInitialExtent();
      }
      prepareStore(chunks, i, dim.type, end2, append);
    }
    if (provider.fillStorage) {
      provider.fillStorage(start2, end2, chunks, rawExtent);
    } else {
      let dataItem = [];
      for (let idx = start2; idx < end2; idx++) {
        dataItem = provider.getItem(idx, dataItem);
        for (let dimIdx = 0; dimIdx < dimLen; dimIdx++) {
          const dimStorage = chunks[dimIdx];
          const val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx);
          dimStorage[idx] = val;
          const dimRawExtent = rawExtent[dimIdx];
          val < dimRawExtent[0] && (dimRawExtent[0] = val);
          val > dimRawExtent[1] && (dimRawExtent[1] = val);
        }
      }
    }
    if (!provider.persistent && provider.clean) {
      provider.clean();
    }
    this._rawCount = this._count = end2;
    this._extent = [];
  }
  count() {
    return this._count;
  }
  get(dim, idx) {
    if (!(idx >= 0 && idx < this._count)) {
      return NaN;
    }
    const dimStore = this._chunks[dim];
    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;
  }
  getValues(dimensions, idx) {
    const values = [];
    let dimArr = [];
    if (idx == null) {
      idx = dimensions;
      dimensions = [];
      for (let i = 0; i < this._dimensions.length; i++) {
        dimArr.push(i);
      }
    } else {
      dimArr = dimensions;
    }
    for (let i = 0, len2 = dimArr.length; i < len2; i++) {
      values.push(this.get(dimArr[i], idx));
    }
    return values;
  }
  getByRawIndex(dim, rawIdx) {
    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {
      return NaN;
    }
    const dimStore = this._chunks[dim];
    return dimStore ? dimStore[rawIdx] : NaN;
  }
  getSum(dim) {
    const dimData = this._chunks[dim];
    let sum2 = 0;
    if (dimData) {
      for (let i = 0, len2 = this.count(); i < len2; i++) {
        const value = this.get(dim, i);
        if (!isNaN(value)) {
          sum2 += value;
        }
      }
    }
    return sum2;
  }
  getMedian(dim) {
    const dimDataArray = [];
    this.each([dim], function(val) {
      if (!isNaN(val)) {
        dimDataArray.push(val);
      }
    });
    const sortedDimDataArray = dimDataArray.sort(function(a, b) {
      return a - b;
    });
    const len2 = this.count();
    return len2 === 0 ? 0 : len2 % 2 === 1 ? sortedDimDataArray[(len2 - 1) / 2] : (sortedDimDataArray[len2 / 2] + sortedDimDataArray[len2 / 2 - 1]) / 2;
  }
  indexOfRawIndex(rawIndex) {
    if (rawIndex >= this._rawCount || rawIndex < 0) {
      return -1;
    }
    if (!this._indices) {
      return rawIndex;
    }
    const indices = this._indices;
    const rawDataIndex = indices[rawIndex];
    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {
      return rawIndex;
    }
    let left = 0;
    let right = this._count - 1;
    while (left <= right) {
      const mid = (left + right) / 2 | 0;
      if (indices[mid] < rawIndex) {
        left = mid + 1;
      } else if (indices[mid] > rawIndex) {
        right = mid - 1;
      } else {
        return mid;
      }
    }
    return -1;
  }
  indicesOfNearest(dim, value, maxDistance) {
    const chunks = this._chunks;
    const dimData = chunks[dim];
    const nearestIndices = [];
    if (!dimData) {
      return nearestIndices;
    }
    if (maxDistance == null) {
      maxDistance = Infinity;
    }
    let minDist = Infinity;
    let minDiff = -1;
    let nearestIndicesLen = 0;
    for (let i = 0, len2 = this.count(); i < len2; i++) {
      const dataIndex = this.getRawIndex(i);
      const diff = value - dimData[dataIndex];
      const dist3 = Math.abs(diff);
      if (dist3 <= maxDistance) {
        if (dist3 < minDist || dist3 === minDist && diff >= 0 && minDiff < 0) {
          minDist = dist3;
          minDiff = diff;
          nearestIndicesLen = 0;
        }
        if (diff === minDiff) {
          nearestIndices[nearestIndicesLen++] = i;
        }
      }
    }
    nearestIndices.length = nearestIndicesLen;
    return nearestIndices;
  }
  getIndices() {
    let newIndices;
    const indices = this._indices;
    if (indices) {
      const Ctor = indices.constructor;
      const thisCount = this._count;
      if (Ctor === Array) {
        newIndices = new Ctor(thisCount);
        for (let i = 0; i < thisCount; i++) {
          newIndices[i] = indices[i];
        }
      } else {
        newIndices = new Ctor(indices.buffer, 0, thisCount);
      }
    } else {
      const Ctor = getIndicesCtor(this._rawCount);
      newIndices = new Ctor(this.count());
      for (let i = 0; i < newIndices.length; i++) {
        newIndices[i] = i;
      }
    }
    return newIndices;
  }
  filter(dims, cb) {
    if (!this._count) {
      return this;
    }
    const newStore = this.clone();
    const count2 = newStore.count();
    const Ctor = getIndicesCtor(newStore._rawCount);
    const newIndices = new Ctor(count2);
    const value = [];
    const dimSize = dims.length;
    let offset = 0;
    const dim0 = dims[0];
    const chunks = newStore._chunks;
    for (let i = 0; i < count2; i++) {
      let keep;
      const rawIdx = newStore.getRawIndex(i);
      if (dimSize === 0) {
        keep = cb(i);
      } else if (dimSize === 1) {
        const val = chunks[dim0][rawIdx];
        keep = cb(val, i);
      } else {
        let k = 0;
        for (; k < dimSize; k++) {
          value[k] = chunks[dims[k]][rawIdx];
        }
        value[k] = i;
        keep = cb.apply(null, value);
      }
      if (keep) {
        newIndices[offset++] = rawIdx;
      }
    }
    if (offset < count2) {
      newStore._indices = newIndices;
    }
    newStore._count = offset;
    newStore._extent = [];
    newStore._updateGetRawIdx();
    return newStore;
  }
  selectRange(range) {
    const newStore = this.clone();
    const len2 = newStore._count;
    if (!len2) {
      return this;
    }
    const dims = keys(range);
    const dimSize = dims.length;
    if (!dimSize) {
      return this;
    }
    const originalCount = newStore.count();
    const Ctor = getIndicesCtor(newStore._rawCount);
    const newIndices = new Ctor(originalCount);
    let offset = 0;
    const dim0 = dims[0];
    const min3 = range[dim0][0];
    const max3 = range[dim0][1];
    const storeArr = newStore._chunks;
    let quickFinished = false;
    if (!newStore._indices) {
      let idx = 0;
      if (dimSize === 1) {
        const dimStorage = storeArr[dims[0]];
        for (let i = 0; i < len2; i++) {
          const val = dimStorage[i];
          if (val >= min3 && val <= max3 || isNaN(val)) {
            newIndices[offset++] = idx;
          }
          idx++;
        }
        quickFinished = true;
      } else if (dimSize === 2) {
        const dimStorage = storeArr[dims[0]];
        const dimStorage2 = storeArr[dims[1]];
        const min23 = range[dims[1]][0];
        const max23 = range[dims[1]][1];
        for (let i = 0; i < len2; i++) {
          const val = dimStorage[i];
          const val2 = dimStorage2[i];
          if ((val >= min3 && val <= max3 || isNaN(val)) && (val2 >= min23 && val2 <= max23 || isNaN(val2))) {
            newIndices[offset++] = idx;
          }
          idx++;
        }
        quickFinished = true;
      }
    }
    if (!quickFinished) {
      if (dimSize === 1) {
        for (let i = 0; i < originalCount; i++) {
          const rawIndex = newStore.getRawIndex(i);
          const val = storeArr[dims[0]][rawIndex];
          if (val >= min3 && val <= max3 || isNaN(val)) {
            newIndices[offset++] = rawIndex;
          }
        }
      } else {
        for (let i = 0; i < originalCount; i++) {
          let keep = true;
          const rawIndex = newStore.getRawIndex(i);
          for (let k = 0; k < dimSize; k++) {
            const dimk = dims[k];
            const val = storeArr[dimk][rawIndex];
            if (val < range[dimk][0] || val > range[dimk][1]) {
              keep = false;
            }
          }
          if (keep) {
            newIndices[offset++] = newStore.getRawIndex(i);
          }
        }
      }
    }
    if (offset < originalCount) {
      newStore._indices = newIndices;
    }
    newStore._count = offset;
    newStore._extent = [];
    newStore._updateGetRawIdx();
    return newStore;
  }
  map(dims, cb) {
    const target = this.clone(dims);
    this._updateDims(target, dims, cb);
    return target;
  }
  modify(dims, cb) {
    this._updateDims(this, dims, cb);
  }
  _updateDims(target, dims, cb) {
    const targetChunks = target._chunks;
    const tmpRetValue = [];
    const dimSize = dims.length;
    const dataCount = target.count();
    const values = [];
    const rawExtent = target._rawExtent;
    for (let i = 0; i < dims.length; i++) {
      rawExtent[dims[i]] = getInitialExtent();
    }
    for (let dataIndex = 0; dataIndex < dataCount; dataIndex++) {
      const rawIndex = target.getRawIndex(dataIndex);
      for (let k = 0; k < dimSize; k++) {
        values[k] = targetChunks[dims[k]][rawIndex];
      }
      values[dimSize] = dataIndex;
      let retValue = cb && cb.apply(null, values);
      if (retValue != null) {
        if (typeof retValue !== "object") {
          tmpRetValue[0] = retValue;
          retValue = tmpRetValue;
        }
        for (let i = 0; i < retValue.length; i++) {
          const dim = dims[i];
          const val = retValue[i];
          const rawExtentOnDim = rawExtent[dim];
          const dimStore = targetChunks[dim];
          if (dimStore) {
            dimStore[rawIndex] = val;
          }
          if (val < rawExtentOnDim[0]) {
            rawExtentOnDim[0] = val;
          }
          if (val > rawExtentOnDim[1]) {
            rawExtentOnDim[1] = val;
          }
        }
      }
    }
  }
  lttbDownSample(valueDimension, rate) {
    const target = this.clone([valueDimension], true);
    const targetStorage = target._chunks;
    const dimStore = targetStorage[valueDimension];
    const len2 = this.count();
    let sampledIndex = 0;
    const frameSize = Math.floor(1 / rate);
    let currentRawIndex = this.getRawIndex(0);
    let maxArea;
    let area;
    let nextRawIndex;
    const newIndices = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(len2 / frameSize) + 2) * 2, len2));
    newIndices[sampledIndex++] = currentRawIndex;
    for (let i = 1; i < len2 - 1; i += frameSize) {
      const nextFrameStart = Math.min(i + frameSize, len2 - 1);
      const nextFrameEnd = Math.min(i + frameSize * 2, len2);
      const avgX = (nextFrameEnd + nextFrameStart) / 2;
      let avgY = 0;
      for (let idx = nextFrameStart; idx < nextFrameEnd; idx++) {
        const rawIndex = this.getRawIndex(idx);
        const y = dimStore[rawIndex];
        if (isNaN(y)) {
          continue;
        }
        avgY += y;
      }
      avgY /= nextFrameEnd - nextFrameStart;
      const frameStart = i;
      const frameEnd = Math.min(i + frameSize, len2);
      const pointAX = i - 1;
      const pointAY = dimStore[currentRawIndex];
      maxArea = -1;
      nextRawIndex = frameStart;
      let firstNaNIndex = -1;
      let countNaN = 0;
      for (let idx = frameStart; idx < frameEnd; idx++) {
        const rawIndex = this.getRawIndex(idx);
        const y = dimStore[rawIndex];
        if (isNaN(y)) {
          countNaN++;
          if (firstNaNIndex < 0) {
            firstNaNIndex = rawIndex;
          }
          continue;
        }
        area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));
        if (area > maxArea) {
          maxArea = area;
          nextRawIndex = rawIndex;
        }
      }
      if (countNaN > 0 && countNaN < frameEnd - frameStart) {
        newIndices[sampledIndex++] = Math.min(firstNaNIndex, nextRawIndex);
        nextRawIndex = Math.max(firstNaNIndex, nextRawIndex);
      }
      newIndices[sampledIndex++] = nextRawIndex;
      currentRawIndex = nextRawIndex;
    }
    newIndices[sampledIndex++] = this.getRawIndex(len2 - 1);
    target._count = sampledIndex;
    target._indices = newIndices;
    target.getRawIndex = this._getRawIdx;
    return target;
  }
  downSample(dimension, rate, sampleValue, sampleIndex) {
    const target = this.clone([dimension], true);
    const targetStorage = target._chunks;
    const frameValues = [];
    let frameSize = Math.floor(1 / rate);
    const dimStore = targetStorage[dimension];
    const len2 = this.count();
    const rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent();
    const newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len2 / frameSize));
    let offset = 0;
    for (let i = 0; i < len2; i += frameSize) {
      if (frameSize > len2 - i) {
        frameSize = len2 - i;
        frameValues.length = frameSize;
      }
      for (let k = 0; k < frameSize; k++) {
        const dataIdx = this.getRawIndex(i + k);
        frameValues[k] = dimStore[dataIdx];
      }
      const value = sampleValue(frameValues);
      const sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len2 - 1));
      dimStore[sampleFrameIdx] = value;
      if (value < rawExtentOnDim[0]) {
        rawExtentOnDim[0] = value;
      }
      if (value > rawExtentOnDim[1]) {
        rawExtentOnDim[1] = value;
      }
      newIndices[offset++] = sampleFrameIdx;
    }
    target._count = offset;
    target._indices = newIndices;
    target._updateGetRawIdx();
    return target;
  }
  each(dims, cb) {
    if (!this._count) {
      return;
    }
    const dimSize = dims.length;
    const chunks = this._chunks;
    for (let i = 0, len2 = this.count(); i < len2; i++) {
      const rawIdx = this.getRawIndex(i);
      switch (dimSize) {
        case 0:
          cb(i);
          break;
        case 1:
          cb(chunks[dims[0]][rawIdx], i);
          break;
        case 2:
          cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i);
          break;
        default:
          let k = 0;
          const value = [];
          for (; k < dimSize; k++) {
            value[k] = chunks[dims[k]][rawIdx];
          }
          value[k] = i;
          cb.apply(null, value);
      }
    }
  }
  getDataExtent(dim) {
    const dimData = this._chunks[dim];
    const initialExtent = getInitialExtent();
    if (!dimData) {
      return initialExtent;
    }
    const currEnd = this.count();
    const useRaw = !this._indices;
    let dimExtent;
    if (useRaw) {
      return this._rawExtent[dim].slice();
    }
    dimExtent = this._extent[dim];
    if (dimExtent) {
      return dimExtent.slice();
    }
    dimExtent = initialExtent;
    let min3 = dimExtent[0];
    let max3 = dimExtent[1];
    for (let i = 0; i < currEnd; i++) {
      const rawIdx = this.getRawIndex(i);
      const value = dimData[rawIdx];
      value < min3 && (min3 = value);
      value > max3 && (max3 = value);
    }
    dimExtent = [min3, max3];
    this._extent[dim] = dimExtent;
    return dimExtent;
  }
  getRawDataItem(idx) {
    const rawIdx = this.getRawIndex(idx);
    if (!this._provider.persistent) {
      const val = [];
      const chunks = this._chunks;
      for (let i = 0; i < chunks.length; i++) {
        val.push(chunks[i][rawIdx]);
      }
      return val;
    } else {
      return this._provider.getItem(rawIdx);
    }
  }
  clone(clonedDims, ignoreIndices) {
    const target = new DataStore2();
    const chunks = this._chunks;
    const clonedDimsMap = clonedDims && reduce(clonedDims, (obj, dimIdx) => {
      obj[dimIdx] = true;
      return obj;
    }, {});
    if (clonedDimsMap) {
      for (let i = 0; i < chunks.length; i++) {
        target._chunks[i] = !clonedDimsMap[i] ? chunks[i] : cloneChunk(chunks[i]);
      }
    } else {
      target._chunks = chunks;
    }
    this._copyCommonProps(target);
    if (!ignoreIndices) {
      target._indices = this._cloneIndices();
    }
    target._updateGetRawIdx();
    return target;
  }
  _copyCommonProps(target) {
    target._count = this._count;
    target._rawCount = this._rawCount;
    target._provider = this._provider;
    target._dimensions = this._dimensions;
    target._extent = clone(this._extent);
    target._rawExtent = clone(this._rawExtent);
  }
  _cloneIndices() {
    if (this._indices) {
      const Ctor = this._indices.constructor;
      let indices;
      if (Ctor === Array) {
        const thisCount = this._indices.length;
        indices = new Ctor(thisCount);
        for (let i = 0; i < thisCount; i++) {
          indices[i] = this._indices[i];
        }
      } else {
        indices = new Ctor(this._indices);
      }
      return indices;
    }
    return null;
  }
  _getRawIdxIdentity(idx) {
    return idx;
  }
  _getRawIdx(idx) {
    if (idx < this._count && idx >= 0) {
      return this._indices[idx];
    }
    return -1;
  }
  _updateGetRawIdx() {
    this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
  }
};
var DataStore = DataStore2;
DataStore.internalField = function() {
  function getDimValueSimply(dataItem, property, dataIndex, dimIndex) {
    return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex]);
  }
  defaultDimValueGetters = {
    arrayRows: getDimValueSimply,
    objectRows(dataItem, property, dataIndex, dimIndex) {
      return parseDataValue(dataItem[property], this._dimensions[dimIndex]);
    },
    keyedColumns: getDimValueSimply,
    original(dataItem, property, dataIndex, dimIndex) {
      const value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);
      return parseDataValue(value instanceof Array ? value[dimIndex] : value, this._dimensions[dimIndex]);
    },
    typedArray: function(dataItem, property, dataIndex, dimIndex) {
      return dataItem[dimIndex];
    }
  };
}();
var DataStore_default = DataStore;

// src/data/helper/sourceManager.ts
var SourceManager = class {
  constructor(sourceHost) {
    this._sourceList = [];
    this._storeList = [];
    this._upstreamSignList = [];
    this._versionSignBase = 0;
    this._dirty = true;
    this._sourceHost = sourceHost;
  }
  dirty() {
    this._setLocalSource([], []);
    this._storeList = [];
    this._dirty = true;
  }
  _setLocalSource(sourceList, upstreamSignList) {
    this._sourceList = sourceList;
    this._upstreamSignList = upstreamSignList;
    this._versionSignBase++;
    if (this._versionSignBase > 9e10) {
      this._versionSignBase = 0;
    }
  }
  _getVersionSign() {
    return this._sourceHost.uid + "_" + this._versionSignBase;
  }
  prepareSource() {
    if (this._isDirty()) {
      this._createSource();
      this._dirty = false;
    }
  }
  _createSource() {
    this._setLocalSource([], []);
    const sourceHost = this._sourceHost;
    const upSourceMgrList = this._getUpstreamSourceManagers();
    const hasUpstream = !!upSourceMgrList.length;
    let resultSourceList;
    let upstreamSignList;
    if (isSeries(sourceHost)) {
      const seriesModel = sourceHost;
      let data;
      let sourceFormat;
      let upSource;
      if (hasUpstream) {
        const upSourceMgr = upSourceMgrList[0];
        upSourceMgr.prepareSource();
        upSource = upSourceMgr.getSource();
        data = upSource.data;
        sourceFormat = upSource.sourceFormat;
        upstreamSignList = [upSourceMgr._getVersionSign()];
      } else {
        data = seriesModel.get("data", true);
        sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;
        upstreamSignList = [];
      }
      const newMetaRawOption = this._getSourceMetaRawOption() || {};
      const upMetaRawOption = upSource && upSource.metaRawOption || {};
      const seriesLayoutBy = retrieve2(newMetaRawOption.seriesLayoutBy, upMetaRawOption.seriesLayoutBy) || null;
      const sourceHeader = retrieve2(newMetaRawOption.sourceHeader, upMetaRawOption.sourceHeader);
      const dimensions = retrieve2(newMetaRawOption.dimensions, upMetaRawOption.dimensions);
      const needsCreateSource = seriesLayoutBy !== upMetaRawOption.seriesLayoutBy || !!sourceHeader !== !!upMetaRawOption.sourceHeader || dimensions;
      resultSourceList = needsCreateSource ? [createSource(data, {seriesLayoutBy, sourceHeader, dimensions}, sourceFormat)] : [];
    } else {
      const datasetModel = sourceHost;
      if (hasUpstream) {
        const result = this._applyTransform(upSourceMgrList);
        resultSourceList = result.sourceList;
        upstreamSignList = result.upstreamSignList;
      } else {
        const sourceData = datasetModel.get("source", true);
        resultSourceList = [createSource(sourceData, this._getSourceMetaRawOption(), null)];
        upstreamSignList = [];
      }
    }
    if (true) {
      assert(resultSourceList && upstreamSignList);
    }
    this._setLocalSource(resultSourceList, upstreamSignList);
  }
  _applyTransform(upMgrList) {
    const datasetModel = this._sourceHost;
    const transformOption = datasetModel.get("transform", true);
    const fromTransformResult = datasetModel.get("fromTransformResult", true);
    if (true) {
      assert(fromTransformResult != null || transformOption != null);
    }
    if (fromTransformResult != null) {
      let errMsg = "";
      if (upMgrList.length !== 1) {
        if (true) {
          errMsg = "When using `fromTransformResult`, there should be only one upstream dataset";
        }
        doThrow(errMsg);
      }
    }
    let sourceList;
    const upSourceList = [];
    const upstreamSignList = [];
    each(upMgrList, (upMgr) => {
      upMgr.prepareSource();
      const upSource = upMgr.getSource(fromTransformResult || 0);
      let errMsg = "";
      if (fromTransformResult != null && !upSource) {
        if (true) {
          errMsg = "Can not retrieve result by `fromTransformResult`: " + fromTransformResult;
        }
        doThrow(errMsg);
      }
      upSourceList.push(upSource);
      upstreamSignList.push(upMgr._getVersionSign());
    });
    if (transformOption) {
      sourceList = applyDataTransform(transformOption, upSourceList, {datasetIndex: datasetModel.componentIndex});
    } else if (fromTransformResult != null) {
      sourceList = [cloneSourceShallow(upSourceList[0])];
    }
    return {sourceList, upstreamSignList};
  }
  _isDirty() {
    if (this._dirty) {
      return true;
    }
    const upSourceMgrList = this._getUpstreamSourceManagers();
    for (let i = 0; i < upSourceMgrList.length; i++) {
      const upSrcMgr = upSourceMgrList[i];
      if (upSrcMgr._isDirty() || this._upstreamSignList[i] !== upSrcMgr._getVersionSign()) {
        return true;
      }
    }
  }
  getSource(sourceIndex) {
    sourceIndex = sourceIndex || 0;
    const source = this._sourceList[sourceIndex];
    if (!source) {
      const upSourceMgrList = this._getUpstreamSourceManagers();
      return upSourceMgrList[0] && upSourceMgrList[0].getSource(sourceIndex);
    }
    return source;
  }
  getSharedDataStore(seriesDimRequest) {
    if (true) {
      assert(isSeries(this._sourceHost), "Can only call getDataStore on series source manager.");
    }
    const schema = seriesDimRequest.makeStoreSchema();
    return this._innerGetDataStore(schema.dimensions, seriesDimRequest.source, schema.hash);
  }
  _innerGetDataStore(storeDims, seriesSource, sourceReadKey) {
    const sourceIndex = 0;
    const storeList = this._storeList;
    let cachedStoreMap = storeList[sourceIndex];
    if (!cachedStoreMap) {
      cachedStoreMap = storeList[sourceIndex] = {};
    }
    let cachedStore = cachedStoreMap[sourceReadKey];
    if (!cachedStore) {
      const upSourceMgr = this._getUpstreamSourceManagers()[0];
      if (isSeries(this._sourceHost) && upSourceMgr) {
        cachedStore = upSourceMgr._innerGetDataStore(storeDims, seriesSource, sourceReadKey);
      } else {
        cachedStore = new DataStore_default();
        cachedStore.initData(new DefaultDataProvider(seriesSource, storeDims.length), storeDims);
      }
      cachedStoreMap[sourceReadKey] = cachedStore;
    }
    return cachedStore;
  }
  _getUpstreamSourceManagers() {
    const sourceHost = this._sourceHost;
    if (isSeries(sourceHost)) {
      const datasetModel = querySeriesUpstreamDatasetModel(sourceHost);
      return !datasetModel ? [] : [datasetModel.getSourceManager()];
    } else {
      return map(queryDatasetUpstreamDatasetModels(sourceHost), (datasetModel) => datasetModel.getSourceManager());
    }
  }
  _getSourceMetaRawOption() {
    const sourceHost = this._sourceHost;
    let seriesLayoutBy;
    let sourceHeader;
    let dimensions;
    if (isSeries(sourceHost)) {
      seriesLayoutBy = sourceHost.get("seriesLayoutBy", true);
      sourceHeader = sourceHost.get("sourceHeader", true);
      dimensions = sourceHost.get("dimensions", true);
    } else if (!this._getUpstreamSourceManagers().length) {
      const model = sourceHost;
      seriesLayoutBy = model.get("seriesLayoutBy", true);
      sourceHeader = model.get("sourceHeader", true);
      dimensions = model.get("dimensions", true);
    }
    return {seriesLayoutBy, sourceHeader, dimensions};
  }
};
function disableTransformOptionMerge(datasetModel) {
  const transformOption = datasetModel.option.transform;
  transformOption && setAsPrimitive(datasetModel.option.transform);
}
function isSeries(sourceHost) {
  return sourceHost.mainType === "series";
}
function doThrow(errMsg) {
  throw new Error(errMsg);
}

// src/component/tooltip/tooltipMarkup.ts
var TOOLTIP_LINE_HEIGHT_CSS = "line-height:1";
function getTooltipTextStyle(textStyle, renderMode) {
  const nameFontColor = textStyle.color || "#6e7079";
  const nameFontSize = textStyle.fontSize || 12;
  const nameFontWeight = textStyle.fontWeight || "400";
  const valueFontColor = textStyle.color || "#464646";
  const valueFontSize = textStyle.fontSize || 14;
  const valueFontWeight = textStyle.fontWeight || "900";
  if (renderMode === "html") {
    return {
      nameStyle: `font-size:${encodeHTML(nameFontSize + "")}px;color:${encodeHTML(nameFontColor)};font-weight:${encodeHTML(nameFontWeight + "")}`,
      valueStyle: `font-size:${encodeHTML(valueFontSize + "")}px;color:${encodeHTML(valueFontColor)};font-weight:${encodeHTML(valueFontWeight + "")}`
    };
  } else {
    return {
      nameStyle: {
        fontSize: nameFontSize,
        fill: nameFontColor,
        fontWeight: nameFontWeight
      },
      valueStyle: {
        fontSize: valueFontSize,
        fill: valueFontColor,
        fontWeight: valueFontWeight
      }
    };
  }
}
var HTML_GAPS = [0, 10, 20, 30];
var RICH_TEXT_GAPS = ["", "\n", "\n\n", "\n\n\n"];
function createTooltipMarkup(type, option) {
  option.type = type;
  return option;
}
function isSectionFragment(frag) {
  return frag.type === "section";
}
function getBuilder(frag) {
  return isSectionFragment(frag) ? buildSection : buildNameValue;
}
function getBlockGapLevel(frag) {
  if (isSectionFragment(frag)) {
    let gapLevel = 0;
    const subBlockLen = frag.blocks.length;
    const hasInnerGap = subBlockLen > 1 || subBlockLen > 0 && !frag.noHeader;
    each(frag.blocks, function(subBlock) {
      const subGapLevel = getBlockGapLevel(subBlock);
      if (subGapLevel >= gapLevel) {
        gapLevel = subGapLevel + +(hasInnerGap && (!subGapLevel || isSectionFragment(subBlock) && !subBlock.noHeader));
      }
    });
    return gapLevel;
  }
  return 0;
}
function buildSection(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
  const noHeader = fragment.noHeader;
  const gaps = getGap(getBlockGapLevel(fragment));
  const subMarkupTextList = [];
  let subBlocks = fragment.blocks || [];
  assert(!subBlocks || isArray(subBlocks));
  subBlocks = subBlocks || [];
  const orderMode = ctx.orderMode;
  if (fragment.sortBlocks && orderMode) {
    subBlocks = subBlocks.slice();
    const orderMap = {valueAsc: "asc", valueDesc: "desc"};
    if (hasOwn(orderMap, orderMode)) {
      const comparator = new SortOrderComparator(orderMap[orderMode], null);
      subBlocks.sort((a, b) => comparator.evaluate(a.sortParam, b.sortParam));
    } else if (orderMode === "seriesDesc") {
      subBlocks.reverse();
    }
  }
  each(subBlocks, function(subBlock, idx) {
    const valueFormatter = fragment.valueFormatter;
    const subMarkupText2 = getBuilder(subBlock)(valueFormatter ? extend(extend({}, ctx), {valueFormatter}) : ctx, subBlock, idx > 0 ? gaps.html : 0, toolTipTextStyle);
    subMarkupText2 != null && subMarkupTextList.push(subMarkupText2);
  });
  const subMarkupText = ctx.renderMode === "richText" ? subMarkupTextList.join(gaps.richText) : wrapBlockHTML(subMarkupTextList.join(""), noHeader ? topMarginForOuterGap : gaps.html);
  if (noHeader) {
    return subMarkupText;
  }
  const displayableHeader = makeValueReadable(fragment.header, "ordinal", ctx.useUTC);
  const {nameStyle} = getTooltipTextStyle(toolTipTextStyle, ctx.renderMode);
  if (ctx.renderMode === "richText") {
    return wrapInlineNameRichText(ctx, displayableHeader, nameStyle) + gaps.richText + subMarkupText;
  } else {
    return wrapBlockHTML(`<div style="${nameStyle};${TOOLTIP_LINE_HEIGHT_CSS};">` + encodeHTML(displayableHeader) + "</div>" + subMarkupText, topMarginForOuterGap);
  }
}
function buildNameValue(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
  const renderMode = ctx.renderMode;
  const noName = fragment.noName;
  const noValue = fragment.noValue;
  const noMarker = !fragment.markerType;
  const name = fragment.name;
  const useUTC = ctx.useUTC;
  const valueFormatter = fragment.valueFormatter || ctx.valueFormatter || ((value) => {
    value = isArray(value) ? value : [value];
    return map(value, (val, idx) => makeValueReadable(val, isArray(valueTypeOption) ? valueTypeOption[idx] : valueTypeOption, useUTC));
  });
  if (noName && noValue) {
    return;
  }
  const markerStr = noMarker ? "" : ctx.markupStyleCreator.makeTooltipMarker(fragment.markerType, fragment.markerColor || "#333", renderMode);
  const readableName = noName ? "" : makeValueReadable(name, "ordinal", useUTC);
  const valueTypeOption = fragment.valueType;
  const readableValueList = noValue ? [] : valueFormatter(fragment.value, fragment.dataIndex);
  const valueAlignRight = !noMarker || !noName;
  const valueCloseToMarker = !noMarker && noName;
  const {nameStyle, valueStyle} = getTooltipTextStyle(toolTipTextStyle, renderMode);
  return renderMode === "richText" ? (noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameRichText(ctx, readableName, nameStyle)) + (noValue ? "" : wrapInlineValueRichText(ctx, readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)) : wrapBlockHTML((noMarker ? "" : markerStr) + (noName ? "" : wrapInlineNameHTML(readableName, !noMarker, nameStyle)) + (noValue ? "" : wrapInlineValueHTML(readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)), topMarginForOuterGap);
}
function buildTooltipMarkup(fragment, markupStyleCreator, renderMode, orderMode, useUTC, toolTipTextStyle) {
  if (!fragment) {
    return;
  }
  const builder = getBuilder(fragment);
  const ctx = {
    useUTC,
    renderMode,
    orderMode,
    markupStyleCreator,
    valueFormatter: fragment.valueFormatter
  };
  return builder(ctx, fragment, 0, toolTipTextStyle);
}
function getGap(gapLevel) {
  return {
    html: HTML_GAPS[gapLevel],
    richText: RICH_TEXT_GAPS[gapLevel]
  };
}
function wrapBlockHTML(encodedContent, topGap) {
  const clearfix = '<div style="clear:both"></div>';
  const marginCSS = `margin: ${topGap}px 0 0`;
  return `<div style="${marginCSS};${TOOLTIP_LINE_HEIGHT_CSS};">` + encodedContent + clearfix + "</div>";
}
function wrapInlineNameHTML(name, leftHasMarker, style) {
  const marginCss = leftHasMarker ? "margin-left:2px" : "";
  return `<span style="${style};${marginCss}">` + encodeHTML(name) + "</span>";
}
function wrapInlineValueHTML(valueList, alignRight, valueCloseToMarker, style) {
  const paddingStr = valueCloseToMarker ? "10px" : "20px";
  const alignCSS = alignRight ? `float:right;margin-left:${paddingStr}` : "";
  valueList = isArray(valueList) ? valueList : [valueList];
  return `<span style="${alignCSS};${style}">` + map(valueList, (value) => encodeHTML(value)).join("&nbsp;&nbsp;") + "</span>";
}
function wrapInlineNameRichText(ctx, name, style) {
  return ctx.markupStyleCreator.wrapRichTextStyle(name, style);
}
function wrapInlineValueRichText(ctx, values, alignRight, valueCloseToMarker, style) {
  const styles = [style];
  const paddingLeft = valueCloseToMarker ? 10 : 20;
  alignRight && styles.push({padding: [0, 0, 0, paddingLeft], align: "right"});
  return ctx.markupStyleCreator.wrapRichTextStyle(isArray(values) ? values.join("  ") : values, styles);
}
function retrieveVisualColorForTooltipMarker(series, dataIndex) {
  const style = series.getData().getItemVisual(dataIndex, "style");
  const color2 = style[series.visualDrawType];
  return convertToColorString(color2);
}
function getPaddingFromTooltipModel(model, renderMode) {
  const padding = model.get("padding");
  return padding != null ? padding : renderMode === "richText" ? [8, 10] : 10;
}
var TooltipMarkupStyleCreator = class {
  constructor() {
    this.richTextStyles = {};
    this._nextStyleNameId = getRandomIdBase();
  }
  _generateStyleName() {
    return "__EC_aUTo_" + this._nextStyleNameId++;
  }
  makeTooltipMarker(markerType, colorStr, renderMode) {
    const markerId = renderMode === "richText" ? this._generateStyleName() : null;
    const marker = getTooltipMarker({
      color: colorStr,
      type: markerType,
      renderMode,
      markerId
    });
    if (isString(marker)) {
      return marker;
    } else {
      if (true) {
        assert(markerId);
      }
      this.richTextStyles[markerId] = marker.style;
      return marker.content;
    }
  }
  wrapRichTextStyle(text, styles) {
    const finalStl = {};
    if (isArray(styles)) {
      each(styles, (stl) => extend(finalStl, stl));
    } else {
      extend(finalStl, styles);
    }
    const styleName = this._generateStyleName();
    this.richTextStyles[styleName] = finalStl;
    return `{${styleName}|${text}}`;
  }
};

// src/component/tooltip/seriesFormatTooltip.ts
function defaultSeriesFormatTooltip(opt) {
  const series = opt.series;
  const dataIndex = opt.dataIndex;
  const multipleSeries = opt.multipleSeries;
  const data = series.getData();
  const tooltipDims = data.mapDimensionsAll("defaultedTooltip");
  const tooltipDimLen = tooltipDims.length;
  const value = series.getRawValue(dataIndex);
  const isValueArr = isArray(value);
  const markerColor = retrieveVisualColorForTooltipMarker(series, dataIndex);
  let inlineValue;
  let inlineValueType;
  let subBlocks;
  let sortParam;
  if (tooltipDimLen > 1 || isValueArr && !tooltipDimLen) {
    const formatArrResult = formatTooltipArrayValue(value, series, dataIndex, tooltipDims, markerColor);
    inlineValue = formatArrResult.inlineValues;
    inlineValueType = formatArrResult.inlineValueTypes;
    subBlocks = formatArrResult.blocks;
    sortParam = formatArrResult.inlineValues[0];
  } else if (tooltipDimLen) {
    const dimInfo = data.getDimensionInfo(tooltipDims[0]);
    sortParam = inlineValue = retrieveRawValue(data, dataIndex, tooltipDims[0]);
    inlineValueType = dimInfo.type;
  } else {
    sortParam = inlineValue = isValueArr ? value[0] : value;
  }
  const seriesNameSpecified = isNameSpecified(series);
  const seriesName = seriesNameSpecified && series.name || "";
  const itemName = data.getName(dataIndex);
  const inlineName = multipleSeries ? seriesName : itemName;
  return createTooltipMarkup("section", {
    header: seriesName,
    noHeader: multipleSeries || !seriesNameSpecified,
    sortParam,
    blocks: [
      createTooltipMarkup("nameValue", {
        markerType: "item",
        markerColor,
        name: inlineName,
        noName: !trim(inlineName),
        value: inlineValue,
        valueType: inlineValueType,
        dataIndex
      })
    ].concat(subBlocks || [])
  });
}
function formatTooltipArrayValue(value, series, dataIndex, tooltipDims, colorStr) {
  const data = series.getData();
  const isValueMultipleLine = reduce(value, function(isValueMultipleLine2, val, idx) {
    const dimItem = data.getDimensionInfo(idx);
    return isValueMultipleLine2 = isValueMultipleLine2 || dimItem && dimItem.tooltip !== false && dimItem.displayName != null;
  }, false);
  const inlineValues = [];
  const inlineValueTypes = [];
  const blocks = [];
  tooltipDims.length ? each(tooltipDims, function(dim) {
    setEachItem(retrieveRawValue(data, dataIndex, dim), dim);
  }) : each(value, setEachItem);
  function setEachItem(val, dim) {
    const dimInfo = data.getDimensionInfo(dim);
    if (!dimInfo || dimInfo.otherDims.tooltip === false) {
      return;
    }
    if (isValueMultipleLine) {
      blocks.push(createTooltipMarkup("nameValue", {
        markerType: "subItem",
        markerColor: colorStr,
        name: dimInfo.displayName,
        value: val,
        valueType: dimInfo.type
      }));
    } else {
      inlineValues.push(val);
      inlineValueTypes.push(dimInfo.type);
    }
  }
  return {inlineValues, inlineValueTypes, blocks};
}

// src/model/Series.ts
var inner2 = makeInner();
function getSelectionKey(data, dataIndex) {
  return data.getName(dataIndex) || data.getId(dataIndex);
}
var SERIES_UNIVERSAL_TRANSITION_PROP = "__universalTransitionEnabled";
var SeriesModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this._selectedDataIndicesMap = {};
  }
  init(option, parentModel, ecModel) {
    this.seriesIndex = this.componentIndex;
    this.dataTask = createTask({
      count: dataTaskCount,
      reset: dataTaskReset
    });
    this.dataTask.context = {model: this};
    this.mergeDefaultAndTheme(option, ecModel);
    const sourceManager = inner2(this).sourceManager = new SourceManager(this);
    sourceManager.prepareSource();
    const data = this.getInitialData(option, ecModel);
    wrapData(data, this);
    this.dataTask.context.data = data;
    if (true) {
      assert(data, "getInitialData returned invalid data.");
    }
    inner2(this).dataBeforeProcessed = data;
    autoSeriesName(this);
    this._initSelectedMapFromData(data);
  }
  mergeDefaultAndTheme(option, ecModel) {
    const layoutMode = fetchLayoutMode(this);
    const inputPositionParams = layoutMode ? getLayoutParams(option) : {};
    let themeSubType = this.subType;
    if (Component_default.hasClass(themeSubType)) {
      themeSubType += "Series";
    }
    merge(option, ecModel.getTheme().get(this.subType));
    merge(option, this.getDefaultOption());
    defaultEmphasis(option, "label", ["show"]);
    this.fillDataTextStyle(option.data);
    if (layoutMode) {
      mergeLayoutParam(option, inputPositionParams, layoutMode);
    }
  }
  mergeOption(newSeriesOption, ecModel) {
    newSeriesOption = merge(this.option, newSeriesOption, true);
    this.fillDataTextStyle(newSeriesOption.data);
    const layoutMode = fetchLayoutMode(this);
    if (layoutMode) {
      mergeLayoutParam(this.option, newSeriesOption, layoutMode);
    }
    const sourceManager = inner2(this).sourceManager;
    sourceManager.dirty();
    sourceManager.prepareSource();
    const data = this.getInitialData(newSeriesOption, ecModel);
    wrapData(data, this);
    this.dataTask.dirty();
    this.dataTask.context.data = data;
    inner2(this).dataBeforeProcessed = data;
    autoSeriesName(this);
    this._initSelectedMapFromData(data);
  }
  fillDataTextStyle(data) {
    if (data && !isTypedArray(data)) {
      const props = ["show"];
      for (let i = 0; i < data.length; i++) {
        if (data[i] && data[i].label) {
          defaultEmphasis(data[i], "label", props);
        }
      }
    }
  }
  getInitialData(option, ecModel) {
    return;
  }
  appendData(params) {
    const data = this.getRawData();
    data.appendData(params.data);
  }
  getData(dataType) {
    const task = getCurrentTask(this);
    if (task) {
      const data = task.context.data;
      return dataType == null ? data : data.getLinkedData(dataType);
    } else {
      return inner2(this).data;
    }
  }
  getAllData() {
    const mainData = this.getData();
    return mainData && mainData.getLinkedDataAll ? mainData.getLinkedDataAll() : [{data: mainData}];
  }
  setData(data) {
    const task = getCurrentTask(this);
    if (task) {
      const context = task.context;
      context.outputData = data;
      if (task !== this.dataTask) {
        context.data = data;
      }
    }
    inner2(this).data = data;
  }
  getEncode() {
    const encode = this.get("encode", true);
    if (encode) {
      return createHashMap(encode);
    }
  }
  getSourceManager() {
    return inner2(this).sourceManager;
  }
  getSource() {
    return this.getSourceManager().getSource();
  }
  getRawData() {
    return inner2(this).dataBeforeProcessed;
  }
  getColorBy() {
    const colorBy = this.get("colorBy");
    return colorBy || "series";
  }
  isColorBySeries() {
    return this.getColorBy() === "series";
  }
  getBaseAxis() {
    const coordSys = this.coordinateSystem;
    return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    return defaultSeriesFormatTooltip({
      series: this,
      dataIndex,
      multipleSeries
    });
  }
  isAnimationEnabled() {
    const ecModel = this.ecModel;
    if (env_default.node && !(ecModel && ecModel.ssr)) {
      return false;
    }
    let animationEnabled = this.getShallow("animation");
    if (animationEnabled) {
      if (this.getData().count() > this.getShallow("animationThreshold")) {
        animationEnabled = false;
      }
    }
    return !!animationEnabled;
  }
  restoreData() {
    this.dataTask.dirty();
  }
  getColorFromPalette(name, scope, requestColorNum) {
    const ecModel = this.ecModel;
    let color2 = PaletteMixin.prototype.getColorFromPalette.call(this, name, scope, requestColorNum);
    if (!color2) {
      color2 = ecModel.getColorFromPalette(name, scope, requestColorNum);
    }
    return color2;
  }
  coordDimToDataDim(coordDim) {
    return this.getRawData().mapDimensionsAll(coordDim);
  }
  getProgressive() {
    return this.get("progressive");
  }
  getProgressiveThreshold() {
    return this.get("progressiveThreshold");
  }
  select(innerDataIndices, dataType) {
    this._innerSelect(this.getData(dataType), innerDataIndices);
  }
  unselect(innerDataIndices, dataType) {
    const selectedMap = this.option.selectedMap;
    if (!selectedMap) {
      return;
    }
    const selectedMode = this.option.selectedMode;
    const data = this.getData(dataType);
    if (selectedMode === "series" || selectedMap === "all") {
      this.option.selectedMap = {};
      this._selectedDataIndicesMap = {};
      return;
    }
    for (let i = 0; i < innerDataIndices.length; i++) {
      const dataIndex = innerDataIndices[i];
      const nameOrId = getSelectionKey(data, dataIndex);
      selectedMap[nameOrId] = false;
      this._selectedDataIndicesMap[nameOrId] = -1;
    }
  }
  toggleSelect(innerDataIndices, dataType) {
    const tmpArr2 = [];
    for (let i = 0; i < innerDataIndices.length; i++) {
      tmpArr2[0] = innerDataIndices[i];
      this.isSelected(innerDataIndices[i], dataType) ? this.unselect(tmpArr2, dataType) : this.select(tmpArr2, dataType);
    }
  }
  getSelectedDataIndices() {
    if (this.option.selectedMap === "all") {
      return [].slice.call(this.getData().getIndices());
    }
    const selectedDataIndicesMap = this._selectedDataIndicesMap;
    const nameOrIds = keys(selectedDataIndicesMap);
    const dataIndices = [];
    for (let i = 0; i < nameOrIds.length; i++) {
      const dataIndex = selectedDataIndicesMap[nameOrIds[i]];
      if (dataIndex >= 0) {
        dataIndices.push(dataIndex);
      }
    }
    return dataIndices;
  }
  isSelected(dataIndex, dataType) {
    const selectedMap = this.option.selectedMap;
    if (!selectedMap) {
      return false;
    }
    const data = this.getData(dataType);
    return (selectedMap === "all" || selectedMap[getSelectionKey(data, dataIndex)]) && !data.getItemModel(dataIndex).get(["select", "disabled"]);
  }
  isUniversalTransitionEnabled() {
    if (this[SERIES_UNIVERSAL_TRANSITION_PROP]) {
      return true;
    }
    const universalTransitionOpt = this.option.universalTransition;
    if (!universalTransitionOpt) {
      return false;
    }
    if (universalTransitionOpt === true) {
      return true;
    }
    return universalTransitionOpt && universalTransitionOpt.enabled;
  }
  _innerSelect(data, innerDataIndices) {
    const option = this.option;
    const selectedMode = option.selectedMode;
    const len2 = innerDataIndices.length;
    if (!selectedMode || !len2) {
      return;
    }
    if (selectedMode === "series") {
      option.selectedMap = "all";
    } else if (selectedMode === "multiple") {
      if (!isObject(option.selectedMap)) {
        option.selectedMap = {};
      }
      const selectedMap = option.selectedMap;
      for (let i = 0; i < len2; i++) {
        const dataIndex = innerDataIndices[i];
        const nameOrId = getSelectionKey(data, dataIndex);
        selectedMap[nameOrId] = true;
        this._selectedDataIndicesMap[nameOrId] = data.getRawIndex(dataIndex);
      }
    } else if (selectedMode === "single" || selectedMode === true) {
      const lastDataIndex = innerDataIndices[len2 - 1];
      const nameOrId = getSelectionKey(data, lastDataIndex);
      option.selectedMap = {
        [nameOrId]: true
      };
      this._selectedDataIndicesMap = {
        [nameOrId]: data.getRawIndex(lastDataIndex)
      };
    }
  }
  _initSelectedMapFromData(data) {
    if (this.option.selectedMap) {
      return;
    }
    const dataIndices = [];
    if (data.hasItemOption) {
      data.each(function(idx) {
        const rawItem = data.getRawDataItem(idx);
        if (rawItem && rawItem.selected) {
          dataIndices.push(idx);
        }
      });
    }
    if (dataIndices.length > 0) {
      this._innerSelect(data, dataIndices);
    }
  }
  static registerClass(clz) {
    return Component_default.registerClass(clz);
  }
};
var SeriesModel = SeriesModel2;
SERIES_UNIVERSAL_TRANSITION_PROP;
SeriesModel.protoInitialize = function() {
  const proto2 = SeriesModel2.prototype;
  proto2.type = "series.__base__";
  proto2.seriesIndex = 0;
  proto2.ignoreStyleOnData = false;
  proto2.hasSymbolVisual = false;
  proto2.defaultSymbol = "circle";
  proto2.visualStyleAccessPath = "itemStyle";
  proto2.visualDrawType = "fill";
}();
mixin(SeriesModel, DataFormatMixin);
mixin(SeriesModel, PaletteMixin);
mountExtend(SeriesModel, Component_default);
function autoSeriesName(seriesModel) {
  const name = seriesModel.name;
  if (!isNameSpecified(seriesModel)) {
    seriesModel.name = getSeriesAutoName(seriesModel) || name;
  }
}
function getSeriesAutoName(seriesModel) {
  const data = seriesModel.getRawData();
  const dataDims = data.mapDimensionsAll("seriesName");
  const nameArr = [];
  each(dataDims, function(dataDim) {
    const dimInfo = data.getDimensionInfo(dataDim);
    dimInfo.displayName && nameArr.push(dimInfo.displayName);
  });
  return nameArr.join(" ");
}
function dataTaskCount(context) {
  return context.model.getRawData().count();
}
function dataTaskReset(context) {
  const seriesModel = context.model;
  seriesModel.setData(seriesModel.getRawData().cloneShallow());
  return dataTaskProgress;
}
function dataTaskProgress(param, context) {
  if (context.outputData && param.end > context.outputData.count()) {
    context.model.getRawData().cloneShallow(context.outputData);
  }
}
function wrapData(data, seriesModel) {
  each(concatArray(data.CHANGABLE_METHODS, data.DOWNSAMPLE_METHODS), function(methodName) {
    data.wrapMethod(methodName, curry(onDataChange, seriesModel));
  });
}
function onDataChange(seriesModel, newList) {
  const task = getCurrentTask(seriesModel);
  if (task) {
    task.setOutputEnd((newList || this).count());
  }
  return newList;
}
function getCurrentTask(seriesModel) {
  const scheduler = (seriesModel.ecModel || {}).scheduler;
  const pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);
  if (pipeline) {
    let task = pipeline.currentTask;
    if (task) {
      const agentStubMap = task.agentStubMap;
      if (agentStubMap) {
        task = agentStubMap.get(seriesModel.uid);
      }
    }
    return task;
  }
}
var Series_default = SeriesModel;

// src/view/Component.ts
var ComponentView = class {
  constructor() {
    this.group = new Group_default();
    this.uid = getUID("viewComponent");
  }
  init(ecModel, api2) {
  }
  render(model, ecModel, api2, payload) {
  }
  dispose(ecModel, api2) {
  }
  updateView(model, ecModel, api2, payload) {
  }
  updateLayout(model, ecModel, api2, payload) {
  }
  updateVisual(model, ecModel, api2, payload) {
  }
  toggleBlurSeries(seriesModels, isBlur, ecModel) {
  }
  eachRendered(cb) {
    const group = this.group;
    if (group) {
      group.traverse(cb);
    }
  }
};
enableClassExtend(ComponentView);
enableClassManagement(ComponentView);
var Component_default2 = ComponentView;

// src/chart/helper/createRenderPlanner.ts
function createRenderPlanner() {
  const inner23 = makeInner();
  return function(seriesModel) {
    const fields = inner23(seriesModel);
    const pipelineContext = seriesModel.pipelineContext;
    const originalLarge = !!fields.large;
    const originalProgressive = !!fields.progressiveRender;
    const large = fields.large = !!(pipelineContext && pipelineContext.large);
    const progressive = fields.progressiveRender = !!(pipelineContext && pipelineContext.progressiveRender);
    return !!(originalLarge !== large || originalProgressive !== progressive) && "reset";
  };
}

// src/view/Chart.ts
var inner3 = makeInner();
var renderPlanner = createRenderPlanner();
var ChartView2 = class {
  constructor() {
    this.group = new Group_default();
    this.uid = getUID("viewChart");
    this.renderTask = createTask({
      plan: renderTaskPlan,
      reset: renderTaskReset
    });
    this.renderTask.context = {view: this};
  }
  init(ecModel, api2) {
  }
  render(seriesModel, ecModel, api2, payload) {
    if (true) {
      throw new Error("render method must been implemented");
    }
  }
  highlight(seriesModel, ecModel, api2, payload) {
    const data = seriesModel.getData(payload && payload.dataType);
    if (!data) {
      if (true) {
        error(`Unknown dataType ${payload.dataType}`);
      }
      return;
    }
    toggleHighlight(data, payload, "emphasis");
  }
  downplay(seriesModel, ecModel, api2, payload) {
    const data = seriesModel.getData(payload && payload.dataType);
    if (!data) {
      if (true) {
        error(`Unknown dataType ${payload.dataType}`);
      }
      return;
    }
    toggleHighlight(data, payload, "normal");
  }
  remove(ecModel, api2) {
    this.group.removeAll();
  }
  dispose(ecModel, api2) {
  }
  updateView(seriesModel, ecModel, api2, payload) {
    this.render(seriesModel, ecModel, api2, payload);
  }
  updateLayout(seriesModel, ecModel, api2, payload) {
    this.render(seriesModel, ecModel, api2, payload);
  }
  updateVisual(seriesModel, ecModel, api2, payload) {
    this.render(seriesModel, ecModel, api2, payload);
  }
  eachRendered(cb) {
    traverseElements(this.group, cb);
  }
  static markUpdateMethod(payload, methodName) {
    inner3(payload).updateMethod = methodName;
  }
};
var ChartView = ChartView2;
ChartView.protoInitialize = function() {
  const proto2 = ChartView2.prototype;
  proto2.type = "chart";
}();
function elSetState(el, state, highlightDigit) {
  if (el && isHighDownDispatcher(el)) {
    (state === "emphasis" ? enterEmphasis : leaveEmphasis)(el, highlightDigit);
  }
}
function toggleHighlight(data, payload, state) {
  const dataIndex = queryDataIndex(data, payload);
  const highlightDigit = payload && payload.highlightKey != null ? getHighlightDigit(payload.highlightKey) : null;
  if (dataIndex != null) {
    each(normalizeToArray(dataIndex), function(dataIdx) {
      elSetState(data.getItemGraphicEl(dataIdx), state, highlightDigit);
    });
  } else {
    data.eachItemGraphicEl(function(el) {
      elSetState(el, state, highlightDigit);
    });
  }
}
enableClassExtend(ChartView, ["dispose"]);
enableClassManagement(ChartView);
function renderTaskPlan(context) {
  return renderPlanner(context.model);
}
function renderTaskReset(context) {
  const seriesModel = context.model;
  const ecModel = context.ecModel;
  const api2 = context.api;
  const payload = context.payload;
  const progressiveRender = seriesModel.pipelineContext.progressiveRender;
  const view = context.view;
  const updateMethod = payload && inner3(payload).updateMethod;
  const methodName = progressiveRender ? "incrementalPrepareRender" : updateMethod && view[updateMethod] ? updateMethod : "render";
  if (methodName !== "render") {
    view[methodName](seriesModel, ecModel, api2, payload);
  }
  return progressMethodMap[methodName];
}
var progressMethodMap = {
  incrementalPrepareRender: {
    progress: function(params, context) {
      context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload);
    }
  },
  render: {
    forceFirstProgress: true,
    progress: function(params, context) {
      context.view.render(context.model, context.ecModel, context.api, context.payload);
    }
  }
};
var Chart_default = ChartView;

// src/util/throttle.ts
var ORIGIN_METHOD = "\0__throttleOriginMethod";
var RATE = "\0__throttleRate";
var THROTTLE_TYPE = "\0__throttleType";
function throttle(fn, delay, debounce) {
  let currCall;
  let lastCall = 0;
  let lastExec = 0;
  let timer = null;
  let diff;
  let scope;
  let args;
  let debounceNextCall;
  delay = delay || 0;
  function exec() {
    lastExec = new Date().getTime();
    timer = null;
    fn.apply(scope, args || []);
  }
  const cb = function(...cbArgs) {
    currCall = new Date().getTime();
    scope = this;
    args = cbArgs;
    const thisDelay = debounceNextCall || delay;
    const thisDebounce = debounceNextCall || debounce;
    debounceNextCall = null;
    diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;
    clearTimeout(timer);
    if (thisDebounce) {
      timer = setTimeout(exec, thisDelay);
    } else {
      if (diff >= 0) {
        exec();
      } else {
        timer = setTimeout(exec, -diff);
      }
    }
    lastCall = currCall;
  };
  cb.clear = function() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  };
  cb.debounceNextCall = function(debounceDelay) {
    debounceNextCall = debounceDelay;
  };
  return cb;
}
function createOrUpdate(obj, fnAttr, rate, throttleType) {
  let fn = obj[fnAttr];
  if (!fn) {
    return;
  }
  const originFn = fn[ORIGIN_METHOD] || fn;
  const lastThrottleType = fn[THROTTLE_TYPE];
  const lastRate = fn[RATE];
  if (lastRate !== rate || lastThrottleType !== throttleType) {
    if (rate == null || !throttleType) {
      return obj[fnAttr] = originFn;
    }
    fn = obj[fnAttr] = throttle(originFn, rate, throttleType === "debounce");
    fn[ORIGIN_METHOD] = originFn;
    fn[THROTTLE_TYPE] = throttleType;
    fn[RATE] = rate;
  }
  return fn;
}
function clear(obj, fnAttr) {
  const fn = obj[fnAttr];
  if (fn && fn[ORIGIN_METHOD]) {
    fn.clear && fn.clear();
    obj[fnAttr] = fn[ORIGIN_METHOD];
  }
}

// src/visual/style.ts
var inner4 = makeInner();
var defaultStyleMappers = {
  itemStyle: makeStyleMapper(ITEM_STYLE_KEY_MAP, true),
  lineStyle: makeStyleMapper(LINE_STYLE_KEY_MAP, true)
};
var defaultColorKey = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function getStyleMapper(seriesModel, stylePath) {
  const styleMapper = seriesModel.visualStyleMapper || defaultStyleMappers[stylePath];
  if (!styleMapper) {
    console.warn(`Unknown style type '${stylePath}'.`);
    return defaultStyleMappers.itemStyle;
  }
  return styleMapper;
}
function getDefaultColorKey(seriesModel, stylePath) {
  const colorKey = seriesModel.visualDrawType || defaultColorKey[stylePath];
  if (!colorKey) {
    console.warn(`Unknown style type '${stylePath}'.`);
    return "fill";
  }
  return colorKey;
}
var seriesStyleTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset(seriesModel, ecModel) {
    const data = seriesModel.getData();
    const stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
    const styleModel = seriesModel.getModel(stylePath);
    const getStyle2 = getStyleMapper(seriesModel, stylePath);
    const globalStyle = getStyle2(styleModel);
    const decalOption = styleModel.getShallow("decal");
    if (decalOption) {
      data.setVisual("decal", decalOption);
      decalOption.dirty = true;
    }
    const colorKey = getDefaultColorKey(seriesModel, stylePath);
    const color2 = globalStyle[colorKey];
    const colorCallback = isFunction(color2) ? color2 : null;
    const hasAutoColor = globalStyle.fill === "auto" || globalStyle.stroke === "auto";
    if (!globalStyle[colorKey] || colorCallback || hasAutoColor) {
      const colorPalette2 = seriesModel.getColorFromPalette(seriesModel.name, null, ecModel.getSeriesCount());
      if (!globalStyle[colorKey]) {
        globalStyle[colorKey] = colorPalette2;
        data.setVisual("colorFromPalette", true);
      }
      globalStyle.fill = globalStyle.fill === "auto" || isFunction(globalStyle.fill) ? colorPalette2 : globalStyle.fill;
      globalStyle.stroke = globalStyle.stroke === "auto" || isFunction(globalStyle.stroke) ? colorPalette2 : globalStyle.stroke;
    }
    data.setVisual("style", globalStyle);
    data.setVisual("drawType", colorKey);
    if (!ecModel.isSeriesFiltered(seriesModel) && colorCallback) {
      data.setVisual("colorFromPalette", false);
      return {
        dataEach(data2, idx) {
          const dataParams = seriesModel.getDataParams(idx);
          const itemStyle = extend({}, globalStyle);
          itemStyle[colorKey] = colorCallback(dataParams);
          data2.setItemVisual(idx, "style", itemStyle);
        }
      };
    }
  }
};
var sharedModel = new Model_default();
var dataStyleTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset(seriesModel, ecModel) {
    if (seriesModel.ignoreStyleOnData || ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    const data = seriesModel.getData();
    const stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
    const getStyle2 = getStyleMapper(seriesModel, stylePath);
    const colorKey = data.getVisual("drawType");
    return {
      dataEach: data.hasItemOption ? function(data2, idx) {
        const rawItem = data2.getRawDataItem(idx);
        if (rawItem && rawItem[stylePath]) {
          sharedModel.option = rawItem[stylePath];
          const style = getStyle2(sharedModel);
          const existsStyle = data2.ensureUniqueItemVisual(idx, "style");
          extend(existsStyle, style);
          if (sharedModel.option.decal) {
            data2.setItemVisual(idx, "decal", sharedModel.option.decal);
            sharedModel.option.decal.dirty = true;
          }
          if (colorKey in style) {
            data2.setItemVisual(idx, "colorFromPalette", false);
          }
        }
      } : null
    };
  }
};
var dataColorPaletteTask = {
  performRawSeries: true,
  overallReset(ecModel) {
    const paletteScopeGroupByType = createHashMap();
    ecModel.eachSeries((seriesModel) => {
      const colorBy = seriesModel.getColorBy();
      if (seriesModel.isColorBySeries()) {
        return;
      }
      const key = seriesModel.type + "-" + colorBy;
      let colorScope = paletteScopeGroupByType.get(key);
      if (!colorScope) {
        colorScope = {};
        paletteScopeGroupByType.set(key, colorScope);
      }
      inner4(seriesModel).scope = colorScope;
    });
    ecModel.eachSeries((seriesModel) => {
      if (seriesModel.isColorBySeries() || ecModel.isSeriesFiltered(seriesModel)) {
        return;
      }
      const dataAll = seriesModel.getRawData();
      const idxMap = {};
      const data = seriesModel.getData();
      const colorScope = inner4(seriesModel).scope;
      const stylePath = seriesModel.visualStyleAccessPath || "itemStyle";
      const colorKey = getDefaultColorKey(seriesModel, stylePath);
      data.each(function(idx) {
        const rawIdx = data.getRawIndex(idx);
        idxMap[rawIdx] = idx;
      });
      dataAll.each(function(rawIdx) {
        const idx = idxMap[rawIdx];
        const fromPalette = data.getItemVisual(idx, "colorFromPalette");
        if (fromPalette) {
          const itemStyle = data.ensureUniqueItemVisual(idx, "style");
          const name = dataAll.getName(rawIdx) || rawIdx + "";
          const dataCount = dataAll.count();
          itemStyle[colorKey] = seriesModel.getColorFromPalette(name, colorScope, dataCount);
        }
      });
    });
  }
};

// src/loading/default.ts
var PI5 = Math.PI;
function defaultLoading(api2, opts) {
  opts = opts || {};
  defaults(opts, {
    text: "loading",
    textColor: "#000",
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255, 255, 255, 0.8)",
    showSpinner: true,
    color: "#5470c6",
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  const group = new Group_default();
  const mask = new Rect_default({
    style: {
      fill: opts.maskColor
    },
    zlevel: opts.zlevel,
    z: 1e4
  });
  group.add(mask);
  const textContent = new Text_default({
    style: {
      text: opts.text,
      fill: opts.textColor,
      fontSize: opts.fontSize,
      fontWeight: opts.fontWeight,
      fontStyle: opts.fontStyle,
      fontFamily: opts.fontFamily
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  const labelRect = new Rect_default({
    style: {
      fill: "none"
    },
    textContent,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: opts.zlevel,
    z: 10001
  });
  group.add(labelRect);
  let arc2;
  if (opts.showSpinner) {
    arc2 = new Arc_default({
      shape: {
        startAngle: -PI5 / 2,
        endAngle: -PI5 / 2 + 0.1,
        r: opts.spinnerRadius
      },
      style: {
        stroke: opts.color,
        lineCap: "round",
        lineWidth: opts.lineWidth
      },
      zlevel: opts.zlevel,
      z: 10001
    });
    arc2.animateShape(true).when(1e3, {
      endAngle: PI5 * 3 / 2
    }).start("circularInOut");
    arc2.animateShape(true).when(1e3, {
      startAngle: PI5 * 3 / 2
    }).delay(300).start("circularInOut");
    group.add(arc2);
  }
  group.resize = function() {
    const textWidth = textContent.getBoundingRect().width;
    const r = opts.showSpinner ? opts.spinnerRadius : 0;
    const cx = (api2.getWidth() - r * 2 - (opts.showSpinner && textWidth ? 10 : 0) - textWidth) / 2 - (opts.showSpinner && textWidth ? 0 : 5 + textWidth / 2) + (opts.showSpinner ? 0 : textWidth / 2) + (textWidth ? 0 : r);
    const cy = api2.getHeight() / 2;
    opts.showSpinner && arc2.setShape({
      cx,
      cy
    });
    labelRect.setShape({
      x: cx - r,
      y: cy - r,
      width: r * 2,
      height: r * 2
    });
    mask.setShape({
      x: 0,
      y: 0,
      width: api2.getWidth(),
      height: api2.getHeight()
    });
  };
  group.resize();
  return group;
}

// src/core/Scheduler.ts
var Scheduler = class {
  constructor(ecInstance, api2, dataProcessorHandlers, visualHandlers) {
    this._stageTaskMap = createHashMap();
    this.ecInstance = ecInstance;
    this.api = api2;
    dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();
    visualHandlers = this._visualHandlers = visualHandlers.slice();
    this._allHandlers = dataProcessorHandlers.concat(visualHandlers);
  }
  restoreData(ecModel, payload) {
    ecModel.restoreData(payload);
    this._stageTaskMap.each(function(taskRecord) {
      const overallTask = taskRecord.overallTask;
      overallTask && overallTask.dirty();
    });
  }
  getPerformArgs(task, isBlock) {
    if (!task.__pipeline) {
      return;
    }
    const pipeline = this._pipelineMap.get(task.__pipeline.id);
    const pCtx = pipeline.context;
    const incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;
    const step = incremental ? pipeline.step : null;
    const modDataCount = pCtx && pCtx.modDataCount;
    const modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;
    return {step, modBy, modDataCount};
  }
  getPipeline(pipelineId) {
    return this._pipelineMap.get(pipelineId);
  }
  updateStreamModes(seriesModel, view) {
    const pipeline = this._pipelineMap.get(seriesModel.uid);
    const data = seriesModel.getData();
    const dataLen = data.count();
    const progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;
    const large = seriesModel.get("large") && dataLen >= seriesModel.get("largeThreshold");
    const modDataCount = seriesModel.get("progressiveChunkMode") === "mod" ? dataLen : null;
    seriesModel.pipelineContext = pipeline.context = {
      progressiveRender,
      modDataCount,
      large
    };
  }
  restorePipelines(ecModel) {
    const scheduler = this;
    const pipelineMap = scheduler._pipelineMap = createHashMap();
    ecModel.eachSeries(function(seriesModel) {
      const progressive = seriesModel.getProgressive();
      const pipelineId = seriesModel.uid;
      pipelineMap.set(pipelineId, {
        id: pipelineId,
        head: null,
        tail: null,
        threshold: seriesModel.getProgressiveThreshold(),
        progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),
        blockIndex: -1,
        step: Math.round(progressive || 700),
        count: 0
      });
      scheduler._pipe(seriesModel, seriesModel.dataTask);
    });
  }
  prepareStageTasks() {
    const stageTaskMap = this._stageTaskMap;
    const ecModel = this.api.getModel();
    const api2 = this.api;
    each(this._allHandlers, function(handler) {
      const record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {});
      let errMsg = "";
      if (true) {
        errMsg = '"reset" and "overallReset" must not be both specified.';
      }
      assert(!(handler.reset && handler.overallReset), errMsg);
      handler.reset && this._createSeriesStageTask(handler, record, ecModel, api2);
      handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api2);
    }, this);
  }
  prepareView(view, model, ecModel, api2) {
    const renderTask = view.renderTask;
    const context = renderTask.context;
    context.model = model;
    context.ecModel = ecModel;
    context.api = api2;
    renderTask.__block = !view.incrementalPrepareRender;
    this._pipe(model, renderTask);
  }
  performDataProcessorTasks(ecModel, payload) {
    this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, {block: true});
  }
  performVisualTasks(ecModel, payload, opt) {
    this._performStageTasks(this._visualHandlers, ecModel, payload, opt);
  }
  _performStageTasks(stageHandlers, ecModel, payload, opt) {
    opt = opt || {};
    let unfinished = false;
    const scheduler = this;
    each(stageHandlers, function(stageHandler, idx) {
      if (opt.visualType && opt.visualType !== stageHandler.visualType) {
        return;
      }
      const stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);
      const seriesTaskMap = stageHandlerRecord.seriesTaskMap;
      const overallTask = stageHandlerRecord.overallTask;
      if (overallTask) {
        let overallNeedDirty;
        const agentStubMap = overallTask.agentStubMap;
        agentStubMap.each(function(stub) {
          if (needSetDirty(opt, stub)) {
            stub.dirty();
            overallNeedDirty = true;
          }
        });
        overallNeedDirty && overallTask.dirty();
        scheduler.updatePayload(overallTask, payload);
        const performArgs = scheduler.getPerformArgs(overallTask, opt.block);
        agentStubMap.each(function(stub) {
          stub.perform(performArgs);
        });
        if (overallTask.perform(performArgs)) {
          unfinished = true;
        }
      } else if (seriesTaskMap) {
        seriesTaskMap.each(function(task, pipelineId) {
          if (needSetDirty(opt, task)) {
            task.dirty();
          }
          const performArgs = scheduler.getPerformArgs(task, opt.block);
          performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);
          scheduler.updatePayload(task, payload);
          if (task.perform(performArgs)) {
            unfinished = true;
          }
        });
      }
    });
    function needSetDirty(opt2, task) {
      return opt2.setDirty && (!opt2.dirtyMap || opt2.dirtyMap.get(task.__pipeline.id));
    }
    this.unfinished = unfinished || this.unfinished;
  }
  performSeriesTasks(ecModel) {
    let unfinished;
    ecModel.eachSeries(function(seriesModel) {
      unfinished = seriesModel.dataTask.perform() || unfinished;
    });
    this.unfinished = unfinished || this.unfinished;
  }
  plan() {
    this._pipelineMap.each(function(pipeline) {
      let task = pipeline.tail;
      do {
        if (task.__block) {
          pipeline.blockIndex = task.__idxInPipeline;
          break;
        }
        task = task.getUpstream();
      } while (task);
    });
  }
  updatePayload(task, payload) {
    payload !== "remain" && (task.context.payload = payload);
  }
  _createSeriesStageTask(stageHandler, stageHandlerRecord, ecModel, api2) {
    const scheduler = this;
    const oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap;
    const newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = createHashMap();
    const seriesType2 = stageHandler.seriesType;
    const getTargetSeries = stageHandler.getTargetSeries;
    if (stageHandler.createOnAllSeries) {
      ecModel.eachRawSeries(create4);
    } else if (seriesType2) {
      ecModel.eachRawSeriesByType(seriesType2, create4);
    } else if (getTargetSeries) {
      getTargetSeries(ecModel, api2).each(create4);
    }
    function create4(seriesModel) {
      const pipelineId = seriesModel.uid;
      const task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || createTask({
        plan: seriesTaskPlan,
        reset: seriesTaskReset,
        count: seriesTaskCount
      }));
      task.context = {
        model: seriesModel,
        ecModel,
        api: api2,
        useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,
        plan: stageHandler.plan,
        reset: stageHandler.reset,
        scheduler
      };
      scheduler._pipe(seriesModel, task);
    }
  }
  _createOverallStageTask(stageHandler, stageHandlerRecord, ecModel, api2) {
    const scheduler = this;
    const overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || createTask({reset: overallTaskReset});
    overallTask.context = {
      ecModel,
      api: api2,
      overallReset: stageHandler.overallReset,
      scheduler
    };
    const oldAgentStubMap = overallTask.agentStubMap;
    const newAgentStubMap = overallTask.agentStubMap = createHashMap();
    const seriesType2 = stageHandler.seriesType;
    const getTargetSeries = stageHandler.getTargetSeries;
    let overallProgress = true;
    let shouldOverallTaskDirty = false;
    let errMsg = "";
    if (true) {
      errMsg = '"createOnAllSeries" is not supported for "overallReset", because it will block all streams.';
    }
    assert(!stageHandler.createOnAllSeries, errMsg);
    if (seriesType2) {
      ecModel.eachRawSeriesByType(seriesType2, createStub);
    } else if (getTargetSeries) {
      getTargetSeries(ecModel, api2).each(createStub);
    } else {
      overallProgress = false;
      each(ecModel.getSeries(), createStub);
    }
    function createStub(seriesModel) {
      const pipelineId = seriesModel.uid;
      const stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || (shouldOverallTaskDirty = true, createTask({reset: stubReset, onDirty: stubOnDirty})));
      stub.context = {
        model: seriesModel,
        overallProgress
      };
      stub.agent = overallTask;
      stub.__block = overallProgress;
      scheduler._pipe(seriesModel, stub);
    }
    if (shouldOverallTaskDirty) {
      overallTask.dirty();
    }
  }
  _pipe(seriesModel, task) {
    const pipelineId = seriesModel.uid;
    const pipeline = this._pipelineMap.get(pipelineId);
    !pipeline.head && (pipeline.head = task);
    pipeline.tail && pipeline.tail.pipe(task);
    pipeline.tail = task;
    task.__idxInPipeline = pipeline.count++;
    task.__pipeline = pipeline;
  }
  static wrapStageHandler(stageHandler, visualType) {
    if (isFunction(stageHandler)) {
      stageHandler = {
        overallReset: stageHandler,
        seriesType: detectSeriseType(stageHandler)
      };
    }
    stageHandler.uid = getUID("stageHandler");
    visualType && (stageHandler.visualType = visualType);
    return stageHandler;
  }
};
function overallTaskReset(context) {
  context.overallReset(context.ecModel, context.api, context.payload);
}
function stubReset(context) {
  return context.overallProgress && stubProgress;
}
function stubProgress() {
  this.agent.dirty();
  this.getDownstream().dirty();
}
function stubOnDirty() {
  this.agent && this.agent.dirty();
}
function seriesTaskPlan(context) {
  return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;
}
function seriesTaskReset(context) {
  if (context.useClearVisual) {
    context.data.clearAllVisual();
  }
  const resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));
  return resetDefines.length > 1 ? map(resetDefines, function(v, idx) {
    return makeSeriesTaskProgress(idx);
  }) : singleSeriesTaskProgress;
}
var singleSeriesTaskProgress = makeSeriesTaskProgress(0);
function makeSeriesTaskProgress(resetDefineIdx) {
  return function(params, context) {
    const data = context.data;
    const resetDefine = context.resetDefines[resetDefineIdx];
    if (resetDefine && resetDefine.dataEach) {
      for (let i = params.start; i < params.end; i++) {
        resetDefine.dataEach(data, i);
      }
    } else if (resetDefine && resetDefine.progress) {
      resetDefine.progress(params, data);
    }
  };
}
function seriesTaskCount(context) {
  return context.data.count();
}
function detectSeriseType(legacyFunc) {
  seriesType = null;
  try {
    legacyFunc(ecModelMock, apiMock);
  } catch (e2) {
  }
  return seriesType;
}
var ecModelMock = {};
var apiMock = {};
var seriesType;
mockMethods(ecModelMock, Global_default);
mockMethods(apiMock, ExtensionAPI_default);
ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function(type) {
  seriesType = type;
};
ecModelMock.eachComponent = function(cond) {
  if (cond.mainType === "series" && cond.subType) {
    seriesType = cond.subType;
  }
};
function mockMethods(target, Clz) {
  for (let name in Clz.prototype) {
    target[name] = noop;
  }
}
var Scheduler_default = Scheduler;

// src/theme/light.ts
var colorAll = [
  "#37A2DA",
  "#32C5E9",
  "#67E0E3",
  "#9FE6B8",
  "#FFDB5C",
  "#ff9f7f",
  "#fb7293",
  "#E062AE",
  "#E690D1",
  "#e7bcf3",
  "#9d96f5",
  "#8378EA",
  "#96BFFF"
];
var light_default = {
  color: colorAll,
  colorLayer: [
    ["#37A2DA", "#ffd85c", "#fd7b5f"],
    ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"],
    ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"],
    colorAll
  ]
};

// src/theme/dark.ts
var contrastColor = "#B9B8CE";
var backgroundColor = "#100C2A";
var axisCommon = function() {
  return {
    axisLine: {
      lineStyle: {
        color: contrastColor
      }
    },
    splitLine: {
      lineStyle: {
        color: "#484753"
      }
    },
    splitArea: {
      areaStyle: {
        color: ["rgba(255,255,255,0.02)", "rgba(255,255,255,0.05)"]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: "#20203B"
      }
    }
  };
};
var colorPalette = [
  "#4992ff",
  "#7cffb2",
  "#fddd60",
  "#ff6e76",
  "#58d9f9",
  "#05c091",
  "#ff8a45",
  "#8d48e3",
  "#dd79ff"
];
var theme = {
  darkMode: true,
  color: colorPalette,
  backgroundColor,
  axisPointer: {
    lineStyle: {
      color: "#817f91"
    },
    crossStyle: {
      color: "#817f91"
    },
    label: {
      color: "#fff"
    }
  },
  legend: {
    textStyle: {
      color: contrastColor
    }
  },
  textStyle: {
    color: contrastColor
  },
  title: {
    textStyle: {
      color: "#EEF1FA"
    },
    subtextStyle: {
      color: "#B9B8CE"
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: contrastColor
    }
  },
  dataZoom: {
    borderColor: "#71708A",
    textStyle: {
      color: contrastColor
    },
    brushStyle: {
      color: "rgba(135,163,206,0.3)"
    },
    handleStyle: {
      color: "#353450",
      borderColor: "#C5CBE3"
    },
    moveHandleStyle: {
      color: "#B0B6C3",
      opacity: 0.3
    },
    fillerColor: "rgba(135,163,206,0.2)",
    emphasis: {
      handleStyle: {
        borderColor: "#91B7F2",
        color: "#4D587D"
      },
      moveHandleStyle: {
        color: "#636D9A",
        opacity: 0.7
      }
    },
    dataBackground: {
      lineStyle: {
        color: "#71708A",
        width: 1
      },
      areaStyle: {
        color: "#71708A"
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: "#87A3CE"
      },
      areaStyle: {
        color: "#87A3CE"
      }
    }
  },
  visualMap: {
    textStyle: {
      color: contrastColor
    }
  },
  timeline: {
    lineStyle: {
      color: contrastColor
    },
    label: {
      color: contrastColor
    },
    controlStyle: {
      color: contrastColor,
      borderColor: contrastColor
    }
  },
  calendar: {
    itemStyle: {
      color: backgroundColor
    },
    dayLabel: {
      color: contrastColor
    },
    monthLabel: {
      color: contrastColor
    },
    yearLabel: {
      color: contrastColor
    }
  },
  timeAxis: axisCommon(),
  logAxis: axisCommon(),
  valueAxis: axisCommon(),
  categoryAxis: axisCommon(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: colorPalette
  },
  gauge: {
    title: {
      color: contrastColor
    },
    axisLine: {
      lineStyle: {
        color: [[1, "rgba(207,212,219,0.2)"]]
      }
    },
    axisLabel: {
      color: contrastColor
    },
    detail: {
      color: "#EEF1FA"
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
    }
  }
};
theme.categoryAxis.splitLine.show = false;
var dark_default = theme;

// src/util/ECEventProcessor.ts
var ECEventProcessor = class {
  normalizeQuery(query) {
    const cptQuery = {};
    const dataQuery = {};
    const otherQuery = {};
    if (isString(query)) {
      const condCptType = parseClassType(query);
      cptQuery.mainType = condCptType.main || null;
      cptQuery.subType = condCptType.sub || null;
    } else {
      const suffixes = ["Index", "Name", "Id"];
      const dataKeys = {name: 1, dataIndex: 1, dataType: 1};
      each(query, function(val, key) {
        let reserved = false;
        for (let i = 0; i < suffixes.length; i++) {
          const propSuffix = suffixes[i];
          const suffixPos = key.lastIndexOf(propSuffix);
          if (suffixPos > 0 && suffixPos === key.length - propSuffix.length) {
            const mainType = key.slice(0, suffixPos);
            if (mainType !== "data") {
              cptQuery.mainType = mainType;
              cptQuery[propSuffix.toLowerCase()] = val;
              reserved = true;
            }
          }
        }
        if (dataKeys.hasOwnProperty(key)) {
          dataQuery[key] = val;
          reserved = true;
        }
        if (!reserved) {
          otherQuery[key] = val;
        }
      });
    }
    return {
      cptQuery,
      dataQuery,
      otherQuery
    };
  }
  filter(eventType, query) {
    const eventInfo = this.eventInfo;
    if (!eventInfo) {
      return true;
    }
    const targetEl = eventInfo.targetEl;
    const packedEvent = eventInfo.packedEvent;
    const model = eventInfo.model;
    const view = eventInfo.view;
    if (!model || !view) {
      return true;
    }
    const cptQuery = query.cptQuery;
    const dataQuery = query.dataQuery;
    return check(cptQuery, model, "mainType") && check(cptQuery, model, "subType") && check(cptQuery, model, "index", "componentIndex") && check(cptQuery, model, "name") && check(cptQuery, model, "id") && check(dataQuery, packedEvent, "name") && check(dataQuery, packedEvent, "dataIndex") && check(dataQuery, packedEvent, "dataType") && (!view.filterForExposedEvent || view.filterForExposedEvent(eventType, query.otherQuery, targetEl, packedEvent));
    function check(query2, host, prop, propOnHost) {
      return query2[prop] == null || host[propOnHost || prop] === query2[prop];
    }
  }
  afterTrigger() {
    this.eventInfo = null;
  }
};

// src/visual/symbol.ts
var SYMBOL_PROPS_WITH_CB = [
  "symbol",
  "symbolSize",
  "symbolRotate",
  "symbolOffset"
];
var SYMBOL_PROPS = SYMBOL_PROPS_WITH_CB.concat([
  "symbolKeepAspect"
]);
var seriesSymbolTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    const data = seriesModel.getData();
    if (seriesModel.legendIcon) {
      data.setVisual("legendIcon", seriesModel.legendIcon);
    }
    if (!seriesModel.hasSymbolVisual) {
      return;
    }
    const symbolOptions = {};
    const symbolOptionsCb = {};
    let hasCallback = false;
    for (let i = 0; i < SYMBOL_PROPS_WITH_CB.length; i++) {
      const symbolPropName = SYMBOL_PROPS_WITH_CB[i];
      const val = seriesModel.get(symbolPropName);
      if (isFunction(val)) {
        hasCallback = true;
        symbolOptionsCb[symbolPropName] = val;
      } else {
        symbolOptions[symbolPropName] = val;
      }
    }
    symbolOptions.symbol = symbolOptions.symbol || seriesModel.defaultSymbol;
    data.setVisual(extend({
      legendIcon: seriesModel.legendIcon || symbolOptions.symbol,
      symbolKeepAspect: seriesModel.get("symbolKeepAspect")
    }, symbolOptions));
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    const symbolPropsCb = keys(symbolOptionsCb);
    function dataEach(data2, idx) {
      const rawValue = seriesModel.getRawValue(idx);
      const params = seriesModel.getDataParams(idx);
      for (let i = 0; i < symbolPropsCb.length; i++) {
        const symbolPropName = symbolPropsCb[i];
        data2.setItemVisual(idx, symbolPropName, symbolOptionsCb[symbolPropName](rawValue, params));
      }
    }
    return {dataEach: hasCallback ? dataEach : null};
  }
};
var dataSymbolTask = {
  createOnAllSeries: true,
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    if (!seriesModel.hasSymbolVisual) {
      return;
    }
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    const data = seriesModel.getData();
    function dataEach(data2, idx) {
      const itemModel = data2.getItemModel(idx);
      for (let i = 0; i < SYMBOL_PROPS.length; i++) {
        const symbolPropName = SYMBOL_PROPS[i];
        const val = itemModel.getShallow(symbolPropName, true);
        if (val != null) {
          data2.setItemVisual(idx, symbolPropName, val);
        }
      }
    }
    return {dataEach: data.hasItemOption ? dataEach : null};
  }
};

// src/visual/helper.ts
function getItemVisualFromData(data, dataIndex, key) {
  switch (key) {
    case "color":
      const style = data.getItemVisual(dataIndex, "style");
      return style[data.getVisual("drawType")];
    case "opacity":
      return data.getItemVisual(dataIndex, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return data.getItemVisual(dataIndex, key);
    default:
      if (true) {
        console.warn(`Unknown visual type ${key}`);
      }
  }
}
function getVisualFromData(data, key) {
  switch (key) {
    case "color":
      const style = data.getVisual("style");
      return style[data.getVisual("drawType")];
    case "opacity":
      return data.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return data.getVisual(key);
    default:
      if (true) {
        console.warn(`Unknown visual type ${key}`);
      }
  }
}
function setItemVisualFromData(data, dataIndex, key, value) {
  switch (key) {
    case "color":
      const style = data.ensureUniqueItemVisual(dataIndex, "style");
      style[data.getVisual("drawType")] = value;
      data.setItemVisual(dataIndex, "colorFromPalette", false);
      break;
    case "opacity":
      data.ensureUniqueItemVisual(dataIndex, "style").opacity = value;
      break;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      data.setItemVisual(dataIndex, key, value);
      break;
    default:
      if (true) {
        console.warn(`Unknown visual type ${key}`);
      }
  }
}

// src/legacy/dataSelectAction.ts
function createLegacyDataSelectAction(seriesType2, ecRegisterAction) {
  function getSeriesIndices(ecModel, payload) {
    const seriesIndices = [];
    ecModel.eachComponent({
      mainType: "series",
      subType: seriesType2,
      query: payload
    }, function(seriesModel) {
      seriesIndices.push(seriesModel.seriesIndex);
    });
    return seriesIndices;
  }
  each([
    [seriesType2 + "ToggleSelect", "toggleSelect"],
    [seriesType2 + "Select", "select"],
    [seriesType2 + "UnSelect", "unselect"]
  ], function(eventsMap) {
    ecRegisterAction(eventsMap[0], function(payload, ecModel, api2) {
      payload = extend({}, payload);
      if (true) {
        deprecateReplaceLog(payload.type, eventsMap[1]);
      }
      api2.dispatchAction(extend(payload, {
        type: eventsMap[1],
        seriesIndex: getSeriesIndices(ecModel, payload)
      }));
    });
  });
}
function handleSeriesLegacySelectEvents(type, eventPostfix, ecIns, ecModel, payload) {
  const legacyEventName = type + eventPostfix;
  if (!ecIns.isSilent(legacyEventName)) {
    if (true) {
      deprecateLog(`event ${legacyEventName} is deprecated.`);
    }
    ecModel.eachComponent({
      mainType: "series",
      subType: "pie"
    }, function(seriesModel) {
      const seriesIndex = seriesModel.seriesIndex;
      const selectedMap = seriesModel.option.selectedMap;
      const selected = payload.selected;
      for (let i = 0; i < selected.length; i++) {
        if (selected[i].seriesIndex === seriesIndex) {
          const data = seriesModel.getData();
          const dataIndex = queryDataIndex(data, payload.fromActionPayload);
          ecIns.trigger(legacyEventName, {
            type: legacyEventName,
            seriesId: seriesModel.id,
            name: isArray(dataIndex) ? data.getName(dataIndex[0]) : data.getName(dataIndex),
            selected: isString(selectedMap) ? selectedMap : extend({}, selectedMap)
          });
        }
      }
    });
  }
}
function handleLegacySelectEvents(messageCenter, ecIns, api2) {
  messageCenter.on("selectchanged", function(params) {
    const ecModel = api2.getModel();
    if (params.isFromClick) {
      handleSeriesLegacySelectEvents("map", "selectchanged", ecIns, ecModel, params);
      handleSeriesLegacySelectEvents("pie", "selectchanged", ecIns, ecModel, params);
    } else if (params.fromAction === "select") {
      handleSeriesLegacySelectEvents("map", "selected", ecIns, ecModel, params);
      handleSeriesLegacySelectEvents("pie", "selected", ecIns, ecModel, params);
    } else if (params.fromAction === "unselect") {
      handleSeriesLegacySelectEvents("map", "unselected", ecIns, ecModel, params);
      handleSeriesLegacySelectEvents("pie", "unselected", ecIns, ecModel, params);
    }
  });
}

// src/util/event.ts
function findEventDispatcher(target, det, returnFirstMatch) {
  let found;
  while (target) {
    if (det(target)) {
      found = target;
      if (returnFirstMatch) {
        break;
      }
    }
    target = target.__hostTarget || target.parent;
  }
  return found;
}

// node_modules/zrender/src/core/WeakMap.ts
var wmUniqueIndex = Math.round(Math.random() * 9);
var supportDefineProperty = typeof Object.defineProperty === "function";
var WeakMap = class {
  constructor() {
    this._id = "__ec_inner_" + wmUniqueIndex++;
  }
  get(key) {
    return this._guard(key)[this._id];
  }
  set(key, value) {
    const target = this._guard(key);
    if (supportDefineProperty) {
      Object.defineProperty(target, this._id, {
        value,
        enumerable: false,
        configurable: true
      });
    } else {
      target[this._id] = value;
    }
    return this;
  }
  delete(key) {
    if (this.has(key)) {
      delete this._guard(key)[this._id];
      return true;
    }
    return false;
  }
  has(key) {
    return !!this._guard(key)[this._id];
  }
  _guard(key) {
    if (key !== Object(key)) {
      throw TypeError("Value of WeakMap is not a non-null object.");
    }
    return key;
  }
};
var WeakMap_default = WeakMap;

// src/util/symbol.ts
var Triangle = Path_default.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(path, shape) {
    const cx = shape.cx;
    const cy = shape.cy;
    const width = shape.width / 2;
    const height = shape.height / 2;
    path.moveTo(cx, cy - height);
    path.lineTo(cx + width, cy + height);
    path.lineTo(cx - width, cy + height);
    path.closePath();
  }
});
var Diamond = Path_default.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(path, shape) {
    const cx = shape.cx;
    const cy = shape.cy;
    const width = shape.width / 2;
    const height = shape.height / 2;
    path.moveTo(cx, cy - height);
    path.lineTo(cx + width, cy);
    path.lineTo(cx, cy + height);
    path.lineTo(cx - width, cy);
    path.closePath();
  }
});
var Pin = Path_default.extend({
  type: "pin",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(path, shape) {
    const x = shape.x;
    const y = shape.y;
    const w = shape.width / 5 * 3;
    const h = Math.max(w, shape.height);
    const r = w / 2;
    const dy = r * r / (h - r);
    const cy = y - h + r + dy;
    const angle = Math.asin(dy / r);
    const dx = Math.cos(angle) * r;
    const tanX = Math.sin(angle);
    const tanY = Math.cos(angle);
    const cpLen = r * 0.6;
    const cpLen2 = r * 0.7;
    path.moveTo(x - dx, cy + dy);
    path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);
    path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);
    path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);
    path.closePath();
  }
});
var Arrow = Path_default.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(ctx, shape) {
    const height = shape.height;
    const width = shape.width;
    const x = shape.x;
    const y = shape.y;
    const dx = width / 3 * 2;
    ctx.moveTo(x, y);
    ctx.lineTo(x + dx, y + height);
    ctx.lineTo(x, y + height / 4 * 3);
    ctx.lineTo(x - dx, y + height);
    ctx.lineTo(x, y);
    ctx.closePath();
  }
});
var symbolCtors = {
  line: Line_default,
  rect: Rect_default,
  roundRect: Rect_default,
  square: Rect_default,
  circle: Circle_default,
  diamond: Diamond,
  pin: Pin,
  arrow: Arrow,
  triangle: Triangle
};
var symbolShapeMakers = {
  line: function(x, y, w, h, shape) {
    shape.x1 = x;
    shape.y1 = y + h / 2;
    shape.x2 = x + w;
    shape.y2 = y + h / 2;
  },
  rect: function(x, y, w, h, shape) {
    shape.x = x;
    shape.y = y;
    shape.width = w;
    shape.height = h;
  },
  roundRect: function(x, y, w, h, shape) {
    shape.x = x;
    shape.y = y;
    shape.width = w;
    shape.height = h;
    shape.r = Math.min(w, h) / 4;
  },
  square: function(x, y, w, h, shape) {
    const size = Math.min(w, h);
    shape.x = x;
    shape.y = y;
    shape.width = size;
    shape.height = size;
  },
  circle: function(x, y, w, h, shape) {
    shape.cx = x + w / 2;
    shape.cy = y + h / 2;
    shape.r = Math.min(w, h) / 2;
  },
  diamond: function(x, y, w, h, shape) {
    shape.cx = x + w / 2;
    shape.cy = y + h / 2;
    shape.width = w;
    shape.height = h;
  },
  pin: function(x, y, w, h, shape) {
    shape.x = x + w / 2;
    shape.y = y + h / 2;
    shape.width = w;
    shape.height = h;
  },
  arrow: function(x, y, w, h, shape) {
    shape.x = x + w / 2;
    shape.y = y + h / 2;
    shape.width = w;
    shape.height = h;
  },
  triangle: function(x, y, w, h, shape) {
    shape.cx = x + w / 2;
    shape.cy = y + h / 2;
    shape.width = w;
    shape.height = h;
  }
};
var symbolBuildProxies = {};
each(symbolCtors, function(Ctor, name) {
  symbolBuildProxies[name] = new Ctor();
});
var SymbolClz = Path_default.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition(out2, config, rect) {
    const res = calculateTextPosition(out2, config, rect);
    const shape = this.shape;
    if (shape && shape.symbolType === "pin" && config.position === "inside") {
      res.y = rect.y + rect.height * 0.4;
    }
    return res;
  },
  buildPath(ctx, shape, inBundle) {
    let symbolType = shape.symbolType;
    if (symbolType !== "none") {
      let proxySymbol = symbolBuildProxies[symbolType];
      if (!proxySymbol) {
        symbolType = "rect";
        proxySymbol = symbolBuildProxies[symbolType];
      }
      symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
      proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
    }
  }
});
function symbolPathSetColor(color2, innerColor2) {
  if (this.type !== "image") {
    const symbolStyle = this.style;
    if (this.__isEmptyBrush) {
      symbolStyle.stroke = color2;
      symbolStyle.fill = innerColor2 || "#fff";
      symbolStyle.lineWidth = 2;
    } else if (this.shape.symbolType === "line") {
      symbolStyle.stroke = color2;
    } else {
      symbolStyle.fill = color2;
    }
    this.markRedraw();
  }
}
function createSymbol(symbolType, x, y, w, h, color2, keepAspect) {
  const isEmpty = symbolType.indexOf("empty") === 0;
  if (isEmpty) {
    symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
  }
  let symbolPath;
  if (symbolType.indexOf("image://") === 0) {
    symbolPath = makeImage(symbolType.slice(8), new BoundingRect_default(x, y, w, h), keepAspect ? "center" : "cover");
  } else if (symbolType.indexOf("path://") === 0) {
    symbolPath = makePath(symbolType.slice(7), {}, new BoundingRect_default(x, y, w, h), keepAspect ? "center" : "cover");
  } else {
    symbolPath = new SymbolClz({
      shape: {
        symbolType,
        x,
        y,
        width: w,
        height: h
      }
    });
  }
  symbolPath.__isEmptyBrush = isEmpty;
  symbolPath.setColor = symbolPathSetColor;
  if (color2) {
    symbolPath.setColor(color2);
  }
  return symbolPath;
}
function normalizeSymbolSize(symbolSize) {
  if (!isArray(symbolSize)) {
    symbolSize = [+symbolSize, +symbolSize];
  }
  return [symbolSize[0] || 0, symbolSize[1] || 0];
}
function normalizeSymbolOffset(symbolOffset, symbolSize) {
  if (symbolOffset == null) {
    return;
  }
  if (!isArray(symbolOffset)) {
    symbolOffset = [symbolOffset, symbolOffset];
  }
  return [
    parsePercent2(symbolOffset[0], symbolSize[0]) || 0,
    parsePercent2(retrieve2(symbolOffset[1], symbolOffset[0]), symbolSize[1]) || 0
  ];
}

// node_modules/zrender/src/canvas/helper.ts
function isSafeNum(num) {
  return isFinite(num);
}
function createLinearGradient(ctx, obj, rect) {
  let x = obj.x == null ? 0 : obj.x;
  let x2 = obj.x2 == null ? 1 : obj.x2;
  let y = obj.y == null ? 0 : obj.y;
  let y2 = obj.y2 == null ? 0 : obj.y2;
  if (!obj.global) {
    x = x * rect.width + rect.x;
    x2 = x2 * rect.width + rect.x;
    y = y * rect.height + rect.y;
    y2 = y2 * rect.height + rect.y;
  }
  x = isSafeNum(x) ? x : 0;
  x2 = isSafeNum(x2) ? x2 : 1;
  y = isSafeNum(y) ? y : 0;
  y2 = isSafeNum(y2) ? y2 : 0;
  const canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
  return canvasGradient;
}
function createRadialGradient(ctx, obj, rect) {
  const width = rect.width;
  const height = rect.height;
  const min3 = Math.min(width, height);
  let x = obj.x == null ? 0.5 : obj.x;
  let y = obj.y == null ? 0.5 : obj.y;
  let r = obj.r == null ? 0.5 : obj.r;
  if (!obj.global) {
    x = x * width + rect.x;
    y = y * height + rect.y;
    r = r * min3;
  }
  x = isSafeNum(x) ? x : 0.5;
  y = isSafeNum(y) ? y : 0.5;
  r = r >= 0 && isSafeNum(r) ? r : 0.5;
  const canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
  return canvasGradient;
}
function getCanvasGradient(ctx, obj, rect) {
  const canvasGradient = obj.type === "radial" ? createRadialGradient(ctx, obj, rect) : createLinearGradient(ctx, obj, rect);
  const colorStops = obj.colorStops;
  for (let i = 0; i < colorStops.length; i++) {
    canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
  }
  return canvasGradient;
}
function isClipPathChanged(clipPaths, prevClipPaths) {
  if (clipPaths === prevClipPaths || !clipPaths && !prevClipPaths) {
    return false;
  }
  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
    return true;
  }
  for (let i = 0; i < clipPaths.length; i++) {
    if (clipPaths[i] !== prevClipPaths[i]) {
      return true;
    }
  }
  return false;
}
function parseInt10(val) {
  return parseInt(val, 10);
}
function getSize(root, whIdx, opts) {
  const wh = ["width", "height"][whIdx];
  const cwh = ["clientWidth", "clientHeight"][whIdx];
  const plt = ["paddingLeft", "paddingTop"][whIdx];
  const prb = ["paddingRight", "paddingBottom"][whIdx];
  if (opts[wh] != null && opts[wh] !== "auto") {
    return parseFloat(opts[wh]);
  }
  const stl = document.defaultView.getComputedStyle(root);
  return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;
}

// node_modules/zrender/src/canvas/dashStyle.ts
function normalizeLineDash(lineType, lineWidth) {
  if (!lineType || lineType === "solid" || !(lineWidth > 0)) {
    return null;
  }
  return lineType === "dashed" ? [4 * lineWidth, 2 * lineWidth] : lineType === "dotted" ? [lineWidth] : isNumber(lineType) ? [lineType] : isArray(lineType) ? lineType : null;
}
function getLineDash(el) {
  const style = el.style;
  let lineDash = style.lineDash && style.lineWidth > 0 && normalizeLineDash(style.lineDash, style.lineWidth);
  let lineDashOffset = style.lineDashOffset;
  if (lineDash) {
    const lineScale = style.strokeNoScale && el.getLineScale ? el.getLineScale() : 1;
    if (lineScale && lineScale !== 1) {
      lineDash = map(lineDash, function(rawVal) {
        return rawVal / lineScale;
      });
      lineDashOffset /= lineScale;
    }
  }
  return [lineDash, lineDashOffset];
}

// node_modules/zrender/src/canvas/graphic.ts
var pathProxyForDraw = new PathProxy_default(true);
function styleHasStroke(style) {
  const stroke = style.stroke;
  return !(stroke == null || stroke === "none" || !(style.lineWidth > 0));
}
function isValidStrokeFillStyle(strokeOrFill) {
  return typeof strokeOrFill === "string" && strokeOrFill !== "none";
}
function styleHasFill(style) {
  const fill = style.fill;
  return fill != null && fill !== "none";
}
function doFillPath(ctx, style) {
  if (style.fillOpacity != null && style.fillOpacity !== 1) {
    const originalGlobalAlpha = ctx.globalAlpha;
    ctx.globalAlpha = style.fillOpacity * style.opacity;
    ctx.fill();
    ctx.globalAlpha = originalGlobalAlpha;
  } else {
    ctx.fill();
  }
}
function doStrokePath(ctx, style) {
  if (style.strokeOpacity != null && style.strokeOpacity !== 1) {
    const originalGlobalAlpha = ctx.globalAlpha;
    ctx.globalAlpha = style.strokeOpacity * style.opacity;
    ctx.stroke();
    ctx.globalAlpha = originalGlobalAlpha;
  } else {
    ctx.stroke();
  }
}
function createCanvasPattern(ctx, pattern, el) {
  const image = createOrUpdateImage(pattern.image, pattern.__image, el);
  if (isImageReady(image)) {
    const canvasPattern = ctx.createPattern(image, pattern.repeat || "repeat");
    if (typeof DOMMatrix === "function" && canvasPattern && canvasPattern.setTransform) {
      const matrix13 = new DOMMatrix();
      matrix13.translateSelf(pattern.x || 0, pattern.y || 0);
      matrix13.rotateSelf(0, 0, (pattern.rotation || 0) * RADIAN_TO_DEGREE);
      matrix13.scaleSelf(pattern.scaleX || 1, pattern.scaleY || 1);
      canvasPattern.setTransform(matrix13);
    }
    return canvasPattern;
  }
}
function brushPath(ctx, el, style, inBatch) {
  let hasStroke = styleHasStroke(style);
  let hasFill = styleHasFill(style);
  const strokePercent = style.strokePercent;
  const strokePart = strokePercent < 1;
  const firstDraw = !el.path;
  if ((!el.silent || strokePart) && firstDraw) {
    el.createPathProxy();
  }
  const path = el.path || pathProxyForDraw;
  const dirtyFlag = el.__dirty;
  if (!inBatch) {
    const fill = style.fill;
    const stroke = style.stroke;
    const hasFillGradient = hasFill && !!fill.colorStops;
    const hasStrokeGradient = hasStroke && !!stroke.colorStops;
    const hasFillPattern = hasFill && !!fill.image;
    const hasStrokePattern = hasStroke && !!stroke.image;
    let fillGradient;
    let strokeGradient;
    let fillPattern;
    let strokePattern;
    let rect;
    if (hasFillGradient || hasStrokeGradient) {
      rect = el.getBoundingRect();
    }
    if (hasFillGradient) {
      fillGradient = dirtyFlag ? getCanvasGradient(ctx, fill, rect) : el.__canvasFillGradient;
      el.__canvasFillGradient = fillGradient;
    }
    if (hasStrokeGradient) {
      strokeGradient = dirtyFlag ? getCanvasGradient(ctx, stroke, rect) : el.__canvasStrokeGradient;
      el.__canvasStrokeGradient = strokeGradient;
    }
    if (hasFillPattern) {
      fillPattern = dirtyFlag || !el.__canvasFillPattern ? createCanvasPattern(ctx, fill, el) : el.__canvasFillPattern;
      el.__canvasFillPattern = fillPattern;
    }
    if (hasStrokePattern) {
      strokePattern = dirtyFlag || !el.__canvasStrokePattern ? createCanvasPattern(ctx, stroke, el) : el.__canvasStrokePattern;
      el.__canvasStrokePattern = fillPattern;
    }
    if (hasFillGradient) {
      ctx.fillStyle = fillGradient;
    } else if (hasFillPattern) {
      if (fillPattern) {
        ctx.fillStyle = fillPattern;
      } else {
        hasFill = false;
      }
    }
    if (hasStrokeGradient) {
      ctx.strokeStyle = strokeGradient;
    } else if (hasStrokePattern) {
      if (strokePattern) {
        ctx.strokeStyle = strokePattern;
      } else {
        hasStroke = false;
      }
    }
  }
  const scale4 = el.getGlobalScale();
  path.setScale(scale4[0], scale4[1], el.segmentIgnoreThreshold);
  let lineDash;
  let lineDashOffset;
  if (ctx.setLineDash && style.lineDash) {
    [lineDash, lineDashOffset] = getLineDash(el);
  }
  let needsRebuild = true;
  if (firstDraw || dirtyFlag & SHAPE_CHANGED_BIT) {
    path.setDPR(ctx.dpr);
    if (strokePart) {
      path.setContext(null);
    } else {
      path.setContext(ctx);
      needsRebuild = false;
    }
    path.reset();
    el.buildPath(path, el.shape, inBatch);
    path.toStatic();
    el.pathUpdated();
  }
  if (needsRebuild) {
    path.rebuildPath(ctx, strokePart ? strokePercent : 1);
  }
  if (lineDash) {
    ctx.setLineDash(lineDash);
    ctx.lineDashOffset = lineDashOffset;
  }
  if (!inBatch) {
    if (style.strokeFirst) {
      if (hasStroke) {
        doStrokePath(ctx, style);
      }
      if (hasFill) {
        doFillPath(ctx, style);
      }
    } else {
      if (hasFill) {
        doFillPath(ctx, style);
      }
      if (hasStroke) {
        doStrokePath(ctx, style);
      }
    }
  }
  if (lineDash) {
    ctx.setLineDash([]);
  }
}
function brushImage(ctx, el, style) {
  const image = el.__image = createOrUpdateImage(style.image, el.__image, el, el.onload);
  if (!image || !isImageReady(image)) {
    return;
  }
  const x = style.x || 0;
  const y = style.y || 0;
  let width = el.getWidth();
  let height = el.getHeight();
  const aspect = image.width / image.height;
  if (width == null && height != null) {
    width = height * aspect;
  } else if (height == null && width != null) {
    height = width / aspect;
  } else if (width == null && height == null) {
    width = image.width;
    height = image.height;
  }
  if (style.sWidth && style.sHeight) {
    const sx = style.sx || 0;
    const sy = style.sy || 0;
    ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
  } else if (style.sx && style.sy) {
    const sx = style.sx;
    const sy = style.sy;
    const sWidth = width - sx;
    const sHeight = height - sy;
    ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
  } else {
    ctx.drawImage(image, x, y, width, height);
  }
}
function brushText(ctx, el, style) {
  let text = style.text;
  text != null && (text += "");
  if (text) {
    ctx.font = style.font || DEFAULT_FONT;
    ctx.textAlign = style.textAlign;
    ctx.textBaseline = style.textBaseline;
    let lineDash;
    let lineDashOffset;
    if (ctx.setLineDash && style.lineDash) {
      [lineDash, lineDashOffset] = getLineDash(el);
    }
    if (lineDash) {
      ctx.setLineDash(lineDash);
      ctx.lineDashOffset = lineDashOffset;
    }
    if (style.strokeFirst) {
      if (styleHasStroke(style)) {
        ctx.strokeText(text, style.x, style.y);
      }
      if (styleHasFill(style)) {
        ctx.fillText(text, style.x, style.y);
      }
    } else {
      if (styleHasFill(style)) {
        ctx.fillText(text, style.x, style.y);
      }
      if (styleHasStroke(style)) {
        ctx.strokeText(text, style.x, style.y);
      }
    }
    if (lineDash) {
      ctx.setLineDash([]);
    }
  }
}
var SHADOW_NUMBER_PROPS = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"];
var STROKE_PROPS = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function bindCommonProps(ctx, style, prevStyle, forceSetAll, scope) {
  let styleChanged = false;
  if (!forceSetAll) {
    prevStyle = prevStyle || {};
    if (style === prevStyle) {
      return false;
    }
  }
  if (forceSetAll || style.opacity !== prevStyle.opacity) {
    flushPathDrawn(ctx, scope);
    styleChanged = true;
    const opacity = Math.max(Math.min(style.opacity, 1), 0);
    ctx.globalAlpha = isNaN(opacity) ? DEFAULT_COMMON_STYLE.opacity : opacity;
  }
  if (forceSetAll || style.blend !== prevStyle.blend) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    ctx.globalCompositeOperation = style.blend || DEFAULT_COMMON_STYLE.blend;
  }
  for (let i = 0; i < SHADOW_NUMBER_PROPS.length; i++) {
    const propName = SHADOW_NUMBER_PROPS[i];
    if (forceSetAll || style[propName] !== prevStyle[propName]) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx[propName] = ctx.dpr * (style[propName] || 0);
    }
  }
  if (forceSetAll || style.shadowColor !== prevStyle.shadowColor) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    ctx.shadowColor = style.shadowColor || DEFAULT_COMMON_STYLE.shadowColor;
  }
  return styleChanged;
}
function bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetAll, scope) {
  const style = getStyle(el, scope.inHover);
  const prevStyle = forceSetAll ? null : prevEl && getStyle(prevEl, scope.inHover) || {};
  if (style === prevStyle) {
    return false;
  }
  let styleChanged = bindCommonProps(ctx, style, prevStyle, forceSetAll, scope);
  if (forceSetAll || style.fill !== prevStyle.fill) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    isValidStrokeFillStyle(style.fill) && (ctx.fillStyle = style.fill);
  }
  if (forceSetAll || style.stroke !== prevStyle.stroke) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    isValidStrokeFillStyle(style.stroke) && (ctx.strokeStyle = style.stroke);
  }
  if (forceSetAll || style.opacity !== prevStyle.opacity) {
    if (!styleChanged) {
      flushPathDrawn(ctx, scope);
      styleChanged = true;
    }
    ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
  }
  if (el.hasStroke()) {
    const lineWidth = style.lineWidth;
    const newLineWidth = lineWidth / (style.strokeNoScale && el.getLineScale ? el.getLineScale() : 1);
    if (ctx.lineWidth !== newLineWidth) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx.lineWidth = newLineWidth;
    }
  }
  for (let i = 0; i < STROKE_PROPS.length; i++) {
    const prop = STROKE_PROPS[i];
    const propName = prop[0];
    if (forceSetAll || style[propName] !== prevStyle[propName]) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope);
        styleChanged = true;
      }
      ctx[propName] = style[propName] || prop[1];
    }
  }
  return styleChanged;
}
function bindImageStyle(ctx, el, prevEl, forceSetAll, scope) {
  return bindCommonProps(ctx, getStyle(el, scope.inHover), prevEl && getStyle(prevEl, scope.inHover), forceSetAll, scope);
}
function setContextTransform(ctx, el) {
  const m2 = el.transform;
  const dpr2 = ctx.dpr || 1;
  if (m2) {
    ctx.setTransform(dpr2 * m2[0], dpr2 * m2[1], dpr2 * m2[2], dpr2 * m2[3], dpr2 * m2[4], dpr2 * m2[5]);
  } else {
    ctx.setTransform(dpr2, 0, 0, dpr2, 0, 0);
  }
}
function updateClipStatus(clipPaths, ctx, scope) {
  let allClipped = false;
  for (let i = 0; i < clipPaths.length; i++) {
    const clipPath = clipPaths[i];
    allClipped = allClipped || clipPath.isZeroArea();
    setContextTransform(ctx, clipPath);
    ctx.beginPath();
    clipPath.buildPath(ctx, clipPath.shape);
    ctx.clip();
  }
  scope.allClipped = allClipped;
}
function isTransformChanged(m0, m1) {
  if (m0 && m1) {
    return m0[0] !== m1[0] || m0[1] !== m1[1] || m0[2] !== m1[2] || m0[3] !== m1[3] || m0[4] !== m1[4] || m0[5] !== m1[5];
  } else if (!m0 && !m1) {
    return false;
  }
  return true;
}
var DRAW_TYPE_PATH = 1;
var DRAW_TYPE_IMAGE = 2;
var DRAW_TYPE_TEXT = 3;
var DRAW_TYPE_INCREMENTAL = 4;
function canPathBatch(style) {
  const hasFill = styleHasFill(style);
  const hasStroke = styleHasStroke(style);
  return !(style.lineDash || !(+hasFill ^ +hasStroke) || hasFill && typeof style.fill !== "string" || hasStroke && typeof style.stroke !== "string" || style.strokePercent < 1 || style.strokeOpacity < 1 || style.fillOpacity < 1);
}
function flushPathDrawn(ctx, scope) {
  scope.batchFill && ctx.fill();
  scope.batchStroke && ctx.stroke();
  scope.batchFill = "";
  scope.batchStroke = "";
}
function getStyle(el, inHover) {
  return inHover ? el.__hoverStyle || el.style : el.style;
}
function brushSingle(ctx, el) {
  brush(ctx, el, {inHover: false, viewWidth: 0, viewHeight: 0}, true);
}
function brush(ctx, el, scope, isLast) {
  const m2 = el.transform;
  if (!el.shouldBePainted(scope.viewWidth, scope.viewHeight, false, false)) {
    el.__dirty &= ~REDRAW_BIT;
    el.__isRendered = false;
    return;
  }
  const clipPaths = el.__clipPaths;
  const prevElClipPaths = scope.prevElClipPaths;
  let forceSetTransform = false;
  let forceSetStyle = false;
  if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {
    if (prevElClipPaths && prevElClipPaths.length) {
      flushPathDrawn(ctx, scope);
      ctx.restore();
      forceSetStyle = forceSetTransform = true;
      scope.prevElClipPaths = null;
      scope.allClipped = false;
      scope.prevEl = null;
    }
    if (clipPaths && clipPaths.length) {
      flushPathDrawn(ctx, scope);
      ctx.save();
      updateClipStatus(clipPaths, ctx, scope);
      forceSetTransform = true;
    }
    scope.prevElClipPaths = clipPaths;
  }
  if (scope.allClipped) {
    el.__isRendered = false;
    return;
  }
  el.beforeBrush && el.beforeBrush();
  el.innerBeforeBrush();
  const prevEl = scope.prevEl;
  if (!prevEl) {
    forceSetStyle = forceSetTransform = true;
  }
  let canBatchPath = el instanceof Path_default && el.autoBatch && canPathBatch(el.style);
  if (forceSetTransform || isTransformChanged(m2, prevEl.transform)) {
    flushPathDrawn(ctx, scope);
    setContextTransform(ctx, el);
  } else if (!canBatchPath) {
    flushPathDrawn(ctx, scope);
  }
  const style = getStyle(el, scope.inHover);
  if (el instanceof Path_default) {
    if (scope.lastDrawType !== DRAW_TYPE_PATH) {
      forceSetStyle = true;
      scope.lastDrawType = DRAW_TYPE_PATH;
    }
    bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
    if (!canBatchPath || !scope.batchFill && !scope.batchStroke) {
      ctx.beginPath();
    }
    brushPath(ctx, el, style, canBatchPath);
    if (canBatchPath) {
      scope.batchFill = style.fill || "";
      scope.batchStroke = style.stroke || "";
    }
  } else {
    if (el instanceof TSpan_default) {
      if (scope.lastDrawType !== DRAW_TYPE_TEXT) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_TEXT;
      }
      bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
      brushText(ctx, el, style);
    } else if (el instanceof Image_default) {
      if (scope.lastDrawType !== DRAW_TYPE_IMAGE) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_IMAGE;
      }
      bindImageStyle(ctx, el, prevEl, forceSetStyle, scope);
      brushImage(ctx, el, style);
    } else if (el.getTemporalDisplayables) {
      if (scope.lastDrawType !== DRAW_TYPE_INCREMENTAL) {
        forceSetStyle = true;
        scope.lastDrawType = DRAW_TYPE_INCREMENTAL;
      }
      brushIncremental(ctx, el, scope);
    }
  }
  if (canBatchPath && isLast) {
    flushPathDrawn(ctx, scope);
  }
  el.innerAfterBrush();
  el.afterBrush && el.afterBrush();
  scope.prevEl = el;
  el.__dirty = 0;
  el.__isRendered = true;
}
function brushIncremental(ctx, el, scope) {
  let displayables = el.getDisplayables();
  let temporalDisplayables = el.getTemporalDisplayables();
  ctx.save();
  let innerScope = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: false,
    viewWidth: scope.viewWidth,
    viewHeight: scope.viewHeight,
    inHover: scope.inHover
  };
  let i;
  let len2;
  for (i = el.getCursor(), len2 = displayables.length; i < len2; i++) {
    const displayable = displayables[i];
    displayable.beforeBrush && displayable.beforeBrush();
    displayable.innerBeforeBrush();
    brush(ctx, displayable, innerScope, i === len2 - 1);
    displayable.innerAfterBrush();
    displayable.afterBrush && displayable.afterBrush();
    innerScope.prevEl = displayable;
  }
  for (let i2 = 0, len3 = temporalDisplayables.length; i2 < len3; i2++) {
    const displayable = temporalDisplayables[i2];
    displayable.beforeBrush && displayable.beforeBrush();
    displayable.innerBeforeBrush();
    brush(ctx, displayable, innerScope, i2 === len3 - 1);
    displayable.innerAfterBrush();
    displayable.afterBrush && displayable.afterBrush();
    innerScope.prevEl = displayable;
  }
  el.clearTemporalDisplayables();
  el.notClear = true;
  ctx.restore();
}

// src/util/decal.ts
var decalMap = new WeakMap_default();
var decalCache = new LRU_default(100);
var decalKeys = [
  "symbol",
  "symbolSize",
  "symbolKeepAspect",
  "color",
  "backgroundColor",
  "dashArrayX",
  "dashArrayY",
  "maxTileWidth",
  "maxTileHeight"
];
function createOrUpdatePatternFromDecal(decalObject, api2) {
  if (decalObject === "none") {
    return null;
  }
  const dpr2 = api2.getDevicePixelRatio();
  const zr = api2.getZr();
  const isSVG = zr.painter.type === "svg";
  if (decalObject.dirty) {
    decalMap.delete(decalObject);
  }
  const oldPattern = decalMap.get(decalObject);
  if (oldPattern) {
    return oldPattern;
  }
  const decalOpt = defaults(decalObject, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: true,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  if (decalOpt.backgroundColor === "none") {
    decalOpt.backgroundColor = null;
  }
  const pattern = {repeat: "repeat"};
  setPatternnSource(pattern);
  pattern.rotation = decalOpt.rotation;
  pattern.scaleX = pattern.scaleY = isSVG ? 1 : 1 / dpr2;
  decalMap.set(decalObject, pattern);
  decalObject.dirty = false;
  return pattern;
  function setPatternnSource(pattern2) {
    const keys2 = [dpr2];
    let isValidKey = true;
    for (let i = 0; i < decalKeys.length; ++i) {
      const value = decalOpt[decalKeys[i]];
      if (value != null && !isArray(value) && !isString(value) && !isNumber(value) && typeof value !== "boolean") {
        isValidKey = false;
        break;
      }
      keys2.push(value);
    }
    let cacheKey;
    if (isValidKey) {
      cacheKey = keys2.join(",") + (isSVG ? "-svg" : "");
      const cache = decalCache.get(cacheKey);
      if (cache) {
        isSVG ? pattern2.svgElement = cache : pattern2.image = cache;
      }
    }
    const dashArrayX = normalizeDashArrayX(decalOpt.dashArrayX);
    const dashArrayY = normalizeDashArrayY(decalOpt.dashArrayY);
    const symbolArray = normalizeSymbolArray(decalOpt.symbol);
    const lineBlockLengthsX = getLineBlockLengthX(dashArrayX);
    const lineBlockLengthY = getLineBlockLengthY(dashArrayY);
    const canvas = !isSVG && platformApi.createCanvas();
    const svgRoot = isSVG && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    };
    const pSize = getPatternSize();
    let ctx;
    if (canvas) {
      canvas.width = pSize.width * dpr2;
      canvas.height = pSize.height * dpr2;
      ctx = canvas.getContext("2d");
    }
    brushDecal();
    if (isValidKey) {
      decalCache.put(cacheKey, canvas || svgRoot);
    }
    pattern2.image = canvas;
    pattern2.svgElement = svgRoot;
    pattern2.svgWidth = pSize.width;
    pattern2.svgHeight = pSize.height;
    function getPatternSize() {
      let width = 1;
      for (let i = 0, xlen = lineBlockLengthsX.length; i < xlen; ++i) {
        width = getLeastCommonMultiple(width, lineBlockLengthsX[i]);
      }
      let symbolRepeats = 1;
      for (let i = 0, xlen = symbolArray.length; i < xlen; ++i) {
        symbolRepeats = getLeastCommonMultiple(symbolRepeats, symbolArray[i].length);
      }
      width *= symbolRepeats;
      const height = lineBlockLengthY * lineBlockLengthsX.length * symbolArray.length;
      if (true) {
        const warn2 = (attrName) => {
          console.warn(`Calculated decal size is greater than ${attrName} due to decal option settings so ${attrName} is used for the decal size. Please consider changing the decal option to make a smaller decal or set ${attrName} to be larger to avoid incontinuity.`);
        };
        if (width > decalOpt.maxTileWidth) {
          warn2("maxTileWidth");
        }
        if (height > decalOpt.maxTileHeight) {
          warn2("maxTileHeight");
        }
      }
      return {
        width: Math.max(1, Math.min(width, decalOpt.maxTileWidth)),
        height: Math.max(1, Math.min(height, decalOpt.maxTileHeight))
      };
    }
    function brushDecal() {
      if (ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (decalOpt.backgroundColor) {
          ctx.fillStyle = decalOpt.backgroundColor;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
      }
      let ySum = 0;
      for (let i = 0; i < dashArrayY.length; ++i) {
        ySum += dashArrayY[i];
      }
      if (ySum <= 0) {
        return;
      }
      let y = -lineBlockLengthY;
      let yId = 0;
      let yIdTotal = 0;
      let xId0 = 0;
      while (y < pSize.height) {
        if (yId % 2 === 0) {
          const symbolYId = yIdTotal / 2 % symbolArray.length;
          let x = 0;
          let xId1 = 0;
          let xId1Total = 0;
          while (x < pSize.width * 2) {
            let xSum = 0;
            for (let i = 0; i < dashArrayX[xId0].length; ++i) {
              xSum += dashArrayX[xId0][i];
            }
            if (xSum <= 0) {
              break;
            }
            if (xId1 % 2 === 0) {
              const size = (1 - decalOpt.symbolSize) * 0.5;
              const left = x + dashArrayX[xId0][xId1] * size;
              const top = y + dashArrayY[yId] * size;
              const width = dashArrayX[xId0][xId1] * decalOpt.symbolSize;
              const height = dashArrayY[yId] * decalOpt.symbolSize;
              const symbolXId = xId1Total / 2 % symbolArray[symbolYId].length;
              brushSymbol(left, top, width, height, symbolArray[symbolYId][symbolXId]);
            }
            x += dashArrayX[xId0][xId1];
            ++xId1Total;
            ++xId1;
            if (xId1 === dashArrayX[xId0].length) {
              xId1 = 0;
            }
          }
          ++xId0;
          if (xId0 === dashArrayX.length) {
            xId0 = 0;
          }
        }
        y += dashArrayY[yId];
        ++yIdTotal;
        ++yId;
        if (yId === dashArrayY.length) {
          yId = 0;
        }
      }
      function brushSymbol(x, y2, width, height, symbolType) {
        const scale4 = isSVG ? 1 : dpr2;
        const symbol = createSymbol(symbolType, x * scale4, y2 * scale4, width * scale4, height * scale4, decalOpt.color, decalOpt.symbolKeepAspect);
        if (isSVG) {
          const symbolVNode = zr.painter.renderOneToVNode(symbol);
          if (symbolVNode) {
            svgRoot.children.push(symbolVNode);
          }
        } else {
          brushSingle(ctx, symbol);
        }
      }
    }
  }
}
function normalizeSymbolArray(symbol) {
  if (!symbol || symbol.length === 0) {
    return [["rect"]];
  }
  if (isString(symbol)) {
    return [[symbol]];
  }
  let isAllString = true;
  for (let i = 0; i < symbol.length; ++i) {
    if (!isString(symbol[i])) {
      isAllString = false;
      break;
    }
  }
  if (isAllString) {
    return normalizeSymbolArray([symbol]);
  }
  const result = [];
  for (let i = 0; i < symbol.length; ++i) {
    if (isString(symbol[i])) {
      result.push([symbol[i]]);
    } else {
      result.push(symbol[i]);
    }
  }
  return result;
}
function normalizeDashArrayX(dash) {
  if (!dash || dash.length === 0) {
    return [[0, 0]];
  }
  if (isNumber(dash)) {
    const dashValue = Math.ceil(dash);
    return [[dashValue, dashValue]];
  }
  let isAllNumber = true;
  for (let i = 0; i < dash.length; ++i) {
    if (!isNumber(dash[i])) {
      isAllNumber = false;
      break;
    }
  }
  if (isAllNumber) {
    return normalizeDashArrayX([dash]);
  }
  const result = [];
  for (let i = 0; i < dash.length; ++i) {
    if (isNumber(dash[i])) {
      const dashValue = Math.ceil(dash[i]);
      result.push([dashValue, dashValue]);
    } else {
      const dashValue = map(dash[i], (n) => Math.ceil(n));
      if (dashValue.length % 2 === 1) {
        result.push(dashValue.concat(dashValue));
      } else {
        result.push(dashValue);
      }
    }
  }
  return result;
}
function normalizeDashArrayY(dash) {
  if (!dash || typeof dash === "object" && dash.length === 0) {
    return [0, 0];
  }
  if (isNumber(dash)) {
    const dashValue2 = Math.ceil(dash);
    return [dashValue2, dashValue2];
  }
  const dashValue = map(dash, (n) => Math.ceil(n));
  return dash.length % 2 ? dashValue.concat(dashValue) : dashValue;
}
function getLineBlockLengthX(dash) {
  return map(dash, function(line2) {
    return getLineBlockLengthY(line2);
  });
}
function getLineBlockLengthY(dash) {
  let blockLength = 0;
  for (let i = 0; i < dash.length; ++i) {
    blockLength += dash[i];
  }
  if (dash.length % 2 === 1) {
    return blockLength * 2;
  }
  return blockLength;
}

// src/visual/decal.ts
function decalVisual(ecModel, api2) {
  ecModel.eachRawSeries((seriesModel) => {
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    const data = seriesModel.getData();
    if (data.hasItemVisual()) {
      data.each((idx) => {
        const decal2 = data.getItemVisual(idx, "decal");
        if (decal2) {
          const itemStyle = data.ensureUniqueItemVisual(idx, "style");
          itemStyle.decal = createOrUpdatePatternFromDecal(decal2, api2);
        }
      });
    }
    const decal = data.getVisual("decal");
    if (decal) {
      const style = data.getVisual("style");
      style.decal = createOrUpdatePatternFromDecal(decal, api2);
    }
  });
}

// src/core/lifecycle.ts
var lifecycle = new Eventful_default();
var lifecycle_default = lifecycle;

// src/core/impl.ts
var implsStore = {};
function registerImpl(name, impl) {
  if (true) {
    if (implsStore[name]) {
      error(`Already has an implementation of ${name}.`);
    }
  }
  implsStore[name] = impl;
}
function getImpl(name) {
  if (true) {
    if (!implsStore[name]) {
      error(`Implementation of ${name} doesn't exists.`);
    }
  }
  return implsStore[name];
}

// src/core/echarts.ts
var version2 = "5.5.0";
var dependencies = {
  zrender: "5.5.0"
};
var TEST_FRAME_REMAIN_TIME = 1;
var PRIORITY_PROCESSOR_SERIES_FILTER = 800;
var PRIORITY_PROCESSOR_DATASTACK = 900;
var PRIORITY_PROCESSOR_FILTER = 1e3;
var PRIORITY_PROCESSOR_DEFAULT = 2e3;
var PRIORITY_PROCESSOR_STATISTIC = 5e3;
var PRIORITY_VISUAL_LAYOUT = 1e3;
var PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100;
var PRIORITY_VISUAL_GLOBAL = 2e3;
var PRIORITY_VISUAL_CHART = 3e3;
var PRIORITY_VISUAL_COMPONENT = 4e3;
var PRIORITY_VISUAL_CHART_DATA_CUSTOM = 4500;
var PRIORITY_VISUAL_POST_CHART_LAYOUT = 4600;
var PRIORITY_VISUAL_BRUSH = 5e3;
var PRIORITY_VISUAL_ARIA = 6e3;
var PRIORITY_VISUAL_DECAL = 7e3;
var PRIORITY = {
  PROCESSOR: {
    FILTER: PRIORITY_PROCESSOR_FILTER,
    SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
    STATISTIC: PRIORITY_PROCESSOR_STATISTIC
  },
  VISUAL: {
    LAYOUT: PRIORITY_VISUAL_LAYOUT,
    PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
    GLOBAL: PRIORITY_VISUAL_GLOBAL,
    CHART: PRIORITY_VISUAL_CHART,
    POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
    COMPONENT: PRIORITY_VISUAL_COMPONENT,
    BRUSH: PRIORITY_VISUAL_BRUSH,
    CHART_ITEM: PRIORITY_VISUAL_CHART_DATA_CUSTOM,
    ARIA: PRIORITY_VISUAL_ARIA,
    DECAL: PRIORITY_VISUAL_DECAL
  }
};
var IN_MAIN_PROCESS_KEY = "__flagInMainProcess";
var PENDING_UPDATE = "__pendingUpdate";
var STATUS_NEEDS_UPDATE_KEY = "__needsUpdateStatus";
var ACTION_REG = /^[a-zA-Z0-9_]+$/;
var CONNECT_STATUS_KEY = "__connectUpdateStatus";
var CONNECT_STATUS_PENDING = 0;
var CONNECT_STATUS_UPDATING = 1;
var CONNECT_STATUS_UPDATED = 2;
function createRegisterEventWithLowercaseECharts(method) {
  return function(...args) {
    if (this.isDisposed()) {
      disposedWarning(this.id);
      return;
    }
    return toLowercaseNameAndCallEventful(this, method, args);
  };
}
function createRegisterEventWithLowercaseMessageCenter(method) {
  return function(...args) {
    return toLowercaseNameAndCallEventful(this, method, args);
  };
}
function toLowercaseNameAndCallEventful(host, method, args) {
  args[0] = args[0] && args[0].toLowerCase();
  return Eventful_default.prototype[method].apply(host, args);
}
var MessageCenter = class extends Eventful_default {
};
var messageCenterProto = MessageCenter.prototype;
messageCenterProto.on = createRegisterEventWithLowercaseMessageCenter("on");
messageCenterProto.off = createRegisterEventWithLowercaseMessageCenter("off");
var prepare;
var prepareView;
var updateDirectly;
var updateMethods;
var doConvertPixel;
var updateStreamModes;
var doDispatchAction;
var flushPendingActions;
var triggerUpdatedEvent;
var bindRenderedEvent;
var bindMouseEvent;
var render;
var renderComponents;
var renderSeries;
var createExtensionAPI;
var enableConnect;
var markStatusToUpdate;
var applyChangedStates;
var ECharts = class extends Eventful_default {
  constructor(dom, theme2, opts) {
    super(new ECEventProcessor());
    this._chartsViews = [];
    this._chartsMap = {};
    this._componentsViews = [];
    this._componentsMap = {};
    this._pendingActions = [];
    opts = opts || {};
    if (isString(theme2)) {
      theme2 = themeStorage[theme2];
    }
    this._dom = dom;
    let defaultRenderer = "canvas";
    let defaultCoarsePointer = "auto";
    let defaultUseDirtyRect = false;
    if (true) {
      const root = env_default.hasGlobalWindow ? window : global;
      if (root) {
        defaultRenderer = retrieve2(root.__ECHARTS__DEFAULT__RENDERER__, defaultRenderer);
        defaultCoarsePointer = retrieve2(root.__ECHARTS__DEFAULT__COARSE_POINTER, defaultCoarsePointer);
        defaultUseDirtyRect = retrieve2(root.__ECHARTS__DEFAULT__USE_DIRTY_RECT__, defaultUseDirtyRect);
      }
    }
    if (opts.ssr) {
      registerSSRDataGetter((el) => {
        const ecData = getECData(el);
        const dataIndex = ecData.dataIndex;
        if (dataIndex == null) {
          return;
        }
        const hashMap = createHashMap();
        hashMap.set("series_index", ecData.seriesIndex);
        hashMap.set("data_index", dataIndex);
        ecData.ssrType && hashMap.set("ssr_type", ecData.ssrType);
        return hashMap;
      });
    }
    const zr = this._zr = init(dom, {
      renderer: opts.renderer || defaultRenderer,
      devicePixelRatio: opts.devicePixelRatio,
      width: opts.width,
      height: opts.height,
      ssr: opts.ssr,
      useDirtyRect: retrieve2(opts.useDirtyRect, defaultUseDirtyRect),
      useCoarsePointer: retrieve2(opts.useCoarsePointer, defaultCoarsePointer),
      pointerSize: opts.pointerSize
    });
    this._ssr = opts.ssr;
    this._throttledZrFlush = throttle(bind(zr.flush, zr), 17);
    theme2 = clone(theme2);
    theme2 && globalBackwardCompat(theme2, true);
    this._theme = theme2;
    this._locale = createLocaleObject(opts.locale || SYSTEM_LANG);
    this._coordSysMgr = new CoordinateSystem_default();
    const api2 = this._api = createExtensionAPI(this);
    function prioritySortFunc(a, b) {
      return a.__prio - b.__prio;
    }
    sort(visualFuncs, prioritySortFunc);
    sort(dataProcessorFuncs, prioritySortFunc);
    this._scheduler = new Scheduler_default(this, api2, dataProcessorFuncs, visualFuncs);
    this._messageCenter = new MessageCenter();
    this._initEvents();
    this.resize = bind(this.resize, this);
    zr.animation.on("frame", this._onframe, this);
    bindRenderedEvent(zr, this);
    bindMouseEvent(zr, this);
    setAsPrimitive(this);
  }
  _onframe() {
    if (this._disposed) {
      return;
    }
    applyChangedStates(this);
    const scheduler = this._scheduler;
    if (this[PENDING_UPDATE]) {
      const silent = this[PENDING_UPDATE].silent;
      this[IN_MAIN_PROCESS_KEY] = true;
      try {
        prepare(this);
        updateMethods.update.call(this, null, this[PENDING_UPDATE].updateParams);
      } catch (e2) {
        this[IN_MAIN_PROCESS_KEY] = false;
        this[PENDING_UPDATE] = null;
        throw e2;
      }
      this._zr.flush();
      this[IN_MAIN_PROCESS_KEY] = false;
      this[PENDING_UPDATE] = null;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    } else if (scheduler.unfinished) {
      let remainTime = TEST_FRAME_REMAIN_TIME;
      const ecModel = this._model;
      const api2 = this._api;
      scheduler.unfinished = false;
      do {
        const startTime = +new Date();
        scheduler.performSeriesTasks(ecModel);
        scheduler.performDataProcessorTasks(ecModel);
        updateStreamModes(this, ecModel);
        scheduler.performVisualTasks(ecModel);
        renderSeries(this, this._model, api2, "remain", {});
        remainTime -= +new Date() - startTime;
      } while (remainTime > 0 && scheduler.unfinished);
      if (!scheduler.unfinished) {
        this._zr.flush();
      }
    }
  }
  getDom() {
    return this._dom;
  }
  getId() {
    return this.id;
  }
  getZr() {
    return this._zr;
  }
  isSSR() {
    return this._ssr;
  }
  setOption(option, notMerge, lazyUpdate) {
    if (this[IN_MAIN_PROCESS_KEY]) {
      if (true) {
        error("`setOption` should not be called during main process.");
      }
      return;
    }
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    let silent;
    let replaceMerge;
    let transitionOpt;
    if (isObject(notMerge)) {
      lazyUpdate = notMerge.lazyUpdate;
      silent = notMerge.silent;
      replaceMerge = notMerge.replaceMerge;
      transitionOpt = notMerge.transition;
      notMerge = notMerge.notMerge;
    }
    this[IN_MAIN_PROCESS_KEY] = true;
    if (!this._model || notMerge) {
      const optionManager = new OptionManager_default(this._api);
      const theme2 = this._theme;
      const ecModel = this._model = new Global_default();
      ecModel.scheduler = this._scheduler;
      ecModel.ssr = this._ssr;
      ecModel.init(null, null, null, theme2, this._locale, optionManager);
    }
    this._model.setOption(option, {replaceMerge}, optionPreprocessorFuncs);
    const updateParams = {
      seriesTransition: transitionOpt,
      optionChanged: true
    };
    if (lazyUpdate) {
      this[PENDING_UPDATE] = {
        silent,
        updateParams
      };
      this[IN_MAIN_PROCESS_KEY] = false;
      this.getZr().wakeUp();
    } else {
      try {
        prepare(this);
        updateMethods.update.call(this, null, updateParams);
      } catch (e2) {
        this[PENDING_UPDATE] = null;
        this[IN_MAIN_PROCESS_KEY] = false;
        throw e2;
      }
      if (!this._ssr) {
        this._zr.flush();
      }
      this[PENDING_UPDATE] = null;
      this[IN_MAIN_PROCESS_KEY] = false;
      flushPendingActions.call(this, silent);
      triggerUpdatedEvent.call(this, silent);
    }
  }
  setTheme() {
    deprecateLog("ECharts#setTheme() is DEPRECATED in ECharts 3.0");
  }
  getModel() {
    return this._model;
  }
  getOption() {
    return this._model && this._model.getOption();
  }
  getWidth() {
    return this._zr.getWidth();
  }
  getHeight() {
    return this._zr.getHeight();
  }
  getDevicePixelRatio() {
    return this._zr.painter.dpr || env_default.hasGlobalWindow && window.devicePixelRatio || 1;
  }
  getRenderedCanvas(opts) {
    if (true) {
      deprecateReplaceLog("getRenderedCanvas", "renderToCanvas");
    }
    return this.renderToCanvas(opts);
  }
  renderToCanvas(opts) {
    opts = opts || {};
    const painter = this._zr.painter;
    if (true) {
      if (painter.type !== "canvas") {
        throw new Error("renderToCanvas can only be used in the canvas renderer.");
      }
    }
    return painter.getRenderedCanvas({
      backgroundColor: opts.backgroundColor || this._model.get("backgroundColor"),
      pixelRatio: opts.pixelRatio || this.getDevicePixelRatio()
    });
  }
  renderToSVGString(opts) {
    opts = opts || {};
    const painter = this._zr.painter;
    if (true) {
      if (painter.type !== "svg") {
        throw new Error("renderToSVGString can only be used in the svg renderer.");
      }
    }
    return painter.renderToString({
      useViewBox: opts.useViewBox
    });
  }
  getSvgDataURL() {
    if (!env_default.svgSupported) {
      return;
    }
    const zr = this._zr;
    const list = zr.storage.getDisplayList();
    each(list, function(el) {
      el.stopAnimation(null, true);
    });
    return zr.painter.toDataURL();
  }
  getDataURL(opts) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    opts = opts || {};
    const excludeComponents = opts.excludeComponents;
    const ecModel = this._model;
    const excludesComponentViews = [];
    const self2 = this;
    each(excludeComponents, function(componentType) {
      ecModel.eachComponent({
        mainType: componentType
      }, function(component) {
        const view = self2._componentsMap[component.__viewId];
        if (!view.group.ignore) {
          excludesComponentViews.push(view);
          view.group.ignore = true;
        }
      });
    });
    const url = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(opts).toDataURL("image/" + (opts && opts.type || "png"));
    each(excludesComponentViews, function(view) {
      view.group.ignore = false;
    });
    return url;
  }
  getConnectedDataURL(opts) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    const isSvg = opts.type === "svg";
    const groupId = this.group;
    const mathMin12 = Math.min;
    const mathMax12 = Math.max;
    const MAX_NUMBER = Infinity;
    if (connectedGroups[groupId]) {
      let left = MAX_NUMBER;
      let top = MAX_NUMBER;
      let right = -MAX_NUMBER;
      let bottom = -MAX_NUMBER;
      const canvasList = [];
      const dpr2 = opts && opts.pixelRatio || this.getDevicePixelRatio();
      each(instances2, function(chart, id) {
        if (chart.group === groupId) {
          const canvas = isSvg ? chart.getZr().painter.getSvgDom().innerHTML : chart.renderToCanvas(clone(opts));
          const boundingRect = chart.getDom().getBoundingClientRect();
          left = mathMin12(boundingRect.left, left);
          top = mathMin12(boundingRect.top, top);
          right = mathMax12(boundingRect.right, right);
          bottom = mathMax12(boundingRect.bottom, bottom);
          canvasList.push({
            dom: canvas,
            left: boundingRect.left,
            top: boundingRect.top
          });
        }
      });
      left *= dpr2;
      top *= dpr2;
      right *= dpr2;
      bottom *= dpr2;
      const width = right - left;
      const height = bottom - top;
      const targetCanvas = platformApi.createCanvas();
      const zr = init(targetCanvas, {
        renderer: isSvg ? "svg" : "canvas"
      });
      zr.resize({
        width,
        height
      });
      if (isSvg) {
        let content = "";
        each(canvasList, function(item) {
          const x = item.left - left;
          const y = item.top - top;
          content += '<g transform="translate(' + x + "," + y + ')">' + item.dom + "</g>";
        });
        zr.painter.getSvgRoot().innerHTML = content;
        if (opts.connectedBackgroundColor) {
          zr.painter.setBackgroundColor(opts.connectedBackgroundColor);
        }
        zr.refreshImmediately();
        return zr.painter.toDataURL();
      } else {
        if (opts.connectedBackgroundColor) {
          zr.add(new Rect_default({
            shape: {
              x: 0,
              y: 0,
              width,
              height
            },
            style: {
              fill: opts.connectedBackgroundColor
            }
          }));
        }
        each(canvasList, function(item) {
          const img = new Image_default({
            style: {
              x: item.left * dpr2 - left,
              y: item.top * dpr2 - top,
              image: item.dom
            }
          });
          zr.add(img);
        });
        zr.refreshImmediately();
        return targetCanvas.toDataURL("image/" + (opts && opts.type || "png"));
      }
    } else {
      return this.getDataURL(opts);
    }
  }
  convertToPixel(finder, value) {
    return doConvertPixel(this, "convertToPixel", finder, value);
  }
  convertFromPixel(finder, value) {
    return doConvertPixel(this, "convertFromPixel", finder, value);
  }
  containPixel(finder, value) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    const ecModel = this._model;
    let result;
    const findResult = parseFinder(ecModel, finder);
    each(findResult, function(models, key) {
      key.indexOf("Models") >= 0 && each(models, function(model) {
        const coordSys = model.coordinateSystem;
        if (coordSys && coordSys.containPoint) {
          result = result || !!coordSys.containPoint(value);
        } else if (key === "seriesModels") {
          const view = this._chartsMap[model.__viewId];
          if (view && view.containPoint) {
            result = result || view.containPoint(value, model);
          } else {
            if (true) {
              warn(key + ": " + (view ? "The found component do not support containPoint." : "No view mapping to the found component."));
            }
          }
        } else {
          if (true) {
            warn(key + ": containPoint is not supported");
          }
        }
      }, this);
    }, this);
    return !!result;
  }
  getVisual(finder, visualType) {
    const ecModel = this._model;
    const parsedFinder = parseFinder(ecModel, finder, {
      defaultMainType: "series"
    });
    const seriesModel = parsedFinder.seriesModel;
    if (true) {
      if (!seriesModel) {
        warn("There is no specified series model");
      }
    }
    const data = seriesModel.getData();
    const dataIndexInside = parsedFinder.hasOwnProperty("dataIndexInside") ? parsedFinder.dataIndexInside : parsedFinder.hasOwnProperty("dataIndex") ? data.indexOfRawIndex(parsedFinder.dataIndex) : null;
    return dataIndexInside != null ? getItemVisualFromData(data, dataIndexInside, visualType) : getVisualFromData(data, visualType);
  }
  getViewOfComponentModel(componentModel) {
    return this._componentsMap[componentModel.__viewId];
  }
  getViewOfSeriesModel(seriesModel) {
    return this._chartsMap[seriesModel.__viewId];
  }
  _initEvents() {
    each(MOUSE_EVENT_NAMES, (eveName) => {
      const handler = (e2) => {
        const ecModel = this.getModel();
        const el = e2.target;
        let params;
        const isGlobalOut = eveName === "globalout";
        if (isGlobalOut) {
          params = {};
        } else {
          el && findEventDispatcher(el, (parent) => {
            const ecData = getECData(parent);
            if (ecData && ecData.dataIndex != null) {
              const dataModel = ecData.dataModel || ecModel.getSeriesByIndex(ecData.seriesIndex);
              params = dataModel && dataModel.getDataParams(ecData.dataIndex, ecData.dataType, el) || {};
              return true;
            } else if (ecData.eventData) {
              params = extend({}, ecData.eventData);
              return true;
            }
          }, true);
        }
        if (params) {
          let componentType = params.componentType;
          let componentIndex = params.componentIndex;
          if (componentType === "markLine" || componentType === "markPoint" || componentType === "markArea") {
            componentType = "series";
            componentIndex = params.seriesIndex;
          }
          const model = componentType && componentIndex != null && ecModel.getComponent(componentType, componentIndex);
          const view = model && this[model.mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId];
          if (true) {
            if (!isGlobalOut && !(model && view)) {
              warn("model or view can not be found by params");
            }
          }
          params.event = e2;
          params.type = eveName;
          this._$eventProcessor.eventInfo = {
            targetEl: el,
            packedEvent: params,
            model,
            view
          };
          this.trigger(eveName, params);
        }
      };
      handler.zrEventfulCallAtLast = true;
      this._zr.on(eveName, handler, this);
    });
    each(eventActionMap, (actionType, eventType) => {
      this._messageCenter.on(eventType, function(event) {
        this.trigger(eventType, event);
      }, this);
    });
    each(["selectchanged"], (eventType) => {
      this._messageCenter.on(eventType, function(event) {
        this.trigger(eventType, event);
      }, this);
    });
    handleLegacySelectEvents(this._messageCenter, this, this._api);
  }
  isDisposed() {
    return this._disposed;
  }
  clear() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this.setOption({series: []}, true);
  }
  dispose() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._disposed = true;
    const dom = this.getDom();
    if (dom) {
      setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, "");
    }
    const chart = this;
    const api2 = chart._api;
    const ecModel = chart._model;
    each(chart._componentsViews, function(component) {
      component.dispose(ecModel, api2);
    });
    each(chart._chartsViews, function(chart2) {
      chart2.dispose(ecModel, api2);
    });
    chart._zr.dispose();
    chart._dom = chart._model = chart._chartsMap = chart._componentsMap = chart._chartsViews = chart._componentsViews = chart._scheduler = chart._api = chart._zr = chart._throttledZrFlush = chart._theme = chart._coordSysMgr = chart._messageCenter = null;
    delete instances2[chart.id];
  }
  resize(opts) {
    if (this[IN_MAIN_PROCESS_KEY]) {
      if (true) {
        error("`resize` should not be called during main process.");
      }
      return;
    }
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._zr.resize(opts);
    const ecModel = this._model;
    this._loadingFX && this._loadingFX.resize();
    if (!ecModel) {
      return;
    }
    let needPrepare = ecModel.resetOption("media");
    let silent = opts && opts.silent;
    if (this[PENDING_UPDATE]) {
      if (silent == null) {
        silent = this[PENDING_UPDATE].silent;
      }
      needPrepare = true;
      this[PENDING_UPDATE] = null;
    }
    this[IN_MAIN_PROCESS_KEY] = true;
    try {
      needPrepare && prepare(this);
      updateMethods.update.call(this, {
        type: "resize",
        animation: extend({
          duration: 0
        }, opts && opts.animation)
      });
    } catch (e2) {
      this[IN_MAIN_PROCESS_KEY] = false;
      throw e2;
    }
    this[IN_MAIN_PROCESS_KEY] = false;
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  }
  showLoading(name, cfg) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    if (isObject(name)) {
      cfg = name;
      name = "";
    }
    name = name || "default";
    this.hideLoading();
    if (!loadingEffects[name]) {
      if (true) {
        warn("Loading effects " + name + " not exists.");
      }
      return;
    }
    const el = loadingEffects[name](this._api, cfg);
    const zr = this._zr;
    this._loadingFX = el;
    zr.add(el);
  }
  hideLoading() {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    this._loadingFX && this._zr.remove(this._loadingFX);
    this._loadingFX = null;
  }
  makeActionFromEvent(eventObj) {
    const payload = extend({}, eventObj);
    payload.type = eventActionMap[eventObj.type];
    return payload;
  }
  dispatchAction(payload, opt) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    if (!isObject(opt)) {
      opt = {silent: !!opt};
    }
    if (!actions[payload.type]) {
      return;
    }
    if (!this._model) {
      return;
    }
    if (this[IN_MAIN_PROCESS_KEY]) {
      this._pendingActions.push(payload);
      return;
    }
    const silent = opt.silent;
    doDispatchAction.call(this, payload, silent);
    const flush = opt.flush;
    if (flush) {
      this._zr.flush();
    } else if (flush !== false && env_default.browser.weChat) {
      this._throttledZrFlush();
    }
    flushPendingActions.call(this, silent);
    triggerUpdatedEvent.call(this, silent);
  }
  updateLabelLayout() {
    lifecycle_default.trigger("series:layoutlabels", this._model, this._api, {
      updatedSeries: []
    });
  }
  appendData(params) {
    if (this._disposed) {
      disposedWarning(this.id);
      return;
    }
    const seriesIndex = params.seriesIndex;
    const ecModel = this.getModel();
    const seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    if (true) {
      assert(params.data && seriesModel);
    }
    seriesModel.appendData(params);
    this._scheduler.unfinished = true;
    this.getZr().wakeUp();
  }
};
PENDING_UPDATE, IN_MAIN_PROCESS_KEY, CONNECT_STATUS_KEY, STATUS_NEEDS_UPDATE_KEY;
ECharts.internalField = function() {
  prepare = function(ecIns) {
    const scheduler = ecIns._scheduler;
    scheduler.restorePipelines(ecIns._model);
    scheduler.prepareStageTasks();
    prepareView(ecIns, true);
    prepareView(ecIns, false);
    scheduler.plan();
  };
  prepareView = function(ecIns, isComponent) {
    const ecModel = ecIns._model;
    const scheduler = ecIns._scheduler;
    const viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews;
    const viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap;
    const zr = ecIns._zr;
    const api2 = ecIns._api;
    for (let i = 0; i < viewList.length; i++) {
      viewList[i].__alive = false;
    }
    isComponent ? ecModel.eachComponent(function(componentType, model) {
      componentType !== "series" && doPrepare(model);
    }) : ecModel.eachSeries(doPrepare);
    function doPrepare(model) {
      const requireNewView = model.__requireNewView;
      model.__requireNewView = false;
      const viewId = "_ec_" + model.id + "_" + model.type;
      let view = !requireNewView && viewMap[viewId];
      if (!view) {
        const classType = parseClassType(model.type);
        const Clazz = isComponent ? Component_default2.getClass(classType.main, classType.sub) : Chart_default.getClass(classType.sub);
        if (true) {
          assert(Clazz, classType.sub + " does not exist.");
        }
        view = new Clazz();
        view.init(ecModel, api2);
        viewMap[viewId] = view;
        viewList.push(view);
        zr.add(view.group);
      }
      model.__viewId = view.__id = viewId;
      view.__alive = true;
      view.__model = model;
      view.group.__ecComponentInfo = {
        mainType: model.mainType,
        index: model.componentIndex
      };
      !isComponent && scheduler.prepareView(view, model, ecModel, api2);
    }
    for (let i = 0; i < viewList.length; ) {
      const view = viewList[i];
      if (!view.__alive) {
        !isComponent && view.renderTask.dispose();
        zr.remove(view.group);
        view.dispose(ecModel, api2);
        viewList.splice(i, 1);
        if (viewMap[view.__id] === view) {
          delete viewMap[view.__id];
        }
        view.__id = view.group.__ecComponentInfo = null;
      } else {
        i++;
      }
    }
  };
  updateDirectly = function(ecIns, method, payload, mainType, subType) {
    const ecModel = ecIns._model;
    ecModel.setUpdatePayload(payload);
    if (!mainType) {
      each([].concat(ecIns._componentsViews).concat(ecIns._chartsViews), callView);
      return;
    }
    const query = {};
    query[mainType + "Id"] = payload[mainType + "Id"];
    query[mainType + "Index"] = payload[mainType + "Index"];
    query[mainType + "Name"] = payload[mainType + "Name"];
    const condition = {mainType, query};
    subType && (condition.subType = subType);
    const excludeSeriesId = payload.excludeSeriesId;
    let excludeSeriesIdMap;
    if (excludeSeriesId != null) {
      excludeSeriesIdMap = createHashMap();
      each(normalizeToArray(excludeSeriesId), (id) => {
        const modelId = convertOptionIdName(id, null);
        if (modelId != null) {
          excludeSeriesIdMap.set(modelId, true);
        }
      });
    }
    ecModel && ecModel.eachComponent(condition, function(model) {
      const isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) != null;
      if (isExcluded) {
        return;
      }
      ;
      if (isHighDownPayload(payload)) {
        if (model instanceof Series_default) {
          if (payload.type === HIGHLIGHT_ACTION_TYPE && !payload.notBlur && !model.get(["emphasis", "disabled"])) {
            blurSeriesFromHighlightPayload(model, payload, ecIns._api);
          }
        } else {
          const {focusSelf, dispatchers} = findComponentHighDownDispatchers(model.mainType, model.componentIndex, payload.name, ecIns._api);
          if (payload.type === HIGHLIGHT_ACTION_TYPE && focusSelf && !payload.notBlur) {
            blurComponent(model.mainType, model.componentIndex, ecIns._api);
          }
          if (dispatchers) {
            each(dispatchers, (dispatcher) => {
              payload.type === HIGHLIGHT_ACTION_TYPE ? enterEmphasis(dispatcher) : leaveEmphasis(dispatcher);
            });
          }
        }
      } else if (isSelectChangePayload(payload)) {
        if (model instanceof Series_default) {
          toggleSelectionFromPayload(model, payload, ecIns._api);
          updateSeriesElementSelection(model);
          markStatusToUpdate(ecIns);
        }
      }
    }, ecIns);
    ecModel && ecModel.eachComponent(condition, function(model) {
      const isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) != null;
      if (isExcluded) {
        return;
      }
      ;
      callView(ecIns[mainType === "series" ? "_chartsMap" : "_componentsMap"][model.__viewId]);
    }, ecIns);
    function callView(view) {
      view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
    }
  };
  updateMethods = {
    prepareAndUpdate(payload) {
      prepare(this);
      updateMethods.update.call(this, payload, {
        optionChanged: payload.newOption != null
      });
    },
    update(payload, updateParams) {
      const ecModel = this._model;
      const api2 = this._api;
      const zr = this._zr;
      const coordSysMgr = this._coordSysMgr;
      const scheduler = this._scheduler;
      if (!ecModel) {
        return;
      }
      ecModel.setUpdatePayload(payload);
      scheduler.restoreData(ecModel, payload);
      scheduler.performSeriesTasks(ecModel);
      coordSysMgr.create(ecModel, api2);
      scheduler.performDataProcessorTasks(ecModel, payload);
      updateStreamModes(this, ecModel);
      coordSysMgr.update(ecModel, api2);
      clearColorPalette(ecModel);
      scheduler.performVisualTasks(ecModel, payload);
      render(this, ecModel, api2, payload, updateParams);
      const backgroundColor2 = ecModel.get("backgroundColor") || "transparent";
      const darkMode = ecModel.get("darkMode");
      zr.setBackgroundColor(backgroundColor2);
      if (darkMode != null && darkMode !== "auto") {
        zr.setDarkMode(darkMode);
      }
      lifecycle_default.trigger("afterupdate", ecModel, api2);
    },
    updateTransform(payload) {
      const ecModel = this._model;
      const api2 = this._api;
      if (!ecModel) {
        return;
      }
      ecModel.setUpdatePayload(payload);
      const componentDirtyList = [];
      ecModel.eachComponent((componentType, componentModel) => {
        if (componentType === "series") {
          return;
        }
        const componentView = this.getViewOfComponentModel(componentModel);
        if (componentView && componentView.__alive) {
          if (componentView.updateTransform) {
            const result = componentView.updateTransform(componentModel, ecModel, api2, payload);
            result && result.update && componentDirtyList.push(componentView);
          } else {
            componentDirtyList.push(componentView);
          }
        }
      });
      const seriesDirtyMap = createHashMap();
      ecModel.eachSeries((seriesModel) => {
        const chartView = this._chartsMap[seriesModel.__viewId];
        if (chartView.updateTransform) {
          const result = chartView.updateTransform(seriesModel, ecModel, api2, payload);
          result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);
        } else {
          seriesDirtyMap.set(seriesModel.uid, 1);
        }
      });
      clearColorPalette(ecModel);
      this._scheduler.performVisualTasks(ecModel, payload, {setDirty: true, dirtyMap: seriesDirtyMap});
      renderSeries(this, ecModel, api2, payload, {}, seriesDirtyMap);
      lifecycle_default.trigger("afterupdate", ecModel, api2);
    },
    updateView(payload) {
      const ecModel = this._model;
      if (!ecModel) {
        return;
      }
      ecModel.setUpdatePayload(payload);
      Chart_default.markUpdateMethod(payload, "updateView");
      clearColorPalette(ecModel);
      this._scheduler.performVisualTasks(ecModel, payload, {setDirty: true});
      render(this, ecModel, this._api, payload, {});
      lifecycle_default.trigger("afterupdate", ecModel, this._api);
    },
    updateVisual(payload) {
      const ecModel = this._model;
      if (!ecModel) {
        return;
      }
      ecModel.setUpdatePayload(payload);
      ecModel.eachSeries(function(seriesModel) {
        seriesModel.getData().clearAllVisual();
      });
      Chart_default.markUpdateMethod(payload, "updateVisual");
      clearColorPalette(ecModel);
      this._scheduler.performVisualTasks(ecModel, payload, {visualType: "visual", setDirty: true});
      ecModel.eachComponent((componentType, componentModel) => {
        if (componentType !== "series") {
          const componentView = this.getViewOfComponentModel(componentModel);
          componentView && componentView.__alive && componentView.updateVisual(componentModel, ecModel, this._api, payload);
        }
      });
      ecModel.eachSeries((seriesModel) => {
        const chartView = this._chartsMap[seriesModel.__viewId];
        chartView.updateVisual(seriesModel, ecModel, this._api, payload);
      });
      lifecycle_default.trigger("afterupdate", ecModel, this._api);
    },
    updateLayout(payload) {
      updateMethods.update.call(this, payload);
    }
  };
  doConvertPixel = function(ecIns, methodName, finder, value) {
    if (ecIns._disposed) {
      disposedWarning(ecIns.id);
      return;
    }
    const ecModel = ecIns._model;
    const coordSysList = ecIns._coordSysMgr.getCoordinateSystems();
    let result;
    const parsedFinder = parseFinder(ecModel, finder);
    for (let i = 0; i < coordSysList.length; i++) {
      const coordSys = coordSysList[i];
      if (coordSys[methodName] && (result = coordSys[methodName](ecModel, parsedFinder, value)) != null) {
        return result;
      }
    }
    if (true) {
      warn("No coordinate system that supports " + methodName + " found by the given finder.");
    }
  };
  updateStreamModes = function(ecIns, ecModel) {
    const chartsMap = ecIns._chartsMap;
    const scheduler = ecIns._scheduler;
    ecModel.eachSeries(function(seriesModel) {
      scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);
    });
  };
  doDispatchAction = function(payload, silent) {
    const ecModel = this.getModel();
    const payloadType = payload.type;
    const escapeConnect = payload.escapeConnect;
    const actionWrap = actions[payloadType];
    const actionInfo3 = actionWrap.actionInfo;
    const cptTypeTmp = (actionInfo3.update || "update").split(":");
    const updateMethod = cptTypeTmp.pop();
    const cptType = cptTypeTmp[0] != null && parseClassType(cptTypeTmp[0]);
    this[IN_MAIN_PROCESS_KEY] = true;
    let payloads = [payload];
    let batched = false;
    if (payload.batch) {
      batched = true;
      payloads = map(payload.batch, function(item) {
        item = defaults(extend({}, item), payload);
        item.batch = null;
        return item;
      });
    }
    const eventObjBatch = [];
    let eventObj;
    const isSelectChange = isSelectChangePayload(payload);
    const isHighDown = isHighDownPayload(payload);
    if (isHighDown) {
      allLeaveBlur(this._api);
    }
    each(payloads, (batchItem) => {
      eventObj = actionWrap.action(batchItem, this._model, this._api);
      eventObj = eventObj || extend({}, batchItem);
      eventObj.type = actionInfo3.event || eventObj.type;
      eventObjBatch.push(eventObj);
      if (isHighDown) {
        const {queryOptionMap, mainTypeSpecified} = preParseFinder(payload);
        const componentMainType = mainTypeSpecified ? queryOptionMap.keys()[0] : "series";
        updateDirectly(this, updateMethod, batchItem, componentMainType);
        markStatusToUpdate(this);
      } else if (isSelectChange) {
        updateDirectly(this, updateMethod, batchItem, "series");
        markStatusToUpdate(this);
      } else if (cptType) {
        updateDirectly(this, updateMethod, batchItem, cptType.main, cptType.sub);
      }
    });
    if (updateMethod !== "none" && !isHighDown && !isSelectChange && !cptType) {
      try {
        if (this[PENDING_UPDATE]) {
          prepare(this);
          updateMethods.update.call(this, payload);
          this[PENDING_UPDATE] = null;
        } else {
          updateMethods[updateMethod].call(this, payload);
        }
      } catch (e2) {
        this[IN_MAIN_PROCESS_KEY] = false;
        throw e2;
      }
    }
    if (batched) {
      eventObj = {
        type: actionInfo3.event || payloadType,
        escapeConnect,
        batch: eventObjBatch
      };
    } else {
      eventObj = eventObjBatch[0];
    }
    this[IN_MAIN_PROCESS_KEY] = false;
    if (!silent) {
      const messageCenter = this._messageCenter;
      messageCenter.trigger(eventObj.type, eventObj);
      if (isSelectChange) {
        const newObj = {
          type: "selectchanged",
          escapeConnect,
          selected: getAllSelectedIndices(ecModel),
          isFromClick: payload.isFromClick || false,
          fromAction: payload.type,
          fromActionPayload: payload
        };
        messageCenter.trigger(newObj.type, newObj);
      }
    }
  };
  flushPendingActions = function(silent) {
    const pendingActions = this._pendingActions;
    while (pendingActions.length) {
      const payload = pendingActions.shift();
      doDispatchAction.call(this, payload, silent);
    }
  };
  triggerUpdatedEvent = function(silent) {
    !silent && this.trigger("updated");
  };
  bindRenderedEvent = function(zr, ecIns) {
    zr.on("rendered", function(params) {
      ecIns.trigger("rendered", params);
      if (zr.animation.isFinished() && !ecIns[PENDING_UPDATE] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length) {
        ecIns.trigger("finished");
      }
    });
  };
  bindMouseEvent = function(zr, ecIns) {
    zr.on("mouseover", function(e2) {
      const el = e2.target;
      const dispatcher = findEventDispatcher(el, isHighDownDispatcher);
      if (dispatcher) {
        handleGlobalMouseOverForHighDown(dispatcher, e2, ecIns._api);
        markStatusToUpdate(ecIns);
      }
    }).on("mouseout", function(e2) {
      const el = e2.target;
      const dispatcher = findEventDispatcher(el, isHighDownDispatcher);
      if (dispatcher) {
        handleGlobalMouseOutForHighDown(dispatcher, e2, ecIns._api);
        markStatusToUpdate(ecIns);
      }
    }).on("click", function(e2) {
      const el = e2.target;
      const dispatcher = findEventDispatcher(el, (target) => getECData(target).dataIndex != null, true);
      if (dispatcher) {
        const actionType = dispatcher.selected ? "unselect" : "select";
        const ecData = getECData(dispatcher);
        ecIns._api.dispatchAction({
          type: actionType,
          dataType: ecData.dataType,
          dataIndexInside: ecData.dataIndex,
          seriesIndex: ecData.seriesIndex,
          isFromClick: true
        });
      }
    });
  };
  function clearColorPalette(ecModel) {
    ecModel.clearColorPalette();
    ecModel.eachSeries(function(seriesModel) {
      seriesModel.clearColorPalette();
    });
  }
  ;
  function allocateZlevels(ecModel) {
    ;
    const componentZLevels = [];
    const seriesZLevels = [];
    let hasSeparateZLevel = false;
    ecModel.eachComponent(function(componentType, componentModel) {
      const zlevel = componentModel.get("zlevel") || 0;
      const z = componentModel.get("z") || 0;
      const zlevelKey = componentModel.getZLevelKey();
      hasSeparateZLevel = hasSeparateZLevel || !!zlevelKey;
      (componentType === "series" ? seriesZLevels : componentZLevels).push({
        zlevel,
        z,
        idx: componentModel.componentIndex,
        type: componentType,
        key: zlevelKey
      });
    });
    if (hasSeparateZLevel) {
      const zLevels = componentZLevels.concat(seriesZLevels);
      let lastSeriesZLevel;
      let lastSeriesKey;
      sort(zLevels, (a, b) => {
        if (a.zlevel === b.zlevel) {
          return a.z - b.z;
        }
        return a.zlevel - b.zlevel;
      });
      each(zLevels, (item) => {
        const componentModel = ecModel.getComponent(item.type, item.idx);
        let zlevel = item.zlevel;
        const key = item.key;
        if (lastSeriesZLevel != null) {
          zlevel = Math.max(lastSeriesZLevel, zlevel);
        }
        if (key) {
          if (zlevel === lastSeriesZLevel && key !== lastSeriesKey) {
            zlevel++;
          }
          lastSeriesKey = key;
        } else if (lastSeriesKey) {
          if (zlevel === lastSeriesZLevel) {
            zlevel++;
          }
          lastSeriesKey = "";
        }
        lastSeriesZLevel = zlevel;
        componentModel.setZLevel(zlevel);
      });
    }
  }
  render = (ecIns, ecModel, api2, payload, updateParams) => {
    allocateZlevels(ecModel);
    renderComponents(ecIns, ecModel, api2, payload, updateParams);
    each(ecIns._chartsViews, function(chart) {
      chart.__alive = false;
    });
    renderSeries(ecIns, ecModel, api2, payload, updateParams);
    each(ecIns._chartsViews, function(chart) {
      if (!chart.__alive) {
        chart.remove(ecModel, api2);
      }
    });
  };
  renderComponents = (ecIns, ecModel, api2, payload, updateParams, dirtyList) => {
    each(dirtyList || ecIns._componentsViews, function(componentView) {
      const componentModel = componentView.__model;
      clearStates(componentModel, componentView);
      componentView.render(componentModel, ecModel, api2, payload);
      updateZ3(componentModel, componentView);
      updateStates(componentModel, componentView);
    });
  };
  renderSeries = (ecIns, ecModel, api2, payload, updateParams, dirtyMap) => {
    const scheduler = ecIns._scheduler;
    updateParams = extend(updateParams || {}, {
      updatedSeries: ecModel.getSeries()
    });
    lifecycle_default.trigger("series:beforeupdate", ecModel, api2, updateParams);
    let unfinished = false;
    ecModel.eachSeries(function(seriesModel) {
      const chartView = ecIns._chartsMap[seriesModel.__viewId];
      chartView.__alive = true;
      const renderTask = chartView.renderTask;
      scheduler.updatePayload(renderTask, payload);
      clearStates(seriesModel, chartView);
      if (dirtyMap && dirtyMap.get(seriesModel.uid)) {
        renderTask.dirty();
      }
      if (renderTask.perform(scheduler.getPerformArgs(renderTask))) {
        unfinished = true;
      }
      chartView.group.silent = !!seriesModel.get("silent");
      updateBlend(seriesModel, chartView);
      updateSeriesElementSelection(seriesModel);
    });
    scheduler.unfinished = unfinished || scheduler.unfinished;
    lifecycle_default.trigger("series:layoutlabels", ecModel, api2, updateParams);
    lifecycle_default.trigger("series:transition", ecModel, api2, updateParams);
    ecModel.eachSeries(function(seriesModel) {
      const chartView = ecIns._chartsMap[seriesModel.__viewId];
      updateZ3(seriesModel, chartView);
      updateStates(seriesModel, chartView);
    });
    updateHoverLayerStatus(ecIns, ecModel);
    lifecycle_default.trigger("series:afterupdate", ecModel, api2, updateParams);
  };
  markStatusToUpdate = function(ecIns) {
    ecIns[STATUS_NEEDS_UPDATE_KEY] = true;
    ecIns.getZr().wakeUp();
  };
  applyChangedStates = function(ecIns) {
    if (!ecIns[STATUS_NEEDS_UPDATE_KEY]) {
      return;
    }
    ecIns.getZr().storage.traverse(function(el) {
      if (isElementRemoved(el)) {
        return;
      }
      applyElementStates(el);
    });
    ecIns[STATUS_NEEDS_UPDATE_KEY] = false;
  };
  function applyElementStates(el) {
    const newStates = [];
    const oldStates = el.currentStates;
    for (let i = 0; i < oldStates.length; i++) {
      const stateName = oldStates[i];
      if (!(stateName === "emphasis" || stateName === "blur" || stateName === "select")) {
        newStates.push(stateName);
      }
    }
    if (el.selected && el.states.select) {
      newStates.push("select");
    }
    if (el.hoverState === HOVER_STATE_EMPHASIS && el.states.emphasis) {
      newStates.push("emphasis");
    } else if (el.hoverState === HOVER_STATE_BLUR && el.states.blur) {
      newStates.push("blur");
    }
    el.useStates(newStates);
  }
  function updateHoverLayerStatus(ecIns, ecModel) {
    const zr = ecIns._zr;
    const storage2 = zr.storage;
    let elCount = 0;
    storage2.traverse(function(el) {
      if (!el.isGroup) {
        elCount++;
      }
    });
    if (elCount > ecModel.get("hoverLayerThreshold") && !env_default.node && !env_default.worker) {
      ecModel.eachSeries(function(seriesModel) {
        if (seriesModel.preventUsingHoverLayer) {
          return;
        }
        const chartView = ecIns._chartsMap[seriesModel.__viewId];
        if (chartView.__alive) {
          chartView.eachRendered((el) => {
            if (el.states.emphasis) {
              el.states.emphasis.hoverLayer = true;
            }
          });
        }
      });
    }
  }
  ;
  function updateBlend(seriesModel, chartView) {
    const blendMode = seriesModel.get("blendMode") || null;
    chartView.eachRendered((el) => {
      if (!el.isGroup) {
        el.style.blend = blendMode;
      }
    });
  }
  ;
  function updateZ3(model, view) {
    if (model.preventAutoZ) {
      return;
    }
    const z = model.get("z") || 0;
    const zlevel = model.get("zlevel") || 0;
    view.eachRendered((el) => {
      doUpdateZ(el, z, zlevel, -Infinity);
      return true;
    });
  }
  ;
  function doUpdateZ(el, z, zlevel, maxZ2) {
    const label = el.getTextContent();
    const labelLine = el.getTextGuideLine();
    const isGroup = el.isGroup;
    if (isGroup) {
      const children = el.childrenRef();
      for (let i = 0; i < children.length; i++) {
        maxZ2 = Math.max(doUpdateZ(children[i], z, zlevel, maxZ2), maxZ2);
      }
    } else {
      el.z = z;
      el.zlevel = zlevel;
      maxZ2 = Math.max(el.z2, maxZ2);
    }
    if (label) {
      label.z = z;
      label.zlevel = zlevel;
      isFinite(maxZ2) && (label.z2 = maxZ2 + 2);
    }
    if (labelLine) {
      const textGuideLineConfig = el.textGuideLineConfig;
      labelLine.z = z;
      labelLine.zlevel = zlevel;
      isFinite(maxZ2) && (labelLine.z2 = maxZ2 + (textGuideLineConfig && textGuideLineConfig.showAbove ? 1 : -1));
    }
    return maxZ2;
  }
  function clearStates(model, view) {
    view.eachRendered(function(el) {
      if (isElementRemoved(el)) {
        return;
      }
      const textContent = el.getTextContent();
      const textGuide = el.getTextGuideLine();
      if (el.stateTransition) {
        el.stateTransition = null;
      }
      if (textContent && textContent.stateTransition) {
        textContent.stateTransition = null;
      }
      if (textGuide && textGuide.stateTransition) {
        textGuide.stateTransition = null;
      }
      if (el.hasState()) {
        el.prevStates = el.currentStates;
        el.clearStates();
      } else if (el.prevStates) {
        el.prevStates = null;
      }
    });
  }
  function updateStates(model, view) {
    const stateAnimationModel = model.getModel("stateAnimation");
    const enableAnimation = model.isAnimationEnabled();
    const duration = stateAnimationModel.get("duration");
    const stateTransition = duration > 0 ? {
      duration,
      delay: stateAnimationModel.get("delay"),
      easing: stateAnimationModel.get("easing")
    } : null;
    view.eachRendered(function(el) {
      if (el.states && el.states.emphasis) {
        if (isElementRemoved(el)) {
          return;
        }
        if (el instanceof Path_default) {
          savePathStates(el);
        }
        if (el.__dirty) {
          const prevStates = el.prevStates;
          if (prevStates) {
            el.useStates(prevStates);
          }
        }
        if (enableAnimation) {
          el.stateTransition = stateTransition;
          const textContent = el.getTextContent();
          const textGuide = el.getTextGuideLine();
          if (textContent) {
            textContent.stateTransition = stateTransition;
          }
          if (textGuide) {
            textGuide.stateTransition = stateTransition;
          }
        }
        if (el.__dirty) {
          applyElementStates(el);
        }
      }
    });
  }
  ;
  createExtensionAPI = function(ecIns) {
    return new class extends ExtensionAPI_default {
      getCoordinateSystems() {
        return ecIns._coordSysMgr.getCoordinateSystems();
      }
      getComponentByElement(el) {
        while (el) {
          const modelInfo = el.__ecComponentInfo;
          if (modelInfo != null) {
            return ecIns._model.getComponent(modelInfo.mainType, modelInfo.index);
          }
          el = el.parent;
        }
      }
      enterEmphasis(el, highlightDigit) {
        enterEmphasis(el, highlightDigit);
        markStatusToUpdate(ecIns);
      }
      leaveEmphasis(el, highlightDigit) {
        leaveEmphasis(el, highlightDigit);
        markStatusToUpdate(ecIns);
      }
      enterBlur(el) {
        enterBlur(el);
        markStatusToUpdate(ecIns);
      }
      leaveBlur(el) {
        leaveBlur(el);
        markStatusToUpdate(ecIns);
      }
      enterSelect(el) {
        enterSelect(el);
        markStatusToUpdate(ecIns);
      }
      leaveSelect(el) {
        leaveSelect(el);
        markStatusToUpdate(ecIns);
      }
      getModel() {
        return ecIns.getModel();
      }
      getViewOfComponentModel(componentModel) {
        return ecIns.getViewOfComponentModel(componentModel);
      }
      getViewOfSeriesModel(seriesModel) {
        return ecIns.getViewOfSeriesModel(seriesModel);
      }
    }(ecIns);
  };
  enableConnect = function(chart) {
    function updateConnectedChartsStatus(charts, status) {
      for (let i = 0; i < charts.length; i++) {
        const otherChart = charts[i];
        otherChart[CONNECT_STATUS_KEY] = status;
      }
    }
    each(eventActionMap, function(actionType, eventType) {
      chart._messageCenter.on(eventType, function(event) {
        if (connectedGroups[chart.group] && chart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_PENDING) {
          if (event && event.escapeConnect) {
            return;
          }
          const action = chart.makeActionFromEvent(event);
          const otherCharts = [];
          each(instances2, function(otherChart) {
            if (otherChart !== chart && otherChart.group === chart.group) {
              otherCharts.push(otherChart);
            }
          });
          updateConnectedChartsStatus(otherCharts, CONNECT_STATUS_PENDING);
          each(otherCharts, function(otherChart) {
            if (otherChart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_UPDATING) {
              otherChart.dispatchAction(action);
            }
          });
          updateConnectedChartsStatus(otherCharts, CONNECT_STATUS_UPDATED);
        }
      });
    });
  };
}();
var echartsProto = ECharts.prototype;
echartsProto.on = createRegisterEventWithLowercaseECharts("on");
echartsProto.off = createRegisterEventWithLowercaseECharts("off");
echartsProto.one = function(eventName, cb, ctx) {
  const self2 = this;
  deprecateLog("ECharts#one is deprecated.");
  function wrapped(...args2) {
    cb && cb.apply && cb.apply(this, args2);
    self2.off(eventName, wrapped);
  }
  ;
  this.on.call(this, eventName, wrapped, ctx);
};
var MOUSE_EVENT_NAMES = [
  "click",
  "dblclick",
  "mouseover",
  "mouseout",
  "mousemove",
  "mousedown",
  "mouseup",
  "globalout",
  "contextmenu"
];
function disposedWarning(id) {
  if (true) {
    warn("Instance " + id + " has been disposed");
  }
}
var actions = {};
var eventActionMap = {};
var dataProcessorFuncs = [];
var optionPreprocessorFuncs = [];
var visualFuncs = [];
var themeStorage = {};
var loadingEffects = {};
var instances2 = {};
var connectedGroups = {};
var idBase = +new Date() - 0;
var groupIdBase = +new Date() - 0;
var DOM_ATTRIBUTE_KEY = "_echarts_instance_";
function init2(dom, theme2, opts) {
  const isClient = !(opts && opts.ssr);
  if (isClient) {
    if (true) {
      if (!dom) {
        throw new Error("Initialize failed: invalid dom.");
      }
    }
    const existInstance = getInstanceByDom(dom);
    if (existInstance) {
      if (true) {
        warn("There is a chart instance already initialized on the dom.");
      }
      return existInstance;
    }
    if (true) {
      if (isDom(dom) && dom.nodeName.toUpperCase() !== "CANVAS" && (!dom.clientWidth && (!opts || opts.width == null) || !dom.clientHeight && (!opts || opts.height == null))) {
        warn("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload.");
      }
    }
  }
  const chart = new ECharts(dom, theme2, opts);
  chart.id = "ec_" + idBase++;
  instances2[chart.id] = chart;
  isClient && setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id);
  enableConnect(chart);
  lifecycle_default.trigger("afterinit", chart);
  return chart;
}
function connect(groupId) {
  if (isArray(groupId)) {
    const charts = groupId;
    groupId = null;
    each(charts, function(chart) {
      if (chart.group != null) {
        groupId = chart.group;
      }
    });
    groupId = groupId || "g_" + groupIdBase++;
    each(charts, function(chart) {
      chart.group = groupId;
    });
  }
  connectedGroups[groupId] = true;
  return groupId;
}
function disconnect(groupId) {
  connectedGroups[groupId] = false;
}
var disConnect = disconnect;
function dispose2(chart) {
  if (isString(chart)) {
    chart = instances2[chart];
  } else if (!(chart instanceof ECharts)) {
    chart = getInstanceByDom(chart);
  }
  if (chart instanceof ECharts && !chart.isDisposed()) {
    chart.dispose();
  }
}
function getInstanceByDom(dom) {
  return instances2[getAttribute(dom, DOM_ATTRIBUTE_KEY)];
}
function getInstanceById(key) {
  return instances2[key];
}
function registerTheme(name, theme2) {
  themeStorage[name] = theme2;
}
function registerPreprocessor(preprocessorFunc) {
  if (indexOf(optionPreprocessorFuncs, preprocessorFunc) < 0) {
    optionPreprocessorFuncs.push(preprocessorFunc);
  }
}
function registerProcessor(priority, processor) {
  normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_DEFAULT);
}
function registerPostInit(postInitFunc) {
  registerUpdateLifecycle("afterinit", postInitFunc);
}
function registerPostUpdate(postUpdateFunc) {
  registerUpdateLifecycle("afterupdate", postUpdateFunc);
}
function registerUpdateLifecycle(name, cb) {
  lifecycle_default.on(name, cb);
}
function registerAction(actionInfo3, eventName, action) {
  if (isFunction(eventName)) {
    action = eventName;
    eventName = "";
  }
  const actionType = isObject(actionInfo3) ? actionInfo3.type : [actionInfo3, actionInfo3 = {
    event: eventName
  }][0];
  actionInfo3.event = (actionInfo3.event || actionType).toLowerCase();
  eventName = actionInfo3.event;
  if (eventActionMap[eventName]) {
    return;
  }
  assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));
  if (!actions[actionType]) {
    actions[actionType] = {action, actionInfo: actionInfo3};
  }
  eventActionMap[eventName] = actionType;
}
function registerCoordinateSystem(type, coordSysCreator) {
  CoordinateSystem_default.register(type, coordSysCreator);
}
function getCoordinateSystemDimensions(type) {
  const coordSysCreator = CoordinateSystem_default.get(type);
  if (coordSysCreator) {
    return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();
  }
}
function registerLayout(priority, layoutTask) {
  normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, "layout");
}
function registerVisual(priority, visualTask) {
  normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, "visual");
}
var registeredTasks = [];
function normalizeRegister(targetList, priority, fn, defaultPriority, visualType) {
  if (isFunction(priority) || isObject(priority)) {
    fn = priority;
    priority = defaultPriority;
  }
  if (true) {
    if (isNaN(priority) || priority == null) {
      throw new Error("Illegal priority");
    }
    each(targetList, function(wrap) {
      assert(wrap.__raw !== fn);
    });
  }
  if (indexOf(registeredTasks, fn) >= 0) {
    return;
  }
  registeredTasks.push(fn);
  const stageHandler = Scheduler_default.wrapStageHandler(fn, visualType);
  stageHandler.__prio = priority;
  stageHandler.__raw = fn;
  targetList.push(stageHandler);
}
function registerLoading(name, loadingFx) {
  loadingEffects[name] = loadingFx;
}
function setCanvasCreator(creator) {
  if (true) {
    deprecateLog("setCanvasCreator is deprecated. Use setPlatformAPI({ createCanvas }) instead.");
  }
  setPlatformAPI({
    createCanvas: creator
  });
}
function registerMap(mapName, geoJson, specialAreas) {
  const registerMap3 = getImpl("registerMap");
  registerMap3 && registerMap3(mapName, geoJson, specialAreas);
}
function getMap(mapName) {
  const getMap2 = getImpl("getMap");
  return getMap2 && getMap2(mapName);
}
var registerTransform = registerExternalTransform;
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataStyleTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataColorPaletteTask);
registerVisual(PRIORITY_VISUAL_GLOBAL, seriesSymbolTask);
registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataSymbolTask);
registerVisual(PRIORITY_VISUAL_DECAL, decalVisual);
registerPreprocessor(globalBackwardCompat);
registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack);
registerLoading("default", defaultLoading);
registerAction({
  type: HIGHLIGHT_ACTION_TYPE,
  event: HIGHLIGHT_ACTION_TYPE,
  update: HIGHLIGHT_ACTION_TYPE
}, noop);
registerAction({
  type: DOWNPLAY_ACTION_TYPE,
  event: DOWNPLAY_ACTION_TYPE,
  update: DOWNPLAY_ACTION_TYPE
}, noop);
registerAction({
  type: SELECT_ACTION_TYPE,
  event: SELECT_ACTION_TYPE,
  update: SELECT_ACTION_TYPE
}, noop);
registerAction({
  type: UNSELECT_ACTION_TYPE,
  event: UNSELECT_ACTION_TYPE,
  update: UNSELECT_ACTION_TYPE
}, noop);
registerAction({
  type: TOGGLE_SELECT_ACTION_TYPE,
  event: TOGGLE_SELECT_ACTION_TYPE,
  update: TOGGLE_SELECT_ACTION_TYPE
}, noop);
registerTheme("light", light_default);
registerTheme("dark", dark_default);
var dataTool = {};

// src/extension.ts
var extensions = [];
var extensionRegisters = {
  registerPreprocessor,
  registerProcessor,
  registerPostInit,
  registerPostUpdate,
  registerUpdateLifecycle,
  registerAction,
  registerCoordinateSystem,
  registerLayout,
  registerVisual,
  registerTransform,
  registerLoading,
  registerMap,
  registerImpl,
  PRIORITY,
  ComponentModel: Component_default,
  ComponentView: Component_default2,
  SeriesModel: Series_default,
  ChartView: Chart_default,
  registerComponentModel(ComponentModelClass) {
    Component_default.registerClass(ComponentModelClass);
  },
  registerComponentView(ComponentViewClass) {
    Component_default2.registerClass(ComponentViewClass);
  },
  registerSeriesModel(SeriesModelClass) {
    Series_default.registerClass(SeriesModelClass);
  },
  registerChartView(ChartViewClass) {
    Chart_default.registerClass(ChartViewClass);
  },
  registerSubTypeDefaulter(componentType, defaulter) {
    Component_default.registerSubTypeDefaulter(componentType, defaulter);
  },
  registerPainter(painterType, PainterCtor) {
    registerPainter(painterType, PainterCtor);
  }
};
function use(ext) {
  if (isArray(ext)) {
    each(ext, (singleExt) => {
      use(singleExt);
    });
    return;
  }
  if (indexOf(extensions, ext) >= 0) {
    return;
  }
  extensions.push(ext);
  if (isFunction(ext)) {
    ext = {
      install: ext
    };
  }
  ext.install(extensionRegisters);
}

// src/data/DataDiffer.ts
function dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {
  return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;
}
function defaultKeyGetter(item) {
  return item;
}
var DataDiffer = class {
  constructor(oldArr, newArr, oldKeyGetter, newKeyGetter, context, diffMode) {
    this._old = oldArr;
    this._new = newArr;
    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
    this._newKeyGetter = newKeyGetter || defaultKeyGetter;
    this.context = context;
    this._diffModeMultiple = diffMode === "multiple";
  }
  add(func) {
    this._add = func;
    return this;
  }
  update(func) {
    this._update = func;
    return this;
  }
  updateManyToOne(func) {
    this._updateManyToOne = func;
    return this;
  }
  updateOneToMany(func) {
    this._updateOneToMany = func;
    return this;
  }
  updateManyToMany(func) {
    this._updateManyToMany = func;
    return this;
  }
  remove(func) {
    this._remove = func;
    return this;
  }
  execute() {
    this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
  }
  _executeOneToOne() {
    const oldArr = this._old;
    const newArr = this._new;
    const newDataIndexMap = {};
    const oldDataKeyArr = new Array(oldArr.length);
    const newDataKeyArr = new Array(newArr.length);
    this._initIndexMap(oldArr, null, oldDataKeyArr, "_oldKeyGetter");
    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
    for (let i = 0; i < oldArr.length; i++) {
      const oldKey = oldDataKeyArr[i];
      const newIdxMapVal = newDataIndexMap[oldKey];
      const newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
      if (newIdxMapValLen > 1) {
        const newIdx = newIdxMapVal.shift();
        if (newIdxMapVal.length === 1) {
          newDataIndexMap[oldKey] = newIdxMapVal[0];
        }
        this._update && this._update(newIdx, i);
      } else if (newIdxMapValLen === 1) {
        newDataIndexMap[oldKey] = null;
        this._update && this._update(newIdxMapVal, i);
      } else {
        this._remove && this._remove(i);
      }
    }
    this._performRestAdd(newDataKeyArr, newDataIndexMap);
  }
  _executeMultiple() {
    const oldArr = this._old;
    const newArr = this._new;
    const oldDataIndexMap = {};
    const newDataIndexMap = {};
    const oldDataKeyArr = [];
    const newDataKeyArr = [];
    this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, "_oldKeyGetter");
    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, "_newKeyGetter");
    for (let i = 0; i < oldDataKeyArr.length; i++) {
      const oldKey = oldDataKeyArr[i];
      const oldIdxMapVal = oldDataIndexMap[oldKey];
      const newIdxMapVal = newDataIndexMap[oldKey];
      const oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);
      const newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
      if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {
        this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {
        this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {
        this._update && this._update(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {
        this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal);
        newDataIndexMap[oldKey] = null;
      } else if (oldIdxMapValLen > 1) {
        for (let i2 = 0; i2 < oldIdxMapValLen; i2++) {
          this._remove && this._remove(oldIdxMapVal[i2]);
        }
      } else {
        this._remove && this._remove(oldIdxMapVal);
      }
    }
    this._performRestAdd(newDataKeyArr, newDataIndexMap);
  }
  _performRestAdd(newDataKeyArr, newDataIndexMap) {
    for (let i = 0; i < newDataKeyArr.length; i++) {
      const newKey = newDataKeyArr[i];
      const newIdxMapVal = newDataIndexMap[newKey];
      const idxMapValLen = dataIndexMapValueLength(newIdxMapVal);
      if (idxMapValLen > 1) {
        for (let j = 0; j < idxMapValLen; j++) {
          this._add && this._add(newIdxMapVal[j]);
        }
      } else if (idxMapValLen === 1) {
        this._add && this._add(newIdxMapVal);
      }
      newDataIndexMap[newKey] = null;
    }
  }
  _initIndexMap(arr, map3, keyArr, keyGetterName) {
    const cbModeMultiple = this._diffModeMultiple;
    for (let i = 0; i < arr.length; i++) {
      const key = "_ec_" + this[keyGetterName](arr[i], i);
      if (!cbModeMultiple) {
        keyArr[i] = key;
      }
      if (!map3) {
        continue;
      }
      const idxMapVal = map3[key];
      const idxMapValLen = dataIndexMapValueLength(idxMapVal);
      if (idxMapValLen === 0) {
        map3[key] = i;
        if (cbModeMultiple) {
          keyArr.push(key);
        }
      } else if (idxMapValLen === 1) {
        map3[key] = [idxMapVal, i];
      } else {
        idxMapVal.push(i);
      }
    }
  }
};
var DataDiffer_default = DataDiffer;

// src/data/helper/dimensionHelper.ts
var DimensionUserOuput = class {
  constructor(encode, dimRequest) {
    this._encode = encode;
    this._schema = dimRequest;
  }
  get() {
    return {
      fullDimensions: this._getFullDimensionNames(),
      encode: this._encode
    };
  }
  _getFullDimensionNames() {
    if (!this._cachedDimNames) {
      this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : [];
    }
    return this._cachedDimNames;
  }
};
function summarizeDimensions(data, schema) {
  const summary = {};
  const encode = summary.encode = {};
  const notExtraCoordDimMap = createHashMap();
  let defaultedLabel = [];
  let defaultedTooltip = [];
  const userOutputEncode = {};
  each(data.dimensions, function(dimName) {
    const dimItem = data.getDimensionInfo(dimName);
    const coordDim = dimItem.coordDim;
    if (coordDim) {
      if (true) {
        assert(VISUAL_DIMENSIONS.get(coordDim) == null);
      }
      const coordDimIndex = dimItem.coordDimIndex;
      getOrCreateEncodeArr(encode, coordDim)[coordDimIndex] = dimName;
      if (!dimItem.isExtraCoord) {
        notExtraCoordDimMap.set(coordDim, 1);
        if (mayLabelDimType(dimItem.type)) {
          defaultedLabel[0] = dimName;
        }
        getOrCreateEncodeArr(userOutputEncode, coordDim)[coordDimIndex] = data.getDimensionIndex(dimItem.name);
      }
      if (dimItem.defaultTooltip) {
        defaultedTooltip.push(dimName);
      }
    }
    VISUAL_DIMENSIONS.each(function(v, otherDim) {
      const encodeArr = getOrCreateEncodeArr(encode, otherDim);
      const dimIndex = dimItem.otherDims[otherDim];
      if (dimIndex != null && dimIndex !== false) {
        encodeArr[dimIndex] = dimItem.name;
      }
    });
  });
  let dataDimsOnCoord = [];
  const encodeFirstDimNotExtra = {};
  notExtraCoordDimMap.each(function(v, coordDim) {
    const dimArr = encode[coordDim];
    encodeFirstDimNotExtra[coordDim] = dimArr[0];
    dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);
  });
  summary.dataDimsOnCoord = dataDimsOnCoord;
  summary.dataDimIndicesOnCoord = map(dataDimsOnCoord, (dimName) => data.getDimensionInfo(dimName).storeDimIndex);
  summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;
  const encodeLabel = encode.label;
  if (encodeLabel && encodeLabel.length) {
    defaultedLabel = encodeLabel.slice();
  }
  const encodeTooltip = encode.tooltip;
  if (encodeTooltip && encodeTooltip.length) {
    defaultedTooltip = encodeTooltip.slice();
  } else if (!defaultedTooltip.length) {
    defaultedTooltip = defaultedLabel.slice();
  }
  encode.defaultedLabel = defaultedLabel;
  encode.defaultedTooltip = defaultedTooltip;
  summary.userOutput = new DimensionUserOuput(userOutputEncode, schema);
  return summary;
}
function getOrCreateEncodeArr(encode, dim) {
  if (!encode.hasOwnProperty(dim)) {
    encode[dim] = [];
  }
  return encode[dim];
}
function getDimensionTypeByAxis(axisType) {
  return axisType === "category" ? "ordinal" : axisType === "time" ? "time" : "float";
}
function mayLabelDimType(dimType) {
  return !(dimType === "ordinal" || dimType === "time");
}

// src/data/SeriesDimensionDefine.ts
var SeriesDimensionDefine = class {
  constructor(opt) {
    this.otherDims = {};
    if (opt != null) {
      extend(this, opt);
    }
  }
};
var SeriesDimensionDefine_default = SeriesDimensionDefine;

// src/data/helper/SeriesDataSchema.ts
var inner5 = makeInner();
var dimTypeShort = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
};
var SeriesDataSchema = class {
  constructor(opt) {
    this.dimensions = opt.dimensions;
    this._dimOmitted = opt.dimensionOmitted;
    this.source = opt.source;
    this._fullDimCount = opt.fullDimensionCount;
    this._updateDimOmitted(opt.dimensionOmitted);
  }
  isDimensionOmitted() {
    return this._dimOmitted;
  }
  _updateDimOmitted(dimensionOmitted) {
    this._dimOmitted = dimensionOmitted;
    if (!dimensionOmitted) {
      return;
    }
    if (!this._dimNameMap) {
      this._dimNameMap = ensureSourceDimNameMap(this.source);
    }
  }
  getSourceDimensionIndex(dimName) {
    return retrieve2(this._dimNameMap.get(dimName), -1);
  }
  getSourceDimension(dimIndex) {
    const dimensionsDefine = this.source.dimensionsDefine;
    if (dimensionsDefine) {
      return dimensionsDefine[dimIndex];
    }
  }
  makeStoreSchema() {
    const dimCount = this._fullDimCount;
    const willRetrieveDataByName = shouldRetrieveDataByName(this.source);
    const makeHashStrict = !shouldOmitUnusedDimensions(dimCount);
    let dimHash = "";
    const dims = [];
    for (let fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < dimCount; fullDimIdx++) {
      let property;
      let type;
      let ordinalMeta;
      const seriesDimDef = this.dimensions[seriesDimIdx];
      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
        property = willRetrieveDataByName ? seriesDimDef.name : null;
        type = seriesDimDef.type;
        ordinalMeta = seriesDimDef.ordinalMeta;
        seriesDimIdx++;
      } else {
        const sourceDimDef = this.getSourceDimension(fullDimIdx);
        if (sourceDimDef) {
          property = willRetrieveDataByName ? sourceDimDef.name : null;
          type = sourceDimDef.type;
        }
      }
      dims.push({property, type, ordinalMeta});
      if (willRetrieveDataByName && property != null && (!seriesDimDef || !seriesDimDef.isCalculationCoord)) {
        dimHash += makeHashStrict ? property.replace(/\`/g, "`1").replace(/\$/g, "`2") : property;
      }
      dimHash += "$";
      dimHash += dimTypeShort[type] || "f";
      if (ordinalMeta) {
        dimHash += ordinalMeta.uid;
      }
      dimHash += "$";
    }
    const source = this.source;
    const hash = [
      source.seriesLayoutBy,
      source.startIndex,
      dimHash
    ].join("$$");
    return {
      dimensions: dims,
      hash
    };
  }
  makeOutputDimensionNames() {
    const result = [];
    for (let fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < this._fullDimCount; fullDimIdx++) {
      let name;
      const seriesDimDef = this.dimensions[seriesDimIdx];
      if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
        if (!seriesDimDef.isCalculationCoord) {
          name = seriesDimDef.name;
        }
        seriesDimIdx++;
      } else {
        const sourceDimDef = this.getSourceDimension(fullDimIdx);
        if (sourceDimDef) {
          name = sourceDimDef.name;
        }
      }
      result.push(name);
    }
    return result;
  }
  appendCalculationDimension(dimDef) {
    this.dimensions.push(dimDef);
    dimDef.isCalculationCoord = true;
    this._fullDimCount++;
    this._updateDimOmitted(true);
  }
};
function isSeriesDataSchema(schema) {
  return schema instanceof SeriesDataSchema;
}
function createDimNameMap(dimsDef) {
  const dataDimNameMap = createHashMap();
  for (let i = 0; i < (dimsDef || []).length; i++) {
    const dimDefItemRaw = dimsDef[i];
    const userDimName = isObject(dimDefItemRaw) ? dimDefItemRaw.name : dimDefItemRaw;
    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {
      dataDimNameMap.set(userDimName, i);
    }
  }
  return dataDimNameMap;
}
function ensureSourceDimNameMap(source) {
  const innerSource = inner5(source);
  return innerSource.dimNameMap || (innerSource.dimNameMap = createDimNameMap(source.dimensionsDefine));
}
function shouldOmitUnusedDimensions(dimCount) {
  return dimCount > 30;
}

// src/data/SeriesData.ts
var isObject3 = isObject;
var map2 = map;
var CtorInt32Array2 = typeof Int32Array === "undefined" ? Array : Int32Array;
var ID_PREFIX = "e\0\0";
var INDEX_NOT_FOUND = -1;
var TRANSFERABLE_PROPERTIES = [
  "hasItemOption",
  "_nameList",
  "_idList",
  "_invertedIndicesMap",
  "_dimSummary",
  "userOutput",
  "_rawData",
  "_dimValueGetter",
  "_nameDimIdx",
  "_idDimIdx",
  "_nameRepeatCount"
];
var CLONE_PROPERTIES = [
  "_approximateExtent"
];
var prepareInvertedIndex;
var getId;
var getIdNameFromStore;
var normalizeDimensions;
var transferProperties;
var cloneListForMapAndSample;
var makeIdFromName;
var SeriesData2 = class {
  constructor(dimensionsInput, hostModel) {
    this.type = "list";
    this._dimOmitted = false;
    this._nameList = [];
    this._idList = [];
    this._visual = {};
    this._layout = {};
    this._itemVisuals = [];
    this._itemLayouts = [];
    this._graphicEls = [];
    this._approximateExtent = {};
    this._calculationInfo = {};
    this.hasItemOption = false;
    this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "lttbDownSample", "map"];
    this.CHANGABLE_METHODS = ["filterSelf", "selectRange"];
    this.DOWNSAMPLE_METHODS = ["downSample", "lttbDownSample"];
    let dimensions;
    let assignStoreDimIdx = false;
    if (isSeriesDataSchema(dimensionsInput)) {
      dimensions = dimensionsInput.dimensions;
      this._dimOmitted = dimensionsInput.isDimensionOmitted();
      this._schema = dimensionsInput;
    } else {
      assignStoreDimIdx = true;
      dimensions = dimensionsInput;
    }
    dimensions = dimensions || ["x", "y"];
    const dimensionInfos = {};
    const dimensionNames = [];
    const invertedIndicesMap = {};
    let needsHasOwn = false;
    const emptyObj = {};
    for (let i = 0; i < dimensions.length; i++) {
      const dimInfoInput = dimensions[i];
      const dimensionInfo = isString(dimInfoInput) ? new SeriesDimensionDefine_default({name: dimInfoInput}) : !(dimInfoInput instanceof SeriesDimensionDefine_default) ? new SeriesDimensionDefine_default(dimInfoInput) : dimInfoInput;
      const dimensionName = dimensionInfo.name;
      dimensionInfo.type = dimensionInfo.type || "float";
      if (!dimensionInfo.coordDim) {
        dimensionInfo.coordDim = dimensionName;
        dimensionInfo.coordDimIndex = 0;
      }
      const otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};
      dimensionNames.push(dimensionName);
      dimensionInfos[dimensionName] = dimensionInfo;
      if (emptyObj[dimensionName] != null) {
        needsHasOwn = true;
      }
      if (dimensionInfo.createInvertedIndices) {
        invertedIndicesMap[dimensionName] = [];
      }
      if (otherDims.itemName === 0) {
        this._nameDimIdx = i;
      }
      if (otherDims.itemId === 0) {
        this._idDimIdx = i;
      }
      if (true) {
        assert(assignStoreDimIdx || dimensionInfo.storeDimIndex >= 0);
      }
      if (assignStoreDimIdx) {
        dimensionInfo.storeDimIndex = i;
      }
    }
    this.dimensions = dimensionNames;
    this._dimInfos = dimensionInfos;
    this._initGetDimensionInfo(needsHasOwn);
    this.hostModel = hostModel;
    this._invertedIndicesMap = invertedIndicesMap;
    if (this._dimOmitted) {
      const dimIdxToName = this._dimIdxToName = createHashMap();
      each(dimensionNames, (dimName) => {
        dimIdxToName.set(dimensionInfos[dimName].storeDimIndex, dimName);
      });
    }
  }
  getDimension(dim) {
    let dimIdx = this._recognizeDimIndex(dim);
    if (dimIdx == null) {
      return dim;
    }
    dimIdx = dim;
    if (!this._dimOmitted) {
      return this.dimensions[dimIdx];
    }
    const dimName = this._dimIdxToName.get(dimIdx);
    if (dimName != null) {
      return dimName;
    }
    const sourceDimDef = this._schema.getSourceDimension(dimIdx);
    if (sourceDimDef) {
      return sourceDimDef.name;
    }
  }
  getDimensionIndex(dim) {
    const dimIdx = this._recognizeDimIndex(dim);
    if (dimIdx != null) {
      return dimIdx;
    }
    if (dim == null) {
      return -1;
    }
    const dimInfo = this._getDimInfo(dim);
    return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1;
  }
  _recognizeDimIndex(dim) {
    if (isNumber(dim) || dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {
      return +dim;
    }
  }
  _getStoreDimIndex(dim) {
    const dimIdx = this.getDimensionIndex(dim);
    if (true) {
      if (dimIdx == null) {
        throw new Error("Unknown dimension " + dim);
      }
    }
    return dimIdx;
  }
  getDimensionInfo(dim) {
    return this._getDimInfo(this.getDimension(dim));
  }
  _initGetDimensionInfo(needsHasOwn) {
    const dimensionInfos = this._dimInfos;
    this._getDimInfo = needsHasOwn ? (dimName) => dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : void 0 : (dimName) => dimensionInfos[dimName];
  }
  getDimensionsOnCoord() {
    return this._dimSummary.dataDimsOnCoord.slice();
  }
  mapDimension(coordDim, idx) {
    const dimensionsSummary = this._dimSummary;
    if (idx == null) {
      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];
    }
    const dims = dimensionsSummary.encode[coordDim];
    return dims ? dims[idx] : null;
  }
  mapDimensionsAll(coordDim) {
    const dimensionsSummary = this._dimSummary;
    const dims = dimensionsSummary.encode[coordDim];
    return (dims || []).slice();
  }
  getStore() {
    return this._store;
  }
  initData(data, nameList, dimValueGetter) {
    let store;
    if (data instanceof DataStore_default) {
      store = data;
    }
    if (!store) {
      const dimensions = this.dimensions;
      const provider = isSourceInstance(data) || isArrayLike(data) ? new DefaultDataProvider(data, dimensions.length) : data;
      store = new DataStore_default();
      const dimensionInfos = map2(dimensions, (dimName) => ({
        type: this._dimInfos[dimName].type,
        property: dimName
      }));
      store.initData(provider, dimensionInfos, dimValueGetter);
    }
    this._store = store;
    this._nameList = (nameList || []).slice();
    this._idList = [];
    this._nameRepeatCount = {};
    this._doInit(0, store.count());
    this._dimSummary = summarizeDimensions(this, this._schema);
    this.userOutput = this._dimSummary.userOutput;
  }
  appendData(data) {
    const range = this._store.appendData(data);
    this._doInit(range[0], range[1]);
  }
  appendValues(values, names) {
    const {start: start2, end: end2} = this._store.appendValues(values, names.length);
    const shouldMakeIdFromName = this._shouldMakeIdFromName();
    this._updateOrdinalMeta();
    if (names) {
      for (let idx = start2; idx < end2; idx++) {
        const sourceIdx = idx - start2;
        this._nameList[idx] = names[sourceIdx];
        if (shouldMakeIdFromName) {
          makeIdFromName(this, idx);
        }
      }
    }
  }
  _updateOrdinalMeta() {
    const store = this._store;
    const dimensions = this.dimensions;
    for (let i = 0; i < dimensions.length; i++) {
      const dimInfo = this._dimInfos[dimensions[i]];
      if (dimInfo.ordinalMeta) {
        store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta);
      }
    }
  }
  _shouldMakeIdFromName() {
    const provider = this._store.getProvider();
    return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage;
  }
  _doInit(start2, end2) {
    if (start2 >= end2) {
      return;
    }
    const store = this._store;
    const provider = store.getProvider();
    this._updateOrdinalMeta();
    const nameList = this._nameList;
    const idList = this._idList;
    const sourceFormat = provider.getSource().sourceFormat;
    const isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL;
    if (isFormatOriginal && !provider.pure) {
      const sharedDataItem = [];
      for (let idx = start2; idx < end2; idx++) {
        const dataItem = provider.getItem(idx, sharedDataItem);
        if (!this.hasItemOption && isDataItemOption(dataItem)) {
          this.hasItemOption = true;
        }
        if (dataItem) {
          const itemName = dataItem.name;
          if (nameList[idx] == null && itemName != null) {
            nameList[idx] = convertOptionIdName(itemName, null);
          }
          const itemId = dataItem.id;
          if (idList[idx] == null && itemId != null) {
            idList[idx] = convertOptionIdName(itemId, null);
          }
        }
      }
    }
    if (this._shouldMakeIdFromName()) {
      for (let idx = start2; idx < end2; idx++) {
        makeIdFromName(this, idx);
      }
    }
    prepareInvertedIndex(this);
  }
  getApproximateExtent(dim) {
    return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim));
  }
  setApproximateExtent(extent3, dim) {
    dim = this.getDimension(dim);
    this._approximateExtent[dim] = extent3.slice();
  }
  getCalculationInfo(key) {
    return this._calculationInfo[key];
  }
  setCalculationInfo(key, value) {
    isObject3(key) ? extend(this._calculationInfo, key) : this._calculationInfo[key] = value;
  }
  getName(idx) {
    const rawIndex = this.getRawIndex(idx);
    let name = this._nameList[rawIndex];
    if (name == null && this._nameDimIdx != null) {
      name = getIdNameFromStore(this, this._nameDimIdx, rawIndex);
    }
    if (name == null) {
      name = "";
    }
    return name;
  }
  _getCategory(dimIdx, idx) {
    const ordinal = this._store.get(dimIdx, idx);
    const ordinalMeta = this._store.getOrdinalMeta(dimIdx);
    if (ordinalMeta) {
      return ordinalMeta.categories[ordinal];
    }
    return ordinal;
  }
  getId(idx) {
    return getId(this, this.getRawIndex(idx));
  }
  count() {
    return this._store.count();
  }
  get(dim, idx) {
    const store = this._store;
    const dimInfo = this._dimInfos[dim];
    if (dimInfo) {
      return store.get(dimInfo.storeDimIndex, idx);
    }
  }
  getByRawIndex(dim, rawIdx) {
    const store = this._store;
    const dimInfo = this._dimInfos[dim];
    if (dimInfo) {
      return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx);
    }
  }
  getIndices() {
    return this._store.getIndices();
  }
  getDataExtent(dim) {
    return this._store.getDataExtent(this._getStoreDimIndex(dim));
  }
  getSum(dim) {
    return this._store.getSum(this._getStoreDimIndex(dim));
  }
  getMedian(dim) {
    return this._store.getMedian(this._getStoreDimIndex(dim));
  }
  getValues(dimensions, idx) {
    const store = this._store;
    return isArray(dimensions) ? store.getValues(map2(dimensions, (dim) => this._getStoreDimIndex(dim)), idx) : store.getValues(dimensions);
  }
  hasValue(idx) {
    const dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord;
    for (let i = 0, len2 = dataDimIndicesOnCoord.length; i < len2; i++) {
      if (isNaN(this._store.get(dataDimIndicesOnCoord[i], idx))) {
        return false;
      }
    }
    return true;
  }
  indexOfName(name) {
    for (let i = 0, len2 = this._store.count(); i < len2; i++) {
      if (this.getName(i) === name) {
        return i;
      }
    }
    return -1;
  }
  getRawIndex(idx) {
    return this._store.getRawIndex(idx);
  }
  indexOfRawIndex(rawIndex) {
    return this._store.indexOfRawIndex(rawIndex);
  }
  rawIndexOf(dim, value) {
    const invertedIndices = dim && this._invertedIndicesMap[dim];
    if (true) {
      if (!invertedIndices) {
        throw new Error("Do not supported yet");
      }
    }
    const rawIndex = invertedIndices[value];
    if (rawIndex == null || isNaN(rawIndex)) {
      return INDEX_NOT_FOUND;
    }
    return rawIndex;
  }
  indicesOfNearest(dim, value, maxDistance) {
    return this._store.indicesOfNearest(this._getStoreDimIndex(dim), value, maxDistance);
  }
  each(dims, cb, ctx) {
    "use strict";
    if (isFunction(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    }
    const fCtx = ctx || this;
    const dimIndices = map2(normalizeDimensions(dims), this._getStoreDimIndex, this);
    this._store.each(dimIndices, fCtx ? bind(cb, fCtx) : cb);
  }
  filterSelf(dims, cb, ctx) {
    "use strict";
    if (isFunction(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    }
    const fCtx = ctx || this;
    const dimIndices = map2(normalizeDimensions(dims), this._getStoreDimIndex, this);
    this._store = this._store.filter(dimIndices, fCtx ? bind(cb, fCtx) : cb);
    return this;
  }
  selectRange(range) {
    "use strict";
    const innerRange = {};
    const dims = keys(range);
    const dimIndices = [];
    each(dims, (dim) => {
      const dimIdx = this._getStoreDimIndex(dim);
      innerRange[dimIdx] = range[dim];
      dimIndices.push(dimIdx);
    });
    this._store = this._store.selectRange(innerRange);
    return this;
  }
  mapArray(dims, cb, ctx) {
    "use strict";
    if (isFunction(dims)) {
      ctx = cb;
      cb = dims;
      dims = [];
    }
    ctx = ctx || this;
    const result = [];
    this.each(dims, function() {
      result.push(cb && cb.apply(this, arguments));
    }, ctx);
    return result;
  }
  map(dims, cb, ctx, ctxCompat) {
    "use strict";
    const fCtx = ctx || ctxCompat || this;
    const dimIndices = map2(normalizeDimensions(dims), this._getStoreDimIndex, this);
    const list = cloneListForMapAndSample(this);
    list._store = this._store.map(dimIndices, fCtx ? bind(cb, fCtx) : cb);
    return list;
  }
  modify(dims, cb, ctx, ctxCompat) {
    const fCtx = ctx || ctxCompat || this;
    if (true) {
      each(normalizeDimensions(dims), (dim) => {
        const dimInfo = this.getDimensionInfo(dim);
        if (!dimInfo.isCalculationCoord) {
          console.error("Danger: only stack dimension can be modified");
        }
      });
    }
    const dimIndices = map2(normalizeDimensions(dims), this._getStoreDimIndex, this);
    this._store.modify(dimIndices, fCtx ? bind(cb, fCtx) : cb);
  }
  downSample(dimension, rate, sampleValue, sampleIndex) {
    const list = cloneListForMapAndSample(this);
    list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex);
    return list;
  }
  lttbDownSample(valueDimension, rate) {
    const list = cloneListForMapAndSample(this);
    list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate);
    return list;
  }
  getRawDataItem(idx) {
    return this._store.getRawDataItem(idx);
  }
  getItemModel(idx) {
    const hostModel = this.hostModel;
    const dataItem = this.getRawDataItem(idx);
    return new Model_default(dataItem, hostModel, hostModel && hostModel.ecModel);
  }
  diff(otherList) {
    const thisList = this;
    return new DataDiffer_default(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function(idx) {
      return getId(otherList, idx);
    }, function(idx) {
      return getId(thisList, idx);
    });
  }
  getVisual(key) {
    const visual = this._visual;
    return visual && visual[key];
  }
  setVisual(kvObj, val) {
    this._visual = this._visual || {};
    if (isObject3(kvObj)) {
      extend(this._visual, kvObj);
    } else {
      this._visual[kvObj] = val;
    }
  }
  getItemVisual(idx, key) {
    const itemVisual = this._itemVisuals[idx];
    const val = itemVisual && itemVisual[key];
    if (val == null) {
      return this.getVisual(key);
    }
    return val;
  }
  hasItemVisual() {
    return this._itemVisuals.length > 0;
  }
  ensureUniqueItemVisual(idx, key) {
    const itemVisuals = this._itemVisuals;
    let itemVisual = itemVisuals[idx];
    if (!itemVisual) {
      itemVisual = itemVisuals[idx] = {};
    }
    let val = itemVisual[key];
    if (val == null) {
      val = this.getVisual(key);
      if (isArray(val)) {
        val = val.slice();
      } else if (isObject3(val)) {
        val = extend({}, val);
      }
      itemVisual[key] = val;
    }
    return val;
  }
  setItemVisual(idx, key, value) {
    const itemVisual = this._itemVisuals[idx] || {};
    this._itemVisuals[idx] = itemVisual;
    if (isObject3(key)) {
      extend(itemVisual, key);
    } else {
      itemVisual[key] = value;
    }
  }
  clearAllVisual() {
    this._visual = {};
    this._itemVisuals = [];
  }
  setLayout(key, val) {
    isObject3(key) ? extend(this._layout, key) : this._layout[key] = val;
  }
  getLayout(key) {
    return this._layout[key];
  }
  getItemLayout(idx) {
    return this._itemLayouts[idx];
  }
  setItemLayout(idx, layout18, merge2) {
    this._itemLayouts[idx] = merge2 ? extend(this._itemLayouts[idx] || {}, layout18) : layout18;
  }
  clearItemLayouts() {
    this._itemLayouts.length = 0;
  }
  setItemGraphicEl(idx, el) {
    const seriesIndex = this.hostModel && this.hostModel.seriesIndex;
    setCommonECData(seriesIndex, this.dataType, idx, el);
    this._graphicEls[idx] = el;
  }
  getItemGraphicEl(idx) {
    return this._graphicEls[idx];
  }
  eachItemGraphicEl(cb, context) {
    each(this._graphicEls, function(el, idx) {
      if (el) {
        cb && cb.call(context, el, idx);
      }
    });
  }
  cloneShallow(list) {
    if (!list) {
      list = new SeriesData2(this._schema ? this._schema : map2(this.dimensions, this._getDimInfo, this), this.hostModel);
    }
    transferProperties(list, this);
    list._store = this._store;
    return list;
  }
  wrapMethod(methodName, injectFunction) {
    const originalMethod = this[methodName];
    if (!isFunction(originalMethod)) {
      return;
    }
    this.__wrappedMethods = this.__wrappedMethods || [];
    this.__wrappedMethods.push(methodName);
    this[methodName] = function() {
      const res = originalMethod.apply(this, arguments);
      return injectFunction.apply(this, [res].concat(slice(arguments)));
    };
  }
};
var SeriesData = SeriesData2;
SeriesData.internalField = function() {
  prepareInvertedIndex = function(data) {
    const invertedIndicesMap = data._invertedIndicesMap;
    each(invertedIndicesMap, function(invertedIndices, dim) {
      const dimInfo = data._dimInfos[dim];
      const ordinalMeta = dimInfo.ordinalMeta;
      const store = data._store;
      if (ordinalMeta) {
        invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array2(ordinalMeta.categories.length);
        for (let i = 0; i < invertedIndices.length; i++) {
          invertedIndices[i] = INDEX_NOT_FOUND;
        }
        for (let i = 0; i < store.count(); i++) {
          invertedIndices[store.get(dimInfo.storeDimIndex, i)] = i;
        }
      }
    });
  };
  getIdNameFromStore = function(data, dimIdx, idx) {
    return convertOptionIdName(data._getCategory(dimIdx, idx), null);
  };
  getId = function(data, rawIndex) {
    let id = data._idList[rawIndex];
    if (id == null && data._idDimIdx != null) {
      id = getIdNameFromStore(data, data._idDimIdx, rawIndex);
    }
    if (id == null) {
      id = ID_PREFIX + rawIndex;
    }
    return id;
  };
  normalizeDimensions = function(dimensions) {
    if (!isArray(dimensions)) {
      dimensions = dimensions != null ? [dimensions] : [];
    }
    return dimensions;
  };
  cloneListForMapAndSample = function(original) {
    const list = new SeriesData2(original._schema ? original._schema : map2(original.dimensions, original._getDimInfo, original), original.hostModel);
    transferProperties(list, original);
    return list;
  };
  transferProperties = function(target, source) {
    each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function(propName) {
      if (source.hasOwnProperty(propName)) {
        target[propName] = source[propName];
      }
    });
    target.__wrappedMethods = source.__wrappedMethods;
    each(CLONE_PROPERTIES, function(propName) {
      target[propName] = clone(source[propName]);
    });
    target._calculationInfo = extend({}, source._calculationInfo);
  };
  makeIdFromName = function(data, idx) {
    const nameList = data._nameList;
    const idList = data._idList;
    const nameDimIdx = data._nameDimIdx;
    const idDimIdx = data._idDimIdx;
    let name = nameList[idx];
    let id = idList[idx];
    if (name == null && nameDimIdx != null) {
      nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx);
    }
    if (id == null && idDimIdx != null) {
      idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx);
    }
    if (id == null && name != null) {
      const nameRepeatCount = data._nameRepeatCount;
      const nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;
      id = name;
      if (nmCnt > 1) {
        id += "__ec__" + nmCnt;
      }
      idList[idx] = id;
    }
  };
}();
var SeriesData_default = SeriesData;

// src/export/api/helper.ts
var helper_exports = {};
__export(helper_exports, {
  createDimensions: () => createDimensions,
  createList: () => createList,
  createScale: () => createScale,
  createSymbol: () => createSymbol,
  createTextStyle: () => createTextStyle2,
  dataStack: () => dataStack2,
  enableHoverEmphasis: () => enableHoverEmphasis,
  getECData: () => getECData,
  getLayoutRect: () => getLayoutRect,
  mixinAxisModelCommonMethods: () => mixinAxisModelCommonMethods
});

// src/data/helper/createDimensions.ts
function createDimensions(source, opt) {
  return prepareSeriesDataSchema(source, opt).dimensions;
}
function prepareSeriesDataSchema(source, opt) {
  if (!isSourceInstance(source)) {
    source = createSourceFromSeriesDataOption(source);
  }
  opt = opt || {};
  const sysDims = opt.coordDimensions || [];
  const dimsDef = opt.dimensionsDefine || source.dimensionsDefine || [];
  const coordDimNameMap = createHashMap();
  const resultList = [];
  const dimCount = getDimCount(source, sysDims, dimsDef, opt.dimensionsCount);
  const omitUnusedDimensions = opt.canOmitUnusedDimensions && shouldOmitUnusedDimensions(dimCount);
  const isUsingSourceDimensionsDef = dimsDef === source.dimensionsDefine;
  const dataDimNameMap = isUsingSourceDimensionsDef ? ensureSourceDimNameMap(source) : createDimNameMap(dimsDef);
  let encodeDef = opt.encodeDefine;
  if (!encodeDef && opt.encodeDefaulter) {
    encodeDef = opt.encodeDefaulter(source, dimCount);
  }
  const encodeDefMap = createHashMap(encodeDef);
  const indicesMap = new CtorInt32Array(dimCount);
  for (let i = 0; i < indicesMap.length; i++) {
    indicesMap[i] = -1;
  }
  function getResultItem(dimIdx) {
    const idx = indicesMap[dimIdx];
    if (idx < 0) {
      const dimDefItemRaw = dimsDef[dimIdx];
      const dimDefItem = isObject(dimDefItemRaw) ? dimDefItemRaw : {name: dimDefItemRaw};
      const resultItem = new SeriesDimensionDefine_default();
      const userDimName = dimDefItem.name;
      if (userDimName != null && dataDimNameMap.get(userDimName) != null) {
        resultItem.name = resultItem.displayName = userDimName;
      }
      dimDefItem.type != null && (resultItem.type = dimDefItem.type);
      dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);
      const newIdx = resultList.length;
      indicesMap[dimIdx] = newIdx;
      resultItem.storeDimIndex = dimIdx;
      resultList.push(resultItem);
      return resultItem;
    }
    return resultList[idx];
  }
  if (!omitUnusedDimensions) {
    for (let i = 0; i < dimCount; i++) {
      getResultItem(i);
    }
  }
  encodeDefMap.each(function(dataDimsRaw, coordDim) {
    const dataDims = normalizeToArray(dataDimsRaw).slice();
    if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {
      encodeDefMap.set(coordDim, false);
      return;
    }
    const validDataDims = encodeDefMap.set(coordDim, []);
    each(dataDims, function(resultDimIdxOrName, idx) {
      const resultDimIdx = isString(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;
      if (resultDimIdx != null && resultDimIdx < dimCount) {
        validDataDims[idx] = resultDimIdx;
        applyDim(getResultItem(resultDimIdx), coordDim, idx);
      }
    });
  });
  let availDimIdx = 0;
  each(sysDims, function(sysDimItemRaw) {
    let coordDim;
    let sysDimItemDimsDef;
    let sysDimItemOtherDims;
    let sysDimItem;
    if (isString(sysDimItemRaw)) {
      coordDim = sysDimItemRaw;
      sysDimItem = {};
    } else {
      sysDimItem = sysDimItemRaw;
      coordDim = sysDimItem.name;
      const ordinalMeta = sysDimItem.ordinalMeta;
      sysDimItem.ordinalMeta = null;
      sysDimItem = extend({}, sysDimItem);
      sysDimItem.ordinalMeta = ordinalMeta;
      sysDimItemDimsDef = sysDimItem.dimsDef;
      sysDimItemOtherDims = sysDimItem.otherDims;
      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
    }
    let dataDims = encodeDefMap.get(coordDim);
    if (dataDims === false) {
      return;
    }
    dataDims = normalizeToArray(dataDims);
    if (!dataDims.length) {
      for (let i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {
        while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) {
          availDimIdx++;
        }
        availDimIdx < dimCount && dataDims.push(availDimIdx++);
      }
    }
    each(dataDims, function(resultDimIdx, coordDimIndex) {
      const resultItem = getResultItem(resultDimIdx);
      if (isUsingSourceDimensionsDef && sysDimItem.type != null) {
        resultItem.type = sysDimItem.type;
      }
      applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex);
      if (resultItem.name == null && sysDimItemDimsDef) {
        let sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];
        !isObject(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {
          name: sysDimItemDimsDefItem
        });
        resultItem.name = resultItem.displayName = sysDimItemDimsDefItem.name;
        resultItem.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;
      }
      sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims);
    });
  });
  function applyDim(resultItem, coordDim, coordDimIndex) {
    if (VISUAL_DIMENSIONS.get(coordDim) != null) {
      resultItem.otherDims[coordDim] = coordDimIndex;
    } else {
      resultItem.coordDim = coordDim;
      resultItem.coordDimIndex = coordDimIndex;
      coordDimNameMap.set(coordDim, true);
    }
  }
  const generateCoord = opt.generateCoord;
  let generateCoordCount = opt.generateCoordCount;
  const fromZero = generateCoordCount != null;
  generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;
  const extra = generateCoord || "value";
  function ifNoNameFillWithCoordName(resultItem) {
    if (resultItem.name == null) {
      resultItem.name = resultItem.coordDim;
    }
  }
  if (!omitUnusedDimensions) {
    for (let resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {
      const resultItem = getResultItem(resultDimIdx);
      const coordDim = resultItem.coordDim;
      if (coordDim == null) {
        resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero);
        resultItem.coordDimIndex = 0;
        if (!generateCoord || generateCoordCount <= 0) {
          resultItem.isExtraCoord = true;
        }
        generateCoordCount--;
      }
      ifNoNameFillWithCoordName(resultItem);
      if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {
        resultItem.type = "ordinal";
      }
    }
  } else {
    each(resultList, (resultItem) => {
      ifNoNameFillWithCoordName(resultItem);
    });
    resultList.sort((item0, item1) => item0.storeDimIndex - item1.storeDimIndex);
  }
  removeDuplication(resultList);
  return new SeriesDataSchema({
    source,
    dimensions: resultList,
    fullDimensionCount: dimCount,
    dimensionOmitted: omitUnusedDimensions
  });
}
function removeDuplication(result) {
  const duplicationMap = createHashMap();
  for (let i = 0; i < result.length; i++) {
    const dim = result[i];
    const dimOriginalName = dim.name;
    let count2 = duplicationMap.get(dimOriginalName) || 0;
    if (count2 > 0) {
      dim.name = dimOriginalName + (count2 - 1);
    }
    count2++;
    duplicationMap.set(dimOriginalName, count2);
  }
}
function getDimCount(source, sysDims, dimsDef, optDimCount) {
  let dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);
  each(sysDims, function(sysDimItem) {
    let sysDimItemDimsDef;
    if (isObject(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {
      dimCount = Math.max(dimCount, sysDimItemDimsDef.length);
    }
  });
  return dimCount;
}
function genCoordDimName(name, map3, fromZero) {
  if (fromZero || map3.hasKey(name)) {
    let i = 0;
    while (map3.hasKey(name + i)) {
      i++;
    }
    name += i;
  }
  map3.set(name, true);
  return name;
}

// src/model/referHelper.ts
var CoordSysInfo = class {
  constructor(coordSysName) {
    this.coordSysDims = [];
    this.axisMap = createHashMap();
    this.categoryAxisMap = createHashMap();
    this.coordSysName = coordSysName;
  }
};
function getCoordSysInfoBySeries(seriesModel) {
  const coordSysName = seriesModel.get("coordinateSystem");
  const result = new CoordSysInfo(coordSysName);
  const fetch = fetchers[coordSysName];
  if (fetch) {
    fetch(seriesModel, result, result.axisMap, result.categoryAxisMap);
    return result;
  }
}
var fetchers = {
  cartesian2d: function(seriesModel, result, axisMap, categoryAxisMap) {
    const xAxisModel = seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
    const yAxisModel = seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
    if (true) {
      if (!xAxisModel) {
        throw new Error('xAxis "' + retrieve(seriesModel.get("xAxisIndex"), seriesModel.get("xAxisId"), 0) + '" not found');
      }
      if (!yAxisModel) {
        throw new Error('yAxis "' + retrieve(seriesModel.get("xAxisIndex"), seriesModel.get("yAxisId"), 0) + '" not found');
      }
    }
    result.coordSysDims = ["x", "y"];
    axisMap.set("x", xAxisModel);
    axisMap.set("y", yAxisModel);
    if (isCategory(xAxisModel)) {
      categoryAxisMap.set("x", xAxisModel);
      result.firstCategoryDimIndex = 0;
    }
    if (isCategory(yAxisModel)) {
      categoryAxisMap.set("y", yAxisModel);
      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
    }
  },
  singleAxis: function(seriesModel, result, axisMap, categoryAxisMap) {
    const singleAxisModel = seriesModel.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
    if (true) {
      if (!singleAxisModel) {
        throw new Error("singleAxis should be specified.");
      }
    }
    result.coordSysDims = ["single"];
    axisMap.set("single", singleAxisModel);
    if (isCategory(singleAxisModel)) {
      categoryAxisMap.set("single", singleAxisModel);
      result.firstCategoryDimIndex = 0;
    }
  },
  polar: function(seriesModel, result, axisMap, categoryAxisMap) {
    const polarModel = seriesModel.getReferringComponents("polar", SINGLE_REFERRING).models[0];
    const radiusAxisModel = polarModel.findAxisModel("radiusAxis");
    const angleAxisModel = polarModel.findAxisModel("angleAxis");
    if (true) {
      if (!angleAxisModel) {
        throw new Error("angleAxis option not found");
      }
      if (!radiusAxisModel) {
        throw new Error("radiusAxis option not found");
      }
    }
    result.coordSysDims = ["radius", "angle"];
    axisMap.set("radius", radiusAxisModel);
    axisMap.set("angle", angleAxisModel);
    if (isCategory(radiusAxisModel)) {
      categoryAxisMap.set("radius", radiusAxisModel);
      result.firstCategoryDimIndex = 0;
    }
    if (isCategory(angleAxisModel)) {
      categoryAxisMap.set("angle", angleAxisModel);
      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
    }
  },
  geo: function(seriesModel, result, axisMap, categoryAxisMap) {
    result.coordSysDims = ["lng", "lat"];
  },
  parallel: function(seriesModel, result, axisMap, categoryAxisMap) {
    const ecModel = seriesModel.ecModel;
    const parallelModel = ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
    const coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();
    each(parallelModel.parallelAxisIndex, function(axisIndex, index) {
      const axisModel = ecModel.getComponent("parallelAxis", axisIndex);
      const axisDim = coordSysDims[index];
      axisMap.set(axisDim, axisModel);
      if (isCategory(axisModel)) {
        categoryAxisMap.set(axisDim, axisModel);
        if (result.firstCategoryDimIndex == null) {
          result.firstCategoryDimIndex = index;
        }
      }
    });
  }
};
function isCategory(axisModel) {
  return axisModel.get("type") === "category";
}

// src/data/helper/dataStackHelper.ts
function enableDataStack(seriesModel, dimensionsInput, opt) {
  opt = opt || {};
  let byIndex = opt.byIndex;
  const stackedCoordDimension = opt.stackedCoordDimension;
  let dimensionDefineList;
  let schema;
  let store;
  if (isLegacyDimensionsInput(dimensionsInput)) {
    dimensionDefineList = dimensionsInput;
  } else {
    schema = dimensionsInput.schema;
    dimensionDefineList = schema.dimensions;
    store = dimensionsInput.store;
  }
  const mayStack = !!(seriesModel && seriesModel.get("stack"));
  let stackedByDimInfo;
  let stackedDimInfo;
  let stackResultDimension;
  let stackedOverDimension;
  each(dimensionDefineList, function(dimensionInfo, index) {
    if (isString(dimensionInfo)) {
      dimensionDefineList[index] = dimensionInfo = {
        name: dimensionInfo
      };
    }
    if (mayStack && !dimensionInfo.isExtraCoord) {
      if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {
        stackedByDimInfo = dimensionInfo;
      }
      if (!stackedDimInfo && dimensionInfo.type !== "ordinal" && dimensionInfo.type !== "time" && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {
        stackedDimInfo = dimensionInfo;
      }
    }
  });
  if (stackedDimInfo && !byIndex && !stackedByDimInfo) {
    byIndex = true;
  }
  if (stackedDimInfo) {
    stackResultDimension = "__\0ecstackresult_" + seriesModel.id;
    stackedOverDimension = "__\0ecstackedover_" + seriesModel.id;
    if (stackedByDimInfo) {
      stackedByDimInfo.createInvertedIndices = true;
    }
    const stackedDimCoordDim = stackedDimInfo.coordDim;
    const stackedDimType = stackedDimInfo.type;
    let stackedDimCoordIndex = 0;
    each(dimensionDefineList, function(dimensionInfo) {
      if (dimensionInfo.coordDim === stackedDimCoordDim) {
        stackedDimCoordIndex++;
      }
    });
    const stackedOverDimensionDefine = {
      name: stackResultDimension,
      coordDim: stackedDimCoordDim,
      coordDimIndex: stackedDimCoordIndex,
      type: stackedDimType,
      isExtraCoord: true,
      isCalculationCoord: true,
      storeDimIndex: dimensionDefineList.length
    };
    const stackResultDimensionDefine = {
      name: stackedOverDimension,
      coordDim: stackedOverDimension,
      coordDimIndex: stackedDimCoordIndex + 1,
      type: stackedDimType,
      isExtraCoord: true,
      isCalculationCoord: true,
      storeDimIndex: dimensionDefineList.length + 1
    };
    if (schema) {
      if (store) {
        stackedOverDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackedOverDimension, stackedDimType);
        stackResultDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackResultDimension, stackedDimType);
      }
      schema.appendCalculationDimension(stackedOverDimensionDefine);
      schema.appendCalculationDimension(stackResultDimensionDefine);
    } else {
      dimensionDefineList.push(stackedOverDimensionDefine);
      dimensionDefineList.push(stackResultDimensionDefine);
    }
  }
  return {
    stackedDimension: stackedDimInfo && stackedDimInfo.name,
    stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,
    isStackedByIndex: byIndex,
    stackedOverDimension,
    stackResultDimension
  };
}
function isLegacyDimensionsInput(dimensionsInput) {
  return !isSeriesDataSchema(dimensionsInput.schema);
}
function isDimensionStacked(data, stackedDim) {
  return !!stackedDim && stackedDim === data.getCalculationInfo("stackedDimension");
}
function getStackedDimension(data, targetDim) {
  return isDimensionStacked(data, targetDim) ? data.getCalculationInfo("stackResultDimension") : targetDim;
}

// src/chart/helper/createSeriesData.ts
function getCoordSysDimDefs(seriesModel, coordSysInfo) {
  const coordSysName = seriesModel.get("coordinateSystem");
  const registeredCoordSys = CoordinateSystem_default.get(coordSysName);
  let coordSysDimDefs;
  if (coordSysInfo && coordSysInfo.coordSysDims) {
    coordSysDimDefs = map(coordSysInfo.coordSysDims, function(dim) {
      const dimInfo = {
        name: dim
      };
      const axisModel = coordSysInfo.axisMap.get(dim);
      if (axisModel) {
        const axisType = axisModel.get("type");
        dimInfo.type = getDimensionTypeByAxis(axisType);
      }
      return dimInfo;
    });
  }
  if (!coordSysDimDefs) {
    coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ["x", "y"];
  }
  return coordSysDimDefs;
}
function injectOrdinalMeta(dimInfoList, createInvertedIndices, coordSysInfo) {
  let firstCategoryDimIndex;
  let hasNameEncode;
  coordSysInfo && each(dimInfoList, function(dimInfo, dimIndex) {
    const coordDim = dimInfo.coordDim;
    const categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);
    if (categoryAxisModel) {
      if (firstCategoryDimIndex == null) {
        firstCategoryDimIndex = dimIndex;
      }
      dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();
      if (createInvertedIndices) {
        dimInfo.createInvertedIndices = true;
      }
    }
    if (dimInfo.otherDims.itemName != null) {
      hasNameEncode = true;
    }
  });
  if (!hasNameEncode && firstCategoryDimIndex != null) {
    dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;
  }
  return firstCategoryDimIndex;
}
function createSeriesData(sourceRaw, seriesModel, opt) {
  opt = opt || {};
  const sourceManager = seriesModel.getSourceManager();
  let source;
  let isOriginalSource = false;
  if (sourceRaw) {
    isOriginalSource = true;
    source = createSourceFromSeriesDataOption(sourceRaw);
  } else {
    source = sourceManager.getSource();
    isOriginalSource = source.sourceFormat === SOURCE_FORMAT_ORIGINAL;
  }
  const coordSysInfo = getCoordSysInfoBySeries(seriesModel);
  const coordSysDimDefs = getCoordSysDimDefs(seriesModel, coordSysInfo);
  const useEncodeDefaulter = opt.useEncodeDefaulter;
  const encodeDefaulter = isFunction(useEncodeDefaulter) ? useEncodeDefaulter : useEncodeDefaulter ? curry(makeSeriesEncodeForAxisCoordSys, coordSysDimDefs, seriesModel) : null;
  const createDimensionOptions = {
    coordDimensions: coordSysDimDefs,
    generateCoord: opt.generateCoord,
    encodeDefine: seriesModel.getEncode(),
    encodeDefaulter,
    canOmitUnusedDimensions: !isOriginalSource
  };
  const schema = prepareSeriesDataSchema(source, createDimensionOptions);
  const firstCategoryDimIndex = injectOrdinalMeta(schema.dimensions, opt.createInvertedIndices, coordSysInfo);
  const store = !isOriginalSource ? sourceManager.getSharedDataStore(schema) : null;
  const stackCalculationInfo = enableDataStack(seriesModel, {schema, store});
  const data = new SeriesData_default(schema, seriesModel);
  data.setCalculationInfo(stackCalculationInfo);
  const dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function(itemOpt, dimName, dataIndex, dimIndex) {
    return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);
  } : null;
  data.hasItemOption = false;
  data.initData(isOriginalSource ? source : store, null, dimValueGetter);
  return data;
}
function isNeedCompleteOrdinalData(source) {
  if (source.sourceFormat === SOURCE_FORMAT_ORIGINAL) {
    const sampleItem = firstDataNotNull(source.data || []);
    return !isArray(getDataItemValue(sampleItem));
  }
}
function firstDataNotNull(arr) {
  let i = 0;
  while (i < arr.length && arr[i] == null) {
    i++;
  }
  return arr[i];
}
var createSeriesData_default = createSeriesData;

// src/scale/Scale.ts
var Scale = class {
  constructor(setting) {
    this._setting = setting || {};
    this._extent = [Infinity, -Infinity];
  }
  getSetting(name) {
    return this._setting[name];
  }
  unionExtent(other) {
    const extent3 = this._extent;
    other[0] < extent3[0] && (extent3[0] = other[0]);
    other[1] > extent3[1] && (extent3[1] = other[1]);
  }
  unionExtentFromData(data, dim) {
    this.unionExtent(data.getApproximateExtent(dim));
  }
  getExtent() {
    return this._extent.slice();
  }
  setExtent(start2, end2) {
    const thisExtent = this._extent;
    if (!isNaN(start2)) {
      thisExtent[0] = start2;
    }
    if (!isNaN(end2)) {
      thisExtent[1] = end2;
    }
  }
  isInExtentRange(value) {
    return this._extent[0] <= value && this._extent[1] >= value;
  }
  isBlank() {
    return this._isBlank;
  }
  setBlank(isBlank) {
    this._isBlank = isBlank;
  }
};
enableClassManagement(Scale);
var Scale_default = Scale;

// src/data/OrdinalMeta.ts
var uidBase = 0;
var OrdinalMeta = class {
  constructor(opt) {
    this.categories = opt.categories || [];
    this._needCollect = opt.needCollect;
    this._deduplication = opt.deduplication;
    this.uid = ++uidBase;
  }
  static createByAxisModel(axisModel) {
    const option = axisModel.option;
    const data = option.data;
    const categories = data && map(data, getName);
    return new OrdinalMeta({
      categories,
      needCollect: !categories,
      deduplication: option.dedplication !== false
    });
  }
  getOrdinal(category) {
    return this._getOrCreateMap().get(category);
  }
  parseAndCollect(category) {
    let index;
    const needCollect = this._needCollect;
    if (!isString(category) && !needCollect) {
      return category;
    }
    if (needCollect && !this._deduplication) {
      index = this.categories.length;
      this.categories[index] = category;
      return index;
    }
    const map3 = this._getOrCreateMap();
    index = map3.get(category);
    if (index == null) {
      if (needCollect) {
        index = this.categories.length;
        this.categories[index] = category;
        map3.set(category, index);
      } else {
        index = NaN;
      }
    }
    return index;
  }
  _getOrCreateMap() {
    return this._map || (this._map = createHashMap(this.categories));
  }
};
function getName(obj) {
  if (isObject(obj) && obj.value != null) {
    return obj.value;
  } else {
    return obj + "";
  }
}
var OrdinalMeta_default = OrdinalMeta;

// src/scale/helper.ts
function isValueNice(val) {
  const exp10 = Math.pow(10, quantityExponent(Math.abs(val)));
  const f = Math.abs(val / exp10);
  return f === 0 || f === 1 || f === 2 || f === 3 || f === 5;
}
function isIntervalOrLogScale(scale4) {
  return scale4.type === "interval" || scale4.type === "log";
}
function intervalScaleNiceTicks(extent3, splitNumber, minInterval, maxInterval) {
  const result = {};
  const span = extent3[1] - extent3[0];
  let interval = result.interval = nice(span / splitNumber, true);
  if (minInterval != null && interval < minInterval) {
    interval = result.interval = minInterval;
  }
  if (maxInterval != null && interval > maxInterval) {
    interval = result.interval = maxInterval;
  }
  const precision = result.intervalPrecision = getIntervalPrecision(interval);
  const niceTickExtent = result.niceTickExtent = [
    round(Math.ceil(extent3[0] / interval) * interval, precision),
    round(Math.floor(extent3[1] / interval) * interval, precision)
  ];
  fixExtent(niceTickExtent, extent3);
  return result;
}
function increaseInterval(interval) {
  const exp10 = Math.pow(10, quantityExponent(interval));
  let f = interval / exp10;
  if (!f) {
    f = 1;
  } else if (f === 2) {
    f = 3;
  } else if (f === 3) {
    f = 5;
  } else {
    f *= 2;
  }
  return round(f * exp10);
}
function getIntervalPrecision(interval) {
  return getPrecision(interval) + 2;
}
function clamp(niceTickExtent, idx, extent3) {
  niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent3[1]), extent3[0]);
}
function fixExtent(niceTickExtent, extent3) {
  !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent3[0]);
  !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent3[1]);
  clamp(niceTickExtent, 0, extent3);
  clamp(niceTickExtent, 1, extent3);
  if (niceTickExtent[0] > niceTickExtent[1]) {
    niceTickExtent[0] = niceTickExtent[1];
  }
}
function contain2(val, extent3) {
  return val >= extent3[0] && val <= extent3[1];
}
function normalize2(val, extent3) {
  if (extent3[1] === extent3[0]) {
    return 0.5;
  }
  return (val - extent3[0]) / (extent3[1] - extent3[0]);
}
function scale3(val, extent3) {
  return val * (extent3[1] - extent3[0]) + extent3[0];
}

// src/scale/Ordinal.ts
var OrdinalScale = class extends Scale_default {
  constructor(setting) {
    super(setting);
    this.type = "ordinal";
    let ordinalMeta = this.getSetting("ordinalMeta");
    if (!ordinalMeta) {
      ordinalMeta = new OrdinalMeta_default({});
    }
    if (isArray(ordinalMeta)) {
      ordinalMeta = new OrdinalMeta_default({
        categories: map(ordinalMeta, (item) => isObject(item) ? item.value : item)
      });
    }
    this._ordinalMeta = ordinalMeta;
    this._extent = this.getSetting("extent") || [0, ordinalMeta.categories.length - 1];
  }
  parse(val) {
    if (val == null) {
      return NaN;
    }
    return isString(val) ? this._ordinalMeta.getOrdinal(val) : Math.round(val);
  }
  contain(rank) {
    rank = this.parse(rank);
    return contain2(rank, this._extent) && this._ordinalMeta.categories[rank] != null;
  }
  normalize(val) {
    val = this._getTickNumber(this.parse(val));
    return normalize2(val, this._extent);
  }
  scale(val) {
    val = Math.round(scale3(val, this._extent));
    return this.getRawOrdinalNumber(val);
  }
  getTicks() {
    const ticks = [];
    const extent3 = this._extent;
    let rank = extent3[0];
    while (rank <= extent3[1]) {
      ticks.push({
        value: rank
      });
      rank++;
    }
    return ticks;
  }
  getMinorTicks(splitNumber) {
    return;
  }
  setSortInfo(info) {
    if (info == null) {
      this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
      return;
    }
    const infoOrdinalNumbers = info.ordinalNumbers;
    const ordinalsByTick = this._ordinalNumbersByTick = [];
    const ticksByOrdinal = this._ticksByOrdinalNumber = [];
    let tickNum = 0;
    const allCategoryLen = this._ordinalMeta.categories.length;
    for (const len2 = Math.min(allCategoryLen, infoOrdinalNumbers.length); tickNum < len2; ++tickNum) {
      const ordinalNumber = infoOrdinalNumbers[tickNum];
      ordinalsByTick[tickNum] = ordinalNumber;
      ticksByOrdinal[ordinalNumber] = tickNum;
    }
    let unusedOrdinal = 0;
    for (; tickNum < allCategoryLen; ++tickNum) {
      while (ticksByOrdinal[unusedOrdinal] != null) {
        unusedOrdinal++;
      }
      ;
      ordinalsByTick.push(unusedOrdinal);
      ticksByOrdinal[unusedOrdinal] = tickNum;
    }
  }
  _getTickNumber(ordinal) {
    const ticksByOrdinalNumber = this._ticksByOrdinalNumber;
    return ticksByOrdinalNumber && ordinal >= 0 && ordinal < ticksByOrdinalNumber.length ? ticksByOrdinalNumber[ordinal] : ordinal;
  }
  getRawOrdinalNumber(tickNumber) {
    const ordinalNumbersByTick = this._ordinalNumbersByTick;
    return ordinalNumbersByTick && tickNumber >= 0 && tickNumber < ordinalNumbersByTick.length ? ordinalNumbersByTick[tickNumber] : tickNumber;
  }
  getLabel(tick) {
    if (!this.isBlank()) {
      const ordinalNumber = this.getRawOrdinalNumber(tick.value);
      const cateogry = this._ordinalMeta.categories[ordinalNumber];
      return cateogry == null ? "" : cateogry + "";
    }
  }
  count() {
    return this._extent[1] - this._extent[0] + 1;
  }
  unionExtentFromData(data, dim) {
    this.unionExtent(data.getApproximateExtent(dim));
  }
  isInExtentRange(value) {
    value = this._getTickNumber(value);
    return this._extent[0] <= value && this._extent[1] >= value;
  }
  getOrdinalMeta() {
    return this._ordinalMeta;
  }
  calcNiceTicks() {
  }
  calcNiceExtent() {
  }
};
OrdinalScale.type = "ordinal";
Scale_default.registerClass(OrdinalScale);
var Ordinal_default = OrdinalScale;

// src/scale/Interval.ts
var roundNumber = round;
var IntervalScale = class extends Scale_default {
  constructor() {
    super(...arguments);
    this.type = "interval";
    this._interval = 0;
    this._intervalPrecision = 2;
  }
  parse(val) {
    return val;
  }
  contain(val) {
    return contain2(val, this._extent);
  }
  normalize(val) {
    return normalize2(val, this._extent);
  }
  scale(val) {
    return scale3(val, this._extent);
  }
  setExtent(start2, end2) {
    const thisExtent = this._extent;
    if (!isNaN(start2)) {
      thisExtent[0] = parseFloat(start2);
    }
    if (!isNaN(end2)) {
      thisExtent[1] = parseFloat(end2);
    }
  }
  unionExtent(other) {
    const extent3 = this._extent;
    other[0] < extent3[0] && (extent3[0] = other[0]);
    other[1] > extent3[1] && (extent3[1] = other[1]);
    this.setExtent(extent3[0], extent3[1]);
  }
  getInterval() {
    return this._interval;
  }
  setInterval(interval) {
    this._interval = interval;
    this._niceExtent = this._extent.slice();
    this._intervalPrecision = getIntervalPrecision(interval);
  }
  getTicks(expandToNicedExtent) {
    const interval = this._interval;
    const extent3 = this._extent;
    const niceTickExtent = this._niceExtent;
    const intervalPrecision = this._intervalPrecision;
    const ticks = [];
    if (!interval) {
      return ticks;
    }
    const safeLimit = 1e4;
    if (extent3[0] < niceTickExtent[0]) {
      if (expandToNicedExtent) {
        ticks.push({
          value: roundNumber(niceTickExtent[0] - interval, intervalPrecision)
        });
      } else {
        ticks.push({
          value: extent3[0]
        });
      }
    }
    let tick = niceTickExtent[0];
    while (tick <= niceTickExtent[1]) {
      ticks.push({
        value: tick
      });
      tick = roundNumber(tick + interval, intervalPrecision);
      if (tick === ticks[ticks.length - 1].value) {
        break;
      }
      if (ticks.length > safeLimit) {
        return [];
      }
    }
    const lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];
    if (extent3[1] > lastNiceTick) {
      if (expandToNicedExtent) {
        ticks.push({
          value: roundNumber(lastNiceTick + interval, intervalPrecision)
        });
      } else {
        ticks.push({
          value: extent3[1]
        });
      }
    }
    return ticks;
  }
  getMinorTicks(splitNumber) {
    const ticks = this.getTicks(true);
    const minorTicks = [];
    const extent3 = this.getExtent();
    for (let i = 1; i < ticks.length; i++) {
      const nextTick = ticks[i];
      const prevTick = ticks[i - 1];
      let count2 = 0;
      const minorTicksGroup = [];
      const interval = nextTick.value - prevTick.value;
      const minorInterval = interval / splitNumber;
      while (count2 < splitNumber - 1) {
        const minorTick = roundNumber(prevTick.value + (count2 + 1) * minorInterval);
        if (minorTick > extent3[0] && minorTick < extent3[1]) {
          minorTicksGroup.push(minorTick);
        }
        count2++;
      }
      minorTicks.push(minorTicksGroup);
    }
    return minorTicks;
  }
  getLabel(data, opt) {
    if (data == null) {
      return "";
    }
    let precision = opt && opt.precision;
    if (precision == null) {
      precision = getPrecision(data.value) || 0;
    } else if (precision === "auto") {
      precision = this._intervalPrecision;
    }
    const dataNum = roundNumber(data.value, precision, true);
    return addCommas(dataNum);
  }
  calcNiceTicks(splitNumber, minInterval, maxInterval) {
    splitNumber = splitNumber || 5;
    const extent3 = this._extent;
    let span = extent3[1] - extent3[0];
    if (!isFinite(span)) {
      return;
    }
    if (span < 0) {
      span = -span;
      extent3.reverse();
    }
    const result = intervalScaleNiceTicks(extent3, splitNumber, minInterval, maxInterval);
    this._intervalPrecision = result.intervalPrecision;
    this._interval = result.interval;
    this._niceExtent = result.niceTickExtent;
  }
  calcNiceExtent(opt) {
    const extent3 = this._extent;
    if (extent3[0] === extent3[1]) {
      if (extent3[0] !== 0) {
        const expandSize = Math.abs(extent3[0]);
        if (!opt.fixMax) {
          extent3[1] += expandSize / 2;
          extent3[0] -= expandSize / 2;
        } else {
          extent3[0] -= expandSize / 2;
        }
      } else {
        extent3[1] = 1;
      }
    }
    const span = extent3[1] - extent3[0];
    if (!isFinite(span)) {
      extent3[0] = 0;
      extent3[1] = 1;
    }
    this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
    const interval = this._interval;
    if (!opt.fixMin) {
      extent3[0] = roundNumber(Math.floor(extent3[0] / interval) * interval);
    }
    if (!opt.fixMax) {
      extent3[1] = roundNumber(Math.ceil(extent3[1] / interval) * interval);
    }
  }
  setNiceExtent(min3, max3) {
    this._niceExtent = [min3, max3];
  }
};
IntervalScale.type = "interval";
Scale_default.registerClass(IntervalScale);
var Interval_default = IntervalScale;

// src/util/vendor.ts
var supportFloat32Array = typeof Float32Array !== "undefined";
var Float32ArrayCtor = !supportFloat32Array ? Array : Float32Array;
function createFloat32Array(arg) {
  if (isArray(arg)) {
    return supportFloat32Array ? new Float32Array(arg) : arg;
  }
  return new Float32ArrayCtor(arg);
}

// src/layout/barGrid.ts
var STACK_PREFIX = "__ec_stack_";
function getSeriesStackId(seriesModel) {
  return seriesModel.get("stack") || STACK_PREFIX + seriesModel.seriesIndex;
}
function getAxisKey(axis) {
  return axis.dim + axis.index;
}
function getLayoutOnAxis(opt) {
  const params = [];
  const baseAxis = opt.axis;
  const axisKey = "axis0";
  if (baseAxis.type !== "category") {
    return;
  }
  const bandWidth = baseAxis.getBandWidth();
  for (let i = 0; i < opt.count || 0; i++) {
    params.push(defaults({
      bandWidth,
      axisKey,
      stackId: STACK_PREFIX + i
    }, opt));
  }
  const widthAndOffsets = doCalBarWidthAndOffset(params);
  const result = [];
  for (let i = 0; i < opt.count; i++) {
    const item = widthAndOffsets[axisKey][STACK_PREFIX + i];
    item.offsetCenter = item.offset + item.width / 2;
    result.push(item);
  }
  return result;
}
function prepareLayoutBarSeries(seriesType2, ecModel) {
  const seriesModels = [];
  ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
    if (isOnCartesian(seriesModel)) {
      seriesModels.push(seriesModel);
    }
  });
  return seriesModels;
}
function getValueAxesMinGaps(barSeries) {
  const axisValues = {};
  each(barSeries, function(seriesModel) {
    const cartesian = seriesModel.coordinateSystem;
    const baseAxis = cartesian.getBaseAxis();
    if (baseAxis.type !== "time" && baseAxis.type !== "value") {
      return;
    }
    const data = seriesModel.getData();
    const key = baseAxis.dim + "_" + baseAxis.index;
    const dimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
    const store = data.getStore();
    for (let i = 0, cnt = store.count(); i < cnt; ++i) {
      const value = store.get(dimIdx, i);
      if (!axisValues[key]) {
        axisValues[key] = [value];
      } else {
        axisValues[key].push(value);
      }
    }
  });
  const axisMinGaps = {};
  for (const key in axisValues) {
    if (axisValues.hasOwnProperty(key)) {
      const valuesInAxis = axisValues[key];
      if (valuesInAxis) {
        valuesInAxis.sort(function(a, b) {
          return a - b;
        });
        let min3 = null;
        for (let j = 1; j < valuesInAxis.length; ++j) {
          const delta = valuesInAxis[j] - valuesInAxis[j - 1];
          if (delta > 0) {
            min3 = min3 === null ? delta : Math.min(min3, delta);
          }
        }
        axisMinGaps[key] = min3;
      }
    }
  }
  return axisMinGaps;
}
function makeColumnLayout(barSeries) {
  const axisMinGaps = getValueAxesMinGaps(barSeries);
  const seriesInfoList = [];
  each(barSeries, function(seriesModel) {
    const cartesian = seriesModel.coordinateSystem;
    const baseAxis = cartesian.getBaseAxis();
    const axisExtent = baseAxis.getExtent();
    let bandWidth;
    if (baseAxis.type === "category") {
      bandWidth = baseAxis.getBandWidth();
    } else if (baseAxis.type === "value" || baseAxis.type === "time") {
      const key = baseAxis.dim + "_" + baseAxis.index;
      const minGap = axisMinGaps[key];
      const extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);
      const scale4 = baseAxis.scale.getExtent();
      const scaleSpan = Math.abs(scale4[1] - scale4[0]);
      bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan;
    } else {
      const data = seriesModel.getData();
      bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
    }
    const barWidth = parsePercent2(seriesModel.get("barWidth"), bandWidth);
    const barMaxWidth = parsePercent2(seriesModel.get("barMaxWidth"), bandWidth);
    const barMinWidth = parsePercent2(seriesModel.get("barMinWidth") || (isInLargeMode(seriesModel) ? 0.5 : 1), bandWidth);
    const barGap = seriesModel.get("barGap");
    const barCategoryGap = seriesModel.get("barCategoryGap");
    seriesInfoList.push({
      bandWidth,
      barWidth,
      barMaxWidth,
      barMinWidth,
      barGap,
      barCategoryGap,
      axisKey: getAxisKey(baseAxis),
      stackId: getSeriesStackId(seriesModel)
    });
  });
  return doCalBarWidthAndOffset(seriesInfoList);
}
function doCalBarWidthAndOffset(seriesInfoList) {
  const columnsMap = {};
  each(seriesInfoList, function(seriesInfo, idx) {
    const axisKey = seriesInfo.axisKey;
    const bandWidth = seriesInfo.bandWidth;
    const columnsOnAxis = columnsMap[axisKey] || {
      bandWidth,
      remainedWidth: bandWidth,
      autoWidthCount: 0,
      categoryGap: null,
      gap: "20%",
      stacks: {}
    };
    const stacks = columnsOnAxis.stacks;
    columnsMap[axisKey] = columnsOnAxis;
    const stackId = seriesInfo.stackId;
    if (!stacks[stackId]) {
      columnsOnAxis.autoWidthCount++;
    }
    stacks[stackId] = stacks[stackId] || {
      width: 0,
      maxWidth: 0
    };
    let barWidth = seriesInfo.barWidth;
    if (barWidth && !stacks[stackId].width) {
      stacks[stackId].width = barWidth;
      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
      columnsOnAxis.remainedWidth -= barWidth;
    }
    const barMaxWidth = seriesInfo.barMaxWidth;
    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
    const barMinWidth = seriesInfo.barMinWidth;
    barMinWidth && (stacks[stackId].minWidth = barMinWidth);
    const barGap = seriesInfo.barGap;
    barGap != null && (columnsOnAxis.gap = barGap);
    const barCategoryGap = seriesInfo.barCategoryGap;
    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
  });
  const result = {};
  each(columnsMap, function(columnsOnAxis, coordSysName) {
    result[coordSysName] = {};
    const stacks = columnsOnAxis.stacks;
    const bandWidth = columnsOnAxis.bandWidth;
    let categoryGapPercent = columnsOnAxis.categoryGap;
    if (categoryGapPercent == null) {
      const columnCount = keys(stacks).length;
      categoryGapPercent = Math.max(35 - columnCount * 4, 15) + "%";
    }
    const categoryGap = parsePercent2(categoryGapPercent, bandWidth);
    const barGapPercent = parsePercent2(columnsOnAxis.gap, 1);
    let remainedWidth = columnsOnAxis.remainedWidth;
    let autoWidthCount = columnsOnAxis.autoWidthCount;
    let autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    each(stacks, function(column) {
      const maxWidth = column.maxWidth;
      const minWidth = column.minWidth;
      if (!column.width) {
        let finalWidth = autoWidth;
        if (maxWidth && maxWidth < finalWidth) {
          finalWidth = Math.min(maxWidth, remainedWidth);
        }
        if (minWidth && minWidth > finalWidth) {
          finalWidth = minWidth;
        }
        if (finalWidth !== autoWidth) {
          column.width = finalWidth;
          remainedWidth -= finalWidth + barGapPercent * finalWidth;
          autoWidthCount--;
        }
      } else {
        let finalWidth = column.width;
        if (maxWidth) {
          finalWidth = Math.min(finalWidth, maxWidth);
        }
        if (minWidth) {
          finalWidth = Math.max(finalWidth, minWidth);
        }
        column.width = finalWidth;
        remainedWidth -= finalWidth + barGapPercent * finalWidth;
        autoWidthCount--;
      }
    });
    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    let widthSum = 0;
    let lastColumn;
    each(stacks, function(column, idx) {
      if (!column.width) {
        column.width = autoWidth;
      }
      lastColumn = column;
      widthSum += column.width * (1 + barGapPercent);
    });
    if (lastColumn) {
      widthSum -= lastColumn.width * barGapPercent;
    }
    let offset = -widthSum / 2;
    each(stacks, function(column, stackId) {
      result[coordSysName][stackId] = result[coordSysName][stackId] || {
        bandWidth,
        offset,
        width: column.width
      };
      offset += column.width * (1 + barGapPercent);
    });
  });
  return result;
}
function retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {
  if (barWidthAndOffset && axis) {
    const result = barWidthAndOffset[getAxisKey(axis)];
    if (result != null && seriesModel != null) {
      return result[getSeriesStackId(seriesModel)];
    }
    return result;
  }
}
function layout2(seriesType2, ecModel) {
  const seriesModels = prepareLayoutBarSeries(seriesType2, ecModel);
  const barWidthAndOffset = makeColumnLayout(seriesModels);
  each(seriesModels, function(seriesModel) {
    const data = seriesModel.getData();
    const cartesian = seriesModel.coordinateSystem;
    const baseAxis = cartesian.getBaseAxis();
    const stackId = getSeriesStackId(seriesModel);
    const columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];
    const columnOffset = columnLayoutInfo.offset;
    const columnWidth = columnLayoutInfo.width;
    data.setLayout({
      bandWidth: columnLayoutInfo.bandWidth,
      offset: columnOffset,
      size: columnWidth
    });
  });
}
function createProgressiveLayout(seriesType2) {
  return {
    seriesType: seriesType2,
    plan: createRenderPlanner(),
    reset: function(seriesModel) {
      if (!isOnCartesian(seriesModel)) {
        return;
      }
      const data = seriesModel.getData();
      const cartesian = seriesModel.coordinateSystem;
      const baseAxis = cartesian.getBaseAxis();
      const valueAxis2 = cartesian.getOtherAxis(baseAxis);
      const valueDimIdx = data.getDimensionIndex(data.mapDimension(valueAxis2.dim));
      const baseDimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim));
      const drawBackground = seriesModel.get("showBackground", true);
      const valueDim = data.mapDimension(valueAxis2.dim);
      const stackResultDim = data.getCalculationInfo("stackResultDimension");
      const stacked = isDimensionStacked(data, valueDim) && !!data.getCalculationInfo("stackedOnSeries");
      const isValueAxisH = valueAxis2.isHorizontal();
      const valueAxisStart = getValueAxisStart(baseAxis, valueAxis2);
      const isLarge = isInLargeMode(seriesModel);
      const barMinHeight = seriesModel.get("barMinHeight") || 0;
      const stackedDimIdx = stackResultDim && data.getDimensionIndex(stackResultDim);
      const columnWidth = data.getLayout("size");
      const columnOffset = data.getLayout("offset");
      return {
        progress: function(params, data2) {
          const count2 = params.count;
          const largePoints = isLarge && createFloat32Array(count2 * 3);
          const largeBackgroundPoints = isLarge && drawBackground && createFloat32Array(count2 * 3);
          const largeDataIndices = isLarge && createFloat32Array(count2);
          const coordLayout = cartesian.master.getRect();
          const bgSize = isValueAxisH ? coordLayout.width : coordLayout.height;
          let dataIndex;
          const store = data2.getStore();
          let idxOffset = 0;
          while ((dataIndex = params.next()) != null) {
            const value = store.get(stacked ? stackedDimIdx : valueDimIdx, dataIndex);
            const baseValue = store.get(baseDimIdx, dataIndex);
            let baseCoord = valueAxisStart;
            let startValue;
            if (stacked) {
              startValue = +value - store.get(valueDimIdx, dataIndex);
            }
            let x;
            let y;
            let width;
            let height;
            if (isValueAxisH) {
              const coord = cartesian.dataToPoint([value, baseValue]);
              if (stacked) {
                const startCoord = cartesian.dataToPoint([startValue, baseValue]);
                baseCoord = startCoord[0];
              }
              x = baseCoord;
              y = coord[1] + columnOffset;
              width = coord[0] - baseCoord;
              height = columnWidth;
              if (Math.abs(width) < barMinHeight) {
                width = (width < 0 ? -1 : 1) * barMinHeight;
              }
            } else {
              const coord = cartesian.dataToPoint([baseValue, value]);
              if (stacked) {
                const startCoord = cartesian.dataToPoint([baseValue, startValue]);
                baseCoord = startCoord[1];
              }
              x = coord[0] + columnOffset;
              y = baseCoord;
              width = columnWidth;
              height = coord[1] - baseCoord;
              if (Math.abs(height) < barMinHeight) {
                height = (height <= 0 ? -1 : 1) * barMinHeight;
              }
            }
            if (!isLarge) {
              data2.setItemLayout(dataIndex, {x, y, width, height});
            } else {
              largePoints[idxOffset] = x;
              largePoints[idxOffset + 1] = y;
              largePoints[idxOffset + 2] = isValueAxisH ? width : height;
              if (largeBackgroundPoints) {
                largeBackgroundPoints[idxOffset] = isValueAxisH ? coordLayout.x : x;
                largeBackgroundPoints[idxOffset + 1] = isValueAxisH ? y : coordLayout.y;
                largeBackgroundPoints[idxOffset + 2] = bgSize;
              }
              largeDataIndices[dataIndex] = dataIndex;
            }
            idxOffset += 3;
          }
          if (isLarge) {
            data2.setLayout({
              largePoints,
              largeDataIndices,
              largeBackgroundPoints,
              valueAxisHorizontal: isValueAxisH
            });
          }
        }
      };
    }
  };
}
function isOnCartesian(seriesModel) {
  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "cartesian2d";
}
function isInLargeMode(seriesModel) {
  return seriesModel.pipelineContext && seriesModel.pipelineContext.large;
}
function getValueAxisStart(baseAxis, valueAxis2) {
  return valueAxis2.toGlobalCoord(valueAxis2.dataToCoord(valueAxis2.type === "log" ? 1 : 0));
}

// src/scale/Time.ts
var bisect = function(a, x, lo, hi) {
  while (lo < hi) {
    const mid = lo + hi >>> 1;
    if (a[mid][1] < x) {
      lo = mid + 1;
    } else {
      hi = mid;
    }
  }
  return lo;
};
var TimeScale = class extends Interval_default {
  constructor(settings) {
    super(settings);
    this.type = "time";
  }
  getLabel(tick) {
    const useUTC = this.getSetting("useUTC");
    return format(tick.value, fullLeveledFormatter[getDefaultFormatPrecisionOfInterval(getPrimaryTimeUnit(this._minLevelUnit))] || fullLeveledFormatter.second, useUTC, this.getSetting("locale"));
  }
  getFormattedLabel(tick, idx, labelFormatter) {
    const isUTC = this.getSetting("useUTC");
    const lang = this.getSetting("locale");
    return leveledFormat(tick, idx, labelFormatter, lang, isUTC);
  }
  getTicks() {
    const interval = this._interval;
    const extent3 = this._extent;
    let ticks = [];
    if (!interval) {
      return ticks;
    }
    ticks.push({
      value: extent3[0],
      level: 0
    });
    const useUTC = this.getSetting("useUTC");
    const innerTicks = getIntervalTicks(this._minLevelUnit, this._approxInterval, useUTC, extent3);
    ticks = ticks.concat(innerTicks);
    ticks.push({
      value: extent3[1],
      level: 0
    });
    return ticks;
  }
  calcNiceExtent(opt) {
    const extent3 = this._extent;
    if (extent3[0] === extent3[1]) {
      extent3[0] -= ONE_DAY;
      extent3[1] += ONE_DAY;
    }
    if (extent3[1] === -Infinity && extent3[0] === Infinity) {
      const d = new Date();
      extent3[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());
      extent3[0] = extent3[1] - ONE_DAY;
    }
    this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
  }
  calcNiceTicks(approxTickNum, minInterval, maxInterval) {
    approxTickNum = approxTickNum || 10;
    const extent3 = this._extent;
    const span = extent3[1] - extent3[0];
    this._approxInterval = span / approxTickNum;
    if (minInterval != null && this._approxInterval < minInterval) {
      this._approxInterval = minInterval;
    }
    if (maxInterval != null && this._approxInterval > maxInterval) {
      this._approxInterval = maxInterval;
    }
    const scaleIntervalsLen = scaleIntervals.length;
    const idx = Math.min(bisect(scaleIntervals, this._approxInterval, 0, scaleIntervalsLen), scaleIntervalsLen - 1);
    this._interval = scaleIntervals[idx][1];
    this._minLevelUnit = scaleIntervals[Math.max(idx - 1, 0)][0];
  }
  parse(val) {
    return isNumber(val) ? val : +parseDate(val);
  }
  contain(val) {
    return contain2(this.parse(val), this._extent);
  }
  normalize(val) {
    return normalize2(this.parse(val), this._extent);
  }
  scale(val) {
    return scale3(val, this._extent);
  }
};
TimeScale.type = "time";
var scaleIntervals = [
  ["second", ONE_SECOND],
  ["minute", ONE_MINUTE],
  ["hour", ONE_HOUR],
  ["quarter-day", ONE_HOUR * 6],
  ["half-day", ONE_HOUR * 12],
  ["day", ONE_DAY * 1.2],
  ["half-week", ONE_DAY * 3.5],
  ["week", ONE_DAY * 7],
  ["month", ONE_DAY * 31],
  ["quarter", ONE_DAY * 95],
  ["half-year", ONE_YEAR / 2],
  ["year", ONE_YEAR]
];
function isUnitValueSame(unit, valueA, valueB, isUTC) {
  const dateA = parseDate(valueA);
  const dateB = parseDate(valueB);
  const isSame = (unit2) => {
    return getUnitValue(dateA, unit2, isUTC) === getUnitValue(dateB, unit2, isUTC);
  };
  const isSameYear = () => isSame("year");
  const isSameMonth = () => isSameYear() && isSame("month");
  const isSameDay = () => isSameMonth() && isSame("day");
  const isSameHour = () => isSameDay() && isSame("hour");
  const isSameMinute = () => isSameHour() && isSame("minute");
  const isSameSecond = () => isSameMinute() && isSame("second");
  const isSameMilliSecond = () => isSameSecond() && isSame("millisecond");
  switch (unit) {
    case "year":
      return isSameYear();
    case "month":
      return isSameMonth();
    case "day":
      return isSameDay();
    case "hour":
      return isSameHour();
    case "minute":
      return isSameMinute();
    case "second":
      return isSameSecond();
    case "millisecond":
      return isSameMilliSecond();
  }
}
function getDateInterval(approxInterval, daysInMonth) {
  approxInterval /= ONE_DAY;
  return approxInterval > 16 ? 16 : approxInterval > 7.5 ? 7 : approxInterval > 3.5 ? 4 : approxInterval > 1.5 ? 2 : 1;
}
function getMonthInterval(approxInterval) {
  const APPROX_ONE_MONTH = 30 * ONE_DAY;
  approxInterval /= APPROX_ONE_MONTH;
  return approxInterval > 6 ? 6 : approxInterval > 3 ? 3 : approxInterval > 2 ? 2 : 1;
}
function getHourInterval(approxInterval) {
  approxInterval /= ONE_HOUR;
  return approxInterval > 12 ? 12 : approxInterval > 6 ? 6 : approxInterval > 3.5 ? 4 : approxInterval > 2 ? 2 : 1;
}
function getMinutesAndSecondsInterval(approxInterval, isMinutes) {
  approxInterval /= isMinutes ? ONE_MINUTE : ONE_SECOND;
  return approxInterval > 30 ? 30 : approxInterval > 20 ? 20 : approxInterval > 15 ? 15 : approxInterval > 10 ? 10 : approxInterval > 5 ? 5 : approxInterval > 2 ? 2 : 1;
}
function getMillisecondsInterval(approxInterval) {
  return nice(approxInterval, true);
}
function getFirstTimestampOfUnit(date, unitName, isUTC) {
  const outDate = new Date(date);
  switch (getPrimaryTimeUnit(unitName)) {
    case "year":
    case "month":
      outDate[monthSetterName(isUTC)](0);
    case "day":
      outDate[dateSetterName(isUTC)](1);
    case "hour":
      outDate[hoursSetterName(isUTC)](0);
    case "minute":
      outDate[minutesSetterName(isUTC)](0);
    case "second":
      outDate[secondsSetterName(isUTC)](0);
      outDate[millisecondsSetterName(isUTC)](0);
  }
  return outDate.getTime();
}
function getIntervalTicks(bottomUnitName, approxInterval, isUTC, extent3) {
  const safeLimit = 1e4;
  const unitNames = timeUnits;
  let iter = 0;
  function addTicksInSpan(interval, minTimestamp, maxTimestamp, getMethodName, setMethodName, isDate, out2) {
    const date = new Date(minTimestamp);
    let dateTime = minTimestamp;
    let d = date[getMethodName]();
    while (dateTime < maxTimestamp && dateTime <= extent3[1]) {
      out2.push({
        value: dateTime
      });
      d += interval;
      date[setMethodName](d);
      dateTime = date.getTime();
    }
    out2.push({
      value: dateTime,
      notAdd: true
    });
  }
  function addLevelTicks(unitName, lastLevelTicks, levelTicks) {
    const newAddedTicks = [];
    const isFirstLevel = !lastLevelTicks.length;
    if (isUnitValueSame(getPrimaryTimeUnit(unitName), extent3[0], extent3[1], isUTC)) {
      return;
    }
    if (isFirstLevel) {
      lastLevelTicks = [{
        value: getFirstTimestampOfUnit(new Date(extent3[0]), unitName, isUTC)
      }, {
        value: extent3[1]
      }];
    }
    for (let i = 0; i < lastLevelTicks.length - 1; i++) {
      const startTick = lastLevelTicks[i].value;
      const endTick = lastLevelTicks[i + 1].value;
      if (startTick === endTick) {
        continue;
      }
      let interval;
      let getterName;
      let setterName;
      let isDate = false;
      switch (unitName) {
        case "year":
          interval = Math.max(1, Math.round(approxInterval / ONE_DAY / 365));
          getterName = fullYearGetterName(isUTC);
          setterName = fullYearSetterName(isUTC);
          break;
        case "half-year":
        case "quarter":
        case "month":
          interval = getMonthInterval(approxInterval);
          getterName = monthGetterName(isUTC);
          setterName = monthSetterName(isUTC);
          break;
        case "week":
        case "half-week":
        case "day":
          interval = getDateInterval(approxInterval, 31);
          getterName = dateGetterName(isUTC);
          setterName = dateSetterName(isUTC);
          isDate = true;
          break;
        case "half-day":
        case "quarter-day":
        case "hour":
          interval = getHourInterval(approxInterval);
          getterName = hoursGetterName(isUTC);
          setterName = hoursSetterName(isUTC);
          break;
        case "minute":
          interval = getMinutesAndSecondsInterval(approxInterval, true);
          getterName = minutesGetterName(isUTC);
          setterName = minutesSetterName(isUTC);
          break;
        case "second":
          interval = getMinutesAndSecondsInterval(approxInterval, false);
          getterName = secondsGetterName(isUTC);
          setterName = secondsSetterName(isUTC);
          break;
        case "millisecond":
          interval = getMillisecondsInterval(approxInterval);
          getterName = millisecondsGetterName(isUTC);
          setterName = millisecondsSetterName(isUTC);
          break;
      }
      addTicksInSpan(interval, startTick, endTick, getterName, setterName, isDate, newAddedTicks);
      if (unitName === "year" && levelTicks.length > 1 && i === 0) {
        levelTicks.unshift({
          value: levelTicks[0].value - interval
        });
      }
    }
    for (let i = 0; i < newAddedTicks.length; i++) {
      levelTicks.push(newAddedTicks[i]);
    }
    return newAddedTicks;
  }
  const levelsTicks = [];
  let currentLevelTicks = [];
  let tickCount = 0;
  let lastLevelTickCount = 0;
  for (let i = 0; i < unitNames.length && iter++ < safeLimit; ++i) {
    const primaryTimeUnit = getPrimaryTimeUnit(unitNames[i]);
    if (!isPrimaryTimeUnit(unitNames[i])) {
      continue;
    }
    addLevelTicks(unitNames[i], levelsTicks[levelsTicks.length - 1] || [], currentLevelTicks);
    const nextPrimaryTimeUnit = unitNames[i + 1] ? getPrimaryTimeUnit(unitNames[i + 1]) : null;
    if (primaryTimeUnit !== nextPrimaryTimeUnit) {
      if (currentLevelTicks.length) {
        lastLevelTickCount = tickCount;
        currentLevelTicks.sort((a, b) => a.value - b.value);
        const levelTicksRemoveDuplicated = [];
        for (let i2 = 0; i2 < currentLevelTicks.length; ++i2) {
          const tickValue = currentLevelTicks[i2].value;
          if (i2 === 0 || currentLevelTicks[i2 - 1].value !== tickValue) {
            levelTicksRemoveDuplicated.push(currentLevelTicks[i2]);
            if (tickValue >= extent3[0] && tickValue <= extent3[1]) {
              tickCount++;
            }
          }
        }
        const targetTickNum = (extent3[1] - extent3[0]) / approxInterval;
        if (tickCount > targetTickNum * 1.5 && lastLevelTickCount > targetTickNum / 1.5) {
          break;
        }
        levelsTicks.push(levelTicksRemoveDuplicated);
        if (tickCount > targetTickNum || bottomUnitName === unitNames[i]) {
          break;
        }
      }
      currentLevelTicks = [];
    }
  }
  if (true) {
    if (iter >= safeLimit) {
      warn("Exceed safe limit.");
    }
  }
  const levelsTicksInExtent = filter(map(levelsTicks, (levelTicks) => {
    return filter(levelTicks, (tick) => tick.value >= extent3[0] && tick.value <= extent3[1] && !tick.notAdd);
  }), (levelTicks) => levelTicks.length > 0);
  const ticks = [];
  const maxLevel = levelsTicksInExtent.length - 1;
  for (let i = 0; i < levelsTicksInExtent.length; ++i) {
    const levelTicks = levelsTicksInExtent[i];
    for (let k = 0; k < levelTicks.length; ++k) {
      ticks.push({
        value: levelTicks[k].value,
        level: maxLevel - i
      });
    }
  }
  ticks.sort((a, b) => a.value - b.value);
  const result = [];
  for (let i = 0; i < ticks.length; ++i) {
    if (i === 0 || ticks[i].value !== ticks[i - 1].value) {
      result.push(ticks[i]);
    }
  }
  return result;
}
Scale_default.registerClass(TimeScale);
var Time_default = TimeScale;

// src/scale/Log.ts
var scaleProto = Scale_default.prototype;
var intervalScaleProto = Interval_default.prototype;
var roundingErrorFix = round;
var mathFloor = Math.floor;
var mathCeil = Math.ceil;
var mathPow2 = Math.pow;
var mathLog = Math.log;
var LogScale = class extends Scale_default {
  constructor() {
    super(...arguments);
    this.type = "log";
    this.base = 10;
    this._originalScale = new Interval_default();
    this._interval = 0;
  }
  getTicks(expandToNicedExtent) {
    const originalScale = this._originalScale;
    const extent3 = this._extent;
    const originalExtent = originalScale.getExtent();
    const ticks = intervalScaleProto.getTicks.call(this, expandToNicedExtent);
    return map(ticks, function(tick) {
      const val = tick.value;
      let powVal = round(mathPow2(this.base, val));
      powVal = val === extent3[0] && this._fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;
      powVal = val === extent3[1] && this._fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;
      return {
        value: powVal
      };
    }, this);
  }
  setExtent(start2, end2) {
    const base2 = mathLog(this.base);
    start2 = mathLog(Math.max(0, start2)) / base2;
    end2 = mathLog(Math.max(0, end2)) / base2;
    intervalScaleProto.setExtent.call(this, start2, end2);
  }
  getExtent() {
    const base2 = this.base;
    const extent3 = scaleProto.getExtent.call(this);
    extent3[0] = mathPow2(base2, extent3[0]);
    extent3[1] = mathPow2(base2, extent3[1]);
    const originalScale = this._originalScale;
    const originalExtent = originalScale.getExtent();
    this._fixMin && (extent3[0] = fixRoundingError(extent3[0], originalExtent[0]));
    this._fixMax && (extent3[1] = fixRoundingError(extent3[1], originalExtent[1]));
    return extent3;
  }
  unionExtent(extent3) {
    this._originalScale.unionExtent(extent3);
    const base2 = this.base;
    extent3[0] = mathLog(extent3[0]) / mathLog(base2);
    extent3[1] = mathLog(extent3[1]) / mathLog(base2);
    scaleProto.unionExtent.call(this, extent3);
  }
  unionExtentFromData(data, dim) {
    this.unionExtent(data.getApproximateExtent(dim));
  }
  calcNiceTicks(approxTickNum) {
    approxTickNum = approxTickNum || 10;
    const extent3 = this._extent;
    const span = extent3[1] - extent3[0];
    if (span === Infinity || span <= 0) {
      return;
    }
    let interval = quantity(span);
    const err = approxTickNum / span * interval;
    if (err <= 0.5) {
      interval *= 10;
    }
    while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
      interval *= 10;
    }
    const niceExtent = [
      round(mathCeil(extent3[0] / interval) * interval),
      round(mathFloor(extent3[1] / interval) * interval)
    ];
    this._interval = interval;
    this._niceExtent = niceExtent;
  }
  calcNiceExtent(opt) {
    intervalScaleProto.calcNiceExtent.call(this, opt);
    this._fixMin = opt.fixMin;
    this._fixMax = opt.fixMax;
  }
  parse(val) {
    return val;
  }
  contain(val) {
    val = mathLog(val) / mathLog(this.base);
    return contain2(val, this._extent);
  }
  normalize(val) {
    val = mathLog(val) / mathLog(this.base);
    return normalize2(val, this._extent);
  }
  scale(val) {
    val = scale3(val, this._extent);
    return mathPow2(this.base, val);
  }
};
LogScale.type = "log";
var proto = LogScale.prototype;
proto.getMinorTicks = intervalScaleProto.getMinorTicks;
proto.getLabel = intervalScaleProto.getLabel;
function fixRoundingError(val, originalVal) {
  return roundingErrorFix(val, getPrecision(originalVal));
}
Scale_default.registerClass(LogScale);
var Log_default = LogScale;

// src/coord/scaleRawExtentInfo.ts
var ScaleRawExtentInfo = class {
  constructor(scale4, model, originalExtent) {
    this._prepareParams(scale4, model, originalExtent);
  }
  _prepareParams(scale4, model, dataExtent) {
    if (dataExtent[1] < dataExtent[0]) {
      dataExtent = [NaN, NaN];
    }
    this._dataMin = dataExtent[0];
    this._dataMax = dataExtent[1];
    const isOrdinal = this._isOrdinal = scale4.type === "ordinal";
    this._needCrossZero = scale4.type === "interval" && model.getNeedCrossZero && model.getNeedCrossZero();
    const modelMinRaw = this._modelMinRaw = model.get("min", true);
    if (isFunction(modelMinRaw)) {
      this._modelMinNum = parseAxisModelMinMax(scale4, modelMinRaw({
        min: dataExtent[0],
        max: dataExtent[1]
      }));
    } else if (modelMinRaw !== "dataMin") {
      this._modelMinNum = parseAxisModelMinMax(scale4, modelMinRaw);
    }
    const modelMaxRaw = this._modelMaxRaw = model.get("max", true);
    if (isFunction(modelMaxRaw)) {
      this._modelMaxNum = parseAxisModelMinMax(scale4, modelMaxRaw({
        min: dataExtent[0],
        max: dataExtent[1]
      }));
    } else if (modelMaxRaw !== "dataMax") {
      this._modelMaxNum = parseAxisModelMinMax(scale4, modelMaxRaw);
    }
    if (isOrdinal) {
      this._axisDataLen = model.getCategories().length;
    } else {
      const boundaryGap = model.get("boundaryGap");
      const boundaryGapArr = isArray(boundaryGap) ? boundaryGap : [boundaryGap || 0, boundaryGap || 0];
      if (typeof boundaryGapArr[0] === "boolean" || typeof boundaryGapArr[1] === "boolean") {
        if (true) {
          console.warn('Boolean type for boundaryGap is only allowed for ordinal axis. Please use string in percentage instead, e.g., "20%". Currently, boundaryGap is set to be 0.');
        }
        this._boundaryGapInner = [0, 0];
      } else {
        this._boundaryGapInner = [
          parsePercent(boundaryGapArr[0], 1),
          parsePercent(boundaryGapArr[1], 1)
        ];
      }
    }
  }
  calculate() {
    const isOrdinal = this._isOrdinal;
    const dataMin = this._dataMin;
    const dataMax = this._dataMax;
    const axisDataLen = this._axisDataLen;
    const boundaryGapInner = this._boundaryGapInner;
    const span = !isOrdinal ? dataMax - dataMin || Math.abs(dataMin) : null;
    let min3 = this._modelMinRaw === "dataMin" ? dataMin : this._modelMinNum;
    let max3 = this._modelMaxRaw === "dataMax" ? dataMax : this._modelMaxNum;
    let minFixed = min3 != null;
    let maxFixed = max3 != null;
    if (min3 == null) {
      min3 = isOrdinal ? axisDataLen ? 0 : NaN : dataMin - boundaryGapInner[0] * span;
    }
    if (max3 == null) {
      max3 = isOrdinal ? axisDataLen ? axisDataLen - 1 : NaN : dataMax + boundaryGapInner[1] * span;
    }
    (min3 == null || !isFinite(min3)) && (min3 = NaN);
    (max3 == null || !isFinite(max3)) && (max3 = NaN);
    const isBlank = eqNaN(min3) || eqNaN(max3) || isOrdinal && !axisDataLen;
    if (this._needCrossZero) {
      if (min3 > 0 && max3 > 0 && !minFixed) {
        min3 = 0;
      }
      if (min3 < 0 && max3 < 0 && !maxFixed) {
        max3 = 0;
      }
    }
    const determinedMin = this._determinedMin;
    const determinedMax = this._determinedMax;
    if (determinedMin != null) {
      min3 = determinedMin;
      minFixed = true;
    }
    if (determinedMax != null) {
      max3 = determinedMax;
      maxFixed = true;
    }
    return {
      min: min3,
      max: max3,
      minFixed,
      maxFixed,
      isBlank
    };
  }
  modifyDataMinMax(minMaxName, val) {
    if (true) {
      assert(!this.frozen);
    }
    this[DATA_MIN_MAX_ATTR[minMaxName]] = val;
  }
  setDeterminedMinMax(minMaxName, val) {
    const attr = DETERMINED_MIN_MAX_ATTR[minMaxName];
    if (true) {
      assert(!this.frozen && this[attr] == null);
    }
    this[attr] = val;
  }
  freeze() {
    this.frozen = true;
  }
};
var DETERMINED_MIN_MAX_ATTR = {min: "_determinedMin", max: "_determinedMax"};
var DATA_MIN_MAX_ATTR = {min: "_dataMin", max: "_dataMax"};
function ensureScaleRawExtentInfo(scale4, model, originalExtent) {
  let rawExtentInfo = scale4.rawExtentInfo;
  if (rawExtentInfo) {
    return rawExtentInfo;
  }
  rawExtentInfo = new ScaleRawExtentInfo(scale4, model, originalExtent);
  scale4.rawExtentInfo = rawExtentInfo;
  return rawExtentInfo;
}
function parseAxisModelMinMax(scale4, minMax) {
  return minMax == null ? null : eqNaN(minMax) ? NaN : scale4.parse(minMax);
}

// src/coord/axisHelper.ts
function getScaleExtent(scale4, model) {
  const scaleType = scale4.type;
  const rawExtentResult = ensureScaleRawExtentInfo(scale4, model, scale4.getExtent()).calculate();
  scale4.setBlank(rawExtentResult.isBlank);
  let min3 = rawExtentResult.min;
  let max3 = rawExtentResult.max;
  const ecModel = model.ecModel;
  if (ecModel && scaleType === "time") {
    const barSeriesModels = prepareLayoutBarSeries("bar", ecModel);
    let isBaseAxisAndHasBarSeries = false;
    each(barSeriesModels, function(seriesModel) {
      isBaseAxisAndHasBarSeries = isBaseAxisAndHasBarSeries || seriesModel.getBaseAxis() === model.axis;
    });
    if (isBaseAxisAndHasBarSeries) {
      const barWidthAndOffset = makeColumnLayout(barSeriesModels);
      const adjustedScale = adjustScaleForOverflow(min3, max3, model, barWidthAndOffset);
      min3 = adjustedScale.min;
      max3 = adjustedScale.max;
    }
  }
  return {
    extent: [min3, max3],
    fixMin: rawExtentResult.minFixed,
    fixMax: rawExtentResult.maxFixed
  };
}
function adjustScaleForOverflow(min3, max3, model, barWidthAndOffset) {
  const axisExtent = model.axis.getExtent();
  const axisLength = axisExtent[1] - axisExtent[0];
  const barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);
  if (barsOnCurrentAxis === void 0) {
    return {min: min3, max: max3};
  }
  let minOverflow = Infinity;
  each(barsOnCurrentAxis, function(item) {
    minOverflow = Math.min(item.offset, minOverflow);
  });
  let maxOverflow = -Infinity;
  each(barsOnCurrentAxis, function(item) {
    maxOverflow = Math.max(item.offset + item.width, maxOverflow);
  });
  minOverflow = Math.abs(minOverflow);
  maxOverflow = Math.abs(maxOverflow);
  const totalOverFlow = minOverflow + maxOverflow;
  const oldRange = max3 - min3;
  const oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;
  const overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;
  max3 += overflowBuffer * (maxOverflow / totalOverFlow);
  min3 -= overflowBuffer * (minOverflow / totalOverFlow);
  return {min: min3, max: max3};
}
function niceScaleExtent(scale4, inModel) {
  const model = inModel;
  const extentInfo = getScaleExtent(scale4, model);
  const extent3 = extentInfo.extent;
  const splitNumber = model.get("splitNumber");
  if (scale4 instanceof Log_default) {
    scale4.base = model.get("logBase");
  }
  const scaleType = scale4.type;
  const interval = model.get("interval");
  const isIntervalOrTime = scaleType === "interval" || scaleType === "time";
  scale4.setExtent(extent3[0], extent3[1]);
  scale4.calcNiceExtent({
    splitNumber,
    fixMin: extentInfo.fixMin,
    fixMax: extentInfo.fixMax,
    minInterval: isIntervalOrTime ? model.get("minInterval") : null,
    maxInterval: isIntervalOrTime ? model.get("maxInterval") : null
  });
  if (interval != null) {
    scale4.setInterval && scale4.setInterval(interval);
  }
}
function createScaleByModel(model, axisType) {
  axisType = axisType || model.get("type");
  if (axisType) {
    switch (axisType) {
      case "category":
        return new Ordinal_default({
          ordinalMeta: model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(),
          extent: [Infinity, -Infinity]
        });
      case "time":
        return new Time_default({
          locale: model.ecModel.getLocaleModel(),
          useUTC: model.ecModel.get("useUTC")
        });
      default:
        return new (Scale_default.getClass(axisType) || Interval_default)();
    }
  }
}
function ifAxisCrossZero(axis) {
  const dataExtent = axis.scale.getExtent();
  const min3 = dataExtent[0];
  const max3 = dataExtent[1];
  return !(min3 > 0 && max3 > 0 || min3 < 0 && max3 < 0);
}
function makeLabelFormatter(axis) {
  const labelFormatter = axis.getLabelModel().get("formatter");
  const categoryTickStart = axis.type === "category" ? axis.scale.getExtent()[0] : null;
  if (axis.scale.type === "time") {
    return function(tpl) {
      return function(tick, idx) {
        return axis.scale.getFormattedLabel(tick, idx, tpl);
      };
    }(labelFormatter);
  } else if (isString(labelFormatter)) {
    return function(tpl) {
      return function(tick) {
        const label = axis.scale.getLabel(tick);
        const text = tpl.replace("{value}", label != null ? label : "");
        return text;
      };
    }(labelFormatter);
  } else if (isFunction(labelFormatter)) {
    return function(cb) {
      return function(tick, idx) {
        if (categoryTickStart != null) {
          idx = tick.value - categoryTickStart;
        }
        return cb(getAxisRawValue(axis, tick), idx, tick.level != null ? {
          level: tick.level
        } : null);
      };
    }(labelFormatter);
  } else {
    return function(tick) {
      return axis.scale.getLabel(tick);
    };
  }
}
function getAxisRawValue(axis, tick) {
  return axis.type === "category" ? axis.scale.getLabel(tick) : tick.value;
}
function estimateLabelUnionRect(axis) {
  const axisModel = axis.model;
  const scale4 = axis.scale;
  if (!axisModel.get(["axisLabel", "show"]) || scale4.isBlank()) {
    return;
  }
  let realNumberScaleTicks;
  let tickCount;
  const categoryScaleExtent = scale4.getExtent();
  if (scale4 instanceof Ordinal_default) {
    tickCount = scale4.count();
  } else {
    realNumberScaleTicks = scale4.getTicks();
    tickCount = realNumberScaleTicks.length;
  }
  const axisLabelModel = axis.getLabelModel();
  const labelFormatter = makeLabelFormatter(axis);
  let rect;
  let step = 1;
  if (tickCount > 40) {
    step = Math.ceil(tickCount / 40);
  }
  for (let i = 0; i < tickCount; i += step) {
    const tick = realNumberScaleTicks ? realNumberScaleTicks[i] : {
      value: categoryScaleExtent[0] + i
    };
    const label = labelFormatter(tick, i);
    const unrotatedSingleRect = axisLabelModel.getTextRect(label);
    const singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get("rotate") || 0);
    rect ? rect.union(singleRect) : rect = singleRect;
  }
  return rect;
}
function rotateTextRect(textRect, rotate2) {
  const rotateRadians = rotate2 * Math.PI / 180;
  const beforeWidth = textRect.width;
  const beforeHeight = textRect.height;
  const afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));
  const afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));
  const rotatedRect = new BoundingRect_default(textRect.x, textRect.y, afterWidth, afterHeight);
  return rotatedRect;
}
function getOptionCategoryInterval(model) {
  const interval = model.get("interval");
  return interval == null ? "auto" : interval;
}
function shouldShowAllLabels(axis) {
  return axis.type === "category" && getOptionCategoryInterval(axis.getLabelModel()) === 0;
}
function getDataDimensionsOnAxis(data, axisDim) {
  const dataDimMap = {};
  each(data.mapDimensionsAll(axisDim), function(dataDim) {
    dataDimMap[getStackedDimension(data, dataDim)] = true;
  });
  return keys(dataDimMap);
}
function unionAxisExtentFromData(dataExtent, data, axisDim) {
  if (data) {
    each(getDataDimensionsOnAxis(data, axisDim), function(dim) {
      const seriesExtent = data.getApproximateExtent(dim);
      seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);
      seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);
    });
  }
}

// src/coord/axisModelCommonMixin.ts
var AxisModelCommonMixin = class {
  getNeedCrossZero() {
    const option = this.option;
    return !option.scale;
  }
  getCoordSysModel() {
    return;
  }
};

// src/export/api/helper.ts
function createList(seriesModel) {
  return createSeriesData_default(null, seriesModel);
}
var dataStack2 = {
  isDimensionStacked,
  enableDataStack,
  getStackedDimension
};
function createScale(dataExtent, option) {
  let axisModel = option;
  if (!(option instanceof Model_default)) {
    axisModel = new Model_default(option);
  }
  const scale4 = createScaleByModel(axisModel);
  scale4.setExtent(dataExtent[0], dataExtent[1]);
  niceScaleExtent(scale4, axisModel);
  return scale4;
}
function mixinAxisModelCommonMethods(Model2) {
  mixin(Model2, AxisModelCommonMixin);
}
function createTextStyle2(textStyleModel, opts) {
  opts = opts || {};
  return createTextStyle(textStyleModel, null, null, opts.state !== "normal");
}

// node_modules/zrender/src/contain/polygon.ts
var EPSILON5 = 1e-8;
function isAroundEqual2(a, b) {
  return Math.abs(a - b) < EPSILON5;
}
function contain3(points4, x, y) {
  let w = 0;
  let p = points4[0];
  if (!p) {
    return false;
  }
  for (let i = 1; i < points4.length; i++) {
    const p2 = points4[i];
    w += windingLine(p[0], p[1], p2[0], p2[1], x, y);
    p = p2;
  }
  const p0 = points4[0];
  if (!isAroundEqual2(p[0], p0[0]) || !isAroundEqual2(p[1], p0[1])) {
    w += windingLine(p[0], p[1], p0[0], p0[1], x, y);
  }
  return w !== 0;
}

// src/coord/geo/Region.ts
var TMP_TRANSFORM = [];
function transformPoints(points4, transform2) {
  for (let p = 0; p < points4.length; p++) {
    applyTransform(points4[p], points4[p], transform2);
  }
}
function updateBBoxFromPoints(points4, min3, max3, projection) {
  for (let i = 0; i < points4.length; i++) {
    let p = points4[i];
    if (projection) {
      p = projection.project(p);
    }
    if (p && isFinite(p[0]) && isFinite(p[1])) {
      min(min3, min3, p);
      max(max3, max3, p);
    }
  }
}
function centroid(points4) {
  let signedArea = 0;
  let cx = 0;
  let cy = 0;
  const len2 = points4.length;
  let x0 = points4[len2 - 1][0];
  let y0 = points4[len2 - 1][1];
  for (let i = 0; i < len2; i++) {
    const x1 = points4[i][0];
    const y1 = points4[i][1];
    const a = x0 * y1 - x1 * y0;
    signedArea += a;
    cx += (x0 + x1) * a;
    cy += (y0 + y1) * a;
    x0 = x1;
    y0 = y1;
  }
  return signedArea ? [cx / signedArea / 3, cy / signedArea / 3, signedArea] : [points4[0][0] || 0, points4[0][1] || 0];
}
var Region = class {
  constructor(name) {
    this.name = name;
  }
  setCenter(center3) {
    this._center = center3;
  }
  getCenter() {
    let center3 = this._center;
    if (!center3) {
      center3 = this._center = this.calcCenter();
    }
    return center3;
  }
};
var GeoJSONPolygonGeometry = class {
  constructor(exterior, interiors) {
    this.type = "polygon";
    this.exterior = exterior;
    this.interiors = interiors;
  }
};
var GeoJSONLineStringGeometry = class {
  constructor(points4) {
    this.type = "linestring";
    this.points = points4;
  }
};
var GeoJSONRegion = class extends Region {
  constructor(name, geometries, cp) {
    super(name);
    this.type = "geoJSON";
    this.geometries = geometries;
    this._center = cp && [cp[0], cp[1]];
  }
  calcCenter() {
    const geometries = this.geometries;
    let largestGeo;
    let largestGeoSize = 0;
    for (let i = 0; i < geometries.length; i++) {
      const geo = geometries[i];
      const exterior = geo.exterior;
      const size = exterior && exterior.length;
      if (size > largestGeoSize) {
        largestGeo = geo;
        largestGeoSize = size;
      }
    }
    if (largestGeo) {
      return centroid(largestGeo.exterior);
    }
    const rect = this.getBoundingRect();
    return [
      rect.x + rect.width / 2,
      rect.y + rect.height / 2
    ];
  }
  getBoundingRect(projection) {
    let rect = this._rect;
    if (rect && !projection) {
      return rect;
    }
    const min3 = [Infinity, Infinity];
    const max3 = [-Infinity, -Infinity];
    const geometries = this.geometries;
    each(geometries, (geo) => {
      if (geo.type === "polygon") {
        updateBBoxFromPoints(geo.exterior, min3, max3, projection);
      } else {
        each(geo.points, (points4) => {
          updateBBoxFromPoints(points4, min3, max3, projection);
        });
      }
    });
    if (!(isFinite(min3[0]) && isFinite(min3[1]) && isFinite(max3[0]) && isFinite(max3[1]))) {
      min3[0] = min3[1] = max3[0] = max3[1] = 0;
    }
    rect = new BoundingRect_default(min3[0], min3[1], max3[0] - min3[0], max3[1] - min3[1]);
    if (!projection) {
      this._rect = rect;
    }
    return rect;
  }
  contain(coord) {
    const rect = this.getBoundingRect();
    const geometries = this.geometries;
    if (!rect.contain(coord[0], coord[1])) {
      return false;
    }
    loopGeo:
      for (let i = 0, len2 = geometries.length; i < len2; i++) {
        const geo = geometries[i];
        if (geo.type !== "polygon") {
          continue;
        }
        const exterior = geo.exterior;
        const interiors = geo.interiors;
        if (contain3(exterior, coord[0], coord[1])) {
          for (let k = 0; k < (interiors ? interiors.length : 0); k++) {
            if (contain3(interiors[k], coord[0], coord[1])) {
              continue loopGeo;
            }
          }
          return true;
        }
      }
    return false;
  }
  transformTo(x, y, width, height) {
    let rect = this.getBoundingRect();
    const aspect = rect.width / rect.height;
    if (!width) {
      width = aspect * height;
    } else if (!height) {
      height = width / aspect;
    }
    const target = new BoundingRect_default(x, y, width, height);
    const transform2 = rect.calculateTransform(target);
    const geometries = this.geometries;
    for (let i = 0; i < geometries.length; i++) {
      const geo = geometries[i];
      if (geo.type === "polygon") {
        transformPoints(geo.exterior, transform2);
        each(geo.interiors, (interior) => {
          transformPoints(interior, transform2);
        });
      } else {
        each(geo.points, (points4) => {
          transformPoints(points4, transform2);
        });
      }
    }
    rect = this._rect;
    rect.copy(target);
    this._center = [
      rect.x + rect.width / 2,
      rect.y + rect.height / 2
    ];
  }
  cloneShallow(name) {
    name == null && (name = this.name);
    const newRegion = new GeoJSONRegion(name, this.geometries, this._center);
    newRegion._rect = this._rect;
    newRegion.transformTo = null;
    return newRegion;
  }
};
var GeoSVGRegion = class extends Region {
  constructor(name, elOnlyForCalculate) {
    super(name);
    this.type = "geoSVG";
    this._elOnlyForCalculate = elOnlyForCalculate;
  }
  calcCenter() {
    const el = this._elOnlyForCalculate;
    const rect = el.getBoundingRect();
    const center3 = [
      rect.x + rect.width / 2,
      rect.y + rect.height / 2
    ];
    const mat = identity(TMP_TRANSFORM);
    let target = el;
    while (target && !target.isGeoSVGGraphicRoot) {
      mul2(mat, target.getLocalTransform(), mat);
      target = target.parent;
    }
    invert(mat, mat);
    applyTransform(center3, center3, mat);
    return center3;
  }
};

// src/coord/geo/parseGeoJson.ts
function decode(json) {
  if (!json.UTF8Encoding) {
    return json;
  }
  const jsonCompressed = json;
  let encodeScale = jsonCompressed.UTF8Scale;
  if (encodeScale == null) {
    encodeScale = 1024;
  }
  const features2 = jsonCompressed.features;
  each(features2, (feature) => {
    const geometry = feature.geometry;
    const encodeOffsets = geometry.encodeOffsets;
    const coordinates = geometry.coordinates;
    if (!encodeOffsets) {
      return;
    }
    switch (geometry.type) {
      case "LineString":
        geometry.coordinates = decodeRing(coordinates, encodeOffsets, encodeScale);
        break;
      case "Polygon":
        decodeRings(coordinates, encodeOffsets, encodeScale);
        break;
      case "MultiLineString":
        decodeRings(coordinates, encodeOffsets, encodeScale);
        break;
      case "MultiPolygon":
        each(coordinates, (rings, idx) => decodeRings(rings, encodeOffsets[idx], encodeScale));
    }
  });
  jsonCompressed.UTF8Encoding = false;
  return jsonCompressed;
}
function decodeRings(rings, encodeOffsets, encodeScale) {
  for (let c = 0; c < rings.length; c++) {
    rings[c] = decodeRing(rings[c], encodeOffsets[c], encodeScale);
  }
}
function decodeRing(coordinate, encodeOffsets, encodeScale) {
  const result = [];
  let prevX = encodeOffsets[0];
  let prevY = encodeOffsets[1];
  for (let i = 0; i < coordinate.length; i += 2) {
    let x = coordinate.charCodeAt(i) - 64;
    let y = coordinate.charCodeAt(i + 1) - 64;
    x = x >> 1 ^ -(x & 1);
    y = y >> 1 ^ -(y & 1);
    x += prevX;
    y += prevY;
    prevX = x;
    prevY = y;
    result.push([x / encodeScale, y / encodeScale]);
  }
  return result;
}
function parseGeoJSON(geoJson, nameProperty) {
  geoJson = decode(geoJson);
  return map(filter(geoJson.features, function(featureObj) {
    return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0;
  }), function(featureObj) {
    const properties = featureObj.properties;
    const geo = featureObj.geometry;
    const geometries = [];
    switch (geo.type) {
      case "Polygon":
        const coordinates = geo.coordinates;
        geometries.push(new GeoJSONPolygonGeometry(coordinates[0], coordinates.slice(1)));
        break;
      case "MultiPolygon":
        each(geo.coordinates, function(item) {
          if (item[0]) {
            geometries.push(new GeoJSONPolygonGeometry(item[0], item.slice(1)));
          }
        });
        break;
      case "LineString":
        geometries.push(new GeoJSONLineStringGeometry([geo.coordinates]));
        break;
      case "MultiLineString":
        geometries.push(new GeoJSONLineStringGeometry(geo.coordinates));
    }
    const region = new GeoJSONRegion(properties[nameProperty || "name"], geometries, properties.cp);
    region.properties = properties;
    return region;
  });
}

// src/export/api/number.ts
var number_exports = {};
__export(number_exports, {
  MAX_SAFE_INTEGER: () => MAX_SAFE_INTEGER,
  asc: () => asc,
  getPercentWithPrecision: () => getPercentWithPrecision,
  getPixelPrecision: () => getPixelPrecision,
  getPrecision: () => getPrecision,
  getPrecisionSafe: () => getPrecisionSafe,
  isNumeric: () => isNumeric,
  isRadianAroundZero: () => isRadianAroundZero,
  linearMap: () => linearMap,
  nice: () => nice,
  numericToNumber: () => numericToNumber,
  parseDate: () => parseDate,
  quantile: () => quantile,
  quantity: () => quantity,
  quantityExponent: () => quantityExponent,
  reformIntervals: () => reformIntervals,
  remRadian: () => remRadian,
  round: () => round
});

// src/export/api/time.ts
var time_exports = {};
__export(time_exports, {
  format: () => format,
  parse: () => parseDate
});

// src/export/api/graphic.ts
var graphic_exports2 = {};
__export(graphic_exports2, {
  Arc: () => Arc_default,
  BezierCurve: () => BezierCurve_default,
  BoundingRect: () => BoundingRect_default,
  Circle: () => Circle_default,
  CompoundPath: () => CompoundPath_default,
  Ellipse: () => Ellipse_default,
  Group: () => Group_default,
  Image: () => Image_default,
  IncrementalDisplayable: () => IncrementalDisplayable_default,
  Line: () => Line_default,
  LinearGradient: () => LinearGradient_default,
  Polygon: () => Polygon_default,
  Polyline: () => Polyline_default,
  RadialGradient: () => RadialGradient_default,
  Rect: () => Rect_default,
  Ring: () => Ring_default,
  Sector: () => Sector_default,
  Text: () => Text_default,
  clipPointsByRect: () => clipPointsByRect,
  clipRectByRect: () => clipRectByRect,
  createIcon: () => createIcon,
  extendPath: () => extendPath,
  extendShape: () => extendShape,
  getShapeClass: () => getShapeClass,
  getTransform: () => getTransform,
  initProps: () => initProps,
  makeImage: () => makeImage,
  makePath: () => makePath,
  mergePath: () => mergePath2,
  registerShape: () => registerShape,
  resizePath: () => resizePath,
  updateProps: () => updateProps
});

// src/export/api/format.ts
var format_exports = {};
__export(format_exports, {
  addCommas: () => addCommas,
  capitalFirst: () => capitalFirst,
  encodeHTML: () => encodeHTML,
  formatTime: () => formatTime,
  formatTpl: () => formatTpl,
  getTextRect: () => getTextRect,
  getTooltipMarker: () => getTooltipMarker,
  normalizeCssArray: () => normalizeCssArray2,
  toCamelCase: () => toCamelCase,
  truncateText: () => truncateText
});

// src/export/api/util.ts
var util_exports2 = {};
__export(util_exports2, {
  bind: () => bind,
  clone: () => clone,
  curry: () => curry,
  defaults: () => defaults,
  each: () => each,
  extend: () => extend,
  filter: () => filter,
  indexOf: () => indexOf,
  inherits: () => inherits,
  isArray: () => isArray,
  isFunction: () => isFunction,
  isObject: () => isObject,
  isString: () => isString,
  map: () => map,
  merge: () => merge,
  reduce: () => reduce
});

// src/coord/axisTickLabelBuilder.ts
var inner6 = makeInner();
function createAxisLabels(axis) {
  return axis.type === "category" ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);
}
function createAxisTicks(axis, tickModel) {
  return axis.type === "category" ? makeCategoryTicks(axis, tickModel) : {ticks: map(axis.scale.getTicks(), (tick) => tick.value)};
}
function makeCategoryLabels(axis) {
  const labelModel = axis.getLabelModel();
  const result = makeCategoryLabelsActually(axis, labelModel);
  return !labelModel.get("show") || axis.scale.isBlank() ? {labels: [], labelCategoryInterval: result.labelCategoryInterval} : result;
}
function makeCategoryLabelsActually(axis, labelModel) {
  const labelsCache = getListCache(axis, "labels");
  const optionLabelInterval = getOptionCategoryInterval(labelModel);
  const result = listCacheGet(labelsCache, optionLabelInterval);
  if (result) {
    return result;
  }
  let labels;
  let numericLabelInterval;
  if (isFunction(optionLabelInterval)) {
    labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);
  } else {
    numericLabelInterval = optionLabelInterval === "auto" ? makeAutoCategoryInterval(axis) : optionLabelInterval;
    labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);
  }
  return listCacheSet(labelsCache, optionLabelInterval, {
    labels,
    labelCategoryInterval: numericLabelInterval
  });
}
function makeCategoryTicks(axis, tickModel) {
  const ticksCache = getListCache(axis, "ticks");
  const optionTickInterval = getOptionCategoryInterval(tickModel);
  const result = listCacheGet(ticksCache, optionTickInterval);
  if (result) {
    return result;
  }
  let ticks;
  let tickCategoryInterval;
  if (!tickModel.get("show") || axis.scale.isBlank()) {
    ticks = [];
  }
  if (isFunction(optionTickInterval)) {
    ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);
  } else if (optionTickInterval === "auto") {
    const labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());
    tickCategoryInterval = labelsResult.labelCategoryInterval;
    ticks = map(labelsResult.labels, function(labelItem) {
      return labelItem.tickValue;
    });
  } else {
    tickCategoryInterval = optionTickInterval;
    ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);
  }
  return listCacheSet(ticksCache, optionTickInterval, {
    ticks,
    tickCategoryInterval
  });
}
function makeRealNumberLabels(axis) {
  const ticks = axis.scale.getTicks();
  const labelFormatter = makeLabelFormatter(axis);
  return {
    labels: map(ticks, function(tick, idx) {
      return {
        level: tick.level,
        formattedLabel: labelFormatter(tick, idx),
        rawLabel: axis.scale.getLabel(tick),
        tickValue: tick.value
      };
    })
  };
}
function getListCache(axis, prop) {
  return inner6(axis)[prop] || (inner6(axis)[prop] = []);
}
function listCacheGet(cache, key) {
  for (let i = 0; i < cache.length; i++) {
    if (cache[i].key === key) {
      return cache[i].value;
    }
  }
}
function listCacheSet(cache, key, value) {
  cache.push({key, value});
  return value;
}
function makeAutoCategoryInterval(axis) {
  const result = inner6(axis).autoInterval;
  return result != null ? result : inner6(axis).autoInterval = axis.calculateCategoryInterval();
}
function calculateCategoryInterval(axis) {
  const params = fetchAutoCategoryIntervalCalculationParams(axis);
  const labelFormatter = makeLabelFormatter(axis);
  const rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;
  const ordinalScale = axis.scale;
  const ordinalExtent = ordinalScale.getExtent();
  const tickCount = ordinalScale.count();
  if (ordinalExtent[1] - ordinalExtent[0] < 1) {
    return 0;
  }
  let step = 1;
  if (tickCount > 40) {
    step = Math.max(1, Math.floor(tickCount / 40));
  }
  let tickValue = ordinalExtent[0];
  const unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
  const unitW = Math.abs(unitSpan * Math.cos(rotation));
  const unitH = Math.abs(unitSpan * Math.sin(rotation));
  let maxW = 0;
  let maxH = 0;
  for (; tickValue <= ordinalExtent[1]; tickValue += step) {
    let width = 0;
    let height = 0;
    const rect = getBoundingRect(labelFormatter({value: tickValue}), params.font, "center", "top");
    width = rect.width * 1.3;
    height = rect.height * 1.3;
    maxW = Math.max(maxW, width, 7);
    maxH = Math.max(maxH, height, 7);
  }
  let dw = maxW / unitW;
  let dh = maxH / unitH;
  isNaN(dw) && (dw = Infinity);
  isNaN(dh) && (dh = Infinity);
  let interval = Math.max(0, Math.floor(Math.min(dw, dh)));
  const cache = inner6(axis.model);
  const axisExtent = axis.getExtent();
  const lastAutoInterval = cache.lastAutoInterval;
  const lastTickCount = cache.lastTickCount;
  if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval && cache.axisExtent0 === axisExtent[0] && cache.axisExtent1 === axisExtent[1]) {
    interval = lastAutoInterval;
  } else {
    cache.lastTickCount = tickCount;
    cache.lastAutoInterval = interval;
    cache.axisExtent0 = axisExtent[0];
    cache.axisExtent1 = axisExtent[1];
  }
  return interval;
}
function fetchAutoCategoryIntervalCalculationParams(axis) {
  const labelModel = axis.getLabelModel();
  return {
    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,
    labelRotate: labelModel.get("rotate") || 0,
    font: labelModel.getFont()
  };
}
function makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {
  const labelFormatter = makeLabelFormatter(axis);
  const ordinalScale = axis.scale;
  const ordinalExtent = ordinalScale.getExtent();
  const labelModel = axis.getLabelModel();
  const result = [];
  const step = Math.max((categoryInterval || 0) + 1, 1);
  let startTick = ordinalExtent[0];
  const tickCount = ordinalScale.count();
  if (startTick !== 0 && step > 1 && tickCount / step > 2) {
    startTick = Math.round(Math.ceil(startTick / step) * step);
  }
  const showAllLabel = shouldShowAllLabels(axis);
  const includeMinLabel = labelModel.get("showMinLabel") || showAllLabel;
  const includeMaxLabel = labelModel.get("showMaxLabel") || showAllLabel;
  if (includeMinLabel && startTick !== ordinalExtent[0]) {
    addItem(ordinalExtent[0]);
  }
  let tickValue = startTick;
  for (; tickValue <= ordinalExtent[1]; tickValue += step) {
    addItem(tickValue);
  }
  if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {
    addItem(ordinalExtent[1]);
  }
  function addItem(tickValue2) {
    const tickObj = {value: tickValue2};
    result.push(onlyTick ? tickValue2 : {
      formattedLabel: labelFormatter(tickObj),
      rawLabel: ordinalScale.getLabel(tickObj),
      tickValue: tickValue2
    });
  }
  return result;
}
function makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {
  const ordinalScale = axis.scale;
  const labelFormatter = makeLabelFormatter(axis);
  const result = [];
  each(ordinalScale.getTicks(), function(tick) {
    const rawLabel = ordinalScale.getLabel(tick);
    const tickValue = tick.value;
    if (categoryInterval(tick.value, rawLabel)) {
      result.push(onlyTick ? tickValue : {
        formattedLabel: labelFormatter(tick),
        rawLabel,
        tickValue
      });
    }
  });
  return result;
}

// src/coord/Axis.ts
var NORMALIZED_EXTENT = [0, 1];
var Axis = class {
  constructor(dim, scale4, extent3) {
    this.onBand = false;
    this.inverse = false;
    this.dim = dim;
    this.scale = scale4;
    this._extent = extent3 || [0, 0];
  }
  contain(coord) {
    const extent3 = this._extent;
    const min3 = Math.min(extent3[0], extent3[1]);
    const max3 = Math.max(extent3[0], extent3[1]);
    return coord >= min3 && coord <= max3;
  }
  containData(data) {
    return this.scale.contain(data);
  }
  getExtent() {
    return this._extent.slice();
  }
  getPixelPrecision(dataExtent) {
    return getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
  }
  setExtent(start2, end2) {
    const extent3 = this._extent;
    extent3[0] = start2;
    extent3[1] = end2;
  }
  dataToCoord(data, clamp2) {
    let extent3 = this._extent;
    const scale4 = this.scale;
    data = scale4.normalize(data);
    if (this.onBand && scale4.type === "ordinal") {
      extent3 = extent3.slice();
      fixExtentWithBands(extent3, scale4.count());
    }
    return linearMap(data, NORMALIZED_EXTENT, extent3, clamp2);
  }
  coordToData(coord, clamp2) {
    let extent3 = this._extent;
    const scale4 = this.scale;
    if (this.onBand && scale4.type === "ordinal") {
      extent3 = extent3.slice();
      fixExtentWithBands(extent3, scale4.count());
    }
    const t = linearMap(coord, extent3, NORMALIZED_EXTENT, clamp2);
    return this.scale.scale(t);
  }
  pointToData(point, clamp2) {
    return;
  }
  getTicksCoords(opt) {
    opt = opt || {};
    const tickModel = opt.tickModel || this.getTickModel();
    const result = createAxisTicks(this, tickModel);
    const ticks = result.ticks;
    const ticksCoords = map(ticks, function(tickVal) {
      return {
        coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(tickVal) : tickVal),
        tickValue: tickVal
      };
    }, this);
    const alignWithLabel = tickModel.get("alignWithLabel");
    fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);
    return ticksCoords;
  }
  getMinorTicksCoords() {
    if (this.scale.type === "ordinal") {
      return [];
    }
    const minorTickModel = this.model.getModel("minorTick");
    let splitNumber = minorTickModel.get("splitNumber");
    if (!(splitNumber > 0 && splitNumber < 100)) {
      splitNumber = 5;
    }
    const minorTicks = this.scale.getMinorTicks(splitNumber);
    const minorTicksCoords = map(minorTicks, function(minorTicksGroup) {
      return map(minorTicksGroup, function(minorTick) {
        return {
          coord: this.dataToCoord(minorTick),
          tickValue: minorTick
        };
      }, this);
    }, this);
    return minorTicksCoords;
  }
  getViewLabels() {
    return createAxisLabels(this).labels;
  }
  getLabelModel() {
    return this.model.getModel("axisLabel");
  }
  getTickModel() {
    return this.model.getModel("axisTick");
  }
  getBandWidth() {
    const axisExtent = this._extent;
    const dataExtent = this.scale.getExtent();
    let len2 = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);
    len2 === 0 && (len2 = 1);
    const size = Math.abs(axisExtent[1] - axisExtent[0]);
    return Math.abs(size) / len2;
  }
  calculateCategoryInterval() {
    return calculateCategoryInterval(this);
  }
};
function fixExtentWithBands(extent3, nTick) {
  const size = extent3[1] - extent3[0];
  const len2 = nTick;
  const margin = size / len2 / 2;
  extent3[0] += margin;
  extent3[1] -= margin;
}
function fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp2) {
  const ticksLen = ticksCoords.length;
  if (!axis.onBand || alignWithLabel || !ticksLen) {
    return;
  }
  const axisExtent = axis.getExtent();
  let last;
  let diffSize;
  if (ticksLen === 1) {
    ticksCoords[0].coord = axisExtent[0];
    last = ticksCoords[1] = {coord: axisExtent[1]};
  } else {
    const crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;
    const shift = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;
    each(ticksCoords, function(ticksItem) {
      ticksItem.coord -= shift / 2;
    });
    const dataExtent = axis.scale.getExtent();
    diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;
    last = {coord: ticksCoords[ticksLen - 1].coord + shift * diffSize};
    ticksCoords.push(last);
  }
  const inverse = axisExtent[0] > axisExtent[1];
  if (littleThan2(ticksCoords[0].coord, axisExtent[0])) {
    clamp2 ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();
  }
  if (clamp2 && littleThan2(axisExtent[0], ticksCoords[0].coord)) {
    ticksCoords.unshift({coord: axisExtent[0]});
  }
  if (littleThan2(axisExtent[1], last.coord)) {
    clamp2 ? last.coord = axisExtent[1] : ticksCoords.pop();
  }
  if (clamp2 && littleThan2(last.coord, axisExtent[1])) {
    ticksCoords.push({coord: axisExtent[1]});
  }
  function littleThan2(a, b) {
    a = round(a);
    b = round(b);
    return inverse ? a > b : a < b;
  }
}
var Axis_default = Axis;

// src/export/api.ts
function extendComponentModel(proto2) {
  const Model2 = Component_default.extend(proto2);
  Component_default.registerClass(Model2);
  return Model2;
}
function extendComponentView(proto2) {
  const View2 = Component_default2.extend(proto2);
  Component_default2.registerClass(View2);
  return View2;
}
function extendSeriesModel(proto2) {
  const Model2 = Series_default.extend(proto2);
  Series_default.registerClass(Model2);
  return Model2;
}
function extendChartView(proto2) {
  const View2 = Chart_default.extend(proto2);
  Chart_default.registerClass(View2);
  return View2;
}

// src/label/labelGuideHelper.ts
var PI27 = Math.PI * 2;
var CMD4 = PathProxy_default.CMD;
var DEFAULT_SEARCH_SPACE = ["top", "right", "bottom", "left"];
function getCandidateAnchor(pos, distance2, rect, outPt, outDir) {
  const width = rect.width;
  const height = rect.height;
  switch (pos) {
    case "top":
      outPt.set(rect.x + width / 2, rect.y - distance2);
      outDir.set(0, -1);
      break;
    case "bottom":
      outPt.set(rect.x + width / 2, rect.y + height + distance2);
      outDir.set(0, 1);
      break;
    case "left":
      outPt.set(rect.x - distance2, rect.y + height / 2);
      outDir.set(-1, 0);
      break;
    case "right":
      outPt.set(rect.x + width + distance2, rect.y + height / 2);
      outDir.set(1, 0);
      break;
  }
}
function projectPointToArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y, out2) {
  x -= cx;
  y -= cy;
  const d = Math.sqrt(x * x + y * y);
  x /= d;
  y /= d;
  const ox = x * r + cx;
  const oy = y * r + cy;
  if (Math.abs(startAngle - endAngle) % PI27 < 1e-4) {
    out2[0] = ox;
    out2[1] = oy;
    return d - r;
  }
  if (anticlockwise) {
    const tmp = startAngle;
    startAngle = normalizeRadian(endAngle);
    endAngle = normalizeRadian(tmp);
  } else {
    startAngle = normalizeRadian(startAngle);
    endAngle = normalizeRadian(endAngle);
  }
  if (startAngle > endAngle) {
    endAngle += PI27;
  }
  let angle = Math.atan2(y, x);
  if (angle < 0) {
    angle += PI27;
  }
  if (angle >= startAngle && angle <= endAngle || angle + PI27 >= startAngle && angle + PI27 <= endAngle) {
    out2[0] = ox;
    out2[1] = oy;
    return d - r;
  }
  const x1 = r * Math.cos(startAngle) + cx;
  const y1 = r * Math.sin(startAngle) + cy;
  const x2 = r * Math.cos(endAngle) + cx;
  const y2 = r * Math.sin(endAngle) + cy;
  const d1 = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y);
  const d2 = (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);
  if (d1 < d2) {
    out2[0] = x1;
    out2[1] = y1;
    return Math.sqrt(d1);
  } else {
    out2[0] = x2;
    out2[1] = y2;
    return Math.sqrt(d2);
  }
}
function projectPointToLine(x1, y1, x2, y2, x, y, out2, limitToEnds) {
  const dx = x - x1;
  const dy = y - y1;
  let dx1 = x2 - x1;
  let dy1 = y2 - y1;
  const lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1);
  dx1 /= lineLen;
  dy1 /= lineLen;
  const projectedLen = dx * dx1 + dy * dy1;
  let t = projectedLen / lineLen;
  if (limitToEnds) {
    t = Math.min(Math.max(t, 0), 1);
  }
  t *= lineLen;
  const ox = out2[0] = x1 + t * dx1;
  const oy = out2[1] = y1 + t * dy1;
  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));
}
function projectPointToRect(x1, y1, width, height, x, y, out2) {
  if (width < 0) {
    x1 = x1 + width;
    width = -width;
  }
  if (height < 0) {
    y1 = y1 + height;
    height = -height;
  }
  const x2 = x1 + width;
  const y2 = y1 + height;
  const ox = out2[0] = Math.min(Math.max(x, x1), x2);
  const oy = out2[1] = Math.min(Math.max(y, y1), y2);
  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));
}
var tmpPt = [];
function nearestPointOnRect(pt, rect, out2) {
  const dist3 = projectPointToRect(rect.x, rect.y, rect.width, rect.height, pt.x, pt.y, tmpPt);
  out2.set(tmpPt[0], tmpPt[1]);
  return dist3;
}
function nearestPointOnPath(pt, path, out2) {
  let xi = 0;
  let yi = 0;
  let x0 = 0;
  let y0 = 0;
  let x1;
  let y1;
  let minDist = Infinity;
  const data = path.data;
  const x = pt.x;
  const y = pt.y;
  for (let i = 0; i < data.length; ) {
    const cmd = data[i++];
    if (i === 1) {
      xi = data[i];
      yi = data[i + 1];
      x0 = xi;
      y0 = yi;
    }
    let d = minDist;
    switch (cmd) {
      case CMD4.M:
        x0 = data[i++];
        y0 = data[i++];
        xi = x0;
        yi = y0;
        break;
      case CMD4.L:
        d = projectPointToLine(xi, yi, data[i], data[i + 1], x, y, tmpPt, true);
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD4.C:
        d = cubicProjectPoint(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD4.Q:
        d = quadraticProjectPoint(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);
        xi = data[i++];
        yi = data[i++];
        break;
      case CMD4.A:
        const cx = data[i++];
        const cy = data[i++];
        const rx = data[i++];
        const ry = data[i++];
        const theta = data[i++];
        const dTheta = data[i++];
        i += 1;
        const anticlockwise = !!(1 - data[i++]);
        x1 = Math.cos(theta) * rx + cx;
        y1 = Math.sin(theta) * ry + cy;
        if (i <= 1) {
          x0 = x1;
          y0 = y1;
        }
        const _x = (x - cx) * ry / rx + cx;
        d = projectPointToArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y, tmpPt);
        xi = Math.cos(theta + dTheta) * rx + cx;
        yi = Math.sin(theta + dTheta) * ry + cy;
        break;
      case CMD4.R:
        x0 = xi = data[i++];
        y0 = yi = data[i++];
        const width = data[i++];
        const height = data[i++];
        d = projectPointToRect(x0, y0, width, height, x, y, tmpPt);
        break;
      case CMD4.Z:
        d = projectPointToLine(xi, yi, x0, y0, x, y, tmpPt, true);
        xi = x0;
        yi = y0;
        break;
    }
    if (d < minDist) {
      minDist = d;
      out2.set(tmpPt[0], tmpPt[1]);
    }
  }
  return minDist;
}
var pt0 = new Point_default();
var pt1 = new Point_default();
var pt2 = new Point_default();
var dir = new Point_default();
var dir2 = new Point_default();
function updateLabelLinePoints(target, labelLineModel) {
  if (!target) {
    return;
  }
  const labelLine = target.getTextGuideLine();
  const label = target.getTextContent();
  if (!(label && labelLine)) {
    return;
  }
  const labelGuideConfig = target.textGuideLineConfig || {};
  const points4 = [[0, 0], [0, 0], [0, 0]];
  const searchSpace = labelGuideConfig.candidates || DEFAULT_SEARCH_SPACE;
  const labelRect = label.getBoundingRect().clone();
  labelRect.applyTransform(label.getComputedTransform());
  let minDist = Infinity;
  const anchorPoint = labelGuideConfig.anchor;
  const targetTransform = target.getComputedTransform();
  const targetInversedTransform = targetTransform && invert([], targetTransform);
  const len2 = labelLineModel.get("length2") || 0;
  if (anchorPoint) {
    pt2.copy(anchorPoint);
  }
  for (let i = 0; i < searchSpace.length; i++) {
    const candidate = searchSpace[i];
    getCandidateAnchor(candidate, 0, labelRect, pt0, dir);
    Point_default.scaleAndAdd(pt1, pt0, dir, len2);
    pt1.transform(targetInversedTransform);
    const boundingRect = target.getBoundingRect();
    const dist3 = anchorPoint ? anchorPoint.distance(pt1) : target instanceof Path_default ? nearestPointOnPath(pt1, target.path, pt2) : nearestPointOnRect(pt1, boundingRect, pt2);
    if (dist3 < minDist) {
      minDist = dist3;
      pt1.transform(targetTransform);
      pt2.transform(targetTransform);
      pt2.toArray(points4[0]);
      pt1.toArray(points4[1]);
      pt0.toArray(points4[2]);
    }
  }
  limitTurnAngle(points4, labelLineModel.get("minTurnAngle"));
  labelLine.setShape({points: points4});
}
var tmpArr = [];
var tmpProjPoint = new Point_default();
function limitTurnAngle(linePoints, minTurnAngle) {
  if (!(minTurnAngle <= 180 && minTurnAngle > 0)) {
    return;
  }
  minTurnAngle = minTurnAngle / 180 * Math.PI;
  pt0.fromArray(linePoints[0]);
  pt1.fromArray(linePoints[1]);
  pt2.fromArray(linePoints[2]);
  Point_default.sub(dir, pt0, pt1);
  Point_default.sub(dir2, pt2, pt1);
  const len1 = dir.len();
  const len2 = dir2.len();
  if (len1 < 1e-3 || len2 < 1e-3) {
    return;
  }
  dir.scale(1 / len1);
  dir2.scale(1 / len2);
  const angleCos = dir.dot(dir2);
  const minTurnAngleCos = Math.cos(minTurnAngle);
  if (minTurnAngleCos < angleCos) {
    const d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
    tmpProjPoint.fromArray(tmpArr);
    tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI - minTurnAngle));
    const t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
    if (isNaN(t)) {
      return;
    }
    if (t < 0) {
      Point_default.copy(tmpProjPoint, pt1);
    } else if (t > 1) {
      Point_default.copy(tmpProjPoint, pt2);
    }
    tmpProjPoint.toArray(linePoints[1]);
  }
}
function limitSurfaceAngle(linePoints, surfaceNormal, maxSurfaceAngle) {
  if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) {
    return;
  }
  maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI;
  pt0.fromArray(linePoints[0]);
  pt1.fromArray(linePoints[1]);
  pt2.fromArray(linePoints[2]);
  Point_default.sub(dir, pt1, pt0);
  Point_default.sub(dir2, pt2, pt1);
  const len1 = dir.len();
  const len2 = dir2.len();
  if (len1 < 1e-3 || len2 < 1e-3) {
    return;
  }
  dir.scale(1 / len1);
  dir2.scale(1 / len2);
  const angleCos = dir.dot(surfaceNormal);
  const maxSurfaceAngleCos = Math.cos(maxSurfaceAngle);
  if (angleCos < maxSurfaceAngleCos) {
    const d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
    tmpProjPoint.fromArray(tmpArr);
    const HALF_PI = Math.PI / 2;
    const angle2 = Math.acos(dir2.dot(surfaceNormal));
    const newAngle = HALF_PI + angle2 - maxSurfaceAngle;
    if (newAngle >= HALF_PI) {
      Point_default.copy(tmpProjPoint, pt2);
    } else {
      tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI / 2 - newAngle));
      const t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
      if (isNaN(t)) {
        return;
      }
      if (t < 0) {
        Point_default.copy(tmpProjPoint, pt1);
      } else if (t > 1) {
        Point_default.copy(tmpProjPoint, pt2);
      }
    }
    tmpProjPoint.toArray(linePoints[1]);
  }
}
function setLabelLineState(labelLine, ignore, stateName, stateModel) {
  const isNormal = stateName === "normal";
  const stateObj = isNormal ? labelLine : labelLine.ensureState(stateName);
  stateObj.ignore = ignore;
  let smooth = stateModel.get("smooth");
  if (smooth && smooth === true) {
    smooth = 0.3;
  }
  stateObj.shape = stateObj.shape || {};
  if (smooth > 0) {
    stateObj.shape.smooth = smooth;
  }
  const styleObj = stateModel.getModel("lineStyle").getLineStyle();
  isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj;
}
function buildLabelLinePath(path, shape) {
  const smooth = shape.smooth;
  const points4 = shape.points;
  if (!points4) {
    return;
  }
  path.moveTo(points4[0][0], points4[0][1]);
  if (smooth > 0 && points4.length >= 3) {
    const len1 = dist(points4[0], points4[1]);
    const len2 = dist(points4[1], points4[2]);
    if (!len1 || !len2) {
      path.lineTo(points4[1][0], points4[1][1]);
      path.lineTo(points4[2][0], points4[2][1]);
      return;
    }
    const moveLen = Math.min(len1, len2) * smooth;
    const midPoint0 = lerp([], points4[1], points4[0], moveLen / len1);
    const midPoint2 = lerp([], points4[1], points4[2], moveLen / len2);
    const midPoint1 = lerp([], midPoint0, midPoint2, 0.5);
    path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1]);
    path.bezierCurveTo(midPoint2[0], midPoint2[1], midPoint2[0], midPoint2[1], points4[2][0], points4[2][1]);
  } else {
    for (let i = 1; i < points4.length; i++) {
      path.lineTo(points4[i][0], points4[i][1]);
    }
  }
}
function setLabelLineStyle(targetEl, statesModels, defaultStyle) {
  let labelLine = targetEl.getTextGuideLine();
  const label = targetEl.getTextContent();
  if (!label) {
    if (labelLine) {
      targetEl.removeTextGuideLine();
    }
    return;
  }
  const normalModel = statesModels.normal;
  const showNormal = normalModel.get("show");
  const labelIgnoreNormal = label.ignore;
  for (let i = 0; i < DISPLAY_STATES.length; i++) {
    const stateName = DISPLAY_STATES[i];
    const stateModel = statesModels[stateName];
    const isNormal = stateName === "normal";
    if (stateModel) {
      const stateShow = stateModel.get("show");
      const isLabelIgnored = isNormal ? labelIgnoreNormal : retrieve2(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal);
      if (isLabelIgnored || !retrieve2(stateShow, showNormal)) {
        const stateObj = isNormal ? labelLine : labelLine && labelLine.states[stateName];
        if (stateObj) {
          stateObj.ignore = true;
        }
        if (!!labelLine) {
          setLabelLineState(labelLine, true, stateName, stateModel);
        }
        continue;
      }
      if (!labelLine) {
        labelLine = new Polyline_default();
        targetEl.setTextGuideLine(labelLine);
        if (!isNormal && (labelIgnoreNormal || !showNormal)) {
          setLabelLineState(labelLine, true, "normal", statesModels.normal);
        }
        if (targetEl.stateProxy) {
          labelLine.stateProxy = targetEl.stateProxy;
        }
      }
      setLabelLineState(labelLine, false, stateName, stateModel);
    }
  }
  if (labelLine) {
    defaults(labelLine.style, defaultStyle);
    labelLine.style.fill = null;
    const showAbove = normalModel.get("showAbove");
    const labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {};
    labelLineConfig.showAbove = showAbove || false;
    labelLine.buildPath = buildLabelLinePath;
  }
}
function getLabelLineStatesModels(itemModel, labelLineName) {
  labelLineName = labelLineName || "labelLine";
  const statesModels = {
    normal: itemModel.getModel(labelLineName)
  };
  for (let i = 0; i < SPECIAL_STATES.length; i++) {
    const stateName = SPECIAL_STATES[i];
    statesModels[stateName] = itemModel.getModel([stateName, labelLineName]);
  }
  return statesModels;
}

// src/label/labelLayoutHelper.ts
function prepareLayoutList(input) {
  const list = [];
  for (let i = 0; i < input.length; i++) {
    const rawItem = input[i];
    if (rawItem.defaultAttr.ignore) {
      continue;
    }
    const label = rawItem.label;
    const transform2 = label.getComputedTransform();
    const localRect = label.getBoundingRect();
    const isAxisAligned = !transform2 || transform2[1] < 1e-5 && transform2[2] < 1e-5;
    const minMargin = label.style.margin || 0;
    const globalRect = localRect.clone();
    globalRect.applyTransform(transform2);
    globalRect.x -= minMargin / 2;
    globalRect.y -= minMargin / 2;
    globalRect.width += minMargin;
    globalRect.height += minMargin;
    const obb = isAxisAligned ? new OrientedBoundingRect_default(localRect, transform2) : null;
    list.push({
      label,
      labelLine: rawItem.labelLine,
      rect: globalRect,
      localRect,
      obb,
      priority: rawItem.priority,
      defaultAttr: rawItem.defaultAttr,
      layoutOption: rawItem.computedLayoutOption,
      axisAligned: isAxisAligned,
      transform: transform2
    });
  }
  return list;
}
function shiftLayout(list, xyDim, sizeDim, minBound, maxBound, balanceShift) {
  const len2 = list.length;
  if (len2 < 2) {
    return;
  }
  list.sort(function(a, b) {
    return a.rect[xyDim] - b.rect[xyDim];
  });
  let lastPos = 0;
  let delta;
  let adjusted = false;
  const shifts = [];
  let totalShifts = 0;
  for (let i = 0; i < len2; i++) {
    const item = list[i];
    const rect = item.rect;
    delta = rect[xyDim] - lastPos;
    if (delta < 0) {
      rect[xyDim] -= delta;
      item.label[xyDim] -= delta;
      adjusted = true;
    }
    const shift = Math.max(-delta, 0);
    shifts.push(shift);
    totalShifts += shift;
    lastPos = rect[xyDim] + rect[sizeDim];
  }
  if (totalShifts > 0 && balanceShift) {
    shiftList(-totalShifts / len2, 0, len2);
  }
  const first = list[0];
  const last = list[len2 - 1];
  let minGap;
  let maxGap;
  updateMinMaxGap();
  minGap < 0 && squeezeGaps(-minGap, 0.8);
  maxGap < 0 && squeezeGaps(maxGap, 0.8);
  updateMinMaxGap();
  takeBoundsGap(minGap, maxGap, 1);
  takeBoundsGap(maxGap, minGap, -1);
  updateMinMaxGap();
  if (minGap < 0) {
    squeezeWhenBailout(-minGap);
  }
  if (maxGap < 0) {
    squeezeWhenBailout(maxGap);
  }
  function updateMinMaxGap() {
    minGap = first.rect[xyDim] - minBound;
    maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];
  }
  function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {
    if (gapThisBound < 0) {
      const moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);
      if (moveFromMaxGap > 0) {
        shiftList(moveFromMaxGap * moveDir, 0, len2);
        const remained = moveFromMaxGap + gapThisBound;
        if (remained < 0) {
          squeezeGaps(-remained * moveDir, 1);
        }
      } else {
        squeezeGaps(-gapThisBound * moveDir, 1);
      }
    }
  }
  function shiftList(delta2, start2, end2) {
    if (delta2 !== 0) {
      adjusted = true;
    }
    for (let i = start2; i < end2; i++) {
      const item = list[i];
      const rect = item.rect;
      rect[xyDim] += delta2;
      item.label[xyDim] += delta2;
    }
  }
  function squeezeGaps(delta2, maxSqeezePercent) {
    const gaps = [];
    let totalGaps = 0;
    for (let i = 1; i < len2; i++) {
      const prevItemRect = list[i - 1].rect;
      const gap = Math.max(list[i].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);
      gaps.push(gap);
      totalGaps += gap;
    }
    if (!totalGaps) {
      return;
    }
    const squeezePercent = Math.min(Math.abs(delta2) / totalGaps, maxSqeezePercent);
    if (delta2 > 0) {
      for (let i = 0; i < len2 - 1; i++) {
        const movement = gaps[i] * squeezePercent;
        shiftList(movement, 0, i + 1);
      }
    } else {
      for (let i = len2 - 1; i > 0; i--) {
        const movement = gaps[i - 1] * squeezePercent;
        shiftList(-movement, i, len2);
      }
    }
  }
  function squeezeWhenBailout(delta2) {
    const dir3 = delta2 < 0 ? -1 : 1;
    delta2 = Math.abs(delta2);
    const moveForEachLabel = Math.ceil(delta2 / (len2 - 1));
    for (let i = 0; i < len2 - 1; i++) {
      if (dir3 > 0) {
        shiftList(moveForEachLabel, 0, i + 1);
      } else {
        shiftList(-moveForEachLabel, len2 - i - 1, len2);
      }
      delta2 -= moveForEachLabel;
      if (delta2 <= 0) {
        return;
      }
    }
  }
  return adjusted;
}
function shiftLayoutOnX(list, leftBound, rightBound, balanceShift) {
  return shiftLayout(list, "x", "width", leftBound, rightBound, balanceShift);
}
function shiftLayoutOnY(list, topBound, bottomBound, balanceShift) {
  return shiftLayout(list, "y", "height", topBound, bottomBound, balanceShift);
}
function hideOverlap(labelList) {
  const displayedLabels = [];
  labelList.sort(function(a, b) {
    return b.priority - a.priority;
  });
  const globalRect = new BoundingRect_default(0, 0, 0, 0);
  function hideEl(el) {
    if (!el.ignore) {
      const emphasisState = el.ensureState("emphasis");
      if (emphasisState.ignore == null) {
        emphasisState.ignore = false;
      }
    }
    el.ignore = true;
  }
  for (let i = 0; i < labelList.length; i++) {
    const labelItem = labelList[i];
    const isAxisAligned = labelItem.axisAligned;
    const localRect = labelItem.localRect;
    const transform2 = labelItem.transform;
    const label = labelItem.label;
    const labelLine = labelItem.labelLine;
    globalRect.copy(labelItem.rect);
    globalRect.width -= 0.1;
    globalRect.height -= 0.1;
    globalRect.x += 0.05;
    globalRect.y += 0.05;
    let obb = labelItem.obb;
    let overlapped = false;
    for (let j = 0; j < displayedLabels.length; j++) {
      const existsTextCfg = displayedLabels[j];
      if (!globalRect.intersect(existsTextCfg.rect)) {
        continue;
      }
      if (isAxisAligned && existsTextCfg.axisAligned) {
        overlapped = true;
        break;
      }
      if (!existsTextCfg.obb) {
        existsTextCfg.obb = new OrientedBoundingRect_default(existsTextCfg.localRect, existsTextCfg.transform);
      }
      if (!obb) {
        obb = new OrientedBoundingRect_default(localRect, transform2);
      }
      if (obb.intersect(existsTextCfg.obb)) {
        overlapped = true;
        break;
      }
    }
    if (overlapped) {
      hideEl(label);
      labelLine && hideEl(labelLine);
    } else {
      label.attr("ignore", labelItem.defaultAttr.ignore);
      labelLine && labelLine.attr("ignore", labelItem.defaultAttr.labelGuideIgnore);
      displayedLabels.push(labelItem);
    }
  }
}

// src/label/LabelManager.ts
function cloneArr(points4) {
  if (points4) {
    const newPoints = [];
    for (let i = 0; i < points4.length; i++) {
      newPoints.push(points4[i].slice());
    }
    return newPoints;
  }
}
function prepareLayoutCallbackParams(labelItem, hostEl) {
  const label = labelItem.label;
  const labelLine = hostEl && hostEl.getTextGuideLine();
  return {
    dataIndex: labelItem.dataIndex,
    dataType: labelItem.dataType,
    seriesIndex: labelItem.seriesModel.seriesIndex,
    text: labelItem.label.style.text,
    rect: labelItem.hostRect,
    labelRect: labelItem.rect,
    align: label.style.align,
    verticalAlign: label.style.verticalAlign,
    labelLinePoints: cloneArr(labelLine && labelLine.shape.points)
  };
}
var LABEL_OPTION_TO_STYLE_KEYS = ["align", "verticalAlign", "width", "height", "fontSize"];
var dummyTransformable = new Transformable_default();
var labelLayoutInnerStore = makeInner();
var labelLineAnimationStore = makeInner();
function extendWithKeys(target, source, keys2) {
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    if (source[key] != null) {
      target[key] = source[key];
    }
  }
}
var LABEL_LAYOUT_PROPS = ["x", "y", "rotation"];
var LabelManager = class {
  constructor() {
    this._labelList = [];
    this._chartViewList = [];
  }
  clearLabels() {
    this._labelList = [];
    this._chartViewList = [];
  }
  _addLabel(dataIndex, dataType, seriesModel, label, layoutOption) {
    const labelStyle = label.style;
    const hostEl = label.__hostTarget;
    const textConfig = hostEl.textConfig || {};
    const labelTransform = label.getComputedTransform();
    const labelRect = label.getBoundingRect().plain();
    BoundingRect_default.applyTransform(labelRect, labelRect, labelTransform);
    if (labelTransform) {
      dummyTransformable.setLocalTransform(labelTransform);
    } else {
      dummyTransformable.x = dummyTransformable.y = dummyTransformable.rotation = dummyTransformable.originX = dummyTransformable.originY = 0;
      dummyTransformable.scaleX = dummyTransformable.scaleY = 1;
    }
    dummyTransformable.rotation = normalizeRadian(dummyTransformable.rotation);
    const host = label.__hostTarget;
    let hostRect;
    if (host) {
      hostRect = host.getBoundingRect().plain();
      const transform2 = host.getComputedTransform();
      BoundingRect_default.applyTransform(hostRect, hostRect, transform2);
    }
    const labelGuide = hostRect && host.getTextGuideLine();
    this._labelList.push({
      label,
      labelLine: labelGuide,
      seriesModel,
      dataIndex,
      dataType,
      layoutOption,
      computedLayoutOption: null,
      rect: labelRect,
      hostRect,
      priority: hostRect ? hostRect.width * hostRect.height : 0,
      defaultAttr: {
        ignore: label.ignore,
        labelGuideIgnore: labelGuide && labelGuide.ignore,
        x: dummyTransformable.x,
        y: dummyTransformable.y,
        scaleX: dummyTransformable.scaleX,
        scaleY: dummyTransformable.scaleY,
        rotation: dummyTransformable.rotation,
        style: {
          x: labelStyle.x,
          y: labelStyle.y,
          align: labelStyle.align,
          verticalAlign: labelStyle.verticalAlign,
          width: labelStyle.width,
          height: labelStyle.height,
          fontSize: labelStyle.fontSize
        },
        cursor: label.cursor,
        attachedPos: textConfig.position,
        attachedRot: textConfig.rotation
      }
    });
  }
  addLabelsOfSeries(chartView) {
    this._chartViewList.push(chartView);
    const seriesModel = chartView.__model;
    const layoutOption = seriesModel.get("labelLayout");
    if (!(isFunction(layoutOption) || keys(layoutOption).length)) {
      return;
    }
    chartView.group.traverse((child) => {
      if (child.ignore) {
        return true;
      }
      const textEl = child.getTextContent();
      const ecData = getECData(child);
      if (textEl && !textEl.disableLabelLayout) {
        this._addLabel(ecData.dataIndex, ecData.dataType, seriesModel, textEl, layoutOption);
      }
    });
  }
  updateLayoutConfig(api2) {
    const width = api2.getWidth();
    const height = api2.getHeight();
    function createDragHandler(el, labelLineModel) {
      return function() {
        updateLabelLinePoints(el, labelLineModel);
      };
    }
    for (let i = 0; i < this._labelList.length; i++) {
      const labelItem = this._labelList[i];
      const label = labelItem.label;
      const hostEl = label.__hostTarget;
      const defaultLabelAttr = labelItem.defaultAttr;
      let layoutOption;
      if (isFunction(labelItem.layoutOption)) {
        layoutOption = labelItem.layoutOption(prepareLayoutCallbackParams(labelItem, hostEl));
      } else {
        layoutOption = labelItem.layoutOption;
      }
      layoutOption = layoutOption || {};
      labelItem.computedLayoutOption = layoutOption;
      const degreeToRadian = Math.PI / 180;
      if (hostEl) {
        hostEl.setTextConfig({
          local: false,
          position: layoutOption.x != null || layoutOption.y != null ? null : defaultLabelAttr.attachedPos,
          rotation: layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.attachedRot,
          offset: [layoutOption.dx || 0, layoutOption.dy || 0]
        });
      }
      let needsUpdateLabelLine = false;
      if (layoutOption.x != null) {
        label.x = parsePercent2(layoutOption.x, width);
        label.setStyle("x", 0);
        needsUpdateLabelLine = true;
      } else {
        label.x = defaultLabelAttr.x;
        label.setStyle("x", defaultLabelAttr.style.x);
      }
      if (layoutOption.y != null) {
        label.y = parsePercent2(layoutOption.y, height);
        label.setStyle("y", 0);
        needsUpdateLabelLine = true;
      } else {
        label.y = defaultLabelAttr.y;
        label.setStyle("y", defaultLabelAttr.style.y);
      }
      if (layoutOption.labelLinePoints) {
        const guideLine = hostEl.getTextGuideLine();
        if (guideLine) {
          guideLine.setShape({points: layoutOption.labelLinePoints});
          needsUpdateLabelLine = false;
        }
      }
      const labelLayoutStore = labelLayoutInnerStore(label);
      labelLayoutStore.needsUpdateLabelLine = needsUpdateLabelLine;
      label.rotation = layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.rotation;
      label.scaleX = defaultLabelAttr.scaleX;
      label.scaleY = defaultLabelAttr.scaleY;
      for (let k = 0; k < LABEL_OPTION_TO_STYLE_KEYS.length; k++) {
        const key = LABEL_OPTION_TO_STYLE_KEYS[k];
        label.setStyle(key, layoutOption[key] != null ? layoutOption[key] : defaultLabelAttr.style[key]);
      }
      if (layoutOption.draggable) {
        label.draggable = true;
        label.cursor = "move";
        if (hostEl) {
          let hostModel = labelItem.seriesModel;
          if (labelItem.dataIndex != null) {
            const data = labelItem.seriesModel.getData(labelItem.dataType);
            hostModel = data.getItemModel(labelItem.dataIndex);
          }
          label.on("drag", createDragHandler(hostEl, hostModel.getModel("labelLine")));
        }
      } else {
        label.off("drag");
        label.cursor = defaultLabelAttr.cursor;
      }
    }
  }
  layout(api2) {
    const width = api2.getWidth();
    const height = api2.getHeight();
    const labelList = prepareLayoutList(this._labelList);
    const labelsNeedsAdjustOnX = filter(labelList, function(item) {
      return item.layoutOption.moveOverlap === "shiftX";
    });
    const labelsNeedsAdjustOnY = filter(labelList, function(item) {
      return item.layoutOption.moveOverlap === "shiftY";
    });
    shiftLayoutOnX(labelsNeedsAdjustOnX, 0, width);
    shiftLayoutOnY(labelsNeedsAdjustOnY, 0, height);
    const labelsNeedsHideOverlap = filter(labelList, function(item) {
      return item.layoutOption.hideOverlap;
    });
    hideOverlap(labelsNeedsHideOverlap);
  }
  processLabelsOverall() {
    each(this._chartViewList, (chartView) => {
      const seriesModel = chartView.__model;
      const ignoreLabelLineUpdate = chartView.ignoreLabelLineUpdate;
      const animationEnabled = seriesModel.isAnimationEnabled();
      chartView.group.traverse((child) => {
        if (child.ignore && !child.forceLabelAnimation) {
          return true;
        }
        let needsUpdateLabelLine = !ignoreLabelLineUpdate;
        const label = child.getTextContent();
        if (!needsUpdateLabelLine && label) {
          needsUpdateLabelLine = labelLayoutInnerStore(label).needsUpdateLabelLine;
        }
        if (needsUpdateLabelLine) {
          this._updateLabelLine(child, seriesModel);
        }
        if (animationEnabled) {
          this._animateLabels(child, seriesModel);
        }
      });
    });
  }
  _updateLabelLine(el, seriesModel) {
    const textEl = el.getTextContent();
    const ecData = getECData(el);
    const dataIndex = ecData.dataIndex;
    if (textEl && dataIndex != null) {
      const data = seriesModel.getData(ecData.dataType);
      const itemModel = data.getItemModel(dataIndex);
      const defaultStyle = {};
      const visualStyle = data.getItemVisual(dataIndex, "style");
      if (visualStyle) {
        const visualType = data.getVisual("drawType");
        defaultStyle.stroke = visualStyle[visualType];
      }
      const labelLineModel = itemModel.getModel("labelLine");
      setLabelLineStyle(el, getLabelLineStatesModels(itemModel), defaultStyle);
      updateLabelLinePoints(el, labelLineModel);
    }
  }
  _animateLabels(el, seriesModel) {
    const textEl = el.getTextContent();
    const guideLine = el.getTextGuideLine();
    if (textEl && (el.forceLabelAnimation || !textEl.ignore && !textEl.invisible && !el.disableLabelAnimation && !isElementRemoved(el))) {
      const layoutStore = labelLayoutInnerStore(textEl);
      const oldLayout = layoutStore.oldLayout;
      const ecData = getECData(el);
      const dataIndex = ecData.dataIndex;
      const newProps = {
        x: textEl.x,
        y: textEl.y,
        rotation: textEl.rotation
      };
      const data = seriesModel.getData(ecData.dataType);
      if (!oldLayout) {
        textEl.attr(newProps);
        if (!labelInner(textEl).valueAnimation) {
          const oldOpacity = retrieve2(textEl.style.opacity, 1);
          textEl.style.opacity = 0;
          initProps(textEl, {
            style: {opacity: oldOpacity}
          }, seriesModel, dataIndex);
        }
      } else {
        textEl.attr(oldLayout);
        const prevStates = el.prevStates;
        if (prevStates) {
          if (indexOf(prevStates, "select") >= 0) {
            textEl.attr(layoutStore.oldLayoutSelect);
          }
          if (indexOf(prevStates, "emphasis") >= 0) {
            textEl.attr(layoutStore.oldLayoutEmphasis);
          }
        }
        updateProps(textEl, newProps, seriesModel, dataIndex);
      }
      layoutStore.oldLayout = newProps;
      if (textEl.states.select) {
        const layoutSelect = layoutStore.oldLayoutSelect = {};
        extendWithKeys(layoutSelect, newProps, LABEL_LAYOUT_PROPS);
        extendWithKeys(layoutSelect, textEl.states.select, LABEL_LAYOUT_PROPS);
      }
      if (textEl.states.emphasis) {
        const layoutEmphasis = layoutStore.oldLayoutEmphasis = {};
        extendWithKeys(layoutEmphasis, newProps, LABEL_LAYOUT_PROPS);
        extendWithKeys(layoutEmphasis, textEl.states.emphasis, LABEL_LAYOUT_PROPS);
      }
      animateLabelValue(textEl, dataIndex, data, seriesModel, seriesModel);
    }
    if (guideLine && !guideLine.ignore && !guideLine.invisible) {
      const layoutStore = labelLineAnimationStore(guideLine);
      const oldLayout = layoutStore.oldLayout;
      const newLayout = {points: guideLine.shape.points};
      if (!oldLayout) {
        guideLine.setShape(newLayout);
        guideLine.style.strokePercent = 0;
        initProps(guideLine, {
          style: {strokePercent: 1}
        }, seriesModel);
      } else {
        guideLine.attr({shape: oldLayout});
        updateProps(guideLine, {
          shape: newLayout
        }, seriesModel);
      }
      layoutStore.oldLayout = newLayout;
    }
  }
};
var LabelManager_default = LabelManager;

// src/label/installLabelLayout.ts
var getLabelManager = makeInner();
function installLabelLayout(registers) {
  registers.registerUpdateLifecycle("series:beforeupdate", (ecModel, api2, params) => {
    let labelManager = getLabelManager(api2).labelManager;
    if (!labelManager) {
      labelManager = getLabelManager(api2).labelManager = new LabelManager_default();
    }
    labelManager.clearLabels();
  });
  registers.registerUpdateLifecycle("series:layoutlabels", (ecModel, api2, params) => {
    const labelManager = getLabelManager(api2).labelManager;
    params.updatedSeries.forEach((series) => {
      labelManager.addLabelsOfSeries(api2.getViewOfSeriesModel(series));
    });
    labelManager.updateLayoutConfig(api2);
    labelManager.layout(api2);
    labelManager.processLabelsOverall();
  });
}

// node_modules/zrender/src/svg/SVGPathRebuilder.ts
var mathSin5 = Math.sin;
var mathCos5 = Math.cos;
var PI6 = Math.PI;
var PI28 = Math.PI * 2;
var degree = 180 / PI6;
var SVGPathRebuilder = class {
  reset(precision) {
    this._start = true;
    this._d = [];
    this._str = "";
    this._p = Math.pow(10, precision || 4);
  }
  moveTo(x, y) {
    this._add("M", x, y);
  }
  lineTo(x, y) {
    this._add("L", x, y);
  }
  bezierCurveTo(x, y, x2, y2, x3, y3) {
    this._add("C", x, y, x2, y2, x3, y3);
  }
  quadraticCurveTo(x, y, x2, y2) {
    this._add("Q", x, y, x2, y2);
  }
  arc(cx, cy, r, startAngle, endAngle, anticlockwise) {
    this.ellipse(cx, cy, r, r, 0, startAngle, endAngle, anticlockwise);
  }
  ellipse(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise) {
    let dTheta = endAngle - startAngle;
    const clockwise = !anticlockwise;
    const dThetaPositive = Math.abs(dTheta);
    const isCircle = isAroundZero2(dThetaPositive - PI28) || (clockwise ? dTheta >= PI28 : -dTheta >= PI28);
    const unifiedTheta = dTheta > 0 ? dTheta % PI28 : dTheta % PI28 + PI28;
    let large = false;
    if (isCircle) {
      large = true;
    } else if (isAroundZero2(dThetaPositive)) {
      large = false;
    } else {
      large = unifiedTheta >= PI6 === !!clockwise;
    }
    const x0 = cx + rx * mathCos5(startAngle);
    const y0 = cy + ry * mathSin5(startAngle);
    if (this._start) {
      this._add("M", x0, y0);
    }
    const xRot = Math.round(psi * degree);
    if (isCircle) {
      const p = 1 / this._p;
      const dTheta2 = (clockwise ? 1 : -1) * (PI28 - p);
      this._add("A", rx, ry, xRot, 1, +clockwise, cx + rx * mathCos5(startAngle + dTheta2), cy + ry * mathSin5(startAngle + dTheta2));
      if (p > 0.01) {
        this._add("A", rx, ry, xRot, 0, +clockwise, x0, y0);
      }
    } else {
      const x = cx + rx * mathCos5(endAngle);
      const y = cy + ry * mathSin5(endAngle);
      this._add("A", rx, ry, xRot, +large, +clockwise, x, y);
    }
  }
  rect(x, y, w, h) {
    this._add("M", x, y);
    this._add("l", w, 0);
    this._add("l", 0, h);
    this._add("l", -w, 0);
    this._add("Z");
  }
  closePath() {
    if (this._d.length > 0) {
      this._add("Z");
    }
  }
  _add(cmd, a, b, c, d, e2, f, g, h) {
    const vals = [];
    const p = this._p;
    for (let i = 1; i < arguments.length; i++) {
      const val = arguments[i];
      if (isNaN(val)) {
        this._invalid = true;
        return;
      }
      vals.push(Math.round(val * p) / p);
    }
    this._d.push(cmd + vals.join(" "));
    this._start = cmd === "Z";
  }
  generateStr() {
    this._str = this._invalid ? "" : this._d.join("");
    this._d = [];
  }
  getStr() {
    return this._str;
  }
};
var SVGPathRebuilder_default = SVGPathRebuilder;

// node_modules/zrender/src/svg/mapStyleToAttrs.ts
var NONE = "none";
var mathRound2 = Math.round;
function pathHasFill(style) {
  const fill = style.fill;
  return fill != null && fill !== NONE;
}
function pathHasStroke(style) {
  const stroke = style.stroke;
  return stroke != null && stroke !== NONE;
}
var strokeProps = ["lineCap", "miterLimit", "lineJoin"];
var svgStrokeProps = map(strokeProps, (prop) => `stroke-${prop.toLowerCase()}`);
function mapStyleToAttrs(updateAttr2, style, el, forceUpdate) {
  const opacity = style.opacity == null ? 1 : style.opacity;
  if (el instanceof Image_default) {
    updateAttr2("opacity", opacity);
    return;
  }
  if (pathHasFill(style)) {
    const fill = normalizeColor(style.fill);
    updateAttr2("fill", fill.color);
    const fillOpacity = style.fillOpacity != null ? style.fillOpacity * fill.opacity * opacity : fill.opacity * opacity;
    if (forceUpdate || fillOpacity < 1) {
      updateAttr2("fill-opacity", fillOpacity);
    }
  } else {
    updateAttr2("fill", NONE);
  }
  if (pathHasStroke(style)) {
    const stroke = normalizeColor(style.stroke);
    updateAttr2("stroke", stroke.color);
    const strokeScale = style.strokeNoScale ? el.getLineScale() : 1;
    const strokeWidth = strokeScale ? (style.lineWidth || 0) / strokeScale : 0;
    const strokeOpacity = style.strokeOpacity != null ? style.strokeOpacity * stroke.opacity * opacity : stroke.opacity * opacity;
    const strokeFirst = style.strokeFirst;
    if (forceUpdate || strokeWidth !== 1) {
      updateAttr2("stroke-width", strokeWidth);
    }
    if (forceUpdate || strokeFirst) {
      updateAttr2("paint-order", strokeFirst ? "stroke" : "fill");
    }
    if (forceUpdate || strokeOpacity < 1) {
      updateAttr2("stroke-opacity", strokeOpacity);
    }
    if (style.lineDash) {
      let [lineDash, lineDashOffset] = getLineDash(el);
      if (lineDash) {
        lineDashOffset = mathRound2(lineDashOffset || 0);
        updateAttr2("stroke-dasharray", lineDash.join(","));
        if (lineDashOffset || forceUpdate) {
          updateAttr2("stroke-dashoffset", lineDashOffset);
        }
      }
    } else if (forceUpdate) {
      updateAttr2("stroke-dasharray", NONE);
    }
    for (let i = 0; i < strokeProps.length; i++) {
      const propName = strokeProps[i];
      if (forceUpdate || style[propName] !== DEFAULT_PATH_STYLE[propName]) {
        const val = style[propName] || DEFAULT_PATH_STYLE[propName];
        val && updateAttr2(svgStrokeProps[i], val);
      }
    }
  } else if (forceUpdate) {
    updateAttr2("stroke", NONE);
  }
}

// node_modules/zrender/src/svg/core.ts
var SVGNS = "http://www.w3.org/2000/svg";
var XLINKNS = "http://www.w3.org/1999/xlink";
var XMLNS = "http://www.w3.org/2000/xmlns/";
var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
var META_DATA_PREFIX = "ecmeta_";
function createElement(name) {
  return document.createElementNS(SVGNS, name);
}
function createVNode(tag, key, attrs, children, text) {
  return {
    tag,
    attrs: attrs || {},
    children,
    text,
    key
  };
}
function createElementOpen(name, attrs) {
  const attrsStr = [];
  if (attrs) {
    for (let key in attrs) {
      const val = attrs[key];
      let part = key;
      if (val === false) {
        continue;
      } else if (val !== true && val != null) {
        part += `="${val}"`;
      }
      attrsStr.push(part);
    }
  }
  return `<${name} ${attrsStr.join(" ")}>`;
}
function createElementClose(name) {
  return `</${name}>`;
}
function vNodeToString(el, opts) {
  opts = opts || {};
  const S = opts.newline ? "\n" : "";
  function convertElToString(el2) {
    const {children, tag, attrs, text} = el2;
    return createElementOpen(tag, attrs) + (tag !== "style" ? encodeHTML(text) : text || "") + (children ? `${S}${map(children, (child) => convertElToString(child)).join(S)}${S}` : "") + createElementClose(tag);
  }
  return convertElToString(el);
}
function getCssString(selectorNodes, animationNodes, opts) {
  opts = opts || {};
  const S = opts.newline ? "\n" : "";
  const bracketBegin = ` {${S}`;
  const bracketEnd = `${S}}`;
  const selectors = map(keys(selectorNodes), (className) => {
    return className + bracketBegin + map(keys(selectorNodes[className]), (attrName) => {
      return `${attrName}:${selectorNodes[className][attrName]};`;
    }).join(S) + bracketEnd;
  }).join(S);
  const animations = map(keys(animationNodes), (animationName) => {
    return `@keyframes ${animationName}${bracketBegin}` + map(keys(animationNodes[animationName]), (percent) => {
      return percent + bracketBegin + map(keys(animationNodes[animationName][percent]), (attrName) => {
        let val = animationNodes[animationName][percent][attrName];
        if (attrName === "d") {
          val = `path("${val}")`;
        }
        return `${attrName}:${val};`;
      }).join(S) + bracketEnd;
    }).join(S) + bracketEnd;
  }).join(S);
  if (!selectors && !animations) {
    return "";
  }
  return ["<![CDATA[", selectors, animations, "]]>"].join(S);
}
function createBrushScope(zrId) {
  return {
    zrId,
    shadowCache: {},
    patternCache: {},
    gradientCache: {},
    clipPathCache: {},
    defs: {},
    cssNodes: {},
    cssAnims: {},
    cssStyleCache: {},
    cssAnimIdx: 0,
    shadowIdx: 0,
    gradientIdx: 0,
    patternIdx: 0,
    clipPathIdx: 0
  };
}
function createSVGVNode(width, height, children, useViewBox) {
  return createVNode("svg", "root", {
    width,
    height,
    xmlns: SVGNS,
    "xmlns:xlink": XLINKNS,
    version: "1.1",
    baseProfile: "full",
    viewBox: useViewBox ? `0 0 ${width} ${height}` : false
  }, children);
}

// node_modules/zrender/src/svg/cssClassId.ts
var cssClassIdx = 0;
function getClassId() {
  return cssClassIdx++;
}

// node_modules/zrender/src/svg/cssAnimation.ts
var EASING_MAP = {
  cubicIn: "0.32,0,0.67,0",
  cubicOut: "0.33,1,0.68,1",
  cubicInOut: "0.65,0,0.35,1",
  quadraticIn: "0.11,0,0.5,0",
  quadraticOut: "0.5,1,0.89,1",
  quadraticInOut: "0.45,0,0.55,1",
  quarticIn: "0.5,0,0.75,0",
  quarticOut: "0.25,1,0.5,1",
  quarticInOut: "0.76,0,0.24,1",
  quinticIn: "0.64,0,0.78,0",
  quinticOut: "0.22,1,0.36,1",
  quinticInOut: "0.83,0,0.17,1",
  sinusoidalIn: "0.12,0,0.39,0",
  sinusoidalOut: "0.61,1,0.88,1",
  sinusoidalInOut: "0.37,0,0.63,1",
  exponentialIn: "0.7,0,0.84,0",
  exponentialOut: "0.16,1,0.3,1",
  exponentialInOut: "0.87,0,0.13,1",
  circularIn: "0.55,0,1,0.45",
  circularOut: "0,0.55,0.45,1",
  circularInOut: "0.85,0,0.15,1"
};
var transformOriginKey = "transform-origin";
function buildPathString(el, kfShape, path) {
  const shape = extend({}, el.shape);
  extend(shape, kfShape);
  el.buildPath(path, shape);
  const svgPathBuilder = new SVGPathRebuilder_default();
  svgPathBuilder.reset(getPathPrecision(el));
  path.rebuildPath(svgPathBuilder, 1);
  svgPathBuilder.generateStr();
  return svgPathBuilder.getStr();
}
function setTransformOrigin(target, transform2) {
  const {originX, originY} = transform2;
  if (originX || originY) {
    target[transformOriginKey] = `${originX}px ${originY}px`;
  }
}
var ANIMATE_STYLE_MAP = {
  fill: "fill",
  opacity: "opacity",
  lineWidth: "stroke-width",
  lineDashOffset: "stroke-dashoffset"
};
function addAnimation(cssAnim, scope) {
  const animationName = scope.zrId + "-ani-" + scope.cssAnimIdx++;
  scope.cssAnims[animationName] = cssAnim;
  return animationName;
}
function createCompoundPathCSSAnimation(el, attrs, scope) {
  const paths = el.shape.paths;
  const composedAnim = {};
  let cssAnimationCfg;
  let cssAnimationName;
  each(paths, (path) => {
    const subScope = createBrushScope(scope.zrId);
    subScope.animation = true;
    createCSSAnimation(path, {}, subScope, true);
    const cssAnims = subScope.cssAnims;
    const cssNodes = subScope.cssNodes;
    const animNames = keys(cssAnims);
    const len2 = animNames.length;
    if (!len2) {
      return;
    }
    cssAnimationName = animNames[len2 - 1];
    const lastAnim = cssAnims[cssAnimationName];
    for (let percent in lastAnim) {
      const kf = lastAnim[percent];
      composedAnim[percent] = composedAnim[percent] || {d: ""};
      composedAnim[percent].d += kf.d || "";
    }
    for (let className in cssNodes) {
      const val = cssNodes[className].animation;
      if (val.indexOf(cssAnimationName) >= 0) {
        cssAnimationCfg = val;
      }
    }
  });
  if (!cssAnimationCfg) {
    return;
  }
  attrs.d = false;
  const animationName = addAnimation(composedAnim, scope);
  return cssAnimationCfg.replace(cssAnimationName, animationName);
}
function getEasingFunc(easing) {
  return isString(easing) ? EASING_MAP[easing] ? `cubic-bezier(${EASING_MAP[easing]})` : createCubicEasingFunc(easing) ? easing : "" : "";
}
function createCSSAnimation(el, attrs, scope, onlyShape) {
  const animators = el.animators;
  const len2 = animators.length;
  const cssAnimations = [];
  if (el instanceof CompoundPath_default) {
    const animationCfg = createCompoundPathCSSAnimation(el, attrs, scope);
    if (animationCfg) {
      cssAnimations.push(animationCfg);
    } else if (!len2) {
      return;
    }
  } else if (!len2) {
    return;
  }
  const groupAnimators = {};
  for (let i = 0; i < len2; i++) {
    const animator = animators[i];
    const cfgArr = [animator.getMaxTime() / 1e3 + "s"];
    const easing = getEasingFunc(animator.getClip().easing);
    const delay = animator.getDelay();
    if (easing) {
      cfgArr.push(easing);
    } else {
      cfgArr.push("linear");
    }
    if (delay) {
      cfgArr.push(delay / 1e3 + "s");
    }
    if (animator.getLoop()) {
      cfgArr.push("infinite");
    }
    const cfg = cfgArr.join(" ");
    groupAnimators[cfg] = groupAnimators[cfg] || [cfg, []];
    groupAnimators[cfg][1].push(animator);
  }
  function createSingleCSSAnimation(groupAnimator) {
    const animators2 = groupAnimator[1];
    const len3 = animators2.length;
    const transformKfs = {};
    const shapeKfs = {};
    const finalKfs = {};
    const animationTimingFunctionAttrName = "animation-timing-function";
    function saveAnimatorTrackToCssKfs(animator, cssKfs, toCssAttrName) {
      const tracks = animator.getTracks();
      const maxTime = animator.getMaxTime();
      for (let k = 0; k < tracks.length; k++) {
        const track = tracks[k];
        if (track.needsAnimate()) {
          const kfs = track.keyframes;
          let attrName = track.propName;
          toCssAttrName && (attrName = toCssAttrName(attrName));
          if (attrName) {
            for (let i = 0; i < kfs.length; i++) {
              const kf = kfs[i];
              const percent = Math.round(kf.time / maxTime * 100) + "%";
              const kfEasing = getEasingFunc(kf.easing);
              const rawValue = kf.rawValue;
              if (isString(rawValue) || isNumber(rawValue)) {
                cssKfs[percent] = cssKfs[percent] || {};
                cssKfs[percent][attrName] = kf.rawValue;
                if (kfEasing) {
                  cssKfs[percent][animationTimingFunctionAttrName] = kfEasing;
                }
              }
            }
          }
        }
      }
    }
    for (let i = 0; i < len3; i++) {
      const animator = animators2[i];
      const targetProp = animator.targetName;
      if (!targetProp) {
        !onlyShape && saveAnimatorTrackToCssKfs(animator, transformKfs);
      } else if (targetProp === "shape") {
        saveAnimatorTrackToCssKfs(animator, shapeKfs);
      }
    }
    for (let percent in transformKfs) {
      const transform2 = {};
      copyTransform(transform2, el);
      extend(transform2, transformKfs[percent]);
      const str = getSRTTransformString(transform2);
      const timingFunction = transformKfs[percent][animationTimingFunctionAttrName];
      finalKfs[percent] = str ? {
        transform: str
      } : {};
      setTransformOrigin(finalKfs[percent], transform2);
      if (timingFunction) {
        finalKfs[percent][animationTimingFunctionAttrName] = timingFunction;
      }
    }
    ;
    let path;
    let canAnimateShape = true;
    for (let percent in shapeKfs) {
      finalKfs[percent] = finalKfs[percent] || {};
      const isFirst = !path;
      const timingFunction = shapeKfs[percent][animationTimingFunctionAttrName];
      if (isFirst) {
        path = new PathProxy_default();
      }
      let len4 = path.len();
      path.reset();
      finalKfs[percent].d = buildPathString(el, shapeKfs[percent], path);
      let newLen = path.len();
      if (!isFirst && len4 !== newLen) {
        canAnimateShape = false;
        break;
      }
      if (timingFunction) {
        finalKfs[percent][animationTimingFunctionAttrName] = timingFunction;
      }
    }
    ;
    if (!canAnimateShape) {
      for (let percent in finalKfs) {
        delete finalKfs[percent].d;
      }
    }
    if (!onlyShape) {
      for (let i = 0; i < len3; i++) {
        const animator = animators2[i];
        const targetProp = animator.targetName;
        if (targetProp === "style") {
          saveAnimatorTrackToCssKfs(animator, finalKfs, (propName) => ANIMATE_STYLE_MAP[propName]);
        }
      }
    }
    const percents = keys(finalKfs);
    let allTransformOriginSame = true;
    let transformOrigin;
    for (let i = 1; i < percents.length; i++) {
      const p0 = percents[i - 1];
      const p1 = percents[i];
      if (finalKfs[p0][transformOriginKey] !== finalKfs[p1][transformOriginKey]) {
        allTransformOriginSame = false;
        break;
      }
      transformOrigin = finalKfs[p0][transformOriginKey];
    }
    if (allTransformOriginSame && transformOrigin) {
      for (const percent in finalKfs) {
        if (finalKfs[percent][transformOriginKey]) {
          delete finalKfs[percent][transformOriginKey];
        }
      }
      attrs[transformOriginKey] = transformOrigin;
    }
    if (filter(percents, (percent) => keys(finalKfs[percent]).length > 0).length) {
      const animationName = addAnimation(finalKfs, scope);
      return `${animationName} ${groupAnimator[0]} both`;
    }
  }
  for (let key in groupAnimators) {
    const animationCfg = createSingleCSSAnimation(groupAnimators[key]);
    if (animationCfg) {
      cssAnimations.push(animationCfg);
    }
  }
  if (cssAnimations.length) {
    const className = scope.zrId + "-cls-" + getClassId();
    scope.cssNodes["." + className] = {
      animation: cssAnimations.join(",")
    };
    attrs.class = className;
  }
}

// node_modules/zrender/src/svg/cssEmphasis.ts
function createCSSEmphasis(el, attrs, scope) {
  if (!el.ignore) {
    if (el.isSilent()) {
      const style = {
        "pointer-events": "none"
      };
      setClassAttribute(style, attrs, scope, true);
    } else {
      const emphasisStyle = el.states.emphasis && el.states.emphasis.style ? el.states.emphasis.style : {};
      let fill = emphasisStyle.fill;
      if (!fill) {
        const normalFill = el.style && el.style.fill;
        const selectFill = el.states.select && el.states.select.style && el.states.select.style.fill;
        const fromFill = el.currentStates.indexOf("select") >= 0 ? selectFill || normalFill : normalFill;
        if (fromFill) {
          fill = liftColor(fromFill);
        }
      }
      let lineWidth = emphasisStyle.lineWidth;
      if (lineWidth) {
        const scaleX = !emphasisStyle.strokeNoScale && el.transform ? el.transform[0] : 1;
        lineWidth = lineWidth / scaleX;
      }
      const style = {
        cursor: "pointer"
      };
      if (fill) {
        style.fill = fill;
      }
      if (emphasisStyle.stroke) {
        style.stroke = emphasisStyle.stroke;
      }
      if (lineWidth) {
        style["stroke-width"] = lineWidth;
      }
      setClassAttribute(style, attrs, scope, true);
    }
  }
}
function setClassAttribute(style, attrs, scope, withHover) {
  const styleKey = JSON.stringify(style);
  let className = scope.cssStyleCache[styleKey];
  if (!className) {
    className = scope.zrId + "-cls-" + getClassId();
    scope.cssStyleCache[styleKey] = className;
    scope.cssNodes["." + className + (withHover ? ":hover" : "")] = style;
  }
  attrs.class = attrs.class ? attrs.class + " " + className : className;
}

// node_modules/zrender/src/svg/graphic.ts
var round5 = Math.round;
function isImageLike2(val) {
  return val && isString(val.src);
}
function isCanvasLike(val) {
  return val && isFunction(val.toDataURL);
}
function setStyleAttrs(attrs, style, el, scope) {
  mapStyleToAttrs((key, val) => {
    const isFillStroke = key === "fill" || key === "stroke";
    if (isFillStroke && isGradient(val)) {
      setGradient(style, attrs, key, scope);
    } else if (isFillStroke && isPattern(val)) {
      setPattern(el, attrs, key, scope);
    } else if (isFillStroke && val === "none") {
      attrs[key] = "transparent";
    } else {
      attrs[key] = val;
    }
  }, style, el, false);
  setShadow(el, attrs, scope);
}
function setMetaData(attrs, el) {
  const metaData = getElementSSRData(el);
  if (metaData) {
    metaData.each((val, key) => {
      val != null && (attrs[(META_DATA_PREFIX + key).toLowerCase()] = val + "");
    });
    if (el.isSilent()) {
      attrs[META_DATA_PREFIX + "silent"] = "true";
    }
  }
}
function noRotateScale(m2) {
  return isAroundZero2(m2[0] - 1) && isAroundZero2(m2[1]) && isAroundZero2(m2[2]) && isAroundZero2(m2[3] - 1);
}
function noTranslate(m2) {
  return isAroundZero2(m2[4]) && isAroundZero2(m2[5]);
}
function setTransform(attrs, m2, compress) {
  if (m2 && !(noTranslate(m2) && noRotateScale(m2))) {
    const mul3 = compress ? 10 : 1e4;
    attrs.transform = noRotateScale(m2) ? `translate(${round5(m2[4] * mul3) / mul3} ${round5(m2[5] * mul3) / mul3})` : getMatrixStr(m2);
  }
}
function convertPolyShape(shape, attrs, mul3) {
  const points4 = shape.points;
  const strArr = [];
  for (let i = 0; i < points4.length; i++) {
    strArr.push(round5(points4[i][0] * mul3) / mul3);
    strArr.push(round5(points4[i][1] * mul3) / mul3);
  }
  attrs.points = strArr.join(" ");
}
function validatePolyShape(shape) {
  return !shape.smooth;
}
function createAttrsConvert(desc) {
  const normalizedDesc = map(desc, (item) => typeof item === "string" ? [item, item] : item);
  return function(shape, attrs, mul3) {
    for (let i = 0; i < normalizedDesc.length; i++) {
      const item = normalizedDesc[i];
      const val = shape[item[0]];
      if (val != null) {
        attrs[item[1]] = round5(val * mul3) / mul3;
      }
    }
  };
}
var builtinShapesDef = {
  circle: [createAttrsConvert(["cx", "cy", "r"])],
  polyline: [convertPolyShape, validatePolyShape],
  polygon: [convertPolyShape, validatePolyShape]
};
function hasShapeAnimation(el) {
  const animators = el.animators;
  for (let i = 0; i < animators.length; i++) {
    if (animators[i].targetName === "shape") {
      return true;
    }
  }
  return false;
}
function brushSVGPath(el, scope) {
  const style = el.style;
  const shape = el.shape;
  const builtinShpDef = builtinShapesDef[el.type];
  const attrs = {};
  const needsAnimate = scope.animation;
  let svgElType = "path";
  const strokePercent = el.style.strokePercent;
  const precision = scope.compress && getPathPrecision(el) || 4;
  if (builtinShpDef && !scope.willUpdate && !(builtinShpDef[1] && !builtinShpDef[1](shape)) && !(needsAnimate && hasShapeAnimation(el)) && !(strokePercent < 1)) {
    svgElType = el.type;
    const mul3 = Math.pow(10, precision);
    builtinShpDef[0](shape, attrs, mul3);
  } else {
    const needBuildPath = !el.path || el.shapeChanged();
    if (!el.path) {
      el.createPathProxy();
    }
    const path = el.path;
    if (needBuildPath) {
      path.beginPath();
      el.buildPath(path, el.shape);
      el.pathUpdated();
    }
    const pathVersion = path.getVersion();
    const elExt = el;
    let svgPathBuilder = elExt.__svgPathBuilder;
    if (elExt.__svgPathVersion !== pathVersion || !svgPathBuilder || strokePercent !== elExt.__svgPathStrokePercent) {
      if (!svgPathBuilder) {
        svgPathBuilder = elExt.__svgPathBuilder = new SVGPathRebuilder_default();
      }
      svgPathBuilder.reset(precision);
      path.rebuildPath(svgPathBuilder, strokePercent);
      svgPathBuilder.generateStr();
      elExt.__svgPathVersion = pathVersion;
      elExt.__svgPathStrokePercent = strokePercent;
    }
    attrs.d = svgPathBuilder.getStr();
  }
  setTransform(attrs, el.transform);
  setStyleAttrs(attrs, style, el, scope);
  setMetaData(attrs, el);
  scope.animation && createCSSAnimation(el, attrs, scope);
  scope.emphasis && createCSSEmphasis(el, attrs, scope);
  return createVNode(svgElType, el.id + "", attrs);
}
function brushSVGImage(el, scope) {
  const style = el.style;
  let image = style.image;
  if (image && !isString(image)) {
    if (isImageLike2(image)) {
      image = image.src;
    } else if (isCanvasLike(image)) {
      image = image.toDataURL();
    }
  }
  if (!image) {
    return;
  }
  const x = style.x || 0;
  const y = style.y || 0;
  const dw = style.width;
  const dh = style.height;
  const attrs = {
    href: image,
    width: dw,
    height: dh
  };
  if (x) {
    attrs.x = x;
  }
  if (y) {
    attrs.y = y;
  }
  setTransform(attrs, el.transform);
  setStyleAttrs(attrs, style, el, scope);
  setMetaData(attrs, el);
  scope.animation && createCSSAnimation(el, attrs, scope);
  return createVNode("image", el.id + "", attrs);
}
function brushSVGTSpan(el, scope) {
  const style = el.style;
  let text = style.text;
  text != null && (text += "");
  if (!text || isNaN(style.x) || isNaN(style.y)) {
    return;
  }
  const font = style.font || DEFAULT_FONT;
  const x = style.x || 0;
  const y = adjustTextY(style.y || 0, getLineHeight(font), style.textBaseline);
  const textAlign = TEXT_ALIGN_TO_ANCHOR[style.textAlign] || style.textAlign;
  const attrs = {
    "dominant-baseline": "central",
    "text-anchor": textAlign
  };
  if (hasSeparateFont(style)) {
    let separatedFontStr = "";
    const fontStyle = style.fontStyle;
    const fontSize = parseFontSize(style.fontSize);
    if (!parseFloat(fontSize)) {
      return;
    }
    const fontFamily = style.fontFamily || DEFAULT_FONT_FAMILY;
    const fontWeight = style.fontWeight;
    separatedFontStr += `font-size:${fontSize};font-family:${fontFamily};`;
    if (fontStyle && fontStyle !== "normal") {
      separatedFontStr += `font-style:${fontStyle};`;
    }
    if (fontWeight && fontWeight !== "normal") {
      separatedFontStr += `font-weight:${fontWeight};`;
    }
    attrs.style = separatedFontStr;
  } else {
    attrs.style = `font: ${font}`;
  }
  if (text.match(/\s/)) {
    attrs["xml:space"] = "preserve";
  }
  if (x) {
    attrs.x = x;
  }
  if (y) {
    attrs.y = y;
  }
  setTransform(attrs, el.transform);
  setStyleAttrs(attrs, style, el, scope);
  setMetaData(attrs, el);
  scope.animation && createCSSAnimation(el, attrs, scope);
  return createVNode("text", el.id + "", attrs, void 0, text);
}
function brush2(el, scope) {
  if (el instanceof Path_default) {
    return brushSVGPath(el, scope);
  } else if (el instanceof Image_default) {
    return brushSVGImage(el, scope);
  } else if (el instanceof TSpan_default) {
    return brushSVGTSpan(el, scope);
  }
}
function setShadow(el, attrs, scope) {
  const style = el.style;
  if (hasShadow(style)) {
    const shadowKey = getShadowKey(el);
    const shadowCache = scope.shadowCache;
    let shadowId = shadowCache[shadowKey];
    if (!shadowId) {
      const globalScale = el.getGlobalScale();
      const scaleX = globalScale[0];
      const scaleY = globalScale[1];
      if (!scaleX || !scaleY) {
        return;
      }
      const offsetX = style.shadowOffsetX || 0;
      const offsetY = style.shadowOffsetY || 0;
      const blur = style.shadowBlur;
      const {opacity, color: color2} = normalizeColor(style.shadowColor);
      const stdDx = blur / 2 / scaleX;
      const stdDy = blur / 2 / scaleY;
      const stdDeviation = stdDx + " " + stdDy;
      shadowId = scope.zrId + "-s" + scope.shadowIdx++;
      scope.defs[shadowId] = createVNode("filter", shadowId, {
        id: shadowId,
        x: "-100%",
        y: "-100%",
        width: "300%",
        height: "300%"
      }, [
        createVNode("feDropShadow", "", {
          dx: offsetX / scaleX,
          dy: offsetY / scaleY,
          stdDeviation,
          "flood-color": color2,
          "flood-opacity": opacity
        })
      ]);
      shadowCache[shadowKey] = shadowId;
    }
    attrs.filter = getIdURL(shadowId);
  }
}
function setGradient(style, attrs, target, scope) {
  const val = style[target];
  let gradientTag;
  let gradientAttrs = {
    gradientUnits: val.global ? "userSpaceOnUse" : "objectBoundingBox"
  };
  if (isLinearGradient(val)) {
    gradientTag = "linearGradient";
    gradientAttrs.x1 = val.x;
    gradientAttrs.y1 = val.y;
    gradientAttrs.x2 = val.x2;
    gradientAttrs.y2 = val.y2;
  } else if (isRadialGradient(val)) {
    gradientTag = "radialGradient";
    gradientAttrs.cx = retrieve2(val.x, 0.5);
    gradientAttrs.cy = retrieve2(val.y, 0.5);
    gradientAttrs.r = retrieve2(val.r, 0.5);
  } else {
    if (true) {
      logError("Illegal gradient type.");
    }
    return;
  }
  const colors = val.colorStops;
  const colorStops = [];
  for (let i = 0, len2 = colors.length; i < len2; ++i) {
    const offset = round4(colors[i].offset) * 100 + "%";
    const stopColor = colors[i].color;
    const {color: color2, opacity} = normalizeColor(stopColor);
    const stopsAttrs = {
      offset
    };
    stopsAttrs["stop-color"] = color2;
    if (opacity < 1) {
      stopsAttrs["stop-opacity"] = opacity;
    }
    colorStops.push(createVNode("stop", i + "", stopsAttrs));
  }
  const gradientVNode = createVNode(gradientTag, "", gradientAttrs, colorStops);
  const gradientKey = vNodeToString(gradientVNode);
  const gradientCache = scope.gradientCache;
  let gradientId = gradientCache[gradientKey];
  if (!gradientId) {
    gradientId = scope.zrId + "-g" + scope.gradientIdx++;
    gradientCache[gradientKey] = gradientId;
    gradientAttrs.id = gradientId;
    scope.defs[gradientId] = createVNode(gradientTag, gradientId, gradientAttrs, colorStops);
  }
  attrs[target] = getIdURL(gradientId);
}
function setPattern(el, attrs, target, scope) {
  const val = el.style[target];
  const boundingRect = el.getBoundingRect();
  const patternAttrs = {};
  const repeat = val.repeat;
  const noRepeat = repeat === "no-repeat";
  const repeatX = repeat === "repeat-x";
  const repeatY = repeat === "repeat-y";
  let child;
  if (isImagePattern(val)) {
    let imageWidth = val.imageWidth;
    let imageHeight = val.imageHeight;
    let imageSrc;
    const patternImage = val.image;
    if (isString(patternImage)) {
      imageSrc = patternImage;
    } else if (isImageLike2(patternImage)) {
      imageSrc = patternImage.src;
    } else if (isCanvasLike(patternImage)) {
      imageSrc = patternImage.toDataURL();
    }
    if (typeof Image === "undefined") {
      const errMsg = "Image width/height must been given explictly in svg-ssr renderer.";
      assert(imageWidth, errMsg);
      assert(imageHeight, errMsg);
    } else if (imageWidth == null || imageHeight == null) {
      const setSizeToVNode = (vNode, img) => {
        if (vNode) {
          const svgEl = vNode.elm;
          let width = imageWidth || img.width;
          let height = imageHeight || img.height;
          if (vNode.tag === "pattern") {
            if (repeatX) {
              height = 1;
              width /= boundingRect.width;
            } else if (repeatY) {
              width = 1;
              height /= boundingRect.height;
            }
          }
          vNode.attrs.width = width;
          vNode.attrs.height = height;
          if (svgEl) {
            svgEl.setAttribute("width", width);
            svgEl.setAttribute("height", height);
          }
        }
      };
      const createdImage = createOrUpdateImage(imageSrc, null, el, (img) => {
        noRepeat || setSizeToVNode(patternVNode, img);
        setSizeToVNode(child, img);
      });
      if (createdImage && createdImage.width && createdImage.height) {
        imageWidth = imageWidth || createdImage.width;
        imageHeight = imageHeight || createdImage.height;
      }
    }
    child = createVNode("image", "img", {
      href: imageSrc,
      width: imageWidth,
      height: imageHeight
    });
    patternAttrs.width = imageWidth;
    patternAttrs.height = imageHeight;
  } else if (val.svgElement) {
    child = clone(val.svgElement);
    patternAttrs.width = val.svgWidth;
    patternAttrs.height = val.svgHeight;
  }
  if (!child) {
    return;
  }
  let patternWidth;
  let patternHeight;
  if (noRepeat) {
    patternWidth = patternHeight = 1;
  } else if (repeatX) {
    patternHeight = 1;
    patternWidth = patternAttrs.width / boundingRect.width;
  } else if (repeatY) {
    patternWidth = 1;
    patternHeight = patternAttrs.height / boundingRect.height;
  } else {
    patternAttrs.patternUnits = "userSpaceOnUse";
  }
  if (patternWidth != null && !isNaN(patternWidth)) {
    patternAttrs.width = patternWidth;
  }
  if (patternHeight != null && !isNaN(patternHeight)) {
    patternAttrs.height = patternHeight;
  }
  const patternTransform = getSRTTransformString(val);
  patternTransform && (patternAttrs.patternTransform = patternTransform);
  let patternVNode = createVNode("pattern", "", patternAttrs, [child]);
  const patternKey = vNodeToString(patternVNode);
  const patternCache = scope.patternCache;
  let patternId = patternCache[patternKey];
  if (!patternId) {
    patternId = scope.zrId + "-p" + scope.patternIdx++;
    patternCache[patternKey] = patternId;
    patternAttrs.id = patternId;
    patternVNode = scope.defs[patternId] = createVNode("pattern", patternId, patternAttrs, [child]);
  }
  attrs[target] = getIdURL(patternId);
}
function setClipPath(clipPath, attrs, scope) {
  const {clipPathCache, defs} = scope;
  let clipPathId = clipPathCache[clipPath.id];
  if (!clipPathId) {
    clipPathId = scope.zrId + "-c" + scope.clipPathIdx++;
    const clipPathAttrs = {
      id: clipPathId
    };
    clipPathCache[clipPath.id] = clipPathId;
    defs[clipPathId] = createVNode("clipPath", clipPathId, clipPathAttrs, [brushSVGPath(clipPath, scope)]);
  }
  attrs["clip-path"] = getIdURL(clipPathId);
}

// node_modules/zrender/src/svg/domapi.ts
function createTextNode(text) {
  return document.createTextNode(text);
}
function insertBefore(parentNode2, newNode, referenceNode) {
  parentNode2.insertBefore(newNode, referenceNode);
}
function removeChild(node, child) {
  node.removeChild(child);
}
function appendChild(node, child) {
  node.appendChild(child);
}
function parentNode(node) {
  return node.parentNode;
}
function nextSibling(node) {
  return node.nextSibling;
}
function setTextContent(node, text) {
  node.textContent = text;
}

// node_modules/zrender/src/svg/patch.ts
var colonChar = 58;
var xChar = 120;
var emptyNode = createVNode("", "");
function isUndef(s) {
  return s === void 0;
}
function isDef(s) {
  return s !== void 0;
}
function createKeyToOldIdx(children, beginIdx, endIdx) {
  const map3 = {};
  for (let i = beginIdx; i <= endIdx; ++i) {
    const key = children[i].key;
    if (key !== void 0) {
      if (true) {
        if (map3[key] != null) {
          console.error(`Duplicate key ${key}`);
        }
      }
      map3[key] = i;
    }
  }
  return map3;
}
function sameVnode(vnode1, vnode2) {
  const isSameKey = vnode1.key === vnode2.key;
  const isSameTag = vnode1.tag === vnode2.tag;
  return isSameTag && isSameKey;
}
function createElm(vnode) {
  let i;
  const children = vnode.children;
  const tag = vnode.tag;
  if (isDef(tag)) {
    const elm = vnode.elm = createElement(tag);
    updateAttrs(emptyNode, vnode);
    if (isArray(children)) {
      for (i = 0; i < children.length; ++i) {
        const ch = children[i];
        if (ch != null) {
          appendChild(elm, createElm(ch));
        }
      }
    } else if (isDef(vnode.text) && !isObject(vnode.text)) {
      appendChild(elm, createTextNode(vnode.text));
    }
  } else {
    vnode.elm = createTextNode(vnode.text);
  }
  return vnode.elm;
}
function addVnodes(parentElm, before, vnodes, startIdx, endIdx) {
  for (; startIdx <= endIdx; ++startIdx) {
    const ch = vnodes[startIdx];
    if (ch != null) {
      insertBefore(parentElm, createElm(ch), before);
    }
  }
}
function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
  for (; startIdx <= endIdx; ++startIdx) {
    const ch = vnodes[startIdx];
    if (ch != null) {
      if (isDef(ch.tag)) {
        const parent = parentNode(ch.elm);
        removeChild(parent, ch.elm);
      } else {
        removeChild(parentElm, ch.elm);
      }
    }
  }
}
function updateAttrs(oldVnode, vnode) {
  let key;
  const elm = vnode.elm;
  const oldAttrs = oldVnode && oldVnode.attrs || {};
  const attrs = vnode.attrs || {};
  if (oldAttrs === attrs) {
    return;
  }
  for (key in attrs) {
    const cur = attrs[key];
    const old = oldAttrs[key];
    if (old !== cur) {
      if (cur === true) {
        elm.setAttribute(key, "");
      } else if (cur === false) {
        elm.removeAttribute(key);
      } else {
        if (key === "style") {
          elm.style.cssText = cur;
        } else if (key.charCodeAt(0) !== xChar) {
          elm.setAttribute(key, cur);
        } else if (key === "xmlns:xlink" || key === "xmlns") {
          elm.setAttributeNS(XMLNS, key, cur);
        } else if (key.charCodeAt(3) === colonChar) {
          elm.setAttributeNS(XML_NAMESPACE, key, cur);
        } else if (key.charCodeAt(5) === colonChar) {
          elm.setAttributeNS(XLINKNS, key, cur);
        } else {
          elm.setAttribute(key, cur);
        }
      }
    }
  }
  for (key in oldAttrs) {
    if (!(key in attrs)) {
      elm.removeAttribute(key);
    }
  }
}
function updateChildren(parentElm, oldCh, newCh) {
  let oldStartIdx = 0;
  let newStartIdx = 0;
  let oldEndIdx = oldCh.length - 1;
  let oldStartVnode = oldCh[0];
  let oldEndVnode = oldCh[oldEndIdx];
  let newEndIdx = newCh.length - 1;
  let newStartVnode = newCh[0];
  let newEndVnode = newCh[newEndIdx];
  let oldKeyToIdx;
  let idxInOld;
  let elmToMove;
  let before;
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (oldStartVnode == null) {
      oldStartVnode = oldCh[++oldStartIdx];
    } else if (oldEndVnode == null) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (newStartVnode == null) {
      newStartVnode = newCh[++newStartIdx];
    } else if (newEndVnode == null) {
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldStartVnode, newStartVnode)) {
      patchVnode(oldStartVnode, newStartVnode);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (sameVnode(oldEndVnode, newEndVnode)) {
      patchVnode(oldEndVnode, newEndVnode);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldStartVnode, newEndVnode)) {
      patchVnode(oldStartVnode, newEndVnode);
      insertBefore(parentElm, oldStartVnode.elm, nextSibling(oldEndVnode.elm));
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (sameVnode(oldEndVnode, newStartVnode)) {
      patchVnode(oldEndVnode, newStartVnode);
      insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      if (isUndef(oldKeyToIdx)) {
        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
      }
      idxInOld = oldKeyToIdx[newStartVnode.key];
      if (isUndef(idxInOld)) {
        insertBefore(parentElm, createElm(newStartVnode), oldStartVnode.elm);
      } else {
        elmToMove = oldCh[idxInOld];
        if (elmToMove.tag !== newStartVnode.tag) {
          insertBefore(parentElm, createElm(newStartVnode), oldStartVnode.elm);
        } else {
          patchVnode(elmToMove, newStartVnode);
          oldCh[idxInOld] = void 0;
          insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);
        }
      }
      newStartVnode = newCh[++newStartIdx];
    }
  }
  if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
    if (oldStartIdx > oldEndIdx) {
      before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx);
    } else {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }
}
function patchVnode(oldVnode, vnode) {
  const elm = vnode.elm = oldVnode.elm;
  const oldCh = oldVnode.children;
  const ch = vnode.children;
  if (oldVnode === vnode) {
    return;
  }
  updateAttrs(oldVnode, vnode);
  if (isUndef(vnode.text)) {
    if (isDef(oldCh) && isDef(ch)) {
      if (oldCh !== ch) {
        updateChildren(elm, oldCh, ch);
      }
    } else if (isDef(ch)) {
      if (isDef(oldVnode.text)) {
        setTextContent(elm, "");
      }
      addVnodes(elm, null, ch, 0, ch.length - 1);
    } else if (isDef(oldCh)) {
      removeVnodes(elm, oldCh, 0, oldCh.length - 1);
    } else if (isDef(oldVnode.text)) {
      setTextContent(elm, "");
    }
  } else if (oldVnode.text !== vnode.text) {
    if (isDef(oldCh)) {
      removeVnodes(elm, oldCh, 0, oldCh.length - 1);
    }
    setTextContent(elm, vnode.text);
  }
}
function patch(oldVnode, vnode) {
  if (sameVnode(oldVnode, vnode)) {
    patchVnode(oldVnode, vnode);
  } else {
    const elm = oldVnode.elm;
    const parent = parentNode(elm);
    createElm(vnode);
    if (parent !== null) {
      insertBefore(parent, vnode.elm, nextSibling(elm));
      removeVnodes(parent, [oldVnode], 0, 0);
    }
  }
  return vnode;
}

// node_modules/zrender/src/svg/Painter.ts
var svgId = 0;
var SVGPainter = class {
  constructor(root, storage2, opts) {
    this.type = "svg";
    this.refreshHover = createMethodNotSupport("refreshHover");
    this.configLayer = createMethodNotSupport("configLayer");
    this.storage = storage2;
    this._opts = opts = extend({}, opts);
    this.root = root;
    this._id = "zr" + svgId++;
    this._oldVNode = createSVGVNode(opts.width, opts.height);
    if (root && !opts.ssr) {
      const viewport = this._viewport = document.createElement("div");
      viewport.style.cssText = "position:relative;overflow:hidden";
      const svgDom = this._svgDom = this._oldVNode.elm = createElement("svg");
      updateAttrs(null, this._oldVNode);
      viewport.appendChild(svgDom);
      root.appendChild(viewport);
    }
    this.resize(opts.width, opts.height);
  }
  getType() {
    return this.type;
  }
  getViewportRoot() {
    return this._viewport;
  }
  getViewportRootOffset() {
    const viewportRoot = this.getViewportRoot();
    if (viewportRoot) {
      return {
        offsetLeft: viewportRoot.offsetLeft || 0,
        offsetTop: viewportRoot.offsetTop || 0
      };
    }
  }
  getSvgDom() {
    return this._svgDom;
  }
  refresh() {
    if (this.root) {
      const vnode = this.renderToVNode({
        willUpdate: true
      });
      vnode.attrs.style = "position:absolute;left:0;top:0;user-select:none";
      patch(this._oldVNode, vnode);
      this._oldVNode = vnode;
    }
  }
  renderOneToVNode(el) {
    return brush2(el, createBrushScope(this._id));
  }
  renderToVNode(opts) {
    opts = opts || {};
    const list = this.storage.getDisplayList(true);
    const width = this._width;
    const height = this._height;
    const scope = createBrushScope(this._id);
    scope.animation = opts.animation;
    scope.willUpdate = opts.willUpdate;
    scope.compress = opts.compress;
    scope.emphasis = opts.emphasis;
    const children = [];
    const bgVNode = this._bgVNode = createBackgroundVNode(width, height, this._backgroundColor, scope);
    bgVNode && children.push(bgVNode);
    const mainVNode = !opts.compress ? this._mainVNode = createVNode("g", "main", {}, []) : null;
    this._paintList(list, scope, mainVNode ? mainVNode.children : children);
    mainVNode && children.push(mainVNode);
    const defs = map(keys(scope.defs), (id) => scope.defs[id]);
    if (defs.length) {
      children.push(createVNode("defs", "defs", {}, defs));
    }
    if (opts.animation) {
      const animationCssStr = getCssString(scope.cssNodes, scope.cssAnims, {newline: true});
      if (animationCssStr) {
        const styleNode = createVNode("style", "stl", {}, [], animationCssStr);
        children.push(styleNode);
      }
    }
    return createSVGVNode(width, height, children, opts.useViewBox);
  }
  renderToString(opts) {
    opts = opts || {};
    return vNodeToString(this.renderToVNode({
      animation: retrieve2(opts.cssAnimation, true),
      emphasis: retrieve2(opts.cssEmphasis, true),
      willUpdate: false,
      compress: true,
      useViewBox: retrieve2(opts.useViewBox, true)
    }), {newline: true});
  }
  setBackgroundColor(backgroundColor2) {
    this._backgroundColor = backgroundColor2;
  }
  getSvgRoot() {
    return this._mainVNode && this._mainVNode.elm;
  }
  _paintList(list, scope, out2) {
    const listLen = list.length;
    const clipPathsGroupsStack = [];
    let clipPathsGroupsStackDepth = 0;
    let currentClipPathGroup;
    let prevClipPaths;
    let clipGroupNodeIdx = 0;
    for (let i = 0; i < listLen; i++) {
      const displayable = list[i];
      if (!displayable.invisible) {
        const clipPaths = displayable.__clipPaths;
        const len2 = clipPaths && clipPaths.length || 0;
        const prevLen = prevClipPaths && prevClipPaths.length || 0;
        let lca;
        for (lca = Math.max(len2 - 1, prevLen - 1); lca >= 0; lca--) {
          if (clipPaths && prevClipPaths && clipPaths[lca] === prevClipPaths[lca]) {
            break;
          }
        }
        for (let i2 = prevLen - 1; i2 > lca; i2--) {
          clipPathsGroupsStackDepth--;
          currentClipPathGroup = clipPathsGroupsStack[clipPathsGroupsStackDepth - 1];
        }
        for (let i2 = lca + 1; i2 < len2; i2++) {
          const groupAttrs = {};
          setClipPath(clipPaths[i2], groupAttrs, scope);
          const g = createVNode("g", "clip-g-" + clipGroupNodeIdx++, groupAttrs, []);
          (currentClipPathGroup ? currentClipPathGroup.children : out2).push(g);
          clipPathsGroupsStack[clipPathsGroupsStackDepth++] = g;
          currentClipPathGroup = g;
        }
        prevClipPaths = clipPaths;
        const ret = brush2(displayable, scope);
        if (ret) {
          (currentClipPathGroup ? currentClipPathGroup.children : out2).push(ret);
        }
      }
    }
  }
  resize(width, height) {
    const opts = this._opts;
    const root = this.root;
    const viewport = this._viewport;
    width != null && (opts.width = width);
    height != null && (opts.height = height);
    if (root && viewport) {
      viewport.style.display = "none";
      width = getSize(root, 0, opts);
      height = getSize(root, 1, opts);
      viewport.style.display = "";
    }
    if (this._width !== width || this._height !== height) {
      this._width = width;
      this._height = height;
      if (viewport) {
        const viewportStyle = viewport.style;
        viewportStyle.width = width + "px";
        viewportStyle.height = height + "px";
      }
      if (!isPattern(this._backgroundColor)) {
        const svgDom = this._svgDom;
        if (svgDom) {
          svgDom.setAttribute("width", width);
          svgDom.setAttribute("height", height);
        }
        const bgEl = this._bgVNode && this._bgVNode.elm;
        if (bgEl) {
          bgEl.setAttribute("width", width);
          bgEl.setAttribute("height", height);
        }
      } else {
        this.refresh();
      }
    }
  }
  getWidth() {
    return this._width;
  }
  getHeight() {
    return this._height;
  }
  dispose() {
    if (this.root) {
      this.root.innerHTML = "";
    }
    this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
  }
  clear() {
    if (this._svgDom) {
      this._svgDom.innerHTML = null;
    }
    this._oldVNode = null;
  }
  toDataURL(base64) {
    let str = this.renderToString();
    const prefix = "data:image/svg+xml;";
    if (base64) {
      str = encodeBase64(str);
      return str && prefix + "base64," + str;
    }
    return prefix + "charset=UTF-8," + encodeURIComponent(str);
  }
};
function createMethodNotSupport(method) {
  return function() {
    if (true) {
      logError('In SVG mode painter not support method "' + method + '"');
    }
  };
}
function createBackgroundVNode(width, height, backgroundColor2, scope) {
  let bgVNode;
  if (backgroundColor2 && backgroundColor2 !== "none") {
    bgVNode = createVNode("rect", "bg", {
      width,
      height,
      x: "0",
      y: "0"
    });
    if (isGradient(backgroundColor2)) {
      setGradient({fill: backgroundColor2}, bgVNode.attrs, "fill", scope);
    } else if (isPattern(backgroundColor2)) {
      setPattern({
        style: {
          fill: backgroundColor2
        },
        dirty: noop,
        getBoundingRect: () => ({width, height})
      }, bgVNode.attrs, "fill", scope);
    } else {
      const {color: color2, opacity} = normalizeColor(backgroundColor2);
      bgVNode.attrs.fill = color2;
      opacity < 1 && (bgVNode.attrs["fill-opacity"] = opacity);
    }
  }
  return bgVNode;
}
var Painter_default = SVGPainter;

// src/renderer/installSVGRenderer.ts
function install(registers) {
  registers.registerPainter("svg", Painter_default);
}

// node_modules/zrender/src/canvas/Layer.ts
function createDom(id, painter, dpr2) {
  const newDom = platformApi.createCanvas();
  const width = painter.getWidth();
  const height = painter.getHeight();
  const newDomStyle = newDom.style;
  if (newDomStyle) {
    newDomStyle.position = "absolute";
    newDomStyle.left = "0";
    newDomStyle.top = "0";
    newDomStyle.width = width + "px";
    newDomStyle.height = height + "px";
    newDom.setAttribute("data-zr-dom-id", id);
  }
  newDom.width = width * dpr2;
  newDom.height = height * dpr2;
  return newDom;
}
var Layer = class extends Eventful_default {
  constructor(id, painter, dpr2) {
    super();
    this.motionBlur = false;
    this.lastFrameAlpha = 0.7;
    this.dpr = 1;
    this.virtual = false;
    this.config = {};
    this.incremental = false;
    this.zlevel = 0;
    this.maxRepaintRectCount = 5;
    this.__dirty = true;
    this.__firstTimePaint = true;
    this.__used = false;
    this.__drawIndex = 0;
    this.__startIndex = 0;
    this.__endIndex = 0;
    this.__prevStartIndex = null;
    this.__prevEndIndex = null;
    let dom;
    dpr2 = dpr2 || devicePixelRatio;
    if (typeof id === "string") {
      dom = createDom(id, painter, dpr2);
    } else if (isObject(id)) {
      dom = id;
      id = dom.id;
    }
    this.id = id;
    this.dom = dom;
    const domStyle = dom.style;
    if (domStyle) {
      disableUserSelect(dom);
      dom.onselectstart = () => false;
      domStyle.padding = "0";
      domStyle.margin = "0";
      domStyle.borderWidth = "0";
    }
    this.painter = painter;
    this.dpr = dpr2;
  }
  getElementCount() {
    return this.__endIndex - this.__startIndex;
  }
  afterBrush() {
    this.__prevStartIndex = this.__startIndex;
    this.__prevEndIndex = this.__endIndex;
  }
  initContext() {
    this.ctx = this.dom.getContext("2d");
    this.ctx.dpr = this.dpr;
  }
  setUnpainted() {
    this.__firstTimePaint = true;
  }
  createBackBuffer() {
    const dpr2 = this.dpr;
    this.domBack = createDom("back-" + this.id, this.painter, dpr2);
    this.ctxBack = this.domBack.getContext("2d");
    if (dpr2 !== 1) {
      this.ctxBack.scale(dpr2, dpr2);
    }
  }
  createRepaintRects(displayList, prevList, viewWidth, viewHeight) {
    if (this.__firstTimePaint) {
      this.__firstTimePaint = false;
      return null;
    }
    const mergedRepaintRects = [];
    const maxRepaintRectCount = this.maxRepaintRectCount;
    let full = false;
    const pendingRect = new BoundingRect_default(0, 0, 0, 0);
    function addRectToMergePool(rect) {
      if (!rect.isFinite() || rect.isZero()) {
        return;
      }
      if (mergedRepaintRects.length === 0) {
        const boundingRect = new BoundingRect_default(0, 0, 0, 0);
        boundingRect.copy(rect);
        mergedRepaintRects.push(boundingRect);
      } else {
        let isMerged = false;
        let minDeltaArea = Infinity;
        let bestRectToMergeIdx = 0;
        for (let i = 0; i < mergedRepaintRects.length; ++i) {
          const mergedRect = mergedRepaintRects[i];
          if (mergedRect.intersect(rect)) {
            const pendingRect2 = new BoundingRect_default(0, 0, 0, 0);
            pendingRect2.copy(mergedRect);
            pendingRect2.union(rect);
            mergedRepaintRects[i] = pendingRect2;
            isMerged = true;
            break;
          } else if (full) {
            pendingRect.copy(rect);
            pendingRect.union(mergedRect);
            const aArea = rect.width * rect.height;
            const bArea = mergedRect.width * mergedRect.height;
            const pendingArea = pendingRect.width * pendingRect.height;
            const deltaArea = pendingArea - aArea - bArea;
            if (deltaArea < minDeltaArea) {
              minDeltaArea = deltaArea;
              bestRectToMergeIdx = i;
            }
          }
        }
        if (full) {
          mergedRepaintRects[bestRectToMergeIdx].union(rect);
          isMerged = true;
        }
        if (!isMerged) {
          const boundingRect = new BoundingRect_default(0, 0, 0, 0);
          boundingRect.copy(rect);
          mergedRepaintRects.push(boundingRect);
        }
        if (!full) {
          full = mergedRepaintRects.length >= maxRepaintRectCount;
        }
      }
    }
    for (let i = this.__startIndex; i < this.__endIndex; ++i) {
      const el = displayList[i];
      if (el) {
        const shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true);
        const prevRect = el.__isRendered && (el.__dirty & REDRAW_BIT || !shouldPaint) ? el.getPrevPaintRect() : null;
        if (prevRect) {
          addRectToMergePool(prevRect);
        }
        const curRect = shouldPaint && (el.__dirty & REDRAW_BIT || !el.__isRendered) ? el.getPaintRect() : null;
        if (curRect) {
          addRectToMergePool(curRect);
        }
      }
    }
    for (let i = this.__prevStartIndex; i < this.__prevEndIndex; ++i) {
      const el = prevList[i];
      const shouldPaint = el && el.shouldBePainted(viewWidth, viewHeight, true, true);
      if (el && (!shouldPaint || !el.__zr) && el.__isRendered) {
        const prevRect = el.getPrevPaintRect();
        if (prevRect) {
          addRectToMergePool(prevRect);
        }
      }
    }
    let hasIntersections;
    do {
      hasIntersections = false;
      for (let i = 0; i < mergedRepaintRects.length; ) {
        if (mergedRepaintRects[i].isZero()) {
          mergedRepaintRects.splice(i, 1);
          continue;
        }
        for (let j = i + 1; j < mergedRepaintRects.length; ) {
          if (mergedRepaintRects[i].intersect(mergedRepaintRects[j])) {
            hasIntersections = true;
            mergedRepaintRects[i].union(mergedRepaintRects[j]);
            mergedRepaintRects.splice(j, 1);
          } else {
            j++;
          }
        }
        i++;
      }
    } while (hasIntersections);
    this._paintRects = mergedRepaintRects;
    return mergedRepaintRects;
  }
  debugGetPaintRects() {
    return (this._paintRects || []).slice();
  }
  resize(width, height) {
    const dpr2 = this.dpr;
    const dom = this.dom;
    const domStyle = dom.style;
    const domBack = this.domBack;
    if (domStyle) {
      domStyle.width = width + "px";
      domStyle.height = height + "px";
    }
    dom.width = width * dpr2;
    dom.height = height * dpr2;
    if (domBack) {
      domBack.width = width * dpr2;
      domBack.height = height * dpr2;
      if (dpr2 !== 1) {
        this.ctxBack.scale(dpr2, dpr2);
      }
    }
  }
  clear(clearAll, clearColor, repaintRects) {
    const dom = this.dom;
    const ctx = this.ctx;
    const width = dom.width;
    const height = dom.height;
    clearColor = clearColor || this.clearColor;
    const haveMotionBLur = this.motionBlur && !clearAll;
    const lastFrameAlpha = this.lastFrameAlpha;
    const dpr2 = this.dpr;
    const self2 = this;
    if (haveMotionBLur) {
      if (!this.domBack) {
        this.createBackBuffer();
      }
      this.ctxBack.globalCompositeOperation = "copy";
      this.ctxBack.drawImage(dom, 0, 0, width / dpr2, height / dpr2);
    }
    const domBack = this.domBack;
    function doClear(x, y, width2, height2) {
      ctx.clearRect(x, y, width2, height2);
      if (clearColor && clearColor !== "transparent") {
        let clearColorGradientOrPattern;
        if (isGradientObject(clearColor)) {
          const shouldCache = clearColor.global || clearColor.__width === width2 && clearColor.__height === height2;
          clearColorGradientOrPattern = shouldCache && clearColor.__canvasGradient || getCanvasGradient(ctx, clearColor, {
            x: 0,
            y: 0,
            width: width2,
            height: height2
          });
          clearColor.__canvasGradient = clearColorGradientOrPattern;
          clearColor.__width = width2;
          clearColor.__height = height2;
        } else if (isImagePatternObject(clearColor)) {
          clearColor.scaleX = clearColor.scaleX || dpr2;
          clearColor.scaleY = clearColor.scaleY || dpr2;
          clearColorGradientOrPattern = createCanvasPattern(ctx, clearColor, {
            dirty() {
              self2.setUnpainted();
              self2.painter.refresh();
            }
          });
        }
        ctx.save();
        ctx.fillStyle = clearColorGradientOrPattern || clearColor;
        ctx.fillRect(x, y, width2, height2);
        ctx.restore();
      }
      if (haveMotionBLur) {
        ctx.save();
        ctx.globalAlpha = lastFrameAlpha;
        ctx.drawImage(domBack, x, y, width2, height2);
        ctx.restore();
      }
    }
    ;
    if (!repaintRects || haveMotionBLur) {
      doClear(0, 0, width, height);
    } else if (repaintRects.length) {
      each(repaintRects, (rect) => {
        doClear(rect.x * dpr2, rect.y * dpr2, rect.width * dpr2, rect.height * dpr2);
      });
    }
  }
};
var Layer_default = Layer;

// node_modules/zrender/src/canvas/Painter.ts
var HOVER_LAYER_ZLEVEL = 1e5;
var CANVAS_ZLEVEL = 314159;
var EL_AFTER_INCREMENTAL_INC = 0.01;
var INCREMENTAL_INC = 1e-3;
function isLayerValid(layer) {
  if (!layer) {
    return false;
  }
  if (layer.__builtin__) {
    return true;
  }
  if (typeof layer.resize !== "function" || typeof layer.refresh !== "function") {
    return false;
  }
  return true;
}
function createRoot(width, height) {
  const domRoot = document.createElement("div");
  domRoot.style.cssText = [
    "position:relative",
    "width:" + width + "px",
    "height:" + height + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";";
  return domRoot;
}
var CanvasPainter = class {
  constructor(root, storage2, opts, id) {
    this.type = "canvas";
    this._zlevelList = [];
    this._prevDisplayList = [];
    this._layers = {};
    this._layerConfig = {};
    this._needsManuallyCompositing = false;
    this.type = "canvas";
    const singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === "CANVAS";
    this._opts = opts = extend({}, opts || {});
    this.dpr = opts.devicePixelRatio || devicePixelRatio;
    this._singleCanvas = singleCanvas;
    this.root = root;
    const rootStyle = root.style;
    if (rootStyle) {
      disableUserSelect(root);
      root.innerHTML = "";
    }
    this.storage = storage2;
    const zlevelList = this._zlevelList;
    this._prevDisplayList = [];
    const layers = this._layers;
    if (!singleCanvas) {
      this._width = getSize(root, 0, opts);
      this._height = getSize(root, 1, opts);
      const domRoot = this._domRoot = createRoot(this._width, this._height);
      root.appendChild(domRoot);
    } else {
      const rootCanvas = root;
      let width = rootCanvas.width;
      let height = rootCanvas.height;
      if (opts.width != null) {
        width = opts.width;
      }
      if (opts.height != null) {
        height = opts.height;
      }
      this.dpr = opts.devicePixelRatio || 1;
      rootCanvas.width = width * this.dpr;
      rootCanvas.height = height * this.dpr;
      this._width = width;
      this._height = height;
      const mainLayer = new Layer_default(rootCanvas, this, this.dpr);
      mainLayer.__builtin__ = true;
      mainLayer.initContext();
      layers[CANVAS_ZLEVEL] = mainLayer;
      mainLayer.zlevel = CANVAS_ZLEVEL;
      zlevelList.push(CANVAS_ZLEVEL);
      this._domRoot = root;
    }
  }
  getType() {
    return "canvas";
  }
  isSingleCanvas() {
    return this._singleCanvas;
  }
  getViewportRoot() {
    return this._domRoot;
  }
  getViewportRootOffset() {
    const viewportRoot = this.getViewportRoot();
    if (viewportRoot) {
      return {
        offsetLeft: viewportRoot.offsetLeft || 0,
        offsetTop: viewportRoot.offsetTop || 0
      };
    }
  }
  refresh(paintAll) {
    const list = this.storage.getDisplayList(true);
    const prevList = this._prevDisplayList;
    const zlevelList = this._zlevelList;
    this._redrawId = Math.random();
    this._paintList(list, prevList, paintAll, this._redrawId);
    for (let i = 0; i < zlevelList.length; i++) {
      const z = zlevelList[i];
      const layer = this._layers[z];
      if (!layer.__builtin__ && layer.refresh) {
        const clearColor = i === 0 ? this._backgroundColor : null;
        layer.refresh(clearColor);
      }
    }
    if (this._opts.useDirtyRect) {
      this._prevDisplayList = list.slice();
    }
    return this;
  }
  refreshHover() {
    this._paintHoverList(this.storage.getDisplayList(false));
  }
  _paintHoverList(list) {
    let len2 = list.length;
    let hoverLayer = this._hoverlayer;
    hoverLayer && hoverLayer.clear();
    if (!len2) {
      return;
    }
    const scope = {
      inHover: true,
      viewWidth: this._width,
      viewHeight: this._height
    };
    let ctx;
    for (let i = 0; i < len2; i++) {
      const el = list[i];
      if (el.__inHover) {
        if (!hoverLayer) {
          hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);
        }
        if (!ctx) {
          ctx = hoverLayer.ctx;
          ctx.save();
        }
        brush(ctx, el, scope, i === len2 - 1);
      }
    }
    if (ctx) {
      ctx.restore();
    }
  }
  getHoverLayer() {
    return this.getLayer(HOVER_LAYER_ZLEVEL);
  }
  paintOne(ctx, el) {
    brushSingle(ctx, el);
  }
  _paintList(list, prevList, paintAll, redrawId) {
    if (this._redrawId !== redrawId) {
      return;
    }
    paintAll = paintAll || false;
    this._updateLayerStatus(list);
    const {finished, needsRefreshHover} = this._doPaintList(list, prevList, paintAll);
    if (this._needsManuallyCompositing) {
      this._compositeManually();
    }
    if (needsRefreshHover) {
      this._paintHoverList(list);
    }
    if (!finished) {
      const self2 = this;
      requestAnimationFrame_default(function() {
        self2._paintList(list, prevList, paintAll, redrawId);
      });
    } else {
      this.eachLayer((layer) => {
        layer.afterBrush && layer.afterBrush();
      });
    }
  }
  _compositeManually() {
    const ctx = this.getLayer(CANVAS_ZLEVEL).ctx;
    const width = this._domRoot.width;
    const height = this._domRoot.height;
    ctx.clearRect(0, 0, width, height);
    this.eachBuiltinLayer(function(layer) {
      if (layer.virtual) {
        ctx.drawImage(layer.dom, 0, 0, width, height);
      }
    });
  }
  _doPaintList(list, prevList, paintAll) {
    const layerList = [];
    const useDirtyRect = this._opts.useDirtyRect;
    for (let zi = 0; zi < this._zlevelList.length; zi++) {
      const zlevel = this._zlevelList[zi];
      const layer = this._layers[zlevel];
      if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {
        layerList.push(layer);
      }
    }
    let finished = true;
    let needsRefreshHover = false;
    for (let k = 0; k < layerList.length; k++) {
      const layer = layerList[k];
      const ctx = layer.ctx;
      const repaintRects = useDirtyRect && layer.createRepaintRects(list, prevList, this._width, this._height);
      let start2 = paintAll ? layer.__startIndex : layer.__drawIndex;
      const useTimer = !paintAll && layer.incremental && Date.now;
      const startTime = useTimer && Date.now();
      const clearColor = layer.zlevel === this._zlevelList[0] ? this._backgroundColor : null;
      if (layer.__startIndex === layer.__endIndex) {
        layer.clear(false, clearColor, repaintRects);
      } else if (start2 === layer.__startIndex) {
        const firstEl = list[start2];
        if (!firstEl.incremental || !firstEl.notClear || paintAll) {
          layer.clear(false, clearColor, repaintRects);
        }
      }
      if (start2 === -1) {
        console.error("For some unknown reason. drawIndex is -1");
        start2 = layer.__startIndex;
      }
      let i;
      const repaint = (repaintRect) => {
        const scope = {
          inHover: false,
          allClipped: false,
          prevEl: null,
          viewWidth: this._width,
          viewHeight: this._height
        };
        for (i = start2; i < layer.__endIndex; i++) {
          const el = list[i];
          if (el.__inHover) {
            needsRefreshHover = true;
          }
          this._doPaintEl(el, layer, useDirtyRect, repaintRect, scope, i === layer.__endIndex - 1);
          if (useTimer) {
            const dTime = Date.now() - startTime;
            if (dTime > 15) {
              break;
            }
          }
        }
        if (scope.prevElClipPaths) {
          ctx.restore();
        }
      };
      if (repaintRects) {
        if (repaintRects.length === 0) {
          i = layer.__endIndex;
        } else {
          const dpr2 = this.dpr;
          for (var r = 0; r < repaintRects.length; ++r) {
            const rect = repaintRects[r];
            ctx.save();
            ctx.beginPath();
            ctx.rect(rect.x * dpr2, rect.y * dpr2, rect.width * dpr2, rect.height * dpr2);
            ctx.clip();
            repaint(rect);
            ctx.restore();
          }
        }
      } else {
        ctx.save();
        repaint();
        ctx.restore();
      }
      layer.__drawIndex = i;
      if (layer.__drawIndex < layer.__endIndex) {
        finished = false;
      }
    }
    if (env_default.wxa) {
      each(this._layers, function(layer) {
        if (layer && layer.ctx && layer.ctx.draw) {
          layer.ctx.draw();
        }
      });
    }
    return {
      finished,
      needsRefreshHover
    };
  }
  _doPaintEl(el, currentLayer, useDirtyRect, repaintRect, scope, isLast) {
    const ctx = currentLayer.ctx;
    if (useDirtyRect) {
      const paintRect = el.getPaintRect();
      if (!repaintRect || paintRect && paintRect.intersect(repaintRect)) {
        brush(ctx, el, scope, isLast);
        el.setPrevPaintRect(paintRect);
      }
    } else {
      brush(ctx, el, scope, isLast);
    }
  }
  getLayer(zlevel, virtual) {
    if (this._singleCanvas && !this._needsManuallyCompositing) {
      zlevel = CANVAS_ZLEVEL;
    }
    let layer = this._layers[zlevel];
    if (!layer) {
      layer = new Layer_default("zr_" + zlevel, this, this.dpr);
      layer.zlevel = zlevel;
      layer.__builtin__ = true;
      if (this._layerConfig[zlevel]) {
        merge(layer, this._layerConfig[zlevel], true);
      } else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {
        merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);
      }
      if (virtual) {
        layer.virtual = virtual;
      }
      this.insertLayer(zlevel, layer);
      layer.initContext();
    }
    return layer;
  }
  insertLayer(zlevel, layer) {
    const layersMap = this._layers;
    const zlevelList = this._zlevelList;
    const len2 = zlevelList.length;
    const domRoot = this._domRoot;
    let prevLayer = null;
    let i = -1;
    if (layersMap[zlevel]) {
      if (true) {
        logError("ZLevel " + zlevel + " has been used already");
      }
      return;
    }
    if (!isLayerValid(layer)) {
      if (true) {
        logError("Layer of zlevel " + zlevel + " is not valid");
      }
      return;
    }
    if (len2 > 0 && zlevel > zlevelList[0]) {
      for (i = 0; i < len2 - 1; i++) {
        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
          break;
        }
      }
      prevLayer = layersMap[zlevelList[i]];
    }
    zlevelList.splice(i + 1, 0, zlevel);
    layersMap[zlevel] = layer;
    if (!layer.virtual) {
      if (prevLayer) {
        const prevDom = prevLayer.dom;
        if (prevDom.nextSibling) {
          domRoot.insertBefore(layer.dom, prevDom.nextSibling);
        } else {
          domRoot.appendChild(layer.dom);
        }
      } else {
        if (domRoot.firstChild) {
          domRoot.insertBefore(layer.dom, domRoot.firstChild);
        } else {
          domRoot.appendChild(layer.dom);
        }
      }
    }
    layer.painter || (layer.painter = this);
  }
  eachLayer(cb, context) {
    const zlevelList = this._zlevelList;
    for (let i = 0; i < zlevelList.length; i++) {
      const z = zlevelList[i];
      cb.call(context, this._layers[z], z);
    }
  }
  eachBuiltinLayer(cb, context) {
    const zlevelList = this._zlevelList;
    for (let i = 0; i < zlevelList.length; i++) {
      const z = zlevelList[i];
      const layer = this._layers[z];
      if (layer.__builtin__) {
        cb.call(context, layer, z);
      }
    }
  }
  eachOtherLayer(cb, context) {
    const zlevelList = this._zlevelList;
    for (let i = 0; i < zlevelList.length; i++) {
      const z = zlevelList[i];
      const layer = this._layers[z];
      if (!layer.__builtin__) {
        cb.call(context, layer, z);
      }
    }
  }
  getLayers() {
    return this._layers;
  }
  _updateLayerStatus(list) {
    this.eachBuiltinLayer(function(layer, z) {
      layer.__dirty = layer.__used = false;
    });
    function updatePrevLayer(idx) {
      if (prevLayer) {
        if (prevLayer.__endIndex !== idx) {
          prevLayer.__dirty = true;
        }
        prevLayer.__endIndex = idx;
      }
    }
    if (this._singleCanvas) {
      for (let i2 = 1; i2 < list.length; i2++) {
        const el = list[i2];
        if (el.zlevel !== list[i2 - 1].zlevel || el.incremental) {
          this._needsManuallyCompositing = true;
          break;
        }
      }
    }
    let prevLayer = null;
    let incrementalLayerCount = 0;
    let prevZlevel;
    let i;
    for (i = 0; i < list.length; i++) {
      const el = list[i];
      const zlevel = el.zlevel;
      let layer;
      if (prevZlevel !== zlevel) {
        prevZlevel = zlevel;
        incrementalLayerCount = 0;
      }
      if (el.incremental) {
        layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);
        layer.incremental = true;
        incrementalLayerCount = 1;
      } else {
        layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);
      }
      if (!layer.__builtin__) {
        logError("ZLevel " + zlevel + " has been used by unkown layer " + layer.id);
      }
      if (layer !== prevLayer) {
        layer.__used = true;
        if (layer.__startIndex !== i) {
          layer.__dirty = true;
        }
        layer.__startIndex = i;
        if (!layer.incremental) {
          layer.__drawIndex = i;
        } else {
          layer.__drawIndex = -1;
        }
        updatePrevLayer(i);
        prevLayer = layer;
      }
      if (el.__dirty & REDRAW_BIT && !el.__inHover) {
        layer.__dirty = true;
        if (layer.incremental && layer.__drawIndex < 0) {
          layer.__drawIndex = i;
        }
      }
    }
    updatePrevLayer(i);
    this.eachBuiltinLayer(function(layer, z) {
      if (!layer.__used && layer.getElementCount() > 0) {
        layer.__dirty = true;
        layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0;
      }
      if (layer.__dirty && layer.__drawIndex < 0) {
        layer.__drawIndex = layer.__startIndex;
      }
    });
  }
  clear() {
    this.eachBuiltinLayer(this._clearLayer);
    return this;
  }
  _clearLayer(layer) {
    layer.clear();
  }
  setBackgroundColor(backgroundColor2) {
    this._backgroundColor = backgroundColor2;
    each(this._layers, (layer) => {
      layer.setUnpainted();
    });
  }
  configLayer(zlevel, config) {
    if (config) {
      const layerConfig = this._layerConfig;
      if (!layerConfig[zlevel]) {
        layerConfig[zlevel] = config;
      } else {
        merge(layerConfig[zlevel], config, true);
      }
      for (let i = 0; i < this._zlevelList.length; i++) {
        const _zlevel = this._zlevelList[i];
        if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {
          const layer = this._layers[_zlevel];
          merge(layer, layerConfig[zlevel], true);
        }
      }
    }
  }
  delLayer(zlevel) {
    const layers = this._layers;
    const zlevelList = this._zlevelList;
    const layer = layers[zlevel];
    if (!layer) {
      return;
    }
    layer.dom.parentNode.removeChild(layer.dom);
    delete layers[zlevel];
    zlevelList.splice(indexOf(zlevelList, zlevel), 1);
  }
  resize(width, height) {
    if (!this._domRoot.style) {
      if (width == null || height == null) {
        return;
      }
      this._width = width;
      this._height = height;
      this.getLayer(CANVAS_ZLEVEL).resize(width, height);
    } else {
      const domRoot = this._domRoot;
      domRoot.style.display = "none";
      const opts = this._opts;
      const root = this.root;
      width != null && (opts.width = width);
      height != null && (opts.height = height);
      width = getSize(root, 0, opts);
      height = getSize(root, 1, opts);
      domRoot.style.display = "";
      if (this._width !== width || height !== this._height) {
        domRoot.style.width = width + "px";
        domRoot.style.height = height + "px";
        for (let id in this._layers) {
          if (this._layers.hasOwnProperty(id)) {
            this._layers[id].resize(width, height);
          }
        }
        this.refresh(true);
      }
      this._width = width;
      this._height = height;
    }
    return this;
  }
  clearLayer(zlevel) {
    const layer = this._layers[zlevel];
    if (layer) {
      layer.clear();
    }
  }
  dispose() {
    this.root.innerHTML = "";
    this.root = this.storage = this._domRoot = this._layers = null;
  }
  getRenderedCanvas(opts) {
    opts = opts || {};
    if (this._singleCanvas && !this._compositeManually) {
      return this._layers[CANVAS_ZLEVEL].dom;
    }
    const imageLayer = new Layer_default("image", this, opts.pixelRatio || this.dpr);
    imageLayer.initContext();
    imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);
    const ctx = imageLayer.ctx;
    if (opts.pixelRatio <= this.dpr) {
      this.refresh();
      const width = imageLayer.dom.width;
      const height = imageLayer.dom.height;
      this.eachLayer(function(layer) {
        if (layer.__builtin__) {
          ctx.drawImage(layer.dom, 0, 0, width, height);
        } else if (layer.renderToCanvas) {
          ctx.save();
          layer.renderToCanvas(ctx);
          ctx.restore();
        }
      });
    } else {
      const scope = {
        inHover: false,
        viewWidth: this._width,
        viewHeight: this._height
      };
      const displayList = this.storage.getDisplayList(true);
      for (let i = 0, len2 = displayList.length; i < len2; i++) {
        const el = displayList[i];
        brush(ctx, el, scope, i === len2 - 1);
      }
    }
    return imageLayer.dom;
  }
  getWidth() {
    return this._width;
  }
  getHeight() {
    return this._height;
  }
};
var Painter_default2 = CanvasPainter;

// src/renderer/installCanvasRenderer.ts
function install2(registers) {
  registers.registerPainter("canvas", Painter_default2);
}

// src/chart/line/LineSeries.ts
var LineSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = LineSeriesModel2.type;
    this.hasSymbolVisual = true;
  }
  getInitialData(option) {
    if (true) {
      const coordSys = option.coordinateSystem;
      if (coordSys !== "polar" && coordSys !== "cartesian2d") {
        throw new Error("Line not support coordinateSystem besides cartesian and polar");
      }
    }
    return createSeriesData_default(null, this, {
      useEncodeDefaulter: true
    });
  }
  getLegendIcon(opt) {
    const group = new Group_default();
    const line2 = createSymbol("line", 0, opt.itemHeight / 2, opt.itemWidth, 0, opt.lineStyle.stroke, false);
    group.add(line2);
    line2.setStyle(opt.lineStyle);
    const visualType = this.getData().getVisual("symbol");
    const visualRotate = this.getData().getVisual("symbolRotate");
    const symbolType = visualType === "none" ? "circle" : visualType;
    const size = opt.itemHeight * 0.8;
    const symbol = createSymbol(symbolType, (opt.itemWidth - size) / 2, (opt.itemHeight - size) / 2, size, size, opt.itemStyle.fill);
    group.add(symbol);
    symbol.setStyle(opt.itemStyle);
    const symbolRotate = opt.iconRotate === "inherit" ? visualRotate : opt.iconRotate || 0;
    symbol.rotation = symbolRotate * Math.PI / 180;
    symbol.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);
    if (symbolType.indexOf("empty") > -1) {
      symbol.style.stroke = symbol.style.fill;
      symbol.style.fill = "#fff";
      symbol.style.lineWidth = 2;
    }
    return group;
  }
};
var LineSeriesModel = LineSeriesModel2;
LineSeriesModel.type = "series.line";
LineSeriesModel.dependencies = ["grid", "polar"];
LineSeriesModel.defaultOption = {
  z: 3,
  coordinateSystem: "cartesian2d",
  legendHoverLink: true,
  clip: true,
  label: {
    position: "top"
  },
  endLabel: {
    show: false,
    valueAnimation: true,
    distance: 8
  },
  lineStyle: {
    width: 2,
    type: "solid"
  },
  emphasis: {
    scale: true
  },
  step: false,
  smooth: false,
  smoothMonotone: null,
  symbol: "emptyCircle",
  symbolSize: 4,
  symbolRotate: null,
  showSymbol: true,
  showAllSymbol: "auto",
  connectNulls: false,
  sampling: "none",
  animationEasing: "linear",
  progressive: 0,
  hoverLayerThreshold: Infinity,
  universalTransition: {
    divideShape: "clone"
  },
  triggerLineEvent: false
};
var LineSeries_default = LineSeriesModel;

// src/chart/helper/labelHelper.ts
function getDefaultLabel(data, dataIndex) {
  const labelDims = data.mapDimensionsAll("defaultedLabel");
  const len2 = labelDims.length;
  if (len2 === 1) {
    const rawVal = retrieveRawValue(data, dataIndex, labelDims[0]);
    return rawVal != null ? rawVal + "" : null;
  } else if (len2) {
    const vals = [];
    for (let i = 0; i < labelDims.length; i++) {
      vals.push(retrieveRawValue(data, dataIndex, labelDims[i]));
    }
    return vals.join(" ");
  }
}
function getDefaultInterpolatedLabel(data, interpolatedValue) {
  const labelDims = data.mapDimensionsAll("defaultedLabel");
  if (!isArray(interpolatedValue)) {
    return interpolatedValue + "";
  }
  const vals = [];
  for (let i = 0; i < labelDims.length; i++) {
    const dimIndex = data.getDimensionIndex(labelDims[i]);
    if (dimIndex >= 0) {
      vals.push(interpolatedValue[dimIndex]);
    }
  }
  return vals.join(" ");
}

// src/chart/helper/Symbol.ts
var Symbol = class extends Group_default {
  constructor(data, idx, seriesScope, opts) {
    super();
    this.updateData(data, idx, seriesScope, opts);
  }
  _createSymbol(symbolType, data, idx, symbolSize, keepAspect) {
    this.removeAll();
    const symbolPath = createSymbol(symbolType, -1, -1, 2, 2, null, keepAspect);
    symbolPath.attr({
      z2: 100,
      culling: true,
      scaleX: symbolSize[0] / 2,
      scaleY: symbolSize[1] / 2
    });
    symbolPath.drift = driftSymbol;
    this._symbolType = symbolType;
    this.add(symbolPath);
  }
  stopSymbolAnimation(toLastFrame) {
    this.childAt(0).stopAnimation(null, toLastFrame);
  }
  getSymbolType() {
    return this._symbolType;
  }
  getSymbolPath() {
    return this.childAt(0);
  }
  highlight() {
    enterEmphasis(this.childAt(0));
  }
  downplay() {
    leaveEmphasis(this.childAt(0));
  }
  setZ(zlevel, z) {
    const symbolPath = this.childAt(0);
    symbolPath.zlevel = zlevel;
    symbolPath.z = z;
  }
  setDraggable(draggable, hasCursorOption) {
    const symbolPath = this.childAt(0);
    symbolPath.draggable = draggable;
    symbolPath.cursor = !hasCursorOption && draggable ? "move" : symbolPath.cursor;
  }
  updateData(data, idx, seriesScope, opts) {
    this.silent = false;
    const symbolType = data.getItemVisual(idx, "symbol") || "circle";
    const seriesModel = data.hostModel;
    const symbolSize = Symbol.getSymbolSize(data, idx);
    const isInit = symbolType !== this._symbolType;
    const disableAnimation = opts && opts.disableAnimation;
    if (isInit) {
      const keepAspect = data.getItemVisual(idx, "symbolKeepAspect");
      this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);
    } else {
      const symbolPath = this.childAt(0);
      symbolPath.silent = false;
      const target = {
        scaleX: symbolSize[0] / 2,
        scaleY: symbolSize[1] / 2
      };
      disableAnimation ? symbolPath.attr(target) : updateProps(symbolPath, target, seriesModel, idx);
      saveOldStyle(symbolPath);
    }
    this._updateCommon(data, idx, symbolSize, seriesScope, opts);
    if (isInit) {
      const symbolPath = this.childAt(0);
      if (!disableAnimation) {
        const target = {
          scaleX: this._sizeX,
          scaleY: this._sizeY,
          style: {
            opacity: symbolPath.style.opacity
          }
        };
        symbolPath.scaleX = symbolPath.scaleY = 0;
        symbolPath.style.opacity = 0;
        initProps(symbolPath, target, seriesModel, idx);
      }
    }
    if (disableAnimation) {
      this.childAt(0).stopAnimation("leave");
    }
  }
  _updateCommon(data, idx, symbolSize, seriesScope, opts) {
    const symbolPath = this.childAt(0);
    const seriesModel = data.hostModel;
    let emphasisItemStyle;
    let blurItemStyle;
    let selectItemStyle;
    let focus;
    let blurScope;
    let emphasisDisabled;
    let labelStatesModels;
    let hoverScale;
    let cursorStyle;
    if (seriesScope) {
      emphasisItemStyle = seriesScope.emphasisItemStyle;
      blurItemStyle = seriesScope.blurItemStyle;
      selectItemStyle = seriesScope.selectItemStyle;
      focus = seriesScope.focus;
      blurScope = seriesScope.blurScope;
      labelStatesModels = seriesScope.labelStatesModels;
      hoverScale = seriesScope.hoverScale;
      cursorStyle = seriesScope.cursorStyle;
      emphasisDisabled = seriesScope.emphasisDisabled;
    }
    if (!seriesScope || data.hasItemOption) {
      const itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx);
      const emphasisModel = itemModel.getModel("emphasis");
      emphasisItemStyle = emphasisModel.getModel("itemStyle").getItemStyle();
      selectItemStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
      blurItemStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
      focus = emphasisModel.get("focus");
      blurScope = emphasisModel.get("blurScope");
      emphasisDisabled = emphasisModel.get("disabled");
      labelStatesModels = getLabelStatesModels(itemModel);
      hoverScale = emphasisModel.getShallow("scale");
      cursorStyle = itemModel.getShallow("cursor");
    }
    const symbolRotate = data.getItemVisual(idx, "symbolRotate");
    symbolPath.attr("rotation", (symbolRotate || 0) * Math.PI / 180 || 0);
    const symbolOffset = normalizeSymbolOffset(data.getItemVisual(idx, "symbolOffset"), symbolSize);
    if (symbolOffset) {
      symbolPath.x = symbolOffset[0];
      symbolPath.y = symbolOffset[1];
    }
    cursorStyle && symbolPath.attr("cursor", cursorStyle);
    const symbolStyle = data.getItemVisual(idx, "style");
    const visualColor = symbolStyle.fill;
    if (symbolPath instanceof Image_default) {
      const pathStyle = symbolPath.style;
      symbolPath.useStyle(extend({
        image: pathStyle.image,
        x: pathStyle.x,
        y: pathStyle.y,
        width: pathStyle.width,
        height: pathStyle.height
      }, symbolStyle));
    } else {
      if (symbolPath.__isEmptyBrush) {
        symbolPath.useStyle(extend({}, symbolStyle));
      } else {
        symbolPath.useStyle(symbolStyle);
      }
      symbolPath.style.decal = null;
      symbolPath.setColor(visualColor, opts && opts.symbolInnerColor);
      symbolPath.style.strokeNoScale = true;
    }
    const liftZ = data.getItemVisual(idx, "liftZ");
    const z2Origin = this._z2;
    if (liftZ != null) {
      if (z2Origin == null) {
        this._z2 = symbolPath.z2;
        symbolPath.z2 += liftZ;
      }
    } else if (z2Origin != null) {
      symbolPath.z2 = z2Origin;
      this._z2 = null;
    }
    const useNameLabel = opts && opts.useNameLabel;
    setLabelStyle(symbolPath, labelStatesModels, {
      labelFetcher: seriesModel,
      labelDataIndex: idx,
      defaultText: getLabelDefaultText,
      inheritColor: visualColor,
      defaultOpacity: symbolStyle.opacity
    });
    function getLabelDefaultText(idx2) {
      return useNameLabel ? data.getName(idx2) : getDefaultLabel(data, idx2);
    }
    this._sizeX = symbolSize[0] / 2;
    this._sizeY = symbolSize[1] / 2;
    const emphasisState = symbolPath.ensureState("emphasis");
    emphasisState.style = emphasisItemStyle;
    symbolPath.ensureState("select").style = selectItemStyle;
    symbolPath.ensureState("blur").style = blurItemStyle;
    const scaleRatio = hoverScale == null || hoverScale === true ? Math.max(1.1, 3 / this._sizeY) : isFinite(hoverScale) && hoverScale > 0 ? +hoverScale : 1;
    emphasisState.scaleX = this._sizeX * scaleRatio;
    emphasisState.scaleY = this._sizeY * scaleRatio;
    this.setSymbolScale(1);
    toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
  }
  setSymbolScale(scale4) {
    this.scaleX = this.scaleY = scale4;
  }
  fadeOut(cb, seriesModel, opt) {
    const symbolPath = this.childAt(0);
    const dataIndex = getECData(this).dataIndex;
    const animationOpt = opt && opt.animation;
    this.silent = symbolPath.silent = true;
    if (opt && opt.fadeLabel) {
      const textContent = symbolPath.getTextContent();
      if (textContent) {
        removeElement(textContent, {
          style: {
            opacity: 0
          }
        }, seriesModel, {
          dataIndex,
          removeOpt: animationOpt,
          cb() {
            symbolPath.removeTextContent();
          }
        });
      }
    } else {
      symbolPath.removeTextContent();
    }
    removeElement(symbolPath, {
      style: {
        opacity: 0
      },
      scaleX: 0,
      scaleY: 0
    }, seriesModel, {dataIndex, cb, removeOpt: animationOpt});
  }
  static getSymbolSize(data, idx) {
    return normalizeSymbolSize(data.getItemVisual(idx, "symbolSize"));
  }
};
function driftSymbol(dx, dy) {
  this.parent.drift(dx, dy);
}
var Symbol_default = Symbol;

// src/chart/helper/SymbolDraw.ts
function symbolNeedsDraw(data, point, idx, opt) {
  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, "symbol") !== "none";
}
function normalizeUpdateOpt(opt) {
  if (opt != null && !isObject(opt)) {
    opt = {isIgnore: opt};
  }
  return opt || {};
}
function makeSeriesScope(data) {
  const seriesModel = data.hostModel;
  const emphasisModel = seriesModel.getModel("emphasis");
  return {
    emphasisItemStyle: emphasisModel.getModel("itemStyle").getItemStyle(),
    blurItemStyle: seriesModel.getModel(["blur", "itemStyle"]).getItemStyle(),
    selectItemStyle: seriesModel.getModel(["select", "itemStyle"]).getItemStyle(),
    focus: emphasisModel.get("focus"),
    blurScope: emphasisModel.get("blurScope"),
    emphasisDisabled: emphasisModel.get("disabled"),
    hoverScale: emphasisModel.get("scale"),
    labelStatesModels: getLabelStatesModels(seriesModel),
    cursorStyle: seriesModel.get("cursor")
  };
}
var SymbolDraw = class {
  constructor(SymbolCtor) {
    this.group = new Group_default();
    this._SymbolCtor = SymbolCtor || Symbol_default;
  }
  updateData(data, opt) {
    this._progressiveEls = null;
    opt = normalizeUpdateOpt(opt);
    const group = this.group;
    const seriesModel = data.hostModel;
    const oldData = this._data;
    const SymbolCtor = this._SymbolCtor;
    const disableAnimation = opt.disableAnimation;
    const seriesScope = makeSeriesScope(data);
    const symbolUpdateOpt = {disableAnimation};
    const getSymbolPoint = opt.getSymbolPoint || function(idx) {
      return data.getItemLayout(idx);
    };
    if (!oldData) {
      group.removeAll();
    }
    data.diff(oldData).add(function(newIdx) {
      const point = getSymbolPoint(newIdx);
      if (symbolNeedsDraw(data, point, newIdx, opt)) {
        const symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
        symbolEl.setPosition(point);
        data.setItemGraphicEl(newIdx, symbolEl);
        group.add(symbolEl);
      }
    }).update(function(newIdx, oldIdx) {
      let symbolEl = oldData.getItemGraphicEl(oldIdx);
      const point = getSymbolPoint(newIdx);
      if (!symbolNeedsDraw(data, point, newIdx, opt)) {
        group.remove(symbolEl);
        return;
      }
      const newSymbolType = data.getItemVisual(newIdx, "symbol") || "circle";
      const oldSymbolType = symbolEl && symbolEl.getSymbolType && symbolEl.getSymbolType();
      if (!symbolEl || oldSymbolType && oldSymbolType !== newSymbolType) {
        group.remove(symbolEl);
        symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
        symbolEl.setPosition(point);
      } else {
        symbolEl.updateData(data, newIdx, seriesScope, symbolUpdateOpt);
        const target = {
          x: point[0],
          y: point[1]
        };
        disableAnimation ? symbolEl.attr(target) : updateProps(symbolEl, target, seriesModel);
      }
      group.add(symbolEl);
      data.setItemGraphicEl(newIdx, symbolEl);
    }).remove(function(oldIdx) {
      const el = oldData.getItemGraphicEl(oldIdx);
      el && el.fadeOut(function() {
        group.remove(el);
      }, seriesModel);
    }).execute();
    this._getSymbolPoint = getSymbolPoint;
    this._data = data;
  }
  updateLayout() {
    const data = this._data;
    if (data) {
      data.eachItemGraphicEl((el, idx) => {
        const point = this._getSymbolPoint(idx);
        el.setPosition(point);
        el.markRedraw();
      });
    }
  }
  incrementalPrepareUpdate(data) {
    this._seriesScope = makeSeriesScope(data);
    this._data = null;
    this.group.removeAll();
  }
  incrementalUpdate(taskParams, data, opt) {
    this._progressiveEls = [];
    opt = normalizeUpdateOpt(opt);
    function updateIncrementalAndHover(el) {
      if (!el.isGroup) {
        el.incremental = true;
        el.ensureState("emphasis").hoverLayer = true;
      }
    }
    for (let idx = taskParams.start; idx < taskParams.end; idx++) {
      const point = data.getItemLayout(idx);
      if (symbolNeedsDraw(data, point, idx, opt)) {
        const el = new this._SymbolCtor(data, idx, this._seriesScope);
        el.traverse(updateIncrementalAndHover);
        el.setPosition(point);
        this.group.add(el);
        data.setItemGraphicEl(idx, el);
        this._progressiveEls.push(el);
      }
    }
  }
  eachRendered(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  }
  remove(enableAnimation) {
    const group = this.group;
    const data = this._data;
    if (data && enableAnimation) {
      data.eachItemGraphicEl(function(el) {
        el.fadeOut(function() {
          group.remove(el);
        }, data.hostModel);
      });
    } else {
      group.removeAll();
    }
  }
};
var SymbolDraw_default = SymbolDraw;

// src/chart/line/helper.ts
function prepareDataCoordInfo(coordSys, data, valueOrigin) {
  const baseAxis = coordSys.getBaseAxis();
  const valueAxis2 = coordSys.getOtherAxis(baseAxis);
  const valueStart = getValueStart(valueAxis2, valueOrigin);
  const baseAxisDim = baseAxis.dim;
  const valueAxisDim = valueAxis2.dim;
  const valueDim = data.mapDimension(valueAxisDim);
  const baseDim = data.mapDimension(baseAxisDim);
  const baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
  const dims = map(coordSys.dimensions, function(coordDim) {
    return data.mapDimension(coordDim);
  });
  let stacked = false;
  const stackResultDim = data.getCalculationInfo("stackResultDimension");
  if (isDimensionStacked(data, dims[0])) {
    stacked = true;
    dims[0] = stackResultDim;
  }
  if (isDimensionStacked(data, dims[1])) {
    stacked = true;
    dims[1] = stackResultDim;
  }
  return {
    dataDimsForPoint: dims,
    valueStart,
    valueAxisDim,
    baseAxisDim,
    stacked: !!stacked,
    valueDim,
    baseDim,
    baseDataOffset,
    stackedOverDimension: data.getCalculationInfo("stackedOverDimension")
  };
}
function getValueStart(valueAxis2, valueOrigin) {
  let valueStart = 0;
  const extent3 = valueAxis2.scale.getExtent();
  if (valueOrigin === "start") {
    valueStart = extent3[0];
  } else if (valueOrigin === "end") {
    valueStart = extent3[1];
  } else if (isNumber(valueOrigin) && !isNaN(valueOrigin)) {
    valueStart = valueOrigin;
  } else {
    if (extent3[0] > 0) {
      valueStart = extent3[0];
    } else if (extent3[1] < 0) {
      valueStart = extent3[1];
    }
  }
  return valueStart;
}
function getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {
  let value = NaN;
  if (dataCoordInfo.stacked) {
    value = data.get(data.getCalculationInfo("stackedOverDimension"), idx);
  }
  if (isNaN(value)) {
    value = dataCoordInfo.valueStart;
  }
  const baseDataOffset = dataCoordInfo.baseDataOffset;
  const stackedData = [];
  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);
  stackedData[1 - baseDataOffset] = value;
  return coordSys.dataToPoint(stackedData);
}

// src/chart/line/lineAnimationDiff.ts
function diffData(oldData, newData) {
  const diffResult = [];
  newData.diff(oldData).add(function(idx) {
    diffResult.push({cmd: "+", idx});
  }).update(function(newIdx, oldIdx) {
    diffResult.push({cmd: "=", idx: oldIdx, idx1: newIdx});
  }).remove(function(idx) {
    diffResult.push({cmd: "-", idx});
  }).execute();
  return diffResult;
}
function lineAnimationDiff(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
  const diff = diffData(oldData, newData);
  const currPoints = [];
  const nextPoints = [];
  const currStackedPoints = [];
  const nextStackedPoints = [];
  const status = [];
  const sortedIndices = [];
  const rawIndices = [];
  const newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);
  const oldPoints = oldData.getLayout("points") || [];
  const newPoints = newData.getLayout("points") || [];
  for (let i = 0; i < diff.length; i++) {
    const diffItem = diff[i];
    let pointAdded = true;
    let oldIdx2;
    let newIdx2;
    switch (diffItem.cmd) {
      case "=":
        oldIdx2 = diffItem.idx * 2;
        newIdx2 = diffItem.idx1 * 2;
        let currentX = oldPoints[oldIdx2];
        let currentY = oldPoints[oldIdx2 + 1];
        const nextX = newPoints[newIdx2];
        const nextY = newPoints[newIdx2 + 1];
        if (isNaN(currentX) || isNaN(currentY)) {
          currentX = nextX;
          currentY = nextY;
        }
        currPoints.push(currentX, currentY);
        nextPoints.push(nextX, nextY);
        currStackedPoints.push(oldStackedOnPoints[oldIdx2], oldStackedOnPoints[oldIdx2 + 1]);
        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
        rawIndices.push(newData.getRawIndex(diffItem.idx1));
        break;
      case "+":
        const newIdx = diffItem.idx;
        const newDataDimsForPoint = newDataOldCoordInfo.dataDimsForPoint;
        const oldPt = oldCoordSys.dataToPoint([
          newData.get(newDataDimsForPoint[0], newIdx),
          newData.get(newDataDimsForPoint[1], newIdx)
        ]);
        newIdx2 = newIdx * 2;
        currPoints.push(oldPt[0], oldPt[1]);
        nextPoints.push(newPoints[newIdx2], newPoints[newIdx2 + 1]);
        const stackedOnPoint = getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, newIdx);
        currStackedPoints.push(stackedOnPoint[0], stackedOnPoint[1]);
        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
        rawIndices.push(newData.getRawIndex(newIdx));
        break;
      case "-":
        pointAdded = false;
    }
    if (pointAdded) {
      status.push(diffItem);
      sortedIndices.push(sortedIndices.length);
    }
  }
  sortedIndices.sort(function(a, b) {
    return rawIndices[a] - rawIndices[b];
  });
  const len2 = currPoints.length;
  const sortedCurrPoints = createFloat32Array(len2);
  const sortedNextPoints = createFloat32Array(len2);
  const sortedCurrStackedPoints = createFloat32Array(len2);
  const sortedNextStackedPoints = createFloat32Array(len2);
  const sortedStatus = [];
  for (let i = 0; i < sortedIndices.length; i++) {
    const idx = sortedIndices[i];
    const i2 = i * 2;
    const idx2 = idx * 2;
    sortedCurrPoints[i2] = currPoints[idx2];
    sortedCurrPoints[i2 + 1] = currPoints[idx2 + 1];
    sortedNextPoints[i2] = nextPoints[idx2];
    sortedNextPoints[i2 + 1] = nextPoints[idx2 + 1];
    sortedCurrStackedPoints[i2] = currStackedPoints[idx2];
    sortedCurrStackedPoints[i2 + 1] = currStackedPoints[idx2 + 1];
    sortedNextStackedPoints[i2] = nextStackedPoints[idx2];
    sortedNextStackedPoints[i2 + 1] = nextStackedPoints[idx2 + 1];
    sortedStatus[i] = status[idx];
  }
  return {
    current: sortedCurrPoints,
    next: sortedNextPoints,
    stackedOnCurrent: sortedCurrStackedPoints,
    stackedOnNext: sortedNextStackedPoints,
    status: sortedStatus
  };
}

// src/chart/line/poly.ts
var mathMin6 = Math.min;
var mathMax6 = Math.max;
function isPointNull(x, y) {
  return isNaN(x) || isNaN(y);
}
function drawSegment(ctx, points4, start2, segLen, allLen, dir3, smooth, smoothMonotone, connectNulls) {
  let prevX;
  let prevY;
  let cpx0;
  let cpy0;
  let cpx1;
  let cpy1;
  let idx = start2;
  let k = 0;
  for (; k < segLen; k++) {
    let x = points4[idx * 2];
    let y = points4[idx * 2 + 1];
    if (idx >= allLen || idx < 0) {
      break;
    }
    if (isPointNull(x, y)) {
      if (connectNulls) {
        idx += dir3;
        continue;
      }
      break;
    }
    if (idx === start2) {
      ctx[dir3 > 0 ? "moveTo" : "lineTo"](x, y);
      cpx0 = x;
      cpy0 = y;
    } else {
      let dx = x - prevX;
      let dy = y - prevY;
      if (dx * dx + dy * dy < 0.5) {
        idx += dir3;
        continue;
      }
      if (smooth > 0) {
        let nextIdx = idx + dir3;
        let nextX = points4[nextIdx * 2];
        let nextY = points4[nextIdx * 2 + 1];
        while (nextX === x && nextY === y && k < segLen) {
          k++;
          nextIdx += dir3;
          idx += dir3;
          nextX = points4[nextIdx * 2];
          nextY = points4[nextIdx * 2 + 1];
          x = points4[idx * 2];
          y = points4[idx * 2 + 1];
          dx = x - prevX;
          dy = y - prevY;
        }
        let tmpK = k + 1;
        if (connectNulls) {
          while (isPointNull(nextX, nextY) && tmpK < segLen) {
            tmpK++;
            nextIdx += dir3;
            nextX = points4[nextIdx * 2];
            nextY = points4[nextIdx * 2 + 1];
          }
        }
        let ratioNextSeg = 0.5;
        let vx = 0;
        let vy = 0;
        let nextCpx0;
        let nextCpy0;
        if (tmpK >= segLen || isPointNull(nextX, nextY)) {
          cpx1 = x;
          cpy1 = y;
        } else {
          vx = nextX - prevX;
          vy = nextY - prevY;
          const dx0 = x - prevX;
          const dx1 = nextX - x;
          const dy0 = y - prevY;
          const dy1 = nextY - y;
          let lenPrevSeg;
          let lenNextSeg;
          if (smoothMonotone === "x") {
            lenPrevSeg = Math.abs(dx0);
            lenNextSeg = Math.abs(dx1);
            const dir4 = vx > 0 ? 1 : -1;
            cpx1 = x - dir4 * lenPrevSeg * smooth;
            cpy1 = y;
            nextCpx0 = x + dir4 * lenNextSeg * smooth;
            nextCpy0 = y;
          } else if (smoothMonotone === "y") {
            lenPrevSeg = Math.abs(dy0);
            lenNextSeg = Math.abs(dy1);
            const dir4 = vy > 0 ? 1 : -1;
            cpx1 = x;
            cpy1 = y - dir4 * lenPrevSeg * smooth;
            nextCpx0 = x;
            nextCpy0 = y + dir4 * lenNextSeg * smooth;
          } else {
            lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);
            lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1);
            ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
            cpx1 = x - vx * smooth * (1 - ratioNextSeg);
            cpy1 = y - vy * smooth * (1 - ratioNextSeg);
            nextCpx0 = x + vx * smooth * ratioNextSeg;
            nextCpy0 = y + vy * smooth * ratioNextSeg;
            nextCpx0 = mathMin6(nextCpx0, mathMax6(nextX, x));
            nextCpy0 = mathMin6(nextCpy0, mathMax6(nextY, y));
            nextCpx0 = mathMax6(nextCpx0, mathMin6(nextX, x));
            nextCpy0 = mathMax6(nextCpy0, mathMin6(nextY, y));
            vx = nextCpx0 - x;
            vy = nextCpy0 - y;
            cpx1 = x - vx * lenPrevSeg / lenNextSeg;
            cpy1 = y - vy * lenPrevSeg / lenNextSeg;
            cpx1 = mathMin6(cpx1, mathMax6(prevX, x));
            cpy1 = mathMin6(cpy1, mathMax6(prevY, y));
            cpx1 = mathMax6(cpx1, mathMin6(prevX, x));
            cpy1 = mathMax6(cpy1, mathMin6(prevY, y));
            vx = x - cpx1;
            vy = y - cpy1;
            nextCpx0 = x + vx * lenNextSeg / lenPrevSeg;
            nextCpy0 = y + vy * lenNextSeg / lenPrevSeg;
          }
        }
        ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x, y);
        cpx0 = nextCpx0;
        cpy0 = nextCpy0;
      } else {
        ctx.lineTo(x, y);
      }
    }
    prevX = x;
    prevY = y;
    idx += dir3;
  }
  return k;
}
var ECPolylineShape = class {
  constructor() {
    this.smooth = 0;
    this.smoothConstraint = true;
  }
};
var ECPolyline = class extends Path_default {
  constructor(opts) {
    super(opts);
    this.type = "ec-polyline";
  }
  getDefaultStyle() {
    return {
      stroke: "#000",
      fill: null
    };
  }
  getDefaultShape() {
    return new ECPolylineShape();
  }
  buildPath(ctx, shape) {
    const points4 = shape.points;
    let i = 0;
    let len2 = points4.length / 2;
    if (shape.connectNulls) {
      for (; len2 > 0; len2--) {
        if (!isPointNull(points4[len2 * 2 - 2], points4[len2 * 2 - 1])) {
          break;
        }
      }
      for (; i < len2; i++) {
        if (!isPointNull(points4[i * 2], points4[i * 2 + 1])) {
          break;
        }
      }
    }
    while (i < len2) {
      i += drawSegment(ctx, points4, i, len2, len2, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
    }
  }
  getPointOn(xOrY, dim) {
    if (!this.path) {
      this.createPathProxy();
      this.buildPath(this.path, this.shape);
    }
    const path = this.path;
    const data = path.data;
    const CMD6 = PathProxy_default.CMD;
    let x0;
    let y0;
    const isDimX = dim === "x";
    const roots2 = [];
    for (let i = 0; i < data.length; ) {
      const cmd = data[i++];
      let x;
      let y;
      let x2;
      let y2;
      let x3;
      let y3;
      let t;
      switch (cmd) {
        case CMD6.M:
          x0 = data[i++];
          y0 = data[i++];
          break;
        case CMD6.L:
          x = data[i++];
          y = data[i++];
          t = isDimX ? (xOrY - x0) / (x - x0) : (xOrY - y0) / (y - y0);
          if (t <= 1 && t >= 0) {
            const val = isDimX ? (y - y0) * t + y0 : (x - x0) * t + x0;
            return isDimX ? [xOrY, val] : [val, xOrY];
          }
          x0 = x;
          y0 = y;
          break;
        case CMD6.C:
          x = data[i++];
          y = data[i++];
          x2 = data[i++];
          y2 = data[i++];
          x3 = data[i++];
          y3 = data[i++];
          const nRoot = isDimX ? cubicRootAt(x0, x, x2, x3, xOrY, roots2) : cubicRootAt(y0, y, y2, y3, xOrY, roots2);
          if (nRoot > 0) {
            for (let i2 = 0; i2 < nRoot; i2++) {
              const t2 = roots2[i2];
              if (t2 <= 1 && t2 >= 0) {
                const val = isDimX ? cubicAt(y0, y, y2, y3, t2) : cubicAt(x0, x, x2, x3, t2);
                return isDimX ? [xOrY, val] : [val, xOrY];
              }
            }
          }
          x0 = x3;
          y0 = y3;
          break;
      }
    }
  }
};
var ECPolygonShape = class extends ECPolylineShape {
};
var ECPolygon = class extends Path_default {
  constructor(opts) {
    super(opts);
    this.type = "ec-polygon";
  }
  getDefaultShape() {
    return new ECPolygonShape();
  }
  buildPath(ctx, shape) {
    const points4 = shape.points;
    const stackedOnPoints = shape.stackedOnPoints;
    let i = 0;
    let len2 = points4.length / 2;
    const smoothMonotone = shape.smoothMonotone;
    if (shape.connectNulls) {
      for (; len2 > 0; len2--) {
        if (!isPointNull(points4[len2 * 2 - 2], points4[len2 * 2 - 1])) {
          break;
        }
      }
      for (; i < len2; i++) {
        if (!isPointNull(points4[i * 2], points4[i * 2 + 1])) {
          break;
        }
      }
    }
    while (i < len2) {
      const k = drawSegment(ctx, points4, i, len2, len2, 1, shape.smooth, smoothMonotone, shape.connectNulls);
      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len2, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
      i += k + 1;
      ctx.closePath();
    }
  }
};

// src/chart/helper/createClipPathFromCoordSys.ts
function createGridClipPath(cartesian, hasAnimation, seriesModel, done, during) {
  const rect = cartesian.getArea();
  let x = rect.x;
  let y = rect.y;
  let width = rect.width;
  let height = rect.height;
  const lineWidth = seriesModel.get(["lineStyle", "width"]) || 2;
  x -= lineWidth / 2;
  y -= lineWidth / 2;
  width += lineWidth;
  height += lineWidth;
  width = Math.ceil(width);
  if (x !== Math.floor(x)) {
    x = Math.floor(x);
    width++;
  }
  const clipPath = new Rect_default({
    shape: {
      x,
      y,
      width,
      height
    }
  });
  if (hasAnimation) {
    const baseAxis = cartesian.getBaseAxis();
    const isHorizontal = baseAxis.isHorizontal();
    const isAxisInversed = baseAxis.inverse;
    if (isHorizontal) {
      if (isAxisInversed) {
        clipPath.shape.x += width;
      }
      clipPath.shape.width = 0;
    } else {
      if (!isAxisInversed) {
        clipPath.shape.y += height;
      }
      clipPath.shape.height = 0;
    }
    const duringCb = isFunction(during) ? (percent) => {
      during(percent, clipPath);
    } : null;
    initProps(clipPath, {
      shape: {
        width,
        height,
        x,
        y
      }
    }, seriesModel, null, done, duringCb);
  }
  return clipPath;
}
function createPolarClipPath(polar, hasAnimation, seriesModel) {
  const sectorArea = polar.getArea();
  const r0 = round(sectorArea.r0, 1);
  const r = round(sectorArea.r, 1);
  const clipPath = new Sector_default({
    shape: {
      cx: round(polar.cx, 1),
      cy: round(polar.cy, 1),
      r0,
      r,
      startAngle: sectorArea.startAngle,
      endAngle: sectorArea.endAngle,
      clockwise: sectorArea.clockwise
    }
  });
  if (hasAnimation) {
    const isRadial = polar.getBaseAxis().dim === "angle";
    if (isRadial) {
      clipPath.shape.endAngle = sectorArea.startAngle;
    } else {
      clipPath.shape.r = r0;
    }
    initProps(clipPath, {
      shape: {
        endAngle: sectorArea.endAngle,
        r
      }
    }, seriesModel);
  }
  return clipPath;
}
function createClipPath(coordSys, hasAnimation, seriesModel, done, during) {
  if (!coordSys) {
    return null;
  } else if (coordSys.type === "polar") {
    return createPolarClipPath(coordSys, hasAnimation, seriesModel);
  } else if (coordSys.type === "cartesian2d") {
    return createGridClipPath(coordSys, hasAnimation, seriesModel, done, during);
  }
  return null;
}

// src/coord/CoordinateSystem.ts
function isCoordinateSystemType(coordSys, type) {
  return coordSys.type === type;
}

// src/chart/line/LineView.ts
function isPointsSame(points1, points22) {
  if (points1.length !== points22.length) {
    return;
  }
  for (let i = 0; i < points1.length; i++) {
    if (points1[i] !== points22[i]) {
      return;
    }
  }
  return true;
}
function bboxFromPoints(points4) {
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  for (let i = 0; i < points4.length; ) {
    const x = points4[i++];
    const y = points4[i++];
    if (!isNaN(x)) {
      minX = Math.min(x, minX);
      maxX = Math.max(x, maxX);
    }
    if (!isNaN(y)) {
      minY = Math.min(y, minY);
      maxY = Math.max(y, maxY);
    }
  }
  return [
    [minX, minY],
    [maxX, maxY]
  ];
}
function getBoundingDiff(points1, points22) {
  const [min1, max1] = bboxFromPoints(points1);
  const [min23, max23] = bboxFromPoints(points22);
  return Math.max(Math.abs(min1[0] - min23[0]), Math.abs(min1[1] - min23[1]), Math.abs(max1[0] - max23[0]), Math.abs(max1[1] - max23[1]));
}
function getSmooth(smooth) {
  return isNumber(smooth) ? smooth : smooth ? 0.5 : 0;
}
function getStackedOnPoints(coordSys, data, dataCoordInfo) {
  if (!dataCoordInfo.valueDim) {
    return [];
  }
  const len2 = data.count();
  const points4 = createFloat32Array(len2 * 2);
  for (let idx = 0; idx < len2; idx++) {
    const pt = getStackedOnPoint(dataCoordInfo, coordSys, data, idx);
    points4[idx * 2] = pt[0];
    points4[idx * 2 + 1] = pt[1];
  }
  return points4;
}
function turnPointsIntoStep(points4, coordSys, stepTurnAt, connectNulls) {
  const baseAxis = coordSys.getBaseAxis();
  const baseIndex = baseAxis.dim === "x" || baseAxis.dim === "radius" ? 0 : 1;
  const stepPoints = [];
  let i = 0;
  const stepPt = [];
  const pt = [];
  const nextPt = [];
  const filteredPoints = [];
  if (connectNulls) {
    for (i = 0; i < points4.length; i += 2) {
      if (!isNaN(points4[i]) && !isNaN(points4[i + 1])) {
        filteredPoints.push(points4[i], points4[i + 1]);
      }
    }
    points4 = filteredPoints;
  }
  for (i = 0; i < points4.length - 2; i += 2) {
    nextPt[0] = points4[i + 2];
    nextPt[1] = points4[i + 3];
    pt[0] = points4[i];
    pt[1] = points4[i + 1];
    stepPoints.push(pt[0], pt[1]);
    switch (stepTurnAt) {
      case "end":
        stepPt[baseIndex] = nextPt[baseIndex];
        stepPt[1 - baseIndex] = pt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
        break;
      case "middle":
        const middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
        const stepPt2 = [];
        stepPt[baseIndex] = stepPt2[baseIndex] = middle;
        stepPt[1 - baseIndex] = pt[1 - baseIndex];
        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
        stepPoints.push(stepPt2[0], stepPt2[1]);
        break;
      default:
        stepPt[baseIndex] = pt[baseIndex];
        stepPt[1 - baseIndex] = nextPt[1 - baseIndex];
        stepPoints.push(stepPt[0], stepPt[1]);
    }
  }
  stepPoints.push(points4[i++], points4[i++]);
  return stepPoints;
}
function clipColorStops(colorStops, maxSize) {
  const newColorStops = [];
  const len2 = colorStops.length;
  let prevOutOfRangeColorStop;
  let prevInRangeColorStop;
  function lerpStop(stop0, stop1, clippedCoord) {
    const coord0 = stop0.coord;
    const p = (clippedCoord - coord0) / (stop1.coord - coord0);
    const color2 = lerp2(p, [stop0.color, stop1.color]);
    return {coord: clippedCoord, color: color2};
  }
  for (let i = 0; i < len2; i++) {
    const stop2 = colorStops[i];
    const coord = stop2.coord;
    if (coord < 0) {
      prevOutOfRangeColorStop = stop2;
    } else if (coord > maxSize) {
      if (prevInRangeColorStop) {
        newColorStops.push(lerpStop(prevInRangeColorStop, stop2, maxSize));
      } else if (prevOutOfRangeColorStop) {
        newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop2, 0), lerpStop(prevOutOfRangeColorStop, stop2, maxSize));
      }
      break;
    } else {
      if (prevOutOfRangeColorStop) {
        newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop2, 0));
        prevOutOfRangeColorStop = null;
      }
      newColorStops.push(stop2);
      prevInRangeColorStop = stop2;
    }
  }
  return newColorStops;
}
function getVisualGradient(data, coordSys, api2) {
  const visualMetaList = data.getVisual("visualMeta");
  if (!visualMetaList || !visualMetaList.length || !data.count()) {
    return;
  }
  if (coordSys.type !== "cartesian2d") {
    if (true) {
      console.warn("Visual map on line style is only supported on cartesian2d.");
    }
    return;
  }
  let coordDim;
  let visualMeta;
  for (let i = visualMetaList.length - 1; i >= 0; i--) {
    const dimInfo = data.getDimensionInfo(visualMetaList[i].dimension);
    coordDim = dimInfo && dimInfo.coordDim;
    if (coordDim === "x" || coordDim === "y") {
      visualMeta = visualMetaList[i];
      break;
    }
  }
  if (!visualMeta) {
    if (true) {
      console.warn("Visual map on line style only support x or y dimension.");
    }
    return;
  }
  const axis = coordSys.getAxis(coordDim);
  const colorStops = map(visualMeta.stops, function(stop2) {
    return {
      coord: axis.toGlobalCoord(axis.dataToCoord(stop2.value)),
      color: stop2.color
    };
  });
  const stopLen = colorStops.length;
  const outerColors = visualMeta.outerColors.slice();
  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
    colorStops.reverse();
    outerColors.reverse();
  }
  const colorStopsInRange = clipColorStops(colorStops, coordDim === "x" ? api2.getWidth() : api2.getHeight());
  const inRangeStopLen = colorStopsInRange.length;
  if (!inRangeStopLen && stopLen) {
    return colorStops[0].coord < 0 ? outerColors[1] ? outerColors[1] : colorStops[stopLen - 1].color : outerColors[0] ? outerColors[0] : colorStops[0].color;
  }
  const tinyExtent = 10;
  const minCoord = colorStopsInRange[0].coord - tinyExtent;
  const maxCoord = colorStopsInRange[inRangeStopLen - 1].coord + tinyExtent;
  const coordSpan = maxCoord - minCoord;
  if (coordSpan < 1e-3) {
    return "transparent";
  }
  each(colorStopsInRange, function(stop2) {
    stop2.offset = (stop2.coord - minCoord) / coordSpan;
  });
  colorStopsInRange.push({
    offset: inRangeStopLen ? colorStopsInRange[inRangeStopLen - 1].offset : 0.5,
    color: outerColors[1] || "transparent"
  });
  colorStopsInRange.unshift({
    offset: inRangeStopLen ? colorStopsInRange[0].offset : 0.5,
    color: outerColors[0] || "transparent"
  });
  const gradient = new LinearGradient_default(0, 0, 0, 0, colorStopsInRange, true);
  gradient[coordDim] = minCoord;
  gradient[coordDim + "2"] = maxCoord;
  return gradient;
}
function getIsIgnoreFunc(seriesModel, data, coordSys) {
  const showAllSymbol = seriesModel.get("showAllSymbol");
  const isAuto = showAllSymbol === "auto";
  if (showAllSymbol && !isAuto) {
    return;
  }
  const categoryAxis2 = coordSys.getAxesByScale("ordinal")[0];
  if (!categoryAxis2) {
    return;
  }
  if (isAuto && canShowAllSymbolForCategory(categoryAxis2, data)) {
    return;
  }
  const categoryDataDim = data.mapDimension(categoryAxis2.dim);
  const labelMap = {};
  each(categoryAxis2.getViewLabels(), function(labelItem) {
    const ordinalNumber = categoryAxis2.scale.getRawOrdinalNumber(labelItem.tickValue);
    labelMap[ordinalNumber] = 1;
  });
  return function(dataIndex) {
    return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));
  };
}
function canShowAllSymbolForCategory(categoryAxis2, data) {
  const axisExtent = categoryAxis2.getExtent();
  let availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis2.scale.count();
  isNaN(availSize) && (availSize = 0);
  const dataLen = data.count();
  const step = Math.max(1, Math.round(dataLen / 5));
  for (let dataIndex = 0; dataIndex < dataLen; dataIndex += step) {
    if (Symbol_default.getSymbolSize(data, dataIndex)[categoryAxis2.isHorizontal() ? 1 : 0] * 1.5 > availSize) {
      return false;
    }
  }
  return true;
}
function isPointNull2(x, y) {
  return isNaN(x) || isNaN(y);
}
function getLastIndexNotNull(points4) {
  let len2 = points4.length / 2;
  for (; len2 > 0; len2--) {
    if (!isPointNull2(points4[len2 * 2 - 2], points4[len2 * 2 - 1])) {
      break;
    }
  }
  return len2 - 1;
}
function getPointAtIndex(points4, idx) {
  return [points4[idx * 2], points4[idx * 2 + 1]];
}
function getIndexRange(points4, xOrY, dim) {
  const len2 = points4.length / 2;
  const dimIdx = dim === "x" ? 0 : 1;
  let a;
  let b;
  let prevIndex = 0;
  let nextIndex = -1;
  for (let i = 0; i < len2; i++) {
    b = points4[i * 2 + dimIdx];
    if (isNaN(b) || isNaN(points4[i * 2 + 1 - dimIdx])) {
      continue;
    }
    if (i === 0) {
      a = b;
      continue;
    }
    if (a <= xOrY && b >= xOrY || a >= xOrY && b <= xOrY) {
      nextIndex = i;
      break;
    }
    prevIndex = i;
    a = b;
  }
  return {
    range: [prevIndex, nextIndex],
    t: (xOrY - a) / (b - a)
  };
}
function anyStateShowEndLabel(seriesModel) {
  if (seriesModel.get(["endLabel", "show"])) {
    return true;
  }
  for (let i = 0; i < SPECIAL_STATES.length; i++) {
    if (seriesModel.get([SPECIAL_STATES[i], "endLabel", "show"])) {
      return true;
    }
  }
  return false;
}
function createLineClipPath(lineView, coordSys, hasAnimation, seriesModel) {
  if (isCoordinateSystemType(coordSys, "cartesian2d")) {
    const endLabelModel = seriesModel.getModel("endLabel");
    const valueAnimation = endLabelModel.get("valueAnimation");
    const data = seriesModel.getData();
    const labelAnimationRecord = {lastFrameIndex: 0};
    const during = anyStateShowEndLabel(seriesModel) ? (percent, clipRect) => {
      lineView._endLabelOnDuring(percent, clipRect, data, labelAnimationRecord, valueAnimation, endLabelModel, coordSys);
    } : null;
    const isHorizontal = coordSys.getBaseAxis().isHorizontal();
    const clipPath = createGridClipPath(coordSys, hasAnimation, seriesModel, () => {
      const endLabel = lineView._endLabel;
      if (endLabel && hasAnimation) {
        if (labelAnimationRecord.originalX != null) {
          endLabel.attr({
            x: labelAnimationRecord.originalX,
            y: labelAnimationRecord.originalY
          });
        }
      }
    }, during);
    if (!seriesModel.get("clip", true)) {
      const rectShape = clipPath.shape;
      const expandSize = Math.max(rectShape.width, rectShape.height);
      if (isHorizontal) {
        rectShape.y -= expandSize;
        rectShape.height += expandSize * 2;
      } else {
        rectShape.x -= expandSize;
        rectShape.width += expandSize * 2;
      }
    }
    if (during) {
      during(1, clipPath);
    }
    return clipPath;
  } else {
    if (true) {
      if (seriesModel.get(["endLabel", "show"])) {
        console.warn("endLabel is not supported for lines in polar systems.");
      }
    }
    return createPolarClipPath(coordSys, hasAnimation, seriesModel);
  }
}
function getEndLabelStateSpecified(endLabelModel, coordSys) {
  const baseAxis = coordSys.getBaseAxis();
  const isHorizontal = baseAxis.isHorizontal();
  const isBaseInversed = baseAxis.inverse;
  const align = isHorizontal ? isBaseInversed ? "right" : "left" : "center";
  const verticalAlign = isHorizontal ? "middle" : isBaseInversed ? "top" : "bottom";
  return {
    normal: {
      align: endLabelModel.get("align") || align,
      verticalAlign: endLabelModel.get("verticalAlign") || verticalAlign
    }
  };
}
var LineView = class extends Chart_default {
  init() {
    const lineGroup = new Group_default();
    const symbolDraw = new SymbolDraw_default();
    this.group.add(symbolDraw.group);
    this._symbolDraw = symbolDraw;
    this._lineGroup = lineGroup;
  }
  render(seriesModel, ecModel, api2) {
    const coordSys = seriesModel.coordinateSystem;
    const group = this.group;
    const data = seriesModel.getData();
    const lineStyleModel = seriesModel.getModel("lineStyle");
    const areaStyleModel = seriesModel.getModel("areaStyle");
    let points4 = data.getLayout("points") || [];
    const isCoordSysPolar = coordSys.type === "polar";
    const prevCoordSys = this._coordSys;
    const symbolDraw = this._symbolDraw;
    let polyline = this._polyline;
    let polygon = this._polygon;
    const lineGroup = this._lineGroup;
    const hasAnimation = !ecModel.ssr && seriesModel.get("animation");
    const isAreaChart = !areaStyleModel.isEmpty();
    const valueOrigin = areaStyleModel.get("origin");
    const dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin);
    let stackedOnPoints = isAreaChart && getStackedOnPoints(coordSys, data, dataCoordInfo);
    const showSymbol = seriesModel.get("showSymbol");
    const connectNulls = seriesModel.get("connectNulls");
    const isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys);
    const oldData = this._data;
    oldData && oldData.eachItemGraphicEl(function(el, idx) {
      if (el.__temp) {
        group.remove(el);
        oldData.setItemGraphicEl(idx, null);
      }
    });
    if (!showSymbol) {
      symbolDraw.remove();
    }
    group.add(lineGroup);
    const step = !isCoordSysPolar ? seriesModel.get("step") : false;
    let clipShapeForSymbol;
    if (coordSys && coordSys.getArea && seriesModel.get("clip", true)) {
      clipShapeForSymbol = coordSys.getArea();
      if (clipShapeForSymbol.width != null) {
        clipShapeForSymbol.x -= 0.1;
        clipShapeForSymbol.y -= 0.1;
        clipShapeForSymbol.width += 0.2;
        clipShapeForSymbol.height += 0.2;
      } else if (clipShapeForSymbol.r0) {
        clipShapeForSymbol.r0 -= 0.5;
        clipShapeForSymbol.r += 0.5;
      }
    }
    this._clipShapeForSymbol = clipShapeForSymbol;
    const visualColor = getVisualGradient(data, coordSys, api2) || data.getVisual("style")[data.getVisual("drawType")];
    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
      showSymbol && symbolDraw.updateData(data, {
        isIgnore: isIgnoreFunc,
        clipShape: clipShapeForSymbol,
        disableAnimation: true,
        getSymbolPoint(idx) {
          return [points4[idx * 2], points4[idx * 2 + 1]];
        }
      });
      hasAnimation && this._initSymbolLabelAnimation(data, coordSys, clipShapeForSymbol);
      if (step) {
        points4 = turnPointsIntoStep(points4, coordSys, step, connectNulls);
        if (stackedOnPoints) {
          stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step, connectNulls);
        }
      }
      polyline = this._newPolyline(points4);
      if (isAreaChart) {
        polygon = this._newPolygon(points4, stackedOnPoints);
      } else if (polygon) {
        lineGroup.remove(polygon);
        polygon = this._polygon = null;
      }
      if (!isCoordSysPolar) {
        this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
      }
      lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
    } else {
      if (isAreaChart && !polygon) {
        polygon = this._newPolygon(points4, stackedOnPoints);
      } else if (polygon && !isAreaChart) {
        lineGroup.remove(polygon);
        polygon = this._polygon = null;
      }
      if (!isCoordSysPolar) {
        this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor));
      }
      const oldClipPath = lineGroup.getClipPath();
      if (oldClipPath) {
        const newClipPath = createLineClipPath(this, coordSys, false, seriesModel);
        initProps(oldClipPath, {
          shape: newClipPath.shape
        }, seriesModel);
      } else {
        lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
      }
      showSymbol && symbolDraw.updateData(data, {
        isIgnore: isIgnoreFunc,
        clipShape: clipShapeForSymbol,
        disableAnimation: true,
        getSymbolPoint(idx) {
          return [points4[idx * 2], points4[idx * 2 + 1]];
        }
      });
      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points4)) {
        if (hasAnimation) {
          this._doUpdateAnimation(data, stackedOnPoints, coordSys, api2, step, valueOrigin, connectNulls);
        } else {
          if (step) {
            points4 = turnPointsIntoStep(points4, coordSys, step, connectNulls);
            if (stackedOnPoints) {
              stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step, connectNulls);
            }
          }
          polyline.setShape({
            points: points4
          });
          polygon && polygon.setShape({
            points: points4,
            stackedOnPoints
          });
        }
      }
    }
    const emphasisModel = seriesModel.getModel("emphasis");
    const focus = emphasisModel.get("focus");
    const blurScope = emphasisModel.get("blurScope");
    const emphasisDisabled = emphasisModel.get("disabled");
    polyline.useStyle(defaults(lineStyleModel.getLineStyle(), {
      fill: "none",
      stroke: visualColor,
      lineJoin: "bevel"
    }));
    setStatesStylesFromModel(polyline, seriesModel, "lineStyle");
    if (polyline.style.lineWidth > 0 && seriesModel.get(["emphasis", "lineStyle", "width"]) === "bolder") {
      const emphasisLineStyle = polyline.getState("emphasis").style;
      emphasisLineStyle.lineWidth = +polyline.style.lineWidth + 1;
    }
    getECData(polyline).seriesIndex = seriesModel.seriesIndex;
    toggleHoverEmphasis(polyline, focus, blurScope, emphasisDisabled);
    const smooth = getSmooth(seriesModel.get("smooth"));
    const smoothMonotone = seriesModel.get("smoothMonotone");
    polyline.setShape({
      smooth,
      smoothMonotone,
      connectNulls
    });
    if (polygon) {
      const stackedOnSeries = data.getCalculationInfo("stackedOnSeries");
      let stackedOnSmooth = 0;
      polygon.useStyle(defaults(areaStyleModel.getAreaStyle(), {
        fill: visualColor,
        opacity: 0.7,
        lineJoin: "bevel",
        decal: data.getVisual("style").decal
      }));
      if (stackedOnSeries) {
        stackedOnSmooth = getSmooth(stackedOnSeries.get("smooth"));
      }
      polygon.setShape({
        smooth,
        stackedOnSmooth,
        smoothMonotone,
        connectNulls
      });
      setStatesStylesFromModel(polygon, seriesModel, "areaStyle");
      getECData(polygon).seriesIndex = seriesModel.seriesIndex;
      toggleHoverEmphasis(polygon, focus, blurScope, emphasisDisabled);
    }
    const changePolyState = (toState) => {
      this._changePolyState(toState);
    };
    data.eachItemGraphicEl(function(el) {
      el && (el.onHoverStateChange = changePolyState);
    });
    this._polyline.onHoverStateChange = changePolyState;
    this._data = data;
    this._coordSys = coordSys;
    this._stackedOnPoints = stackedOnPoints;
    this._points = points4;
    this._step = step;
    this._valueOrigin = valueOrigin;
    if (seriesModel.get("triggerLineEvent")) {
      this.packEventData(seriesModel, polyline);
      polygon && this.packEventData(seriesModel, polygon);
    }
  }
  packEventData(seriesModel, el) {
    getECData(el).eventData = {
      componentType: "series",
      componentSubType: "line",
      componentIndex: seriesModel.componentIndex,
      seriesIndex: seriesModel.seriesIndex,
      seriesName: seriesModel.name,
      seriesType: "line"
    };
  }
  highlight(seriesModel, ecModel, api2, payload) {
    const data = seriesModel.getData();
    const dataIndex = queryDataIndex(data, payload);
    this._changePolyState("emphasis");
    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
      const points4 = data.getLayout("points");
      let symbol = data.getItemGraphicEl(dataIndex);
      if (!symbol) {
        const x = points4[dataIndex * 2];
        const y = points4[dataIndex * 2 + 1];
        if (isNaN(x) || isNaN(y)) {
          return;
        }
        if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(x, y)) {
          return;
        }
        const zlevel = seriesModel.get("zlevel") || 0;
        const z = seriesModel.get("z") || 0;
        symbol = new Symbol_default(data, dataIndex);
        symbol.x = x;
        symbol.y = y;
        symbol.setZ(zlevel, z);
        const symbolLabel = symbol.getSymbolPath().getTextContent();
        if (symbolLabel) {
          symbolLabel.zlevel = zlevel;
          symbolLabel.z = z;
          symbolLabel.z2 = this._polyline.z2 + 1;
        }
        symbol.__temp = true;
        data.setItemGraphicEl(dataIndex, symbol);
        symbol.stopSymbolAnimation(true);
        this.group.add(symbol);
      }
      symbol.highlight();
    } else {
      Chart_default.prototype.highlight.call(this, seriesModel, ecModel, api2, payload);
    }
  }
  downplay(seriesModel, ecModel, api2, payload) {
    const data = seriesModel.getData();
    const dataIndex = queryDataIndex(data, payload);
    this._changePolyState("normal");
    if (dataIndex != null && dataIndex >= 0) {
      const symbol = data.getItemGraphicEl(dataIndex);
      if (symbol) {
        if (symbol.__temp) {
          data.setItemGraphicEl(dataIndex, null);
          this.group.remove(symbol);
        } else {
          symbol.downplay();
        }
      }
    } else {
      Chart_default.prototype.downplay.call(this, seriesModel, ecModel, api2, payload);
    }
  }
  _changePolyState(toState) {
    const polygon = this._polygon;
    setStatesFlag(this._polyline, toState);
    polygon && setStatesFlag(polygon, toState);
  }
  _newPolyline(points4) {
    let polyline = this._polyline;
    if (polyline) {
      this._lineGroup.remove(polyline);
    }
    polyline = new ECPolyline({
      shape: {
        points: points4
      },
      segmentIgnoreThreshold: 2,
      z2: 10
    });
    this._lineGroup.add(polyline);
    this._polyline = polyline;
    return polyline;
  }
  _newPolygon(points4, stackedOnPoints) {
    let polygon = this._polygon;
    if (polygon) {
      this._lineGroup.remove(polygon);
    }
    polygon = new ECPolygon({
      shape: {
        points: points4,
        stackedOnPoints
      },
      segmentIgnoreThreshold: 2
    });
    this._lineGroup.add(polygon);
    this._polygon = polygon;
    return polygon;
  }
  _initSymbolLabelAnimation(data, coordSys, clipShape) {
    let isHorizontalOrRadial;
    let isCoordSysPolar;
    const baseAxis = coordSys.getBaseAxis();
    const isAxisInverse = baseAxis.inverse;
    if (coordSys.type === "cartesian2d") {
      isHorizontalOrRadial = baseAxis.isHorizontal();
      isCoordSysPolar = false;
    } else if (coordSys.type === "polar") {
      isHorizontalOrRadial = baseAxis.dim === "angle";
      isCoordSysPolar = true;
    }
    const seriesModel = data.hostModel;
    let seriesDuration = seriesModel.get("animationDuration");
    if (isFunction(seriesDuration)) {
      seriesDuration = seriesDuration(null);
    }
    const seriesDelay = seriesModel.get("animationDelay") || 0;
    const seriesDelayValue = isFunction(seriesDelay) ? seriesDelay(null) : seriesDelay;
    data.eachItemGraphicEl(function(symbol, idx) {
      const el = symbol;
      if (el) {
        const point = [symbol.x, symbol.y];
        let start2;
        let end2;
        let current;
        if (clipShape) {
          if (isCoordSysPolar) {
            const polarClip = clipShape;
            const coord = coordSys.pointToCoord(point);
            if (isHorizontalOrRadial) {
              start2 = polarClip.startAngle;
              end2 = polarClip.endAngle;
              current = -coord[1] / 180 * Math.PI;
            } else {
              start2 = polarClip.r0;
              end2 = polarClip.r;
              current = coord[0];
            }
          } else {
            const gridClip = clipShape;
            if (isHorizontalOrRadial) {
              start2 = gridClip.x;
              end2 = gridClip.x + gridClip.width;
              current = symbol.x;
            } else {
              start2 = gridClip.y + gridClip.height;
              end2 = gridClip.y;
              current = symbol.y;
            }
          }
        }
        let ratio = end2 === start2 ? 0 : (current - start2) / (end2 - start2);
        if (isAxisInverse) {
          ratio = 1 - ratio;
        }
        const delay = isFunction(seriesDelay) ? seriesDelay(idx) : seriesDuration * ratio + seriesDelayValue;
        const symbolPath = el.getSymbolPath();
        const text = symbolPath.getTextContent();
        el.attr({scaleX: 0, scaleY: 0});
        el.animateTo({
          scaleX: 1,
          scaleY: 1
        }, {
          duration: 200,
          setToFinal: true,
          delay
        });
        if (text) {
          text.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay
          });
        }
        symbolPath.disableLabelAnimation = true;
      }
    });
  }
  _initOrUpdateEndLabel(seriesModel, coordSys, inheritColor) {
    const endLabelModel = seriesModel.getModel("endLabel");
    if (anyStateShowEndLabel(seriesModel)) {
      const data = seriesModel.getData();
      const polyline = this._polyline;
      const points4 = data.getLayout("points");
      if (!points4) {
        polyline.removeTextContent();
        this._endLabel = null;
        return;
      }
      let endLabel = this._endLabel;
      if (!endLabel) {
        endLabel = this._endLabel = new Text_default({
          z2: 200
        });
        endLabel.ignoreClip = true;
        polyline.setTextContent(this._endLabel);
        polyline.disableLabelAnimation = true;
      }
      const dataIndex = getLastIndexNotNull(points4);
      if (dataIndex >= 0) {
        setLabelStyle(polyline, getLabelStatesModels(seriesModel, "endLabel"), {
          inheritColor,
          labelFetcher: seriesModel,
          labelDataIndex: dataIndex,
          defaultText(dataIndex2, opt, interpolatedValue) {
            return interpolatedValue != null ? getDefaultInterpolatedLabel(data, interpolatedValue) : getDefaultLabel(data, dataIndex2);
          },
          enableTextSetter: true
        }, getEndLabelStateSpecified(endLabelModel, coordSys));
        polyline.textConfig.position = null;
      }
    } else if (this._endLabel) {
      this._polyline.removeTextContent();
      this._endLabel = null;
    }
  }
  _endLabelOnDuring(percent, clipRect, data, animationRecord, valueAnimation, endLabelModel, coordSys) {
    const endLabel = this._endLabel;
    const polyline = this._polyline;
    if (endLabel) {
      if (percent < 1 && animationRecord.originalX == null) {
        animationRecord.originalX = endLabel.x;
        animationRecord.originalY = endLabel.y;
      }
      const points4 = data.getLayout("points");
      const seriesModel = data.hostModel;
      const connectNulls = seriesModel.get("connectNulls");
      const precision = endLabelModel.get("precision");
      const distance2 = endLabelModel.get("distance") || 0;
      const baseAxis = coordSys.getBaseAxis();
      const isHorizontal = baseAxis.isHorizontal();
      const isBaseInversed = baseAxis.inverse;
      const clipShape = clipRect.shape;
      const xOrY = isBaseInversed ? isHorizontal ? clipShape.x : clipShape.y + clipShape.height : isHorizontal ? clipShape.x + clipShape.width : clipShape.y;
      const distanceX = (isHorizontal ? distance2 : 0) * (isBaseInversed ? -1 : 1);
      const distanceY = (isHorizontal ? 0 : -distance2) * (isBaseInversed ? -1 : 1);
      const dim = isHorizontal ? "x" : "y";
      const dataIndexRange = getIndexRange(points4, xOrY, dim);
      const indices = dataIndexRange.range;
      const diff = indices[1] - indices[0];
      let value;
      if (diff >= 1) {
        if (diff > 1 && !connectNulls) {
          const pt = getPointAtIndex(points4, indices[0]);
          endLabel.attr({
            x: pt[0] + distanceX,
            y: pt[1] + distanceY
          });
          valueAnimation && (value = seriesModel.getRawValue(indices[0]));
        } else {
          const pt = polyline.getPointOn(xOrY, dim);
          pt && endLabel.attr({
            x: pt[0] + distanceX,
            y: pt[1] + distanceY
          });
          const startValue = seriesModel.getRawValue(indices[0]);
          const endValue = seriesModel.getRawValue(indices[1]);
          valueAnimation && (value = interpolateRawValues(data, precision, startValue, endValue, dataIndexRange.t));
        }
        animationRecord.lastFrameIndex = indices[0];
      } else {
        const idx = percent === 1 || animationRecord.lastFrameIndex > 0 ? indices[0] : 0;
        const pt = getPointAtIndex(points4, idx);
        valueAnimation && (value = seriesModel.getRawValue(idx));
        endLabel.attr({
          x: pt[0] + distanceX,
          y: pt[1] + distanceY
        });
      }
      if (valueAnimation) {
        const inner23 = labelInner(endLabel);
        if (typeof inner23.setLabelText === "function") {
          inner23.setLabelText(value);
        }
      }
    }
  }
  _doUpdateAnimation(data, stackedOnPoints, coordSys, api2, step, valueOrigin, connectNulls) {
    const polyline = this._polyline;
    const polygon = this._polygon;
    const seriesModel = data.hostModel;
    const diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);
    let current = diff.current;
    let stackedOnCurrent = diff.stackedOnCurrent;
    let next = diff.next;
    let stackedOnNext = diff.stackedOnNext;
    if (step) {
      current = turnPointsIntoStep(diff.current, coordSys, step, connectNulls);
      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step, connectNulls);
      next = turnPointsIntoStep(diff.next, coordSys, step, connectNulls);
      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step, connectNulls);
    }
    if (getBoundingDiff(current, next) > 3e3 || polygon && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3e3) {
      polyline.stopAnimation();
      polyline.setShape({
        points: next
      });
      if (polygon) {
        polygon.stopAnimation();
        polygon.setShape({
          points: next,
          stackedOnPoints: stackedOnNext
        });
      }
      return;
    }
    polyline.shape.__points = diff.current;
    polyline.shape.points = current;
    const target = {
      shape: {
        points: next
      }
    };
    if (diff.current !== current) {
      target.shape.__points = diff.next;
    }
    polyline.stopAnimation();
    updateProps(polyline, target, seriesModel);
    if (polygon) {
      polygon.setShape({
        points: current,
        stackedOnPoints: stackedOnCurrent
      });
      polygon.stopAnimation();
      updateProps(polygon, {
        shape: {
          stackedOnPoints: stackedOnNext
        }
      }, seriesModel);
      if (polyline.shape.points !== polygon.shape.points) {
        polygon.shape.points = polyline.shape.points;
      }
    }
    const updatedDataInfo = [];
    const diffStatus = diff.status;
    for (let i = 0; i < diffStatus.length; i++) {
      const cmd = diffStatus[i].cmd;
      if (cmd === "=") {
        const el = data.getItemGraphicEl(diffStatus[i].idx1);
        if (el) {
          updatedDataInfo.push({
            el,
            ptIdx: i
          });
        }
      }
    }
    if (polyline.animators && polyline.animators.length) {
      polyline.animators[0].during(function() {
        polygon && polygon.dirtyShape();
        const points4 = polyline.shape.__points;
        for (let i = 0; i < updatedDataInfo.length; i++) {
          const el = updatedDataInfo[i].el;
          const offset = updatedDataInfo[i].ptIdx * 2;
          el.x = points4[offset];
          el.y = points4[offset + 1];
          el.markRedraw();
        }
      });
    }
  }
  remove(ecModel) {
    const group = this.group;
    const oldData = this._data;
    this._lineGroup.removeAll();
    this._symbolDraw.remove(true);
    oldData && oldData.eachItemGraphicEl(function(el, idx) {
      if (el.__temp) {
        group.remove(el);
        oldData.setItemGraphicEl(idx, null);
      }
    });
    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
  }
};
LineView.type = "line";
var LineView_default = LineView;

// src/layout/points.ts
function pointsLayout(seriesType2, forceStoreInTypedArray) {
  return {
    seriesType: seriesType2,
    plan: createRenderPlanner(),
    reset: function(seriesModel) {
      const data = seriesModel.getData();
      const coordSys = seriesModel.coordinateSystem;
      const pipelineContext = seriesModel.pipelineContext;
      const useTypedArray = forceStoreInTypedArray || pipelineContext.large;
      if (!coordSys) {
        return;
      }
      const dims = map(coordSys.dimensions, function(dim) {
        return data.mapDimension(dim);
      }).slice(0, 2);
      const dimLen = dims.length;
      const stackResultDim = data.getCalculationInfo("stackResultDimension");
      if (isDimensionStacked(data, dims[0])) {
        dims[0] = stackResultDim;
      }
      if (isDimensionStacked(data, dims[1])) {
        dims[1] = stackResultDim;
      }
      const store = data.getStore();
      const dimIdx0 = data.getDimensionIndex(dims[0]);
      const dimIdx1 = data.getDimensionIndex(dims[1]);
      return dimLen && {
        progress(params, data2) {
          const segCount = params.end - params.start;
          const points4 = useTypedArray && createFloat32Array(segCount * dimLen);
          const tmpIn = [];
          const tmpOut = [];
          for (let i = params.start, offset = 0; i < params.end; i++) {
            let point;
            if (dimLen === 1) {
              const x = store.get(dimIdx0, i);
              point = coordSys.dataToPoint(x, null, tmpOut);
            } else {
              tmpIn[0] = store.get(dimIdx0, i);
              tmpIn[1] = store.get(dimIdx1, i);
              point = coordSys.dataToPoint(tmpIn, null, tmpOut);
            }
            if (useTypedArray) {
              points4[offset++] = point[0];
              points4[offset++] = point[1];
            } else {
              data2.setItemLayout(i, point.slice());
            }
          }
          useTypedArray && data2.setLayout("points", points4);
        }
      };
    }
  };
}

// src/processor/dataSample.ts
var samplers = {
  average: function(frame) {
    let sum2 = 0;
    let count2 = 0;
    for (let i = 0; i < frame.length; i++) {
      if (!isNaN(frame[i])) {
        sum2 += frame[i];
        count2++;
      }
    }
    return count2 === 0 ? NaN : sum2 / count2;
  },
  sum: function(frame) {
    let sum2 = 0;
    for (let i = 0; i < frame.length; i++) {
      sum2 += frame[i] || 0;
    }
    return sum2;
  },
  max: function(frame) {
    let max3 = -Infinity;
    for (let i = 0; i < frame.length; i++) {
      frame[i] > max3 && (max3 = frame[i]);
    }
    return isFinite(max3) ? max3 : NaN;
  },
  min: function(frame) {
    let min3 = Infinity;
    for (let i = 0; i < frame.length; i++) {
      frame[i] < min3 && (min3 = frame[i]);
    }
    return isFinite(min3) ? min3 : NaN;
  },
  minmax: function(frame) {
    let turningPointAbsoluteValue = -Infinity;
    let turningPointOriginalValue = -Infinity;
    for (let i = 0; i < frame.length; i++) {
      const originalValue = frame[i];
      const absoluteValue = Math.abs(originalValue);
      if (absoluteValue > turningPointAbsoluteValue) {
        turningPointAbsoluteValue = absoluteValue;
        turningPointOriginalValue = originalValue;
      }
    }
    return isFinite(turningPointOriginalValue) ? turningPointOriginalValue : NaN;
  },
  nearest: function(frame) {
    return frame[0];
  }
};
var indexSampler = function(frame) {
  return Math.round(frame.length / 2);
};
function dataSample(seriesType2) {
  return {
    seriesType: seriesType2,
    reset: function(seriesModel, ecModel, api2) {
      const data = seriesModel.getData();
      const sampling = seriesModel.get("sampling");
      const coordSys = seriesModel.coordinateSystem;
      const count2 = data.count();
      if (count2 > 10 && coordSys.type === "cartesian2d" && sampling) {
        const baseAxis = coordSys.getBaseAxis();
        const valueAxis2 = coordSys.getOtherAxis(baseAxis);
        const extent3 = baseAxis.getExtent();
        const dpr2 = api2.getDevicePixelRatio();
        const size = Math.abs(extent3[1] - extent3[0]) * (dpr2 || 1);
        const rate = Math.round(count2 / size);
        if (isFinite(rate) && rate > 1) {
          if (sampling === "lttb") {
            seriesModel.setData(data.lttbDownSample(data.mapDimension(valueAxis2.dim), 1 / rate));
          }
          let sampler;
          if (isString(sampling)) {
            sampler = samplers[sampling];
          } else if (isFunction(sampling)) {
            sampler = sampling;
          }
          if (sampler) {
            seriesModel.setData(data.downSample(data.mapDimension(valueAxis2.dim), 1 / rate, sampler, indexSampler));
          }
        }
      }
    }
  };
}

// src/chart/line/install.ts
function install3(registers) {
  registers.registerChartView(LineView_default);
  registers.registerSeriesModel(LineSeries_default);
  registers.registerLayout(pointsLayout("line", true));
  registers.registerVisual({
    seriesType: "line",
    reset: function(seriesModel) {
      const data = seriesModel.getData();
      const lineStyle = seriesModel.getModel("lineStyle").getLineStyle();
      if (lineStyle && !lineStyle.stroke) {
        lineStyle.stroke = data.getVisual("style").fill;
      }
      data.setVisual("legendLineStyle", lineStyle);
    }
  });
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample("line"));
}

// src/chart/bar/BaseBarSeries.ts
var BaseBarSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = BaseBarSeriesModel2.type;
  }
  getInitialData(option, ecModel) {
    return createSeriesData_default(null, this, {useEncodeDefaulter: true});
  }
  getMarkerPosition(value, dims, startingAtTick) {
    const coordSys = this.coordinateSystem;
    if (coordSys && coordSys.clampData) {
      const clampData = coordSys.clampData(value);
      const pt = coordSys.dataToPoint(clampData);
      if (startingAtTick) {
        each(coordSys.getAxes(), function(axis, idx) {
          if (axis.type === "category" && dims != null) {
            const tickCoords = axis.getTicksCoords();
            const alignTicksWithLabel = axis.getTickModel().get("alignWithLabel");
            let targetTickId = clampData[idx];
            const isEnd = dims[idx] === "x1" || dims[idx] === "y1";
            if (isEnd && !alignTicksWithLabel) {
              targetTickId += 1;
            }
            if (tickCoords.length < 2) {
              return;
            } else if (tickCoords.length === 2) {
              pt[idx] = axis.toGlobalCoord(axis.getExtent()[isEnd ? 1 : 0]);
              return;
            }
            let leftCoord;
            let coord;
            let stepTickValue = 1;
            for (let i = 0; i < tickCoords.length; i++) {
              const tickCoord = tickCoords[i].coord;
              const tickValue = i === tickCoords.length - 1 ? tickCoords[i - 1].tickValue + stepTickValue : tickCoords[i].tickValue;
              if (tickValue === targetTickId) {
                coord = tickCoord;
                break;
              } else if (tickValue < targetTickId) {
                leftCoord = tickCoord;
              } else if (leftCoord != null && tickValue > targetTickId) {
                coord = (tickCoord + leftCoord) / 2;
                break;
              }
              if (i === 1) {
                stepTickValue = tickValue - tickCoords[0].tickValue;
              }
            }
            if (coord == null) {
              if (!leftCoord) {
                coord = tickCoords[0].coord;
              } else if (leftCoord) {
                coord = tickCoords[tickCoords.length - 1].coord;
              }
            }
            pt[idx] = axis.toGlobalCoord(coord);
          }
        });
      } else {
        const data = this.getData();
        const offset = data.getLayout("offset");
        const size = data.getLayout("size");
        const offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
        pt[offsetIndex] += offset + size / 2;
      }
      return pt;
    }
    return [NaN, NaN];
  }
};
var BaseBarSeriesModel = BaseBarSeriesModel2;
BaseBarSeriesModel.type = "series.__base_bar__";
BaseBarSeriesModel.defaultOption = {
  z: 2,
  coordinateSystem: "cartesian2d",
  legendHoverLink: true,
  barMinHeight: 0,
  barMinAngle: 0,
  large: false,
  largeThreshold: 400,
  progressive: 3e3,
  progressiveChunkMode: "mod"
};
Series_default.registerClass(BaseBarSeriesModel);
var BaseBarSeries_default = BaseBarSeriesModel;

// src/chart/bar/BarSeries.ts
var BarSeriesModel2 = class extends BaseBarSeries_default {
  constructor() {
    super(...arguments);
    this.type = BarSeriesModel2.type;
  }
  getInitialData() {
    return createSeriesData_default(null, this, {
      useEncodeDefaulter: true,
      createInvertedIndices: !!this.get("realtimeSort", true) || null
    });
  }
  getProgressive() {
    return this.get("large") ? this.get("progressive") : false;
  }
  getProgressiveThreshold() {
    let progressiveThreshold = this.get("progressiveThreshold");
    const largeThreshold = this.get("largeThreshold");
    if (largeThreshold > progressiveThreshold) {
      progressiveThreshold = largeThreshold;
    }
    return progressiveThreshold;
  }
  brushSelector(dataIndex, data, selectors) {
    return selectors.rect(data.getItemLayout(dataIndex));
  }
};
var BarSeriesModel = BarSeriesModel2;
BarSeriesModel.type = "series.bar";
BarSeriesModel.dependencies = ["grid", "polar"];
BarSeriesModel.defaultOption = inheritDefaultOption(BaseBarSeries_default.defaultOption, {
  clip: true,
  roundCap: false,
  showBackground: false,
  backgroundStyle: {
    color: "rgba(180, 180, 180, 0.2)",
    borderColor: null,
    borderWidth: 0,
    borderType: "solid",
    borderRadius: 0,
    shadowBlur: 0,
    shadowColor: null,
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    opacity: 1
  },
  select: {
    itemStyle: {
      borderColor: "#212121"
    }
  },
  realtimeSort: false
});
var BarSeries_default = BarSeriesModel;

// src/util/shape/sausage.ts
var SausageShape = class {
  constructor() {
    this.cx = 0;
    this.cy = 0;
    this.r0 = 0;
    this.r = 0;
    this.startAngle = 0;
    this.endAngle = Math.PI * 2;
    this.clockwise = true;
  }
};
var SausagePath = class extends Path_default {
  constructor(opts) {
    super(opts);
    this.type = "sausage";
  }
  getDefaultShape() {
    return new SausageShape();
  }
  buildPath(ctx, shape) {
    const cx = shape.cx;
    const cy = shape.cy;
    const r0 = Math.max(shape.r0 || 0, 0);
    const r = Math.max(shape.r, 0);
    const dr = (r - r0) * 0.5;
    const rCenter = r0 + dr;
    let startAngle = shape.startAngle;
    const endAngle = shape.endAngle;
    const clockwise = shape.clockwise;
    const PI210 = Math.PI * 2;
    const lessThanCircle = clockwise ? endAngle - startAngle < PI210 : startAngle - endAngle < PI210;
    if (!lessThanCircle) {
      startAngle = endAngle - (clockwise ? PI210 : -PI210);
    }
    const unitStartX = Math.cos(startAngle);
    const unitStartY = Math.sin(startAngle);
    const unitEndX = Math.cos(endAngle);
    const unitEndY = Math.sin(endAngle);
    if (lessThanCircle) {
      ctx.moveTo(unitStartX * r0 + cx, unitStartY * r0 + cy);
      ctx.arc(unitStartX * rCenter + cx, unitStartY * rCenter + cy, dr, -Math.PI + startAngle, startAngle, !clockwise);
    } else {
      ctx.moveTo(unitStartX * r + cx, unitStartY * r + cy);
    }
    ctx.arc(cx, cy, r, startAngle, endAngle, !clockwise);
    ctx.arc(unitEndX * rCenter + cx, unitEndY * rCenter + cy, dr, endAngle - Math.PI * 2, endAngle - Math.PI, !clockwise);
    if (r0 !== 0) {
      ctx.arc(cx, cy, r0, endAngle, startAngle, clockwise);
    }
  }
};
var sausage_default = SausagePath;

// src/label/sectorLabel.ts
function createSectorCalculateTextPosition(positionMapping, opts) {
  opts = opts || {};
  const isRoundCap = opts.isRoundCap;
  return function(out2, opts2, boundingRect) {
    const textPosition = opts2.position;
    if (!textPosition || textPosition instanceof Array) {
      return calculateTextPosition(out2, opts2, boundingRect);
    }
    const mappedSectorPosition = positionMapping(textPosition);
    const distance2 = opts2.distance != null ? opts2.distance : 5;
    const sector = this.shape;
    const cx = sector.cx;
    const cy = sector.cy;
    const r = sector.r;
    const r0 = sector.r0;
    const middleR = (r + r0) / 2;
    const startAngle = sector.startAngle;
    const endAngle = sector.endAngle;
    const middleAngle = (startAngle + endAngle) / 2;
    const extraDist = isRoundCap ? Math.abs(r - r0) / 2 : 0;
    const mathCos6 = Math.cos;
    const mathSin6 = Math.sin;
    let x = cx + r * mathCos6(startAngle);
    let y = cy + r * mathSin6(startAngle);
    let textAlign = "left";
    let textVerticalAlign = "top";
    switch (mappedSectorPosition) {
      case "startArc":
        x = cx + (r0 - distance2) * mathCos6(middleAngle);
        y = cy + (r0 - distance2) * mathSin6(middleAngle);
        textAlign = "center";
        textVerticalAlign = "top";
        break;
      case "insideStartArc":
        x = cx + (r0 + distance2) * mathCos6(middleAngle);
        y = cy + (r0 + distance2) * mathSin6(middleAngle);
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "startAngle":
        x = cx + middleR * mathCos6(startAngle) + adjustAngleDistanceX(startAngle, distance2 + extraDist, false);
        y = cy + middleR * mathSin6(startAngle) + adjustAngleDistanceY(startAngle, distance2 + extraDist, false);
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      case "insideStartAngle":
        x = cx + middleR * mathCos6(startAngle) + adjustAngleDistanceX(startAngle, -distance2 + extraDist, false);
        y = cy + middleR * mathSin6(startAngle) + adjustAngleDistanceY(startAngle, -distance2 + extraDist, false);
        textAlign = "left";
        textVerticalAlign = "middle";
        break;
      case "middle":
        x = cx + middleR * mathCos6(middleAngle);
        y = cy + middleR * mathSin6(middleAngle);
        textAlign = "center";
        textVerticalAlign = "middle";
        break;
      case "endArc":
        x = cx + (r + distance2) * mathCos6(middleAngle);
        y = cy + (r + distance2) * mathSin6(middleAngle);
        textAlign = "center";
        textVerticalAlign = "bottom";
        break;
      case "insideEndArc":
        x = cx + (r - distance2) * mathCos6(middleAngle);
        y = cy + (r - distance2) * mathSin6(middleAngle);
        textAlign = "center";
        textVerticalAlign = "top";
        break;
      case "endAngle":
        x = cx + middleR * mathCos6(endAngle) + adjustAngleDistanceX(endAngle, distance2 + extraDist, true);
        y = cy + middleR * mathSin6(endAngle) + adjustAngleDistanceY(endAngle, distance2 + extraDist, true);
        textAlign = "left";
        textVerticalAlign = "middle";
        break;
      case "insideEndAngle":
        x = cx + middleR * mathCos6(endAngle) + adjustAngleDistanceX(endAngle, -distance2 + extraDist, true);
        y = cy + middleR * mathSin6(endAngle) + adjustAngleDistanceY(endAngle, -distance2 + extraDist, true);
        textAlign = "right";
        textVerticalAlign = "middle";
        break;
      default:
        return calculateTextPosition(out2, opts2, boundingRect);
    }
    out2 = out2 || {};
    out2.x = x;
    out2.y = y;
    out2.align = textAlign;
    out2.verticalAlign = textVerticalAlign;
    return out2;
  };
}
function setSectorTextRotation(sector, textPosition, positionMapping, rotateType) {
  if (isNumber(rotateType)) {
    sector.setTextConfig({
      rotation: rotateType
    });
    return;
  } else if (isArray(textPosition)) {
    sector.setTextConfig({
      rotation: 0
    });
    return;
  }
  const shape = sector.shape;
  const startAngle = shape.clockwise ? shape.startAngle : shape.endAngle;
  const endAngle = shape.clockwise ? shape.endAngle : shape.startAngle;
  const middleAngle = (startAngle + endAngle) / 2;
  let anchorAngle;
  const mappedSectorPosition = positionMapping(textPosition);
  switch (mappedSectorPosition) {
    case "startArc":
    case "insideStartArc":
    case "middle":
    case "insideEndArc":
    case "endArc":
      anchorAngle = middleAngle;
      break;
    case "startAngle":
    case "insideStartAngle":
      anchorAngle = startAngle;
      break;
    case "endAngle":
    case "insideEndAngle":
      anchorAngle = endAngle;
      break;
    default:
      sector.setTextConfig({
        rotation: 0
      });
      return;
  }
  let rotate2 = Math.PI * 1.5 - anchorAngle;
  if (mappedSectorPosition === "middle" && rotate2 > Math.PI / 2 && rotate2 < Math.PI * 1.5) {
    rotate2 -= Math.PI;
  }
  sector.setTextConfig({
    rotation: rotate2
  });
}
function adjustAngleDistanceX(angle, distance2, isEnd) {
  return distance2 * Math.sin(angle) * (isEnd ? -1 : 1);
}
function adjustAngleDistanceY(angle, distance2, isEnd) {
  return distance2 * Math.cos(angle) * (isEnd ? 1 : -1);
}

// src/chart/helper/sectorHelper.ts
function getSectorCornerRadius(model, shape, zeroIfNull) {
  let cornerRadius = model.get("borderRadius");
  if (cornerRadius == null) {
    return zeroIfNull ? {cornerRadius: 0} : null;
  }
  if (!isArray(cornerRadius)) {
    cornerRadius = [cornerRadius, cornerRadius, cornerRadius, cornerRadius];
  }
  const dr = Math.abs(shape.r || 0 - shape.r0 || 0);
  return {
    cornerRadius: map(cornerRadius, (cr) => parsePercent(cr, dr))
  };
}

// src/chart/bar/BarView.ts
var mathMax7 = Math.max;
var mathMin7 = Math.min;
function getClipArea(coord, data) {
  const coordSysClipArea = coord.getArea && coord.getArea();
  if (isCoordinateSystemType(coord, "cartesian2d")) {
    const baseAxis = coord.getBaseAxis();
    if (baseAxis.type !== "category" || !baseAxis.onBand) {
      const expandWidth = data.getLayout("bandWidth");
      if (baseAxis.isHorizontal()) {
        coordSysClipArea.x -= expandWidth;
        coordSysClipArea.width += expandWidth * 2;
      } else {
        coordSysClipArea.y -= expandWidth;
        coordSysClipArea.height += expandWidth * 2;
      }
    }
  }
  return coordSysClipArea;
}
var BarView2 = class extends Chart_default {
  constructor() {
    super();
    this.type = BarView2.type;
    this._isFirstFrame = true;
  }
  render(seriesModel, ecModel, api2, payload) {
    this._model = seriesModel;
    this._removeOnRenderedListener(api2);
    this._updateDrawMode(seriesModel);
    const coordinateSystemType = seriesModel.get("coordinateSystem");
    if (coordinateSystemType === "cartesian2d" || coordinateSystemType === "polar") {
      this._progressiveEls = null;
      this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api2) : this._renderNormal(seriesModel, ecModel, api2, payload);
    } else if (true) {
      warn("Only cartesian2d and polar supported for bar.");
    }
  }
  incrementalPrepareRender(seriesModel) {
    this._clear();
    this._updateDrawMode(seriesModel);
    this._updateLargeClip(seriesModel);
  }
  incrementalRender(params, seriesModel) {
    this._progressiveEls = [];
    this._incrementalRenderLarge(params, seriesModel);
  }
  eachRendered(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  }
  _updateDrawMode(seriesModel) {
    const isLargeDraw = seriesModel.pipelineContext.large;
    if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {
      this._isLargeDraw = isLargeDraw;
      this._clear();
    }
  }
  _renderNormal(seriesModel, ecModel, api2, payload) {
    const group = this.group;
    const data = seriesModel.getData();
    const oldData = this._data;
    const coord = seriesModel.coordinateSystem;
    const baseAxis = coord.getBaseAxis();
    let isHorizontalOrRadial;
    if (coord.type === "cartesian2d") {
      isHorizontalOrRadial = baseAxis.isHorizontal();
    } else if (coord.type === "polar") {
      isHorizontalOrRadial = baseAxis.dim === "angle";
    }
    const animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;
    const realtimeSortCfg = shouldRealtimeSort(seriesModel, coord);
    if (realtimeSortCfg) {
      this._enableRealtimeSort(realtimeSortCfg, data, api2);
    }
    const needsClip = seriesModel.get("clip", true) || realtimeSortCfg;
    const coordSysClipArea = getClipArea(coord, data);
    group.removeClipPath();
    const roundCap = seriesModel.get("roundCap", true);
    const drawBackground = seriesModel.get("showBackground", true);
    const backgroundModel = seriesModel.getModel("backgroundStyle");
    const barBorderRadius = backgroundModel.get("borderRadius") || 0;
    const bgEls = [];
    const oldBgEls = this._backgroundEls;
    const isInitSort = payload && payload.isInitSort;
    const isChangeOrder = payload && payload.type === "changeAxisOrder";
    function createBackground(dataIndex) {
      const bgLayout = getLayout[coord.type](data, dataIndex);
      const bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);
      bgEl.useStyle(backgroundModel.getItemStyle());
      if (coord.type === "cartesian2d") {
        bgEl.setShape("r", barBorderRadius);
      } else {
        bgEl.setShape("cornerRadius", barBorderRadius);
      }
      bgEls[dataIndex] = bgEl;
      return bgEl;
    }
    ;
    data.diff(oldData).add(function(dataIndex) {
      const itemModel = data.getItemModel(dataIndex);
      const layout18 = getLayout[coord.type](data, dataIndex, itemModel);
      if (drawBackground) {
        createBackground(dataIndex);
      }
      if (!data.hasValue(dataIndex) || !isValidLayout[coord.type](layout18)) {
        return;
      }
      let isClipped = false;
      if (needsClip) {
        isClipped = clip[coord.type](coordSysClipArea, layout18);
      }
      const el = elementCreator[coord.type](seriesModel, data, dataIndex, layout18, isHorizontalOrRadial, animationModel, baseAxis.model, false, roundCap);
      if (realtimeSortCfg) {
        el.forceLabelAnimation = true;
      }
      updateStyle(el, data, dataIndex, itemModel, layout18, seriesModel, isHorizontalOrRadial, coord.type === "polar");
      if (isInitSort) {
        el.attr({shape: layout18});
      } else if (realtimeSortCfg) {
        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout18, dataIndex, isHorizontalOrRadial, false, false);
      } else {
        initProps(el, {shape: layout18}, seriesModel, dataIndex);
      }
      data.setItemGraphicEl(dataIndex, el);
      group.add(el);
      el.ignore = isClipped;
    }).update(function(newIndex, oldIndex) {
      const itemModel = data.getItemModel(newIndex);
      const layout18 = getLayout[coord.type](data, newIndex, itemModel);
      if (drawBackground) {
        let bgEl;
        if (oldBgEls.length === 0) {
          bgEl = createBackground(oldIndex);
        } else {
          bgEl = oldBgEls[oldIndex];
          bgEl.useStyle(backgroundModel.getItemStyle());
          if (coord.type === "cartesian2d") {
            bgEl.setShape("r", barBorderRadius);
          } else {
            bgEl.setShape("cornerRadius", barBorderRadius);
          }
          bgEls[newIndex] = bgEl;
        }
        const bgLayout = getLayout[coord.type](data, newIndex);
        const shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);
        updateProps(bgEl, {shape}, animationModel, newIndex);
      }
      let el = oldData.getItemGraphicEl(oldIndex);
      if (!data.hasValue(newIndex) || !isValidLayout[coord.type](layout18)) {
        group.remove(el);
        return;
      }
      let isClipped = false;
      if (needsClip) {
        isClipped = clip[coord.type](coordSysClipArea, layout18);
        if (isClipped) {
          group.remove(el);
        }
      }
      if (!el) {
        el = elementCreator[coord.type](seriesModel, data, newIndex, layout18, isHorizontalOrRadial, animationModel, baseAxis.model, !!el, roundCap);
      } else {
        saveOldStyle(el);
      }
      if (realtimeSortCfg) {
        el.forceLabelAnimation = true;
      }
      if (isChangeOrder) {
        const textEl = el.getTextContent();
        if (textEl) {
          const labelInnerStore = labelInner(textEl);
          if (labelInnerStore.prevValue != null) {
            labelInnerStore.prevValue = labelInnerStore.value;
          }
        }
      } else {
        updateStyle(el, data, newIndex, itemModel, layout18, seriesModel, isHorizontalOrRadial, coord.type === "polar");
      }
      if (isInitSort) {
        el.attr({shape: layout18});
      } else if (realtimeSortCfg) {
        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout18, newIndex, isHorizontalOrRadial, true, isChangeOrder);
      } else {
        updateProps(el, {
          shape: layout18
        }, seriesModel, newIndex, null);
      }
      data.setItemGraphicEl(newIndex, el);
      el.ignore = isClipped;
      group.add(el);
    }).remove(function(dataIndex) {
      const el = oldData.getItemGraphicEl(dataIndex);
      el && removeElementWithFadeOut(el, seriesModel, dataIndex);
    }).execute();
    const bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group_default());
    bgGroup.removeAll();
    for (let i = 0; i < bgEls.length; ++i) {
      bgGroup.add(bgEls[i]);
    }
    group.add(bgGroup);
    this._backgroundEls = bgEls;
    this._data = data;
  }
  _renderLarge(seriesModel, ecModel, api2) {
    this._clear();
    createLarge(seriesModel, this.group);
    this._updateLargeClip(seriesModel);
  }
  _incrementalRenderLarge(params, seriesModel) {
    this._removeBackground();
    createLarge(seriesModel, this.group, this._progressiveEls, true);
  }
  _updateLargeClip(seriesModel) {
    const clipPath = seriesModel.get("clip", true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);
    const group = this.group;
    if (clipPath) {
      group.setClipPath(clipPath);
    } else {
      group.removeClipPath();
    }
  }
  _enableRealtimeSort(realtimeSortCfg, data, api2) {
    if (!data.count()) {
      return;
    }
    const baseAxis = realtimeSortCfg.baseAxis;
    if (this._isFirstFrame) {
      this._dispatchInitSort(data, realtimeSortCfg, api2);
      this._isFirstFrame = false;
    } else {
      const orderMapping = (idx) => {
        const el = data.getItemGraphicEl(idx);
        const shape = el && el.shape;
        return shape && Math.abs(baseAxis.isHorizontal() ? shape.height : shape.width) || 0;
      };
      this._onRendered = () => {
        this._updateSortWithinSameData(data, orderMapping, baseAxis, api2);
      };
      api2.getZr().on("rendered", this._onRendered);
    }
  }
  _dataSort(data, baseAxis, orderMapping) {
    const info = [];
    data.each(data.mapDimension(baseAxis.dim), (ordinalNumber, dataIdx) => {
      let mappedValue = orderMapping(dataIdx);
      mappedValue = mappedValue == null ? NaN : mappedValue;
      info.push({
        dataIndex: dataIdx,
        mappedValue,
        ordinalNumber
      });
    });
    info.sort((a, b) => {
      return b.mappedValue - a.mappedValue;
    });
    return {
      ordinalNumbers: map(info, (item) => item.ordinalNumber)
    };
  }
  _isOrderChangedWithinSameData(data, orderMapping, baseAxis) {
    const scale4 = baseAxis.scale;
    const ordinalDataDim = data.mapDimension(baseAxis.dim);
    let lastValue = Number.MAX_VALUE;
    for (let tickNum = 0, len2 = scale4.getOrdinalMeta().categories.length; tickNum < len2; ++tickNum) {
      const rawIdx = data.rawIndexOf(ordinalDataDim, scale4.getRawOrdinalNumber(tickNum));
      const value = rawIdx < 0 ? Number.MIN_VALUE : orderMapping(data.indexOfRawIndex(rawIdx));
      if (value > lastValue) {
        return true;
      }
      lastValue = value;
    }
    return false;
  }
  _isOrderDifferentInView(orderInfo, baseAxis) {
    const scale4 = baseAxis.scale;
    const extent3 = scale4.getExtent();
    let tickNum = Math.max(0, extent3[0]);
    const tickMax = Math.min(extent3[1], scale4.getOrdinalMeta().categories.length - 1);
    for (; tickNum <= tickMax; ++tickNum) {
      if (orderInfo.ordinalNumbers[tickNum] !== scale4.getRawOrdinalNumber(tickNum)) {
        return true;
      }
    }
  }
  _updateSortWithinSameData(data, orderMapping, baseAxis, api2) {
    if (!this._isOrderChangedWithinSameData(data, orderMapping, baseAxis)) {
      return;
    }
    const sortInfo = this._dataSort(data, baseAxis, orderMapping);
    if (this._isOrderDifferentInView(sortInfo, baseAxis)) {
      this._removeOnRenderedListener(api2);
      api2.dispatchAction({
        type: "changeAxisOrder",
        componentType: baseAxis.dim + "Axis",
        axisId: baseAxis.index,
        sortInfo
      });
    }
  }
  _dispatchInitSort(data, realtimeSortCfg, api2) {
    const baseAxis = realtimeSortCfg.baseAxis;
    const sortResult = this._dataSort(data, baseAxis, (dataIdx) => data.get(data.mapDimension(realtimeSortCfg.otherAxis.dim), dataIdx));
    api2.dispatchAction({
      type: "changeAxisOrder",
      componentType: baseAxis.dim + "Axis",
      isInitSort: true,
      axisId: baseAxis.index,
      sortInfo: sortResult
    });
  }
  remove(ecModel, api2) {
    this._clear(this._model);
    this._removeOnRenderedListener(api2);
  }
  dispose(ecModel, api2) {
    this._removeOnRenderedListener(api2);
  }
  _removeOnRenderedListener(api2) {
    if (this._onRendered) {
      api2.getZr().off("rendered", this._onRendered);
      this._onRendered = null;
    }
  }
  _clear(model) {
    const group = this.group;
    const data = this._data;
    if (model && model.isAnimationEnabled() && data && !this._isLargeDraw) {
      this._removeBackground();
      this._backgroundEls = [];
      data.eachItemGraphicEl(function(el) {
        removeElementWithFadeOut(el, model, getECData(el).dataIndex);
      });
    } else {
      group.removeAll();
    }
    this._data = null;
    this._isFirstFrame = true;
  }
  _removeBackground() {
    this.group.remove(this._backgroundGroup);
    this._backgroundGroup = null;
  }
};
var BarView = BarView2;
BarView.type = "bar";
var clip = {
  cartesian2d(coordSysBoundingRect, layout18) {
    const signWidth = layout18.width < 0 ? -1 : 1;
    const signHeight = layout18.height < 0 ? -1 : 1;
    if (signWidth < 0) {
      layout18.x += layout18.width;
      layout18.width = -layout18.width;
    }
    if (signHeight < 0) {
      layout18.y += layout18.height;
      layout18.height = -layout18.height;
    }
    const coordSysX2 = coordSysBoundingRect.x + coordSysBoundingRect.width;
    const coordSysY2 = coordSysBoundingRect.y + coordSysBoundingRect.height;
    const x = mathMax7(layout18.x, coordSysBoundingRect.x);
    const x2 = mathMin7(layout18.x + layout18.width, coordSysX2);
    const y = mathMax7(layout18.y, coordSysBoundingRect.y);
    const y2 = mathMin7(layout18.y + layout18.height, coordSysY2);
    const xClipped = x2 < x;
    const yClipped = y2 < y;
    layout18.x = xClipped && x > coordSysX2 ? x2 : x;
    layout18.y = yClipped && y > coordSysY2 ? y2 : y;
    layout18.width = xClipped ? 0 : x2 - x;
    layout18.height = yClipped ? 0 : y2 - y;
    if (signWidth < 0) {
      layout18.x += layout18.width;
      layout18.width = -layout18.width;
    }
    if (signHeight < 0) {
      layout18.y += layout18.height;
      layout18.height = -layout18.height;
    }
    return xClipped || yClipped;
  },
  polar(coordSysClipArea, layout18) {
    const signR = layout18.r0 <= layout18.r ? 1 : -1;
    if (signR < 0) {
      const tmp = layout18.r;
      layout18.r = layout18.r0;
      layout18.r0 = tmp;
    }
    const r = mathMin7(layout18.r, coordSysClipArea.r);
    const r0 = mathMax7(layout18.r0, coordSysClipArea.r0);
    layout18.r = r;
    layout18.r0 = r0;
    const clipped = r - r0 < 0;
    if (signR < 0) {
      const tmp = layout18.r;
      layout18.r = layout18.r0;
      layout18.r0 = tmp;
    }
    return clipped;
  }
};
var elementCreator = {
  cartesian2d(seriesModel, data, newIndex, layout18, isHorizontal, animationModel, axisModel, isUpdate, roundCap) {
    const rect = new Rect_default({
      shape: extend({}, layout18),
      z2: 1
    });
    rect.__dataIndex = newIndex;
    rect.name = "item";
    if (animationModel) {
      const rectShape = rect.shape;
      const animateProperty = isHorizontal ? "height" : "width";
      rectShape[animateProperty] = 0;
    }
    return rect;
  },
  polar(seriesModel, data, newIndex, layout18, isRadial, animationModel, axisModel, isUpdate, roundCap) {
    const ShapeClass = !isRadial && roundCap ? sausage_default : Sector_default;
    const sector = new ShapeClass({
      shape: layout18,
      z2: 1
    });
    sector.name = "item";
    const positionMap = createPolarPositionMapping(isRadial);
    sector.calculateTextPosition = createSectorCalculateTextPosition(positionMap, {
      isRoundCap: ShapeClass === sausage_default
    });
    if (animationModel) {
      const sectorShape = sector.shape;
      const animateProperty = isRadial ? "r" : "endAngle";
      const animateTarget = {};
      sectorShape[animateProperty] = isRadial ? layout18.r0 : layout18.startAngle;
      animateTarget[animateProperty] = layout18[animateProperty];
      (isUpdate ? updateProps : initProps)(sector, {
        shape: animateTarget
      }, animationModel);
    }
    return sector;
  }
};
function shouldRealtimeSort(seriesModel, coordSys) {
  const realtimeSortOption = seriesModel.get("realtimeSort", true);
  const baseAxis = coordSys.getBaseAxis();
  if (true) {
    if (realtimeSortOption) {
      if (baseAxis.type !== "category") {
        warn("`realtimeSort` will not work because this bar series is not based on a category axis.");
      }
      if (coordSys.type !== "cartesian2d") {
        warn("`realtimeSort` will not work because this bar series is not on cartesian2d.");
      }
    }
  }
  if (realtimeSortOption && baseAxis.type === "category" && coordSys.type === "cartesian2d") {
    return {
      baseAxis,
      otherAxis: coordSys.getOtherAxis(baseAxis)
    };
  }
}
function updateRealtimeAnimation(realtimeSortCfg, seriesAnimationModel, el, layout18, newIndex, isHorizontal, isUpdate, isChangeOrder) {
  let seriesTarget;
  let axisTarget;
  if (isHorizontal) {
    axisTarget = {
      x: layout18.x,
      width: layout18.width
    };
    seriesTarget = {
      y: layout18.y,
      height: layout18.height
    };
  } else {
    axisTarget = {
      y: layout18.y,
      height: layout18.height
    };
    seriesTarget = {
      x: layout18.x,
      width: layout18.width
    };
  }
  if (!isChangeOrder) {
    (isUpdate ? updateProps : initProps)(el, {
      shape: seriesTarget
    }, seriesAnimationModel, newIndex, null);
  }
  const axisAnimationModel = seriesAnimationModel ? realtimeSortCfg.baseAxis.model : null;
  (isUpdate ? updateProps : initProps)(el, {
    shape: axisTarget
  }, axisAnimationModel, newIndex);
}
function checkPropertiesNotValid(obj, props) {
  for (let i = 0; i < props.length; i++) {
    if (!isFinite(obj[props[i]])) {
      return true;
    }
  }
  return false;
}
var rectPropties = ["x", "y", "width", "height"];
var polarPropties = ["cx", "cy", "r", "startAngle", "endAngle"];
var isValidLayout = {
  cartesian2d(layout18) {
    return !checkPropertiesNotValid(layout18, rectPropties);
  },
  polar(layout18) {
    return !checkPropertiesNotValid(layout18, polarPropties);
  }
};
var getLayout = {
  cartesian2d(data, dataIndex, itemModel) {
    const layout18 = data.getItemLayout(dataIndex);
    const fixedLineWidth = itemModel ? getLineWidth(itemModel, layout18) : 0;
    const signX = layout18.width > 0 ? 1 : -1;
    const signY = layout18.height > 0 ? 1 : -1;
    return {
      x: layout18.x + signX * fixedLineWidth / 2,
      y: layout18.y + signY * fixedLineWidth / 2,
      width: layout18.width - signX * fixedLineWidth,
      height: layout18.height - signY * fixedLineWidth
    };
  },
  polar(data, dataIndex, itemModel) {
    const layout18 = data.getItemLayout(dataIndex);
    return {
      cx: layout18.cx,
      cy: layout18.cy,
      r0: layout18.r0,
      r: layout18.r,
      startAngle: layout18.startAngle,
      endAngle: layout18.endAngle,
      clockwise: layout18.clockwise
    };
  }
};
function isZeroOnPolar(layout18) {
  return layout18.startAngle != null && layout18.endAngle != null && layout18.startAngle === layout18.endAngle;
}
function createPolarPositionMapping(isRadial) {
  return ((isRadial2) => {
    const arcOrAngle = isRadial2 ? "Arc" : "Angle";
    return (position2) => {
      switch (position2) {
        case "start":
        case "insideStart":
        case "end":
        case "insideEnd":
          return position2 + arcOrAngle;
        default:
          return position2;
      }
    };
  })(isRadial);
}
function updateStyle(el, data, dataIndex, itemModel, layout18, seriesModel, isHorizontalOrRadial, isPolar) {
  const style = data.getItemVisual(dataIndex, "style");
  if (!isPolar) {
    const borderRadius = itemModel.get(["itemStyle", "borderRadius"]) || 0;
    el.setShape("r", borderRadius);
  } else if (!seriesModel.get("roundCap")) {
    const sectorShape = el.shape;
    const cornerRadius = getSectorCornerRadius(itemModel.getModel("itemStyle"), sectorShape, true);
    extend(sectorShape, cornerRadius);
    el.setShape(sectorShape);
  }
  el.useStyle(style);
  const cursorStyle = itemModel.getShallow("cursor");
  cursorStyle && el.attr("cursor", cursorStyle);
  const labelPositionOutside = isPolar ? isHorizontalOrRadial ? layout18.r >= layout18.r0 ? "endArc" : "startArc" : layout18.endAngle >= layout18.startAngle ? "endAngle" : "startAngle" : isHorizontalOrRadial ? layout18.height >= 0 ? "bottom" : "top" : layout18.width >= 0 ? "right" : "left";
  const labelStatesModels = getLabelStatesModels(itemModel);
  setLabelStyle(el, labelStatesModels, {
    labelFetcher: seriesModel,
    labelDataIndex: dataIndex,
    defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),
    inheritColor: style.fill,
    defaultOpacity: style.opacity,
    defaultOutsidePosition: labelPositionOutside
  });
  const label = el.getTextContent();
  if (isPolar && label) {
    const position2 = itemModel.get(["label", "position"]);
    el.textConfig.inside = position2 === "middle" ? true : null;
    setSectorTextRotation(el, position2 === "outside" ? labelPositionOutside : position2, createPolarPositionMapping(isHorizontalOrRadial), itemModel.get(["label", "rotate"]));
  }
  setLabelValueAnimation(label, labelStatesModels, seriesModel.getRawValue(dataIndex), (value) => getDefaultInterpolatedLabel(data, value));
  const emphasisModel = itemModel.getModel(["emphasis"]);
  toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  setStatesStylesFromModel(el, itemModel);
  if (isZeroOnPolar(layout18)) {
    el.style.fill = "none";
    el.style.stroke = "none";
    each(el.states, (state) => {
      if (state.style) {
        state.style.fill = state.style.stroke = "none";
      }
    });
  }
}
function getLineWidth(itemModel, rawLayout) {
  const borderColor = itemModel.get(["itemStyle", "borderColor"]);
  if (!borderColor || borderColor === "none") {
    return 0;
  }
  const lineWidth = itemModel.get(["itemStyle", "borderWidth"]) || 0;
  const width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);
  const height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);
  return Math.min(lineWidth, width, height);
}
var LagePathShape = class {
};
var LargePath = class extends Path_default {
  constructor(opts) {
    super(opts);
    this.type = "largeBar";
  }
  getDefaultShape() {
    return new LagePathShape();
  }
  buildPath(ctx, shape) {
    const points4 = shape.points;
    const baseDimIdx = this.baseDimIdx;
    const valueDimIdx = 1 - this.baseDimIdx;
    const startPoint = [];
    const size = [];
    const barWidth = this.barWidth;
    for (let i = 0; i < points4.length; i += 3) {
      size[baseDimIdx] = barWidth;
      size[valueDimIdx] = points4[i + 2];
      startPoint[baseDimIdx] = points4[i + baseDimIdx];
      startPoint[valueDimIdx] = points4[i + valueDimIdx];
      ctx.rect(startPoint[0], startPoint[1], size[0], size[1]);
    }
  }
};
function createLarge(seriesModel, group, progressiveEls, incremental) {
  const data = seriesModel.getData();
  const baseDimIdx = data.getLayout("valueAxisHorizontal") ? 1 : 0;
  const largeDataIndices = data.getLayout("largeDataIndices");
  const barWidth = data.getLayout("size");
  const backgroundModel = seriesModel.getModel("backgroundStyle");
  const bgPoints = data.getLayout("largeBackgroundPoints");
  if (bgPoints) {
    const bgEl = new LargePath({
      shape: {
        points: bgPoints
      },
      incremental: !!incremental,
      silent: true,
      z2: 0
    });
    bgEl.baseDimIdx = baseDimIdx;
    bgEl.largeDataIndices = largeDataIndices;
    bgEl.barWidth = barWidth;
    bgEl.useStyle(backgroundModel.getItemStyle());
    group.add(bgEl);
    progressiveEls && progressiveEls.push(bgEl);
  }
  const el = new LargePath({
    shape: {points: data.getLayout("largePoints")},
    incremental: !!incremental,
    ignoreCoarsePointer: true,
    z2: 1
  });
  el.baseDimIdx = baseDimIdx;
  el.largeDataIndices = largeDataIndices;
  el.barWidth = barWidth;
  group.add(el);
  el.useStyle(data.getVisual("style"));
  getECData(el).seriesIndex = seriesModel.seriesIndex;
  if (!seriesModel.get("silent")) {
    el.on("mousedown", largePathUpdateDataIndex);
    el.on("mousemove", largePathUpdateDataIndex);
  }
  progressiveEls && progressiveEls.push(el);
}
var largePathUpdateDataIndex = throttle(function(event) {
  const largePath = this;
  const dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);
  getECData(largePath).dataIndex = dataIndex >= 0 ? dataIndex : null;
}, 30, false);
function largePathFindDataIndex(largePath, x, y) {
  const baseDimIdx = largePath.baseDimIdx;
  const valueDimIdx = 1 - baseDimIdx;
  const points4 = largePath.shape.points;
  const largeDataIndices = largePath.largeDataIndices;
  const startPoint = [];
  const size = [];
  const barWidth = largePath.barWidth;
  for (let i = 0, len2 = points4.length / 3; i < len2; i++) {
    const ii = i * 3;
    size[baseDimIdx] = barWidth;
    size[valueDimIdx] = points4[ii + 2];
    startPoint[baseDimIdx] = points4[ii + baseDimIdx];
    startPoint[valueDimIdx] = points4[ii + valueDimIdx];
    if (size[valueDimIdx] < 0) {
      startPoint[valueDimIdx] += size[valueDimIdx];
      size[valueDimIdx] = -size[valueDimIdx];
    }
    if (x >= startPoint[0] && x <= startPoint[0] + size[0] && y >= startPoint[1] && y <= startPoint[1] + size[1]) {
      return largeDataIndices[i];
    }
  }
  return -1;
}
function createBackgroundShape(isHorizontalOrRadial, layout18, coord) {
  if (isCoordinateSystemType(coord, "cartesian2d")) {
    const rectShape = layout18;
    const coordLayout = coord.getArea();
    return {
      x: isHorizontalOrRadial ? rectShape.x : coordLayout.x,
      y: isHorizontalOrRadial ? coordLayout.y : rectShape.y,
      width: isHorizontalOrRadial ? rectShape.width : coordLayout.width,
      height: isHorizontalOrRadial ? coordLayout.height : rectShape.height
    };
  } else {
    const coordLayout = coord.getArea();
    const sectorShape = layout18;
    return {
      cx: coordLayout.cx,
      cy: coordLayout.cy,
      r0: isHorizontalOrRadial ? coordLayout.r0 : sectorShape.r0,
      r: isHorizontalOrRadial ? coordLayout.r : sectorShape.r,
      startAngle: isHorizontalOrRadial ? sectorShape.startAngle : 0,
      endAngle: isHorizontalOrRadial ? sectorShape.endAngle : Math.PI * 2
    };
  }
}
function createBackgroundEl(coord, isHorizontalOrRadial, layout18) {
  const ElementClz = coord.type === "polar" ? Sector_default : Rect_default;
  return new ElementClz({
    shape: createBackgroundShape(isHorizontalOrRadial, layout18, coord),
    silent: true,
    z2: 0
  });
}
var BarView_default = BarView;

// src/chart/bar/install.ts
function install4(registers) {
  registers.registerChartView(BarView_default);
  registers.registerSeriesModel(BarSeries_default);
  registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, curry(layout2, "bar"));
  registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("bar"));
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample("bar"));
  registers.registerAction({
    type: "changeAxisOrder",
    event: "changeAxisOrder",
    update: "update"
  }, function(payload, ecModel) {
    const componentType = payload.componentType || "series";
    ecModel.eachComponent({mainType: componentType, query: payload}, function(componentModel) {
      if (payload.sortInfo) {
        componentModel.axis.setCategorySortInfo(payload.sortInfo);
      }
    });
  });
}

// src/chart/pie/pieLayout.ts
var PI29 = Math.PI * 2;
var RADIAN = Math.PI / 180;
function getViewRect(seriesModel, api2) {
  return getLayoutRect(seriesModel.getBoxLayoutParams(), {
    width: api2.getWidth(),
    height: api2.getHeight()
  });
}
function getBasicPieLayout(seriesModel, api2) {
  const viewRect2 = getViewRect(seriesModel, api2);
  let center3 = seriesModel.get("center");
  let radius = seriesModel.get("radius");
  if (!isArray(radius)) {
    radius = [0, radius];
  }
  const width = parsePercent2(viewRect2.width, api2.getWidth());
  const height = parsePercent2(viewRect2.height, api2.getHeight());
  const size = Math.min(width, height);
  const r0 = parsePercent2(radius[0], size / 2);
  const r = parsePercent2(radius[1], size / 2);
  let cx;
  let cy;
  const coordSys = seriesModel.coordinateSystem;
  if (coordSys) {
    const point = coordSys.dataToPoint(center3);
    cx = point[0] || 0;
    cy = point[1] || 0;
  } else {
    if (!isArray(center3)) {
      center3 = [center3, center3];
    }
    cx = parsePercent2(center3[0], width) + viewRect2.x;
    cy = parsePercent2(center3[1], height) + viewRect2.y;
  }
  return {
    cx,
    cy,
    r0,
    r
  };
}
function pieLayout(seriesType2, ecModel, api2) {
  ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
    const data = seriesModel.getData();
    const valueDim = data.mapDimension("value");
    const viewRect2 = getViewRect(seriesModel, api2);
    const {cx, cy, r, r0} = getBasicPieLayout(seriesModel, api2);
    let startAngle = -seriesModel.get("startAngle") * RADIAN;
    let endAngle = seriesModel.get("endAngle");
    const padAngle = seriesModel.get("padAngle") * RADIAN;
    endAngle = endAngle === "auto" ? startAngle - PI29 : -endAngle * RADIAN;
    const minAngle = seriesModel.get("minAngle") * RADIAN;
    const minAndPadAngle = minAngle + padAngle;
    let validDataCount = 0;
    data.each(valueDim, function(value) {
      !isNaN(value) && validDataCount++;
    });
    const sum2 = data.getSum(valueDim);
    let unitRadian = Math.PI / (sum2 || validDataCount) * 2;
    const clockwise = seriesModel.get("clockwise");
    const roseType = seriesModel.get("roseType");
    const stillShowZeroSum = seriesModel.get("stillShowZeroSum");
    const extent3 = data.getDataExtent(valueDim);
    extent3[0] = 0;
    const dir3 = clockwise ? 1 : -1;
    const angles = [startAngle, endAngle];
    const halfPadAngle = dir3 * padAngle / 2;
    normalizeArcAngles(angles, !clockwise);
    [startAngle, endAngle] = angles;
    const layoutData = getSeriesLayoutData(seriesModel);
    layoutData.startAngle = startAngle;
    layoutData.endAngle = endAngle;
    layoutData.clockwise = clockwise;
    const angleRange = Math.abs(endAngle - startAngle);
    let restAngle = angleRange;
    let valueSumLargerThanMinAngle = 0;
    let currentAngle = startAngle;
    data.setLayout({viewRect: viewRect2, r});
    data.each(valueDim, function(value, idx) {
      let angle;
      if (isNaN(value)) {
        data.setItemLayout(idx, {
          angle: NaN,
          startAngle: NaN,
          endAngle: NaN,
          clockwise,
          cx,
          cy,
          r0,
          r: roseType ? NaN : r
        });
        return;
      }
      if (roseType !== "area") {
        angle = sum2 === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
      } else {
        angle = angleRange / validDataCount;
      }
      if (angle < minAndPadAngle) {
        angle = minAndPadAngle;
        restAngle -= minAndPadAngle;
      } else {
        valueSumLargerThanMinAngle += value;
      }
      const endAngle2 = currentAngle + dir3 * angle;
      let actualStartAngle = 0;
      let actualEndAngle = 0;
      if (padAngle > angle) {
        actualStartAngle = currentAngle + dir3 * angle / 2;
        actualEndAngle = actualStartAngle;
      } else {
        actualStartAngle = currentAngle + halfPadAngle;
        actualEndAngle = endAngle2 - halfPadAngle;
      }
      data.setItemLayout(idx, {
        angle,
        startAngle: actualStartAngle,
        endAngle: actualEndAngle,
        clockwise,
        cx,
        cy,
        r0,
        r: roseType ? linearMap(value, extent3, [r0, r]) : r
      });
      currentAngle = endAngle2;
    });
    if (restAngle < PI29 && validDataCount) {
      if (restAngle <= 1e-3) {
        const angle = angleRange / validDataCount;
        data.each(valueDim, function(value, idx) {
          if (!isNaN(value)) {
            const layout18 = data.getItemLayout(idx);
            layout18.angle = angle;
            let actualStartAngle = 0;
            let actualEndAngle = 0;
            if (angle < padAngle) {
              actualStartAngle = startAngle + dir3 * (idx + 1 / 2) * angle;
              actualEndAngle = actualStartAngle;
            } else {
              actualStartAngle = startAngle + dir3 * idx * angle + halfPadAngle;
              actualEndAngle = startAngle + dir3 * (idx + 1) * angle - halfPadAngle;
            }
            layout18.startAngle = actualStartAngle;
            layout18.endAngle = actualEndAngle;
          }
        });
      } else {
        unitRadian = restAngle / valueSumLargerThanMinAngle;
        currentAngle = startAngle;
        data.each(valueDim, function(value, idx) {
          if (!isNaN(value)) {
            const layout18 = data.getItemLayout(idx);
            const angle = layout18.angle === minAndPadAngle ? minAndPadAngle : value * unitRadian;
            let actualStartAngle = 0;
            let actualEndAngle = 0;
            if (angle < padAngle) {
              actualStartAngle = currentAngle + dir3 * angle / 2;
              actualEndAngle = actualStartAngle;
            } else {
              actualStartAngle = currentAngle + halfPadAngle;
              actualEndAngle = currentAngle + dir3 * angle - halfPadAngle;
            }
            layout18.startAngle = actualStartAngle;
            layout18.endAngle = actualEndAngle;
            currentAngle += dir3 * angle;
          }
        });
      }
    }
  });
}
var getSeriesLayoutData = makeInner();

// src/processor/dataFilter.ts
function dataFilter(seriesType2) {
  return {
    seriesType: seriesType2,
    reset: function(seriesModel, ecModel) {
      const legendModels = ecModel.findComponents({
        mainType: "legend"
      });
      if (!legendModels || !legendModels.length) {
        return;
      }
      const data = seriesModel.getData();
      data.filterSelf(function(idx) {
        const name = data.getName(idx);
        for (let i = 0; i < legendModels.length; i++) {
          if (!legendModels[i].isSelected(name)) {
            return false;
          }
        }
        return true;
      });
    }
  };
}

// src/chart/pie/labelLayout.ts
var RADIAN2 = Math.PI / 180;
function adjustSingleSide(list, cx, cy, r, dir3, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {
  if (list.length < 2) {
    return;
  }
  ;
  function recalculateXOnSemiToAlignOnEllipseCurve(semi) {
    const rB = semi.rB;
    const rB2 = rB * rB;
    for (let i = 0; i < semi.list.length; i++) {
      const item = semi.list[i];
      const dy = Math.abs(item.label.y - cy);
      const rA = r + item.len;
      const rA2 = rA * rA;
      const dx = Math.sqrt((1 - Math.abs(dy * dy / rB2)) * rA2);
      const newX = cx + (dx + item.len2) * dir3;
      const deltaX = newX - item.label.x;
      const newTargetWidth = item.targetTextWidth - deltaX * dir3;
      constrainTextWidth(item, newTargetWidth, true);
      item.label.x = newX;
    }
  }
  function recalculateX(items) {
    const topSemi = {list: [], maxY: 0};
    const bottomSemi = {list: [], maxY: 0};
    for (let i = 0; i < items.length; i++) {
      if (items[i].labelAlignTo !== "none") {
        continue;
      }
      const item = items[i];
      const semi = item.label.y > cy ? bottomSemi : topSemi;
      const dy = Math.abs(item.label.y - cy);
      if (dy >= semi.maxY) {
        const dx = item.label.x - cx - item.len2 * dir3;
        const rA = r + item.len;
        const rB = Math.abs(dx) < rA ? Math.sqrt(dy * dy / (1 - dx * dx / rA / rA)) : rA;
        semi.rB = rB;
        semi.maxY = dy;
      }
      semi.list.push(item);
    }
    recalculateXOnSemiToAlignOnEllipseCurve(topSemi);
    recalculateXOnSemiToAlignOnEllipseCurve(bottomSemi);
  }
  const len2 = list.length;
  for (let i = 0; i < len2; i++) {
    if (list[i].position === "outer" && list[i].labelAlignTo === "labelLine") {
      const dx = list[i].label.x - farthestX;
      list[i].linePoints[1][0] += dx;
      list[i].label.x = farthestX;
    }
  }
  if (shiftLayoutOnY(list, viewTop, viewTop + viewHeight)) {
    recalculateX(list);
  }
}
function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop) {
  const leftList = [];
  const rightList = [];
  let leftmostX = Number.MAX_VALUE;
  let rightmostX = -Number.MAX_VALUE;
  for (let i = 0; i < labelLayoutList.length; i++) {
    const label = labelLayoutList[i].label;
    if (isPositionCenter(labelLayoutList[i])) {
      continue;
    }
    if (label.x < cx) {
      leftmostX = Math.min(leftmostX, label.x);
      leftList.push(labelLayoutList[i]);
    } else {
      rightmostX = Math.max(rightmostX, label.x);
      rightList.push(labelLayoutList[i]);
    }
  }
  for (let i = 0; i < labelLayoutList.length; i++) {
    const layout18 = labelLayoutList[i];
    if (!isPositionCenter(layout18) && layout18.linePoints) {
      if (layout18.labelStyleWidth != null) {
        continue;
      }
      const label = layout18.label;
      const linePoints = layout18.linePoints;
      let targetTextWidth;
      if (layout18.labelAlignTo === "edge") {
        if (label.x < cx) {
          targetTextWidth = linePoints[2][0] - layout18.labelDistance - viewLeft - layout18.edgeDistance;
        } else {
          targetTextWidth = viewLeft + viewWidth - layout18.edgeDistance - linePoints[2][0] - layout18.labelDistance;
        }
      } else if (layout18.labelAlignTo === "labelLine") {
        if (label.x < cx) {
          targetTextWidth = leftmostX - viewLeft - layout18.bleedMargin;
        } else {
          targetTextWidth = viewLeft + viewWidth - rightmostX - layout18.bleedMargin;
        }
      } else {
        if (label.x < cx) {
          targetTextWidth = label.x - viewLeft - layout18.bleedMargin;
        } else {
          targetTextWidth = viewLeft + viewWidth - label.x - layout18.bleedMargin;
        }
      }
      layout18.targetTextWidth = targetTextWidth;
      constrainTextWidth(layout18, targetTextWidth);
    }
  }
  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);
  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);
  for (let i = 0; i < labelLayoutList.length; i++) {
    const layout18 = labelLayoutList[i];
    if (!isPositionCenter(layout18) && layout18.linePoints) {
      const label = layout18.label;
      const linePoints = layout18.linePoints;
      const isAlignToEdge = layout18.labelAlignTo === "edge";
      const padding = label.style.padding;
      const paddingH = padding ? padding[1] + padding[3] : 0;
      const extraPaddingH = label.style.backgroundColor ? 0 : paddingH;
      const realTextWidth = layout18.rect.width + extraPaddingH;
      const dist3 = linePoints[1][0] - linePoints[2][0];
      if (isAlignToEdge) {
        if (label.x < cx) {
          linePoints[2][0] = viewLeft + layout18.edgeDistance + realTextWidth + layout18.labelDistance;
        } else {
          linePoints[2][0] = viewLeft + viewWidth - layout18.edgeDistance - realTextWidth - layout18.labelDistance;
        }
      } else {
        if (label.x < cx) {
          linePoints[2][0] = label.x + layout18.labelDistance;
        } else {
          linePoints[2][0] = label.x - layout18.labelDistance;
        }
        linePoints[1][0] = linePoints[2][0] + dist3;
      }
      linePoints[1][1] = linePoints[2][1] = label.y;
    }
  }
}
function constrainTextWidth(layout18, availableWidth, forceRecalculate = false) {
  if (layout18.labelStyleWidth != null) {
    return;
  }
  const label = layout18.label;
  const style = label.style;
  const textRect = layout18.rect;
  const bgColor = style.backgroundColor;
  const padding = style.padding;
  const paddingH = padding ? padding[1] + padding[3] : 0;
  const overflow = style.overflow;
  const oldOuterWidth = textRect.width + (bgColor ? 0 : paddingH);
  if (availableWidth < oldOuterWidth || forceRecalculate) {
    const oldHeight = textRect.height;
    if (overflow && overflow.match("break")) {
      label.setStyle("backgroundColor", null);
      label.setStyle("width", availableWidth - paddingH);
      const innerRect = label.getBoundingRect();
      label.setStyle("width", Math.ceil(innerRect.width));
      label.setStyle("backgroundColor", bgColor);
    } else {
      const availableInnerWidth = availableWidth - paddingH;
      const newWidth = availableWidth < oldOuterWidth ? availableInnerWidth : forceRecalculate ? availableInnerWidth > layout18.unconstrainedWidth ? null : availableInnerWidth : null;
      label.setStyle("width", newWidth);
    }
    const newRect = label.getBoundingRect();
    textRect.width = newRect.width;
    const margin = (label.style.margin || 0) + 2.1;
    textRect.height = newRect.height + margin;
    textRect.y -= (textRect.height - oldHeight) / 2;
  }
}
function isPositionCenter(sectorShape) {
  return sectorShape.position === "center";
}
function pieLabelLayout(seriesModel) {
  const data = seriesModel.getData();
  const labelLayoutList = [];
  let cx;
  let cy;
  let hasLabelRotate = false;
  const minShowLabelRadian = (seriesModel.get("minShowLabelAngle") || 0) * RADIAN2;
  const viewRect2 = data.getLayout("viewRect");
  const r = data.getLayout("r");
  const viewWidth = viewRect2.width;
  const viewLeft = viewRect2.x;
  const viewTop = viewRect2.y;
  const viewHeight = viewRect2.height;
  function setNotShow(el) {
    el.ignore = true;
  }
  function isLabelShown(label) {
    if (!label.ignore) {
      return true;
    }
    for (const key in label.states) {
      if (label.states[key].ignore === false) {
        return true;
      }
    }
    return false;
  }
  data.each(function(idx) {
    const sector = data.getItemGraphicEl(idx);
    const sectorShape = sector.shape;
    const label = sector.getTextContent();
    const labelLine = sector.getTextGuideLine();
    const itemModel = data.getItemModel(idx);
    const labelModel = itemModel.getModel("label");
    const labelPosition = labelModel.get("position") || itemModel.get(["emphasis", "label", "position"]);
    const labelDistance = labelModel.get("distanceToLabelLine");
    const labelAlignTo = labelModel.get("alignTo");
    const edgeDistance = parsePercent2(labelModel.get("edgeDistance"), viewWidth);
    const bleedMargin = labelModel.get("bleedMargin");
    const labelLineModel = itemModel.getModel("labelLine");
    let labelLineLen = labelLineModel.get("length");
    labelLineLen = parsePercent2(labelLineLen, viewWidth);
    let labelLineLen2 = labelLineModel.get("length2");
    labelLineLen2 = parsePercent2(labelLineLen2, viewWidth);
    if (Math.abs(sectorShape.endAngle - sectorShape.startAngle) < minShowLabelRadian) {
      each(label.states, setNotShow);
      label.ignore = true;
      if (labelLine) {
        each(labelLine.states, setNotShow);
        labelLine.ignore = true;
      }
      return;
    }
    if (!isLabelShown(label)) {
      return;
    }
    const midAngle = (sectorShape.startAngle + sectorShape.endAngle) / 2;
    const nx = Math.cos(midAngle);
    const ny = Math.sin(midAngle);
    let textX;
    let textY;
    let linePoints;
    let textAlign;
    cx = sectorShape.cx;
    cy = sectorShape.cy;
    const isLabelInside = labelPosition === "inside" || labelPosition === "inner";
    if (labelPosition === "center") {
      textX = sectorShape.cx;
      textY = sectorShape.cy;
      textAlign = "center";
    } else {
      const x1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * nx : sectorShape.r * nx) + cx;
      const y1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * ny : sectorShape.r * ny) + cy;
      textX = x1 + nx * 3;
      textY = y1 + ny * 3;
      if (!isLabelInside) {
        const x2 = x1 + nx * (labelLineLen + r - sectorShape.r);
        const y2 = y1 + ny * (labelLineLen + r - sectorShape.r);
        const x3 = x2 + (nx < 0 ? -1 : 1) * labelLineLen2;
        const y3 = y2;
        if (labelAlignTo === "edge") {
          textX = nx < 0 ? viewLeft + edgeDistance : viewLeft + viewWidth - edgeDistance;
        } else {
          textX = x3 + (nx < 0 ? -labelDistance : labelDistance);
        }
        textY = y3;
        linePoints = [[x1, y1], [x2, y2], [x3, y3]];
      }
      textAlign = isLabelInside ? "center" : labelAlignTo === "edge" ? nx > 0 ? "right" : "left" : nx > 0 ? "left" : "right";
    }
    const PI11 = Math.PI;
    let labelRotate = 0;
    const rotate2 = labelModel.get("rotate");
    if (isNumber(rotate2)) {
      labelRotate = rotate2 * (PI11 / 180);
    } else if (labelPosition === "center") {
      labelRotate = 0;
    } else if (rotate2 === "radial" || rotate2 === true) {
      const radialAngle = nx < 0 ? -midAngle + PI11 : -midAngle;
      labelRotate = radialAngle;
    } else if (rotate2 === "tangential" && labelPosition !== "outside" && labelPosition !== "outer") {
      let rad = Math.atan2(nx, ny);
      if (rad < 0) {
        rad = PI11 * 2 + rad;
      }
      const isDown = ny > 0;
      if (isDown) {
        rad = PI11 + rad;
      }
      labelRotate = rad - PI11;
    }
    hasLabelRotate = !!labelRotate;
    label.x = textX;
    label.y = textY;
    label.rotation = labelRotate;
    label.setStyle({
      verticalAlign: "middle"
    });
    if (!isLabelInside) {
      const textRect = label.getBoundingRect().clone();
      textRect.applyTransform(label.getComputedTransform());
      const margin = (label.style.margin || 0) + 2.1;
      textRect.y -= margin / 2;
      textRect.height += margin;
      labelLayoutList.push({
        label,
        labelLine,
        position: labelPosition,
        len: labelLineLen,
        len2: labelLineLen2,
        minTurnAngle: labelLineModel.get("minTurnAngle"),
        maxSurfaceAngle: labelLineModel.get("maxSurfaceAngle"),
        surfaceNormal: new Point_default(nx, ny),
        linePoints,
        textAlign,
        labelDistance,
        labelAlignTo,
        edgeDistance,
        bleedMargin,
        rect: textRect,
        unconstrainedWidth: textRect.width,
        labelStyleWidth: label.style.width
      });
    } else {
      label.setStyle({
        align: textAlign
      });
      const selectState = label.states.select;
      if (selectState) {
        selectState.x += label.x;
        selectState.y += label.y;
      }
    }
    sector.setTextConfig({
      inside: isLabelInside
    });
  });
  if (!hasLabelRotate && seriesModel.get("avoidLabelOverlap")) {
    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop);
  }
  for (let i = 0; i < labelLayoutList.length; i++) {
    const layout18 = labelLayoutList[i];
    const label = layout18.label;
    const labelLine = layout18.labelLine;
    const notShowLabel = isNaN(label.x) || isNaN(label.y);
    if (label) {
      label.setStyle({
        align: layout18.textAlign
      });
      if (notShowLabel) {
        each(label.states, setNotShow);
        label.ignore = true;
      }
      const selectState = label.states.select;
      if (selectState) {
        selectState.x += label.x;
        selectState.y += label.y;
      }
    }
    if (labelLine) {
      const linePoints = layout18.linePoints;
      if (notShowLabel || !linePoints) {
        each(labelLine.states, setNotShow);
        labelLine.ignore = true;
      } else {
        limitTurnAngle(linePoints, layout18.minTurnAngle);
        limitSurfaceAngle(linePoints, layout18.surfaceNormal, layout18.maxSurfaceAngle);
        labelLine.setShape({points: linePoints});
        label.__hostTarget.textGuideLineConfig = {
          anchor: new Point_default(linePoints[0][0], linePoints[0][1])
        };
      }
    }
  }
}

// src/chart/pie/PieView.ts
var PiePiece = class extends Sector_default {
  constructor(data, idx, startAngle) {
    super();
    this.z2 = 2;
    const text = new Text_default();
    this.setTextContent(text);
    this.updateData(data, idx, startAngle, true);
  }
  updateData(data, idx, startAngle, firstCreate) {
    const sector = this;
    const seriesModel = data.hostModel;
    const itemModel = data.getItemModel(idx);
    const emphasisModel = itemModel.getModel("emphasis");
    const layout18 = data.getItemLayout(idx);
    const sectorShape = extend(getSectorCornerRadius(itemModel.getModel("itemStyle"), layout18, true), layout18);
    if (isNaN(sectorShape.startAngle)) {
      sector.setShape(sectorShape);
      return;
    }
    if (firstCreate) {
      sector.setShape(sectorShape);
      const animationType = seriesModel.getShallow("animationType");
      if (seriesModel.ecModel.ssr) {
        initProps(sector, {
          scaleX: 0,
          scaleY: 0
        }, seriesModel, {dataIndex: idx, isFrom: true});
        sector.originX = sectorShape.cx;
        sector.originY = sectorShape.cy;
      } else if (animationType === "scale") {
        sector.shape.r = layout18.r0;
        initProps(sector, {
          shape: {
            r: layout18.r
          }
        }, seriesModel, idx);
      } else {
        if (startAngle != null) {
          sector.setShape({startAngle, endAngle: startAngle});
          initProps(sector, {
            shape: {
              startAngle: layout18.startAngle,
              endAngle: layout18.endAngle
            }
          }, seriesModel, idx);
        } else {
          sector.shape.endAngle = layout18.startAngle;
          updateProps(sector, {
            shape: {
              endAngle: layout18.endAngle
            }
          }, seriesModel, idx);
        }
      }
    } else {
      saveOldStyle(sector);
      updateProps(sector, {
        shape: sectorShape
      }, seriesModel, idx);
    }
    sector.useStyle(data.getItemVisual(idx, "style"));
    setStatesStylesFromModel(sector, itemModel);
    const midAngle = (layout18.startAngle + layout18.endAngle) / 2;
    const offset = seriesModel.get("selectedOffset");
    const dx = Math.cos(midAngle) * offset;
    const dy = Math.sin(midAngle) * offset;
    const cursorStyle = itemModel.getShallow("cursor");
    cursorStyle && sector.attr("cursor", cursorStyle);
    this._updateLabel(seriesModel, data, idx);
    sector.ensureState("emphasis").shape = extend({
      r: layout18.r + (emphasisModel.get("scale") ? emphasisModel.get("scaleSize") || 0 : 0)
    }, getSectorCornerRadius(emphasisModel.getModel("itemStyle"), layout18));
    extend(sector.ensureState("select"), {
      x: dx,
      y: dy,
      shape: getSectorCornerRadius(itemModel.getModel(["select", "itemStyle"]), layout18)
    });
    extend(sector.ensureState("blur"), {
      shape: getSectorCornerRadius(itemModel.getModel(["blur", "itemStyle"]), layout18)
    });
    const labelLine = sector.getTextGuideLine();
    const labelText = sector.getTextContent();
    labelLine && extend(labelLine.ensureState("select"), {
      x: dx,
      y: dy
    });
    extend(labelText.ensureState("select"), {
      x: dx,
      y: dy
    });
    toggleHoverEmphasis(this, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  }
  _updateLabel(seriesModel, data, idx) {
    const sector = this;
    const itemModel = data.getItemModel(idx);
    const labelLineModel = itemModel.getModel("labelLine");
    const style = data.getItemVisual(idx, "style");
    const visualColor = style && style.fill;
    const visualOpacity = style && style.opacity;
    setLabelStyle(sector, getLabelStatesModels(itemModel), {
      labelFetcher: data.hostModel,
      labelDataIndex: idx,
      inheritColor: visualColor,
      defaultOpacity: visualOpacity,
      defaultText: seriesModel.getFormattedLabel(idx, "normal") || data.getName(idx)
    });
    const labelText = sector.getTextContent();
    sector.setTextConfig({
      position: null,
      rotation: null
    });
    labelText.attr({
      z2: 10
    });
    const labelPosition = seriesModel.get(["label", "position"]);
    if (labelPosition !== "outside" && labelPosition !== "outer") {
      sector.removeTextGuideLine();
    } else {
      let polyline = this.getTextGuideLine();
      if (!polyline) {
        polyline = new Polyline_default();
        this.setTextGuideLine(polyline);
      }
      setLabelLineStyle(this, getLabelLineStatesModels(itemModel), {
        stroke: visualColor,
        opacity: retrieve3(labelLineModel.get(["lineStyle", "opacity"]), visualOpacity, 1)
      });
    }
  }
};
var PieView = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.ignoreLabelLineUpdate = true;
  }
  render(seriesModel, ecModel, api2, payload) {
    const data = seriesModel.getData();
    const oldData = this._data;
    const group = this.group;
    let startAngle;
    if (!oldData && data.count() > 0) {
      let shape = data.getItemLayout(0);
      for (let s = 1; isNaN(shape && shape.startAngle) && s < data.count(); ++s) {
        shape = data.getItemLayout(s);
      }
      if (shape) {
        startAngle = shape.startAngle;
      }
    }
    if (this._emptyCircleSector) {
      group.remove(this._emptyCircleSector);
    }
    if (data.count() === 0 && seriesModel.get("showEmptyCircle")) {
      const layoutData = getSeriesLayoutData(seriesModel);
      const sector = new Sector_default({
        shape: extend(getBasicPieLayout(seriesModel, api2), layoutData)
      });
      sector.useStyle(seriesModel.getModel("emptyCircleStyle").getItemStyle());
      this._emptyCircleSector = sector;
      group.add(sector);
    }
    data.diff(oldData).add(function(idx) {
      const piePiece = new PiePiece(data, idx, startAngle);
      data.setItemGraphicEl(idx, piePiece);
      group.add(piePiece);
    }).update(function(newIdx, oldIdx) {
      const piePiece = oldData.getItemGraphicEl(oldIdx);
      piePiece.updateData(data, newIdx, startAngle);
      piePiece.off("click");
      group.add(piePiece);
      data.setItemGraphicEl(newIdx, piePiece);
    }).remove(function(idx) {
      const piePiece = oldData.getItemGraphicEl(idx);
      removeElementWithFadeOut(piePiece, seriesModel, idx);
    }).execute();
    pieLabelLayout(seriesModel);
    if (seriesModel.get("animationTypeUpdate") !== "expansion") {
      this._data = data;
    }
  }
  dispose() {
  }
  containPoint(point, seriesModel) {
    const data = seriesModel.getData();
    const itemLayout = data.getItemLayout(0);
    if (itemLayout) {
      const dx = point[0] - itemLayout.cx;
      const dy = point[1] - itemLayout.cy;
      const radius = Math.sqrt(dx * dx + dy * dy);
      return radius <= itemLayout.r && radius >= itemLayout.r0;
    }
  }
};
PieView.type = "pie";
var PieView_default = PieView;

// src/chart/helper/createSeriesDataSimply.ts
function createSeriesDataSimply(seriesModel, opt, nameList) {
  opt = isArray(opt) && {
    coordDimensions: opt
  } || extend({
    encodeDefine: seriesModel.getEncode()
  }, opt);
  const source = seriesModel.getSource();
  const {dimensions} = prepareSeriesDataSchema(source, opt);
  const list = new SeriesData_default(dimensions, seriesModel);
  list.initData(source, nameList);
  return list;
}

// src/visual/LegendVisualProvider.ts
var LegendVisualProvider = class {
  constructor(getDataWithEncodedVisual, getRawData2) {
    this._getDataWithEncodedVisual = getDataWithEncodedVisual;
    this._getRawData = getRawData2;
  }
  getAllNames() {
    const rawData = this._getRawData();
    return rawData.mapArray(rawData.getName);
  }
  containName(name) {
    const rawData = this._getRawData();
    return rawData.indexOfName(name) >= 0;
  }
  indexOfName(name) {
    const dataWithEncodedVisual = this._getDataWithEncodedVisual();
    return dataWithEncodedVisual.indexOfName(name);
  }
  getItemVisual(dataIndex, key) {
    const dataWithEncodedVisual = this._getDataWithEncodedVisual();
    return dataWithEncodedVisual.getItemVisual(dataIndex, key);
  }
};
var LegendVisualProvider_default = LegendVisualProvider;

// src/chart/pie/PieSeries.ts
var innerData = makeInner();
var PieSeriesModel = class extends Series_default {
  init(option) {
    super.init.apply(this, arguments);
    this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this));
    this._defaultLabelLine(option);
  }
  mergeOption() {
    super.mergeOption.apply(this, arguments);
  }
  getInitialData() {
    return createSeriesDataSimply(this, {
      coordDimensions: ["value"],
      encodeDefaulter: curry(makeSeriesEncodeForNameBased, this)
    });
  }
  getDataParams(dataIndex) {
    const data = this.getData();
    const dataInner = innerData(data);
    let seats = dataInner.seats;
    if (!seats) {
      const valueList = [];
      data.each(data.mapDimension("value"), function(value) {
        valueList.push(value);
      });
      seats = dataInner.seats = getPercentSeats(valueList, data.hostModel.get("percentPrecision"));
    }
    const params = super.getDataParams(dataIndex);
    params.percent = seats[dataIndex] || 0;
    params.$vars.push("percent");
    return params;
  }
  _defaultLabelLine(option) {
    defaultEmphasis(option, "labelLine", ["show"]);
    const labelLineNormalOpt = option.labelLine;
    const labelLineEmphasisOpt = option.emphasis.labelLine;
    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
  }
};
PieSeriesModel.type = "series.pie";
PieSeriesModel.defaultOption = {
  z: 2,
  legendHoverLink: true,
  colorBy: "data",
  center: ["50%", "50%"],
  radius: [0, "75%"],
  clockwise: true,
  startAngle: 90,
  endAngle: "auto",
  padAngle: 0,
  minAngle: 0,
  minShowLabelAngle: 0,
  selectedOffset: 10,
  percentPrecision: 2,
  stillShowZeroSum: true,
  left: 0,
  top: 0,
  right: 0,
  bottom: 0,
  width: null,
  height: null,
  label: {
    rotate: 0,
    show: true,
    overflow: "truncate",
    position: "outer",
    alignTo: "none",
    edgeDistance: "25%",
    bleedMargin: 10,
    distanceToLabelLine: 5
  },
  labelLine: {
    show: true,
    length: 15,
    length2: 15,
    smooth: false,
    minTurnAngle: 90,
    maxSurfaceAngle: 90,
    lineStyle: {
      width: 1,
      type: "solid"
    }
  },
  itemStyle: {
    borderWidth: 1,
    borderJoin: "round"
  },
  showEmptyCircle: true,
  emptyCircleStyle: {
    color: "lightgray",
    opacity: 1
  },
  labelLayout: {
    hideOverlap: true
  },
  emphasis: {
    scale: true,
    scaleSize: 5
  },
  avoidLabelOverlap: true,
  animationType: "expansion",
  animationDuration: 1e3,
  animationTypeUpdate: "transition",
  animationEasingUpdate: "cubicInOut",
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut"
};
var PieSeries_default = PieSeriesModel;

// src/processor/negativeDataFilter.ts
function negativeDataFilter(seriesType2) {
  return {
    seriesType: seriesType2,
    reset: function(seriesModel, ecModel) {
      const data = seriesModel.getData();
      data.filterSelf(function(idx) {
        const valueDim = data.mapDimension("value");
        const curValue = data.get(valueDim, idx);
        if (isNumber(curValue) && !isNaN(curValue) && curValue < 0) {
          return false;
        }
        return true;
      });
    }
  };
}

// src/chart/pie/install.ts
function install5(registers) {
  registers.registerChartView(PieView_default);
  registers.registerSeriesModel(PieSeries_default);
  createLegacyDataSelectAction("pie", registers.registerAction);
  registers.registerLayout(curry(pieLayout, "pie"));
  registers.registerProcessor(dataFilter("pie"));
  registers.registerProcessor(negativeDataFilter("pie"));
}

// src/chart/scatter/ScatterSeries.ts
var ScatterSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = ScatterSeriesModel2.type;
    this.hasSymbolVisual = true;
  }
  getInitialData(option, ecModel) {
    return createSeriesData_default(null, this, {
      useEncodeDefaulter: true
    });
  }
  getProgressive() {
    const progressive = this.option.progressive;
    if (progressive == null) {
      return this.option.large ? 5e3 : this.get("progressive");
    }
    return progressive;
  }
  getProgressiveThreshold() {
    const progressiveThreshold = this.option.progressiveThreshold;
    if (progressiveThreshold == null) {
      return this.option.large ? 1e4 : this.get("progressiveThreshold");
    }
    return progressiveThreshold;
  }
  brushSelector(dataIndex, data, selectors) {
    return selectors.point(data.getItemLayout(dataIndex));
  }
  getZLevelKey() {
    return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
  }
};
var ScatterSeriesModel = ScatterSeriesModel2;
ScatterSeriesModel.type = "series.scatter";
ScatterSeriesModel.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"];
ScatterSeriesModel.defaultOption = {
  coordinateSystem: "cartesian2d",
  z: 2,
  legendHoverLink: true,
  symbolSize: 10,
  large: false,
  largeThreshold: 2e3,
  itemStyle: {
    opacity: 0.8
  },
  emphasis: {
    scale: true
  },
  clip: true,
  select: {
    itemStyle: {
      borderColor: "#212121"
    }
  },
  universalTransition: {
    divideShape: "clone"
  }
};
var ScatterSeries_default = ScatterSeriesModel;

// src/chart/helper/LargeSymbolDraw.ts
var BOOST_SIZE_THRESHOLD = 4;
var LargeSymbolPathShape = class {
};
var LargeSymbolPath = class extends Path_default {
  constructor(opts) {
    super(opts);
    this._off = 0;
    this.hoverDataIdx = -1;
  }
  getDefaultShape() {
    return new LargeSymbolPathShape();
  }
  reset() {
    this.notClear = false;
    this._off = 0;
  }
  buildPath(path, shape) {
    const points4 = shape.points;
    const size = shape.size;
    const symbolProxy = this.symbolProxy;
    const symbolProxyShape = symbolProxy.shape;
    const ctx = path.getContext ? path.getContext() : path;
    const canBoost = ctx && size[0] < BOOST_SIZE_THRESHOLD;
    const softClipShape = this.softClipShape;
    let i;
    if (canBoost) {
      this._ctx = ctx;
      return;
    }
    this._ctx = null;
    for (i = this._off; i < points4.length; ) {
      const x = points4[i++];
      const y = points4[i++];
      if (isNaN(x) || isNaN(y)) {
        continue;
      }
      if (softClipShape && !softClipShape.contain(x, y)) {
        continue;
      }
      symbolProxyShape.x = x - size[0] / 2;
      symbolProxyShape.y = y - size[1] / 2;
      symbolProxyShape.width = size[0];
      symbolProxyShape.height = size[1];
      symbolProxy.buildPath(path, symbolProxyShape, true);
    }
    if (this.incremental) {
      this._off = i;
      this.notClear = true;
    }
  }
  afterBrush() {
    const shape = this.shape;
    const points4 = shape.points;
    const size = shape.size;
    const ctx = this._ctx;
    const softClipShape = this.softClipShape;
    let i;
    if (!ctx) {
      return;
    }
    for (i = this._off; i < points4.length; ) {
      const x = points4[i++];
      const y = points4[i++];
      if (isNaN(x) || isNaN(y)) {
        continue;
      }
      if (softClipShape && !softClipShape.contain(x, y)) {
        continue;
      }
      ctx.fillRect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]);
    }
    if (this.incremental) {
      this._off = i;
      this.notClear = true;
    }
  }
  findDataIndex(x, y) {
    const shape = this.shape;
    const points4 = shape.points;
    const size = shape.size;
    const w = Math.max(size[0], 4);
    const h = Math.max(size[1], 4);
    for (let idx = points4.length / 2 - 1; idx >= 0; idx--) {
      const i = idx * 2;
      const x0 = points4[i] - w / 2;
      const y0 = points4[i + 1] - h / 2;
      if (x >= x0 && y >= y0 && x <= x0 + w && y <= y0 + h) {
        return idx;
      }
    }
    return -1;
  }
  contain(x, y) {
    const localPos = this.transformCoordToLocal(x, y);
    const rect = this.getBoundingRect();
    x = localPos[0];
    y = localPos[1];
    if (rect.contain(x, y)) {
      const dataIdx = this.hoverDataIdx = this.findDataIndex(x, y);
      return dataIdx >= 0;
    }
    this.hoverDataIdx = -1;
    return false;
  }
  getBoundingRect() {
    let rect = this._rect;
    if (!rect) {
      const shape = this.shape;
      const points4 = shape.points;
      const size = shape.size;
      const w = size[0];
      const h = size[1];
      let minX = Infinity;
      let minY = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      for (let i = 0; i < points4.length; ) {
        const x = points4[i++];
        const y = points4[i++];
        minX = Math.min(x, minX);
        maxX = Math.max(x, maxX);
        minY = Math.min(y, minY);
        maxY = Math.max(y, maxY);
      }
      rect = this._rect = new BoundingRect_default(minX - w / 2, minY - h / 2, maxX - minX + w, maxY - minY + h);
    }
    return rect;
  }
};
var LargeSymbolDraw = class {
  constructor() {
    this.group = new Group_default();
  }
  updateData(data, opt) {
    this._clear();
    const symbolEl = this._create();
    symbolEl.setShape({
      points: data.getLayout("points")
    });
    this._setCommon(symbolEl, data, opt);
  }
  updateLayout(data) {
    let points4 = data.getLayout("points");
    this.group.eachChild(function(child) {
      if (child.startIndex != null) {
        const len2 = (child.endIndex - child.startIndex) * 2;
        const byteOffset = child.startIndex * 4 * 2;
        points4 = new Float32Array(points4.buffer, byteOffset, len2);
      }
      child.setShape("points", points4);
      child.reset();
    });
  }
  incrementalPrepareUpdate(data) {
    this._clear();
  }
  incrementalUpdate(taskParams, data, opt) {
    const lastAdded = this._newAdded[0];
    const points4 = data.getLayout("points");
    const oldPoints = lastAdded && lastAdded.shape.points;
    if (oldPoints && oldPoints.length < 2e4) {
      const oldLen = oldPoints.length;
      const newPoints = new Float32Array(oldLen + points4.length);
      newPoints.set(oldPoints);
      newPoints.set(points4, oldLen);
      lastAdded.endIndex = taskParams.end;
      lastAdded.setShape({points: newPoints});
    } else {
      this._newAdded = [];
      const symbolEl = this._create();
      symbolEl.startIndex = taskParams.start;
      symbolEl.endIndex = taskParams.end;
      symbolEl.incremental = true;
      symbolEl.setShape({
        points: points4
      });
      this._setCommon(symbolEl, data, opt);
    }
  }
  eachRendered(cb) {
    this._newAdded[0] && cb(this._newAdded[0]);
  }
  _create() {
    const symbolEl = new LargeSymbolPath({
      cursor: "default"
    });
    symbolEl.ignoreCoarsePointer = true;
    this.group.add(symbolEl);
    this._newAdded.push(symbolEl);
    return symbolEl;
  }
  _setCommon(symbolEl, data, opt) {
    const hostModel = data.hostModel;
    opt = opt || {};
    const size = data.getVisual("symbolSize");
    symbolEl.setShape("size", size instanceof Array ? size : [size, size]);
    symbolEl.softClipShape = opt.clipShape || null;
    symbolEl.symbolProxy = createSymbol(data.getVisual("symbol"), 0, 0, 0, 0);
    symbolEl.setColor = symbolEl.symbolProxy.setColor;
    const extrudeShadow = symbolEl.shape.size[0] < BOOST_SIZE_THRESHOLD;
    symbolEl.useStyle(hostModel.getModel("itemStyle").getItemStyle(extrudeShadow ? ["color", "shadowBlur", "shadowColor"] : ["color"]));
    const globalStyle = data.getVisual("style");
    const visualColor = globalStyle && globalStyle.fill;
    if (visualColor) {
      symbolEl.setColor(visualColor);
    }
    const ecData = getECData(symbolEl);
    ecData.seriesIndex = hostModel.seriesIndex;
    symbolEl.on("mousemove", function(e2) {
      ecData.dataIndex = null;
      const dataIndex = symbolEl.hoverDataIdx;
      if (dataIndex >= 0) {
        ecData.dataIndex = dataIndex + (symbolEl.startIndex || 0);
      }
    });
  }
  remove() {
    this._clear();
  }
  _clear() {
    this._newAdded = [];
    this.group.removeAll();
  }
};
var LargeSymbolDraw_default = LargeSymbolDraw;

// src/chart/scatter/ScatterView.ts
var ScatterView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = ScatterView2.type;
  }
  render(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    const symbolDraw = this._updateSymbolDraw(data, seriesModel);
    symbolDraw.updateData(data, {
      clipShape: this._getClipShape(seriesModel)
    });
    this._finished = true;
  }
  incrementalPrepareRender(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    const symbolDraw = this._updateSymbolDraw(data, seriesModel);
    symbolDraw.incrementalPrepareUpdate(data);
    this._finished = false;
  }
  incrementalRender(taskParams, seriesModel, ecModel) {
    this._symbolDraw.incrementalUpdate(taskParams, seriesModel.getData(), {
      clipShape: this._getClipShape(seriesModel)
    });
    this._finished = taskParams.end === seriesModel.getData().count();
  }
  updateTransform(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    this.group.dirty();
    if (!this._finished || data.count() > 1e4) {
      return {
        update: true
      };
    } else {
      const res = pointsLayout("").reset(seriesModel, ecModel, api2);
      if (res.progress) {
        res.progress({start: 0, end: data.count(), count: data.count()}, data);
      }
      this._symbolDraw.updateLayout(data);
    }
  }
  eachRendered(cb) {
    this._symbolDraw && this._symbolDraw.eachRendered(cb);
  }
  _getClipShape(seriesModel) {
    if (!seriesModel.get("clip", true)) {
      return;
    }
    const coordSys = seriesModel.coordinateSystem;
    return coordSys && coordSys.getArea && coordSys.getArea(0.1);
  }
  _updateSymbolDraw(data, seriesModel) {
    let symbolDraw = this._symbolDraw;
    const pipelineContext = seriesModel.pipelineContext;
    const isLargeDraw = pipelineContext.large;
    if (!symbolDraw || isLargeDraw !== this._isLargeDraw) {
      symbolDraw && symbolDraw.remove();
      symbolDraw = this._symbolDraw = isLargeDraw ? new LargeSymbolDraw_default() : new SymbolDraw_default();
      this._isLargeDraw = isLargeDraw;
      this.group.removeAll();
    }
    this.group.add(symbolDraw.group);
    return symbolDraw;
  }
  remove(ecModel, api2) {
    this._symbolDraw && this._symbolDraw.remove(true);
    this._symbolDraw = null;
  }
  dispose() {
  }
};
var ScatterView = ScatterView2;
ScatterView.type = "scatter";
var ScatterView_default = ScatterView;

// src/coord/cartesian/GridModel.ts
var GridModel = class extends Component_default {
};
GridModel.type = "grid";
GridModel.dependencies = ["xAxis", "yAxis"];
GridModel.layoutMode = "box";
GridModel.defaultOption = {
  show: false,
  z: 0,
  left: "10%",
  top: 60,
  right: "10%",
  bottom: 70,
  containLabel: false,
  backgroundColor: "rgba(0,0,0,0)",
  borderWidth: 1,
  borderColor: "#ccc"
};
var GridModel_default = GridModel;

// src/coord/cartesian/AxisModel.ts
var CartesianAxisModel = class extends Component_default {
  getCoordSysModel() {
    return this.getReferringComponents("grid", SINGLE_REFERRING).models[0];
  }
};
CartesianAxisModel.type = "cartesian2dAxis";
mixin(CartesianAxisModel, AxisModelCommonMixin);

// src/coord/axisDefault.ts
var defaultOption = {
  show: true,
  z: 0,
  inverse: false,
  name: "",
  nameLocation: "end",
  nameRotate: null,
  nameTruncate: {
    maxWidth: null,
    ellipsis: "...",
    placeholder: "."
  },
  nameTextStyle: {},
  nameGap: 15,
  silent: false,
  triggerEvent: false,
  tooltip: {
    show: false
  },
  axisPointer: {},
  axisLine: {
    show: true,
    onZero: true,
    onZeroAxisIndex: null,
    lineStyle: {
      color: "#6E7079",
      width: 1,
      type: "solid"
    },
    symbol: ["none", "none"],
    symbolSize: [10, 15]
  },
  axisTick: {
    show: true,
    inside: false,
    length: 5,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: true,
    inside: false,
    rotate: 0,
    showMinLabel: null,
    showMaxLabel: null,
    margin: 8,
    fontSize: 12
  },
  splitLine: {
    show: true,
    lineStyle: {
      color: ["#E0E6F1"],
      width: 1,
      type: "solid"
    }
  },
  splitArea: {
    show: false,
    areaStyle: {
      color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
    }
  }
};
var categoryAxis = merge({
  boundaryGap: true,
  deduplication: null,
  splitLine: {
    show: false
  },
  axisTick: {
    alignWithLabel: false,
    interval: "auto"
  },
  axisLabel: {
    interval: "auto"
  }
}, defaultOption);
var valueAxis = merge({
  boundaryGap: [0, 0],
  axisLine: {
    show: "auto"
  },
  axisTick: {
    show: "auto"
  },
  splitNumber: 5,
  minorTick: {
    show: false,
    splitNumber: 5,
    length: 3,
    lineStyle: {}
  },
  minorSplitLine: {
    show: false,
    lineStyle: {
      color: "#F4F7FD",
      width: 1
    }
  }
}, defaultOption);
var timeAxis = merge({
  splitNumber: 6,
  axisLabel: {
    showMinLabel: false,
    showMaxLabel: false,
    rich: {
      primary: {
        fontWeight: "bold"
      }
    }
  },
  splitLine: {
    show: false
  }
}, valueAxis);
var logAxis = defaults({
  logBase: 10
}, valueAxis);
var axisDefault_default = {
  category: categoryAxis,
  value: valueAxis,
  time: timeAxis,
  log: logAxis
};

// src/coord/axisCommonTypes.ts
var AXIS_TYPES = {value: 1, category: 1, time: 1, log: 1};

// src/coord/axisModelCreator.ts
function axisModelCreator(registers, axisName, BaseAxisModelClass, extraDefaultOption) {
  each(AXIS_TYPES, function(v, axisType) {
    const defaultOption3 = merge(merge({}, axisDefault_default[axisType], true), extraDefaultOption, true);
    class AxisModel extends BaseAxisModelClass {
      constructor() {
        super(...arguments);
        this.type = axisName + "Axis." + axisType;
      }
      mergeDefaultAndTheme(option, ecModel) {
        const layoutMode = fetchLayoutMode(this);
        const inputPositionParams = layoutMode ? getLayoutParams(option) : {};
        const themeModel = ecModel.getTheme();
        merge(option, themeModel.get(axisType + "Axis"));
        merge(option, this.getDefaultOption());
        option.type = getAxisType(option);
        if (layoutMode) {
          mergeLayoutParam(option, inputPositionParams, layoutMode);
        }
      }
      optionUpdated() {
        const thisOption = this.option;
        if (thisOption.type === "category") {
          this.__ordinalMeta = OrdinalMeta_default.createByAxisModel(this);
        }
      }
      getCategories(rawData) {
        const option = this.option;
        if (option.type === "category") {
          if (rawData) {
            return option.data;
          }
          return this.__ordinalMeta.categories;
        }
      }
      getOrdinalMeta() {
        return this.__ordinalMeta;
      }
    }
    AxisModel.type = axisName + "Axis." + axisType;
    AxisModel.defaultOption = defaultOption3;
    registers.registerComponentModel(AxisModel);
  });
  registers.registerSubTypeDefaulter(axisName + "Axis", getAxisType);
}
function getAxisType(option) {
  return option.type || (option.data ? "category" : "value");
}

// src/coord/cartesian/Cartesian.ts
var Cartesian = class {
  constructor(name) {
    this.type = "cartesian";
    this._dimList = [];
    this._axes = {};
    this.name = name || "";
  }
  getAxis(dim) {
    return this._axes[dim];
  }
  getAxes() {
    return map(this._dimList, function(dim) {
      return this._axes[dim];
    }, this);
  }
  getAxesByScale(scaleType) {
    scaleType = scaleType.toLowerCase();
    return filter(this.getAxes(), function(axis) {
      return axis.scale.type === scaleType;
    });
  }
  addAxis(axis) {
    const dim = axis.dim;
    this._axes[dim] = axis;
    this._dimList.push(dim);
  }
};
var Cartesian_default = Cartesian;

// src/coord/cartesian/Cartesian2D.ts
var cartesian2DDimensions = ["x", "y"];
function canCalculateAffineTransform(scale4) {
  return scale4.type === "interval" || scale4.type === "time";
}
var Cartesian2D = class extends Cartesian_default {
  constructor() {
    super(...arguments);
    this.type = "cartesian2d";
    this.dimensions = cartesian2DDimensions;
  }
  calcAffineTransform() {
    this._transform = this._invTransform = null;
    const xAxisScale = this.getAxis("x").scale;
    const yAxisScale = this.getAxis("y").scale;
    if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {
      return;
    }
    const xScaleExtent = xAxisScale.getExtent();
    const yScaleExtent = yAxisScale.getExtent();
    const start2 = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);
    const end2 = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);
    const xScaleSpan = xScaleExtent[1] - xScaleExtent[0];
    const yScaleSpan = yScaleExtent[1] - yScaleExtent[0];
    if (!xScaleSpan || !yScaleSpan) {
      return;
    }
    const scaleX = (end2[0] - start2[0]) / xScaleSpan;
    const scaleY = (end2[1] - start2[1]) / yScaleSpan;
    const translateX = start2[0] - xScaleExtent[0] * scaleX;
    const translateY = start2[1] - yScaleExtent[0] * scaleY;
    const m2 = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY];
    this._invTransform = invert([], m2);
  }
  getBaseAxis() {
    return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
  }
  containPoint(point) {
    const axisX = this.getAxis("x");
    const axisY = this.getAxis("y");
    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
  }
  containData(data) {
    return this.getAxis("x").containData(data[0]) && this.getAxis("y").containData(data[1]);
  }
  containZone(data1, data2) {
    const zoneDiag1 = this.dataToPoint(data1);
    const zoneDiag2 = this.dataToPoint(data2);
    const area = this.getArea();
    const zone = new BoundingRect_default(zoneDiag1[0], zoneDiag1[1], zoneDiag2[0] - zoneDiag1[0], zoneDiag2[1] - zoneDiag1[1]);
    return area.intersect(zone);
  }
  dataToPoint(data, clamp2, out2) {
    out2 = out2 || [];
    const xVal = data[0];
    const yVal = data[1];
    if (this._transform && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {
      return applyTransform(out2, data, this._transform);
    }
    const xAxis = this.getAxis("x");
    const yAxis = this.getAxis("y");
    out2[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal, clamp2));
    out2[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal, clamp2));
    return out2;
  }
  clampData(data, out2) {
    const xScale = this.getAxis("x").scale;
    const yScale = this.getAxis("y").scale;
    const xAxisExtent = xScale.getExtent();
    const yAxisExtent = yScale.getExtent();
    const x = xScale.parse(data[0]);
    const y = yScale.parse(data[1]);
    out2 = out2 || [];
    out2[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));
    out2[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));
    return out2;
  }
  pointToData(point, clamp2) {
    const out2 = [];
    if (this._invTransform) {
      return applyTransform(out2, point, this._invTransform);
    }
    const xAxis = this.getAxis("x");
    const yAxis = this.getAxis("y");
    out2[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp2);
    out2[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp2);
    return out2;
  }
  getOtherAxis(axis) {
    return this.getAxis(axis.dim === "x" ? "y" : "x");
  }
  getArea(tolerance) {
    tolerance = tolerance || 0;
    const xExtent = this.getAxis("x").getGlobalExtent();
    const yExtent = this.getAxis("y").getGlobalExtent();
    const x = Math.min(xExtent[0], xExtent[1]) - tolerance;
    const y = Math.min(yExtent[0], yExtent[1]) - tolerance;
    const width = Math.max(xExtent[0], xExtent[1]) - x + tolerance;
    const height = Math.max(yExtent[0], yExtent[1]) - y + tolerance;
    return new BoundingRect_default(x, y, width, height);
  }
};
var Cartesian2D_default = Cartesian2D;

// src/coord/cartesian/Axis2D.ts
var Axis2D = class extends Axis_default {
  constructor(dim, scale4, coordExtent, axisType, position2) {
    super(dim, scale4, coordExtent);
    this.index = 0;
    this.type = axisType || "value";
    this.position = position2 || "bottom";
  }
  isHorizontal() {
    const position2 = this.position;
    return position2 === "top" || position2 === "bottom";
  }
  getGlobalExtent(asc4) {
    const ret = this.getExtent();
    ret[0] = this.toGlobalCoord(ret[0]);
    ret[1] = this.toGlobalCoord(ret[1]);
    asc4 && ret[0] > ret[1] && ret.reverse();
    return ret;
  }
  pointToData(point, clamp2) {
    return this.coordToData(this.toLocalCoord(point[this.dim === "x" ? 0 : 1]), clamp2);
  }
  setCategorySortInfo(info) {
    if (this.type !== "category") {
      return false;
    }
    this.model.option.categorySortInfo = info;
    this.scale.setSortInfo(info);
  }
};
var Axis2D_default = Axis2D;

// src/coord/cartesian/cartesianAxisHelper.ts
function layout4(gridModel, axisModel, opt) {
  opt = opt || {};
  const grid = gridModel.coordinateSystem;
  const axis = axisModel.axis;
  const layout18 = {};
  const otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];
  const rawAxisPosition = axis.position;
  const axisPosition = otherAxisOnZeroOf ? "onZero" : rawAxisPosition;
  const axisDim = axis.dim;
  const rect = grid.getRect();
  const rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
  const idx = {left: 0, right: 1, top: 0, bottom: 1, onZero: 2};
  const axisOffset = axisModel.get("offset") || 0;
  const posBound = axisDim === "x" ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];
  if (otherAxisOnZeroOf) {
    const onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));
    posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
  }
  layout18.position = [
    axisDim === "y" ? posBound[idx[axisPosition]] : rectBound[0],
    axisDim === "x" ? posBound[idx[axisPosition]] : rectBound[3]
  ];
  layout18.rotation = Math.PI / 2 * (axisDim === "x" ? 0 : 1);
  const dirMap = {top: -1, bottom: 1, left: -1, right: 1};
  layout18.labelDirection = layout18.tickDirection = layout18.nameDirection = dirMap[rawAxisPosition];
  layout18.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0;
  if (axisModel.get(["axisTick", "inside"])) {
    layout18.tickDirection = -layout18.tickDirection;
  }
  if (retrieve(opt.labelInside, axisModel.get(["axisLabel", "inside"]))) {
    layout18.labelDirection = -layout18.labelDirection;
  }
  const labelRotate = axisModel.get(["axisLabel", "rotate"]);
  layout18.labelRotate = axisPosition === "top" ? -labelRotate : labelRotate;
  layout18.z2 = 1;
  return layout18;
}
function isCartesian2DSeries(seriesModel) {
  return seriesModel.get("coordinateSystem") === "cartesian2d";
}
function findAxisModels(seriesModel) {
  const axisModelMap = {
    xAxisModel: null,
    yAxisModel: null
  };
  each(axisModelMap, function(v, key) {
    const axisType = key.replace(/Model$/, "");
    const axisModel = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0];
    if (true) {
      if (!axisModel) {
        throw new Error(axisType + ' "' + retrieve3(seriesModel.get(axisType + "Index"), seriesModel.get(axisType + "Id"), 0) + '" not found');
      }
    }
    axisModelMap[key] = axisModel;
  });
  return axisModelMap;
}

// src/coord/axisAlignTicks.ts
var mathLog2 = Math.log;
function alignScaleTicks(scale4, axisModel, alignToScale) {
  const intervalScaleProto2 = Interval_default.prototype;
  const alignToTicks = intervalScaleProto2.getTicks.call(alignToScale);
  const alignToNicedTicks = intervalScaleProto2.getTicks.call(alignToScale, true);
  const alignToSplitNumber = alignToTicks.length - 1;
  const alignToInterval = intervalScaleProto2.getInterval.call(alignToScale);
  const scaleExtent = getScaleExtent(scale4, axisModel);
  let rawExtent = scaleExtent.extent;
  const isMinFixed = scaleExtent.fixMin;
  const isMaxFixed = scaleExtent.fixMax;
  if (scale4.type === "log") {
    const logBase = mathLog2(scale4.base);
    rawExtent = [mathLog2(rawExtent[0]) / logBase, mathLog2(rawExtent[1]) / logBase];
  }
  scale4.setExtent(rawExtent[0], rawExtent[1]);
  scale4.calcNiceExtent({
    splitNumber: alignToSplitNumber,
    fixMin: isMinFixed,
    fixMax: isMaxFixed
  });
  const extent3 = intervalScaleProto2.getExtent.call(scale4);
  if (isMinFixed) {
    rawExtent[0] = extent3[0];
  }
  if (isMaxFixed) {
    rawExtent[1] = extent3[1];
  }
  let interval = intervalScaleProto2.getInterval.call(scale4);
  let min3 = rawExtent[0];
  let max3 = rawExtent[1];
  if (isMinFixed && isMaxFixed) {
    interval = (max3 - min3) / alignToSplitNumber;
  } else if (isMinFixed) {
    max3 = rawExtent[0] + interval * alignToSplitNumber;
    while (max3 < rawExtent[1] && isFinite(max3) && isFinite(rawExtent[1])) {
      interval = increaseInterval(interval);
      max3 = rawExtent[0] + interval * alignToSplitNumber;
    }
  } else if (isMaxFixed) {
    min3 = rawExtent[1] - interval * alignToSplitNumber;
    while (min3 > rawExtent[0] && isFinite(min3) && isFinite(rawExtent[0])) {
      interval = increaseInterval(interval);
      min3 = rawExtent[1] - interval * alignToSplitNumber;
    }
  } else {
    const nicedSplitNumber = scale4.getTicks().length - 1;
    if (nicedSplitNumber > alignToSplitNumber) {
      interval = increaseInterval(interval);
    }
    const range = interval * alignToSplitNumber;
    max3 = Math.ceil(rawExtent[1] / interval) * interval;
    min3 = round(max3 - range);
    if (min3 < 0 && rawExtent[0] >= 0) {
      min3 = 0;
      max3 = round(range);
    } else if (max3 > 0 && rawExtent[1] <= 0) {
      max3 = 0;
      min3 = -round(range);
    }
  }
  const t0 = (alignToTicks[0].value - alignToNicedTicks[0].value) / alignToInterval;
  const t1 = (alignToTicks[alignToSplitNumber].value - alignToNicedTicks[alignToSplitNumber].value) / alignToInterval;
  intervalScaleProto2.setExtent.call(scale4, min3 + interval * t0, max3 + interval * t1);
  intervalScaleProto2.setInterval.call(scale4, interval);
  if (t0 || t1) {
    intervalScaleProto2.setNiceExtent.call(scale4, min3 + interval, max3 - interval);
  }
  if (true) {
    const ticks = intervalScaleProto2.getTicks.call(scale4);
    if (ticks[1] && (!isValueNice(interval) || getPrecisionSafe(ticks[1].value) > getPrecisionSafe(interval))) {
      warn(`The ticks may be not readable when set min: ${axisModel.get("min")}, max: ${axisModel.get("max")} and alignTicks: true`);
    }
  }
}

// src/coord/cartesian/Grid.ts
var Grid2 = class {
  constructor(gridModel, ecModel, api2) {
    this.type = "grid";
    this._coordsMap = {};
    this._coordsList = [];
    this._axesMap = {};
    this._axesList = [];
    this.axisPointerEnabled = true;
    this.dimensions = cartesian2DDimensions;
    this._initCartesian(gridModel, ecModel, api2);
    this.model = gridModel;
  }
  getRect() {
    return this._rect;
  }
  update(ecModel, api2) {
    const axesMap = this._axesMap;
    this._updateScale(ecModel, this.model);
    function updateAxisTicks(axes) {
      let alignTo;
      const axesIndices = keys(axes);
      const len2 = axesIndices.length;
      if (!len2) {
        return;
      }
      const axisNeedsAlign = [];
      for (let i = len2 - 1; i >= 0; i--) {
        const idx = +axesIndices[i];
        const axis = axes[idx];
        const model = axis.model;
        const scale4 = axis.scale;
        if (isIntervalOrLogScale(scale4) && model.get("alignTicks") && model.get("interval") == null) {
          axisNeedsAlign.push(axis);
        } else {
          niceScaleExtent(scale4, model);
          if (isIntervalOrLogScale(scale4)) {
            alignTo = axis;
          }
        }
      }
      ;
      if (axisNeedsAlign.length) {
        if (!alignTo) {
          alignTo = axisNeedsAlign.pop();
          niceScaleExtent(alignTo.scale, alignTo.model);
        }
        each(axisNeedsAlign, (axis) => {
          alignScaleTicks(axis.scale, axis.model, alignTo.scale);
        });
      }
    }
    updateAxisTicks(axesMap.x);
    updateAxisTicks(axesMap.y);
    const onZeroRecords = {};
    each(axesMap.x, function(xAxis) {
      fixAxisOnZero(axesMap, "y", xAxis, onZeroRecords);
    });
    each(axesMap.y, function(yAxis) {
      fixAxisOnZero(axesMap, "x", yAxis, onZeroRecords);
    });
    this.resize(this.model, api2);
  }
  resize(gridModel, api2, ignoreContainLabel) {
    const boxLayoutParams = gridModel.getBoxLayoutParams();
    const isContainLabel = !ignoreContainLabel && gridModel.get("containLabel");
    const gridRect = getLayoutRect(boxLayoutParams, {
      width: api2.getWidth(),
      height: api2.getHeight()
    });
    this._rect = gridRect;
    const axesList = this._axesList;
    adjustAxes();
    if (isContainLabel) {
      each(axesList, function(axis) {
        if (!axis.model.get(["axisLabel", "inside"])) {
          const labelUnionRect = estimateLabelUnionRect(axis);
          if (labelUnionRect) {
            const dim = axis.isHorizontal() ? "height" : "width";
            const margin = axis.model.get(["axisLabel", "margin"]);
            gridRect[dim] -= labelUnionRect[dim] + margin;
            if (axis.position === "top") {
              gridRect.y += labelUnionRect.height + margin;
            } else if (axis.position === "left") {
              gridRect.x += labelUnionRect.width + margin;
            }
          }
        }
      });
      adjustAxes();
    }
    each(this._coordsList, function(coord) {
      coord.calcAffineTransform();
    });
    function adjustAxes() {
      each(axesList, function(axis) {
        const isHorizontal = axis.isHorizontal();
        const extent3 = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
        const idx = axis.inverse ? 1 : 0;
        axis.setExtent(extent3[idx], extent3[1 - idx]);
        updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);
      });
    }
  }
  getAxis(dim, axisIndex) {
    const axesMapOnDim = this._axesMap[dim];
    if (axesMapOnDim != null) {
      return axesMapOnDim[axisIndex || 0];
    }
  }
  getAxes() {
    return this._axesList.slice();
  }
  getCartesian(xAxisIndex, yAxisIndex) {
    if (xAxisIndex != null && yAxisIndex != null) {
      const key = "x" + xAxisIndex + "y" + yAxisIndex;
      return this._coordsMap[key];
    }
    if (isObject(xAxisIndex)) {
      yAxisIndex = xAxisIndex.yAxisIndex;
      xAxisIndex = xAxisIndex.xAxisIndex;
    }
    for (let i = 0, coordList = this._coordsList; i < coordList.length; i++) {
      if (coordList[i].getAxis("x").index === xAxisIndex || coordList[i].getAxis("y").index === yAxisIndex) {
        return coordList[i];
      }
    }
  }
  getCartesians() {
    return this._coordsList.slice();
  }
  convertToPixel(ecModel, finder, value) {
    const target = this._findConvertTarget(finder);
    return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
  }
  convertFromPixel(ecModel, finder, value) {
    const target = this._findConvertTarget(finder);
    return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
  }
  _findConvertTarget(finder) {
    const seriesModel = finder.seriesModel;
    const xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents("xAxis", SINGLE_REFERRING).models[0];
    const yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents("yAxis", SINGLE_REFERRING).models[0];
    const gridModel = finder.gridModel;
    const coordsList = this._coordsList;
    let cartesian;
    let axis;
    if (seriesModel) {
      cartesian = seriesModel.coordinateSystem;
      indexOf(coordsList, cartesian) < 0 && (cartesian = null);
    } else if (xAxisModel && yAxisModel) {
      cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    } else if (xAxisModel) {
      axis = this.getAxis("x", xAxisModel.componentIndex);
    } else if (yAxisModel) {
      axis = this.getAxis("y", yAxisModel.componentIndex);
    } else if (gridModel) {
      const grid = gridModel.coordinateSystem;
      if (grid === this) {
        cartesian = this._coordsList[0];
      }
    }
    return {cartesian, axis};
  }
  containPoint(point) {
    const coord = this._coordsList[0];
    if (coord) {
      return coord.containPoint(point);
    }
  }
  _initCartesian(gridModel, ecModel, api2) {
    const grid = this;
    const axisPositionUsed = {
      left: false,
      right: false,
      top: false,
      bottom: false
    };
    const axesMap = {
      x: {},
      y: {}
    };
    const axesCount = {
      x: 0,
      y: 0
    };
    ecModel.eachComponent("xAxis", createAxisCreator("x"), this);
    ecModel.eachComponent("yAxis", createAxisCreator("y"), this);
    if (!axesCount.x || !axesCount.y) {
      this._axesMap = {};
      this._axesList = [];
      return;
    }
    this._axesMap = axesMap;
    each(axesMap.x, (xAxis, xAxisIndex) => {
      each(axesMap.y, (yAxis, yAxisIndex) => {
        const key = "x" + xAxisIndex + "y" + yAxisIndex;
        const cartesian = new Cartesian2D_default(key);
        cartesian.master = this;
        cartesian.model = gridModel;
        this._coordsMap[key] = cartesian;
        this._coordsList.push(cartesian);
        cartesian.addAxis(xAxis);
        cartesian.addAxis(yAxis);
      });
    });
    function createAxisCreator(dimName) {
      return function(axisModel, idx) {
        if (!isAxisUsedInTheGrid(axisModel, gridModel)) {
          return;
        }
        let axisPosition = axisModel.get("position");
        if (dimName === "x") {
          if (axisPosition !== "top" && axisPosition !== "bottom") {
            axisPosition = axisPositionUsed.bottom ? "top" : "bottom";
          }
        } else {
          if (axisPosition !== "left" && axisPosition !== "right") {
            axisPosition = axisPositionUsed.left ? "right" : "left";
          }
        }
        axisPositionUsed[axisPosition] = true;
        const axis = new Axis2D_default(dimName, createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisPosition);
        const isCategory2 = axis.type === "category";
        axis.onBand = isCategory2 && axisModel.get("boundaryGap");
        axis.inverse = axisModel.get("inverse");
        axisModel.axis = axis;
        axis.model = axisModel;
        axis.grid = grid;
        axis.index = idx;
        grid._axesList.push(axis);
        axesMap[dimName][idx] = axis;
        axesCount[dimName]++;
      };
    }
  }
  _updateScale(ecModel, gridModel) {
    each(this._axesList, function(axis) {
      axis.scale.setExtent(Infinity, -Infinity);
      if (axis.type === "category") {
        const categorySortInfo = axis.model.get("categorySortInfo");
        axis.scale.setSortInfo(categorySortInfo);
      }
    });
    ecModel.eachSeries(function(seriesModel) {
      if (isCartesian2DSeries(seriesModel)) {
        const axesModelMap = findAxisModels(seriesModel);
        const xAxisModel = axesModelMap.xAxisModel;
        const yAxisModel = axesModelMap.yAxisModel;
        if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {
          return;
        }
        const cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
        const data = seriesModel.getData();
        const xAxis = cartesian.getAxis("x");
        const yAxis = cartesian.getAxis("y");
        unionExtent(data, xAxis);
        unionExtent(data, yAxis);
      }
    }, this);
    function unionExtent(data, axis) {
      each(getDataDimensionsOnAxis(data, axis.dim), function(dim) {
        axis.scale.unionExtentFromData(data, dim);
      });
    }
  }
  getTooltipAxes(dim) {
    const baseAxes = [];
    const otherAxes = [];
    each(this.getCartesians(), function(cartesian) {
      const baseAxis = dim != null && dim !== "auto" ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
      const otherAxis = cartesian.getOtherAxis(baseAxis);
      indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
      indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
    });
    return {baseAxes, otherAxes};
  }
  static create(ecModel, api2) {
    const grids = [];
    ecModel.eachComponent("grid", function(gridModel, idx) {
      const grid = new Grid2(gridModel, ecModel, api2);
      grid.name = "grid_" + idx;
      grid.resize(gridModel, api2, true);
      gridModel.coordinateSystem = grid;
      grids.push(grid);
    });
    ecModel.eachSeries(function(seriesModel) {
      if (!isCartesian2DSeries(seriesModel)) {
        return;
      }
      const axesModelMap = findAxisModels(seriesModel);
      const xAxisModel = axesModelMap.xAxisModel;
      const yAxisModel = axesModelMap.yAxisModel;
      const gridModel = xAxisModel.getCoordSysModel();
      if (true) {
        if (!gridModel) {
          throw new Error('Grid "' + retrieve3(xAxisModel.get("gridIndex"), xAxisModel.get("gridId"), 0) + '" not found');
        }
        if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {
          throw new Error("xAxis and yAxis must use the same grid");
        }
      }
      const grid = gridModel.coordinateSystem;
      seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
    });
    return grids;
  }
};
var Grid = Grid2;
Grid.dimensions = cartesian2DDimensions;
function isAxisUsedInTheGrid(axisModel, gridModel) {
  return axisModel.getCoordSysModel() === gridModel;
}
function fixAxisOnZero(axesMap, otherAxisDim, axis, onZeroRecords) {
  axis.getAxesOnZeroOf = function() {
    return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];
  };
  const otherAxes = axesMap[otherAxisDim];
  let otherAxisOnZeroOf;
  const axisModel = axis.model;
  const onZero = axisModel.get(["axisLine", "onZero"]);
  const onZeroAxisIndex = axisModel.get(["axisLine", "onZeroAxisIndex"]);
  if (!onZero) {
    return;
  }
  if (onZeroAxisIndex != null) {
    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {
      otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];
    }
  } else {
    for (const idx in otherAxes) {
      if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
        otherAxisOnZeroOf = otherAxes[idx];
        break;
      }
    }
  }
  if (otherAxisOnZeroOf) {
    onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;
  }
  function getOnZeroRecordKey(axis2) {
    return axis2.dim + "_" + axis2.index;
  }
}
function canOnZeroToAxis(axis) {
  return axis && axis.type !== "category" && axis.type !== "time" && ifAxisCrossZero(axis);
}
function updateAxisTransform(axis, coordBase) {
  const axisExtent = axis.getExtent();
  const axisExtentSum = axisExtent[0] + axisExtent[1];
  axis.toGlobalCoord = axis.dim === "x" ? function(coord) {
    return coord + coordBase;
  } : function(coord) {
    return axisExtentSum - coord + coordBase;
  };
  axis.toLocalCoord = axis.dim === "x" ? function(coord) {
    return coord - coordBase;
  } : function(coord) {
    return axisExtentSum - coord + coordBase;
  };
}
var Grid_default = Grid;

// src/component/axis/AxisBuilder.ts
var PI7 = Math.PI;
var AxisBuilder = class {
  constructor(axisModel, opt) {
    this.group = new Group_default();
    this.opt = opt;
    this.axisModel = axisModel;
    defaults(opt, {
      labelOffset: 0,
      nameDirection: 1,
      tickDirection: 1,
      labelDirection: 1,
      silent: true,
      handleAutoShown: () => true
    });
    const transformGroup = new Group_default({
      x: opt.position[0],
      y: opt.position[1],
      rotation: opt.rotation
    });
    transformGroup.updateTransform();
    this._transformGroup = transformGroup;
  }
  hasBuilder(name) {
    return !!builders[name];
  }
  add(name) {
    builders[name](this.opt, this.axisModel, this.group, this._transformGroup);
  }
  getGroup() {
    return this.group;
  }
  static innerTextLayout(axisRotation, textRotation, direction) {
    const rotationDiff = remRadian(textRotation - axisRotation);
    let textAlign;
    let textVerticalAlign;
    if (isRadianAroundZero(rotationDiff)) {
      textVerticalAlign = direction > 0 ? "top" : "bottom";
      textAlign = "center";
    } else if (isRadianAroundZero(rotationDiff - PI7)) {
      textVerticalAlign = direction > 0 ? "bottom" : "top";
      textAlign = "center";
    } else {
      textVerticalAlign = "middle";
      if (rotationDiff > 0 && rotationDiff < PI7) {
        textAlign = direction > 0 ? "right" : "left";
      } else {
        textAlign = direction > 0 ? "left" : "right";
      }
    }
    return {
      rotation: rotationDiff,
      textAlign,
      textVerticalAlign
    };
  }
  static makeAxisEventDataBase(axisModel) {
    const eventData = {
      componentType: axisModel.mainType,
      componentIndex: axisModel.componentIndex
    };
    eventData[axisModel.mainType + "Index"] = axisModel.componentIndex;
    return eventData;
  }
  static isLabelSilent(axisModel) {
    const tooltipOpt = axisModel.get("tooltip");
    return axisModel.get("silent") || !(axisModel.get("triggerEvent") || tooltipOpt && tooltipOpt.show);
  }
};
var builders = {
  axisLine(opt, axisModel, group, transformGroup) {
    let shown = axisModel.get(["axisLine", "show"]);
    if (shown === "auto" && opt.handleAutoShown) {
      shown = opt.handleAutoShown("axisLine");
    }
    if (!shown) {
      return;
    }
    const extent3 = axisModel.axis.getExtent();
    const matrix13 = transformGroup.transform;
    const pt12 = [extent3[0], 0];
    const pt22 = [extent3[1], 0];
    const inverse = pt12[0] > pt22[0];
    if (matrix13) {
      applyTransform(pt12, pt12, matrix13);
      applyTransform(pt22, pt22, matrix13);
    }
    const lineStyle = extend({
      lineCap: "round"
    }, axisModel.getModel(["axisLine", "lineStyle"]).getLineStyle());
    const line2 = new Line_default({
      shape: {
        x1: pt12[0],
        y1: pt12[1],
        x2: pt22[0],
        y2: pt22[1]
      },
      style: lineStyle,
      strokeContainThreshold: opt.strokeContainThreshold || 5,
      silent: true,
      z2: 1
    });
    subPixelOptimizeLine2(line2.shape, line2.style.lineWidth);
    line2.anid = "line";
    group.add(line2);
    let arrows = axisModel.get(["axisLine", "symbol"]);
    if (arrows != null) {
      let arrowSize = axisModel.get(["axisLine", "symbolSize"]);
      if (isString(arrows)) {
        arrows = [arrows, arrows];
      }
      if (isString(arrowSize) || isNumber(arrowSize)) {
        arrowSize = [arrowSize, arrowSize];
      }
      const arrowOffset = normalizeSymbolOffset(axisModel.get(["axisLine", "symbolOffset"]) || 0, arrowSize);
      const symbolWidth = arrowSize[0];
      const symbolHeight = arrowSize[1];
      each([{
        rotate: opt.rotation + Math.PI / 2,
        offset: arrowOffset[0],
        r: 0
      }, {
        rotate: opt.rotation - Math.PI / 2,
        offset: arrowOffset[1],
        r: Math.sqrt((pt12[0] - pt22[0]) * (pt12[0] - pt22[0]) + (pt12[1] - pt22[1]) * (pt12[1] - pt22[1]))
      }], function(point, index) {
        if (arrows[index] !== "none" && arrows[index] != null) {
          const symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true);
          const r = point.r + point.offset;
          const pt = inverse ? pt22 : pt12;
          symbol.attr({
            rotation: point.rotate,
            x: pt[0] + r * Math.cos(opt.rotation),
            y: pt[1] - r * Math.sin(opt.rotation),
            silent: true,
            z2: 11
          });
          group.add(symbol);
        }
      });
    }
  },
  axisTickLabel(opt, axisModel, group, transformGroup) {
    const ticksEls = buildAxisMajorTicks(group, transformGroup, axisModel, opt);
    const labelEls = buildAxisLabel(group, transformGroup, axisModel, opt);
    fixMinMaxLabelShow(axisModel, labelEls, ticksEls);
    buildAxisMinorTicks(group, transformGroup, axisModel, opt.tickDirection);
    if (axisModel.get(["axisLabel", "hideOverlap"])) {
      const labelList = prepareLayoutList(map(labelEls, (label) => ({
        label,
        priority: label.z2,
        defaultAttr: {
          ignore: label.ignore
        }
      })));
      hideOverlap(labelList);
    }
  },
  axisName(opt, axisModel, group, transformGroup) {
    const name = retrieve(opt.axisName, axisModel.get("name"));
    if (!name) {
      return;
    }
    const nameLocation = axisModel.get("nameLocation");
    const nameDirection = opt.nameDirection;
    const textStyleModel = axisModel.getModel("nameTextStyle");
    const gap = axisModel.get("nameGap") || 0;
    const extent3 = axisModel.axis.getExtent();
    const gapSignal = extent3[0] > extent3[1] ? -1 : 1;
    const pos = [
      nameLocation === "start" ? extent3[0] - gapSignal * gap : nameLocation === "end" ? extent3[1] + gapSignal * gap : (extent3[0] + extent3[1]) / 2,
      isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0
    ];
    let labelLayout2;
    let nameRotation = axisModel.get("nameRotate");
    if (nameRotation != null) {
      nameRotation = nameRotation * PI7 / 180;
    }
    let axisNameAvailableWidth;
    if (isNameLocationCenter(nameLocation)) {
      labelLayout2 = AxisBuilder.innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, nameDirection);
    } else {
      labelLayout2 = endTextLayout(opt.rotation, nameLocation, nameRotation || 0, extent3);
      axisNameAvailableWidth = opt.axisNameAvailableWidth;
      if (axisNameAvailableWidth != null) {
        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout2.rotation));
        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
      }
    }
    const textFont = textStyleModel.getFont();
    const truncateOpt = axisModel.get("nameTruncate", true) || {};
    const ellipsis = truncateOpt.ellipsis;
    const maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);
    const textEl = new Text_default({
      x: pos[0],
      y: pos[1],
      rotation: labelLayout2.rotation,
      silent: AxisBuilder.isLabelSilent(axisModel),
      style: createTextStyle(textStyleModel, {
        text: name,
        font: textFont,
        overflow: "truncate",
        width: maxWidth,
        ellipsis,
        fill: textStyleModel.getTextColor() || axisModel.get(["axisLine", "lineStyle", "color"]),
        align: textStyleModel.get("align") || labelLayout2.textAlign,
        verticalAlign: textStyleModel.get("verticalAlign") || labelLayout2.textVerticalAlign
      }),
      z2: 1
    });
    setTooltipConfig({
      el: textEl,
      componentModel: axisModel,
      itemName: name
    });
    textEl.__fullText = name;
    textEl.anid = "name";
    if (axisModel.get("triggerEvent")) {
      const eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
      eventData.targetType = "axisName";
      eventData.name = name;
      getECData(textEl).eventData = eventData;
    }
    transformGroup.add(textEl);
    textEl.updateTransform();
    group.add(textEl);
    textEl.decomposeTransform();
  }
};
function endTextLayout(rotation, textPosition, textRotate, extent3) {
  const rotationDiff = remRadian(textRotate - rotation);
  let textAlign;
  let textVerticalAlign;
  const inverse = extent3[0] > extent3[1];
  const onLeft = textPosition === "start" && !inverse || textPosition !== "start" && inverse;
  if (isRadianAroundZero(rotationDiff - PI7 / 2)) {
    textVerticalAlign = onLeft ? "bottom" : "top";
    textAlign = "center";
  } else if (isRadianAroundZero(rotationDiff - PI7 * 1.5)) {
    textVerticalAlign = onLeft ? "top" : "bottom";
    textAlign = "center";
  } else {
    textVerticalAlign = "middle";
    if (rotationDiff < PI7 * 1.5 && rotationDiff > PI7 / 2) {
      textAlign = onLeft ? "left" : "right";
    } else {
      textAlign = onLeft ? "right" : "left";
    }
  }
  return {
    rotation: rotationDiff,
    textAlign,
    textVerticalAlign
  };
}
function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {
  if (shouldShowAllLabels(axisModel.axis)) {
    return;
  }
  const showMinLabel = axisModel.get(["axisLabel", "showMinLabel"]);
  const showMaxLabel = axisModel.get(["axisLabel", "showMaxLabel"]);
  labelEls = labelEls || [];
  tickEls = tickEls || [];
  const firstLabel = labelEls[0];
  const nextLabel = labelEls[1];
  const lastLabel = labelEls[labelEls.length - 1];
  const prevLabel = labelEls[labelEls.length - 2];
  const firstTick = tickEls[0];
  const nextTick = tickEls[1];
  const lastTick = tickEls[tickEls.length - 1];
  const prevTick = tickEls[tickEls.length - 2];
  if (showMinLabel === false) {
    ignoreEl(firstLabel);
    ignoreEl(firstTick);
  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
    if (showMinLabel) {
      ignoreEl(nextLabel);
      ignoreEl(nextTick);
    } else {
      ignoreEl(firstLabel);
      ignoreEl(firstTick);
    }
  }
  if (showMaxLabel === false) {
    ignoreEl(lastLabel);
    ignoreEl(lastTick);
  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
    if (showMaxLabel) {
      ignoreEl(prevLabel);
      ignoreEl(prevTick);
    } else {
      ignoreEl(lastLabel);
      ignoreEl(lastTick);
    }
  }
}
function ignoreEl(el) {
  el && (el.ignore = true);
}
function isTwoLabelOverlapped(current, next) {
  const firstRect = current && current.getBoundingRect().clone();
  const nextRect = next && next.getBoundingRect().clone();
  if (!firstRect || !nextRect) {
    return;
  }
  const mRotationBack = identity([]);
  rotate(mRotationBack, mRotationBack, -current.rotation);
  firstRect.applyTransform(mul2([], mRotationBack, current.getLocalTransform()));
  nextRect.applyTransform(mul2([], mRotationBack, next.getLocalTransform()));
  return firstRect.intersect(nextRect);
}
function isNameLocationCenter(nameLocation) {
  return nameLocation === "middle" || nameLocation === "center";
}
function createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {
  const tickEls = [];
  const pt12 = [];
  const pt22 = [];
  for (let i = 0; i < ticksCoords.length; i++) {
    const tickCoord = ticksCoords[i].coord;
    pt12[0] = tickCoord;
    pt12[1] = 0;
    pt22[0] = tickCoord;
    pt22[1] = tickEndCoord;
    if (tickTransform) {
      applyTransform(pt12, pt12, tickTransform);
      applyTransform(pt22, pt22, tickTransform);
    }
    const tickEl = new Line_default({
      shape: {
        x1: pt12[0],
        y1: pt12[1],
        x2: pt22[0],
        y2: pt22[1]
      },
      style: tickLineStyle,
      z2: 2,
      autoBatch: true,
      silent: true
    });
    subPixelOptimizeLine2(tickEl.shape, tickEl.style.lineWidth);
    tickEl.anid = anidPrefix + "_" + ticksCoords[i].tickValue;
    tickEls.push(tickEl);
  }
  return tickEls;
}
function buildAxisMajorTicks(group, transformGroup, axisModel, opt) {
  const axis = axisModel.axis;
  const tickModel = axisModel.getModel("axisTick");
  let shown = tickModel.get("show");
  if (shown === "auto" && opt.handleAutoShown) {
    shown = opt.handleAutoShown("axisTick");
  }
  if (!shown || axis.scale.isBlank()) {
    return;
  }
  const lineStyleModel = tickModel.getModel("lineStyle");
  const tickEndCoord = opt.tickDirection * tickModel.get("length");
  const ticksCoords = axis.getTicksCoords();
  const ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, defaults(lineStyleModel.getLineStyle(), {
    stroke: axisModel.get(["axisLine", "lineStyle", "color"])
  }), "ticks");
  for (let i = 0; i < ticksEls.length; i++) {
    group.add(ticksEls[i]);
  }
  return ticksEls;
}
function buildAxisMinorTicks(group, transformGroup, axisModel, tickDirection) {
  const axis = axisModel.axis;
  const minorTickModel = axisModel.getModel("minorTick");
  if (!minorTickModel.get("show") || axis.scale.isBlank()) {
    return;
  }
  const minorTicksCoords = axis.getMinorTicksCoords();
  if (!minorTicksCoords.length) {
    return;
  }
  const lineStyleModel = minorTickModel.getModel("lineStyle");
  const tickEndCoord = tickDirection * minorTickModel.get("length");
  const minorTickLineStyle = defaults(lineStyleModel.getLineStyle(), defaults(axisModel.getModel("axisTick").getLineStyle(), {
    stroke: axisModel.get(["axisLine", "lineStyle", "color"])
  }));
  for (let i = 0; i < minorTicksCoords.length; i++) {
    const minorTicksEls = createTicks(minorTicksCoords[i], transformGroup.transform, tickEndCoord, minorTickLineStyle, "minorticks_" + i);
    for (let k = 0; k < minorTicksEls.length; k++) {
      group.add(minorTicksEls[k]);
    }
  }
}
function buildAxisLabel(group, transformGroup, axisModel, opt) {
  const axis = axisModel.axis;
  const data = axisModel.get("data");
  const show = retrieve(opt.axisLabelShow, axisModel.get(["axisLabel", "show"]));
  if (!show || axis.scale.isBlank()) {
    return;
  }
  const labelModel = axisModel.getModel("axisLabel");
  const labelMargin = labelModel.get("margin");
  const labels = axis.getViewLabels();
  const labelRotation = (retrieve(opt.labelRotate, labelModel.get("rotate")) || 0) * PI7 / 180;
  const labelLayout2 = AxisBuilder.innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);
  const rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);
  const labelEls = [];
  const silent = AxisBuilder.isLabelSilent(axisModel);
  const triggerEvent = axisModel.get("triggerEvent");
  each(labels, function(labelItem, index) {
    if (axis.type === "time" && !axisModel.isDataNotEmptyAt(index)) {
      return;
    }
    if (data && data.length <= index && data[index].length === 0) {
      return;
    }
    const tickValue = axis.scale.type === "ordinal" ? axis.scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;
    const formattedLabel = labelItem.formattedLabel;
    const rawLabel = labelItem.rawLabel;
    let itemLabelModel = labelModel;
    if (rawCategoryData && rawCategoryData[tickValue]) {
      const rawCategoryItem = rawCategoryData[tickValue];
      if (isObject(rawCategoryItem) && rawCategoryItem.textStyle) {
        itemLabelModel = new Model_default(rawCategoryItem.textStyle, labelModel, axisModel.ecModel);
      }
    }
    const textColor = itemLabelModel.getTextColor() || axisModel.get(["axisLine", "lineStyle", "color"]);
    const tickCoord = axis.dataToCoord(tickValue);
    const align = itemLabelModel.getShallow("align", true) || labelLayout2.textAlign;
    const alignMin = retrieve2(itemLabelModel.getShallow("alignMinLabel", true), align);
    const alignMax = retrieve2(itemLabelModel.getShallow("alignMaxLabel", true), align);
    const verticalAlign = itemLabelModel.getShallow("verticalAlign", true) || itemLabelModel.getShallow("baseline", true) || labelLayout2.textVerticalAlign;
    const verticalAlignMin = retrieve2(itemLabelModel.getShallow("verticalAlignMinLabel", true), verticalAlign);
    const verticalAlignMax = retrieve2(itemLabelModel.getShallow("verticalAlignMaxLabel", true), verticalAlign);
    const textEl = new Text_default({
      x: tickCoord,
      y: opt.labelOffset + opt.labelDirection * labelMargin,
      rotation: labelLayout2.rotation,
      silent,
      z2: 10 + (labelItem.level || 0),
      style: createTextStyle(itemLabelModel, {
        text: formattedLabel,
        align: index === 0 ? alignMin : index === labels.length - 1 ? alignMax : align,
        verticalAlign: index === 0 ? verticalAlignMin : index === labels.length - 1 ? verticalAlignMax : verticalAlign,
        fill: isFunction(textColor) ? textColor(axis.type === "category" ? rawLabel : axis.type === "value" ? tickValue + "" : tickValue, index) : textColor
      })
    });
    textEl.anid = "label_" + tickValue;
    if (triggerEvent) {
      const eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
      eventData.targetType = "axisLabel";
      eventData.value = rawLabel;
      eventData.tickIndex = index;
      if (axis.type === "category") {
        eventData.dataIndex = tickValue;
      }
      getECData(textEl).eventData = eventData;
    }
    transformGroup.add(textEl);
    textEl.updateTransform();
    labelEls.push(textEl);
    group.add(textEl);
    textEl.decomposeTransform();
  });
  return labelEls;
}
var AxisBuilder_default = AxisBuilder;

// src/component/axisPointer/modelHelper.ts
function collect(ecModel, api2) {
  const result = {
    axesInfo: {},
    seriesInvolved: false,
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  collectAxesInfo(result, ecModel, api2);
  result.seriesInvolved && collectSeriesInfo(result, ecModel);
  return result;
}
function collectAxesInfo(result, ecModel, api2) {
  const globalTooltipModel = ecModel.getComponent("tooltip");
  const globalAxisPointerModel = ecModel.getComponent("axisPointer");
  const linksOption = globalAxisPointerModel.get("link", true) || [];
  const linkGroups = [];
  each(api2.getCoordinateSystems(), function(coordSys) {
    if (!coordSys.axisPointerEnabled) {
      return;
    }
    const coordSysKey = makeKey(coordSys.model);
    const axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
    result.coordSysMap[coordSysKey] = coordSys;
    const coordSysModel = coordSys.model;
    const baseTooltipModel = coordSysModel.getModel("tooltip", globalTooltipModel);
    each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null));
    if (coordSys.getTooltipAxes && globalTooltipModel && baseTooltipModel.get("show")) {
      const triggerAxis = baseTooltipModel.get("trigger") === "axis";
      const cross = baseTooltipModel.get(["axisPointer", "type"]) === "cross";
      const tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get(["axisPointer", "axis"]));
      if (triggerAxis || cross) {
        each(tooltipAxes.baseAxes, curry(saveTooltipAxisInfo, cross ? "cross" : true, triggerAxis));
      }
      if (cross) {
        each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, "cross", false));
      }
    }
    function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
      let axisPointerModel = axis.model.getModel("axisPointer", globalAxisPointerModel);
      const axisPointerShow = axisPointerModel.get("show");
      if (!axisPointerShow || axisPointerShow === "auto" && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
        return;
      }
      if (triggerTooltip == null) {
        triggerTooltip = axisPointerModel.get("triggerTooltip");
      }
      axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
      const snap = axisPointerModel.get("snap");
      const triggerEmphasis = axisPointerModel.get("triggerEmphasis");
      const axisKey = makeKey(axis.model);
      const involveSeries = triggerTooltip || snap || axis.type === "category";
      const axisInfo = result.axesInfo[axisKey] = {
        key: axisKey,
        axis,
        coordSys,
        axisPointerModel,
        triggerTooltip,
        triggerEmphasis,
        involveSeries,
        snap,
        useHandle: isHandleTrigger(axisPointerModel),
        seriesModels: [],
        linkGroup: null
      };
      axesInfoInCoordSys[axisKey] = axisInfo;
      result.seriesInvolved = result.seriesInvolved || involveSeries;
      const groupIndex = getLinkGroupIndex(linksOption, axis);
      if (groupIndex != null) {
        const linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {axesInfo: {}});
        linkGroup.axesInfo[axisKey] = axisInfo;
        linkGroup.mapper = linksOption[groupIndex].mapper;
        axisInfo.linkGroup = linkGroup;
      }
    }
  });
}
function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
  const tooltipAxisPointerModel = baseTooltipModel.getModel("axisPointer");
  const fields = [
    "type",
    "snap",
    "lineStyle",
    "shadowStyle",
    "label",
    "animation",
    "animationDurationUpdate",
    "animationEasingUpdate",
    "z"
  ];
  const volatileOption = {};
  each(fields, function(field) {
    volatileOption[field] = clone(tooltipAxisPointerModel.get(field));
  });
  volatileOption.snap = axis.type !== "category" && !!triggerTooltip;
  if (tooltipAxisPointerModel.get("type") === "cross") {
    volatileOption.type = "line";
  }
  const labelOption = volatileOption.label || (volatileOption.label = {});
  labelOption.show == null && (labelOption.show = false);
  if (fromTooltip === "cross") {
    const tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get(["label", "show"]);
    labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true;
    if (!triggerTooltip) {
      const crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get("crossStyle");
      crossStyle && defaults(labelOption, crossStyle.textStyle);
    }
  }
  return axis.model.getModel("axisPointer", new Model_default(volatileOption, globalAxisPointerModel, ecModel));
}
function collectSeriesInfo(result, ecModel) {
  ecModel.eachSeries(function(seriesModel) {
    const coordSys = seriesModel.coordinateSystem;
    const seriesTooltipTrigger = seriesModel.get(["tooltip", "trigger"], true);
    const seriesTooltipShow = seriesModel.get(["tooltip", "show"], true);
    if (!coordSys || seriesTooltipTrigger === "none" || seriesTooltipTrigger === false || seriesTooltipTrigger === "item" || seriesTooltipShow === false || seriesModel.get(["axisPointer", "show"], true) === false) {
      return;
    }
    each(result.coordSysAxesInfo[makeKey(coordSys.model)], function(axisInfo) {
      const axis = axisInfo.axis;
      if (coordSys.getAxis(axis.dim) === axis) {
        axisInfo.seriesModels.push(seriesModel);
        axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
        axisInfo.seriesDataCount += seriesModel.getData().count();
      }
    });
  });
}
function getLinkGroupIndex(linksOption, axis) {
  const axisModel = axis.model;
  const dim = axis.dim;
  for (let i = 0; i < linksOption.length; i++) {
    const linkOption = linksOption[i] || {};
    if (checkPropInLink(linkOption[dim + "AxisId"], axisModel.id) || checkPropInLink(linkOption[dim + "AxisIndex"], axisModel.componentIndex) || checkPropInLink(linkOption[dim + "AxisName"], axisModel.name)) {
      return i;
    }
  }
}
function checkPropInLink(linkPropValue, axisPropValue) {
  return linkPropValue === "all" || isArray(linkPropValue) && indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
}
function fixValue(axisModel) {
  const axisInfo = getAxisInfo(axisModel);
  if (!axisInfo) {
    return;
  }
  const axisPointerModel = axisInfo.axisPointerModel;
  const scale4 = axisInfo.axis.scale;
  const option = axisPointerModel.option;
  const status = axisPointerModel.get("status");
  let value = axisPointerModel.get("value");
  if (value != null) {
    value = scale4.parse(value);
  }
  const useHandle = isHandleTrigger(axisPointerModel);
  if (status == null) {
    option.status = useHandle ? "show" : "hide";
  }
  const extent3 = scale4.getExtent().slice();
  extent3[0] > extent3[1] && extent3.reverse();
  if (value == null || value > extent3[1]) {
    value = extent3[1];
  }
  if (value < extent3[0]) {
    value = extent3[0];
  }
  option.value = value;
  if (useHandle) {
    option.status = axisInfo.axis.scale.isBlank() ? "hide" : "show";
  }
}
function getAxisInfo(axisModel) {
  const coordSysAxesInfo = (axisModel.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
}
function getAxisPointerModel(axisModel) {
  const axisInfo = getAxisInfo(axisModel);
  return axisInfo && axisInfo.axisPointerModel;
}
function isHandleTrigger(axisPointerModel) {
  return !!axisPointerModel.get(["handle", "show"]);
}
function makeKey(model) {
  return model.type + "||" + model.id;
}

// src/component/axis/AxisView.ts
var axisPointerClazz = {};
var AxisView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = AxisView2.type;
  }
  render(axisModel, ecModel, api2, payload) {
    this.axisPointerClass && fixValue(axisModel);
    super.render.apply(this, arguments);
    this._doUpdateAxisPointerClass(axisModel, api2, true);
  }
  updateAxisPointer(axisModel, ecModel, api2, payload) {
    this._doUpdateAxisPointerClass(axisModel, api2, false);
  }
  remove(ecModel, api2) {
    const axisPointer = this._axisPointer;
    axisPointer && axisPointer.remove(api2);
  }
  dispose(ecModel, api2) {
    this._disposeAxisPointer(api2);
    super.dispose.apply(this, arguments);
  }
  _doUpdateAxisPointerClass(axisModel, api2, forceRender) {
    const Clazz = AxisView2.getAxisPointerClass(this.axisPointerClass);
    if (!Clazz) {
      return;
    }
    const axisPointerModel = getAxisPointerModel(axisModel);
    axisPointerModel ? (this._axisPointer || (this._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api2, forceRender) : this._disposeAxisPointer(api2);
  }
  _disposeAxisPointer(api2) {
    this._axisPointer && this._axisPointer.dispose(api2);
    this._axisPointer = null;
  }
  static registerAxisPointerClass(type, clazz) {
    if (true) {
      if (axisPointerClazz[type]) {
        throw new Error("axisPointer " + type + " exists");
      }
    }
    axisPointerClazz[type] = clazz;
  }
  static getAxisPointerClass(type) {
    return type && axisPointerClazz[type];
  }
};
var AxisView = AxisView2;
AxisView.type = "axis";
var AxisView_default = AxisView;

// src/component/axis/axisSplitHelper.ts
var inner7 = makeInner();
function rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {
  const axis = axisModel.axis;
  if (axis.scale.isBlank()) {
    return;
  }
  const splitAreaModel = axisModel.getModel("splitArea");
  const areaStyleModel = splitAreaModel.getModel("areaStyle");
  let areaColors = areaStyleModel.get("color");
  const gridRect = gridModel.coordinateSystem.getRect();
  const ticksCoords = axis.getTicksCoords({
    tickModel: splitAreaModel,
    clamp: true
  });
  if (!ticksCoords.length) {
    return;
  }
  const areaColorsLen = areaColors.length;
  const lastSplitAreaColors = inner7(axisView).splitAreaColors;
  const newSplitAreaColors = createHashMap();
  let colorIndex = 0;
  if (lastSplitAreaColors) {
    for (let i = 0; i < ticksCoords.length; i++) {
      const cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);
      if (cIndex != null) {
        colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;
        break;
      }
    }
  }
  let prev = axis.toGlobalCoord(ticksCoords[0].coord);
  const areaStyle = areaStyleModel.getAreaStyle();
  areaColors = isArray(areaColors) ? areaColors : [areaColors];
  for (let i = 1; i < ticksCoords.length; i++) {
    const tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
    let x;
    let y;
    let width;
    let height;
    if (axis.isHorizontal()) {
      x = prev;
      y = gridRect.y;
      width = tickCoord - x;
      height = gridRect.height;
      prev = x + width;
    } else {
      x = gridRect.x;
      y = prev;
      width = gridRect.width;
      height = tickCoord - y;
      prev = y + height;
    }
    const tickValue = ticksCoords[i - 1].tickValue;
    tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);
    axisGroup.add(new Rect_default({
      anid: tickValue != null ? "area_" + tickValue : null,
      shape: {
        x,
        y,
        width,
        height
      },
      style: defaults({
        fill: areaColors[colorIndex]
      }, areaStyle),
      autoBatch: true,
      silent: true
    }));
    colorIndex = (colorIndex + 1) % areaColorsLen;
  }
  inner7(axisView).splitAreaColors = newSplitAreaColors;
}
function rectCoordAxisHandleRemove(axisView) {
  inner7(axisView).splitAreaColors = null;
}

// src/component/axis/CartesianAxisView.ts
var axisBuilderAttrs = [
  "axisLine",
  "axisTickLabel",
  "axisName"
];
var selfBuilderAttrs = [
  "splitArea",
  "splitLine",
  "minorSplitLine"
];
var CartesianAxisView2 = class extends AxisView_default {
  constructor() {
    super(...arguments);
    this.type = CartesianAxisView2.type;
    this.axisPointerClass = "CartesianAxisPointer";
  }
  render(axisModel, ecModel, api2, payload) {
    this.group.removeAll();
    const oldAxisGroup = this._axisGroup;
    this._axisGroup = new Group_default();
    this.group.add(this._axisGroup);
    if (!axisModel.get("show")) {
      return;
    }
    const gridModel = axisModel.getCoordSysModel();
    const layout18 = layout4(gridModel, axisModel);
    const axisBuilder = new AxisBuilder_default(axisModel, extend({
      handleAutoShown(elementType) {
        const cartesians = gridModel.coordinateSystem.getCartesians();
        for (let i = 0; i < cartesians.length; i++) {
          if (isIntervalOrLogScale(cartesians[i].getOtherAxis(axisModel.axis).scale)) {
            return true;
          }
        }
        return false;
      }
    }, layout18));
    each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
    this._axisGroup.add(axisBuilder.getGroup());
    each(selfBuilderAttrs, function(name) {
      if (axisModel.get([name, "show"])) {
        axisElementBuilders[name](this, this._axisGroup, axisModel, gridModel);
      }
    }, this);
    const isInitialSortFromBarRacing = payload && payload.type === "changeAxisOrder" && payload.isInitSort;
    if (!isInitialSortFromBarRacing) {
      groupTransition(oldAxisGroup, this._axisGroup, axisModel);
    }
    super.render(axisModel, ecModel, api2, payload);
  }
  remove() {
    rectCoordAxisHandleRemove(this);
  }
};
var CartesianAxisView = CartesianAxisView2;
CartesianAxisView.type = "cartesianAxis";
var axisElementBuilders = {
  splitLine(axisView, axisGroup, axisModel, gridModel) {
    const axis = axisModel.axis;
    if (axis.scale.isBlank()) {
      return;
    }
    const splitLineModel = axisModel.getModel("splitLine");
    const lineStyleModel = splitLineModel.getModel("lineStyle");
    let lineColors = lineStyleModel.get("color");
    lineColors = isArray(lineColors) ? lineColors : [lineColors];
    const gridRect = gridModel.coordinateSystem.getRect();
    const isHorizontal = axis.isHorizontal();
    let lineCount = 0;
    const ticksCoords = axis.getTicksCoords({
      tickModel: splitLineModel
    });
    const p1 = [];
    const p2 = [];
    const lineStyle = lineStyleModel.getLineStyle();
    for (let i = 0; i < ticksCoords.length; i++) {
      const tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
      if (isHorizontal) {
        p1[0] = tickCoord;
        p1[1] = gridRect.y;
        p2[0] = tickCoord;
        p2[1] = gridRect.y + gridRect.height;
      } else {
        p1[0] = gridRect.x;
        p1[1] = tickCoord;
        p2[0] = gridRect.x + gridRect.width;
        p2[1] = tickCoord;
      }
      const colorIndex = lineCount++ % lineColors.length;
      const tickValue = ticksCoords[i].tickValue;
      const line2 = new Line_default({
        anid: tickValue != null ? "line_" + ticksCoords[i].tickValue : null,
        autoBatch: true,
        shape: {
          x1: p1[0],
          y1: p1[1],
          x2: p2[0],
          y2: p2[1]
        },
        style: defaults({
          stroke: lineColors[colorIndex]
        }, lineStyle),
        silent: true
      });
      subPixelOptimizeLine2(line2.shape, lineStyle.lineWidth);
      axisGroup.add(line2);
    }
  },
  minorSplitLine(axisView, axisGroup, axisModel, gridModel) {
    const axis = axisModel.axis;
    const minorSplitLineModel = axisModel.getModel("minorSplitLine");
    const lineStyleModel = minorSplitLineModel.getModel("lineStyle");
    const gridRect = gridModel.coordinateSystem.getRect();
    const isHorizontal = axis.isHorizontal();
    const minorTicksCoords = axis.getMinorTicksCoords();
    if (!minorTicksCoords.length) {
      return;
    }
    const p1 = [];
    const p2 = [];
    const lineStyle = lineStyleModel.getLineStyle();
    for (let i = 0; i < minorTicksCoords.length; i++) {
      for (let k = 0; k < minorTicksCoords[i].length; k++) {
        const tickCoord = axis.toGlobalCoord(minorTicksCoords[i][k].coord);
        if (isHorizontal) {
          p1[0] = tickCoord;
          p1[1] = gridRect.y;
          p2[0] = tickCoord;
          p2[1] = gridRect.y + gridRect.height;
        } else {
          p1[0] = gridRect.x;
          p1[1] = tickCoord;
          p2[0] = gridRect.x + gridRect.width;
          p2[1] = tickCoord;
        }
        const line2 = new Line_default({
          anid: "minor_line_" + minorTicksCoords[i][k].tickValue,
          autoBatch: true,
          shape: {
            x1: p1[0],
            y1: p1[1],
            x2: p2[0],
            y2: p2[1]
          },
          style: lineStyle,
          silent: true
        });
        subPixelOptimizeLine2(line2.shape, lineStyle.lineWidth);
        axisGroup.add(line2);
      }
    }
  },
  splitArea(axisView, axisGroup, axisModel, gridModel) {
    rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel);
  }
};
var CartesianXAxisView2 = class extends CartesianAxisView {
  constructor() {
    super(...arguments);
    this.type = CartesianXAxisView2.type;
  }
};
var CartesianXAxisView = CartesianXAxisView2;
CartesianXAxisView.type = "xAxis";
var CartesianYAxisView = class extends CartesianAxisView {
  constructor() {
    super(...arguments);
    this.type = CartesianXAxisView.type;
  }
};
CartesianYAxisView.type = "yAxis";

// src/component/grid/installSimple.ts
var GridView = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = "grid";
  }
  render(gridModel, ecModel) {
    this.group.removeAll();
    if (gridModel.get("show")) {
      this.group.add(new Rect_default({
        shape: gridModel.coordinateSystem.getRect(),
        style: defaults({
          fill: gridModel.get("backgroundColor")
        }, gridModel.getItemStyle()),
        silent: true,
        z2: -1
      }));
    }
  }
};
GridView.type = "grid";
var extraOption = {
  offset: 0
};
function install6(registers) {
  registers.registerComponentView(GridView);
  registers.registerComponentModel(GridModel_default);
  registers.registerCoordinateSystem("cartesian2d", Grid_default);
  axisModelCreator(registers, "x", CartesianAxisModel, extraOption);
  axisModelCreator(registers, "y", CartesianAxisModel, extraOption);
  registers.registerComponentView(CartesianXAxisView);
  registers.registerComponentView(CartesianYAxisView);
  registers.registerPreprocessor(function(option) {
    if (option.xAxis && option.yAxis && !option.grid) {
      option.grid = {};
    }
  });
}

// src/chart/scatter/install.ts
function install7(registers) {
  use(install6);
  registers.registerSeriesModel(ScatterSeries_default);
  registers.registerChartView(ScatterView_default);
  registers.registerLayout(pointsLayout("scatter"));
}

// src/chart/radar/radarLayout.ts
function radarLayout(ecModel) {
  ecModel.eachSeriesByType("radar", function(seriesModel) {
    const data = seriesModel.getData();
    const points4 = [];
    const coordSys = seriesModel.coordinateSystem;
    if (!coordSys) {
      return;
    }
    const axes = coordSys.getIndicatorAxes();
    each(axes, function(axis, axisIndex) {
      data.each(data.mapDimension(axes[axisIndex].dim), function(val, dataIndex) {
        points4[dataIndex] = points4[dataIndex] || [];
        const point = coordSys.dataToPoint(val, axisIndex);
        points4[dataIndex][axisIndex] = isValidPoint(point) ? point : getValueMissingPoint(coordSys);
      });
    });
    data.each(function(idx) {
      const firstPoint = find(points4[idx], function(point) {
        return isValidPoint(point);
      }) || getValueMissingPoint(coordSys);
      points4[idx].push(firstPoint.slice());
      data.setItemLayout(idx, points4[idx]);
    });
  });
}
function isValidPoint(point) {
  return !isNaN(point[0]) && !isNaN(point[1]);
}
function getValueMissingPoint(coordSys) {
  return [coordSys.cx, coordSys.cy];
}

// src/chart/radar/backwardCompat.ts
function radarBackwardCompat(option) {
  let polarOptArr = option.polar;
  if (polarOptArr) {
    if (!isArray(polarOptArr)) {
      polarOptArr = [polarOptArr];
    }
    const polarNotRadar = [];
    each(polarOptArr, function(polarOpt, idx) {
      if (polarOpt.indicator) {
        if (polarOpt.type && !polarOpt.shape) {
          polarOpt.shape = polarOpt.type;
        }
        option.radar = option.radar || [];
        if (!isArray(option.radar)) {
          option.radar = [option.radar];
        }
        option.radar.push(polarOpt);
      } else {
        polarNotRadar.push(polarOpt);
      }
    });
    option.polar = polarNotRadar;
  }
  each(option.series, function(seriesOpt) {
    if (seriesOpt && seriesOpt.type === "radar" && seriesOpt.polarIndex) {
      seriesOpt.radarIndex = seriesOpt.polarIndex;
    }
  });
}

// src/chart/radar/RadarView.ts
var RadarView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = RadarView2.type;
  }
  render(seriesModel, ecModel, api2) {
    const polar = seriesModel.coordinateSystem;
    const group = this.group;
    const data = seriesModel.getData();
    const oldData = this._data;
    function createSymbol3(data2, idx) {
      const symbolType = data2.getItemVisual(idx, "symbol") || "circle";
      if (symbolType === "none") {
        return;
      }
      const symbolSize = normalizeSymbolSize(data2.getItemVisual(idx, "symbolSize"));
      const symbolPath = createSymbol(symbolType, -1, -1, 2, 2);
      const symbolRotate = data2.getItemVisual(idx, "symbolRotate") || 0;
      symbolPath.attr({
        style: {
          strokeNoScale: true
        },
        z2: 100,
        scaleX: symbolSize[0] / 2,
        scaleY: symbolSize[1] / 2,
        rotation: symbolRotate * Math.PI / 180 || 0
      });
      return symbolPath;
    }
    function updateSymbols(oldPoints, newPoints, symbolGroup, data2, idx, isInit) {
      symbolGroup.removeAll();
      for (let i = 0; i < newPoints.length - 1; i++) {
        const symbolPath = createSymbol3(data2, idx);
        if (symbolPath) {
          symbolPath.__dimIdx = i;
          if (oldPoints[i]) {
            symbolPath.setPosition(oldPoints[i]);
            graphic_exports[isInit ? "initProps" : "updateProps"](symbolPath, {
              x: newPoints[i][0],
              y: newPoints[i][1]
            }, seriesModel, idx);
          } else {
            symbolPath.setPosition(newPoints[i]);
          }
          symbolGroup.add(symbolPath);
        }
      }
    }
    function getInitialPoints(points4) {
      return map(points4, function(pt) {
        return [polar.cx, polar.cy];
      });
    }
    data.diff(oldData).add(function(idx) {
      const points4 = data.getItemLayout(idx);
      if (!points4) {
        return;
      }
      const polygon = new Polygon_default();
      const polyline = new Polyline_default();
      const target = {
        shape: {
          points: points4
        }
      };
      polygon.shape.points = getInitialPoints(points4);
      polyline.shape.points = getInitialPoints(points4);
      initProps(polygon, target, seriesModel, idx);
      initProps(polyline, target, seriesModel, idx);
      const itemGroup = new Group_default();
      const symbolGroup = new Group_default();
      itemGroup.add(polyline);
      itemGroup.add(polygon);
      itemGroup.add(symbolGroup);
      updateSymbols(polyline.shape.points, points4, symbolGroup, data, idx, true);
      data.setItemGraphicEl(idx, itemGroup);
    }).update(function(newIdx, oldIdx) {
      const itemGroup = oldData.getItemGraphicEl(oldIdx);
      const polyline = itemGroup.childAt(0);
      const polygon = itemGroup.childAt(1);
      const symbolGroup = itemGroup.childAt(2);
      const target = {
        shape: {
          points: data.getItemLayout(newIdx)
        }
      };
      if (!target.shape.points) {
        return;
      }
      updateSymbols(polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false);
      saveOldStyle(polygon);
      saveOldStyle(polyline);
      updateProps(polyline, target, seriesModel);
      updateProps(polygon, target, seriesModel);
      data.setItemGraphicEl(newIdx, itemGroup);
    }).remove(function(idx) {
      group.remove(oldData.getItemGraphicEl(idx));
    }).execute();
    data.eachItemGraphicEl(function(itemGroup, idx) {
      const itemModel = data.getItemModel(idx);
      const polyline = itemGroup.childAt(0);
      const polygon = itemGroup.childAt(1);
      const symbolGroup = itemGroup.childAt(2);
      const itemStyle = data.getItemVisual(idx, "style");
      const color2 = itemStyle.fill;
      group.add(itemGroup);
      polyline.useStyle(defaults(itemModel.getModel("lineStyle").getLineStyle(), {
        fill: "none",
        stroke: color2
      }));
      setStatesStylesFromModel(polyline, itemModel, "lineStyle");
      setStatesStylesFromModel(polygon, itemModel, "areaStyle");
      const areaStyleModel = itemModel.getModel("areaStyle");
      const polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();
      polygon.ignore = polygonIgnore;
      each(["emphasis", "select", "blur"], function(stateName) {
        const stateModel = itemModel.getModel([stateName, "areaStyle"]);
        const stateIgnore = stateModel.isEmpty() && stateModel.parentModel.isEmpty();
        polygon.ensureState(stateName).ignore = stateIgnore && polygonIgnore;
      });
      polygon.useStyle(defaults(areaStyleModel.getAreaStyle(), {
        fill: color2,
        opacity: 0.7,
        decal: itemStyle.decal
      }));
      const emphasisModel = itemModel.getModel("emphasis");
      const itemHoverStyle = emphasisModel.getModel("itemStyle").getItemStyle();
      symbolGroup.eachChild(function(symbolPath) {
        if (symbolPath instanceof Image_default) {
          const pathStyle = symbolPath.style;
          symbolPath.useStyle(extend({
            image: pathStyle.image,
            x: pathStyle.x,
            y: pathStyle.y,
            width: pathStyle.width,
            height: pathStyle.height
          }, itemStyle));
        } else {
          symbolPath.useStyle(itemStyle);
          symbolPath.setColor(color2);
          symbolPath.style.strokeNoScale = true;
        }
        const pathEmphasisState = symbolPath.ensureState("emphasis");
        pathEmphasisState.style = clone(itemHoverStyle);
        let defaultText = data.getStore().get(data.getDimensionIndex(symbolPath.__dimIdx), idx);
        (defaultText == null || isNaN(defaultText)) && (defaultText = "");
        setLabelStyle(symbolPath, getLabelStatesModels(itemModel), {
          labelFetcher: data.hostModel,
          labelDataIndex: idx,
          labelDimIndex: symbolPath.__dimIdx,
          defaultText,
          inheritColor: color2,
          defaultOpacity: itemStyle.opacity
        });
      });
      toggleHoverEmphasis(itemGroup, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    });
    this._data = data;
  }
  remove() {
    this.group.removeAll();
    this._data = null;
  }
};
var RadarView = RadarView2;
RadarView.type = "radar";
var RadarView_default = RadarView;

// src/chart/radar/RadarSeries.ts
var RadarSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = RadarSeriesModel2.type;
    this.hasSymbolVisual = true;
  }
  init(option) {
    super.init.apply(this, arguments);
    this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this));
  }
  getInitialData(option, ecModel) {
    return createSeriesDataSimply(this, {
      generateCoord: "indicator_",
      generateCoordCount: Infinity
    });
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    const data = this.getData();
    const coordSys = this.coordinateSystem;
    const indicatorAxes = coordSys.getIndicatorAxes();
    const name = this.getData().getName(dataIndex);
    const nameToDisplay = name === "" ? this.name : name;
    const markerColor = retrieveVisualColorForTooltipMarker(this, dataIndex);
    return createTooltipMarkup("section", {
      header: nameToDisplay,
      sortBlocks: true,
      blocks: map(indicatorAxes, (axis) => {
        const val = data.get(data.mapDimension(axis.dim), dataIndex);
        return createTooltipMarkup("nameValue", {
          markerType: "subItem",
          markerColor,
          name: axis.name,
          value: val,
          sortParam: val
        });
      })
    });
  }
  getTooltipPosition(dataIndex) {
    if (dataIndex != null) {
      const data = this.getData();
      const coordSys = this.coordinateSystem;
      const values = data.getValues(map(coordSys.dimensions, function(dim) {
        return data.mapDimension(dim);
      }), dataIndex);
      for (let i = 0, len2 = values.length; i < len2; i++) {
        if (!isNaN(values[i])) {
          const indicatorAxes = coordSys.getIndicatorAxes();
          return coordSys.coordToPoint(indicatorAxes[i].dataToCoord(values[i]), i);
        }
      }
    }
  }
};
var RadarSeriesModel = RadarSeriesModel2;
RadarSeriesModel.type = "series.radar";
RadarSeriesModel.dependencies = ["radar"];
RadarSeriesModel.defaultOption = {
  z: 2,
  colorBy: "data",
  coordinateSystem: "radar",
  legendHoverLink: true,
  radarIndex: 0,
  lineStyle: {
    width: 2,
    type: "solid",
    join: "round"
  },
  label: {
    position: "top"
  },
  symbolSize: 8
};
var RadarSeries_default = RadarSeriesModel;

// src/coord/radar/RadarModel.ts
var valueAxisDefault = axisDefault_default.value;
function defaultsShow(opt, show) {
  return defaults({
    show
  }, opt);
}
var RadarModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = RadarModel2.type;
  }
  optionUpdated() {
    const boundaryGap = this.get("boundaryGap");
    const splitNumber = this.get("splitNumber");
    const scale4 = this.get("scale");
    const axisLine = this.get("axisLine");
    const axisTick = this.get("axisTick");
    const axisLabel = this.get("axisLabel");
    const nameTextStyle = this.get("axisName");
    const showName = this.get(["axisName", "show"]);
    const nameFormatter = this.get(["axisName", "formatter"]);
    const nameGap = this.get("axisNameGap");
    const triggerEvent = this.get("triggerEvent");
    const indicatorModels = map(this.get("indicator") || [], function(indicatorOpt) {
      if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {
        indicatorOpt.min = 0;
      } else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {
        indicatorOpt.max = 0;
      }
      let iNameTextStyle = nameTextStyle;
      if (indicatorOpt.color != null) {
        iNameTextStyle = defaults({
          color: indicatorOpt.color
        }, nameTextStyle);
      }
      const innerIndicatorOpt = merge(clone(indicatorOpt), {
        boundaryGap,
        splitNumber,
        scale: scale4,
        axisLine,
        axisTick,
        axisLabel,
        name: indicatorOpt.text,
        showName,
        nameLocation: "end",
        nameGap,
        nameTextStyle: iNameTextStyle,
        triggerEvent
      }, false);
      if (isString(nameFormatter)) {
        const indName = innerIndicatorOpt.name;
        innerIndicatorOpt.name = nameFormatter.replace("{value}", indName != null ? indName : "");
      } else if (isFunction(nameFormatter)) {
        innerIndicatorOpt.name = nameFormatter(innerIndicatorOpt.name, innerIndicatorOpt);
      }
      const model = new Model_default(innerIndicatorOpt, null, this.ecModel);
      mixin(model, AxisModelCommonMixin.prototype);
      model.mainType = "radar";
      model.componentIndex = this.componentIndex;
      return model;
    }, this);
    this._indicatorModels = indicatorModels;
  }
  getIndicatorModels() {
    return this._indicatorModels;
  }
};
var RadarModel = RadarModel2;
RadarModel.type = "radar";
RadarModel.defaultOption = {
  z: 0,
  center: ["50%", "50%"],
  radius: "75%",
  startAngle: 90,
  axisName: {
    show: true
  },
  boundaryGap: [0, 0],
  splitNumber: 5,
  axisNameGap: 15,
  scale: false,
  shape: "polygon",
  axisLine: merge({
    lineStyle: {
      color: "#bbb"
    }
  }, valueAxisDefault.axisLine),
  axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),
  axisTick: defaultsShow(valueAxisDefault.axisTick, false),
  splitLine: defaultsShow(valueAxisDefault.splitLine, true),
  splitArea: defaultsShow(valueAxisDefault.splitArea, true),
  indicator: []
};
var RadarModel_default = RadarModel;

// src/component/radar/RadarView.ts
var axisBuilderAttrs2 = [
  "axisLine",
  "axisTickLabel",
  "axisName"
];
var RadarView4 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = RadarView4.type;
  }
  render(radarModel, ecModel, api2) {
    const group = this.group;
    group.removeAll();
    this._buildAxes(radarModel);
    this._buildSplitLineAndArea(radarModel);
  }
  _buildAxes(radarModel) {
    const radar = radarModel.coordinateSystem;
    const indicatorAxes = radar.getIndicatorAxes();
    const axisBuilders = map(indicatorAxes, function(indicatorAxis) {
      const axisName = indicatorAxis.model.get("showName") ? indicatorAxis.name : "";
      const axisBuilder = new AxisBuilder_default(indicatorAxis.model, {
        axisName,
        position: [radar.cx, radar.cy],
        rotation: indicatorAxis.angle,
        labelDirection: -1,
        tickDirection: -1,
        nameDirection: 1
      });
      return axisBuilder;
    });
    each(axisBuilders, function(axisBuilder) {
      each(axisBuilderAttrs2, axisBuilder.add, axisBuilder);
      this.group.add(axisBuilder.getGroup());
    }, this);
  }
  _buildSplitLineAndArea(radarModel) {
    const radar = radarModel.coordinateSystem;
    const indicatorAxes = radar.getIndicatorAxes();
    if (!indicatorAxes.length) {
      return;
    }
    const shape = radarModel.get("shape");
    const splitLineModel = radarModel.getModel("splitLine");
    const splitAreaModel = radarModel.getModel("splitArea");
    const lineStyleModel = splitLineModel.getModel("lineStyle");
    const areaStyleModel = splitAreaModel.getModel("areaStyle");
    const showSplitLine = splitLineModel.get("show");
    const showSplitArea = splitAreaModel.get("show");
    const splitLineColors = lineStyleModel.get("color");
    const splitAreaColors = areaStyleModel.get("color");
    const splitLineColorsArr = isArray(splitLineColors) ? splitLineColors : [splitLineColors];
    const splitAreaColorsArr = isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];
    const splitLines = [];
    const splitAreas = [];
    function getColorIndex(areaOrLine, areaOrLineColorList, idx) {
      const colorIndex = idx % areaOrLineColorList.length;
      areaOrLine[colorIndex] = areaOrLine[colorIndex] || [];
      return colorIndex;
    }
    if (shape === "circle") {
      const ticksRadius = indicatorAxes[0].getTicksCoords();
      const cx = radar.cx;
      const cy = radar.cy;
      for (let i = 0; i < ticksRadius.length; i++) {
        if (showSplitLine) {
          const colorIndex = getColorIndex(splitLines, splitLineColorsArr, i);
          splitLines[colorIndex].push(new Circle_default({
            shape: {
              cx,
              cy,
              r: ticksRadius[i].coord
            }
          }));
        }
        if (showSplitArea && i < ticksRadius.length - 1) {
          const colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i);
          splitAreas[colorIndex].push(new Ring_default({
            shape: {
              cx,
              cy,
              r0: ticksRadius[i].coord,
              r: ticksRadius[i + 1].coord
            }
          }));
        }
      }
    } else {
      let realSplitNumber;
      const axesTicksPoints = map(indicatorAxes, function(indicatorAxis, idx) {
        const ticksCoords = indicatorAxis.getTicksCoords();
        realSplitNumber = realSplitNumber == null ? ticksCoords.length - 1 : Math.min(ticksCoords.length - 1, realSplitNumber);
        return map(ticksCoords, function(tickCoord) {
          return radar.coordToPoint(tickCoord.coord, idx);
        });
      });
      let prevPoints = [];
      for (let i = 0; i <= realSplitNumber; i++) {
        const points4 = [];
        for (let j = 0; j < indicatorAxes.length; j++) {
          points4.push(axesTicksPoints[j][i]);
        }
        if (points4[0]) {
          points4.push(points4[0].slice());
        } else {
          if (true) {
            console.error("Can't draw value axis " + i);
          }
        }
        if (showSplitLine) {
          const colorIndex = getColorIndex(splitLines, splitLineColorsArr, i);
          splitLines[colorIndex].push(new Polyline_default({
            shape: {
              points: points4
            }
          }));
        }
        if (showSplitArea && prevPoints) {
          const colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i - 1);
          splitAreas[colorIndex].push(new Polygon_default({
            shape: {
              points: points4.concat(prevPoints)
            }
          }));
        }
        prevPoints = points4.slice().reverse();
      }
    }
    const lineStyle = lineStyleModel.getLineStyle();
    const areaStyle = areaStyleModel.getAreaStyle();
    each(splitAreas, function(splitAreas2, idx) {
      this.group.add(mergePath2(splitAreas2, {
        style: defaults({
          stroke: "none",
          fill: splitAreaColorsArr[idx % splitAreaColorsArr.length]
        }, areaStyle),
        silent: true
      }));
    }, this);
    each(splitLines, function(splitLines2, idx) {
      this.group.add(mergePath2(splitLines2, {
        style: defaults({
          fill: "none",
          stroke: splitLineColorsArr[idx % splitLineColorsArr.length]
        }, lineStyle),
        silent: true
      }));
    }, this);
  }
};
var RadarView3 = RadarView4;
RadarView3.type = "radar";
var RadarView_default2 = RadarView3;

// src/coord/radar/IndicatorAxis.ts
var IndicatorAxis = class extends Axis_default {
  constructor(dim, scale4, radiusExtent) {
    super(dim, scale4, radiusExtent);
    this.type = "value";
    this.angle = 0;
    this.name = "";
  }
};
var IndicatorAxis_default = IndicatorAxis;

// src/coord/radar/Radar.ts
var Radar2 = class {
  constructor(radarModel, ecModel, api2) {
    this.dimensions = [];
    this._model = radarModel;
    this._indicatorAxes = map(radarModel.getIndicatorModels(), function(indicatorModel, idx) {
      const dim = "indicator_" + idx;
      const indicatorAxis = new IndicatorAxis_default(dim, new Interval_default());
      indicatorAxis.name = indicatorModel.get("name");
      indicatorAxis.model = indicatorModel;
      indicatorModel.axis = indicatorAxis;
      this.dimensions.push(dim);
      return indicatorAxis;
    }, this);
    this.resize(radarModel, api2);
  }
  getIndicatorAxes() {
    return this._indicatorAxes;
  }
  dataToPoint(value, indicatorIndex) {
    const indicatorAxis = this._indicatorAxes[indicatorIndex];
    return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);
  }
  coordToPoint(coord, indicatorIndex) {
    const indicatorAxis = this._indicatorAxes[indicatorIndex];
    const angle = indicatorAxis.angle;
    const x = this.cx + coord * Math.cos(angle);
    const y = this.cy - coord * Math.sin(angle);
    return [x, y];
  }
  pointToData(pt) {
    let dx = pt[0] - this.cx;
    let dy = pt[1] - this.cy;
    const radius = Math.sqrt(dx * dx + dy * dy);
    dx /= radius;
    dy /= radius;
    const radian = Math.atan2(-dy, dx);
    let minRadianDiff = Infinity;
    let closestAxis;
    let closestAxisIdx = -1;
    for (let i = 0; i < this._indicatorAxes.length; i++) {
      const indicatorAxis = this._indicatorAxes[i];
      const diff = Math.abs(radian - indicatorAxis.angle);
      if (diff < minRadianDiff) {
        closestAxis = indicatorAxis;
        closestAxisIdx = i;
        minRadianDiff = diff;
      }
    }
    return [closestAxisIdx, +(closestAxis && closestAxis.coordToData(radius))];
  }
  resize(radarModel, api2) {
    const center3 = radarModel.get("center");
    const viewWidth = api2.getWidth();
    const viewHeight = api2.getHeight();
    const viewSize = Math.min(viewWidth, viewHeight) / 2;
    this.cx = parsePercent2(center3[0], viewWidth);
    this.cy = parsePercent2(center3[1], viewHeight);
    this.startAngle = radarModel.get("startAngle") * Math.PI / 180;
    let radius = radarModel.get("radius");
    if (isString(radius) || isNumber(radius)) {
      radius = [0, radius];
    }
    this.r0 = parsePercent2(radius[0], viewSize);
    this.r = parsePercent2(radius[1], viewSize);
    each(this._indicatorAxes, function(indicatorAxis, idx) {
      indicatorAxis.setExtent(this.r0, this.r);
      let angle = this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length;
      angle = Math.atan2(Math.sin(angle), Math.cos(angle));
      indicatorAxis.angle = angle;
    }, this);
  }
  update(ecModel, api2) {
    const indicatorAxes = this._indicatorAxes;
    const radarModel = this._model;
    each(indicatorAxes, function(indicatorAxis) {
      indicatorAxis.scale.setExtent(Infinity, -Infinity);
    });
    ecModel.eachSeriesByType("radar", function(radarSeries, idx) {
      if (radarSeries.get("coordinateSystem") !== "radar" || ecModel.getComponent("radar", radarSeries.get("radarIndex")) !== radarModel) {
        return;
      }
      const data = radarSeries.getData();
      each(indicatorAxes, function(indicatorAxis) {
        indicatorAxis.scale.unionExtentFromData(data, data.mapDimension(indicatorAxis.dim));
      });
    }, this);
    const splitNumber = radarModel.get("splitNumber");
    const dummyScale = new Interval_default();
    dummyScale.setExtent(0, splitNumber);
    dummyScale.setInterval(1);
    each(indicatorAxes, function(indicatorAxis, idx) {
      alignScaleTicks(indicatorAxis.scale, indicatorAxis.model, dummyScale);
    });
  }
  convertToPixel(ecModel, finder, value) {
    console.warn("Not implemented.");
    return null;
  }
  convertFromPixel(ecModel, finder, pixel) {
    console.warn("Not implemented.");
    return null;
  }
  containPoint(point) {
    console.warn("Not implemented.");
    return false;
  }
  static create(ecModel, api2) {
    const radarList = [];
    ecModel.eachComponent("radar", function(radarModel) {
      const radar = new Radar2(radarModel, ecModel, api2);
      radarList.push(radar);
      radarModel.coordinateSystem = radar;
    });
    ecModel.eachSeriesByType("radar", function(radarSeries) {
      if (radarSeries.get("coordinateSystem") === "radar") {
        radarSeries.coordinateSystem = radarList[radarSeries.get("radarIndex") || 0];
      }
    });
    return radarList;
  }
};
var Radar = Radar2;
Radar.dimensions = [];
var Radar_default = Radar;

// src/component/radar/install.ts
function install8(registers) {
  registers.registerCoordinateSystem("radar", Radar_default);
  registers.registerComponentModel(RadarModel_default);
  registers.registerComponentView(RadarView_default2);
  registers.registerVisual({
    seriesType: "radar",
    reset: function(seriesModel) {
      const data = seriesModel.getData();
      data.each(function(idx) {
        data.setItemVisual(idx, "legendIcon", "roundRect");
      });
      data.setVisual("legendIcon", "roundRect");
    }
  });
}

// src/chart/radar/install.ts
function install9(registers) {
  use(install8);
  registers.registerChartView(RadarView_default);
  registers.registerSeriesModel(RadarSeries_default);
  registers.registerLayout(radarLayout);
  registers.registerProcessor(dataFilter("radar"));
  registers.registerPreprocessor(radarBackwardCompat);
}

// src/component/helper/interactionMutex.ts
var ATTR = "\0_ec_interaction_mutex";
function take(zr, resourceKey, userKey) {
  const store = getStore(zr);
  store[resourceKey] = userKey;
}
function release(zr, resourceKey, userKey) {
  const store = getStore(zr);
  const uKey = store[resourceKey];
  if (uKey === userKey) {
    store[resourceKey] = null;
  }
}
function isTaken(zr, resourceKey) {
  return !!getStore(zr)[resourceKey];
}
function getStore(zr) {
  return zr[ATTR] || (zr[ATTR] = {});
}
registerAction({type: "takeGlobalCursor", event: "globalCursorTaken", update: "update"}, noop);

// src/component/helper/RoamController.ts
var RoamController = class extends Eventful_default {
  constructor(zr) {
    super();
    this._zr = zr;
    const mousedownHandler = bind(this._mousedownHandler, this);
    const mousemoveHandler = bind(this._mousemoveHandler, this);
    const mouseupHandler = bind(this._mouseupHandler, this);
    const mousewheelHandler = bind(this._mousewheelHandler, this);
    const pinchHandler = bind(this._pinchHandler, this);
    this.enable = function(controlType, opt) {
      this.disable();
      this._opt = defaults(clone(opt) || {}, {
        zoomOnMouseWheel: true,
        moveOnMouseMove: true,
        moveOnMouseWheel: false,
        preventDefaultMouseMove: true
      });
      if (controlType == null) {
        controlType = true;
      }
      if (controlType === true || (controlType === "move" || controlType === "pan")) {
        zr.on("mousedown", mousedownHandler);
        zr.on("mousemove", mousemoveHandler);
        zr.on("mouseup", mouseupHandler);
      }
      if (controlType === true || (controlType === "scale" || controlType === "zoom")) {
        zr.on("mousewheel", mousewheelHandler);
        zr.on("pinch", pinchHandler);
      }
    };
    this.disable = function() {
      zr.off("mousedown", mousedownHandler);
      zr.off("mousemove", mousemoveHandler);
      zr.off("mouseup", mouseupHandler);
      zr.off("mousewheel", mousewheelHandler);
      zr.off("pinch", pinchHandler);
    };
  }
  isDragging() {
    return this._dragging;
  }
  isPinching() {
    return this._pinching;
  }
  setPointerChecker(pointerChecker) {
    this.pointerChecker = pointerChecker;
  }
  dispose() {
    this.disable();
  }
  _mousedownHandler(e2) {
    if (isMiddleOrRightButtonOnMouseUpDown(e2)) {
      return;
    }
    let el = e2.target;
    while (el) {
      if (el.draggable) {
        return;
      }
      el = el.__hostTarget || el.parent;
    }
    const x = e2.offsetX;
    const y = e2.offsetY;
    if (this.pointerChecker && this.pointerChecker(e2, x, y)) {
      this._x = x;
      this._y = y;
      this._dragging = true;
    }
  }
  _mousemoveHandler(e2) {
    if (!this._dragging || !isAvailableBehavior("moveOnMouseMove", e2, this._opt) || e2.gestureEvent === "pinch" || isTaken(this._zr, "globalPan")) {
      return;
    }
    const x = e2.offsetX;
    const y = e2.offsetY;
    const oldX = this._x;
    const oldY = this._y;
    const dx = x - oldX;
    const dy = y - oldY;
    this._x = x;
    this._y = y;
    this._opt.preventDefaultMouseMove && stop(e2.event);
    trigger(this, "pan", "moveOnMouseMove", e2, {
      dx,
      dy,
      oldX,
      oldY,
      newX: x,
      newY: y,
      isAvailableBehavior: null
    });
  }
  _mouseupHandler(e2) {
    if (!isMiddleOrRightButtonOnMouseUpDown(e2)) {
      this._dragging = false;
    }
  }
  _mousewheelHandler(e2) {
    const shouldZoom = isAvailableBehavior("zoomOnMouseWheel", e2, this._opt);
    const shouldMove = isAvailableBehavior("moveOnMouseWheel", e2, this._opt);
    const wheelDelta = e2.wheelDelta;
    const absWheelDeltaDelta = Math.abs(wheelDelta);
    const originX = e2.offsetX;
    const originY = e2.offsetY;
    if (wheelDelta === 0 || !shouldZoom && !shouldMove) {
      return;
    }
    if (shouldZoom) {
      const factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1;
      const scale4 = wheelDelta > 0 ? factor : 1 / factor;
      checkPointerAndTrigger(this, "zoom", "zoomOnMouseWheel", e2, {
        scale: scale4,
        originX,
        originY,
        isAvailableBehavior: null
      });
    }
    if (shouldMove) {
      const absDelta = Math.abs(wheelDelta);
      const scrollDelta = (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? 0.4 : absDelta > 1 ? 0.15 : 0.05);
      checkPointerAndTrigger(this, "scrollMove", "moveOnMouseWheel", e2, {
        scrollDelta,
        originX,
        originY,
        isAvailableBehavior: null
      });
    }
  }
  _pinchHandler(e2) {
    if (isTaken(this._zr, "globalPan")) {
      return;
    }
    const scale4 = e2.pinchScale > 1 ? 1.1 : 1 / 1.1;
    checkPointerAndTrigger(this, "zoom", null, e2, {
      scale: scale4,
      originX: e2.pinchX,
      originY: e2.pinchY,
      isAvailableBehavior: null
    });
  }
};
function checkPointerAndTrigger(controller, eventName, behaviorToCheck, e2, contollerEvent) {
  if (controller.pointerChecker && controller.pointerChecker(e2, contollerEvent.originX, contollerEvent.originY)) {
    stop(e2.event);
    trigger(controller, eventName, behaviorToCheck, e2, contollerEvent);
  }
}
function trigger(controller, eventName, behaviorToCheck, e2, contollerEvent) {
  contollerEvent.isAvailableBehavior = bind(isAvailableBehavior, null, behaviorToCheck, e2);
  controller.trigger(eventName, contollerEvent);
}
function isAvailableBehavior(behaviorToCheck, e2, settings) {
  const setting = settings[behaviorToCheck];
  return !behaviorToCheck || setting && (!isString(setting) || e2.event[setting + "Key"]);
}
var RoamController_default = RoamController;

// src/component/helper/roamHelper.ts
function updateViewOnPan(controllerHost, dx, dy) {
  const target = controllerHost.target;
  target.x += dx;
  target.y += dy;
  target.dirty();
}
function updateViewOnZoom(controllerHost, zoomDelta, zoomX, zoomY) {
  const target = controllerHost.target;
  const zoomLimit = controllerHost.zoomLimit;
  let newZoom = controllerHost.zoom = controllerHost.zoom || 1;
  newZoom *= zoomDelta;
  if (zoomLimit) {
    const zoomMin = zoomLimit.min || 0;
    const zoomMax = zoomLimit.max || Infinity;
    newZoom = Math.max(Math.min(zoomMax, newZoom), zoomMin);
  }
  const zoomScale = newZoom / controllerHost.zoom;
  controllerHost.zoom = newZoom;
  target.x -= (zoomX - target.x) * (zoomScale - 1);
  target.y -= (zoomY - target.y) * (zoomScale - 1);
  target.scaleX *= zoomScale;
  target.scaleY *= zoomScale;
  target.dirty();
}

// src/component/helper/cursorHelper.ts
var IRRELEVANT_EXCLUDES = {axisPointer: 1, tooltip: 1, brush: 1};
function onIrrelevantElement(e2, api2, targetCoordSysModel) {
  const model = api2.getComponentByElement(e2.topTarget);
  const coordSys = model && model.coordinateSystem;
  return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES.hasOwnProperty(model.mainType) && (coordSys && coordSys.model !== targetCoordSysModel);
}

// node_modules/zrender/src/tool/parseXML.ts
function parseXML(svg) {
  if (isString(svg)) {
    const parser = new DOMParser();
    svg = parser.parseFromString(svg, "text/xml");
  }
  let svgNode = svg;
  if (svgNode.nodeType === 9) {
    svgNode = svgNode.firstChild;
  }
  while (svgNode.nodeName.toLowerCase() !== "svg" || svgNode.nodeType !== 1) {
    svgNode = svgNode.nextSibling;
  }
  return svgNode;
}

// node_modules/zrender/src/tool/parseSVG.ts
var nodeParsers;
var INHERITABLE_STYLE_ATTRIBUTES_MAP = {
  fill: "fill",
  stroke: "stroke",
  "stroke-width": "lineWidth",
  opacity: "opacity",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-miterlimit": "miterLimit",
  "font-family": "fontFamily",
  "font-size": "fontSize",
  "font-style": "fontStyle",
  "font-weight": "fontWeight",
  "text-anchor": "textAlign",
  visibility: "visibility",
  display: "display"
};
var INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS = keys(INHERITABLE_STYLE_ATTRIBUTES_MAP);
var SELF_STYLE_ATTRIBUTES_MAP = {
  "alignment-baseline": "textBaseline",
  "stop-color": "stopColor"
};
var SELF_STYLE_ATTRIBUTES_MAP_KEYS = keys(SELF_STYLE_ATTRIBUTES_MAP);
var SVGParser = class {
  constructor() {
    this._defs = {};
    this._root = null;
  }
  parse(xml, opt) {
    opt = opt || {};
    const svg = parseXML(xml);
    if (true) {
      if (!svg) {
        throw new Error("Illegal svg");
      }
    }
    this._defsUsePending = [];
    let root = new Group_default();
    this._root = root;
    const named = [];
    const viewBox = svg.getAttribute("viewBox") || "";
    let width = parseFloat(svg.getAttribute("width") || opt.width);
    let height = parseFloat(svg.getAttribute("height") || opt.height);
    isNaN(width) && (width = null);
    isNaN(height) && (height = null);
    parseAttributes(svg, root, null, true, false);
    let child = svg.firstChild;
    while (child) {
      this._parseNode(child, root, named, null, false, false);
      child = child.nextSibling;
    }
    applyDefs(this._defs, this._defsUsePending);
    this._defsUsePending = [];
    let viewBoxRect;
    let viewBoxTransform;
    if (viewBox) {
      const viewBoxArr = splitNumberSequence(viewBox);
      if (viewBoxArr.length >= 4) {
        viewBoxRect = {
          x: parseFloat(viewBoxArr[0] || 0),
          y: parseFloat(viewBoxArr[1] || 0),
          width: parseFloat(viewBoxArr[2]),
          height: parseFloat(viewBoxArr[3])
        };
      }
    }
    if (viewBoxRect && width != null && height != null) {
      viewBoxTransform = makeViewBoxTransform(viewBoxRect, {x: 0, y: 0, width, height});
      if (!opt.ignoreViewBox) {
        const elRoot = root;
        root = new Group_default();
        root.add(elRoot);
        elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;
        elRoot.x = viewBoxTransform.x;
        elRoot.y = viewBoxTransform.y;
      }
    }
    if (!opt.ignoreRootClip && width != null && height != null) {
      root.setClipPath(new Rect_default({
        shape: {x: 0, y: 0, width, height}
      }));
    }
    return {
      root,
      width,
      height,
      viewBoxRect,
      viewBoxTransform,
      named
    };
  }
  _parseNode(xmlNode, parentGroup, named, namedFrom, isInDefs, isInText) {
    const nodeName = xmlNode.nodeName.toLowerCase();
    let el;
    let namedFromForSub = namedFrom;
    if (nodeName === "defs") {
      isInDefs = true;
    }
    if (nodeName === "text") {
      isInText = true;
    }
    if (nodeName === "defs" || nodeName === "switch") {
      el = parentGroup;
    } else {
      if (!isInDefs) {
        const parser2 = nodeParsers[nodeName];
        if (parser2 && hasOwn(nodeParsers, nodeName)) {
          el = parser2.call(this, xmlNode, parentGroup);
          const nameAttr = xmlNode.getAttribute("name");
          if (nameAttr) {
            const newNamed = {
              name: nameAttr,
              namedFrom: null,
              svgNodeTagLower: nodeName,
              el
            };
            named.push(newNamed);
            if (nodeName === "g") {
              namedFromForSub = newNamed;
            }
          } else if (namedFrom) {
            named.push({
              name: namedFrom.name,
              namedFrom,
              svgNodeTagLower: nodeName,
              el
            });
          }
          parentGroup.add(el);
        }
      }
      const parser = paintServerParsers[nodeName];
      if (parser && hasOwn(paintServerParsers, nodeName)) {
        const def = parser.call(this, xmlNode);
        const id = xmlNode.getAttribute("id");
        if (id) {
          this._defs[id] = def;
        }
      }
    }
    if (el && el.isGroup) {
      let child = xmlNode.firstChild;
      while (child) {
        if (child.nodeType === 1) {
          this._parseNode(child, el, named, namedFromForSub, isInDefs, isInText);
        } else if (child.nodeType === 3 && isInText) {
          this._parseText(child, el);
        }
        child = child.nextSibling;
      }
    }
  }
  _parseText(xmlNode, parentGroup) {
    const text = new TSpan_default({
      style: {
        text: xmlNode.textContent
      },
      silent: true,
      x: this._textX || 0,
      y: this._textY || 0
    });
    inheritStyle(parentGroup, text);
    parseAttributes(xmlNode, text, this._defsUsePending, false, false);
    applyTextAlignment(text, parentGroup);
    const textStyle = text.style;
    const fontSize = textStyle.fontSize;
    if (fontSize && fontSize < 9) {
      textStyle.fontSize = 9;
      text.scaleX *= fontSize / 9;
      text.scaleY *= fontSize / 9;
    }
    const font = (textStyle.fontSize || textStyle.fontFamily) && [
      textStyle.fontStyle,
      textStyle.fontWeight,
      (textStyle.fontSize || 12) + "px",
      textStyle.fontFamily || "sans-serif"
    ].join(" ");
    textStyle.font = font;
    const rect = text.getBoundingRect();
    this._textX += rect.width;
    parentGroup.add(text);
    return text;
  }
};
SVGParser.internalField = function() {
  nodeParsers = {
    g: function(xmlNode, parentGroup) {
      const g = new Group_default();
      inheritStyle(parentGroup, g);
      parseAttributes(xmlNode, g, this._defsUsePending, false, false);
      return g;
    },
    rect: function(xmlNode, parentGroup) {
      const rect = new Rect_default();
      inheritStyle(parentGroup, rect);
      parseAttributes(xmlNode, rect, this._defsUsePending, false, false);
      rect.setShape({
        x: parseFloat(xmlNode.getAttribute("x") || "0"),
        y: parseFloat(xmlNode.getAttribute("y") || "0"),
        width: parseFloat(xmlNode.getAttribute("width") || "0"),
        height: parseFloat(xmlNode.getAttribute("height") || "0")
      });
      rect.silent = true;
      return rect;
    },
    circle: function(xmlNode, parentGroup) {
      const circle = new Circle_default();
      inheritStyle(parentGroup, circle);
      parseAttributes(xmlNode, circle, this._defsUsePending, false, false);
      circle.setShape({
        cx: parseFloat(xmlNode.getAttribute("cx") || "0"),
        cy: parseFloat(xmlNode.getAttribute("cy") || "0"),
        r: parseFloat(xmlNode.getAttribute("r") || "0")
      });
      circle.silent = true;
      return circle;
    },
    line: function(xmlNode, parentGroup) {
      const line2 = new Line_default();
      inheritStyle(parentGroup, line2);
      parseAttributes(xmlNode, line2, this._defsUsePending, false, false);
      line2.setShape({
        x1: parseFloat(xmlNode.getAttribute("x1") || "0"),
        y1: parseFloat(xmlNode.getAttribute("y1") || "0"),
        x2: parseFloat(xmlNode.getAttribute("x2") || "0"),
        y2: parseFloat(xmlNode.getAttribute("y2") || "0")
      });
      line2.silent = true;
      return line2;
    },
    ellipse: function(xmlNode, parentGroup) {
      const ellipse = new Ellipse_default();
      inheritStyle(parentGroup, ellipse);
      parseAttributes(xmlNode, ellipse, this._defsUsePending, false, false);
      ellipse.setShape({
        cx: parseFloat(xmlNode.getAttribute("cx") || "0"),
        cy: parseFloat(xmlNode.getAttribute("cy") || "0"),
        rx: parseFloat(xmlNode.getAttribute("rx") || "0"),
        ry: parseFloat(xmlNode.getAttribute("ry") || "0")
      });
      ellipse.silent = true;
      return ellipse;
    },
    polygon: function(xmlNode, parentGroup) {
      const pointsStr = xmlNode.getAttribute("points");
      let pointsArr;
      if (pointsStr) {
        pointsArr = parsePoints(pointsStr);
      }
      const polygon = new Polygon_default({
        shape: {
          points: pointsArr || []
        },
        silent: true
      });
      inheritStyle(parentGroup, polygon);
      parseAttributes(xmlNode, polygon, this._defsUsePending, false, false);
      return polygon;
    },
    polyline: function(xmlNode, parentGroup) {
      const pointsStr = xmlNode.getAttribute("points");
      let pointsArr;
      if (pointsStr) {
        pointsArr = parsePoints(pointsStr);
      }
      const polyline = new Polyline_default({
        shape: {
          points: pointsArr || []
        },
        silent: true
      });
      inheritStyle(parentGroup, polyline);
      parseAttributes(xmlNode, polyline, this._defsUsePending, false, false);
      return polyline;
    },
    image: function(xmlNode, parentGroup) {
      const img = new Image_default();
      inheritStyle(parentGroup, img);
      parseAttributes(xmlNode, img, this._defsUsePending, false, false);
      img.setStyle({
        image: xmlNode.getAttribute("xlink:href") || xmlNode.getAttribute("href"),
        x: +xmlNode.getAttribute("x"),
        y: +xmlNode.getAttribute("y"),
        width: +xmlNode.getAttribute("width"),
        height: +xmlNode.getAttribute("height")
      });
      img.silent = true;
      return img;
    },
    text: function(xmlNode, parentGroup) {
      const x = xmlNode.getAttribute("x") || "0";
      const y = xmlNode.getAttribute("y") || "0";
      const dx = xmlNode.getAttribute("dx") || "0";
      const dy = xmlNode.getAttribute("dy") || "0";
      this._textX = parseFloat(x) + parseFloat(dx);
      this._textY = parseFloat(y) + parseFloat(dy);
      const g = new Group_default();
      inheritStyle(parentGroup, g);
      parseAttributes(xmlNode, g, this._defsUsePending, false, true);
      return g;
    },
    tspan: function(xmlNode, parentGroup) {
      const x = xmlNode.getAttribute("x");
      const y = xmlNode.getAttribute("y");
      if (x != null) {
        this._textX = parseFloat(x);
      }
      if (y != null) {
        this._textY = parseFloat(y);
      }
      const dx = xmlNode.getAttribute("dx") || "0";
      const dy = xmlNode.getAttribute("dy") || "0";
      const g = new Group_default();
      inheritStyle(parentGroup, g);
      parseAttributes(xmlNode, g, this._defsUsePending, false, true);
      this._textX += parseFloat(dx);
      this._textY += parseFloat(dy);
      return g;
    },
    path: function(xmlNode, parentGroup) {
      const d = xmlNode.getAttribute("d") || "";
      const path = createFromString(d);
      inheritStyle(parentGroup, path);
      parseAttributes(xmlNode, path, this._defsUsePending, false, false);
      path.silent = true;
      return path;
    }
  };
}();
var paintServerParsers = {
  lineargradient: function(xmlNode) {
    const x1 = parseInt(xmlNode.getAttribute("x1") || "0", 10);
    const y1 = parseInt(xmlNode.getAttribute("y1") || "0", 10);
    const x2 = parseInt(xmlNode.getAttribute("x2") || "10", 10);
    const y2 = parseInt(xmlNode.getAttribute("y2") || "0", 10);
    const gradient = new LinearGradient_default(x1, y1, x2, y2);
    parsePaintServerUnit(xmlNode, gradient);
    parseGradientColorStops(xmlNode, gradient);
    return gradient;
  },
  radialgradient: function(xmlNode) {
    const cx = parseInt(xmlNode.getAttribute("cx") || "0", 10);
    const cy = parseInt(xmlNode.getAttribute("cy") || "0", 10);
    const r = parseInt(xmlNode.getAttribute("r") || "0", 10);
    const gradient = new RadialGradient_default(cx, cy, r);
    parsePaintServerUnit(xmlNode, gradient);
    parseGradientColorStops(xmlNode, gradient);
    return gradient;
  }
};
function parsePaintServerUnit(xmlNode, gradient) {
  const gradientUnits = xmlNode.getAttribute("gradientUnits");
  if (gradientUnits === "userSpaceOnUse") {
    gradient.global = true;
  }
}
function parseGradientColorStops(xmlNode, gradient) {
  let stop2 = xmlNode.firstChild;
  while (stop2) {
    if (stop2.nodeType === 1 && stop2.nodeName.toLocaleLowerCase() === "stop") {
      const offsetStr = stop2.getAttribute("offset");
      let offset;
      if (offsetStr && offsetStr.indexOf("%") > 0) {
        offset = parseInt(offsetStr, 10) / 100;
      } else if (offsetStr) {
        offset = parseFloat(offsetStr);
      } else {
        offset = 0;
      }
      const styleVals = {};
      parseInlineStyle(stop2, styleVals, styleVals);
      const stopColor = styleVals.stopColor || stop2.getAttribute("stop-color") || "#000000";
      gradient.colorStops.push({
        offset,
        color: stopColor
      });
    }
    stop2 = stop2.nextSibling;
  }
}
function inheritStyle(parent, child) {
  if (parent && parent.__inheritedStyle) {
    if (!child.__inheritedStyle) {
      child.__inheritedStyle = {};
    }
    defaults(child.__inheritedStyle, parent.__inheritedStyle);
  }
}
function parsePoints(pointsString) {
  const list = splitNumberSequence(pointsString);
  const points4 = [];
  for (let i = 0; i < list.length; i += 2) {
    const x = parseFloat(list[i]);
    const y = parseFloat(list[i + 1]);
    points4.push([x, y]);
  }
  return points4;
}
function parseAttributes(xmlNode, el, defsUsePending, onlyInlineStyle, isTextGroup) {
  const disp = el;
  const inheritedStyle = disp.__inheritedStyle = disp.__inheritedStyle || {};
  const selfStyle = {};
  if (xmlNode.nodeType === 1) {
    parseTransformAttribute(xmlNode, el);
    parseInlineStyle(xmlNode, inheritedStyle, selfStyle);
    if (!onlyInlineStyle) {
      parseAttributeStyle(xmlNode, inheritedStyle, selfStyle);
    }
  }
  disp.style = disp.style || {};
  if (inheritedStyle.fill != null) {
    disp.style.fill = getFillStrokeStyle(disp, "fill", inheritedStyle.fill, defsUsePending);
  }
  if (inheritedStyle.stroke != null) {
    disp.style.stroke = getFillStrokeStyle(disp, "stroke", inheritedStyle.stroke, defsUsePending);
  }
  each([
    "lineWidth",
    "opacity",
    "fillOpacity",
    "strokeOpacity",
    "miterLimit",
    "fontSize"
  ], function(propName) {
    if (inheritedStyle[propName] != null) {
      disp.style[propName] = parseFloat(inheritedStyle[propName]);
    }
  });
  each([
    "lineDashOffset",
    "lineCap",
    "lineJoin",
    "fontWeight",
    "fontFamily",
    "fontStyle",
    "textAlign"
  ], function(propName) {
    if (inheritedStyle[propName] != null) {
      disp.style[propName] = inheritedStyle[propName];
    }
  });
  if (isTextGroup) {
    disp.__selfStyle = selfStyle;
  }
  if (inheritedStyle.lineDash) {
    disp.style.lineDash = map(splitNumberSequence(inheritedStyle.lineDash), function(str) {
      return parseFloat(str);
    });
  }
  if (inheritedStyle.visibility === "hidden" || inheritedStyle.visibility === "collapse") {
    disp.invisible = true;
  }
  if (inheritedStyle.display === "none") {
    disp.ignore = true;
  }
}
function applyTextAlignment(text, parentGroup) {
  const parentSelfStyle = parentGroup.__selfStyle;
  if (parentSelfStyle) {
    const textBaseline = parentSelfStyle.textBaseline;
    let zrTextBaseline = textBaseline;
    if (!textBaseline || textBaseline === "auto") {
      zrTextBaseline = "alphabetic";
    } else if (textBaseline === "baseline") {
      zrTextBaseline = "alphabetic";
    } else if (textBaseline === "before-edge" || textBaseline === "text-before-edge") {
      zrTextBaseline = "top";
    } else if (textBaseline === "after-edge" || textBaseline === "text-after-edge") {
      zrTextBaseline = "bottom";
    } else if (textBaseline === "central" || textBaseline === "mathematical") {
      zrTextBaseline = "middle";
    }
    text.style.textBaseline = zrTextBaseline;
  }
  const parentInheritedStyle = parentGroup.__inheritedStyle;
  if (parentInheritedStyle) {
    const textAlign = parentInheritedStyle.textAlign;
    let zrTextAlign = textAlign;
    if (textAlign) {
      if (textAlign === "middle") {
        zrTextAlign = "center";
      }
      text.style.textAlign = zrTextAlign;
    }
  }
}
var urlRegex = /^url\(\s*#(.*?)\)/;
function getFillStrokeStyle(el, method, str, defsUsePending) {
  const urlMatch = str && str.match(urlRegex);
  if (urlMatch) {
    const url = trim(urlMatch[1]);
    defsUsePending.push([el, method, url]);
    return;
  }
  if (str === "none") {
    str = null;
  }
  return str;
}
function applyDefs(defs, defsUsePending) {
  for (let i = 0; i < defsUsePending.length; i++) {
    const item = defsUsePending[i];
    item[0].style[item[1]] = defs[item[2]];
  }
}
var numberReg2 = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function splitNumberSequence(rawStr) {
  return rawStr.match(numberReg2) || [];
}
var transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g;
var DEGREE_TO_ANGLE = Math.PI / 180;
function parseTransformAttribute(xmlNode, node) {
  let transform2 = xmlNode.getAttribute("transform");
  if (transform2) {
    transform2 = transform2.replace(/,/g, " ");
    const transformOps = [];
    let mt = null;
    transform2.replace(transformRegex, function(str, type, value) {
      transformOps.push(type, value);
      return "";
    });
    for (let i = transformOps.length - 1; i > 0; i -= 2) {
      const value = transformOps[i];
      const type = transformOps[i - 1];
      const valueArr = splitNumberSequence(value);
      mt = mt || create2();
      switch (type) {
        case "translate":
          translate(mt, mt, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || "0")]);
          break;
        case "scale":
          scale2(mt, mt, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || valueArr[0])]);
          break;
        case "rotate":
          rotate(mt, mt, -parseFloat(valueArr[0]) * DEGREE_TO_ANGLE, [
            parseFloat(valueArr[1] || "0"),
            parseFloat(valueArr[2] || "0")
          ]);
          break;
        case "skewX":
          const sx = Math.tan(parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);
          mul2(mt, [1, 0, sx, 1, 0, 0], mt);
          break;
        case "skewY":
          const sy = Math.tan(parseFloat(valueArr[0]) * DEGREE_TO_ANGLE);
          mul2(mt, [1, sy, 0, 1, 0, 0], mt);
          break;
        case "matrix":
          mt[0] = parseFloat(valueArr[0]);
          mt[1] = parseFloat(valueArr[1]);
          mt[2] = parseFloat(valueArr[2]);
          mt[3] = parseFloat(valueArr[3]);
          mt[4] = parseFloat(valueArr[4]);
          mt[5] = parseFloat(valueArr[5]);
          break;
      }
    }
    node.setLocalTransform(mt);
  }
}
var styleRegex = /([^\s:;]+)\s*:\s*([^:;]+)/g;
function parseInlineStyle(xmlNode, inheritableStyleResult, selfStyleResult) {
  const style = xmlNode.getAttribute("style");
  if (!style) {
    return;
  }
  styleRegex.lastIndex = 0;
  let styleRegResult;
  while ((styleRegResult = styleRegex.exec(style)) != null) {
    const svgStlAttr = styleRegResult[1];
    const zrInheritableStlAttr = hasOwn(INHERITABLE_STYLE_ATTRIBUTES_MAP, svgStlAttr) ? INHERITABLE_STYLE_ATTRIBUTES_MAP[svgStlAttr] : null;
    if (zrInheritableStlAttr) {
      inheritableStyleResult[zrInheritableStlAttr] = styleRegResult[2];
    }
    const zrSelfStlAttr = hasOwn(SELF_STYLE_ATTRIBUTES_MAP, svgStlAttr) ? SELF_STYLE_ATTRIBUTES_MAP[svgStlAttr] : null;
    if (zrSelfStlAttr) {
      selfStyleResult[zrSelfStlAttr] = styleRegResult[2];
    }
  }
}
function parseAttributeStyle(xmlNode, inheritableStyleResult, selfStyleResult) {
  for (let i = 0; i < INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS.length; i++) {
    const svgAttrName = INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS[i];
    const attrValue = xmlNode.getAttribute(svgAttrName);
    if (attrValue != null) {
      inheritableStyleResult[INHERITABLE_STYLE_ATTRIBUTES_MAP[svgAttrName]] = attrValue;
    }
  }
  for (let i = 0; i < SELF_STYLE_ATTRIBUTES_MAP_KEYS.length; i++) {
    const svgAttrName = SELF_STYLE_ATTRIBUTES_MAP_KEYS[i];
    const attrValue = xmlNode.getAttribute(svgAttrName);
    if (attrValue != null) {
      selfStyleResult[SELF_STYLE_ATTRIBUTES_MAP[svgAttrName]] = attrValue;
    }
  }
}
function makeViewBoxTransform(viewBoxRect, boundingRect) {
  const scaleX = boundingRect.width / viewBoxRect.width;
  const scaleY = boundingRect.height / viewBoxRect.height;
  const scale4 = Math.min(scaleX, scaleY);
  return {
    scale: scale4,
    x: -(viewBoxRect.x + viewBoxRect.width / 2) * scale4 + (boundingRect.x + boundingRect.width / 2),
    y: -(viewBoxRect.y + viewBoxRect.height / 2) * scale4 + (boundingRect.y + boundingRect.height / 2)
  };
}
function parseSVG(xml, opt) {
  const parser = new SVGParser();
  return parser.parse(xml, opt);
}

// src/coord/geo/GeoSVGResource.ts
var REGION_AVAILABLE_SVG_TAG_MAP = createHashMap([
  "rect",
  "circle",
  "line",
  "ellipse",
  "polygon",
  "polyline",
  "path",
  "text",
  "tspan",
  "g"
]);
var GeoSVGResource = class {
  constructor(mapName, svg) {
    this.type = "geoSVG";
    this._usedGraphicMap = createHashMap();
    this._freedGraphics = [];
    this._mapName = mapName;
    this._parsedXML = parseXML(svg);
  }
  load() {
    let firstGraphic = this._firstGraphic;
    if (!firstGraphic) {
      firstGraphic = this._firstGraphic = this._buildGraphic(this._parsedXML);
      this._freedGraphics.push(firstGraphic);
      this._boundingRect = this._firstGraphic.boundingRect.clone();
      const {regions, regionsMap} = createRegions(firstGraphic.named);
      this._regions = regions;
      this._regionsMap = regionsMap;
    }
    return {
      boundingRect: this._boundingRect,
      regions: this._regions,
      regionsMap: this._regionsMap
    };
  }
  _buildGraphic(svgXML) {
    let result;
    let rootFromParse;
    try {
      result = svgXML && parseSVG(svgXML, {
        ignoreViewBox: true,
        ignoreRootClip: true
      }) || {};
      rootFromParse = result.root;
      assert(rootFromParse != null);
    } catch (e2) {
      throw new Error("Invalid svg format\n" + e2.message);
    }
    const root = new Group_default();
    root.add(rootFromParse);
    root.isGeoSVGGraphicRoot = true;
    const svgWidth = result.width;
    const svgHeight = result.height;
    const viewBoxRect = result.viewBoxRect;
    let boundingRect = this._boundingRect;
    if (!boundingRect) {
      let bRectX;
      let bRectY;
      let bRectWidth;
      let bRectHeight;
      if (svgWidth != null) {
        bRectX = 0;
        bRectWidth = svgWidth;
      } else if (viewBoxRect) {
        bRectX = viewBoxRect.x;
        bRectWidth = viewBoxRect.width;
      }
      if (svgHeight != null) {
        bRectY = 0;
        bRectHeight = svgHeight;
      } else if (viewBoxRect) {
        bRectY = viewBoxRect.y;
        bRectHeight = viewBoxRect.height;
      }
      if (bRectX == null || bRectY == null) {
        const calculatedBoundingRect = rootFromParse.getBoundingRect();
        if (bRectX == null) {
          bRectX = calculatedBoundingRect.x;
          bRectWidth = calculatedBoundingRect.width;
        }
        if (bRectY == null) {
          bRectY = calculatedBoundingRect.y;
          bRectHeight = calculatedBoundingRect.height;
        }
      }
      boundingRect = this._boundingRect = new BoundingRect_default(bRectX, bRectY, bRectWidth, bRectHeight);
    }
    if (viewBoxRect) {
      const viewBoxTransform = makeViewBoxTransform(viewBoxRect, boundingRect);
      rootFromParse.scaleX = rootFromParse.scaleY = viewBoxTransform.scale;
      rootFromParse.x = viewBoxTransform.x;
      rootFromParse.y = viewBoxTransform.y;
    }
    root.setClipPath(new Rect_default({
      shape: boundingRect.plain()
    }));
    const named = [];
    each(result.named, (namedItem) => {
      if (REGION_AVAILABLE_SVG_TAG_MAP.get(namedItem.svgNodeTagLower) != null) {
        named.push(namedItem);
        setSilent(namedItem.el);
      }
    });
    return {root, boundingRect, named};
  }
  useGraphic(hostKey) {
    const usedRootMap = this._usedGraphicMap;
    let svgGraphic = usedRootMap.get(hostKey);
    if (svgGraphic) {
      return svgGraphic;
    }
    svgGraphic = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML);
    usedRootMap.set(hostKey, svgGraphic);
    return svgGraphic;
  }
  freeGraphic(hostKey) {
    const usedRootMap = this._usedGraphicMap;
    const svgGraphic = usedRootMap.get(hostKey);
    if (svgGraphic) {
      usedRootMap.removeKey(hostKey);
      this._freedGraphics.push(svgGraphic);
    }
  }
};
function setSilent(el) {
  el.silent = false;
  if (el.isGroup) {
    el.traverse((child) => {
      child.silent = false;
    });
  }
}
function createRegions(named) {
  const regions = [];
  const regionsMap = createHashMap();
  each(named, (namedItem) => {
    if (namedItem.namedFrom != null) {
      return;
    }
    const region = new GeoSVGRegion(namedItem.name, namedItem.el);
    regions.push(region);
    regionsMap.set(namedItem.name, region);
  });
  return {regions, regionsMap};
}

// src/coord/geo/fix/nanhai.ts
var geoCoord = [126, 25];
var nanhaiName = "\u5357\u6D77\u8BF8\u5C9B";
var points2 = [
  [
    [0, 3.5],
    [7, 11.2],
    [15, 11.9],
    [30, 7],
    [42, 0.7],
    [52, 0.7],
    [56, 7.7],
    [59, 0.7],
    [64, 0.7],
    [64, 0],
    [5, 0],
    [0, 3.5]
  ],
  [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]],
  [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]],
  [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]],
  [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]],
  [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]],
  [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]],
  [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]],
  [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]],
  [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]],
  [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]],
  [
    [0, 3.5],
    [0, 93.1],
    [64, 93.1],
    [64, 0],
    [63, 0],
    [63, 92.4],
    [1, 92.4],
    [1, 3.5],
    [0, 3.5]
  ]
];
for (let i = 0; i < points2.length; i++) {
  for (let k = 0; k < points2[i].length; k++) {
    points2[i][k][0] /= 10.5;
    points2[i][k][1] /= -10.5 / 0.75;
    points2[i][k][0] += geoCoord[0];
    points2[i][k][1] += geoCoord[1];
  }
}
function fixNanhai(mapType, regions) {
  if (mapType === "china") {
    for (let i = 0; i < regions.length; i++) {
      if (regions[i].name === nanhaiName) {
        return;
      }
    }
    regions.push(new GeoJSONRegion(nanhaiName, map(points2, function(exterior) {
      return {
        type: "polygon",
        exterior
      };
    }), geoCoord));
  }
}

// src/coord/geo/fix/textCoord.ts
var coordsOffsetMap = {
  \u5357\u6D77\u8BF8\u5C9B: [32, 80],
  \u5E7F\u4E1C: [0, -10],
  \u9999\u6E2F: [10, 5],
  \u6FB3\u95E8: [-10, 10],
  \u5929\u6D25: [5, 5]
};
function fixTextCoords(mapType, region) {
  if (mapType === "china") {
    const coordFix = coordsOffsetMap[region.name];
    if (coordFix) {
      const cp = region.getCenter();
      cp[0] += coordFix[0] / 10.5;
      cp[1] += -coordFix[1] / (10.5 / 0.75);
      region.setCenter(cp);
    }
  }
}

// src/coord/geo/fix/diaoyuIsland.ts
var points3 = [
  [
    [123.45165252685547, 25.73527164402261],
    [123.49731445312499, 25.73527164402261],
    [123.49731445312499, 25.750734064600884],
    [123.45165252685547, 25.750734064600884],
    [123.45165252685547, 25.73527164402261]
  ]
];
function fixDiaoyuIsland(mapType, region) {
  if (mapType === "china" && region.name === "\u53F0\u6E7E") {
    region.geometries.push({
      type: "polygon",
      exterior: points3[0]
    });
  }
}

// src/coord/geo/GeoJSONResource.ts
var DEFAULT_NAME_PROPERTY = "name";
var GeoJSONResource = class {
  constructor(mapName, geoJSON, specialAreas) {
    this.type = "geoJSON";
    this._parsedMap = createHashMap();
    this._mapName = mapName;
    this._specialAreas = specialAreas;
    this._geoJSON = parseInput(geoJSON);
  }
  load(nameMap, nameProperty) {
    nameProperty = nameProperty || DEFAULT_NAME_PROPERTY;
    let parsed = this._parsedMap.get(nameProperty);
    if (!parsed) {
      const rawRegions = this._parseToRegions(nameProperty);
      parsed = this._parsedMap.set(nameProperty, {
        regions: rawRegions,
        boundingRect: calculateBoundingRect(rawRegions)
      });
    }
    const regionsMap = createHashMap();
    const finalRegions = [];
    each(parsed.regions, function(region) {
      let regionName = region.name;
      if (nameMap && hasOwn(nameMap, regionName)) {
        region = region.cloneShallow(regionName = nameMap[regionName]);
      }
      finalRegions.push(region);
      regionsMap.set(regionName, region);
    });
    return {
      regions: finalRegions,
      boundingRect: parsed.boundingRect || new BoundingRect_default(0, 0, 0, 0),
      regionsMap
    };
  }
  _parseToRegions(nameProperty) {
    const mapName = this._mapName;
    const geoJSON = this._geoJSON;
    let rawRegions;
    try {
      rawRegions = geoJSON ? parseGeoJSON(geoJSON, nameProperty) : [];
    } catch (e2) {
      throw new Error("Invalid geoJson format\n" + e2.message);
    }
    fixNanhai(mapName, rawRegions);
    each(rawRegions, function(region) {
      const regionName = region.name;
      fixTextCoords(mapName, region);
      fixDiaoyuIsland(mapName, region);
      const specialArea = this._specialAreas && this._specialAreas[regionName];
      if (specialArea) {
        region.transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);
      }
    }, this);
    return rawRegions;
  }
  getMapForUser() {
    return {
      geoJson: this._geoJSON,
      geoJSON: this._geoJSON,
      specialAreas: this._specialAreas
    };
  }
};
function calculateBoundingRect(regions) {
  let rect;
  for (let i = 0; i < regions.length; i++) {
    const regionRect = regions[i].getBoundingRect();
    rect = rect || regionRect.clone();
    rect.union(regionRect);
  }
  return rect;
}
function parseInput(source) {
  return !isString(source) ? source : typeof JSON !== "undefined" && JSON.parse ? JSON.parse(source) : new Function("return (" + source + ");")();
}

// src/coord/geo/geoSourceManager.ts
var storage = createHashMap();
var geoSourceManager_default = {
  registerMap: function(mapName, rawDef, rawSpecialAreas) {
    if (rawDef.svg) {
      const resource = new GeoSVGResource(mapName, rawDef.svg);
      storage.set(mapName, resource);
    } else {
      let geoJSON = rawDef.geoJson || rawDef.geoJSON;
      if (geoJSON && !rawDef.features) {
        rawSpecialAreas = rawDef.specialAreas;
      } else {
        geoJSON = rawDef;
      }
      const resource = new GeoJSONResource(mapName, geoJSON, rawSpecialAreas);
      storage.set(mapName, resource);
    }
  },
  getGeoResource(mapName) {
    return storage.get(mapName);
  },
  getMapForUser: function(mapName) {
    const resource = storage.get(mapName);
    return resource && resource.type === "geoJSON" && resource.getMapForUser();
  },
  load: function(mapName, nameMap, nameProperty) {
    const resource = storage.get(mapName);
    if (!resource) {
      if (true) {
        console.error("Map " + mapName + " not exists. The GeoJSON of the map must be provided.");
      }
      return;
    }
    return resource.load(nameMap, nameProperty);
  }
};

// src/component/helper/MapDraw.ts
var OPTION_STYLE_ENABLED_TAGS = [
  "rect",
  "circle",
  "line",
  "ellipse",
  "polygon",
  "polyline",
  "path"
];
var OPTION_STYLE_ENABLED_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS);
var STATE_TRIGGER_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(["g"]));
var LABEL_HOST_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(["g"]));
var mapLabelRaw = makeInner();
function getFixedItemStyle(model) {
  const itemStyle = model.getItemStyle();
  const areaColor = model.get("areaColor");
  if (areaColor != null) {
    itemStyle.fill = areaColor;
  }
  return itemStyle;
}
function fixLineStyle(styleHost) {
  const style = styleHost.style;
  if (style) {
    style.stroke = style.stroke || style.fill;
    style.fill = null;
  }
}
var MapDraw = class {
  constructor(api2) {
    const group = new Group_default();
    this.uid = getUID("ec_map_draw");
    this._controller = new RoamController_default(api2.getZr());
    this._controllerHost = {target: group};
    this.group = group;
    group.add(this._regionsGroup = new Group_default());
    group.add(this._svgGroup = new Group_default());
  }
  draw(mapOrGeoModel, ecModel, api2, fromView, payload) {
    const isGeo = mapOrGeoModel.mainType === "geo";
    let data = mapOrGeoModel.getData && mapOrGeoModel.getData();
    isGeo && ecModel.eachComponent({mainType: "series", subType: "map"}, function(mapSeries) {
      if (!data && mapSeries.getHostGeoModel() === mapOrGeoModel) {
        data = mapSeries.getData();
      }
    });
    const geo = mapOrGeoModel.coordinateSystem;
    const regionsGroup = this._regionsGroup;
    const group = this.group;
    const transformInfo = geo.getTransformInfo();
    const transformInfoRaw = transformInfo.raw;
    const transformInfoRoam = transformInfo.roam;
    const isFirstDraw = !regionsGroup.childAt(0) || payload;
    if (isFirstDraw) {
      group.x = transformInfoRoam.x;
      group.y = transformInfoRoam.y;
      group.scaleX = transformInfoRoam.scaleX;
      group.scaleY = transformInfoRoam.scaleY;
      group.dirty();
    } else {
      updateProps(group, transformInfoRoam, mapOrGeoModel);
    }
    const isVisualEncodedByVisualMap = data && data.getVisual("visualMeta") && data.getVisual("visualMeta").length > 0;
    const viewBuildCtx = {
      api: api2,
      geo,
      mapOrGeoModel,
      data,
      isVisualEncodedByVisualMap,
      isGeo,
      transformInfoRaw
    };
    if (geo.resourceType === "geoJSON") {
      this._buildGeoJSON(viewBuildCtx);
    } else if (geo.resourceType === "geoSVG") {
      this._buildSVG(viewBuildCtx);
    }
    this._updateController(mapOrGeoModel, ecModel, api2);
    this._updateMapSelectHandler(mapOrGeoModel, regionsGroup, api2, fromView);
  }
  _buildGeoJSON(viewBuildCtx) {
    const regionsGroupByName = this._regionsGroupByName = createHashMap();
    const regionsInfoByName = createHashMap();
    const regionsGroup = this._regionsGroup;
    const transformInfoRaw = viewBuildCtx.transformInfoRaw;
    const mapOrGeoModel = viewBuildCtx.mapOrGeoModel;
    const data = viewBuildCtx.data;
    const projection = viewBuildCtx.geo.projection;
    const projectionStream = projection && projection.stream;
    function transformPoint(point, project) {
      if (project) {
        point = project(point);
      }
      return point && [
        point[0] * transformInfoRaw.scaleX + transformInfoRaw.x,
        point[1] * transformInfoRaw.scaleY + transformInfoRaw.y
      ];
    }
    ;
    function transformPolygonPoints(inPoints) {
      const outPoints = [];
      const project = !projectionStream && projection && projection.project;
      for (let i = 0; i < inPoints.length; ++i) {
        const newPt = transformPoint(inPoints[i], project);
        newPt && outPoints.push(newPt);
      }
      return outPoints;
    }
    function getPolyShape(points4) {
      return {
        shape: {
          points: transformPolygonPoints(points4)
        }
      };
    }
    regionsGroup.removeAll();
    each(viewBuildCtx.geo.regions, function(region) {
      const regionName = region.name;
      let regionGroup = regionsGroupByName.get(regionName);
      let {dataIdx, regionModel} = regionsInfoByName.get(regionName) || {};
      if (!regionGroup) {
        regionGroup = regionsGroupByName.set(regionName, new Group_default());
        regionsGroup.add(regionGroup);
        dataIdx = data ? data.indexOfName(regionName) : null;
        regionModel = viewBuildCtx.isGeo ? mapOrGeoModel.getRegionModel(regionName) : data ? data.getItemModel(dataIdx) : null;
        regionsInfoByName.set(regionName, {dataIdx, regionModel});
      }
      const polygonSubpaths = [];
      const polylineSubpaths = [];
      each(region.geometries, function(geometry) {
        if (geometry.type === "polygon") {
          let polys = [geometry.exterior].concat(geometry.interiors || []);
          if (projectionStream) {
            polys = projectPolys(polys, projectionStream);
          }
          each(polys, (poly) => {
            polygonSubpaths.push(new Polygon_default(getPolyShape(poly)));
          });
        } else {
          let points4 = geometry.points;
          if (projectionStream) {
            points4 = projectPolys(points4, projectionStream, true);
          }
          each(points4, (points5) => {
            polylineSubpaths.push(new Polyline_default(getPolyShape(points5)));
          });
        }
      });
      const centerPt = transformPoint(region.getCenter(), projection && projection.project);
      function createCompoundPath(subpaths, isLine) {
        if (!subpaths.length) {
          return;
        }
        const compoundPath = new CompoundPath_default({
          culling: true,
          segmentIgnoreThreshold: 1,
          shape: {
            paths: subpaths
          }
        });
        regionGroup.add(compoundPath);
        applyOptionStyleForRegion(viewBuildCtx, compoundPath, dataIdx, regionModel);
        resetLabelForRegion(viewBuildCtx, compoundPath, regionName, regionModel, mapOrGeoModel, dataIdx, centerPt);
        if (isLine) {
          fixLineStyle(compoundPath);
          each(compoundPath.states, fixLineStyle);
        }
      }
      createCompoundPath(polygonSubpaths);
      createCompoundPath(polylineSubpaths, true);
    });
    regionsGroupByName.each(function(regionGroup, regionName) {
      const {dataIdx, regionModel} = regionsInfoByName.get(regionName);
      resetEventTriggerForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel, dataIdx);
      resetTooltipForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel);
      resetStateTriggerForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel);
    }, this);
  }
  _buildSVG(viewBuildCtx) {
    const mapName = viewBuildCtx.geo.map;
    const transformInfoRaw = viewBuildCtx.transformInfoRaw;
    this._svgGroup.x = transformInfoRaw.x;
    this._svgGroup.y = transformInfoRaw.y;
    this._svgGroup.scaleX = transformInfoRaw.scaleX;
    this._svgGroup.scaleY = transformInfoRaw.scaleY;
    if (this._svgResourceChanged(mapName)) {
      this._freeSVG();
      this._useSVG(mapName);
    }
    const svgDispatcherMap = this._svgDispatcherMap = createHashMap();
    let focusSelf = false;
    each(this._svgGraphicRecord.named, function(namedItem) {
      const regionName = namedItem.name;
      const mapOrGeoModel = viewBuildCtx.mapOrGeoModel;
      const data = viewBuildCtx.data;
      const svgNodeTagLower = namedItem.svgNodeTagLower;
      const el = namedItem.el;
      const dataIdx = data ? data.indexOfName(regionName) : null;
      const regionModel = mapOrGeoModel.getRegionModel(regionName);
      if (OPTION_STYLE_ENABLED_TAG_MAP.get(svgNodeTagLower) != null && el instanceof Displayable_default) {
        applyOptionStyleForRegion(viewBuildCtx, el, dataIdx, regionModel);
      }
      if (el instanceof Displayable_default) {
        el.culling = true;
      }
      el.z2EmphasisLift = 0;
      if (!namedItem.namedFrom) {
        if (LABEL_HOST_MAP.get(svgNodeTagLower) != null) {
          resetLabelForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx, null);
        }
        resetEventTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx);
        resetTooltipForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel);
        if (STATE_TRIGGER_TAG_MAP.get(svgNodeTagLower) != null) {
          const focus = resetStateTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel);
          if (focus === "self") {
            focusSelf = true;
          }
          const els = svgDispatcherMap.get(regionName) || svgDispatcherMap.set(regionName, []);
          els.push(el);
        }
      }
    }, this);
    this._enableBlurEntireSVG(focusSelf, viewBuildCtx);
  }
  _enableBlurEntireSVG(focusSelf, viewBuildCtx) {
    if (focusSelf && viewBuildCtx.isGeo) {
      const blurStyle = viewBuildCtx.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle();
      const opacity = blurStyle.opacity;
      this._svgGraphicRecord.root.traverse((el) => {
        if (!el.isGroup) {
          setDefaultStateProxy(el);
          const style = el.ensureState("blur").style || {};
          if (style.opacity == null && opacity != null) {
            style.opacity = opacity;
          }
          el.ensureState("emphasis");
        }
      });
    }
  }
  remove() {
    this._regionsGroup.removeAll();
    this._regionsGroupByName = null;
    this._svgGroup.removeAll();
    this._freeSVG();
    this._controller.dispose();
    this._controllerHost = null;
  }
  findHighDownDispatchers(name, geoModel) {
    if (name == null) {
      return [];
    }
    const geo = geoModel.coordinateSystem;
    if (geo.resourceType === "geoJSON") {
      const regionsGroupByName = this._regionsGroupByName;
      if (regionsGroupByName) {
        const regionGroup = regionsGroupByName.get(name);
        return regionGroup ? [regionGroup] : [];
      }
    } else if (geo.resourceType === "geoSVG") {
      return this._svgDispatcherMap && this._svgDispatcherMap.get(name) || [];
    }
  }
  _svgResourceChanged(mapName) {
    return this._svgMapName !== mapName;
  }
  _useSVG(mapName) {
    const resource = geoSourceManager_default.getGeoResource(mapName);
    if (resource && resource.type === "geoSVG") {
      const svgGraphic = resource.useGraphic(this.uid);
      this._svgGroup.add(svgGraphic.root);
      this._svgGraphicRecord = svgGraphic;
      this._svgMapName = mapName;
    }
  }
  _freeSVG() {
    const mapName = this._svgMapName;
    if (mapName == null) {
      return;
    }
    const resource = geoSourceManager_default.getGeoResource(mapName);
    if (resource && resource.type === "geoSVG") {
      resource.freeGraphic(this.uid);
    }
    this._svgGraphicRecord = null;
    this._svgDispatcherMap = null;
    this._svgGroup.removeAll();
    this._svgMapName = null;
  }
  _updateController(mapOrGeoModel, ecModel, api2) {
    const geo = mapOrGeoModel.coordinateSystem;
    const controller = this._controller;
    const controllerHost = this._controllerHost;
    controllerHost.zoomLimit = mapOrGeoModel.get("scaleLimit");
    controllerHost.zoom = geo.getZoom();
    controller.enable(mapOrGeoModel.get("roam") || false);
    const mainType = mapOrGeoModel.mainType;
    function makeActionBase() {
      const action = {
        type: "geoRoam",
        componentType: mainType
      };
      action[mainType + "Id"] = mapOrGeoModel.id;
      return action;
    }
    controller.off("pan").on("pan", function(e2) {
      this._mouseDownFlag = false;
      updateViewOnPan(controllerHost, e2.dx, e2.dy);
      api2.dispatchAction(extend(makeActionBase(), {
        dx: e2.dx,
        dy: e2.dy,
        animation: {
          duration: 0
        }
      }));
    }, this);
    controller.off("zoom").on("zoom", function(e2) {
      this._mouseDownFlag = false;
      updateViewOnZoom(controllerHost, e2.scale, e2.originX, e2.originY);
      api2.dispatchAction(extend(makeActionBase(), {
        totalZoom: controllerHost.zoom,
        zoom: e2.scale,
        originX: e2.originX,
        originY: e2.originY,
        animation: {
          duration: 0
        }
      }));
    }, this);
    controller.setPointerChecker(function(e2, x, y) {
      return geo.containPoint([x, y]) && !onIrrelevantElement(e2, api2, mapOrGeoModel);
    });
  }
  resetForLabelLayout() {
    this.group.traverse((el) => {
      const label = el.getTextContent();
      if (label) {
        label.ignore = mapLabelRaw(label).ignore;
      }
    });
  }
  _updateMapSelectHandler(mapOrGeoModel, regionsGroup, api2, fromView) {
    const mapDraw = this;
    regionsGroup.off("mousedown");
    regionsGroup.off("click");
    if (mapOrGeoModel.get("selectedMode")) {
      regionsGroup.on("mousedown", function() {
        mapDraw._mouseDownFlag = true;
      });
      regionsGroup.on("click", function(e2) {
        if (!mapDraw._mouseDownFlag) {
          return;
        }
        mapDraw._mouseDownFlag = false;
      });
    }
  }
};
function applyOptionStyleForRegion(viewBuildCtx, el, dataIndex, regionModel) {
  const normalStyleModel = regionModel.getModel("itemStyle");
  const emphasisStyleModel = regionModel.getModel(["emphasis", "itemStyle"]);
  const blurStyleModel = regionModel.getModel(["blur", "itemStyle"]);
  const selectStyleModel = regionModel.getModel(["select", "itemStyle"]);
  const normalStyle = getFixedItemStyle(normalStyleModel);
  const emphasisStyle = getFixedItemStyle(emphasisStyleModel);
  const selectStyle = getFixedItemStyle(selectStyleModel);
  const blurStyle = getFixedItemStyle(blurStyleModel);
  const data = viewBuildCtx.data;
  if (data) {
    const style = data.getItemVisual(dataIndex, "style");
    const decal = data.getItemVisual(dataIndex, "decal");
    if (viewBuildCtx.isVisualEncodedByVisualMap && style.fill) {
      normalStyle.fill = style.fill;
    }
    if (decal) {
      normalStyle.decal = createOrUpdatePatternFromDecal(decal, viewBuildCtx.api);
    }
  }
  el.setStyle(normalStyle);
  el.style.strokeNoScale = true;
  el.ensureState("emphasis").style = emphasisStyle;
  el.ensureState("select").style = selectStyle;
  el.ensureState("blur").style = blurStyle;
  setDefaultStateProxy(el);
}
function resetLabelForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx, labelXY) {
  const data = viewBuildCtx.data;
  const isGeo = viewBuildCtx.isGeo;
  const isDataNaN = data && isNaN(data.get(data.mapDimension("value"), dataIdx));
  const itemLayout = data && data.getItemLayout(dataIdx);
  if (isGeo || isDataNaN || itemLayout && itemLayout.showLabel) {
    const query = !isGeo ? dataIdx : regionName;
    let labelFetcher;
    if (!data || dataIdx >= 0) {
      labelFetcher = mapOrGeoModel;
    }
    const specifiedTextOpt = labelXY ? {
      normal: {
        align: "center",
        verticalAlign: "middle"
      }
    } : null;
    setLabelStyle(el, getLabelStatesModels(regionModel), {
      labelFetcher,
      labelDataIndex: query,
      defaultText: regionName
    }, specifiedTextOpt);
    const textEl = el.getTextContent();
    if (textEl) {
      mapLabelRaw(textEl).ignore = textEl.ignore;
      if (el.textConfig && labelXY) {
        const rect = el.getBoundingRect().clone();
        el.textConfig.layoutRect = rect;
        el.textConfig.position = [
          (labelXY[0] - rect.x) / rect.width * 100 + "%",
          (labelXY[1] - rect.y) / rect.height * 100 + "%"
        ];
      }
    }
    el.disableLabelAnimation = true;
  } else {
    el.removeTextContent();
    el.removeTextConfig();
    el.disableLabelAnimation = null;
  }
}
function resetEventTriggerForRegion(viewBuildCtx, eventTrigger, regionName, regionModel, mapOrGeoModel, dataIdx) {
  if (viewBuildCtx.data) {
    viewBuildCtx.data.setItemGraphicEl(dataIdx, eventTrigger);
  } else {
    getECData(eventTrigger).eventData = {
      componentType: "geo",
      componentIndex: mapOrGeoModel.componentIndex,
      geoIndex: mapOrGeoModel.componentIndex,
      name: regionName,
      region: regionModel && regionModel.option || {}
    };
  }
}
function resetTooltipForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel) {
  if (!viewBuildCtx.data) {
    setTooltipConfig({
      el,
      componentModel: mapOrGeoModel,
      itemName: regionName,
      itemTooltipOption: regionModel.get("tooltip")
    });
  }
}
function resetStateTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel) {
  el.highDownSilentOnTouch = !!mapOrGeoModel.get("selectedMode");
  const emphasisModel = regionModel.getModel("emphasis");
  const focus = emphasisModel.get("focus");
  toggleHoverEmphasis(el, focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  if (viewBuildCtx.isGeo) {
    enableComponentHighDownFeatures(el, mapOrGeoModel, regionName);
  }
  return focus;
}
function projectPolys(rings, createStream, isLine) {
  const polygons = [];
  let curPoly;
  function startPolygon() {
    curPoly = [];
  }
  function endPolygon() {
    if (curPoly.length) {
      polygons.push(curPoly);
      curPoly = [];
    }
  }
  const stream = createStream({
    polygonStart: startPolygon,
    polygonEnd: endPolygon,
    lineStart: startPolygon,
    lineEnd: endPolygon,
    point(x, y) {
      if (isFinite(x) && isFinite(y)) {
        curPoly.push([x, y]);
      }
    },
    sphere() {
    }
  });
  !isLine && stream.polygonStart();
  each(rings, (ring) => {
    stream.lineStart();
    for (let i = 0; i < ring.length; i++) {
      stream.point(ring[i][0], ring[i][1]);
    }
    stream.lineEnd();
  });
  !isLine && stream.polygonEnd();
  return polygons;
}
var MapDraw_default = MapDraw;

// src/chart/map/MapView.ts
var MapView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = MapView2.type;
  }
  render(mapModel, ecModel, api2, payload) {
    if (payload && payload.type === "mapToggleSelect" && payload.from === this.uid) {
      return;
    }
    const group = this.group;
    group.removeAll();
    if (mapModel.getHostGeoModel()) {
      return;
    }
    if (this._mapDraw && payload && payload.type === "geoRoam") {
      this._mapDraw.resetForLabelLayout();
    }
    if (!(payload && payload.type === "geoRoam" && payload.componentType === "series" && payload.seriesId === mapModel.id)) {
      if (mapModel.needsDrawMap) {
        const mapDraw = this._mapDraw || new MapDraw_default(api2);
        group.add(mapDraw.group);
        mapDraw.draw(mapModel, ecModel, api2, this, payload);
        this._mapDraw = mapDraw;
      } else {
        this._mapDraw && this._mapDraw.remove();
        this._mapDraw = null;
      }
    } else {
      const mapDraw = this._mapDraw;
      mapDraw && group.add(mapDraw.group);
    }
    mapModel.get("showLegendSymbol") && ecModel.getComponent("legend") && this._renderSymbols(mapModel, ecModel, api2);
  }
  remove() {
    this._mapDraw && this._mapDraw.remove();
    this._mapDraw = null;
    this.group.removeAll();
  }
  dispose() {
    this._mapDraw && this._mapDraw.remove();
    this._mapDraw = null;
  }
  _renderSymbols(mapModel, ecModel, api2) {
    const originalData = mapModel.originalData;
    const group = this.group;
    originalData.each(originalData.mapDimension("value"), function(value, originalDataIndex) {
      if (isNaN(value)) {
        return;
      }
      const layout18 = originalData.getItemLayout(originalDataIndex);
      if (!layout18 || !layout18.point) {
        return;
      }
      const point = layout18.point;
      const offset = layout18.offset;
      const circle = new Circle_default({
        style: {
          fill: mapModel.getData().getVisual("style").fill
        },
        shape: {
          cx: point[0] + offset * 9,
          cy: point[1],
          r: 3
        },
        silent: true,
        z2: 8 + (!offset ? Z2_EMPHASIS_LIFT + 1 : 0)
      });
      if (!offset) {
        const fullData = mapModel.mainSeries.getData();
        const name = originalData.getName(originalDataIndex);
        const fullIndex = fullData.indexOfName(name);
        const itemModel = originalData.getItemModel(originalDataIndex);
        const labelModel = itemModel.getModel("label");
        const regionGroup = fullData.getItemGraphicEl(fullIndex);
        setLabelStyle(circle, getLabelStatesModels(itemModel), {
          labelFetcher: {
            getFormattedLabel(idx, state) {
              return mapModel.getFormattedLabel(fullIndex, state);
            }
          },
          defaultText: name
        });
        circle.disableLabelAnimation = true;
        if (!labelModel.get("position")) {
          circle.setTextConfig({
            position: "bottom"
          });
        }
        regionGroup.onHoverStateChange = function(toState) {
          setStatesFlag(circle, toState);
        };
      }
      group.add(circle);
    });
  }
};
var MapView = MapView2;
MapView.type = "map";
var MapView_default = MapView;

// src/chart/map/MapSeries.ts
var MapSeries2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = MapSeries2.type;
    this.needsDrawMap = false;
    this.seriesGroup = [];
    this.getTooltipPosition = function(dataIndex) {
      if (dataIndex != null) {
        const name = this.getData().getName(dataIndex);
        const geo = this.coordinateSystem;
        const region = geo.getRegion(name);
        return region && geo.dataToPoint(region.getCenter());
      }
    };
  }
  getInitialData(option) {
    const data = createSeriesDataSimply(this, {
      coordDimensions: ["value"],
      encodeDefaulter: curry(makeSeriesEncodeForNameBased, this)
    });
    const dataNameMap = createHashMap();
    const toAppendNames = [];
    for (let i = 0, len2 = data.count(); i < len2; i++) {
      const name = data.getName(i);
      dataNameMap.set(name, true);
    }
    const geoSource = geoSourceManager_default.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
    each(geoSource.regions, function(region) {
      const name = region.name;
      if (!dataNameMap.get(name)) {
        toAppendNames.push(name);
      }
    });
    data.appendValues([], toAppendNames);
    return data;
  }
  getHostGeoModel() {
    const geoIndex = this.option.geoIndex;
    return geoIndex != null ? this.ecModel.getComponent("geo", geoIndex) : null;
  }
  getMapType() {
    return (this.getHostGeoModel() || this).option.map;
  }
  getRawValue(dataIndex) {
    const data = this.getData();
    return data.get(data.mapDimension("value"), dataIndex);
  }
  getRegionModel(regionName) {
    const data = this.getData();
    return data.getItemModel(data.indexOfName(regionName));
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    const data = this.getData();
    const value = this.getRawValue(dataIndex);
    const name = data.getName(dataIndex);
    const seriesGroup = this.seriesGroup;
    const seriesNames = [];
    for (let i = 0; i < seriesGroup.length; i++) {
      const otherIndex = seriesGroup[i].originalData.indexOfName(name);
      const valueDim = data.mapDimension("value");
      if (!isNaN(seriesGroup[i].originalData.get(valueDim, otherIndex))) {
        seriesNames.push(seriesGroup[i].name);
      }
    }
    return createTooltipMarkup("section", {
      header: seriesNames.join(", "),
      noHeader: !seriesNames.length,
      blocks: [createTooltipMarkup("nameValue", {
        name,
        value
      })]
    });
  }
  setZoom(zoom) {
    this.option.zoom = zoom;
  }
  setCenter(center3) {
    this.option.center = center3;
  }
  getLegendIcon(opt) {
    const iconType = opt.icon || "roundRect";
    const icon = createSymbol(iconType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill);
    icon.setStyle(opt.itemStyle);
    icon.style.stroke = "none";
    if (iconType.indexOf("empty") > -1) {
      icon.style.stroke = icon.style.fill;
      icon.style.fill = "#fff";
      icon.style.lineWidth = 2;
    }
    return icon;
  }
};
var MapSeries = MapSeries2;
MapSeries.type = "series.map";
MapSeries.dependencies = ["geo"];
MapSeries.layoutMode = "box";
MapSeries.defaultOption = {
  z: 2,
  coordinateSystem: "geo",
  map: "",
  left: "center",
  top: "center",
  aspectScale: null,
  showLegendSymbol: true,
  boundingCoords: null,
  center: null,
  zoom: 1,
  scaleLimit: null,
  selectedMode: true,
  label: {
    show: false,
    color: "#000"
  },
  itemStyle: {
    borderWidth: 0.5,
    borderColor: "#444",
    areaColor: "#eee"
  },
  emphasis: {
    label: {
      show: true,
      color: "rgb(100,0,0)"
    },
    itemStyle: {
      areaColor: "rgba(255,215,0,0.8)"
    }
  },
  select: {
    label: {
      show: true,
      color: "rgb(100,0,0)"
    },
    itemStyle: {
      color: "rgba(255,215,0,0.8)"
    }
  },
  nameProperty: "name"
};
var MapSeries_default = MapSeries;

// src/chart/map/mapDataStatistic.ts
function dataStatistics(datas, statisticType) {
  const dataNameMap = {};
  each(datas, function(data) {
    data.each(data.mapDimension("value"), function(value, idx) {
      const mapKey = "ec-" + data.getName(idx);
      dataNameMap[mapKey] = dataNameMap[mapKey] || [];
      if (!isNaN(value)) {
        dataNameMap[mapKey].push(value);
      }
    });
  });
  return datas[0].map(datas[0].mapDimension("value"), function(value, idx) {
    const mapKey = "ec-" + datas[0].getName(idx);
    let sum2 = 0;
    let min3 = Infinity;
    let max3 = -Infinity;
    const len2 = dataNameMap[mapKey].length;
    for (let i = 0; i < len2; i++) {
      min3 = Math.min(min3, dataNameMap[mapKey][i]);
      max3 = Math.max(max3, dataNameMap[mapKey][i]);
      sum2 += dataNameMap[mapKey][i];
    }
    let result;
    if (statisticType === "min") {
      result = min3;
    } else if (statisticType === "max") {
      result = max3;
    } else if (statisticType === "average") {
      result = sum2 / len2;
    } else {
      result = sum2;
    }
    return len2 === 0 ? NaN : result;
  });
}
function mapDataStatistic(ecModel) {
  const seriesGroups = {};
  ecModel.eachSeriesByType("map", function(seriesModel) {
    const hostGeoModel = seriesModel.getHostGeoModel();
    const key = hostGeoModel ? "o" + hostGeoModel.id : "i" + seriesModel.getMapType();
    (seriesGroups[key] = seriesGroups[key] || []).push(seriesModel);
  });
  each(seriesGroups, function(seriesList, key) {
    const data = dataStatistics(map(seriesList, function(seriesModel) {
      return seriesModel.getData();
    }), seriesList[0].get("mapValueCalculation"));
    for (let i = 0; i < seriesList.length; i++) {
      seriesList[i].originalData = seriesList[i].getData();
    }
    for (let i = 0; i < seriesList.length; i++) {
      seriesList[i].seriesGroup = seriesList;
      seriesList[i].needsDrawMap = i === 0 && !seriesList[i].getHostGeoModel();
      seriesList[i].setData(data.cloneShallow());
      seriesList[i].mainSeries = seriesList[0];
    }
  });
}

// src/chart/map/mapSymbolLayout.ts
function mapSymbolLayout(ecModel) {
  const processedMapType = {};
  ecModel.eachSeriesByType("map", function(mapSeries) {
    const mapType = mapSeries.getMapType();
    if (mapSeries.getHostGeoModel() || processedMapType[mapType]) {
      return;
    }
    const mapSymbolOffsets = {};
    each(mapSeries.seriesGroup, function(subMapSeries) {
      const geo = subMapSeries.coordinateSystem;
      const data2 = subMapSeries.originalData;
      if (subMapSeries.get("showLegendSymbol") && ecModel.getComponent("legend")) {
        data2.each(data2.mapDimension("value"), function(value, idx) {
          const name = data2.getName(idx);
          const region = geo.getRegion(name);
          if (!region || isNaN(value)) {
            return;
          }
          const offset = mapSymbolOffsets[name] || 0;
          const point = geo.dataToPoint(region.getCenter());
          mapSymbolOffsets[name] = offset + 1;
          data2.setItemLayout(idx, {
            point,
            offset
          });
        });
      }
    });
    const data = mapSeries.getData();
    data.each(function(idx) {
      const name = data.getName(idx);
      const layout18 = data.getItemLayout(idx) || {};
      layout18.showLabel = !mapSymbolOffsets[name];
      data.setItemLayout(idx, layout18);
    });
    processedMapType[mapType] = true;
  });
}

// src/coord/View.ts
var v2ApplyTransform = applyTransform;
var View = class extends Transformable_default {
  constructor(name) {
    super();
    this.type = "view";
    this.dimensions = ["x", "y"];
    this._roamTransformable = new Transformable_default();
    this._rawTransformable = new Transformable_default();
    this.name = name;
  }
  setBoundingRect(x, y, width, height) {
    this._rect = new BoundingRect_default(x, y, width, height);
    return this._rect;
  }
  getBoundingRect() {
    return this._rect;
  }
  setViewRect(x, y, width, height) {
    this._transformTo(x, y, width, height);
    this._viewRect = new BoundingRect_default(x, y, width, height);
  }
  _transformTo(x, y, width, height) {
    const rect = this.getBoundingRect();
    const rawTransform = this._rawTransformable;
    rawTransform.transform = rect.calculateTransform(new BoundingRect_default(x, y, width, height));
    const rawParent = rawTransform.parent;
    rawTransform.parent = null;
    rawTransform.decomposeTransform();
    rawTransform.parent = rawParent;
    this._updateTransform();
  }
  setCenter(centerCoord, api2) {
    if (!centerCoord) {
      return;
    }
    this._center = [
      parsePercent2(centerCoord[0], api2.getWidth()),
      parsePercent2(centerCoord[1], api2.getHeight())
    ];
    this._updateCenterAndZoom();
  }
  setZoom(zoom) {
    zoom = zoom || 1;
    const zoomLimit = this.zoomLimit;
    if (zoomLimit) {
      if (zoomLimit.max != null) {
        zoom = Math.min(zoomLimit.max, zoom);
      }
      if (zoomLimit.min != null) {
        zoom = Math.max(zoomLimit.min, zoom);
      }
    }
    this._zoom = zoom;
    this._updateCenterAndZoom();
  }
  getDefaultCenter() {
    const rawRect = this.getBoundingRect();
    const cx = rawRect.x + rawRect.width / 2;
    const cy = rawRect.y + rawRect.height / 2;
    return [cx, cy];
  }
  getCenter() {
    return this._center || this.getDefaultCenter();
  }
  getZoom() {
    return this._zoom || 1;
  }
  getRoamTransform() {
    return this._roamTransformable.getLocalTransform();
  }
  _updateCenterAndZoom() {
    const rawTransformMatrix = this._rawTransformable.getLocalTransform();
    const roamTransform = this._roamTransformable;
    let defaultCenter = this.getDefaultCenter();
    let center3 = this.getCenter();
    const zoom = this.getZoom();
    center3 = applyTransform([], center3, rawTransformMatrix);
    defaultCenter = applyTransform([], defaultCenter, rawTransformMatrix);
    roamTransform.originX = center3[0];
    roamTransform.originY = center3[1];
    roamTransform.x = defaultCenter[0] - center3[0];
    roamTransform.y = defaultCenter[1] - center3[1];
    roamTransform.scaleX = roamTransform.scaleY = zoom;
    this._updateTransform();
  }
  _updateTransform() {
    const roamTransformable = this._roamTransformable;
    const rawTransformable = this._rawTransformable;
    rawTransformable.parent = roamTransformable;
    roamTransformable.updateTransform();
    rawTransformable.updateTransform();
    copy2(this.transform || (this.transform = []), rawTransformable.transform || create2());
    this._rawTransform = rawTransformable.getLocalTransform();
    this.invTransform = this.invTransform || [];
    invert(this.invTransform, this.transform);
    this.decomposeTransform();
  }
  getTransformInfo() {
    const rawTransformable = this._rawTransformable;
    const roamTransformable = this._roamTransformable;
    const dummyTransformable2 = new Transformable_default();
    dummyTransformable2.transform = roamTransformable.transform;
    dummyTransformable2.decomposeTransform();
    return {
      roam: {
        x: dummyTransformable2.x,
        y: dummyTransformable2.y,
        scaleX: dummyTransformable2.scaleX,
        scaleY: dummyTransformable2.scaleY
      },
      raw: {
        x: rawTransformable.x,
        y: rawTransformable.y,
        scaleX: rawTransformable.scaleX,
        scaleY: rawTransformable.scaleY
      }
    };
  }
  getViewRect() {
    return this._viewRect;
  }
  getViewRectAfterRoam() {
    const rect = this.getBoundingRect().clone();
    rect.applyTransform(this.transform);
    return rect;
  }
  dataToPoint(data, noRoam, out2) {
    const transform2 = noRoam ? this._rawTransform : this.transform;
    out2 = out2 || [];
    return transform2 ? v2ApplyTransform(out2, data, transform2) : copy(out2, data);
  }
  pointToData(point) {
    const invTransform = this.invTransform;
    return invTransform ? v2ApplyTransform([], point, invTransform) : [point[0], point[1]];
  }
  convertToPixel(ecModel, finder, value) {
    const coordSys = getCoordSys(finder);
    return coordSys === this ? coordSys.dataToPoint(value) : null;
  }
  convertFromPixel(ecModel, finder, pixel) {
    const coordSys = getCoordSys(finder);
    return coordSys === this ? coordSys.pointToData(pixel) : null;
  }
  containPoint(point) {
    return this.getViewRectAfterRoam().contain(point[0], point[1]);
  }
};
View.dimensions = ["x", "y"];
function getCoordSys(finder) {
  const seriesModel = finder.seriesModel;
  return seriesModel ? seriesModel.coordinateSystem : null;
}
var View_default = View;

// src/coord/geo/Geo.ts
var GEO_DEFAULT_PARAMS = {
  geoJSON: {
    aspectScale: 0.75,
    invertLongitute: true
  },
  geoSVG: {
    aspectScale: 1,
    invertLongitute: false
  }
};
var geo2DDimensions = ["lng", "lat"];
var Geo = class extends View_default {
  constructor(name, map3, opt) {
    super(name);
    this.dimensions = geo2DDimensions;
    this.type = "geo";
    this._nameCoordMap = createHashMap();
    this.map = map3;
    let projection = opt.projection;
    const source = geoSourceManager_default.load(map3, opt.nameMap, opt.nameProperty);
    const resource = geoSourceManager_default.getGeoResource(map3);
    const resourceType = this.resourceType = resource ? resource.type : null;
    const regions = this.regions = source.regions;
    const defaultParams = GEO_DEFAULT_PARAMS[resource.type];
    this._regionsMap = source.regionsMap;
    this.regions = source.regions;
    if (projection) {
      if (resourceType === "geoSVG") {
        if (true) {
          warn(`Map ${map3} with SVG source can't use projection. Only GeoJSON source supports projection.`);
        }
        projection = null;
      }
      if (!(projection.project && projection.unproject)) {
        if (true) {
          warn("project and unproject must be both provided in the projeciton.");
        }
        projection = null;
      }
    }
    this.projection = projection;
    let boundingRect;
    if (projection) {
      for (let i = 0; i < regions.length; i++) {
        const regionRect = regions[i].getBoundingRect(projection);
        boundingRect = boundingRect || regionRect.clone();
        boundingRect.union(regionRect);
      }
    } else {
      boundingRect = source.boundingRect;
    }
    this.setBoundingRect(boundingRect.x, boundingRect.y, boundingRect.width, boundingRect.height);
    this.aspectScale = projection ? 1 : retrieve2(opt.aspectScale, defaultParams.aspectScale);
    this._invertLongitute = projection ? false : defaultParams.invertLongitute;
  }
  _transformTo(x, y, width, height) {
    let rect = this.getBoundingRect();
    const invertLongitute = this._invertLongitute;
    rect = rect.clone();
    if (invertLongitute) {
      rect.y = -rect.y - rect.height;
    }
    const rawTransformable = this._rawTransformable;
    rawTransformable.transform = rect.calculateTransform(new BoundingRect_default(x, y, width, height));
    const rawParent = rawTransformable.parent;
    rawTransformable.parent = null;
    rawTransformable.decomposeTransform();
    rawTransformable.parent = rawParent;
    if (invertLongitute) {
      rawTransformable.scaleY = -rawTransformable.scaleY;
    }
    this._updateTransform();
  }
  getRegion(name) {
    return this._regionsMap.get(name);
  }
  getRegionByCoord(coord) {
    const regions = this.regions;
    for (let i = 0; i < regions.length; i++) {
      const region = regions[i];
      if (region.type === "geoJSON" && region.contain(coord)) {
        return regions[i];
      }
    }
  }
  addGeoCoord(name, geoCoord2) {
    this._nameCoordMap.set(name, geoCoord2);
  }
  getGeoCoord(name) {
    const region = this._regionsMap.get(name);
    return this._nameCoordMap.get(name) || region && region.getCenter();
  }
  dataToPoint(data, noRoam, out2) {
    if (isString(data)) {
      data = this.getGeoCoord(data);
    }
    if (data) {
      const projection = this.projection;
      if (projection) {
        data = projection.project(data);
      }
      return data && this.projectedToPoint(data, noRoam, out2);
    }
  }
  pointToData(point) {
    const projection = this.projection;
    if (projection) {
      point = projection.unproject(point);
    }
    return point && this.pointToProjected(point);
  }
  pointToProjected(point) {
    return super.pointToData(point);
  }
  projectedToPoint(projected, noRoam, out2) {
    return super.dataToPoint(projected, noRoam, out2);
  }
  convertToPixel(ecModel, finder, value) {
    const coordSys = getCoordSys2(finder);
    return coordSys === this ? coordSys.dataToPoint(value) : null;
  }
  convertFromPixel(ecModel, finder, pixel) {
    const coordSys = getCoordSys2(finder);
    return coordSys === this ? coordSys.pointToData(pixel) : null;
  }
};
mixin(Geo, View_default);
function getCoordSys2(finder) {
  const geoModel = finder.geoModel;
  const seriesModel = finder.seriesModel;
  return geoModel ? geoModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem || (seriesModel.getReferringComponents("geo", SINGLE_REFERRING).models[0] || {}).coordinateSystem : null;
}
var Geo_default = Geo;

// src/coord/geo/geoCreator.ts
function resizeGeo(geoModel, api2) {
  const boundingCoords = geoModel.get("boundingCoords");
  if (boundingCoords != null) {
    let leftTop = boundingCoords[0];
    let rightBottom = boundingCoords[1];
    if (!(isFinite(leftTop[0]) && isFinite(leftTop[1]) && isFinite(rightBottom[0]) && isFinite(rightBottom[1]))) {
      if (true) {
        console.error("Invalid boundingCoords");
      }
    } else {
      const projection = this.projection;
      if (projection) {
        const xMin = leftTop[0];
        const yMin = leftTop[1];
        const xMax = rightBottom[0];
        const yMax = rightBottom[1];
        leftTop = [Infinity, Infinity];
        rightBottom = [-Infinity, -Infinity];
        const sampleLine = (x0, y0, x1, y1) => {
          const dx = x1 - x0;
          const dy = y1 - y0;
          for (let i = 0; i <= 100; i++) {
            const p = i / 100;
            const pt = projection.project([x0 + dx * p, y0 + dy * p]);
            min(leftTop, leftTop, pt);
            max(rightBottom, rightBottom, pt);
          }
        };
        sampleLine(xMin, yMin, xMax, yMin);
        sampleLine(xMax, yMin, xMax, yMax);
        sampleLine(xMax, yMax, xMin, yMax);
        sampleLine(xMin, yMax, xMax, yMin);
      }
      this.setBoundingRect(leftTop[0], leftTop[1], rightBottom[0] - leftTop[0], rightBottom[1] - leftTop[1]);
    }
  }
  const rect = this.getBoundingRect();
  const centerOption = geoModel.get("layoutCenter");
  const sizeOption = geoModel.get("layoutSize");
  const viewWidth = api2.getWidth();
  const viewHeight = api2.getHeight();
  const aspect = rect.width / rect.height * this.aspectScale;
  let useCenterAndSize = false;
  let center3;
  let size;
  if (centerOption && sizeOption) {
    center3 = [
      parsePercent2(centerOption[0], viewWidth),
      parsePercent2(centerOption[1], viewHeight)
    ];
    size = parsePercent2(sizeOption, Math.min(viewWidth, viewHeight));
    if (!isNaN(center3[0]) && !isNaN(center3[1]) && !isNaN(size)) {
      useCenterAndSize = true;
    } else {
      if (true) {
        console.warn("Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead.");
      }
    }
  }
  let viewRect2;
  if (useCenterAndSize) {
    viewRect2 = {};
    if (aspect > 1) {
      viewRect2.width = size;
      viewRect2.height = size / aspect;
    } else {
      viewRect2.height = size;
      viewRect2.width = size * aspect;
    }
    viewRect2.y = center3[1] - viewRect2.height / 2;
    viewRect2.x = center3[0] - viewRect2.width / 2;
  } else {
    const boxLayoutOption = geoModel.getBoxLayoutParams();
    boxLayoutOption.aspect = aspect;
    viewRect2 = getLayoutRect(boxLayoutOption, {
      width: viewWidth,
      height: viewHeight
    });
  }
  this.setViewRect(viewRect2.x, viewRect2.y, viewRect2.width, viewRect2.height);
  this.setCenter(geoModel.get("center"), api2);
  this.setZoom(geoModel.get("zoom"));
}
function setGeoCoords(geo, model) {
  each(model.get("geoCoord"), function(geoCoord2, name) {
    geo.addGeoCoord(name, geoCoord2);
  });
}
var GeoCreator = class {
  constructor() {
    this.dimensions = geo2DDimensions;
  }
  create(ecModel, api2) {
    const geoList = [];
    function getCommonGeoProperties(model) {
      return {
        nameProperty: model.get("nameProperty"),
        aspectScale: model.get("aspectScale"),
        projection: model.get("projection")
      };
    }
    ecModel.eachComponent("geo", function(geoModel, idx) {
      const mapName = geoModel.get("map");
      const geo = new Geo_default(mapName + idx, mapName, extend({
        nameMap: geoModel.get("nameMap")
      }, getCommonGeoProperties(geoModel)));
      geo.zoomLimit = geoModel.get("scaleLimit");
      geoList.push(geo);
      geoModel.coordinateSystem = geo;
      geo.model = geoModel;
      geo.resize = resizeGeo;
      geo.resize(geoModel, api2);
    });
    ecModel.eachSeries(function(seriesModel) {
      const coordSys = seriesModel.get("coordinateSystem");
      if (coordSys === "geo") {
        const geoIndex = seriesModel.get("geoIndex") || 0;
        seriesModel.coordinateSystem = geoList[geoIndex];
      }
    });
    const mapModelGroupBySeries = {};
    ecModel.eachSeriesByType("map", function(seriesModel) {
      if (!seriesModel.getHostGeoModel()) {
        const mapType = seriesModel.getMapType();
        mapModelGroupBySeries[mapType] = mapModelGroupBySeries[mapType] || [];
        mapModelGroupBySeries[mapType].push(seriesModel);
      }
    });
    each(mapModelGroupBySeries, function(mapSeries, mapType) {
      const nameMapList = map(mapSeries, function(singleMapSeries) {
        return singleMapSeries.get("nameMap");
      });
      const geo = new Geo_default(mapType, mapType, extend({
        nameMap: mergeAll(nameMapList)
      }, getCommonGeoProperties(mapSeries[0])));
      geo.zoomLimit = retrieve.apply(null, map(mapSeries, function(singleMapSeries) {
        return singleMapSeries.get("scaleLimit");
      }));
      geoList.push(geo);
      geo.resize = resizeGeo;
      geo.resize(mapSeries[0], api2);
      each(mapSeries, function(singleMapSeries) {
        singleMapSeries.coordinateSystem = geo;
        setGeoCoords(geo, singleMapSeries);
      });
    });
    return geoList;
  }
  getFilledRegions(originRegionArr, mapName, nameMap, nameProperty) {
    const regionsArr = (originRegionArr || []).slice();
    const dataNameMap = createHashMap();
    for (let i = 0; i < regionsArr.length; i++) {
      dataNameMap.set(regionsArr[i].name, regionsArr[i]);
    }
    const source = geoSourceManager_default.load(mapName, nameMap, nameProperty);
    each(source.regions, function(region) {
      const name = region.name;
      !dataNameMap.get(name) && regionsArr.push({name});
    });
    return regionsArr;
  }
};
var geoCreator = new GeoCreator();
var geoCreator_default = geoCreator;

// src/coord/geo/GeoModel.ts
var GeoModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = GeoModel2.type;
  }
  init(option, parentModel, ecModel) {
    const source = geoSourceManager_default.getGeoResource(option.map);
    if (source && source.type === "geoJSON") {
      const itemStyle = option.itemStyle = option.itemStyle || {};
      if (!("color" in itemStyle)) {
        itemStyle.color = "#eee";
      }
    }
    this.mergeDefaultAndTheme(option, ecModel);
    defaultEmphasis(option, "label", ["show"]);
  }
  optionUpdated() {
    const option = this.option;
    option.regions = geoCreator_default.getFilledRegions(option.regions, option.map, option.nameMap, option.nameProperty);
    const selectedMap = {};
    this._optionModelMap = reduce(option.regions || [], (optionModelMap, regionOpt) => {
      const regionName = regionOpt.name;
      if (regionName) {
        optionModelMap.set(regionName, new Model_default(regionOpt, this, this.ecModel));
        if (regionOpt.selected) {
          selectedMap[regionName] = true;
        }
      }
      return optionModelMap;
    }, createHashMap());
    if (!option.selectedMap) {
      option.selectedMap = selectedMap;
    }
  }
  getRegionModel(name) {
    return this._optionModelMap.get(name) || new Model_default(null, this, this.ecModel);
  }
  getFormattedLabel(name, status) {
    const regionModel = this.getRegionModel(name);
    const formatter = status === "normal" ? regionModel.get(["label", "formatter"]) : regionModel.get(["emphasis", "label", "formatter"]);
    const params = {
      name
    };
    if (isFunction(formatter)) {
      params.status = status;
      return formatter(params);
    } else if (isString(formatter)) {
      return formatter.replace("{a}", name != null ? name : "");
    }
  }
  setZoom(zoom) {
    this.option.zoom = zoom;
  }
  setCenter(center3) {
    this.option.center = center3;
  }
  select(name) {
    const option = this.option;
    const selectedMode = option.selectedMode;
    if (!selectedMode) {
      return;
    }
    if (selectedMode !== "multiple") {
      option.selectedMap = null;
    }
    const selectedMap = option.selectedMap || (option.selectedMap = {});
    selectedMap[name] = true;
  }
  unSelect(name) {
    const selectedMap = this.option.selectedMap;
    if (selectedMap) {
      selectedMap[name] = false;
    }
  }
  toggleSelected(name) {
    this[this.isSelected(name) ? "unSelect" : "select"](name);
  }
  isSelected(name) {
    const selectedMap = this.option.selectedMap;
    return !!(selectedMap && selectedMap[name]);
  }
};
var GeoModel = GeoModel2;
GeoModel.type = "geo";
GeoModel.layoutMode = "box";
GeoModel.defaultOption = {
  z: 0,
  show: true,
  left: "center",
  top: "center",
  aspectScale: null,
  silent: false,
  map: "",
  boundingCoords: null,
  center: null,
  zoom: 1,
  scaleLimit: null,
  label: {
    show: false,
    color: "#000"
  },
  itemStyle: {
    borderWidth: 0.5,
    borderColor: "#444"
  },
  emphasis: {
    label: {
      show: true,
      color: "rgb(100,0,0)"
    },
    itemStyle: {
      color: "rgba(255,215,0,0.8)"
    }
  },
  select: {
    label: {
      show: true,
      color: "rgb(100,0,0)"
    },
    itemStyle: {
      color: "rgba(255,215,0,0.8)"
    }
  },
  regions: []
};
var GeoModel_default = GeoModel;

// src/action/roamHelper.ts
function getCenterCoord(view, point) {
  return view.pointToProjected ? view.pointToProjected(point) : view.pointToData(point);
}
function updateCenterAndZoom(view, payload, zoomLimit, api2) {
  const previousZoom = view.getZoom();
  const center3 = view.getCenter();
  let zoom = payload.zoom;
  const point = view.projectedToPoint ? view.projectedToPoint(center3) : view.dataToPoint(center3);
  if (payload.dx != null && payload.dy != null) {
    point[0] -= payload.dx;
    point[1] -= payload.dy;
    view.setCenter(getCenterCoord(view, point), api2);
  }
  if (zoom != null) {
    if (zoomLimit) {
      const zoomMin = zoomLimit.min || 0;
      const zoomMax = zoomLimit.max || Infinity;
      zoom = Math.max(Math.min(previousZoom * zoom, zoomMax), zoomMin) / previousZoom;
    }
    view.scaleX *= zoom;
    view.scaleY *= zoom;
    const fixX = (payload.originX - view.x) * (zoom - 1);
    const fixY = (payload.originY - view.y) * (zoom - 1);
    view.x -= fixX;
    view.y -= fixY;
    view.updateTransform();
    view.setCenter(getCenterCoord(view, point), api2);
    view.setZoom(zoom * previousZoom);
  }
  return {
    center: view.getCenter(),
    zoom: view.getZoom()
  };
}

// src/component/geo/GeoView.ts
var GeoView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = GeoView2.type;
    this.focusBlurEnabled = true;
  }
  init(ecModel, api2) {
    this._api = api2;
  }
  render(geoModel, ecModel, api2, payload) {
    this._model = geoModel;
    if (!geoModel.get("show")) {
      this._mapDraw && this._mapDraw.remove();
      this._mapDraw = null;
      return;
    }
    if (!this._mapDraw) {
      this._mapDraw = new MapDraw_default(api2);
    }
    const mapDraw = this._mapDraw;
    mapDraw.draw(geoModel, ecModel, api2, this, payload);
    mapDraw.group.on("click", this._handleRegionClick, this);
    mapDraw.group.silent = geoModel.get("silent");
    this.group.add(mapDraw.group);
    this.updateSelectStatus(geoModel, ecModel, api2);
  }
  _handleRegionClick(e2) {
    let eventData;
    findEventDispatcher(e2.target, (current) => {
      return (eventData = getECData(current).eventData) != null;
    }, true);
    if (eventData) {
      this._api.dispatchAction({
        type: "geoToggleSelect",
        geoId: this._model.id,
        name: eventData.name
      });
    }
  }
  updateSelectStatus(model, ecModel, api2) {
    this._mapDraw.group.traverse((node) => {
      const eventData = getECData(node).eventData;
      if (eventData) {
        this._model.isSelected(eventData.name) ? api2.enterSelect(node) : api2.leaveSelect(node);
        return true;
      }
    });
  }
  findHighDownDispatchers(name) {
    return this._mapDraw && this._mapDraw.findHighDownDispatchers(name, this._model);
  }
  dispose() {
    this._mapDraw && this._mapDraw.remove();
  }
};
var GeoView = GeoView2;
GeoView.type = "geo";
var GeoView_default = GeoView;

// src/component/geo/install.ts
function registerMap2(mapName, geoJson, specialAreas) {
  geoSourceManager_default.registerMap(mapName, geoJson, specialAreas);
}
function install10(registers) {
  registers.registerCoordinateSystem("geo", geoCreator_default);
  registers.registerComponentModel(GeoModel_default);
  registers.registerComponentView(GeoView_default);
  registers.registerImpl("registerMap", registerMap2);
  registers.registerImpl("getMap", (mapName) => geoSourceManager_default.getMapForUser(mapName));
  function makeAction(method, actionInfo3) {
    actionInfo3.update = "geo:updateSelectStatus";
    registers.registerAction(actionInfo3, function(payload, ecModel) {
      const selected = {};
      const allSelected = [];
      ecModel.eachComponent({mainType: "geo", query: payload}, function(geoModel) {
        geoModel[method](payload.name);
        const geo = geoModel.coordinateSystem;
        each(geo.regions, function(region) {
          selected[region.name] = geoModel.isSelected(region.name) || false;
        });
        const names = [];
        each(selected, function(v, name) {
          selected[name] && names.push(name);
        });
        allSelected.push({
          geoIndex: geoModel.componentIndex,
          name: names
        });
      });
      return {
        selected,
        allSelected,
        name: payload.name
      };
    });
  }
  makeAction("toggleSelected", {
    type: "geoToggleSelect",
    event: "geoselectchanged"
  });
  makeAction("select", {
    type: "geoSelect",
    event: "geoselected"
  });
  makeAction("unSelect", {
    type: "geoUnSelect",
    event: "geounselected"
  });
  registers.registerAction({
    type: "geoRoam",
    event: "geoRoam",
    update: "updateTransform"
  }, function(payload, ecModel, api2) {
    const componentType = payload.componentType || "series";
    ecModel.eachComponent({mainType: componentType, query: payload}, function(componentModel) {
      const geo = componentModel.coordinateSystem;
      if (geo.type !== "geo") {
        return;
      }
      const res = updateCenterAndZoom(geo, payload, componentModel.get("scaleLimit"), api2);
      componentModel.setCenter && componentModel.setCenter(res.center);
      componentModel.setZoom && componentModel.setZoom(res.zoom);
      if (componentType === "series") {
        each(componentModel.seriesGroup, function(seriesModel) {
          seriesModel.setCenter(res.center);
          seriesModel.setZoom(res.zoom);
        });
      }
    });
  });
}

// src/chart/map/install.ts
function install11(registers) {
  use(install10);
  registers.registerChartView(MapView_default);
  registers.registerSeriesModel(MapSeries_default);
  registers.registerLayout(mapSymbolLayout);
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, mapDataStatistic);
  createLegacyDataSelectAction("map", registers.registerAction);
}

// src/chart/tree/layoutHelper.ts
function init3(inRoot) {
  const root = inRoot;
  root.hierNode = {
    defaultAncestor: null,
    ancestor: root,
    prelim: 0,
    modifier: 0,
    change: 0,
    shift: 0,
    i: 0,
    thread: null
  };
  const nodes = [root];
  let node;
  let children;
  while (node = nodes.pop()) {
    children = node.children;
    if (node.isExpand && children.length) {
      const n = children.length;
      for (let i = n - 1; i >= 0; i--) {
        const child = children[i];
        child.hierNode = {
          defaultAncestor: null,
          ancestor: child,
          prelim: 0,
          modifier: 0,
          change: 0,
          shift: 0,
          i,
          thread: null
        };
        nodes.push(child);
      }
    }
  }
}
function firstWalk(node, separation2) {
  const children = node.isExpand ? node.children : [];
  const siblings = node.parentNode.children;
  const subtreeW = node.hierNode.i ? siblings[node.hierNode.i - 1] : null;
  if (children.length) {
    executeShifts(node);
    const midPoint = (children[0].hierNode.prelim + children[children.length - 1].hierNode.prelim) / 2;
    if (subtreeW) {
      node.hierNode.prelim = subtreeW.hierNode.prelim + separation2(node, subtreeW);
      node.hierNode.modifier = node.hierNode.prelim - midPoint;
    } else {
      node.hierNode.prelim = midPoint;
    }
  } else if (subtreeW) {
    node.hierNode.prelim = subtreeW.hierNode.prelim + separation2(node, subtreeW);
  }
  node.parentNode.hierNode.defaultAncestor = apportion(node, subtreeW, node.parentNode.hierNode.defaultAncestor || siblings[0], separation2);
}
function secondWalk(node) {
  const nodeX = node.hierNode.prelim + node.parentNode.hierNode.modifier;
  node.setLayout({x: nodeX}, true);
  node.hierNode.modifier += node.parentNode.hierNode.modifier;
}
function separation(cb) {
  return arguments.length ? cb : defaultSeparation;
}
function radialCoordinate(rad, r) {
  rad -= Math.PI / 2;
  return {
    x: r * Math.cos(rad),
    y: r * Math.sin(rad)
  };
}
function getViewRect2(seriesModel, api2) {
  return getLayoutRect(seriesModel.getBoxLayoutParams(), {
    width: api2.getWidth(),
    height: api2.getHeight()
  });
}
function executeShifts(node) {
  const children = node.children;
  let n = children.length;
  let shift = 0;
  let change = 0;
  while (--n >= 0) {
    const child = children[n];
    child.hierNode.prelim += shift;
    child.hierNode.modifier += shift;
    change += child.hierNode.change;
    shift += child.hierNode.shift + change;
  }
}
function apportion(subtreeV, subtreeW, ancestor, separation2) {
  if (subtreeW) {
    let nodeOutRight = subtreeV;
    let nodeInRight = subtreeV;
    let nodeOutLeft = nodeInRight.parentNode.children[0];
    let nodeInLeft = subtreeW;
    let sumOutRight = nodeOutRight.hierNode.modifier;
    let sumInRight = nodeInRight.hierNode.modifier;
    let sumOutLeft = nodeOutLeft.hierNode.modifier;
    let sumInLeft = nodeInLeft.hierNode.modifier;
    while (nodeInLeft = nextRight(nodeInLeft), nodeInRight = nextLeft(nodeInRight), nodeInLeft && nodeInRight) {
      nodeOutRight = nextRight(nodeOutRight);
      nodeOutLeft = nextLeft(nodeOutLeft);
      nodeOutRight.hierNode.ancestor = subtreeV;
      const shift = nodeInLeft.hierNode.prelim + sumInLeft - nodeInRight.hierNode.prelim - sumInRight + separation2(nodeInLeft, nodeInRight);
      if (shift > 0) {
        moveSubtree(nextAncestor(nodeInLeft, subtreeV, ancestor), subtreeV, shift);
        sumInRight += shift;
        sumOutRight += shift;
      }
      sumInLeft += nodeInLeft.hierNode.modifier;
      sumInRight += nodeInRight.hierNode.modifier;
      sumOutRight += nodeOutRight.hierNode.modifier;
      sumOutLeft += nodeOutLeft.hierNode.modifier;
    }
    if (nodeInLeft && !nextRight(nodeOutRight)) {
      nodeOutRight.hierNode.thread = nodeInLeft;
      nodeOutRight.hierNode.modifier += sumInLeft - sumOutRight;
    }
    if (nodeInRight && !nextLeft(nodeOutLeft)) {
      nodeOutLeft.hierNode.thread = nodeInRight;
      nodeOutLeft.hierNode.modifier += sumInRight - sumOutLeft;
      ancestor = subtreeV;
    }
  }
  return ancestor;
}
function nextRight(node) {
  const children = node.children;
  return children.length && node.isExpand ? children[children.length - 1] : node.hierNode.thread;
}
function nextLeft(node) {
  const children = node.children;
  return children.length && node.isExpand ? children[0] : node.hierNode.thread;
}
function nextAncestor(nodeInLeft, node, ancestor) {
  return nodeInLeft.hierNode.ancestor.parentNode === node.parentNode ? nodeInLeft.hierNode.ancestor : ancestor;
}
function moveSubtree(wl, wr, shift) {
  const change = shift / (wr.hierNode.i - wl.hierNode.i);
  wr.hierNode.change -= change;
  wr.hierNode.shift += shift;
  wr.hierNode.modifier += shift;
  wr.hierNode.prelim += shift;
  wl.hierNode.change += change;
}
function defaultSeparation(node1, node2) {
  return node1.parentNode === node2.parentNode ? 1 : 2;
}

// src/chart/tree/TreeView.ts
var TreeEdgeShape = class {
  constructor() {
    this.parentPoint = [];
    this.childPoints = [];
  }
};
var TreePath = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultStyle() {
    return {
      stroke: "#000",
      fill: null
    };
  }
  getDefaultShape() {
    return new TreeEdgeShape();
  }
  buildPath(ctx, shape) {
    const childPoints = shape.childPoints;
    const childLen = childPoints.length;
    const parentPoint = shape.parentPoint;
    const firstChildPos = childPoints[0];
    const lastChildPos = childPoints[childLen - 1];
    if (childLen === 1) {
      ctx.moveTo(parentPoint[0], parentPoint[1]);
      ctx.lineTo(firstChildPos[0], firstChildPos[1]);
      return;
    }
    const orient = shape.orient;
    const forkDim = orient === "TB" || orient === "BT" ? 0 : 1;
    const otherDim = 1 - forkDim;
    const forkPosition = parsePercent2(shape.forkPosition, 1);
    const tmpPoint = [];
    tmpPoint[forkDim] = parentPoint[forkDim];
    tmpPoint[otherDim] = parentPoint[otherDim] + (lastChildPos[otherDim] - parentPoint[otherDim]) * forkPosition;
    ctx.moveTo(parentPoint[0], parentPoint[1]);
    ctx.lineTo(tmpPoint[0], tmpPoint[1]);
    ctx.moveTo(firstChildPos[0], firstChildPos[1]);
    tmpPoint[forkDim] = firstChildPos[forkDim];
    ctx.lineTo(tmpPoint[0], tmpPoint[1]);
    tmpPoint[forkDim] = lastChildPos[forkDim];
    ctx.lineTo(tmpPoint[0], tmpPoint[1]);
    ctx.lineTo(lastChildPos[0], lastChildPos[1]);
    for (let i = 1; i < childLen - 1; i++) {
      const point = childPoints[i];
      ctx.moveTo(point[0], point[1]);
      tmpPoint[forkDim] = point[forkDim];
      ctx.lineTo(tmpPoint[0], tmpPoint[1]);
    }
  }
};
var TreeView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = TreeView2.type;
    this._mainGroup = new Group_default();
  }
  init(ecModel, api2) {
    this._controller = new RoamController_default(api2.getZr());
    this._controllerHost = {
      target: this.group
    };
    this.group.add(this._mainGroup);
  }
  render(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    const layoutInfo = seriesModel.layoutInfo;
    const group = this._mainGroup;
    const layout18 = seriesModel.get("layout");
    if (layout18 === "radial") {
      group.x = layoutInfo.x + layoutInfo.width / 2;
      group.y = layoutInfo.y + layoutInfo.height / 2;
    } else {
      group.x = layoutInfo.x;
      group.y = layoutInfo.y;
    }
    this._updateViewCoordSys(seriesModel, api2);
    this._updateController(seriesModel, ecModel, api2);
    const oldData = this._data;
    data.diff(oldData).add(function(newIdx) {
      if (symbolNeedsDraw2(data, newIdx)) {
        updateNode(data, newIdx, null, group, seriesModel);
      }
    }).update(function(newIdx, oldIdx) {
      const symbolEl = oldData.getItemGraphicEl(oldIdx);
      if (!symbolNeedsDraw2(data, newIdx)) {
        symbolEl && removeNode(oldData, oldIdx, symbolEl, group, seriesModel);
        return;
      }
      updateNode(data, newIdx, symbolEl, group, seriesModel);
    }).remove(function(oldIdx) {
      const symbolEl = oldData.getItemGraphicEl(oldIdx);
      if (symbolEl) {
        removeNode(oldData, oldIdx, symbolEl, group, seriesModel);
      }
    }).execute();
    this._nodeScaleRatio = seriesModel.get("nodeScaleRatio");
    this._updateNodeAndLinkScale(seriesModel);
    if (seriesModel.get("expandAndCollapse") === true) {
      data.eachItemGraphicEl(function(el, dataIndex) {
        el.off("click").on("click", function() {
          api2.dispatchAction({
            type: "treeExpandAndCollapse",
            seriesId: seriesModel.id,
            dataIndex
          });
        });
      });
    }
    this._data = data;
  }
  _updateViewCoordSys(seriesModel, api2) {
    const data = seriesModel.getData();
    const points4 = [];
    data.each(function(idx) {
      const layout18 = data.getItemLayout(idx);
      if (layout18 && !isNaN(layout18.x) && !isNaN(layout18.y)) {
        points4.push([+layout18.x, +layout18.y]);
      }
    });
    const min3 = [];
    const max3 = [];
    fromPoints(points4, min3, max3);
    const oldMin = this._min;
    const oldMax = this._max;
    if (max3[0] - min3[0] === 0) {
      min3[0] = oldMin ? oldMin[0] : min3[0] - 1;
      max3[0] = oldMax ? oldMax[0] : max3[0] + 1;
    }
    if (max3[1] - min3[1] === 0) {
      min3[1] = oldMin ? oldMin[1] : min3[1] - 1;
      max3[1] = oldMax ? oldMax[1] : max3[1] + 1;
    }
    const viewCoordSys = seriesModel.coordinateSystem = new View_default();
    viewCoordSys.zoomLimit = seriesModel.get("scaleLimit");
    viewCoordSys.setBoundingRect(min3[0], min3[1], max3[0] - min3[0], max3[1] - min3[1]);
    viewCoordSys.setCenter(seriesModel.get("center"), api2);
    viewCoordSys.setZoom(seriesModel.get("zoom"));
    this.group.attr({
      x: viewCoordSys.x,
      y: viewCoordSys.y,
      scaleX: viewCoordSys.scaleX,
      scaleY: viewCoordSys.scaleY
    });
    this._min = min3;
    this._max = max3;
  }
  _updateController(seriesModel, ecModel, api2) {
    const controller = this._controller;
    const controllerHost = this._controllerHost;
    const group = this.group;
    controller.setPointerChecker(function(e2, x, y) {
      const rect = group.getBoundingRect();
      rect.applyTransform(group.transform);
      return rect.contain(x, y) && !onIrrelevantElement(e2, api2, seriesModel);
    });
    controller.enable(seriesModel.get("roam"));
    controllerHost.zoomLimit = seriesModel.get("scaleLimit");
    controllerHost.zoom = seriesModel.coordinateSystem.getZoom();
    controller.off("pan").off("zoom").on("pan", (e2) => {
      updateViewOnPan(controllerHost, e2.dx, e2.dy);
      api2.dispatchAction({
        seriesId: seriesModel.id,
        type: "treeRoam",
        dx: e2.dx,
        dy: e2.dy
      });
    }).on("zoom", (e2) => {
      updateViewOnZoom(controllerHost, e2.scale, e2.originX, e2.originY);
      api2.dispatchAction({
        seriesId: seriesModel.id,
        type: "treeRoam",
        zoom: e2.scale,
        originX: e2.originX,
        originY: e2.originY
      });
      this._updateNodeAndLinkScale(seriesModel);
      api2.updateLabelLayout();
    });
  }
  _updateNodeAndLinkScale(seriesModel) {
    const data = seriesModel.getData();
    const nodeScale = this._getNodeGlobalScale(seriesModel);
    data.eachItemGraphicEl(function(el, idx) {
      el.setSymbolScale(nodeScale);
    });
  }
  _getNodeGlobalScale(seriesModel) {
    const coordSys = seriesModel.coordinateSystem;
    if (coordSys.type !== "view") {
      return 1;
    }
    const nodeScaleRatio = this._nodeScaleRatio;
    const groupZoom = coordSys.scaleX || 1;
    const roamZoom = coordSys.getZoom();
    const nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;
    return nodeScale / groupZoom;
  }
  dispose() {
    this._controller && this._controller.dispose();
    this._controllerHost = null;
  }
  remove() {
    this._mainGroup.removeAll();
    this._data = null;
  }
};
var TreeView = TreeView2;
TreeView.type = "tree";
function symbolNeedsDraw2(data, dataIndex) {
  const layout18 = data.getItemLayout(dataIndex);
  return layout18 && !isNaN(layout18.x) && !isNaN(layout18.y);
}
function updateNode(data, dataIndex, symbolEl, group, seriesModel) {
  const isInit = !symbolEl;
  const node = data.tree.getNodeByDataIndex(dataIndex);
  const itemModel = node.getModel();
  const visualColor = node.getVisual("style").fill;
  const symbolInnerColor = node.isExpand === false && node.children.length !== 0 ? visualColor : "#fff";
  const virtualRoot = data.tree.root;
  const source = node.parentNode === virtualRoot ? node : node.parentNode || node;
  const sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);
  const sourceLayout = source.getLayout();
  const sourceOldLayout = sourceSymbolEl ? {
    x: sourceSymbolEl.__oldX,
    y: sourceSymbolEl.__oldY,
    rawX: sourceSymbolEl.__radialOldRawX,
    rawY: sourceSymbolEl.__radialOldRawY
  } : sourceLayout;
  const targetLayout = node.getLayout();
  if (isInit) {
    symbolEl = new Symbol_default(data, dataIndex, null, {
      symbolInnerColor,
      useNameLabel: true
    });
    symbolEl.x = sourceOldLayout.x;
    symbolEl.y = sourceOldLayout.y;
  } else {
    symbolEl.updateData(data, dataIndex, null, {
      symbolInnerColor,
      useNameLabel: true
    });
  }
  symbolEl.__radialOldRawX = symbolEl.__radialRawX;
  symbolEl.__radialOldRawY = symbolEl.__radialRawY;
  symbolEl.__radialRawX = targetLayout.rawX;
  symbolEl.__radialRawY = targetLayout.rawY;
  group.add(symbolEl);
  data.setItemGraphicEl(dataIndex, symbolEl);
  symbolEl.__oldX = symbolEl.x;
  symbolEl.__oldY = symbolEl.y;
  updateProps(symbolEl, {
    x: targetLayout.x,
    y: targetLayout.y
  }, seriesModel);
  const symbolPath = symbolEl.getSymbolPath();
  if (seriesModel.get("layout") === "radial") {
    const realRoot = virtualRoot.children[0];
    const rootLayout = realRoot.getLayout();
    const length2 = realRoot.children.length;
    let rad;
    let isLeft;
    if (targetLayout.x === rootLayout.x && node.isExpand === true && realRoot.children.length) {
      const center3 = {
        x: (realRoot.children[0].getLayout().x + realRoot.children[length2 - 1].getLayout().x) / 2,
        y: (realRoot.children[0].getLayout().y + realRoot.children[length2 - 1].getLayout().y) / 2
      };
      rad = Math.atan2(center3.y - rootLayout.y, center3.x - rootLayout.x);
      if (rad < 0) {
        rad = Math.PI * 2 + rad;
      }
      isLeft = center3.x < rootLayout.x;
      if (isLeft) {
        rad = rad - Math.PI;
      }
    } else {
      rad = Math.atan2(targetLayout.y - rootLayout.y, targetLayout.x - rootLayout.x);
      if (rad < 0) {
        rad = Math.PI * 2 + rad;
      }
      if (node.children.length === 0 || node.children.length !== 0 && node.isExpand === false) {
        isLeft = targetLayout.x < rootLayout.x;
        if (isLeft) {
          rad = rad - Math.PI;
        }
      } else {
        isLeft = targetLayout.x > rootLayout.x;
        if (!isLeft) {
          rad = rad - Math.PI;
        }
      }
    }
    const textPosition = isLeft ? "left" : "right";
    const normalLabelModel = itemModel.getModel("label");
    const rotate2 = normalLabelModel.get("rotate");
    const labelRotateRadian = rotate2 * (Math.PI / 180);
    const textContent = symbolPath.getTextContent();
    if (textContent) {
      symbolPath.setTextConfig({
        position: normalLabelModel.get("position") || textPosition,
        rotation: rotate2 == null ? -rad : labelRotateRadian,
        origin: "center"
      });
      textContent.setStyle("verticalAlign", "middle");
    }
  }
  const focus = itemModel.get(["emphasis", "focus"]);
  const focusDataIndices = focus === "relative" ? concatArray(node.getAncestorsIndices(), node.getDescendantIndices()) : focus === "ancestor" ? node.getAncestorsIndices() : focus === "descendant" ? node.getDescendantIndices() : null;
  if (focusDataIndices) {
    getECData(symbolEl).focus = focusDataIndices;
  }
  drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group);
  if (symbolEl.__edge) {
    symbolEl.onHoverStateChange = function(toState) {
      if (toState !== "blur") {
        const parentEl = node.parentNode && data.getItemGraphicEl(node.parentNode.dataIndex);
        if (!(parentEl && parentEl.hoverState === HOVER_STATE_BLUR)) {
          setStatesFlag(symbolEl.__edge, toState);
        }
      }
    };
  }
}
function drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group) {
  const itemModel = node.getModel();
  const edgeShape = seriesModel.get("edgeShape");
  const layout18 = seriesModel.get("layout");
  const orient = seriesModel.getOrient();
  const curvature = seriesModel.get(["lineStyle", "curveness"]);
  const edgeForkPosition = seriesModel.get("edgeForkPosition");
  const lineStyle = itemModel.getModel("lineStyle").getLineStyle();
  let edge = symbolEl.__edge;
  if (edgeShape === "curve") {
    if (node.parentNode && node.parentNode !== virtualRoot) {
      if (!edge) {
        edge = symbolEl.__edge = new BezierCurve_default({
          shape: getEdgeShape(layout18, orient, curvature, sourceOldLayout, sourceOldLayout)
        });
      }
      updateProps(edge, {
        shape: getEdgeShape(layout18, orient, curvature, sourceLayout, targetLayout)
      }, seriesModel);
    }
  } else if (edgeShape === "polyline") {
    if (layout18 === "orthogonal") {
      if (node !== virtualRoot && node.children && node.children.length !== 0 && node.isExpand === true) {
        const children = node.children;
        const childPoints = [];
        for (let i = 0; i < children.length; i++) {
          const childLayout = children[i].getLayout();
          childPoints.push([childLayout.x, childLayout.y]);
        }
        if (!edge) {
          edge = symbolEl.__edge = new TreePath({
            shape: {
              parentPoint: [targetLayout.x, targetLayout.y],
              childPoints: [[targetLayout.x, targetLayout.y]],
              orient,
              forkPosition: edgeForkPosition
            }
          });
        }
        updateProps(edge, {
          shape: {
            parentPoint: [targetLayout.x, targetLayout.y],
            childPoints
          }
        }, seriesModel);
      }
    } else {
      if (true) {
        throw new Error("The polyline edgeShape can only be used in orthogonal layout");
      }
    }
  }
  if (edge && !(edgeShape === "polyline" && !node.isExpand)) {
    edge.useStyle(defaults({
      strokeNoScale: true,
      fill: null
    }, lineStyle));
    setStatesStylesFromModel(edge, itemModel, "lineStyle");
    setDefaultStateProxy(edge);
    group.add(edge);
  }
}
function removeNodeEdge(node, data, group, seriesModel, removeAnimationOpt) {
  const virtualRoot = data.tree.root;
  const {source, sourceLayout} = getSourceNode(virtualRoot, node);
  const symbolEl = data.getItemGraphicEl(node.dataIndex);
  if (!symbolEl) {
    return;
  }
  const sourceSymbolEl = data.getItemGraphicEl(source.dataIndex);
  const sourceEdge = sourceSymbolEl.__edge;
  const edge = symbolEl.__edge || (source.isExpand === false || source.children.length === 1 ? sourceEdge : void 0);
  const edgeShape = seriesModel.get("edgeShape");
  const layoutOpt = seriesModel.get("layout");
  const orient = seriesModel.get("orient");
  const curvature = seriesModel.get(["lineStyle", "curveness"]);
  if (edge) {
    if (edgeShape === "curve") {
      removeElement(edge, {
        shape: getEdgeShape(layoutOpt, orient, curvature, sourceLayout, sourceLayout),
        style: {
          opacity: 0
        }
      }, seriesModel, {
        cb() {
          group.remove(edge);
        },
        removeOpt: removeAnimationOpt
      });
    } else if (edgeShape === "polyline" && seriesModel.get("layout") === "orthogonal") {
      removeElement(edge, {
        shape: {
          parentPoint: [sourceLayout.x, sourceLayout.y],
          childPoints: [[sourceLayout.x, sourceLayout.y]]
        },
        style: {
          opacity: 0
        }
      }, seriesModel, {
        cb() {
          group.remove(edge);
        },
        removeOpt: removeAnimationOpt
      });
    }
  }
}
function getSourceNode(virtualRoot, node) {
  let source = node.parentNode === virtualRoot ? node : node.parentNode || node;
  let sourceLayout;
  while (sourceLayout = source.getLayout(), sourceLayout == null) {
    source = source.parentNode === virtualRoot ? source : source.parentNode || source;
  }
  return {
    source,
    sourceLayout
  };
}
function removeNode(data, dataIndex, symbolEl, group, seriesModel) {
  const node = data.tree.getNodeByDataIndex(dataIndex);
  const virtualRoot = data.tree.root;
  const {sourceLayout} = getSourceNode(virtualRoot, node);
  const removeAnimationOpt = {
    duration: seriesModel.get("animationDurationUpdate"),
    easing: seriesModel.get("animationEasingUpdate")
  };
  removeElement(symbolEl, {
    x: sourceLayout.x + 1,
    y: sourceLayout.y + 1
  }, seriesModel, {
    cb() {
      group.remove(symbolEl);
      data.setItemGraphicEl(dataIndex, null);
    },
    removeOpt: removeAnimationOpt
  });
  symbolEl.fadeOut(null, data.hostModel, {
    fadeLabel: true,
    animation: removeAnimationOpt
  });
  node.children.forEach((childNode) => {
    removeNodeEdge(childNode, data, group, seriesModel, removeAnimationOpt);
  });
  removeNodeEdge(node, data, group, seriesModel, removeAnimationOpt);
}
function getEdgeShape(layoutOpt, orient, curvature, sourceLayout, targetLayout) {
  let cpx1;
  let cpy1;
  let cpx2;
  let cpy2;
  let x1;
  let x2;
  let y1;
  let y2;
  if (layoutOpt === "radial") {
    x1 = sourceLayout.rawX;
    y1 = sourceLayout.rawY;
    x2 = targetLayout.rawX;
    y2 = targetLayout.rawY;
    const radialCoor1 = radialCoordinate(x1, y1);
    const radialCoor2 = radialCoordinate(x1, y1 + (y2 - y1) * curvature);
    const radialCoor3 = radialCoordinate(x2, y2 + (y1 - y2) * curvature);
    const radialCoor4 = radialCoordinate(x2, y2);
    return {
      x1: radialCoor1.x || 0,
      y1: radialCoor1.y || 0,
      x2: radialCoor4.x || 0,
      y2: radialCoor4.y || 0,
      cpx1: radialCoor2.x || 0,
      cpy1: radialCoor2.y || 0,
      cpx2: radialCoor3.x || 0,
      cpy2: radialCoor3.y || 0
    };
  } else {
    x1 = sourceLayout.x;
    y1 = sourceLayout.y;
    x2 = targetLayout.x;
    y2 = targetLayout.y;
    if (orient === "LR" || orient === "RL") {
      cpx1 = x1 + (x2 - x1) * curvature;
      cpy1 = y1;
      cpx2 = x2 + (x1 - x2) * curvature;
      cpy2 = y2;
    }
    if (orient === "TB" || orient === "BT") {
      cpx1 = x1;
      cpy1 = y1 + (y2 - y1) * curvature;
      cpx2 = x2;
      cpy2 = y2 + (y1 - y2) * curvature;
    }
  }
  return {
    x1,
    y1,
    x2,
    y2,
    cpx1,
    cpy1,
    cpx2,
    cpy2
  };
}
var TreeView_default = TreeView;

// src/data/helper/linkSeriesData.ts
var inner8 = makeInner();
function linkSeriesData(opt) {
  const mainData = opt.mainData;
  let datas = opt.datas;
  if (!datas) {
    datas = {main: mainData};
    opt.datasAttr = {main: "data"};
  }
  opt.datas = opt.mainData = null;
  linkAll(mainData, datas, opt);
  each(datas, function(data) {
    each(mainData.TRANSFERABLE_METHODS, function(methodName) {
      data.wrapMethod(methodName, curry(transferInjection, opt));
    });
  });
  mainData.wrapMethod("cloneShallow", curry(cloneShallowInjection, opt));
  each(mainData.CHANGABLE_METHODS, function(methodName) {
    mainData.wrapMethod(methodName, curry(changeInjection, opt));
  });
  assert(datas[mainData.dataType] === mainData);
}
function transferInjection(opt, res) {
  if (isMainData(this)) {
    const datas = extend({}, inner8(this).datas);
    datas[this.dataType] = res;
    linkAll(res, datas, opt);
  } else {
    linkSingle(res, this.dataType, inner8(this).mainData, opt);
  }
  return res;
}
function changeInjection(opt, res) {
  opt.struct && opt.struct.update();
  return res;
}
function cloneShallowInjection(opt, res) {
  each(inner8(res).datas, function(data, dataType) {
    data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);
  });
  return res;
}
function getLinkedData(dataType) {
  const mainData = inner8(this).mainData;
  return dataType == null || mainData == null ? mainData : inner8(mainData).datas[dataType];
}
function getLinkedDataAll() {
  const mainData = inner8(this).mainData;
  return mainData == null ? [{data: mainData}] : map(keys(inner8(mainData).datas), function(type) {
    return {
      type,
      data: inner8(mainData).datas[type]
    };
  });
}
function isMainData(data) {
  return inner8(data).mainData === data;
}
function linkAll(mainData, datas, opt) {
  inner8(mainData).datas = {};
  each(datas, function(data, dataType) {
    linkSingle(data, dataType, mainData, opt);
  });
}
function linkSingle(data, dataType, mainData, opt) {
  inner8(mainData).datas[dataType] = data;
  inner8(data).mainData = mainData;
  data.dataType = dataType;
  if (opt.struct) {
    data[opt.structAttr] = opt.struct;
    opt.struct[opt.datasAttr[dataType]] = data;
  }
  data.getLinkedData = getLinkedData;
  data.getLinkedDataAll = getLinkedDataAll;
}
var linkSeriesData_default = linkSeriesData;

// src/data/Tree.ts
var TreeNode = class {
  constructor(name, hostTree) {
    this.depth = 0;
    this.height = 0;
    this.dataIndex = -1;
    this.children = [];
    this.viewChildren = [];
    this.isExpand = false;
    this.name = name || "";
    this.hostTree = hostTree;
  }
  isRemoved() {
    return this.dataIndex < 0;
  }
  eachNode(options, cb, context) {
    if (isFunction(options)) {
      context = cb;
      cb = options;
      options = null;
    }
    options = options || {};
    if (isString(options)) {
      options = {order: options};
    }
    const order = options.order || "preorder";
    const children = this[options.attr || "children"];
    let suppressVisitSub;
    order === "preorder" && (suppressVisitSub = cb.call(context, this));
    for (let i = 0; !suppressVisitSub && i < children.length; i++) {
      children[i].eachNode(options, cb, context);
    }
    order === "postorder" && cb.call(context, this);
  }
  updateDepthAndHeight(depth) {
    let height = 0;
    this.depth = depth;
    for (let i = 0; i < this.children.length; i++) {
      const child = this.children[i];
      child.updateDepthAndHeight(depth + 1);
      if (child.height > height) {
        height = child.height;
      }
    }
    this.height = height + 1;
  }
  getNodeById(id) {
    if (this.getId() === id) {
      return this;
    }
    for (let i = 0, children = this.children, len2 = children.length; i < len2; i++) {
      const res = children[i].getNodeById(id);
      if (res) {
        return res;
      }
    }
  }
  contains(node) {
    if (node === this) {
      return true;
    }
    for (let i = 0, children = this.children, len2 = children.length; i < len2; i++) {
      const res = children[i].contains(node);
      if (res) {
        return res;
      }
    }
  }
  getAncestors(includeSelf) {
    const ancestors = [];
    let node = includeSelf ? this : this.parentNode;
    while (node) {
      ancestors.push(node);
      node = node.parentNode;
    }
    ancestors.reverse();
    return ancestors;
  }
  getAncestorsIndices() {
    const indices = [];
    let currNode = this;
    while (currNode) {
      indices.push(currNode.dataIndex);
      currNode = currNode.parentNode;
    }
    indices.reverse();
    return indices;
  }
  getDescendantIndices() {
    const indices = [];
    this.eachNode((childNode) => {
      indices.push(childNode.dataIndex);
    });
    return indices;
  }
  getValue(dimension) {
    const data = this.hostTree.data;
    return data.getStore().get(data.getDimensionIndex(dimension || "value"), this.dataIndex);
  }
  setLayout(layout18, merge2) {
    this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout18, merge2);
  }
  getLayout() {
    return this.hostTree.data.getItemLayout(this.dataIndex);
  }
  getModel(path) {
    if (this.dataIndex < 0) {
      return;
    }
    const hostTree = this.hostTree;
    const itemModel = hostTree.data.getItemModel(this.dataIndex);
    return itemModel.getModel(path);
  }
  getLevelModel() {
    return (this.hostTree.levelModels || [])[this.depth];
  }
  setVisual(key, value) {
    this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value);
  }
  getVisual(key) {
    return this.hostTree.data.getItemVisual(this.dataIndex, key);
  }
  getRawIndex() {
    return this.hostTree.data.getRawIndex(this.dataIndex);
  }
  getId() {
    return this.hostTree.data.getId(this.dataIndex);
  }
  getChildIndex() {
    if (this.parentNode) {
      const children = this.parentNode.children;
      for (let i = 0; i < children.length; ++i) {
        if (children[i] === this) {
          return i;
        }
      }
      return -1;
    }
    return -1;
  }
  isAncestorOf(node) {
    let parent = node.parentNode;
    while (parent) {
      if (parent === this) {
        return true;
      }
      parent = parent.parentNode;
    }
    return false;
  }
  isDescendantOf(node) {
    return node !== this && node.isAncestorOf(this);
  }
};
var Tree = class {
  constructor(hostModel) {
    this.type = "tree";
    this._nodes = [];
    this.hostModel = hostModel;
  }
  eachNode(options, cb, context) {
    this.root.eachNode(options, cb, context);
  }
  getNodeByDataIndex(dataIndex) {
    const rawIndex = this.data.getRawIndex(dataIndex);
    return this._nodes[rawIndex];
  }
  getNodeById(name) {
    return this.root.getNodeById(name);
  }
  update() {
    const data = this.data;
    const nodes = this._nodes;
    for (let i = 0, len2 = nodes.length; i < len2; i++) {
      nodes[i].dataIndex = -1;
    }
    for (let i = 0, len2 = data.count(); i < len2; i++) {
      nodes[data.getRawIndex(i)].dataIndex = i;
    }
  }
  clearLayouts() {
    this.data.clearItemLayouts();
  }
  static createTree(dataRoot, hostModel, beforeLink) {
    const tree = new Tree(hostModel);
    const listData = [];
    let dimMax = 1;
    buildHierarchy(dataRoot);
    function buildHierarchy(dataNode, parentNode2) {
      const value = dataNode.value;
      dimMax = Math.max(dimMax, isArray(value) ? value.length : 1);
      listData.push(dataNode);
      const node = new TreeNode(convertOptionIdName(dataNode.name, ""), tree);
      parentNode2 ? addChild(node, parentNode2) : tree.root = node;
      tree._nodes.push(node);
      const children = dataNode.children;
      if (children) {
        for (let i = 0; i < children.length; i++) {
          buildHierarchy(children[i], node);
        }
      }
    }
    tree.root.updateDepthAndHeight(0);
    const {dimensions} = prepareSeriesDataSchema(listData, {
      coordDimensions: ["value"],
      dimensionsCount: dimMax
    });
    const list = new SeriesData_default(dimensions, hostModel);
    list.initData(listData);
    beforeLink && beforeLink(list);
    linkSeriesData_default({
      mainData: list,
      struct: tree,
      structAttr: "tree"
    });
    tree.update();
    return tree;
  }
};
function addChild(child, node) {
  const children = node.children;
  if (child.parentNode === node) {
    return;
  }
  children.push(child);
  child.parentNode = node;
}
var Tree_default = Tree;

// src/chart/helper/treeHelper.ts
function retrieveTargetInfo(payload, validPayloadTypes, seriesModel) {
  if (payload && indexOf(validPayloadTypes, payload.type) >= 0) {
    const root = seriesModel.getData().tree.root;
    let targetNode = payload.targetNode;
    if (isString(targetNode)) {
      targetNode = root.getNodeById(targetNode);
    }
    if (targetNode && root.contains(targetNode)) {
      return {
        node: targetNode
      };
    }
    const targetNodeId = payload.targetNodeId;
    if (targetNodeId != null && (targetNode = root.getNodeById(targetNodeId))) {
      return {
        node: targetNode
      };
    }
  }
}
function getPathToRoot(node) {
  const path = [];
  while (node) {
    node = node.parentNode;
    node && path.push(node);
  }
  return path.reverse();
}
function aboveViewRoot(viewRoot, node) {
  const viewPath = getPathToRoot(viewRoot);
  return indexOf(viewPath, node) >= 0;
}
function wrapTreePathInfo(node, seriesModel) {
  const treePathInfo = [];
  while (node) {
    const nodeDataIndex = node.dataIndex;
    treePathInfo.push({
      name: node.name,
      dataIndex: nodeDataIndex,
      value: seriesModel.getRawValue(nodeDataIndex)
    });
    node = node.parentNode;
  }
  treePathInfo.reverse();
  return treePathInfo;
}

// src/chart/tree/TreeSeries.ts
var TreeSeriesModel = class extends Series_default {
  constructor() {
    super(...arguments);
    this.hasSymbolVisual = true;
    this.ignoreStyleOnData = true;
  }
  getInitialData(option) {
    const root = {
      name: option.name,
      children: option.data
    };
    const leaves = option.leaves || {};
    const leavesModel = new Model_default(leaves, this, this.ecModel);
    const tree = Tree_default.createTree(root, this, beforeLink);
    function beforeLink(nodeData) {
      nodeData.wrapMethod("getItemModel", function(model, idx) {
        const node = tree.getNodeByDataIndex(idx);
        if (!(node && node.children.length && node.isExpand)) {
          model.parentModel = leavesModel;
        }
        return model;
      });
    }
    let treeDepth = 0;
    tree.eachNode("preorder", function(node) {
      if (node.depth > treeDepth) {
        treeDepth = node.depth;
      }
    });
    const expandAndCollapse = option.expandAndCollapse;
    const expandTreeDepth = expandAndCollapse && option.initialTreeDepth >= 0 ? option.initialTreeDepth : treeDepth;
    tree.root.eachNode("preorder", function(node) {
      const item = node.hostTree.data.getRawDataItem(node.dataIndex);
      node.isExpand = item && item.collapsed != null ? !item.collapsed : node.depth <= expandTreeDepth;
    });
    return tree.data;
  }
  getOrient() {
    let orient = this.get("orient");
    if (orient === "horizontal") {
      orient = "LR";
    } else if (orient === "vertical") {
      orient = "TB";
    }
    return orient;
  }
  setZoom(zoom) {
    this.option.zoom = zoom;
  }
  setCenter(center3) {
    this.option.center = center3;
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    const tree = this.getData().tree;
    const realRoot = tree.root.children[0];
    let node = tree.getNodeByDataIndex(dataIndex);
    const value = node.getValue();
    let name = node.name;
    while (node && node !== realRoot) {
      name = node.parentNode.name + "." + name;
      node = node.parentNode;
    }
    return createTooltipMarkup("nameValue", {
      name,
      value,
      noValue: isNaN(value) || value == null
    });
  }
  getDataParams(dataIndex) {
    const params = super.getDataParams.apply(this, arguments);
    const node = this.getData().tree.getNodeByDataIndex(dataIndex);
    params.treeAncestors = wrapTreePathInfo(node, this);
    params.collapsed = !node.isExpand;
    return params;
  }
};
TreeSeriesModel.type = "series.tree";
TreeSeriesModel.layoutMode = "box";
TreeSeriesModel.defaultOption = {
  z: 2,
  coordinateSystem: "view",
  left: "12%",
  top: "12%",
  right: "12%",
  bottom: "12%",
  layout: "orthogonal",
  edgeShape: "curve",
  edgeForkPosition: "50%",
  roam: false,
  nodeScaleRatio: 0.4,
  center: null,
  zoom: 1,
  orient: "LR",
  symbol: "emptyCircle",
  symbolSize: 7,
  expandAndCollapse: true,
  initialTreeDepth: 2,
  lineStyle: {
    color: "#ccc",
    width: 1.5,
    curveness: 0.5
  },
  itemStyle: {
    color: "lightsteelblue",
    borderWidth: 1.5
  },
  label: {
    show: true
  },
  animationEasing: "linear",
  animationDuration: 700,
  animationDurationUpdate: 500
};
var TreeSeries_default = TreeSeriesModel;

// src/chart/tree/traversalHelper.ts
function eachAfter(root, callback, separation2) {
  const nodes = [root];
  const next = [];
  let node;
  while (node = nodes.pop()) {
    next.push(node);
    if (node.isExpand) {
      const children = node.children;
      if (children.length) {
        for (let i = 0; i < children.length; i++) {
          nodes.push(children[i]);
        }
      }
    }
  }
  while (node = next.pop()) {
    callback(node, separation2);
  }
}
function eachBefore(root, callback) {
  const nodes = [root];
  let node;
  while (node = nodes.pop()) {
    callback(node);
    if (node.isExpand) {
      const children = node.children;
      if (children.length) {
        for (let i = children.length - 1; i >= 0; i--) {
          nodes.push(children[i]);
        }
      }
    }
  }
}

// src/chart/tree/treeLayout.ts
function treeLayout(ecModel, api2) {
  ecModel.eachSeriesByType("tree", function(seriesModel) {
    commonLayout(seriesModel, api2);
  });
}
function commonLayout(seriesModel, api2) {
  const layoutInfo = getViewRect2(seriesModel, api2);
  seriesModel.layoutInfo = layoutInfo;
  const layout18 = seriesModel.get("layout");
  let width = 0;
  let height = 0;
  let separation2 = null;
  if (layout18 === "radial") {
    width = 2 * Math.PI;
    height = Math.min(layoutInfo.height, layoutInfo.width) / 2;
    separation2 = separation(function(node1, node2) {
      return (node1.parentNode === node2.parentNode ? 1 : 2) / node1.depth;
    });
  } else {
    width = layoutInfo.width;
    height = layoutInfo.height;
    separation2 = separation();
  }
  const virtualRoot = seriesModel.getData().tree.root;
  const realRoot = virtualRoot.children[0];
  if (realRoot) {
    init3(virtualRoot);
    eachAfter(realRoot, firstWalk, separation2);
    virtualRoot.hierNode.modifier = -realRoot.hierNode.prelim;
    eachBefore(realRoot, secondWalk);
    let left = realRoot;
    let right = realRoot;
    let bottom = realRoot;
    eachBefore(realRoot, function(node) {
      const x = node.getLayout().x;
      if (x < left.getLayout().x) {
        left = node;
      }
      if (x > right.getLayout().x) {
        right = node;
      }
      if (node.depth > bottom.depth) {
        bottom = node;
      }
    });
    const delta = left === right ? 1 : separation2(left, right) / 2;
    const tx = delta - left.getLayout().x;
    let kx = 0;
    let ky = 0;
    let coorX = 0;
    let coorY = 0;
    if (layout18 === "radial") {
      kx = width / (right.getLayout().x + delta + tx);
      ky = height / (bottom.depth - 1 || 1);
      eachBefore(realRoot, function(node) {
        coorX = (node.getLayout().x + tx) * kx;
        coorY = (node.depth - 1) * ky;
        const finalCoor = radialCoordinate(coorX, coorY);
        node.setLayout({x: finalCoor.x, y: finalCoor.y, rawX: coorX, rawY: coorY}, true);
      });
    } else {
      const orient = seriesModel.getOrient();
      if (orient === "RL" || orient === "LR") {
        ky = height / (right.getLayout().x + delta + tx);
        kx = width / (bottom.depth - 1 || 1);
        eachBefore(realRoot, function(node) {
          coorY = (node.getLayout().x + tx) * ky;
          coorX = orient === "LR" ? (node.depth - 1) * kx : width - (node.depth - 1) * kx;
          node.setLayout({x: coorX, y: coorY}, true);
        });
      } else if (orient === "TB" || orient === "BT") {
        kx = width / (right.getLayout().x + delta + tx);
        ky = height / (bottom.depth - 1 || 1);
        eachBefore(realRoot, function(node) {
          coorX = (node.getLayout().x + tx) * kx;
          coorY = orient === "TB" ? (node.depth - 1) * ky : height - (node.depth - 1) * ky;
          node.setLayout({x: coorX, y: coorY}, true);
        });
      }
    }
  }
}

// src/chart/tree/treeVisual.ts
function treeVisual(ecModel) {
  ecModel.eachSeriesByType("tree", function(seriesModel) {
    const data = seriesModel.getData();
    const tree = data.tree;
    tree.eachNode(function(node) {
      const model = node.getModel();
      const style = model.getModel("itemStyle").getItemStyle();
      const existsStyle = data.ensureUniqueItemVisual(node.dataIndex, "style");
      extend(existsStyle, style);
    });
  });
}

// src/chart/tree/treeAction.ts
function installTreeAction(registers) {
  registers.registerAction({
    type: "treeExpandAndCollapse",
    event: "treeExpandAndCollapse",
    update: "update"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "tree",
      query: payload
    }, function(seriesModel) {
      const dataIndex = payload.dataIndex;
      const tree = seriesModel.getData().tree;
      const node = tree.getNodeByDataIndex(dataIndex);
      node.isExpand = !node.isExpand;
    });
  });
  registers.registerAction({
    type: "treeRoam",
    event: "treeRoam",
    update: "none"
  }, function(payload, ecModel, api2) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "tree",
      query: payload
    }, function(seriesModel) {
      const coordSys = seriesModel.coordinateSystem;
      const res = updateCenterAndZoom(coordSys, payload, void 0, api2);
      seriesModel.setCenter && seriesModel.setCenter(res.center);
      seriesModel.setZoom && seriesModel.setZoom(res.zoom);
    });
  });
}

// src/chart/tree/install.ts
function install12(registers) {
  registers.registerChartView(TreeView_default);
  registers.registerSeriesModel(TreeSeries_default);
  registers.registerLayout(treeLayout);
  registers.registerVisual(treeVisual);
  installTreeAction(registers);
}

// src/chart/treemap/treemapAction.ts
var actionTypes = [
  "treemapZoomToNode",
  "treemapRender",
  "treemapMove"
];
function installTreemapAction(registers) {
  for (let i = 0; i < actionTypes.length; i++) {
    registers.registerAction({
      type: actionTypes[i],
      update: "updateView"
    }, noop);
  }
  registers.registerAction({type: "treemapRootToNode", update: "updateView"}, function(payload, ecModel) {
    ecModel.eachComponent({mainType: "series", subType: "treemap", query: payload}, handleRootToNode);
    function handleRootToNode(model, index) {
      const types = ["treemapZoomToNode", "treemapRootToNode"];
      const targetInfo = retrieveTargetInfo(payload, types, model);
      if (targetInfo) {
        const originViewRoot = model.getViewRoot();
        if (originViewRoot) {
          payload.direction = aboveViewRoot(originViewRoot, targetInfo.node) ? "rollUp" : "drillDown";
        }
        model.resetViewRoot(targetInfo.node);
      }
    }
  });
}

// src/chart/helper/enableAriaDecalForTree.ts
function enableAriaDecalForTree(seriesModel) {
  const data = seriesModel.getData();
  const tree = data.tree;
  const decalPaletteScope2 = {};
  tree.eachNode((node) => {
    let current = node;
    while (current && current.depth > 1) {
      current = current.parentNode;
    }
    const decal = getDecalFromPalette(seriesModel.ecModel, current.name || current.dataIndex + "", decalPaletteScope2);
    node.setVisual("decal", decal);
  });
}

// src/chart/treemap/TreemapSeries.ts
var TreemapSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = TreemapSeriesModel2.type;
    this.preventUsingHoverLayer = true;
  }
  getInitialData(option, ecModel) {
    const root = {
      name: option.name,
      children: option.data
    };
    completeTreeValue(root);
    let levels = option.levels || [];
    const designatedVisualItemStyle = this.designatedVisualItemStyle = {};
    const designatedVisualModel = new Model_default({itemStyle: designatedVisualItemStyle}, this, ecModel);
    levels = option.levels = setDefault(levels, ecModel);
    const levelModels = map(levels || [], function(levelDefine) {
      return new Model_default(levelDefine, designatedVisualModel, ecModel);
    }, this);
    const tree = Tree_default.createTree(root, this, beforeLink);
    function beforeLink(nodeData) {
      nodeData.wrapMethod("getItemModel", function(model, idx) {
        const node = tree.getNodeByDataIndex(idx);
        const levelModel = node ? levelModels[node.depth] : null;
        model.parentModel = levelModel || designatedVisualModel;
        return model;
      });
    }
    return tree.data;
  }
  optionUpdated() {
    this.resetViewRoot();
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    const data = this.getData();
    const value = this.getRawValue(dataIndex);
    const name = data.getName(dataIndex);
    return createTooltipMarkup("nameValue", {name, value});
  }
  getDataParams(dataIndex) {
    const params = super.getDataParams.apply(this, arguments);
    const node = this.getData().tree.getNodeByDataIndex(dataIndex);
    params.treeAncestors = wrapTreePathInfo(node, this);
    params.treePathInfo = params.treeAncestors;
    return params;
  }
  setLayoutInfo(layoutInfo) {
    this.layoutInfo = this.layoutInfo || {};
    extend(this.layoutInfo, layoutInfo);
  }
  mapIdToIndex(id) {
    let idIndexMap = this._idIndexMap;
    if (!idIndexMap) {
      idIndexMap = this._idIndexMap = createHashMap();
      this._idIndexMapCount = 0;
    }
    let index = idIndexMap.get(id);
    if (index == null) {
      idIndexMap.set(id, index = this._idIndexMapCount++);
    }
    return index;
  }
  getViewRoot() {
    return this._viewRoot;
  }
  resetViewRoot(viewRoot) {
    viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
    const root = this.getRawData().tree.root;
    if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {
      this._viewRoot = root;
    }
  }
  enableAriaDecal() {
    enableAriaDecalForTree(this);
  }
};
var TreemapSeriesModel = TreemapSeriesModel2;
TreemapSeriesModel.type = "series.treemap";
TreemapSeriesModel.layoutMode = "box";
TreemapSeriesModel.defaultOption = {
  progressive: 0,
  left: "center",
  top: "middle",
  width: "80%",
  height: "80%",
  sort: true,
  clipWindow: "origin",
  squareRatio: 0.5 * (1 + Math.sqrt(5)),
  leafDepth: null,
  drillDownIcon: "\u25B6",
  zoomToNodeRatio: 0.32 * 0.32,
  roam: true,
  nodeClick: "zoomToNode",
  animation: true,
  animationDurationUpdate: 900,
  animationEasing: "quinticInOut",
  breadcrumb: {
    show: true,
    height: 22,
    left: "center",
    top: "bottom",
    emptyItemWidth: 25,
    itemStyle: {
      color: "rgba(0,0,0,0.7)",
      textStyle: {
        color: "#fff"
      }
    },
    emphasis: {
      itemStyle: {
        color: "rgba(0,0,0,0.9)"
      }
    }
  },
  label: {
    show: true,
    distance: 0,
    padding: 5,
    position: "inside",
    color: "#fff",
    overflow: "truncate"
  },
  upperLabel: {
    show: false,
    position: [0, "50%"],
    height: 20,
    overflow: "truncate",
    verticalAlign: "middle"
  },
  itemStyle: {
    color: null,
    colorAlpha: null,
    colorSaturation: null,
    borderWidth: 0,
    gapWidth: 0,
    borderColor: "#fff",
    borderColorSaturation: null
  },
  emphasis: {
    upperLabel: {
      show: true,
      position: [0, "50%"],
      overflow: "truncate",
      verticalAlign: "middle"
    }
  },
  visualDimension: 0,
  visualMin: null,
  visualMax: null,
  color: [],
  colorAlpha: null,
  colorSaturation: null,
  colorMappingBy: "index",
  visibleMin: 10,
  childrenVisibleMin: null,
  levels: []
};
function completeTreeValue(dataNode) {
  let sum2 = 0;
  each(dataNode.children, function(child) {
    completeTreeValue(child);
    let childValue = child.value;
    isArray(childValue) && (childValue = childValue[0]);
    sum2 += childValue;
  });
  let thisValue = dataNode.value;
  if (isArray(thisValue)) {
    thisValue = thisValue[0];
  }
  if (thisValue == null || isNaN(thisValue)) {
    thisValue = sum2;
  }
  if (thisValue < 0) {
    thisValue = 0;
  }
  isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
}
function setDefault(levels, ecModel) {
  const globalColorList = normalizeToArray(ecModel.get("color"));
  const globalDecalList = normalizeToArray(ecModel.get(["aria", "decal", "decals"]));
  if (!globalColorList) {
    return;
  }
  levels = levels || [];
  let hasColorDefine;
  let hasDecalDefine;
  each(levels, function(levelDefine) {
    const model = new Model_default(levelDefine);
    const modelColor = model.get("color");
    const modelDecal = model.get("decal");
    if (model.get(["itemStyle", "color"]) || modelColor && modelColor !== "none") {
      hasColorDefine = true;
    }
    if (model.get(["itemStyle", "decal"]) || modelDecal && modelDecal !== "none") {
      hasDecalDefine = true;
    }
  });
  const level0 = levels[0] || (levels[0] = {});
  if (!hasColorDefine) {
    level0.color = globalColorList.slice();
  }
  if (!hasDecalDefine && globalDecalList) {
    level0.decal = globalDecalList.slice();
  }
  return levels;
}
var TreemapSeries_default = TreemapSeriesModel;

// src/chart/treemap/Breadcrumb.ts
var TEXT_PADDING = 8;
var ITEM_GAP = 8;
var ARRAY_LENGTH = 5;
var Breadcrumb = class {
  constructor(containerGroup) {
    this.group = new Group_default();
    containerGroup.add(this.group);
  }
  render(seriesModel, api2, targetNode, onSelect) {
    const model = seriesModel.getModel("breadcrumb");
    const thisGroup = this.group;
    thisGroup.removeAll();
    if (!model.get("show") || !targetNode) {
      return;
    }
    const normalStyleModel = model.getModel("itemStyle");
    const emphasisModel = model.getModel("emphasis");
    const textStyleModel = normalStyleModel.getModel("textStyle");
    const emphasisTextStyleModel = emphasisModel.getModel(["itemStyle", "textStyle"]);
    const layoutParam = {
      pos: {
        left: model.get("left"),
        right: model.get("right"),
        top: model.get("top"),
        bottom: model.get("bottom")
      },
      box: {
        width: api2.getWidth(),
        height: api2.getHeight()
      },
      emptyItemWidth: model.get("emptyItemWidth"),
      totalWidth: 0,
      renderList: []
    };
    this._prepare(targetNode, layoutParam, textStyleModel);
    this._renderContent(seriesModel, layoutParam, normalStyleModel, emphasisModel, textStyleModel, emphasisTextStyleModel, onSelect);
    positionElement(thisGroup, layoutParam.pos, layoutParam.box);
  }
  _prepare(targetNode, layoutParam, textStyleModel) {
    for (let node = targetNode; node; node = node.parentNode) {
      const text = convertOptionIdName(node.getModel().get("name"), "");
      const textRect = textStyleModel.getTextRect(text);
      const itemWidth = Math.max(textRect.width + TEXT_PADDING * 2, layoutParam.emptyItemWidth);
      layoutParam.totalWidth += itemWidth + ITEM_GAP;
      layoutParam.renderList.push({
        node,
        text,
        width: itemWidth
      });
    }
  }
  _renderContent(seriesModel, layoutParam, normalStyleModel, emphasisModel, textStyleModel, emphasisTextStyleModel, onSelect) {
    let lastX = 0;
    const emptyItemWidth = layoutParam.emptyItemWidth;
    const height = seriesModel.get(["breadcrumb", "height"]);
    const availableSize = getAvailableSize(layoutParam.pos, layoutParam.box);
    let totalWidth = layoutParam.totalWidth;
    const renderList = layoutParam.renderList;
    const emphasisItemStyle = emphasisModel.getModel("itemStyle").getItemStyle();
    for (let i = renderList.length - 1; i >= 0; i--) {
      const item = renderList[i];
      const itemNode = item.node;
      let itemWidth = item.width;
      let text = item.text;
      if (totalWidth > availableSize.width) {
        totalWidth -= itemWidth - emptyItemWidth;
        itemWidth = emptyItemWidth;
        text = null;
      }
      const el = new Polygon_default({
        shape: {
          points: makeItemPoints(lastX, 0, itemWidth, height, i === renderList.length - 1, i === 0)
        },
        style: defaults(normalStyleModel.getItemStyle(), {
          lineJoin: "bevel"
        }),
        textContent: new Text_default({
          style: createTextStyle(textStyleModel, {text})
        }),
        textConfig: {
          position: "inside"
        },
        z2: Z2_EMPHASIS_LIFT * 1e4,
        onclick: curry(onSelect, itemNode)
      });
      el.disableLabelAnimation = true;
      el.getTextContent().ensureState("emphasis").style = createTextStyle(emphasisTextStyleModel, {text});
      el.ensureState("emphasis").style = emphasisItemStyle;
      toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
      this.group.add(el);
      packEventData(el, seriesModel, itemNode);
      lastX += itemWidth + ITEM_GAP;
    }
  }
  remove() {
    this.group.removeAll();
  }
};
function makeItemPoints(x, y, itemWidth, itemHeight, head, tail) {
  const points4 = [
    [head ? x : x - ARRAY_LENGTH, y],
    [x + itemWidth, y],
    [x + itemWidth, y + itemHeight],
    [head ? x : x - ARRAY_LENGTH, y + itemHeight]
  ];
  !tail && points4.splice(2, 0, [x + itemWidth + ARRAY_LENGTH, y + itemHeight / 2]);
  !head && points4.push([x, y + itemHeight / 2]);
  return points4;
}
function packEventData(el, seriesModel, itemNode) {
  getECData(el).eventData = {
    componentType: "series",
    componentSubType: "treemap",
    componentIndex: seriesModel.componentIndex,
    seriesIndex: seriesModel.seriesIndex,
    seriesName: seriesModel.name,
    seriesType: "treemap",
    selfType: "breadcrumb",
    nodeData: {
      dataIndex: itemNode && itemNode.dataIndex,
      name: itemNode && itemNode.name
    },
    treePathInfo: itemNode && wrapTreePathInfo(itemNode, seriesModel)
  };
}
var Breadcrumb_default = Breadcrumb;

// src/util/animation.ts
var AnimationWrap = class {
  constructor() {
    this._storage = [];
    this._elExistsMap = {};
  }
  add(el, target, duration, delay, easing) {
    if (this._elExistsMap[el.id]) {
      return false;
    }
    this._elExistsMap[el.id] = true;
    this._storage.push({
      el,
      target,
      duration,
      delay,
      easing
    });
    return true;
  }
  finished(callback) {
    this._finishedCallback = callback;
    return this;
  }
  start() {
    let count2 = this._storage.length;
    const checkTerminate = () => {
      count2--;
      if (count2 <= 0) {
        this._storage.length = 0;
        this._elExistsMap = {};
        this._finishedCallback && this._finishedCallback();
      }
    };
    for (let i = 0, len2 = this._storage.length; i < len2; i++) {
      const item = this._storage[i];
      item.el.animateTo(item.target, {
        duration: item.duration,
        delay: item.delay,
        easing: item.easing,
        setToFinal: true,
        done: checkTerminate,
        aborted: checkTerminate
      });
    }
    return this;
  }
};
function createWrap() {
  return new AnimationWrap();
}

// src/chart/treemap/TreemapView.ts
var Group2 = Group_default;
var Rect2 = Rect_default;
var DRAG_THRESHOLD = 3;
var PATH_LABEL_NOAMAL = "label";
var PATH_UPPERLABEL_NORMAL = "upperLabel";
var Z2_BASE = Z2_EMPHASIS_LIFT * 10;
var Z2_BG = Z2_EMPHASIS_LIFT * 2;
var Z2_CONTENT = Z2_EMPHASIS_LIFT * 3;
var getStateItemStyle = makeStyleMapper([
  ["fill", "color"],
  ["stroke", "strokeColor"],
  ["lineWidth", "strokeWidth"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"]
]);
var getItemStyleNormal = function(model) {
  const itemStyle = getStateItemStyle(model);
  itemStyle.stroke = itemStyle.fill = itemStyle.lineWidth = null;
  return itemStyle;
};
var inner9 = makeInner();
var TreemapView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = TreemapView2.type;
    this._state = "ready";
    this._storage = createStorage();
  }
  render(seriesModel, ecModel, api2, payload) {
    const models = ecModel.findComponents({
      mainType: "series",
      subType: "treemap",
      query: payload
    });
    if (indexOf(models, seriesModel) < 0) {
      return;
    }
    this.seriesModel = seriesModel;
    this.api = api2;
    this.ecModel = ecModel;
    const types = ["treemapZoomToNode", "treemapRootToNode"];
    const targetInfo = retrieveTargetInfo(payload, types, seriesModel);
    const payloadType = payload && payload.type;
    const layoutInfo = seriesModel.layoutInfo;
    const isInit = !this._oldTree;
    const thisStorage = this._storage;
    const reRoot = payloadType === "treemapRootToNode" && targetInfo && thisStorage ? {
      rootNodeGroup: thisStorage.nodeGroup[targetInfo.node.getRawIndex()],
      direction: payload.direction
    } : null;
    const containerGroup = this._giveContainerGroup(layoutInfo);
    const hasAnimation = seriesModel.get("animation");
    const renderResult = this._doRender(containerGroup, seriesModel, reRoot);
    hasAnimation && !isInit && (!payloadType || payloadType === "treemapZoomToNode" || payloadType === "treemapRootToNode") ? this._doAnimation(containerGroup, renderResult, seriesModel, reRoot) : renderResult.renderFinally();
    this._resetController(api2);
    this._renderBreadcrumb(seriesModel, api2, targetInfo);
  }
  _giveContainerGroup(layoutInfo) {
    let containerGroup = this._containerGroup;
    if (!containerGroup) {
      containerGroup = this._containerGroup = new Group2();
      this._initEvents(containerGroup);
      this.group.add(containerGroup);
    }
    containerGroup.x = layoutInfo.x;
    containerGroup.y = layoutInfo.y;
    return containerGroup;
  }
  _doRender(containerGroup, seriesModel, reRoot) {
    const thisTree = seriesModel.getData().tree;
    const oldTree = this._oldTree;
    const lastsForAnimation = createStorage();
    const thisStorage = createStorage();
    const oldStorage = this._storage;
    const willInvisibleEls = [];
    function doRenderNode(thisNode, oldNode, parentGroup, depth) {
      return renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth);
    }
    dualTravel(thisTree.root ? [thisTree.root] : [], oldTree && oldTree.root ? [oldTree.root] : [], containerGroup, thisTree === oldTree || !oldTree, 0);
    const willDeleteEls = clearStorage(oldStorage);
    this._oldTree = thisTree;
    this._storage = thisStorage;
    return {
      lastsForAnimation,
      willDeleteEls,
      renderFinally
    };
    function dualTravel(thisViewChildren, oldViewChildren, parentGroup, sameTree, depth) {
      if (sameTree) {
        oldViewChildren = thisViewChildren;
        each(thisViewChildren, function(child, index) {
          !child.isRemoved() && processNode(index, index);
        });
      } else {
        new DataDiffer_default(oldViewChildren, thisViewChildren, getKey2, getKey2).add(processNode).update(processNode).remove(curry(processNode, null)).execute();
      }
      function getKey2(node) {
        return node.getId();
      }
      function processNode(newIndex, oldIndex) {
        const thisNode = newIndex != null ? thisViewChildren[newIndex] : null;
        const oldNode = oldIndex != null ? oldViewChildren[oldIndex] : null;
        const group = doRenderNode(thisNode, oldNode, parentGroup, depth);
        group && dualTravel(thisNode && thisNode.viewChildren || [], oldNode && oldNode.viewChildren || [], group, sameTree, depth + 1);
      }
    }
    function clearStorage(storage2) {
      const willDeleteEls2 = createStorage();
      storage2 && each(storage2, function(store, storageName) {
        const delEls = willDeleteEls2[storageName];
        each(store, function(el) {
          el && (delEls.push(el), inner9(el).willDelete = true);
        });
      });
      return willDeleteEls2;
    }
    function renderFinally() {
      each(willDeleteEls, function(els) {
        each(els, function(el) {
          el.parent && el.parent.remove(el);
        });
      });
      each(willInvisibleEls, function(el) {
        el.invisible = true;
        el.dirty();
      });
    }
  }
  _doAnimation(containerGroup, renderResult, seriesModel, reRoot) {
    const durationOption = seriesModel.get("animationDurationUpdate");
    const easingOption = seriesModel.get("animationEasing");
    const duration = (isFunction(durationOption) ? 0 : durationOption) || 0;
    const easing = (isFunction(easingOption) ? null : easingOption) || "cubicOut";
    const animationWrap = createWrap();
    each(renderResult.willDeleteEls, function(store, storageName) {
      each(store, function(el, rawIndex) {
        if (el.invisible) {
          return;
        }
        const parent = el.parent;
        let target;
        const innerStore = inner9(parent);
        if (reRoot && reRoot.direction === "drillDown") {
          target = parent === reRoot.rootNodeGroup ? {
            shape: {
              x: 0,
              y: 0,
              width: innerStore.nodeWidth,
              height: innerStore.nodeHeight
            },
            style: {
              opacity: 0
            }
          } : {style: {opacity: 0}};
        } else {
          let targetX = 0;
          let targetY = 0;
          if (!innerStore.willDelete) {
            targetX = innerStore.nodeWidth / 2;
            targetY = innerStore.nodeHeight / 2;
          }
          target = storageName === "nodeGroup" ? {x: targetX, y: targetY, style: {opacity: 0}} : {
            shape: {x: targetX, y: targetY, width: 0, height: 0},
            style: {opacity: 0}
          };
        }
        target && animationWrap.add(el, target, duration, 0, easing);
      });
    });
    each(this._storage, function(store, storageName) {
      each(store, function(el, rawIndex) {
        const last = renderResult.lastsForAnimation[storageName][rawIndex];
        const target = {};
        if (!last) {
          return;
        }
        if (el instanceof Group_default) {
          if (last.oldX != null) {
            target.x = el.x;
            target.y = el.y;
            el.x = last.oldX;
            el.y = last.oldY;
          }
        } else {
          if (last.oldShape) {
            target.shape = extend({}, el.shape);
            el.setShape(last.oldShape);
          }
          if (last.fadein) {
            el.setStyle("opacity", 0);
            target.style = {opacity: 1};
          } else if (el.style.opacity !== 1) {
            target.style = {opacity: 1};
          }
        }
        animationWrap.add(el, target, duration, 0, easing);
      });
    }, this);
    this._state = "animating";
    animationWrap.finished(bind(function() {
      this._state = "ready";
      renderResult.renderFinally();
    }, this)).start();
  }
  _resetController(api2) {
    let controller = this._controller;
    if (!controller) {
      controller = this._controller = new RoamController_default(api2.getZr());
      controller.enable(this.seriesModel.get("roam"));
      controller.on("pan", bind(this._onPan, this));
      controller.on("zoom", bind(this._onZoom, this));
    }
    const rect = new BoundingRect_default(0, 0, api2.getWidth(), api2.getHeight());
    controller.setPointerChecker(function(e2, x, y) {
      return rect.contain(x, y);
    });
  }
  _clearController() {
    let controller = this._controller;
    if (controller) {
      controller.dispose();
      controller = null;
    }
  }
  _onPan(e2) {
    if (this._state !== "animating" && (Math.abs(e2.dx) > DRAG_THRESHOLD || Math.abs(e2.dy) > DRAG_THRESHOLD)) {
      const root = this.seriesModel.getData().tree.root;
      if (!root) {
        return;
      }
      const rootLayout = root.getLayout();
      if (!rootLayout) {
        return;
      }
      this.api.dispatchAction({
        type: "treemapMove",
        from: this.uid,
        seriesId: this.seriesModel.id,
        rootRect: {
          x: rootLayout.x + e2.dx,
          y: rootLayout.y + e2.dy,
          width: rootLayout.width,
          height: rootLayout.height
        }
      });
    }
  }
  _onZoom(e2) {
    let mouseX = e2.originX;
    let mouseY = e2.originY;
    if (this._state !== "animating") {
      const root = this.seriesModel.getData().tree.root;
      if (!root) {
        return;
      }
      const rootLayout = root.getLayout();
      if (!rootLayout) {
        return;
      }
      const rect = new BoundingRect_default(rootLayout.x, rootLayout.y, rootLayout.width, rootLayout.height);
      const layoutInfo = this.seriesModel.layoutInfo;
      mouseX -= layoutInfo.x;
      mouseY -= layoutInfo.y;
      const m2 = create2();
      translate(m2, m2, [-mouseX, -mouseY]);
      scale2(m2, m2, [e2.scale, e2.scale]);
      translate(m2, m2, [mouseX, mouseY]);
      rect.applyTransform(m2);
      this.api.dispatchAction({
        type: "treemapRender",
        from: this.uid,
        seriesId: this.seriesModel.id,
        rootRect: {
          x: rect.x,
          y: rect.y,
          width: rect.width,
          height: rect.height
        }
      });
    }
  }
  _initEvents(containerGroup) {
    containerGroup.on("click", (e2) => {
      if (this._state !== "ready") {
        return;
      }
      const nodeClick = this.seriesModel.get("nodeClick", true);
      if (!nodeClick) {
        return;
      }
      const targetInfo = this.findTarget(e2.offsetX, e2.offsetY);
      if (!targetInfo) {
        return;
      }
      const node = targetInfo.node;
      if (node.getLayout().isLeafRoot) {
        this._rootToNode(targetInfo);
      } else {
        if (nodeClick === "zoomToNode") {
          this._zoomToNode(targetInfo);
        } else if (nodeClick === "link") {
          const itemModel = node.hostTree.data.getItemModel(node.dataIndex);
          const link = itemModel.get("link", true);
          const linkTarget = itemModel.get("target", true) || "blank";
          link && windowOpen(link, linkTarget);
        }
      }
    }, this);
  }
  _renderBreadcrumb(seriesModel, api2, targetInfo) {
    if (!targetInfo) {
      targetInfo = seriesModel.get("leafDepth", true) != null ? {node: seriesModel.getViewRoot()} : this.findTarget(api2.getWidth() / 2, api2.getHeight() / 2);
      if (!targetInfo) {
        targetInfo = {node: seriesModel.getData().tree.root};
      }
    }
    (this._breadcrumb || (this._breadcrumb = new Breadcrumb_default(this.group))).render(seriesModel, api2, targetInfo.node, (node) => {
      if (this._state !== "animating") {
        aboveViewRoot(seriesModel.getViewRoot(), node) ? this._rootToNode({node}) : this._zoomToNode({node});
      }
    });
  }
  remove() {
    this._clearController();
    this._containerGroup && this._containerGroup.removeAll();
    this._storage = createStorage();
    this._state = "ready";
    this._breadcrumb && this._breadcrumb.remove();
  }
  dispose() {
    this._clearController();
  }
  _zoomToNode(targetInfo) {
    this.api.dispatchAction({
      type: "treemapZoomToNode",
      from: this.uid,
      seriesId: this.seriesModel.id,
      targetNode: targetInfo.node
    });
  }
  _rootToNode(targetInfo) {
    this.api.dispatchAction({
      type: "treemapRootToNode",
      from: this.uid,
      seriesId: this.seriesModel.id,
      targetNode: targetInfo.node
    });
  }
  findTarget(x, y) {
    let targetInfo;
    const viewRoot = this.seriesModel.getViewRoot();
    viewRoot.eachNode({attr: "viewChildren", order: "preorder"}, function(node) {
      const bgEl = this._storage.background[node.getRawIndex()];
      if (bgEl) {
        const point = bgEl.transformCoordToLocal(x, y);
        const shape = bgEl.shape;
        if (shape.x <= point[0] && point[0] <= shape.x + shape.width && shape.y <= point[1] && point[1] <= shape.y + shape.height) {
          targetInfo = {
            node,
            offsetX: point[0],
            offsetY: point[1]
          };
        } else {
          return false;
        }
      }
    }, this);
    return targetInfo;
  }
};
var TreemapView = TreemapView2;
TreemapView.type = "treemap";
function createStorage() {
  return {
    nodeGroup: [],
    background: [],
    content: []
  };
}
function renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth) {
  if (!thisNode) {
    return;
  }
  const thisLayout = thisNode.getLayout();
  const data = seriesModel.getData();
  const nodeModel = thisNode.getModel();
  data.setItemGraphicEl(thisNode.dataIndex, null);
  if (!thisLayout || !thisLayout.isInView) {
    return;
  }
  const thisWidth = thisLayout.width;
  const thisHeight = thisLayout.height;
  const borderWidth = thisLayout.borderWidth;
  const thisInvisible = thisLayout.invisible;
  const thisRawIndex = thisNode.getRawIndex();
  const oldRawIndex = oldNode && oldNode.getRawIndex();
  const thisViewChildren = thisNode.viewChildren;
  const upperHeight = thisLayout.upperHeight;
  const isParent = thisViewChildren && thisViewChildren.length;
  const itemStyleNormalModel = nodeModel.getModel("itemStyle");
  const itemStyleEmphasisModel = nodeModel.getModel(["emphasis", "itemStyle"]);
  const itemStyleBlurModel = nodeModel.getModel(["blur", "itemStyle"]);
  const itemStyleSelectModel = nodeModel.getModel(["select", "itemStyle"]);
  const borderRadius = itemStyleNormalModel.get("borderRadius") || 0;
  const group = giveGraphic("nodeGroup", Group2);
  if (!group) {
    return;
  }
  parentGroup.add(group);
  group.x = thisLayout.x || 0;
  group.y = thisLayout.y || 0;
  group.markRedraw();
  inner9(group).nodeWidth = thisWidth;
  inner9(group).nodeHeight = thisHeight;
  if (thisLayout.isAboveViewRoot) {
    return group;
  }
  const bg = giveGraphic("background", Rect2, depth, Z2_BG);
  bg && renderBackground(group, bg, isParent && thisLayout.upperLabelHeight);
  const emphasisModel = nodeModel.getModel("emphasis");
  const focus = emphasisModel.get("focus");
  const blurScope = emphasisModel.get("blurScope");
  const isDisabled = emphasisModel.get("disabled");
  const focusOrIndices = focus === "ancestor" ? thisNode.getAncestorsIndices() : focus === "descendant" ? thisNode.getDescendantIndices() : focus;
  if (isParent) {
    if (isHighDownDispatcher(group)) {
      setAsHighDownDispatcher(group, false);
    }
    if (bg) {
      setAsHighDownDispatcher(bg, !isDisabled);
      data.setItemGraphicEl(thisNode.dataIndex, bg);
      enableHoverFocus(bg, focusOrIndices, blurScope);
    }
  } else {
    const content = giveGraphic("content", Rect2, depth, Z2_CONTENT);
    content && renderContent(group, content);
    bg.disableMorphing = true;
    if (bg && isHighDownDispatcher(bg)) {
      setAsHighDownDispatcher(bg, false);
    }
    setAsHighDownDispatcher(group, !isDisabled);
    data.setItemGraphicEl(thisNode.dataIndex, group);
    enableHoverFocus(group, focusOrIndices, blurScope);
  }
  return group;
  function renderBackground(group2, bg2, useUpperLabel) {
    const ecData = getECData(bg2);
    ecData.dataIndex = thisNode.dataIndex;
    ecData.seriesIndex = seriesModel.seriesIndex;
    bg2.setShape({x: 0, y: 0, width: thisWidth, height: thisHeight, r: borderRadius});
    if (thisInvisible) {
      processInvisible(bg2);
    } else {
      bg2.invisible = false;
      const style = thisNode.getVisual("style");
      const visualBorderColor = style.stroke;
      const normalStyle = getItemStyleNormal(itemStyleNormalModel);
      normalStyle.fill = visualBorderColor;
      const emphasisStyle = getStateItemStyle(itemStyleEmphasisModel);
      emphasisStyle.fill = itemStyleEmphasisModel.get("borderColor");
      const blurStyle = getStateItemStyle(itemStyleBlurModel);
      blurStyle.fill = itemStyleBlurModel.get("borderColor");
      const selectStyle = getStateItemStyle(itemStyleSelectModel);
      selectStyle.fill = itemStyleSelectModel.get("borderColor");
      if (useUpperLabel) {
        const upperLabelWidth = thisWidth - 2 * borderWidth;
        prepareText(bg2, visualBorderColor, style.opacity, {x: borderWidth, y: 0, width: upperLabelWidth, height: upperHeight});
      } else {
        bg2.removeTextContent();
      }
      bg2.setStyle(normalStyle);
      bg2.ensureState("emphasis").style = emphasisStyle;
      bg2.ensureState("blur").style = blurStyle;
      bg2.ensureState("select").style = selectStyle;
      setDefaultStateProxy(bg2);
    }
    group2.add(bg2);
  }
  function renderContent(group2, content) {
    const ecData = getECData(content);
    ecData.dataIndex = thisNode.dataIndex;
    ecData.seriesIndex = seriesModel.seriesIndex;
    const contentWidth = Math.max(thisWidth - 2 * borderWidth, 0);
    const contentHeight = Math.max(thisHeight - 2 * borderWidth, 0);
    content.culling = true;
    content.setShape({
      x: borderWidth,
      y: borderWidth,
      width: contentWidth,
      height: contentHeight,
      r: borderRadius
    });
    if (thisInvisible) {
      processInvisible(content);
    } else {
      content.invisible = false;
      const nodeStyle = thisNode.getVisual("style");
      const visualColor = nodeStyle.fill;
      const normalStyle = getItemStyleNormal(itemStyleNormalModel);
      normalStyle.fill = visualColor;
      normalStyle.decal = nodeStyle.decal;
      const emphasisStyle = getStateItemStyle(itemStyleEmphasisModel);
      const blurStyle = getStateItemStyle(itemStyleBlurModel);
      const selectStyle = getStateItemStyle(itemStyleSelectModel);
      prepareText(content, visualColor, nodeStyle.opacity, null);
      content.setStyle(normalStyle);
      content.ensureState("emphasis").style = emphasisStyle;
      content.ensureState("blur").style = blurStyle;
      content.ensureState("select").style = selectStyle;
      setDefaultStateProxy(content);
    }
    group2.add(content);
  }
  function processInvisible(element) {
    !element.invisible && willInvisibleEls.push(element);
  }
  function prepareText(rectEl, visualColor, visualOpacity, upperLabelRect) {
    const normalLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL);
    const defaultText = convertOptionIdName(nodeModel.get("name"), null);
    const isShow = normalLabelModel.getShallow("show");
    setLabelStyle(rectEl, getLabelStatesModels(nodeModel, upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL), {
      defaultText: isShow ? defaultText : null,
      inheritColor: visualColor,
      defaultOpacity: visualOpacity,
      labelFetcher: seriesModel,
      labelDataIndex: thisNode.dataIndex
    });
    const textEl = rectEl.getTextContent();
    if (!textEl) {
      return;
    }
    const textStyle = textEl.style;
    const textPadding = normalizeCssArray(textStyle.padding || 0);
    if (upperLabelRect) {
      rectEl.setTextConfig({
        layoutRect: upperLabelRect
      });
      textEl.disableLabelLayout = true;
    }
    textEl.beforeUpdate = function() {
      const width = Math.max((upperLabelRect ? upperLabelRect.width : rectEl.shape.width) - textPadding[1] - textPadding[3], 0);
      const height = Math.max((upperLabelRect ? upperLabelRect.height : rectEl.shape.height) - textPadding[0] - textPadding[2], 0);
      if (textStyle.width !== width || textStyle.height !== height) {
        textEl.setStyle({
          width,
          height
        });
      }
    };
    textStyle.truncateMinChar = 2;
    textStyle.lineOverflow = "truncate";
    addDrillDownIcon(textStyle, upperLabelRect, thisLayout);
    const textEmphasisState = textEl.getState("emphasis");
    addDrillDownIcon(textEmphasisState ? textEmphasisState.style : null, upperLabelRect, thisLayout);
  }
  function addDrillDownIcon(style, upperLabelRect, thisLayout2) {
    const text = style ? style.text : null;
    if (!upperLabelRect && thisLayout2.isLeafRoot && text != null) {
      const iconChar = seriesModel.get("drillDownIcon", true);
      style.text = iconChar ? iconChar + " " + text : text;
    }
  }
  function giveGraphic(storageName, Ctor, depth2, z) {
    let element = oldRawIndex != null && oldStorage[storageName][oldRawIndex];
    const lasts = lastsForAnimation[storageName];
    if (element) {
      oldStorage[storageName][oldRawIndex] = null;
      prepareAnimationWhenHasOld(lasts, element);
    } else if (!thisInvisible) {
      element = new Ctor();
      if (element instanceof Displayable_default) {
        element.z2 = calculateZ2(depth2, z);
      }
      prepareAnimationWhenNoOld(lasts, element);
    }
    return thisStorage[storageName][thisRawIndex] = element;
  }
  function prepareAnimationWhenHasOld(lasts, element) {
    const lastCfg = lasts[thisRawIndex] = {};
    if (element instanceof Group2) {
      lastCfg.oldX = element.x;
      lastCfg.oldY = element.y;
    } else {
      lastCfg.oldShape = extend({}, element.shape);
    }
  }
  function prepareAnimationWhenNoOld(lasts, element) {
    const lastCfg = lasts[thisRawIndex] = {};
    const parentNode2 = thisNode.parentNode;
    const isGroup = element instanceof Group_default;
    if (parentNode2 && (!reRoot || reRoot.direction === "drillDown")) {
      let parentOldX = 0;
      let parentOldY = 0;
      const parentOldBg = lastsForAnimation.background[parentNode2.getRawIndex()];
      if (!reRoot && parentOldBg && parentOldBg.oldShape) {
        parentOldX = parentOldBg.oldShape.width;
        parentOldY = parentOldBg.oldShape.height;
      }
      if (isGroup) {
        lastCfg.oldX = 0;
        lastCfg.oldY = parentOldY;
      } else {
        lastCfg.oldShape = {x: parentOldX, y: parentOldY, width: 0, height: 0};
      }
    }
    lastCfg.fadein = !isGroup;
  }
}
function calculateZ2(depth, z2InLevel) {
  return depth * Z2_BASE + z2InLevel;
}
var TreemapView_default = TreemapView;

// src/visual/VisualMapping.ts
var each4 = each;
var isObject4 = isObject;
var CATEGORY_DEFAULT_VISUAL_INDEX = -1;
var VisualMapping2 = class {
  constructor(option) {
    const mappingMethod = option.mappingMethod;
    const visualType = option.type;
    const thisOption = this.option = clone(option);
    this.type = visualType;
    this.mappingMethod = mappingMethod;
    this._normalizeData = normalizers[mappingMethod];
    const visualHandler = VisualMapping2.visualHandlers[visualType];
    this.applyVisual = visualHandler.applyVisual;
    this.getColorMapper = visualHandler.getColorMapper;
    this._normalizedToVisual = visualHandler._normalizedToVisual[mappingMethod];
    if (mappingMethod === "piecewise") {
      normalizeVisualRange(thisOption);
      preprocessForPiecewise(thisOption);
    } else if (mappingMethod === "category") {
      thisOption.categories ? preprocessForSpecifiedCategory(thisOption) : normalizeVisualRange(thisOption, true);
    } else {
      assert(mappingMethod !== "linear" || thisOption.dataExtent);
      normalizeVisualRange(thisOption);
    }
  }
  mapValueToVisual(value) {
    const normalized = this._normalizeData(value);
    return this._normalizedToVisual(normalized, value);
  }
  getNormalizer() {
    return bind(this._normalizeData, this);
  }
  static listVisualTypes() {
    return keys(VisualMapping2.visualHandlers);
  }
  static isValidType(visualType) {
    return VisualMapping2.visualHandlers.hasOwnProperty(visualType);
  }
  static eachVisual(visual, callback, context) {
    if (isObject(visual)) {
      each(visual, callback, context);
    } else {
      callback.call(context, visual);
    }
  }
  static mapVisual(visual, callback, context) {
    let isPrimary;
    let newVisual = isArray(visual) ? [] : isObject(visual) ? {} : (isPrimary = true, null);
    VisualMapping2.eachVisual(visual, function(v, key) {
      const newVal = callback.call(context, v, key);
      isPrimary ? newVisual = newVal : newVisual[key] = newVal;
    });
    return newVisual;
  }
  static retrieveVisuals(obj) {
    const ret = {};
    let hasVisual;
    obj && each4(VisualMapping2.visualHandlers, function(h, visualType) {
      if (obj.hasOwnProperty(visualType)) {
        ret[visualType] = obj[visualType];
        hasVisual = true;
      }
    });
    return hasVisual ? ret : null;
  }
  static prepareVisualTypes(visualTypes) {
    if (isArray(visualTypes)) {
      visualTypes = visualTypes.slice();
    } else if (isObject4(visualTypes)) {
      const types = [];
      each4(visualTypes, function(item, type) {
        types.push(type);
      });
      visualTypes = types;
    } else {
      return [];
    }
    visualTypes.sort(function(type1, type2) {
      return type2 === "color" && type1 !== "color" && type1.indexOf("color") === 0 ? 1 : -1;
    });
    return visualTypes;
  }
  static dependsOn(visualType1, visualType2) {
    return visualType2 === "color" ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;
  }
  static findPieceIndex(value, pieceList, findClosestWhenOutside) {
    let possibleI;
    let abs2 = Infinity;
    for (let i = 0, len2 = pieceList.length; i < len2; i++) {
      const pieceValue = pieceList[i].value;
      if (pieceValue != null) {
        if (pieceValue === value || isString(pieceValue) && pieceValue === value + "") {
          return i;
        }
        findClosestWhenOutside && updatePossible(pieceValue, i);
      }
    }
    for (let i = 0, len2 = pieceList.length; i < len2; i++) {
      const piece = pieceList[i];
      const interval = piece.interval;
      const close = piece.close;
      if (interval) {
        if (interval[0] === -Infinity) {
          if (littleThan(close[1], value, interval[1])) {
            return i;
          }
        } else if (interval[1] === Infinity) {
          if (littleThan(close[0], interval[0], value)) {
            return i;
          }
        } else if (littleThan(close[0], interval[0], value) && littleThan(close[1], value, interval[1])) {
          return i;
        }
        findClosestWhenOutside && updatePossible(interval[0], i);
        findClosestWhenOutside && updatePossible(interval[1], i);
      }
    }
    if (findClosestWhenOutside) {
      return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;
    }
    function updatePossible(val, index) {
      const newAbs = Math.abs(val - value);
      if (newAbs < abs2) {
        abs2 = newAbs;
        possibleI = index;
      }
    }
  }
};
var VisualMapping = VisualMapping2;
VisualMapping.visualHandlers = {
  color: {
    applyVisual: makeApplyVisual("color"),
    getColorMapper: function() {
      const thisOption = this.option;
      return bind(thisOption.mappingMethod === "category" ? function(value, isNormalized) {
        !isNormalized && (value = this._normalizeData(value));
        return doMapCategory.call(this, value);
      } : function(value, isNormalized, out2) {
        const returnRGBArray = !!out2;
        !isNormalized && (value = this._normalizeData(value));
        out2 = fastLerp(value, thisOption.parsedVisual, out2);
        return returnRGBArray ? out2 : stringify(out2, "rgba");
      }, this);
    },
    _normalizedToVisual: {
      linear: function(normalized) {
        return stringify(fastLerp(normalized, this.option.parsedVisual), "rgba");
      },
      category: doMapCategory,
      piecewise: function(normalized, value) {
        let result = getSpecifiedVisual.call(this, value);
        if (result == null) {
          result = stringify(fastLerp(normalized, this.option.parsedVisual), "rgba");
        }
        return result;
      },
      fixed: doMapFixed
    }
  },
  colorHue: makePartialColorVisualHandler(function(color2, value) {
    return modifyHSL(color2, value);
  }),
  colorSaturation: makePartialColorVisualHandler(function(color2, value) {
    return modifyHSL(color2, null, value);
  }),
  colorLightness: makePartialColorVisualHandler(function(color2, value) {
    return modifyHSL(color2, null, null, value);
  }),
  colorAlpha: makePartialColorVisualHandler(function(color2, value) {
    return modifyAlpha(color2, value);
  }),
  decal: {
    applyVisual: makeApplyVisual("decal"),
    _normalizedToVisual: {
      linear: null,
      category: doMapCategory,
      piecewise: null,
      fixed: null
    }
  },
  opacity: {
    applyVisual: makeApplyVisual("opacity"),
    _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
  },
  liftZ: {
    applyVisual: makeApplyVisual("liftZ"),
    _normalizedToVisual: {
      linear: doMapFixed,
      category: doMapFixed,
      piecewise: doMapFixed,
      fixed: doMapFixed
    }
  },
  symbol: {
    applyVisual: function(value, getter, setter) {
      const symbolCfg = this.mapValueToVisual(value);
      setter("symbol", symbolCfg);
    },
    _normalizedToVisual: {
      linear: doMapToArray,
      category: doMapCategory,
      piecewise: function(normalized, value) {
        let result = getSpecifiedVisual.call(this, value);
        if (result == null) {
          result = doMapToArray.call(this, normalized);
        }
        return result;
      },
      fixed: doMapFixed
    }
  },
  symbolSize: {
    applyVisual: makeApplyVisual("symbolSize"),
    _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
  }
};
function preprocessForPiecewise(thisOption) {
  const pieceList = thisOption.pieceList;
  thisOption.hasSpecialVisual = false;
  each(pieceList, function(piece, index) {
    piece.originIndex = index;
    if (piece.visual != null) {
      thisOption.hasSpecialVisual = true;
    }
  });
}
function preprocessForSpecifiedCategory(thisOption) {
  const categories = thisOption.categories;
  const categoryMap = thisOption.categoryMap = {};
  let visual = thisOption.visual;
  each4(categories, function(cate, index) {
    categoryMap[cate] = index;
  });
  if (!isArray(visual)) {
    const visualArr = [];
    if (isObject(visual)) {
      each4(visual, function(v, cate) {
        const index = categoryMap[cate];
        visualArr[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;
      });
    } else {
      visualArr[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;
    }
    visual = setVisualToOption(thisOption, visualArr);
  }
  for (let i = categories.length - 1; i >= 0; i--) {
    if (visual[i] == null) {
      delete categoryMap[categories[i]];
      categories.pop();
    }
  }
}
function normalizeVisualRange(thisOption, isCategory2) {
  const visual = thisOption.visual;
  const visualArr = [];
  if (isObject(visual)) {
    each4(visual, function(v) {
      visualArr.push(v);
    });
  } else if (visual != null) {
    visualArr.push(visual);
  }
  const doNotNeedPair = {color: 1, symbol: 1};
  if (!isCategory2 && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {
    visualArr[1] = visualArr[0];
  }
  setVisualToOption(thisOption, visualArr);
}
function makePartialColorVisualHandler(applyValue) {
  return {
    applyVisual: function(value, getter, setter) {
      const colorChannel = this.mapValueToVisual(value);
      setter("color", applyValue(getter("color"), colorChannel));
    },
    _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
  };
}
function doMapToArray(normalized) {
  const visual = this.option.visual;
  return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {};
}
function makeApplyVisual(visualType) {
  return function(value, getter, setter) {
    setter(visualType, this.mapValueToVisual(value));
  };
}
function doMapCategory(normalized) {
  const visual = this.option.visual;
  return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];
}
function doMapFixed() {
  return this.option.visual[0];
}
function createNormalizedToNumericVisual(sourceExtent) {
  return {
    linear: function(normalized) {
      return linearMap(normalized, sourceExtent, this.option.visual, true);
    },
    category: doMapCategory,
    piecewise: function(normalized, value) {
      let result = getSpecifiedVisual.call(this, value);
      if (result == null) {
        result = linearMap(normalized, sourceExtent, this.option.visual, true);
      }
      return result;
    },
    fixed: doMapFixed
  };
}
function getSpecifiedVisual(value) {
  const thisOption = this.option;
  const pieceList = thisOption.pieceList;
  if (thisOption.hasSpecialVisual) {
    const pieceIndex = VisualMapping.findPieceIndex(value, pieceList);
    const piece = pieceList[pieceIndex];
    if (piece && piece.visual) {
      return piece.visual[this.type];
    }
  }
}
function setVisualToOption(thisOption, visualArr) {
  thisOption.visual = visualArr;
  if (thisOption.type === "color") {
    thisOption.parsedVisual = map(visualArr, function(item) {
      const color2 = parse(item);
      if (!color2 && true) {
        warn(`'${item}' is an illegal color, fallback to '#000000'`, true);
      }
      return color2 || [0, 0, 0, 1];
    });
  }
  return visualArr;
}
var normalizers = {
  linear: function(value) {
    return linearMap(value, this.option.dataExtent, [0, 1], true);
  },
  piecewise: function(value) {
    const pieceList = this.option.pieceList;
    const pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);
    if (pieceIndex != null) {
      return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);
    }
  },
  category: function(value) {
    const index = this.option.categories ? this.option.categoryMap[value] : value;
    return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;
  },
  fixed: noop
};
function littleThan(close, a, b) {
  return close ? a <= b : a < b;
}
var VisualMapping_default = VisualMapping;

// src/chart/treemap/treemapVisual.ts
var ITEM_STYLE_NORMAL = "itemStyle";
var inner10 = makeInner();
var treemapVisual_default = {
  seriesType: "treemap",
  reset(seriesModel) {
    const tree = seriesModel.getData().tree;
    const root = tree.root;
    if (root.isRemoved()) {
      return;
    }
    travelTree(root, {}, seriesModel.getViewRoot().getAncestors(), seriesModel);
  }
};
function travelTree(node, designatedVisual, viewRootAncestors, seriesModel) {
  const nodeModel = node.getModel();
  const nodeLayout = node.getLayout();
  const data = node.hostTree.data;
  if (!nodeLayout || nodeLayout.invisible || !nodeLayout.isInView) {
    return;
  }
  const nodeItemStyleModel = nodeModel.getModel(ITEM_STYLE_NORMAL);
  const visuals = buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel);
  const existsStyle = data.ensureUniqueItemVisual(node.dataIndex, "style");
  let borderColor = nodeItemStyleModel.get("borderColor");
  const borderColorSaturation = nodeItemStyleModel.get("borderColorSaturation");
  let thisNodeColor;
  if (borderColorSaturation != null) {
    thisNodeColor = calculateColor(visuals);
    borderColor = calculateBorderColor(borderColorSaturation, thisNodeColor);
  }
  existsStyle.stroke = borderColor;
  const viewChildren = node.viewChildren;
  if (!viewChildren || !viewChildren.length) {
    thisNodeColor = calculateColor(visuals);
    existsStyle.fill = thisNodeColor;
  } else {
    const mapping = buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren);
    each(viewChildren, function(child, index) {
      if (child.depth >= viewRootAncestors.length || child === viewRootAncestors[child.depth]) {
        const childVisual = mapVisual(nodeModel, visuals, child, index, mapping, seriesModel);
        travelTree(child, childVisual, viewRootAncestors, seriesModel);
      }
    });
  }
}
function buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel) {
  const visuals = extend({}, designatedVisual);
  const designatedVisualItemStyle = seriesModel.designatedVisualItemStyle;
  each(["color", "colorAlpha", "colorSaturation"], function(visualName) {
    designatedVisualItemStyle[visualName] = designatedVisual[visualName];
    const val = nodeItemStyleModel.get(visualName);
    designatedVisualItemStyle[visualName] = null;
    val != null && (visuals[visualName] = val);
  });
  return visuals;
}
function calculateColor(visuals) {
  let color2 = getValueVisualDefine(visuals, "color");
  if (color2) {
    const colorAlpha = getValueVisualDefine(visuals, "colorAlpha");
    const colorSaturation = getValueVisualDefine(visuals, "colorSaturation");
    if (colorSaturation) {
      color2 = modifyHSL(color2, null, null, colorSaturation);
    }
    if (colorAlpha) {
      color2 = modifyAlpha(color2, colorAlpha);
    }
    return color2;
  }
}
function calculateBorderColor(borderColorSaturation, thisNodeColor) {
  return thisNodeColor != null ? modifyHSL(thisNodeColor, null, null, borderColorSaturation) : null;
}
function getValueVisualDefine(visuals, name) {
  const value = visuals[name];
  if (value != null && value !== "none") {
    return value;
  }
}
function buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren) {
  if (!viewChildren || !viewChildren.length) {
    return;
  }
  const rangeVisual = getRangeVisual(nodeModel, "color") || visuals.color != null && visuals.color !== "none" && (getRangeVisual(nodeModel, "colorAlpha") || getRangeVisual(nodeModel, "colorSaturation"));
  if (!rangeVisual) {
    return;
  }
  const visualMin = nodeModel.get("visualMin");
  const visualMax = nodeModel.get("visualMax");
  const dataExtent = nodeLayout.dataExtent.slice();
  visualMin != null && visualMin < dataExtent[0] && (dataExtent[0] = visualMin);
  visualMax != null && visualMax > dataExtent[1] && (dataExtent[1] = visualMax);
  const colorMappingBy = nodeModel.get("colorMappingBy");
  const opt = {
    type: rangeVisual.name,
    dataExtent,
    visual: rangeVisual.range
  };
  if (opt.type === "color" && (colorMappingBy === "index" || colorMappingBy === "id")) {
    opt.mappingMethod = "category";
    opt.loop = true;
  } else {
    opt.mappingMethod = "linear";
  }
  const mapping = new VisualMapping_default(opt);
  inner10(mapping).drColorMappingBy = colorMappingBy;
  return mapping;
}
function getRangeVisual(nodeModel, name) {
  const range = nodeModel.get(name);
  return isArray(range) && range.length ? {
    name,
    range
  } : null;
}
function mapVisual(nodeModel, visuals, child, index, mapping, seriesModel) {
  const childVisuals = extend({}, visuals);
  if (mapping) {
    const mappingType = mapping.type;
    const colorMappingBy = mappingType === "color" && inner10(mapping).drColorMappingBy;
    const value = colorMappingBy === "index" ? index : colorMappingBy === "id" ? seriesModel.mapIdToIndex(child.getId()) : child.getValue(nodeModel.get("visualDimension"));
    childVisuals[mappingType] = mapping.mapValueToVisual(value);
  }
  return childVisuals;
}

// src/chart/treemap/treemapLayout.ts
var mathMax8 = Math.max;
var mathMin8 = Math.min;
var retrieveValue = retrieve;
var each5 = each;
var PATH_BORDER_WIDTH = ["itemStyle", "borderWidth"];
var PATH_GAP_WIDTH = ["itemStyle", "gapWidth"];
var PATH_UPPER_LABEL_SHOW = ["upperLabel", "show"];
var PATH_UPPER_LABEL_HEIGHT = ["upperLabel", "height"];
var treemapLayout_default = {
  seriesType: "treemap",
  reset: function(seriesModel, ecModel, api2, payload) {
    const ecWidth = api2.getWidth();
    const ecHeight = api2.getHeight();
    const seriesOption = seriesModel.option;
    const layoutInfo = getLayoutRect(seriesModel.getBoxLayoutParams(), {
      width: api2.getWidth(),
      height: api2.getHeight()
    });
    const size = seriesOption.size || [];
    const containerWidth = parsePercent2(retrieveValue(layoutInfo.width, size[0]), ecWidth);
    const containerHeight = parsePercent2(retrieveValue(layoutInfo.height, size[1]), ecHeight);
    const payloadType = payload && payload.type;
    const types = ["treemapZoomToNode", "treemapRootToNode"];
    const targetInfo = retrieveTargetInfo(payload, types, seriesModel);
    const rootRect = payloadType === "treemapRender" || payloadType === "treemapMove" ? payload.rootRect : null;
    const viewRoot = seriesModel.getViewRoot();
    const viewAbovePath = getPathToRoot(viewRoot);
    if (payloadType !== "treemapMove") {
      const rootSize = payloadType === "treemapZoomToNode" ? estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) : rootRect ? [rootRect.width, rootRect.height] : [containerWidth, containerHeight];
      let sort4 = seriesOption.sort;
      if (sort4 && sort4 !== "asc" && sort4 !== "desc") {
        sort4 = "desc";
      }
      const options = {
        squareRatio: seriesOption.squareRatio,
        sort: sort4,
        leafDepth: seriesOption.leafDepth
      };
      viewRoot.hostTree.clearLayouts();
      let viewRootLayout = {
        x: 0,
        y: 0,
        width: rootSize[0],
        height: rootSize[1],
        area: rootSize[0] * rootSize[1]
      };
      viewRoot.setLayout(viewRootLayout);
      squarify(viewRoot, options, false, 0);
      viewRootLayout = viewRoot.getLayout();
      each5(viewAbovePath, function(node, index) {
        const childValue = (viewAbovePath[index + 1] || viewRoot).getValue();
        node.setLayout(extend({
          dataExtent: [childValue, childValue],
          borderWidth: 0,
          upperHeight: 0
        }, viewRootLayout));
      });
    }
    const treeRoot = seriesModel.getData().tree.root;
    treeRoot.setLayout(calculateRootPosition(layoutInfo, rootRect, targetInfo), true);
    seriesModel.setLayoutInfo(layoutInfo);
    prunning(treeRoot, new BoundingRect_default(-layoutInfo.x, -layoutInfo.y, ecWidth, ecHeight), viewAbovePath, viewRoot, 0);
  }
};
function squarify(node, options, hideChildren, depth) {
  let width;
  let height;
  if (node.isRemoved()) {
    return;
  }
  const thisLayout = node.getLayout();
  width = thisLayout.width;
  height = thisLayout.height;
  const nodeModel = node.getModel();
  const borderWidth = nodeModel.get(PATH_BORDER_WIDTH);
  const halfGapWidth = nodeModel.get(PATH_GAP_WIDTH) / 2;
  const upperLabelHeight = getUpperLabelHeight(nodeModel);
  const upperHeight = Math.max(borderWidth, upperLabelHeight);
  const layoutOffset = borderWidth - halfGapWidth;
  const layoutOffsetUpper = upperHeight - halfGapWidth;
  node.setLayout({
    borderWidth,
    upperHeight,
    upperLabelHeight
  }, true);
  width = mathMax8(width - 2 * layoutOffset, 0);
  height = mathMax8(height - layoutOffset - layoutOffsetUpper, 0);
  const totalArea = width * height;
  const viewChildren = initChildren(node, nodeModel, totalArea, options, hideChildren, depth);
  if (!viewChildren.length) {
    return;
  }
  const rect = {x: layoutOffset, y: layoutOffsetUpper, width, height};
  let rowFixedLength = mathMin8(width, height);
  let best = Infinity;
  const row = [];
  row.area = 0;
  for (let i = 0, len2 = viewChildren.length; i < len2; ) {
    const child = viewChildren[i];
    row.push(child);
    row.area += child.getLayout().area;
    const score = worst(row, rowFixedLength, options.squareRatio);
    if (score <= best) {
      i++;
      best = score;
    } else {
      row.area -= row.pop().getLayout().area;
      position(row, rowFixedLength, rect, halfGapWidth, false);
      rowFixedLength = mathMin8(rect.width, rect.height);
      row.length = row.area = 0;
      best = Infinity;
    }
  }
  if (row.length) {
    position(row, rowFixedLength, rect, halfGapWidth, true);
  }
  if (!hideChildren) {
    const childrenVisibleMin = nodeModel.get("childrenVisibleMin");
    if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {
      hideChildren = true;
    }
  }
  for (let i = 0, len2 = viewChildren.length; i < len2; i++) {
    squarify(viewChildren[i], options, hideChildren, depth + 1);
  }
}
function initChildren(node, nodeModel, totalArea, options, hideChildren, depth) {
  let viewChildren = node.children || [];
  let orderBy = options.sort;
  orderBy !== "asc" && orderBy !== "desc" && (orderBy = null);
  const overLeafDepth = options.leafDepth != null && options.leafDepth <= depth;
  if (hideChildren && !overLeafDepth) {
    return node.viewChildren = [];
  }
  viewChildren = filter(viewChildren, function(child) {
    return !child.isRemoved();
  });
  sort2(viewChildren, orderBy);
  const info = statistic(nodeModel, viewChildren, orderBy);
  if (info.sum === 0) {
    return node.viewChildren = [];
  }
  info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);
  if (info.sum === 0) {
    return node.viewChildren = [];
  }
  for (let i = 0, len2 = viewChildren.length; i < len2; i++) {
    const area = viewChildren[i].getValue() / info.sum * totalArea;
    viewChildren[i].setLayout({
      area
    });
  }
  if (overLeafDepth) {
    viewChildren.length && node.setLayout({
      isLeafRoot: true
    }, true);
    viewChildren.length = 0;
  }
  node.viewChildren = viewChildren;
  node.setLayout({
    dataExtent: info.dataExtent
  }, true);
  return viewChildren;
}
function filterByThreshold(nodeModel, totalArea, sum2, orderBy, orderedChildren) {
  if (!orderBy) {
    return sum2;
  }
  const visibleMin = nodeModel.get("visibleMin");
  const len2 = orderedChildren.length;
  let deletePoint = len2;
  for (let i = len2 - 1; i >= 0; i--) {
    const value = orderedChildren[orderBy === "asc" ? len2 - i - 1 : i].getValue();
    if (value / sum2 * totalArea < visibleMin) {
      deletePoint = i;
      sum2 -= value;
    }
  }
  orderBy === "asc" ? orderedChildren.splice(0, len2 - deletePoint) : orderedChildren.splice(deletePoint, len2 - deletePoint);
  return sum2;
}
function sort2(viewChildren, orderBy) {
  if (orderBy) {
    viewChildren.sort(function(a, b) {
      const diff = orderBy === "asc" ? a.getValue() - b.getValue() : b.getValue() - a.getValue();
      return diff === 0 ? orderBy === "asc" ? a.dataIndex - b.dataIndex : b.dataIndex - a.dataIndex : diff;
    });
  }
  return viewChildren;
}
function statistic(nodeModel, children, orderBy) {
  let sum2 = 0;
  for (let i = 0, len2 = children.length; i < len2; i++) {
    sum2 += children[i].getValue();
  }
  const dimension = nodeModel.get("visualDimension");
  let dataExtent;
  if (!children || !children.length) {
    dataExtent = [NaN, NaN];
  } else if (dimension === "value" && orderBy) {
    dataExtent = [
      children[children.length - 1].getValue(),
      children[0].getValue()
    ];
    orderBy === "asc" && dataExtent.reverse();
  } else {
    dataExtent = [Infinity, -Infinity];
    each5(children, function(child) {
      const value = child.getValue(dimension);
      value < dataExtent[0] && (dataExtent[0] = value);
      value > dataExtent[1] && (dataExtent[1] = value);
    });
  }
  return {sum: sum2, dataExtent};
}
function worst(row, rowFixedLength, ratio) {
  let areaMax = 0;
  let areaMin = Infinity;
  for (let i = 0, area, len2 = row.length; i < len2; i++) {
    area = row[i].getLayout().area;
    if (area) {
      area < areaMin && (areaMin = area);
      area > areaMax && (areaMax = area);
    }
  }
  const squareArea = row.area * row.area;
  const f = rowFixedLength * rowFixedLength * ratio;
  return squareArea ? mathMax8(f * areaMax / squareArea, squareArea / (f * areaMin)) : Infinity;
}
function position(row, rowFixedLength, rect, halfGapWidth, flush) {
  const idx0WhenH = rowFixedLength === rect.width ? 0 : 1;
  const idx1WhenH = 1 - idx0WhenH;
  const xy = ["x", "y"];
  const wh = ["width", "height"];
  let last = rect[xy[idx0WhenH]];
  let rowOtherLength = rowFixedLength ? row.area / rowFixedLength : 0;
  if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {
    rowOtherLength = rect[wh[idx1WhenH]];
  }
  for (let i = 0, rowLen = row.length; i < rowLen; i++) {
    const node = row[i];
    const nodeLayout = {};
    const step = rowOtherLength ? node.getLayout().area / rowOtherLength : 0;
    const wh1 = nodeLayout[wh[idx1WhenH]] = mathMax8(rowOtherLength - 2 * halfGapWidth, 0);
    const remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;
    const modWH = i === rowLen - 1 || remain < step ? remain : step;
    const wh0 = nodeLayout[wh[idx0WhenH]] = mathMax8(modWH - 2 * halfGapWidth, 0);
    nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin8(halfGapWidth, wh1 / 2);
    nodeLayout[xy[idx0WhenH]] = last + mathMin8(halfGapWidth, wh0 / 2);
    last += modWH;
    node.setLayout(nodeLayout, true);
  }
  rect[xy[idx1WhenH]] += rowOtherLength;
  rect[wh[idx1WhenH]] -= rowOtherLength;
}
function estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {
  let currNode = (targetInfo || {}).node;
  const defaultSize = [containerWidth, containerHeight];
  if (!currNode || currNode === viewRoot) {
    return defaultSize;
  }
  let parent;
  const viewArea = containerWidth * containerHeight;
  let area = viewArea * seriesModel.option.zoomToNodeRatio;
  while (parent = currNode.parentNode) {
    let sum2 = 0;
    const siblings = parent.children;
    for (let i = 0, len2 = siblings.length; i < len2; i++) {
      sum2 += siblings[i].getValue();
    }
    const currNodeValue = currNode.getValue();
    if (currNodeValue === 0) {
      return defaultSize;
    }
    area *= sum2 / currNodeValue;
    const parentModel = parent.getModel();
    const borderWidth = parentModel.get(PATH_BORDER_WIDTH);
    const upperHeight = Math.max(borderWidth, getUpperLabelHeight(parentModel));
    area += 4 * borderWidth * borderWidth + (3 * borderWidth + upperHeight) * Math.pow(area, 0.5);
    area > MAX_SAFE_INTEGER && (area = MAX_SAFE_INTEGER);
    currNode = parent;
  }
  area < viewArea && (area = viewArea);
  const scale4 = Math.pow(area / viewArea, 0.5);
  return [containerWidth * scale4, containerHeight * scale4];
}
function calculateRootPosition(layoutInfo, rootRect, targetInfo) {
  if (rootRect) {
    return {x: rootRect.x, y: rootRect.y};
  }
  const defaultPosition = {x: 0, y: 0};
  if (!targetInfo) {
    return defaultPosition;
  }
  const targetNode = targetInfo.node;
  const layout18 = targetNode.getLayout();
  if (!layout18) {
    return defaultPosition;
  }
  const targetCenter = [layout18.width / 2, layout18.height / 2];
  let node = targetNode;
  while (node) {
    const nodeLayout = node.getLayout();
    targetCenter[0] += nodeLayout.x;
    targetCenter[1] += nodeLayout.y;
    node = node.parentNode;
  }
  return {
    x: layoutInfo.width / 2 - targetCenter[0],
    y: layoutInfo.height / 2 - targetCenter[1]
  };
}
function prunning(node, clipRect, viewAbovePath, viewRoot, depth) {
  const nodeLayout = node.getLayout();
  const nodeInViewAbovePath = viewAbovePath[depth];
  const isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node;
  if (nodeInViewAbovePath && !isAboveViewRoot || depth === viewAbovePath.length && node !== viewRoot) {
    return;
  }
  node.setLayout({
    isInView: true,
    invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),
    isAboveViewRoot
  }, true);
  const childClipRect = new BoundingRect_default(clipRect.x - nodeLayout.x, clipRect.y - nodeLayout.y, clipRect.width, clipRect.height);
  each5(node.viewChildren || [], function(child) {
    prunning(child, childClipRect, viewAbovePath, viewRoot, depth + 1);
  });
}
function getUpperLabelHeight(model) {
  return model.get(PATH_UPPER_LABEL_SHOW) ? model.get(PATH_UPPER_LABEL_HEIGHT) : 0;
}

// src/chart/treemap/install.ts
function install13(registers) {
  registers.registerSeriesModel(TreemapSeries_default);
  registers.registerChartView(TreemapView_default);
  registers.registerVisual(treemapVisual_default);
  registers.registerLayout(treemapLayout_default);
  installTreemapAction(registers);
}

// src/chart/graph/categoryFilter.ts
function categoryFilter(ecModel) {
  const legendModels = ecModel.findComponents({
    mainType: "legend"
  });
  if (!legendModels || !legendModels.length) {
    return;
  }
  ecModel.eachSeriesByType("graph", function(graphSeries) {
    const categoriesData = graphSeries.getCategoriesData();
    const graph = graphSeries.getGraph();
    const data = graph.data;
    const categoryNames = categoriesData.mapArray(categoriesData.getName);
    data.filterSelf(function(idx) {
      const model = data.getItemModel(idx);
      let category = model.getShallow("category");
      if (category != null) {
        if (isNumber(category)) {
          category = categoryNames[category];
        }
        for (let i = 0; i < legendModels.length; i++) {
          if (!legendModels[i].isSelected(category)) {
            return false;
          }
        }
      }
      return true;
    });
  });
}

// src/chart/graph/categoryVisual.ts
function categoryVisual(ecModel) {
  const paletteScope = {};
  ecModel.eachSeriesByType("graph", function(seriesModel) {
    const categoriesData = seriesModel.getCategoriesData();
    const data = seriesModel.getData();
    const categoryNameIdxMap = {};
    categoriesData.each(function(idx) {
      const name = categoriesData.getName(idx);
      categoryNameIdxMap["ec-" + name] = idx;
      const itemModel = categoriesData.getItemModel(idx);
      const style = itemModel.getModel("itemStyle").getItemStyle();
      if (!style.fill) {
        style.fill = seriesModel.getColorFromPalette(name, paletteScope);
      }
      categoriesData.setItemVisual(idx, "style", style);
      const symbolVisualList = ["symbol", "symbolSize", "symbolKeepAspect"];
      for (let i = 0; i < symbolVisualList.length; i++) {
        const symbolVisual = itemModel.getShallow(symbolVisualList[i], true);
        if (symbolVisual != null) {
          categoriesData.setItemVisual(idx, symbolVisualList[i], symbolVisual);
        }
      }
    });
    if (categoriesData.count()) {
      data.each(function(idx) {
        const model = data.getItemModel(idx);
        let categoryIdx = model.getShallow("category");
        if (categoryIdx != null) {
          if (isString(categoryIdx)) {
            categoryIdx = categoryNameIdxMap["ec-" + categoryIdx];
          }
          const categoryStyle = categoriesData.getItemVisual(categoryIdx, "style");
          const style = data.ensureUniqueItemVisual(idx, "style");
          extend(style, categoryStyle);
          const visualList = ["symbol", "symbolSize", "symbolKeepAspect"];
          for (let i = 0; i < visualList.length; i++) {
            data.setItemVisual(idx, visualList[i], categoriesData.getItemVisual(categoryIdx, visualList[i]));
          }
        }
      });
    }
  });
}

// src/chart/graph/edgeVisual.ts
function normalize3(a) {
  if (!(a instanceof Array)) {
    a = [a, a];
  }
  return a;
}
function graphEdgeVisual(ecModel) {
  ecModel.eachSeriesByType("graph", function(seriesModel) {
    const graph = seriesModel.getGraph();
    const edgeData = seriesModel.getEdgeData();
    const symbolType = normalize3(seriesModel.get("edgeSymbol"));
    const symbolSize = normalize3(seriesModel.get("edgeSymbolSize"));
    edgeData.setVisual("fromSymbol", symbolType && symbolType[0]);
    edgeData.setVisual("toSymbol", symbolType && symbolType[1]);
    edgeData.setVisual("fromSymbolSize", symbolSize && symbolSize[0]);
    edgeData.setVisual("toSymbolSize", symbolSize && symbolSize[1]);
    edgeData.setVisual("style", seriesModel.getModel("lineStyle").getLineStyle());
    edgeData.each(function(idx) {
      const itemModel = edgeData.getItemModel(idx);
      const edge = graph.getEdgeByIndex(idx);
      const symbolType2 = normalize3(itemModel.getShallow("symbol", true));
      const symbolSize2 = normalize3(itemModel.getShallow("symbolSize", true));
      const style = itemModel.getModel("lineStyle").getLineStyle();
      const existsStyle = edgeData.ensureUniqueItemVisual(idx, "style");
      extend(existsStyle, style);
      switch (existsStyle.stroke) {
        case "source": {
          const nodeStyle = edge.node1.getVisual("style");
          existsStyle.stroke = nodeStyle && nodeStyle.fill;
          break;
        }
        case "target": {
          const nodeStyle = edge.node2.getVisual("style");
          existsStyle.stroke = nodeStyle && nodeStyle.fill;
          break;
        }
      }
      symbolType2[0] && edge.setVisual("fromSymbol", symbolType2[0]);
      symbolType2[1] && edge.setVisual("toSymbol", symbolType2[1]);
      symbolSize2[0] && edge.setVisual("fromSymbolSize", symbolSize2[0]);
      symbolSize2[1] && edge.setVisual("toSymbolSize", symbolSize2[1]);
    });
  });
}

// src/chart/helper/multipleGraphEdgeHelper.ts
var KEY_DELIMITER = "-->";
var getAutoCurvenessParams = function(seriesModel) {
  return seriesModel.get("autoCurveness") || null;
};
var createCurveness = function(seriesModel, appendLength) {
  const autoCurvenessParmas = getAutoCurvenessParams(seriesModel);
  let length2 = 20;
  let curvenessList = [];
  if (isNumber(autoCurvenessParmas)) {
    length2 = autoCurvenessParmas;
  } else if (isArray(autoCurvenessParmas)) {
    seriesModel.__curvenessList = autoCurvenessParmas;
    return;
  }
  if (appendLength > length2) {
    length2 = appendLength;
  }
  const len2 = length2 % 2 ? length2 + 2 : length2 + 3;
  curvenessList = [];
  for (let i = 0; i < len2; i++) {
    curvenessList.push((i % 2 ? i + 1 : i) / 10 * (i % 2 ? -1 : 1));
  }
  seriesModel.__curvenessList = curvenessList;
};
var getKeyOfEdges = function(n1, n2, seriesModel) {
  const source = [n1.id, n1.dataIndex].join(".");
  const target = [n2.id, n2.dataIndex].join(".");
  return [seriesModel.uid, source, target].join(KEY_DELIMITER);
};
var getOppositeKey = function(key) {
  const keys2 = key.split(KEY_DELIMITER);
  return [keys2[0], keys2[2], keys2[1]].join(KEY_DELIMITER);
};
var getEdgeFromMap = function(edge, seriesModel) {
  const key = getKeyOfEdges(edge.node1, edge.node2, seriesModel);
  return seriesModel.__edgeMap[key];
};
var getTotalLengthBetweenNodes = function(edge, seriesModel) {
  const len2 = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node1, edge.node2, seriesModel), seriesModel);
  const lenV = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node2, edge.node1, seriesModel), seriesModel);
  return len2 + lenV;
};
var getEdgeMapLengthWithKey = function(key, seriesModel) {
  const edgeMap = seriesModel.__edgeMap;
  return edgeMap[key] ? edgeMap[key].length : 0;
};
function initCurvenessList(seriesModel) {
  if (!getAutoCurvenessParams(seriesModel)) {
    return;
  }
  seriesModel.__curvenessList = [];
  seriesModel.__edgeMap = {};
  createCurveness(seriesModel);
}
function createEdgeMapForCurveness(n1, n2, seriesModel, index) {
  if (!getAutoCurvenessParams(seriesModel)) {
    return;
  }
  const key = getKeyOfEdges(n1, n2, seriesModel);
  const edgeMap = seriesModel.__edgeMap;
  const oppositeEdges = edgeMap[getOppositeKey(key)];
  if (edgeMap[key] && !oppositeEdges) {
    edgeMap[key].isForward = true;
  } else if (oppositeEdges && edgeMap[key]) {
    oppositeEdges.isForward = true;
    edgeMap[key].isForward = false;
  }
  edgeMap[key] = edgeMap[key] || [];
  edgeMap[key].push(index);
}
function getCurvenessForEdge(edge, seriesModel, index, needReverse) {
  const autoCurvenessParams = getAutoCurvenessParams(seriesModel);
  const isArrayParam = isArray(autoCurvenessParams);
  if (!autoCurvenessParams) {
    return null;
  }
  const edgeArray = getEdgeFromMap(edge, seriesModel);
  if (!edgeArray) {
    return null;
  }
  let edgeIndex = -1;
  for (let i = 0; i < edgeArray.length; i++) {
    if (edgeArray[i] === index) {
      edgeIndex = i;
      break;
    }
  }
  const totalLen = getTotalLengthBetweenNodes(edge, seriesModel);
  createCurveness(seriesModel, totalLen);
  edge.lineStyle = edge.lineStyle || {};
  const curKey = getKeyOfEdges(edge.node1, edge.node2, seriesModel);
  const curvenessList = seriesModel.__curvenessList;
  const parityCorrection = isArrayParam ? 0 : totalLen % 2 ? 0 : 1;
  if (!edgeArray.isForward) {
    const oppositeKey = getOppositeKey(curKey);
    const len2 = getEdgeMapLengthWithKey(oppositeKey, seriesModel);
    const resValue = curvenessList[edgeIndex + len2 + parityCorrection];
    if (needReverse) {
      if (isArrayParam) {
        if (autoCurvenessParams && autoCurvenessParams[0] === 0) {
          return (len2 + parityCorrection) % 2 ? resValue : -resValue;
        } else {
          return ((len2 % 2 ? 0 : 1) + parityCorrection) % 2 ? resValue : -resValue;
        }
      } else {
        return (len2 + parityCorrection) % 2 ? resValue : -resValue;
      }
    } else {
      return curvenessList[edgeIndex + len2 + parityCorrection];
    }
  } else {
    return curvenessList[parityCorrection + edgeIndex];
  }
}

// src/chart/graph/simpleLayoutHelper.ts
function simpleLayout(seriesModel) {
  const coordSys = seriesModel.coordinateSystem;
  if (coordSys && coordSys.type !== "view") {
    return;
  }
  const graph = seriesModel.getGraph();
  graph.eachNode(function(node) {
    const model = node.getModel();
    node.setLayout([+model.get("x"), +model.get("y")]);
  });
  simpleLayoutEdge(graph, seriesModel);
}
function simpleLayoutEdge(graph, seriesModel) {
  graph.eachEdge(function(edge, index) {
    const curveness = retrieve3(edge.getModel().get(["lineStyle", "curveness"]), -getCurvenessForEdge(edge, seriesModel, index, true), 0);
    const p1 = clone2(edge.node1.getLayout());
    const p2 = clone2(edge.node2.getLayout());
    const points4 = [p1, p2];
    if (+curveness) {
      points4.push([
        (p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * curveness,
        (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * curveness
      ]);
    }
    edge.setLayout(points4);
  });
}

// src/chart/graph/simpleLayout.ts
function graphSimpleLayout(ecModel, api2) {
  ecModel.eachSeriesByType("graph", function(seriesModel) {
    const layout18 = seriesModel.get("layout");
    const coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.type !== "view") {
      const data = seriesModel.getData();
      let dimensions = [];
      each(coordSys.dimensions, function(coordDim) {
        dimensions = dimensions.concat(data.mapDimensionsAll(coordDim));
      });
      for (let dataIndex = 0; dataIndex < data.count(); dataIndex++) {
        const value = [];
        let hasValue = false;
        for (let i = 0; i < dimensions.length; i++) {
          const val = data.get(dimensions[i], dataIndex);
          if (!isNaN(val)) {
            hasValue = true;
          }
          value.push(val);
        }
        if (hasValue) {
          data.setItemLayout(dataIndex, coordSys.dataToPoint(value));
        } else {
          data.setItemLayout(dataIndex, [NaN, NaN]);
        }
      }
      simpleLayoutEdge(data.graph, seriesModel);
    } else if (!layout18 || layout18 === "none") {
      simpleLayout(seriesModel);
    }
  });
}

// src/chart/graph/graphHelper.ts
function getNodeGlobalScale(seriesModel) {
  const coordSys = seriesModel.coordinateSystem;
  if (coordSys.type !== "view") {
    return 1;
  }
  const nodeScaleRatio = seriesModel.option.nodeScaleRatio;
  const groupZoom = coordSys.scaleX;
  const roamZoom = coordSys.getZoom();
  const nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;
  return nodeScale / groupZoom;
}
function getSymbolSize(node) {
  let symbolSize = node.getVisual("symbolSize");
  if (symbolSize instanceof Array) {
    symbolSize = (symbolSize[0] + symbolSize[1]) / 2;
  }
  return +symbolSize;
}

// src/chart/graph/circularLayoutHelper.ts
var PI8 = Math.PI;
var _symbolRadiansHalf = [];
function circularLayout(seriesModel, basedOn, draggingNode, pointer) {
  const coordSys = seriesModel.coordinateSystem;
  if (coordSys && coordSys.type !== "view") {
    return;
  }
  const rect = coordSys.getBoundingRect();
  const nodeData = seriesModel.getData();
  const graph = nodeData.graph;
  const cx = rect.width / 2 + rect.x;
  const cy = rect.height / 2 + rect.y;
  const r = Math.min(rect.width, rect.height) / 2;
  const count2 = nodeData.count();
  nodeData.setLayout({
    cx,
    cy
  });
  if (!count2) {
    return;
  }
  if (draggingNode) {
    const [tempX, tempY] = coordSys.pointToData(pointer);
    const v = [tempX - cx, tempY - cy];
    normalize(v, v);
    scale(v, v, r);
    draggingNode.setLayout([cx + v[0], cy + v[1]], true);
    const circularRotateLabel = seriesModel.get(["circular", "rotateLabel"]);
    rotateNodeLabel(draggingNode, circularRotateLabel, cx, cy);
  }
  _layoutNodesBasedOn[basedOn](seriesModel, graph, nodeData, r, cx, cy, count2);
  graph.eachEdge(function(edge, index) {
    let curveness = retrieve3(edge.getModel().get(["lineStyle", "curveness"]), getCurvenessForEdge(edge, seriesModel, index), 0);
    const p1 = clone2(edge.node1.getLayout());
    const p2 = clone2(edge.node2.getLayout());
    let cp1;
    const x12 = (p1[0] + p2[0]) / 2;
    const y12 = (p1[1] + p2[1]) / 2;
    if (+curveness) {
      curveness *= 3;
      cp1 = [
        cx * curveness + x12 * (1 - curveness),
        cy * curveness + y12 * (1 - curveness)
      ];
    }
    edge.setLayout([p1, p2, cp1]);
  });
}
var _layoutNodesBasedOn = {
  value(seriesModel, graph, nodeData, r, cx, cy, count2) {
    let angle = 0;
    const sum2 = nodeData.getSum("value");
    const unitAngle = Math.PI * 2 / (sum2 || count2);
    graph.eachNode(function(node) {
      const value = node.getValue("value");
      const radianHalf = unitAngle * (sum2 ? value : 1) / 2;
      angle += radianHalf;
      node.setLayout([
        r * Math.cos(angle) + cx,
        r * Math.sin(angle) + cy
      ]);
      angle += radianHalf;
    });
  },
  symbolSize(seriesModel, graph, nodeData, r, cx, cy, count2) {
    let sumRadian = 0;
    _symbolRadiansHalf.length = count2;
    const nodeScale = getNodeGlobalScale(seriesModel);
    graph.eachNode(function(node) {
      let symbolSize = getSymbolSize(node);
      isNaN(symbolSize) && (symbolSize = 2);
      symbolSize < 0 && (symbolSize = 0);
      symbolSize *= nodeScale;
      let symbolRadianHalf = Math.asin(symbolSize / 2 / r);
      isNaN(symbolRadianHalf) && (symbolRadianHalf = PI8 / 2);
      _symbolRadiansHalf[node.dataIndex] = symbolRadianHalf;
      sumRadian += symbolRadianHalf * 2;
    });
    const halfRemainRadian = (2 * PI8 - sumRadian) / count2 / 2;
    let angle = 0;
    graph.eachNode(function(node) {
      const radianHalf = halfRemainRadian + _symbolRadiansHalf[node.dataIndex];
      angle += radianHalf;
      (!node.getLayout() || !node.getLayout().fixed) && node.setLayout([
        r * Math.cos(angle) + cx,
        r * Math.sin(angle) + cy
      ]);
      angle += radianHalf;
    });
  }
};
function rotateNodeLabel(node, circularRotateLabel, cx, cy) {
  const el = node.getGraphicEl();
  if (!el) {
    return;
  }
  const nodeModel = node.getModel();
  let labelRotate = nodeModel.get(["label", "rotate"]) || 0;
  const symbolPath = el.getSymbolPath();
  if (circularRotateLabel) {
    const pos = node.getLayout();
    let rad = Math.atan2(pos[1] - cy, pos[0] - cx);
    if (rad < 0) {
      rad = Math.PI * 2 + rad;
    }
    const isLeft = pos[0] < cx;
    if (isLeft) {
      rad = rad - Math.PI;
    }
    const textPosition = isLeft ? "left" : "right";
    symbolPath.setTextConfig({
      rotation: -rad,
      position: textPosition,
      origin: "center"
    });
    const emphasisState = symbolPath.ensureState("emphasis");
    extend(emphasisState.textConfig || (emphasisState.textConfig = {}), {
      position: textPosition
    });
  } else {
    symbolPath.setTextConfig({
      rotation: labelRotate *= Math.PI / 180
    });
  }
}

// src/chart/graph/circularLayout.ts
function graphCircularLayout(ecModel) {
  ecModel.eachSeriesByType("graph", function(seriesModel) {
    if (seriesModel.get("layout") === "circular") {
      circularLayout(seriesModel, "symbolSize");
    }
  });
}

// src/chart/graph/forceHelper.ts
var scaleAndAdd2 = scaleAndAdd;
function forceLayout(inNodes, inEdges, opts) {
  const nodes = inNodes;
  const edges = inEdges;
  const rect = opts.rect;
  const width = rect.width;
  const height = rect.height;
  const center3 = [rect.x + width / 2, rect.y + height / 2];
  const gravity = opts.gravity == null ? 0.1 : opts.gravity;
  for (let i = 0; i < nodes.length; i++) {
    const n = nodes[i];
    if (!n.p) {
      n.p = create(width * (Math.random() - 0.5) + center3[0], height * (Math.random() - 0.5) + center3[1]);
    }
    n.pp = clone2(n.p);
    n.edges = null;
  }
  const initialFriction = opts.friction == null ? 0.6 : opts.friction;
  let friction = initialFriction;
  let beforeStepCallback;
  let afterStepCallback;
  return {
    warmUp: function() {
      friction = initialFriction * 0.8;
    },
    setFixed: function(idx) {
      nodes[idx].fixed = true;
    },
    setUnfixed: function(idx) {
      nodes[idx].fixed = false;
    },
    beforeStep: function(cb) {
      beforeStepCallback = cb;
    },
    afterStep: function(cb) {
      afterStepCallback = cb;
    },
    step: function(cb) {
      beforeStepCallback && beforeStepCallback(nodes, edges);
      const v12 = [];
      const nLen = nodes.length;
      for (let i = 0; i < edges.length; i++) {
        const e2 = edges[i];
        if (e2.ignoreForceLayout) {
          continue;
        }
        const n1 = e2.n1;
        const n2 = e2.n2;
        sub(v12, n2.p, n1.p);
        const d = len(v12) - e2.d;
        let w = n2.w / (n1.w + n2.w);
        if (isNaN(w)) {
          w = 0;
        }
        normalize(v12, v12);
        !n1.fixed && scaleAndAdd2(n1.p, n1.p, v12, w * d * friction);
        !n2.fixed && scaleAndAdd2(n2.p, n2.p, v12, -(1 - w) * d * friction);
      }
      for (let i = 0; i < nLen; i++) {
        const n = nodes[i];
        if (!n.fixed) {
          sub(v12, center3, n.p);
          scaleAndAdd2(n.p, n.p, v12, gravity * friction);
        }
      }
      for (let i = 0; i < nLen; i++) {
        const n1 = nodes[i];
        for (let j = i + 1; j < nLen; j++) {
          const n2 = nodes[j];
          sub(v12, n2.p, n1.p);
          let d = len(v12);
          if (d === 0) {
            set(v12, Math.random() - 0.5, Math.random() - 0.5);
            d = 1;
          }
          const repFact = (n1.rep + n2.rep) / d / d;
          !n1.fixed && scaleAndAdd2(n1.pp, n1.pp, v12, repFact);
          !n2.fixed && scaleAndAdd2(n2.pp, n2.pp, v12, -repFact);
        }
      }
      const v = [];
      for (let i = 0; i < nLen; i++) {
        const n = nodes[i];
        if (!n.fixed) {
          sub(v, n.p, n.pp);
          scaleAndAdd2(n.p, n.p, v, friction);
          copy(n.pp, n.p);
        }
      }
      friction = friction * 0.992;
      const finished = friction < 0.01;
      afterStepCallback && afterStepCallback(nodes, edges, finished);
      cb && cb(finished);
    }
  };
}

// src/chart/graph/forceLayout.ts
function graphForceLayout(ecModel) {
  ecModel.eachSeriesByType("graph", function(graphSeries) {
    const coordSys = graphSeries.coordinateSystem;
    if (coordSys && coordSys.type !== "view") {
      return;
    }
    if (graphSeries.get("layout") === "force") {
      const preservedPoints = graphSeries.preservedPoints || {};
      const graph = graphSeries.getGraph();
      const nodeData = graph.data;
      const edgeData = graph.edgeData;
      const forceModel = graphSeries.getModel("force");
      const initLayout = forceModel.get("initLayout");
      if (graphSeries.preservedPoints) {
        nodeData.each(function(idx) {
          const id = nodeData.getId(idx);
          nodeData.setItemLayout(idx, preservedPoints[id] || [NaN, NaN]);
        });
      } else if (!initLayout || initLayout === "none") {
        simpleLayout(graphSeries);
      } else if (initLayout === "circular") {
        circularLayout(graphSeries, "value");
      }
      const nodeDataExtent = nodeData.getDataExtent("value");
      const edgeDataExtent = edgeData.getDataExtent("value");
      const repulsion = forceModel.get("repulsion");
      const edgeLength = forceModel.get("edgeLength");
      const repulsionArr = isArray(repulsion) ? repulsion : [repulsion, repulsion];
      let edgeLengthArr = isArray(edgeLength) ? edgeLength : [edgeLength, edgeLength];
      edgeLengthArr = [edgeLengthArr[1], edgeLengthArr[0]];
      const nodes = nodeData.mapArray("value", function(value, idx) {
        const point = nodeData.getItemLayout(idx);
        let rep = linearMap(value, nodeDataExtent, repulsionArr);
        if (isNaN(rep)) {
          rep = (repulsionArr[0] + repulsionArr[1]) / 2;
        }
        return {
          w: rep,
          rep,
          fixed: nodeData.getItemModel(idx).get("fixed"),
          p: !point || isNaN(point[0]) || isNaN(point[1]) ? null : point
        };
      });
      const edges = edgeData.mapArray("value", function(value, idx) {
        const edge = graph.getEdgeByIndex(idx);
        let d = linearMap(value, edgeDataExtent, edgeLengthArr);
        if (isNaN(d)) {
          d = (edgeLengthArr[0] + edgeLengthArr[1]) / 2;
        }
        const edgeModel = edge.getModel();
        const curveness = retrieve3(edge.getModel().get(["lineStyle", "curveness"]), -getCurvenessForEdge(edge, graphSeries, idx, true), 0);
        return {
          n1: nodes[edge.node1.dataIndex],
          n2: nodes[edge.node2.dataIndex],
          d,
          curveness,
          ignoreForceLayout: edgeModel.get("ignoreForceLayout")
        };
      });
      const rect = coordSys.getBoundingRect();
      const forceInstance = forceLayout(nodes, edges, {
        rect,
        gravity: forceModel.get("gravity"),
        friction: forceModel.get("friction")
      });
      forceInstance.beforeStep(function(nodes2, edges2) {
        for (let i = 0, l = nodes2.length; i < l; i++) {
          if (nodes2[i].fixed) {
            copy(nodes2[i].p, graph.getNodeByIndex(i).getLayout());
          }
        }
      });
      forceInstance.afterStep(function(nodes2, edges2, stopped) {
        for (let i = 0, l = nodes2.length; i < l; i++) {
          if (!nodes2[i].fixed) {
            graph.getNodeByIndex(i).setLayout(nodes2[i].p);
          }
          preservedPoints[nodeData.getId(i)] = nodes2[i].p;
        }
        for (let i = 0, l = edges2.length; i < l; i++) {
          const e2 = edges2[i];
          const edge = graph.getEdgeByIndex(i);
          const p1 = e2.n1.p;
          const p2 = e2.n2.p;
          let points4 = edge.getLayout();
          points4 = points4 ? points4.slice() : [];
          points4[0] = points4[0] || [];
          points4[1] = points4[1] || [];
          copy(points4[0], p1);
          copy(points4[1], p2);
          if (+e2.curveness) {
            points4[2] = [
              (p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * e2.curveness,
              (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * e2.curveness
            ];
          }
          edge.setLayout(points4);
        }
      });
      graphSeries.forceLayout = forceInstance;
      graphSeries.preservedPoints = preservedPoints;
      forceInstance.step();
    } else {
      graphSeries.forceLayout = null;
    }
  });
}

// src/chart/graph/createView.ts
function getViewRect3(seriesModel, api2, aspect) {
  const option = extend(seriesModel.getBoxLayoutParams(), {
    aspect
  });
  return getLayoutRect(option, {
    width: api2.getWidth(),
    height: api2.getHeight()
  });
}
function createViewCoordSys(ecModel, api2) {
  const viewList = [];
  ecModel.eachSeriesByType("graph", function(seriesModel) {
    const coordSysType = seriesModel.get("coordinateSystem");
    if (!coordSysType || coordSysType === "view") {
      const data = seriesModel.getData();
      const positions = data.mapArray(function(idx) {
        const itemModel = data.getItemModel(idx);
        return [+itemModel.get("x"), +itemModel.get("y")];
      });
      let min3 = [];
      let max3 = [];
      fromPoints(positions, min3, max3);
      if (max3[0] - min3[0] === 0) {
        max3[0] += 1;
        min3[0] -= 1;
      }
      if (max3[1] - min3[1] === 0) {
        max3[1] += 1;
        min3[1] -= 1;
      }
      const aspect = (max3[0] - min3[0]) / (max3[1] - min3[1]);
      const viewRect2 = getViewRect3(seriesModel, api2, aspect);
      if (isNaN(aspect)) {
        min3 = [viewRect2.x, viewRect2.y];
        max3 = [viewRect2.x + viewRect2.width, viewRect2.y + viewRect2.height];
      }
      const bbWidth = max3[0] - min3[0];
      const bbHeight = max3[1] - min3[1];
      const viewWidth = viewRect2.width;
      const viewHeight = viewRect2.height;
      const viewCoordSys = seriesModel.coordinateSystem = new View_default();
      viewCoordSys.zoomLimit = seriesModel.get("scaleLimit");
      viewCoordSys.setBoundingRect(min3[0], min3[1], bbWidth, bbHeight);
      viewCoordSys.setViewRect(viewRect2.x, viewRect2.y, viewWidth, viewHeight);
      viewCoordSys.setCenter(seriesModel.get("center"), api2);
      viewCoordSys.setZoom(seriesModel.get("zoom"));
      viewList.push(viewCoordSys);
    }
  });
  return viewList;
}

// src/chart/helper/LinePath.ts
var straightLineProto = Line_default.prototype;
var bezierCurveProto = BezierCurve_default.prototype;
var StraightLineShape = class {
  constructor() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.percent = 1;
  }
};
function isStraightLine(shape) {
  return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);
}
var ECLinePath = class extends Path_default {
  constructor(opts) {
    super(opts);
    this.type = "ec-line";
  }
  getDefaultStyle() {
    return {
      stroke: "#000",
      fill: null
    };
  }
  getDefaultShape() {
    return new StraightLineShape();
  }
  buildPath(ctx, shape) {
    if (isStraightLine(shape)) {
      straightLineProto.buildPath.call(this, ctx, shape);
    } else {
      bezierCurveProto.buildPath.call(this, ctx, shape);
    }
  }
  pointAt(t) {
    if (isStraightLine(this.shape)) {
      return straightLineProto.pointAt.call(this, t);
    } else {
      return bezierCurveProto.pointAt.call(this, t);
    }
  }
  tangentAt(t) {
    const shape = this.shape;
    const p = isStraightLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : bezierCurveProto.tangentAt.call(this, t);
    return normalize(p, p);
  }
};
var LinePath_default = ECLinePath;

// src/chart/helper/Line.ts
var SYMBOL_CATEGORIES = ["fromSymbol", "toSymbol"];
function makeSymbolTypeKey(symbolCategory) {
  return "_" + symbolCategory + "Type";
}
function makeSymbolTypeValue(name, lineData, idx) {
  const symbolType = lineData.getItemVisual(idx, name);
  if (!symbolType || symbolType === "none") {
    return symbolType;
  }
  const symbolSize = lineData.getItemVisual(idx, name + "Size");
  const symbolRotate = lineData.getItemVisual(idx, name + "Rotate");
  const symbolOffset = lineData.getItemVisual(idx, name + "Offset");
  const symbolKeepAspect = lineData.getItemVisual(idx, name + "KeepAspect");
  const symbolSizeArr = normalizeSymbolSize(symbolSize);
  const symbolOffsetArr = normalizeSymbolOffset(symbolOffset || 0, symbolSizeArr);
  return symbolType + symbolSizeArr + symbolOffsetArr + (symbolRotate || "") + (symbolKeepAspect || "");
}
function createSymbol2(name, lineData, idx) {
  const symbolType = lineData.getItemVisual(idx, name);
  if (!symbolType || symbolType === "none") {
    return;
  }
  const symbolSize = lineData.getItemVisual(idx, name + "Size");
  const symbolRotate = lineData.getItemVisual(idx, name + "Rotate");
  const symbolOffset = lineData.getItemVisual(idx, name + "Offset");
  const symbolKeepAspect = lineData.getItemVisual(idx, name + "KeepAspect");
  const symbolSizeArr = normalizeSymbolSize(symbolSize);
  const symbolOffsetArr = normalizeSymbolOffset(symbolOffset || 0, symbolSizeArr);
  const symbolPath = createSymbol(symbolType, -symbolSizeArr[0] / 2 + symbolOffsetArr[0], -symbolSizeArr[1] / 2 + symbolOffsetArr[1], symbolSizeArr[0], symbolSizeArr[1], null, symbolKeepAspect);
  symbolPath.__specifiedRotation = symbolRotate == null || isNaN(symbolRotate) ? void 0 : +symbolRotate * Math.PI / 180 || 0;
  symbolPath.name = name;
  return symbolPath;
}
function createLine(points4) {
  const line2 = new LinePath_default({
    name: "line",
    subPixelOptimize: true
  });
  setLinePoints(line2.shape, points4);
  return line2;
}
function setLinePoints(targetShape, points4) {
  targetShape.x1 = points4[0][0];
  targetShape.y1 = points4[0][1];
  targetShape.x2 = points4[1][0];
  targetShape.y2 = points4[1][1];
  targetShape.percent = 1;
  const cp1 = points4[2];
  if (cp1) {
    targetShape.cpx1 = cp1[0];
    targetShape.cpy1 = cp1[1];
  } else {
    targetShape.cpx1 = NaN;
    targetShape.cpy1 = NaN;
  }
}
var Line2 = class extends Group_default {
  constructor(lineData, idx, seriesScope) {
    super();
    this._createLine(lineData, idx, seriesScope);
  }
  _createLine(lineData, idx, seriesScope) {
    const seriesModel = lineData.hostModel;
    const linePoints = lineData.getItemLayout(idx);
    const line2 = createLine(linePoints);
    line2.shape.percent = 0;
    initProps(line2, {
      shape: {
        percent: 1
      }
    }, seriesModel, idx);
    this.add(line2);
    each(SYMBOL_CATEGORIES, function(symbolCategory) {
      const symbol = createSymbol2(symbolCategory, lineData, idx);
      this.add(symbol);
      this[makeSymbolTypeKey(symbolCategory)] = makeSymbolTypeValue(symbolCategory, lineData, idx);
    }, this);
    this._updateCommonStl(lineData, idx, seriesScope);
  }
  updateData(lineData, idx, seriesScope) {
    const seriesModel = lineData.hostModel;
    const line2 = this.childOfName("line");
    const linePoints = lineData.getItemLayout(idx);
    const target = {
      shape: {}
    };
    setLinePoints(target.shape, linePoints);
    updateProps(line2, target, seriesModel, idx);
    each(SYMBOL_CATEGORIES, function(symbolCategory) {
      const symbolType = makeSymbolTypeValue(symbolCategory, lineData, idx);
      const key = makeSymbolTypeKey(symbolCategory);
      if (this[key] !== symbolType) {
        this.remove(this.childOfName(symbolCategory));
        const symbol = createSymbol2(symbolCategory, lineData, idx);
        this.add(symbol);
      }
      this[key] = symbolType;
    }, this);
    this._updateCommonStl(lineData, idx, seriesScope);
  }
  getLinePath() {
    return this.childAt(0);
  }
  _updateCommonStl(lineData, idx, seriesScope) {
    const seriesModel = lineData.hostModel;
    const line2 = this.childOfName("line");
    let emphasisLineStyle = seriesScope && seriesScope.emphasisLineStyle;
    let blurLineStyle = seriesScope && seriesScope.blurLineStyle;
    let selectLineStyle = seriesScope && seriesScope.selectLineStyle;
    let labelStatesModels = seriesScope && seriesScope.labelStatesModels;
    let emphasisDisabled = seriesScope && seriesScope.emphasisDisabled;
    let focus = seriesScope && seriesScope.focus;
    let blurScope = seriesScope && seriesScope.blurScope;
    if (!seriesScope || lineData.hasItemOption) {
      const itemModel = lineData.getItemModel(idx);
      const emphasisModel = itemModel.getModel("emphasis");
      emphasisLineStyle = emphasisModel.getModel("lineStyle").getLineStyle();
      blurLineStyle = itemModel.getModel(["blur", "lineStyle"]).getLineStyle();
      selectLineStyle = itemModel.getModel(["select", "lineStyle"]).getLineStyle();
      emphasisDisabled = emphasisModel.get("disabled");
      focus = emphasisModel.get("focus");
      blurScope = emphasisModel.get("blurScope");
      labelStatesModels = getLabelStatesModels(itemModel);
    }
    const lineStyle = lineData.getItemVisual(idx, "style");
    const visualColor = lineStyle.stroke;
    line2.useStyle(lineStyle);
    line2.style.fill = null;
    line2.style.strokeNoScale = true;
    line2.ensureState("emphasis").style = emphasisLineStyle;
    line2.ensureState("blur").style = blurLineStyle;
    line2.ensureState("select").style = selectLineStyle;
    each(SYMBOL_CATEGORIES, function(symbolCategory) {
      const symbol = this.childOfName(symbolCategory);
      if (symbol) {
        symbol.setColor(visualColor);
        symbol.style.opacity = lineStyle.opacity;
        for (let i = 0; i < SPECIAL_STATES.length; i++) {
          const stateName = SPECIAL_STATES[i];
          const lineState = line2.getState(stateName);
          if (lineState) {
            const lineStateStyle = lineState.style || {};
            const state = symbol.ensureState(stateName);
            const stateStyle = state.style || (state.style = {});
            if (lineStateStyle.stroke != null) {
              stateStyle[symbol.__isEmptyBrush ? "stroke" : "fill"] = lineStateStyle.stroke;
            }
            if (lineStateStyle.opacity != null) {
              stateStyle.opacity = lineStateStyle.opacity;
            }
          }
        }
        symbol.markRedraw();
      }
    }, this);
    const rawVal = seriesModel.getRawValue(idx);
    setLabelStyle(this, labelStatesModels, {
      labelDataIndex: idx,
      labelFetcher: {
        getFormattedLabel(dataIndex, stateName) {
          return seriesModel.getFormattedLabel(dataIndex, stateName, lineData.dataType);
        }
      },
      inheritColor: visualColor || "#000",
      defaultOpacity: lineStyle.opacity,
      defaultText: (rawVal == null ? lineData.getName(idx) : isFinite(rawVal) ? round(rawVal) : rawVal) + ""
    });
    const label = this.getTextContent();
    if (label) {
      const labelNormalModel = labelStatesModels.normal;
      label.__align = label.style.align;
      label.__verticalAlign = label.style.verticalAlign;
      label.__position = labelNormalModel.get("position") || "middle";
      let distance2 = labelNormalModel.get("distance");
      if (!isArray(distance2)) {
        distance2 = [distance2, distance2];
      }
      label.__labelDistance = distance2;
    }
    this.setTextConfig({
      position: null,
      local: true,
      inside: false
    });
    toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
  }
  highlight() {
    enterEmphasis(this);
  }
  downplay() {
    leaveEmphasis(this);
  }
  updateLayout(lineData, idx) {
    this.setLinePoints(lineData.getItemLayout(idx));
  }
  setLinePoints(points4) {
    const linePath = this.childOfName("line");
    setLinePoints(linePath.shape, points4);
    linePath.dirty();
  }
  beforeUpdate() {
    const lineGroup = this;
    const symbolFrom = lineGroup.childOfName("fromSymbol");
    const symbolTo = lineGroup.childOfName("toSymbol");
    const label = lineGroup.getTextContent();
    if (!symbolFrom && !symbolTo && (!label || label.ignore)) {
      return;
    }
    let invScale = 1;
    let parentNode2 = this.parent;
    while (parentNode2) {
      if (parentNode2.scaleX) {
        invScale /= parentNode2.scaleX;
      }
      parentNode2 = parentNode2.parent;
    }
    const line2 = lineGroup.childOfName("line");
    if (!this.__dirty && !line2.__dirty) {
      return;
    }
    const percent = line2.shape.percent;
    const fromPos = line2.pointAt(0);
    const toPos = line2.pointAt(percent);
    const d = sub([], toPos, fromPos);
    normalize(d, d);
    function setSymbolRotation(symbol, percent2) {
      const specifiedRotation = symbol.__specifiedRotation;
      if (specifiedRotation == null) {
        const tangent = line2.tangentAt(percent2);
        symbol.attr("rotation", (percent2 === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
      } else {
        symbol.attr("rotation", specifiedRotation);
      }
    }
    if (symbolFrom) {
      symbolFrom.setPosition(fromPos);
      setSymbolRotation(symbolFrom, 0);
      symbolFrom.scaleX = symbolFrom.scaleY = invScale * percent;
      symbolFrom.markRedraw();
    }
    if (symbolTo) {
      symbolTo.setPosition(toPos);
      setSymbolRotation(symbolTo, 1);
      symbolTo.scaleX = symbolTo.scaleY = invScale * percent;
      symbolTo.markRedraw();
    }
    if (label && !label.ignore) {
      label.x = label.y = 0;
      label.originX = label.originY = 0;
      let textAlign;
      let textVerticalAlign;
      const distance2 = label.__labelDistance;
      const distanceX = distance2[0] * invScale;
      const distanceY = distance2[1] * invScale;
      const halfPercent = percent / 2;
      const tangent = line2.tangentAt(halfPercent);
      const n = [tangent[1], -tangent[0]];
      const cp = line2.pointAt(halfPercent);
      if (n[1] > 0) {
        n[0] = -n[0];
        n[1] = -n[1];
      }
      const dir3 = tangent[0] < 0 ? -1 : 1;
      if (label.__position !== "start" && label.__position !== "end") {
        let rotation = -Math.atan2(tangent[1], tangent[0]);
        if (toPos[0] < fromPos[0]) {
          rotation = Math.PI + rotation;
        }
        label.rotation = rotation;
      }
      let dy;
      switch (label.__position) {
        case "insideStartTop":
        case "insideMiddleTop":
        case "insideEndTop":
        case "middle":
          dy = -distanceY;
          textVerticalAlign = "bottom";
          break;
        case "insideStartBottom":
        case "insideMiddleBottom":
        case "insideEndBottom":
          dy = distanceY;
          textVerticalAlign = "top";
          break;
        default:
          dy = 0;
          textVerticalAlign = "middle";
      }
      switch (label.__position) {
        case "end":
          label.x = d[0] * distanceX + toPos[0];
          label.y = d[1] * distanceY + toPos[1];
          textAlign = d[0] > 0.8 ? "left" : d[0] < -0.8 ? "right" : "center";
          textVerticalAlign = d[1] > 0.8 ? "top" : d[1] < -0.8 ? "bottom" : "middle";
          break;
        case "start":
          label.x = -d[0] * distanceX + fromPos[0];
          label.y = -d[1] * distanceY + fromPos[1];
          textAlign = d[0] > 0.8 ? "right" : d[0] < -0.8 ? "left" : "center";
          textVerticalAlign = d[1] > 0.8 ? "bottom" : d[1] < -0.8 ? "top" : "middle";
          break;
        case "insideStartTop":
        case "insideStart":
        case "insideStartBottom":
          label.x = distanceX * dir3 + fromPos[0];
          label.y = fromPos[1] + dy;
          textAlign = tangent[0] < 0 ? "right" : "left";
          label.originX = -distanceX * dir3;
          label.originY = -dy;
          break;
        case "insideMiddleTop":
        case "insideMiddle":
        case "insideMiddleBottom":
        case "middle":
          label.x = cp[0];
          label.y = cp[1] + dy;
          textAlign = "center";
          label.originY = -dy;
          break;
        case "insideEndTop":
        case "insideEnd":
        case "insideEndBottom":
          label.x = -distanceX * dir3 + toPos[0];
          label.y = toPos[1] + dy;
          textAlign = tangent[0] >= 0 ? "right" : "left";
          label.originX = distanceX * dir3;
          label.originY = -dy;
          break;
      }
      label.scaleX = label.scaleY = invScale;
      label.setStyle({
        verticalAlign: label.__verticalAlign || textVerticalAlign,
        align: label.__align || textAlign
      });
    }
  }
};
var Line_default2 = Line2;

// src/chart/helper/LineDraw.ts
var LineDraw = class {
  constructor(LineCtor) {
    this.group = new Group_default();
    this._LineCtor = LineCtor || Line_default2;
  }
  updateData(lineData) {
    this._progressiveEls = null;
    const lineDraw = this;
    const group = lineDraw.group;
    const oldLineData = lineDraw._lineData;
    lineDraw._lineData = lineData;
    if (!oldLineData) {
      group.removeAll();
    }
    const seriesScope = makeSeriesScope2(lineData);
    lineData.diff(oldLineData).add((idx) => {
      this._doAdd(lineData, idx, seriesScope);
    }).update((newIdx, oldIdx) => {
      this._doUpdate(oldLineData, lineData, oldIdx, newIdx, seriesScope);
    }).remove((idx) => {
      group.remove(oldLineData.getItemGraphicEl(idx));
    }).execute();
  }
  updateLayout() {
    const lineData = this._lineData;
    if (!lineData) {
      return;
    }
    lineData.eachItemGraphicEl(function(el, idx) {
      el.updateLayout(lineData, idx);
    }, this);
  }
  incrementalPrepareUpdate(lineData) {
    this._seriesScope = makeSeriesScope2(lineData);
    this._lineData = null;
    this.group.removeAll();
  }
  incrementalUpdate(taskParams, lineData) {
    this._progressiveEls = [];
    function updateIncrementalAndHover(el) {
      if (!el.isGroup && !isEffectObject(el)) {
        el.incremental = true;
        el.ensureState("emphasis").hoverLayer = true;
      }
    }
    for (let idx = taskParams.start; idx < taskParams.end; idx++) {
      const itemLayout = lineData.getItemLayout(idx);
      if (lineNeedsDraw(itemLayout)) {
        const el = new this._LineCtor(lineData, idx, this._seriesScope);
        el.traverse(updateIncrementalAndHover);
        this.group.add(el);
        lineData.setItemGraphicEl(idx, el);
        this._progressiveEls.push(el);
      }
    }
  }
  remove() {
    this.group.removeAll();
  }
  eachRendered(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  }
  _doAdd(lineData, idx, seriesScope) {
    const itemLayout = lineData.getItemLayout(idx);
    if (!lineNeedsDraw(itemLayout)) {
      return;
    }
    const el = new this._LineCtor(lineData, idx, seriesScope);
    lineData.setItemGraphicEl(idx, el);
    this.group.add(el);
  }
  _doUpdate(oldLineData, newLineData, oldIdx, newIdx, seriesScope) {
    let itemEl = oldLineData.getItemGraphicEl(oldIdx);
    if (!lineNeedsDraw(newLineData.getItemLayout(newIdx))) {
      this.group.remove(itemEl);
      return;
    }
    if (!itemEl) {
      itemEl = new this._LineCtor(newLineData, newIdx, seriesScope);
    } else {
      itemEl.updateData(newLineData, newIdx, seriesScope);
    }
    newLineData.setItemGraphicEl(newIdx, itemEl);
    this.group.add(itemEl);
  }
};
function isEffectObject(el) {
  return el.animators && el.animators.length > 0;
}
function makeSeriesScope2(lineData) {
  const hostModel = lineData.hostModel;
  const emphasisModel = hostModel.getModel("emphasis");
  return {
    lineStyle: hostModel.getModel("lineStyle").getLineStyle(),
    emphasisLineStyle: emphasisModel.getModel(["lineStyle"]).getLineStyle(),
    blurLineStyle: hostModel.getModel(["blur", "lineStyle"]).getLineStyle(),
    selectLineStyle: hostModel.getModel(["select", "lineStyle"]).getLineStyle(),
    emphasisDisabled: emphasisModel.get("disabled"),
    blurScope: emphasisModel.get("blurScope"),
    focus: emphasisModel.get("focus"),
    labelStatesModels: getLabelStatesModels(hostModel)
  };
}
function isPointNaN(pt) {
  return isNaN(pt[0]) || isNaN(pt[1]);
}
function lineNeedsDraw(pts) {
  return pts && !isPointNaN(pts[0]) && !isPointNaN(pts[1]);
}
var LineDraw_default = LineDraw;

// src/chart/graph/adjustEdge.ts
var v1 = [];
var v2 = [];
var v3 = [];
var quadraticAt2 = quadraticAt;
var v2DistSquare = distSquare;
var mathAbs3 = Math.abs;
function intersectCurveCircle(curvePoints, center3, radius) {
  const p0 = curvePoints[0];
  const p1 = curvePoints[1];
  const p2 = curvePoints[2];
  let d = Infinity;
  let t;
  const radiusSquare = radius * radius;
  let interval = 0.1;
  for (let _t = 0.1; _t <= 0.9; _t += 0.1) {
    v1[0] = quadraticAt2(p0[0], p1[0], p2[0], _t);
    v1[1] = quadraticAt2(p0[1], p1[1], p2[1], _t);
    const diff = mathAbs3(v2DistSquare(v1, center3) - radiusSquare);
    if (diff < d) {
      d = diff;
      t = _t;
    }
  }
  for (let i = 0; i < 32; i++) {
    const next = t + interval;
    v2[0] = quadraticAt2(p0[0], p1[0], p2[0], t);
    v2[1] = quadraticAt2(p0[1], p1[1], p2[1], t);
    v3[0] = quadraticAt2(p0[0], p1[0], p2[0], next);
    v3[1] = quadraticAt2(p0[1], p1[1], p2[1], next);
    const diff = v2DistSquare(v2, center3) - radiusSquare;
    if (mathAbs3(diff) < 0.01) {
      break;
    }
    const nextDiff = v2DistSquare(v3, center3) - radiusSquare;
    interval /= 2;
    if (diff < 0) {
      if (nextDiff >= 0) {
        t = t + interval;
      } else {
        t = t - interval;
      }
    } else {
      if (nextDiff >= 0) {
        t = t - interval;
      } else {
        t = t + interval;
      }
    }
  }
  return t;
}
function adjustEdge(graph, scale4) {
  const tmp0 = [];
  const quadraticSubdivide2 = quadraticSubdivide;
  const pts = [[], [], []];
  const pts2 = [[], []];
  const v = [];
  scale4 /= 2;
  graph.eachEdge(function(edge, idx) {
    const linePoints = edge.getLayout();
    const fromSymbol = edge.getVisual("fromSymbol");
    const toSymbol = edge.getVisual("toSymbol");
    if (!linePoints.__original) {
      linePoints.__original = [
        clone2(linePoints[0]),
        clone2(linePoints[1])
      ];
      if (linePoints[2]) {
        linePoints.__original.push(clone2(linePoints[2]));
      }
    }
    const originalPoints = linePoints.__original;
    if (linePoints[2] != null) {
      copy(pts[0], originalPoints[0]);
      copy(pts[1], originalPoints[2]);
      copy(pts[2], originalPoints[1]);
      if (fromSymbol && fromSymbol !== "none") {
        const symbolSize = getSymbolSize(edge.node1);
        const t = intersectCurveCircle(pts, originalPoints[0], symbolSize * scale4);
        quadraticSubdivide2(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
        pts[0][0] = tmp0[3];
        pts[1][0] = tmp0[4];
        quadraticSubdivide2(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
        pts[0][1] = tmp0[3];
        pts[1][1] = tmp0[4];
      }
      if (toSymbol && toSymbol !== "none") {
        const symbolSize = getSymbolSize(edge.node2);
        const t = intersectCurveCircle(pts, originalPoints[1], symbolSize * scale4);
        quadraticSubdivide2(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
        pts[1][0] = tmp0[1];
        pts[2][0] = tmp0[2];
        quadraticSubdivide2(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
        pts[1][1] = tmp0[1];
        pts[2][1] = tmp0[2];
      }
      copy(linePoints[0], pts[0]);
      copy(linePoints[1], pts[2]);
      copy(linePoints[2], pts[1]);
    } else {
      copy(pts2[0], originalPoints[0]);
      copy(pts2[1], originalPoints[1]);
      sub(v, pts2[1], pts2[0]);
      normalize(v, v);
      if (fromSymbol && fromSymbol !== "none") {
        const symbolSize = getSymbolSize(edge.node1);
        scaleAndAdd(pts2[0], pts2[0], v, symbolSize * scale4);
      }
      if (toSymbol && toSymbol !== "none") {
        const symbolSize = getSymbolSize(edge.node2);
        scaleAndAdd(pts2[1], pts2[1], v, -symbolSize * scale4);
      }
      copy(linePoints[0], pts2[0]);
      copy(linePoints[1], pts2[1]);
    }
  });
}

// src/chart/graph/GraphView.ts
function isViewCoordSys(coordSys) {
  return coordSys.type === "view";
}
var GraphView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = GraphView2.type;
  }
  init(ecModel, api2) {
    const symbolDraw = new SymbolDraw_default();
    const lineDraw = new LineDraw_default();
    const group = this.group;
    this._controller = new RoamController_default(api2.getZr());
    this._controllerHost = {
      target: group
    };
    group.add(symbolDraw.group);
    group.add(lineDraw.group);
    this._symbolDraw = symbolDraw;
    this._lineDraw = lineDraw;
    this._firstRender = true;
  }
  render(seriesModel, ecModel, api2) {
    const coordSys = seriesModel.coordinateSystem;
    this._model = seriesModel;
    const symbolDraw = this._symbolDraw;
    const lineDraw = this._lineDraw;
    const group = this.group;
    if (isViewCoordSys(coordSys)) {
      const groupNewProp = {
        x: coordSys.x,
        y: coordSys.y,
        scaleX: coordSys.scaleX,
        scaleY: coordSys.scaleY
      };
      if (this._firstRender) {
        group.attr(groupNewProp);
      } else {
        updateProps(group, groupNewProp, seriesModel);
      }
    }
    adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
    const data = seriesModel.getData();
    symbolDraw.updateData(data);
    const edgeData = seriesModel.getEdgeData();
    lineDraw.updateData(edgeData);
    this._updateNodeAndLinkScale();
    this._updateController(seriesModel, ecModel, api2);
    clearTimeout(this._layoutTimeout);
    const forceLayout2 = seriesModel.forceLayout;
    const layoutAnimation = seriesModel.get(["force", "layoutAnimation"]);
    if (forceLayout2) {
      this._startForceLayoutIteration(forceLayout2, layoutAnimation);
    }
    const layout18 = seriesModel.get("layout");
    data.graph.eachNode((node) => {
      const idx = node.dataIndex;
      const el = node.getGraphicEl();
      const itemModel = node.getModel();
      if (!el) {
        return;
      }
      el.off("drag").off("dragend");
      const draggable = itemModel.get("draggable");
      if (draggable) {
        el.on("drag", (e2) => {
          switch (layout18) {
            case "force":
              forceLayout2.warmUp();
              !this._layouting && this._startForceLayoutIteration(forceLayout2, layoutAnimation);
              forceLayout2.setFixed(idx);
              data.setItemLayout(idx, [el.x, el.y]);
              break;
            case "circular":
              data.setItemLayout(idx, [el.x, el.y]);
              node.setLayout({fixed: true}, true);
              circularLayout(seriesModel, "symbolSize", node, [e2.offsetX, e2.offsetY]);
              this.updateLayout(seriesModel);
              break;
            case "none":
            default:
              data.setItemLayout(idx, [el.x, el.y]);
              simpleLayoutEdge(seriesModel.getGraph(), seriesModel);
              this.updateLayout(seriesModel);
              break;
          }
        }).on("dragend", () => {
          if (forceLayout2) {
            forceLayout2.setUnfixed(idx);
          }
        });
      }
      el.setDraggable(draggable, !!itemModel.get("cursor"));
      const focus = itemModel.get(["emphasis", "focus"]);
      if (focus === "adjacency") {
        getECData(el).focus = node.getAdjacentDataIndices();
      }
    });
    data.graph.eachEdge(function(edge) {
      const el = edge.getGraphicEl();
      const focus = edge.getModel().get(["emphasis", "focus"]);
      if (!el) {
        return;
      }
      if (focus === "adjacency") {
        getECData(el).focus = {
          edge: [edge.dataIndex],
          node: [edge.node1.dataIndex, edge.node2.dataIndex]
        };
      }
    });
    const circularRotateLabel = seriesModel.get("layout") === "circular" && seriesModel.get(["circular", "rotateLabel"]);
    const cx = data.getLayout("cx");
    const cy = data.getLayout("cy");
    data.graph.eachNode((node) => {
      rotateNodeLabel(node, circularRotateLabel, cx, cy);
    });
    this._firstRender = false;
  }
  dispose() {
    this.remove();
    this._controller && this._controller.dispose();
    this._controllerHost = null;
  }
  _startForceLayoutIteration(forceLayout2, layoutAnimation) {
    const self2 = this;
    (function step() {
      forceLayout2.step(function(stopped) {
        self2.updateLayout(self2._model);
        (self2._layouting = !stopped) && (layoutAnimation ? self2._layoutTimeout = setTimeout(step, 16) : step());
      });
    })();
  }
  _updateController(seriesModel, ecModel, api2) {
    const controller = this._controller;
    const controllerHost = this._controllerHost;
    const group = this.group;
    controller.setPointerChecker(function(e2, x, y) {
      const rect = group.getBoundingRect();
      rect.applyTransform(group.transform);
      return rect.contain(x, y) && !onIrrelevantElement(e2, api2, seriesModel);
    });
    if (!isViewCoordSys(seriesModel.coordinateSystem)) {
      controller.disable();
      return;
    }
    controller.enable(seriesModel.get("roam"));
    controllerHost.zoomLimit = seriesModel.get("scaleLimit");
    controllerHost.zoom = seriesModel.coordinateSystem.getZoom();
    controller.off("pan").off("zoom").on("pan", (e2) => {
      updateViewOnPan(controllerHost, e2.dx, e2.dy);
      api2.dispatchAction({
        seriesId: seriesModel.id,
        type: "graphRoam",
        dx: e2.dx,
        dy: e2.dy
      });
    }).on("zoom", (e2) => {
      updateViewOnZoom(controllerHost, e2.scale, e2.originX, e2.originY);
      api2.dispatchAction({
        seriesId: seriesModel.id,
        type: "graphRoam",
        zoom: e2.scale,
        originX: e2.originX,
        originY: e2.originY
      });
      this._updateNodeAndLinkScale();
      adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
      this._lineDraw.updateLayout();
      api2.updateLabelLayout();
    });
  }
  _updateNodeAndLinkScale() {
    const seriesModel = this._model;
    const data = seriesModel.getData();
    const nodeScale = getNodeGlobalScale(seriesModel);
    data.eachItemGraphicEl(function(el, idx) {
      el && el.setSymbolScale(nodeScale);
    });
  }
  updateLayout(seriesModel) {
    adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel));
    this._symbolDraw.updateLayout();
    this._lineDraw.updateLayout();
  }
  remove() {
    clearTimeout(this._layoutTimeout);
    this._layouting = false;
    this._layoutTimeout = null;
    this._symbolDraw && this._symbolDraw.remove();
    this._lineDraw && this._lineDraw.remove();
  }
};
var GraphView = GraphView2;
GraphView.type = "graph";
var GraphView_default = GraphView;

// src/data/Graph.ts
function generateNodeKey(id) {
  return "_EC_" + id;
}
var Graph = class {
  constructor(directed) {
    this.type = "graph";
    this.nodes = [];
    this.edges = [];
    this._nodesMap = {};
    this._edgesMap = {};
    this._directed = directed || false;
  }
  isDirected() {
    return this._directed;
  }
  addNode(id, dataIndex) {
    id = id == null ? "" + dataIndex : "" + id;
    const nodesMap = this._nodesMap;
    if (nodesMap[generateNodeKey(id)]) {
      if (true) {
        console.error("Graph nodes have duplicate name or id");
      }
      return;
    }
    const node = new GraphNode(id, dataIndex);
    node.hostGraph = this;
    this.nodes.push(node);
    nodesMap[generateNodeKey(id)] = node;
    return node;
  }
  getNodeByIndex(dataIndex) {
    const rawIdx = this.data.getRawIndex(dataIndex);
    return this.nodes[rawIdx];
  }
  getNodeById(id) {
    return this._nodesMap[generateNodeKey(id)];
  }
  addEdge(n1, n2, dataIndex) {
    const nodesMap = this._nodesMap;
    const edgesMap = this._edgesMap;
    if (isNumber(n1)) {
      n1 = this.nodes[n1];
    }
    if (isNumber(n2)) {
      n2 = this.nodes[n2];
    }
    if (!(n1 instanceof GraphNode)) {
      n1 = nodesMap[generateNodeKey(n1)];
    }
    if (!(n2 instanceof GraphNode)) {
      n2 = nodesMap[generateNodeKey(n2)];
    }
    if (!n1 || !n2) {
      return;
    }
    const key = n1.id + "-" + n2.id;
    const edge = new GraphEdge(n1, n2, dataIndex);
    edge.hostGraph = this;
    if (this._directed) {
      n1.outEdges.push(edge);
      n2.inEdges.push(edge);
    }
    n1.edges.push(edge);
    if (n1 !== n2) {
      n2.edges.push(edge);
    }
    this.edges.push(edge);
    edgesMap[key] = edge;
    return edge;
  }
  getEdgeByIndex(dataIndex) {
    const rawIdx = this.edgeData.getRawIndex(dataIndex);
    return this.edges[rawIdx];
  }
  getEdge(n1, n2) {
    if (n1 instanceof GraphNode) {
      n1 = n1.id;
    }
    if (n2 instanceof GraphNode) {
      n2 = n2.id;
    }
    const edgesMap = this._edgesMap;
    if (this._directed) {
      return edgesMap[n1 + "-" + n2];
    } else {
      return edgesMap[n1 + "-" + n2] || edgesMap[n2 + "-" + n1];
    }
  }
  eachNode(cb, context) {
    const nodes = this.nodes;
    const len2 = nodes.length;
    for (let i = 0; i < len2; i++) {
      if (nodes[i].dataIndex >= 0) {
        cb.call(context, nodes[i], i);
      }
    }
  }
  eachEdge(cb, context) {
    const edges = this.edges;
    const len2 = edges.length;
    for (let i = 0; i < len2; i++) {
      if (edges[i].dataIndex >= 0 && edges[i].node1.dataIndex >= 0 && edges[i].node2.dataIndex >= 0) {
        cb.call(context, edges[i], i);
      }
    }
  }
  breadthFirstTraverse(cb, startNode, direction, context) {
    if (!(startNode instanceof GraphNode)) {
      startNode = this._nodesMap[generateNodeKey(startNode)];
    }
    if (!startNode) {
      return;
    }
    const edgeType = direction === "out" ? "outEdges" : direction === "in" ? "inEdges" : "edges";
    for (let i = 0; i < this.nodes.length; i++) {
      this.nodes[i].__visited = false;
    }
    if (cb.call(context, startNode, null)) {
      return;
    }
    const queue = [startNode];
    while (queue.length) {
      const currentNode = queue.shift();
      const edges = currentNode[edgeType];
      for (let i = 0; i < edges.length; i++) {
        const e2 = edges[i];
        const otherNode = e2.node1 === currentNode ? e2.node2 : e2.node1;
        if (!otherNode.__visited) {
          if (cb.call(context, otherNode, currentNode)) {
            return;
          }
          queue.push(otherNode);
          otherNode.__visited = true;
        }
      }
    }
  }
  update() {
    const data = this.data;
    const edgeData = this.edgeData;
    const nodes = this.nodes;
    const edges = this.edges;
    for (let i = 0, len2 = nodes.length; i < len2; i++) {
      nodes[i].dataIndex = -1;
    }
    for (let i = 0, len2 = data.count(); i < len2; i++) {
      nodes[data.getRawIndex(i)].dataIndex = i;
    }
    edgeData.filterSelf(function(idx) {
      const edge = edges[edgeData.getRawIndex(idx)];
      return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0;
    });
    for (let i = 0, len2 = edges.length; i < len2; i++) {
      edges[i].dataIndex = -1;
    }
    for (let i = 0, len2 = edgeData.count(); i < len2; i++) {
      edges[edgeData.getRawIndex(i)].dataIndex = i;
    }
  }
  clone() {
    const graph = new Graph(this._directed);
    const nodes = this.nodes;
    const edges = this.edges;
    for (let i = 0; i < nodes.length; i++) {
      graph.addNode(nodes[i].id, nodes[i].dataIndex);
    }
    for (let i = 0; i < edges.length; i++) {
      const e2 = edges[i];
      graph.addEdge(e2.node1.id, e2.node2.id, e2.dataIndex);
    }
    return graph;
  }
};
var GraphNode = class {
  constructor(id, dataIndex) {
    this.inEdges = [];
    this.outEdges = [];
    this.edges = [];
    this.dataIndex = -1;
    this.id = id == null ? "" : id;
    this.dataIndex = dataIndex == null ? -1 : dataIndex;
  }
  degree() {
    return this.edges.length;
  }
  inDegree() {
    return this.inEdges.length;
  }
  outDegree() {
    return this.outEdges.length;
  }
  getModel(path) {
    if (this.dataIndex < 0) {
      return;
    }
    const graph = this.hostGraph;
    const itemModel = graph.data.getItemModel(this.dataIndex);
    return itemModel.getModel(path);
  }
  getAdjacentDataIndices() {
    const dataIndices = {
      edge: [],
      node: []
    };
    for (let i = 0; i < this.edges.length; i++) {
      const adjacentEdge = this.edges[i];
      if (adjacentEdge.dataIndex < 0) {
        continue;
      }
      dataIndices.edge.push(adjacentEdge.dataIndex);
      dataIndices.node.push(adjacentEdge.node1.dataIndex, adjacentEdge.node2.dataIndex);
    }
    return dataIndices;
  }
  getTrajectoryDataIndices() {
    const connectedEdgesMap = createHashMap();
    const connectedNodesMap = createHashMap();
    for (let i = 0; i < this.edges.length; i++) {
      const adjacentEdge = this.edges[i];
      if (adjacentEdge.dataIndex < 0) {
        continue;
      }
      connectedEdgesMap.set(adjacentEdge.dataIndex, true);
      const sourceNodesQueue = [adjacentEdge.node1];
      const targetNodesQueue = [adjacentEdge.node2];
      let nodeIteratorIndex = 0;
      while (nodeIteratorIndex < sourceNodesQueue.length) {
        const sourceNode = sourceNodesQueue[nodeIteratorIndex];
        nodeIteratorIndex++;
        connectedNodesMap.set(sourceNode.dataIndex, true);
        for (let j = 0; j < sourceNode.inEdges.length; j++) {
          connectedEdgesMap.set(sourceNode.inEdges[j].dataIndex, true);
          sourceNodesQueue.push(sourceNode.inEdges[j].node1);
        }
      }
      nodeIteratorIndex = 0;
      while (nodeIteratorIndex < targetNodesQueue.length) {
        const targetNode = targetNodesQueue[nodeIteratorIndex];
        nodeIteratorIndex++;
        connectedNodesMap.set(targetNode.dataIndex, true);
        for (let j = 0; j < targetNode.outEdges.length; j++) {
          connectedEdgesMap.set(targetNode.outEdges[j].dataIndex, true);
          targetNodesQueue.push(targetNode.outEdges[j].node2);
        }
      }
    }
    return {
      edge: connectedEdgesMap.keys(),
      node: connectedNodesMap.keys()
    };
  }
};
var GraphEdge = class {
  constructor(n1, n2, dataIndex) {
    this.dataIndex = -1;
    this.node1 = n1;
    this.node2 = n2;
    this.dataIndex = dataIndex == null ? -1 : dataIndex;
  }
  getModel(path) {
    if (this.dataIndex < 0) {
      return;
    }
    const graph = this.hostGraph;
    const itemModel = graph.edgeData.getItemModel(this.dataIndex);
    return itemModel.getModel(path);
  }
  getAdjacentDataIndices() {
    return {
      edge: [this.dataIndex],
      node: [this.node1.dataIndex, this.node2.dataIndex]
    };
  }
  getTrajectoryDataIndices() {
    const connectedEdgesMap = createHashMap();
    const connectedNodesMap = createHashMap();
    connectedEdgesMap.set(this.dataIndex, true);
    const sourceNodes = [this.node1];
    const targetNodes = [this.node2];
    let nodeIteratorIndex = 0;
    while (nodeIteratorIndex < sourceNodes.length) {
      const sourceNode = sourceNodes[nodeIteratorIndex];
      nodeIteratorIndex++;
      connectedNodesMap.set(sourceNode.dataIndex, true);
      for (let j = 0; j < sourceNode.inEdges.length; j++) {
        connectedEdgesMap.set(sourceNode.inEdges[j].dataIndex, true);
        sourceNodes.push(sourceNode.inEdges[j].node1);
      }
    }
    nodeIteratorIndex = 0;
    while (nodeIteratorIndex < targetNodes.length) {
      const targetNode = targetNodes[nodeIteratorIndex];
      nodeIteratorIndex++;
      connectedNodesMap.set(targetNode.dataIndex, true);
      for (let j = 0; j < targetNode.outEdges.length; j++) {
        connectedEdgesMap.set(targetNode.outEdges[j].dataIndex, true);
        targetNodes.push(targetNode.outEdges[j].node2);
      }
    }
    return {
      edge: connectedEdgesMap.keys(),
      node: connectedNodesMap.keys()
    };
  }
};
function createGraphDataProxyMixin(hostName, dataName) {
  return {
    getValue(dimension) {
      const data = this[hostName][dataName];
      return data.getStore().get(data.getDimensionIndex(dimension || "value"), this.dataIndex);
    },
    setVisual(key, value) {
      this.dataIndex >= 0 && this[hostName][dataName].setItemVisual(this.dataIndex, key, value);
    },
    getVisual(key) {
      return this[hostName][dataName].getItemVisual(this.dataIndex, key);
    },
    setLayout(layout18, merge2) {
      this.dataIndex >= 0 && this[hostName][dataName].setItemLayout(this.dataIndex, layout18, merge2);
    },
    getLayout() {
      return this[hostName][dataName].getItemLayout(this.dataIndex);
    },
    getGraphicEl() {
      return this[hostName][dataName].getItemGraphicEl(this.dataIndex);
    },
    getRawIndex() {
      return this[hostName][dataName].getRawIndex(this.dataIndex);
    }
  };
}
mixin(GraphNode, createGraphDataProxyMixin("hostGraph", "data"));
mixin(GraphEdge, createGraphDataProxyMixin("hostGraph", "edgeData"));
var Graph_default = Graph;

// src/chart/helper/createGraphFromNodeEdge.ts
function createGraphFromNodeEdge(nodes, edges, seriesModel, directed, beforeLink) {
  const graph = new Graph_default(directed);
  for (let i = 0; i < nodes.length; i++) {
    graph.addNode(retrieve(nodes[i].id, nodes[i].name, i), i);
  }
  const linkNameList = [];
  const validEdges = [];
  let linkCount = 0;
  for (let i = 0; i < edges.length; i++) {
    const link = edges[i];
    const source = link.source;
    const target = link.target;
    if (graph.addEdge(source, target, linkCount)) {
      validEdges.push(link);
      linkNameList.push(retrieve(convertOptionIdName(link.id, null), source + " > " + target));
      linkCount++;
    }
  }
  const coordSys = seriesModel.get("coordinateSystem");
  let nodeData;
  if (coordSys === "cartesian2d" || coordSys === "polar") {
    nodeData = createSeriesData_default(nodes, seriesModel);
  } else {
    const coordSysCtor = CoordinateSystem_default.get(coordSys);
    const coordDimensions = coordSysCtor ? coordSysCtor.dimensions || [] : [];
    if (indexOf(coordDimensions, "value") < 0) {
      coordDimensions.concat(["value"]);
    }
    const {dimensions} = prepareSeriesDataSchema(nodes, {
      coordDimensions,
      encodeDefine: seriesModel.getEncode()
    });
    nodeData = new SeriesData_default(dimensions, seriesModel);
    nodeData.initData(nodes);
  }
  const edgeData = new SeriesData_default(["value"], seriesModel);
  edgeData.initData(validEdges, linkNameList);
  beforeLink && beforeLink(nodeData, edgeData);
  linkSeriesData_default({
    mainData: nodeData,
    struct: graph,
    structAttr: "graph",
    datas: {node: nodeData, edge: edgeData},
    datasAttr: {node: "data", edge: "edgeData"}
  });
  graph.update();
  return graph;
}

// src/chart/graph/GraphSeries.ts
var GraphSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = GraphSeriesModel2.type;
    this.hasSymbolVisual = true;
  }
  init(option) {
    super.init.apply(this, arguments);
    const self2 = this;
    function getCategoriesData() {
      return self2._categoriesData;
    }
    this.legendVisualProvider = new LegendVisualProvider_default(getCategoriesData, getCategoriesData);
    this.fillDataTextStyle(option.edges || option.links);
    this._updateCategoriesData();
  }
  mergeOption(option) {
    super.mergeOption.apply(this, arguments);
    this.fillDataTextStyle(option.edges || option.links);
    this._updateCategoriesData();
  }
  mergeDefaultAndTheme(option) {
    super.mergeDefaultAndTheme.apply(this, arguments);
    defaultEmphasis(option, "edgeLabel", ["show"]);
  }
  getInitialData(option, ecModel) {
    const edges = option.edges || option.links || [];
    const nodes = option.data || option.nodes || [];
    const self2 = this;
    if (nodes && edges) {
      initCurvenessList(this);
      const graph = createGraphFromNodeEdge(nodes, edges, this, true, beforeLink);
      each(graph.edges, function(edge) {
        createEdgeMapForCurveness(edge.node1, edge.node2, this, edge.dataIndex);
      }, this);
      return graph.data;
    }
    function beforeLink(nodeData, edgeData) {
      nodeData.wrapMethod("getItemModel", function(model) {
        const categoriesModels = self2._categoriesModels;
        const categoryIdx = model.getShallow("category");
        const categoryModel = categoriesModels[categoryIdx];
        if (categoryModel) {
          categoryModel.parentModel = model.parentModel;
          model.parentModel = categoryModel;
        }
        return model;
      });
      const oldGetModel = Model_default.prototype.getModel;
      function newGetModel(path, parentModel) {
        const model = oldGetModel.call(this, path, parentModel);
        model.resolveParentPath = resolveParentPath;
        return model;
      }
      edgeData.wrapMethod("getItemModel", function(model) {
        model.resolveParentPath = resolveParentPath;
        model.getModel = newGetModel;
        return model;
      });
      function resolveParentPath(pathArr) {
        if (pathArr && (pathArr[0] === "label" || pathArr[1] === "label")) {
          const newPathArr = pathArr.slice();
          if (pathArr[0] === "label") {
            newPathArr[0] = "edgeLabel";
          } else if (pathArr[1] === "label") {
            newPathArr[1] = "edgeLabel";
          }
          return newPathArr;
        }
        return pathArr;
      }
    }
  }
  getGraph() {
    return this.getData().graph;
  }
  getEdgeData() {
    return this.getGraph().edgeData;
  }
  getCategoriesData() {
    return this._categoriesData;
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    if (dataType === "edge") {
      const nodeData = this.getData();
      const params = this.getDataParams(dataIndex, dataType);
      const edge = nodeData.graph.getEdgeByIndex(dataIndex);
      const sourceName = nodeData.getName(edge.node1.dataIndex);
      const targetName = nodeData.getName(edge.node2.dataIndex);
      const nameArr = [];
      sourceName != null && nameArr.push(sourceName);
      targetName != null && nameArr.push(targetName);
      return createTooltipMarkup("nameValue", {
        name: nameArr.join(" > "),
        value: params.value,
        noValue: params.value == null
      });
    }
    const nodeMarkup = defaultSeriesFormatTooltip({
      series: this,
      dataIndex,
      multipleSeries
    });
    return nodeMarkup;
  }
  _updateCategoriesData() {
    const categories = map(this.option.categories || [], function(category) {
      return category.value != null ? category : extend({
        value: 0
      }, category);
    });
    const categoriesData = new SeriesData_default(["value"], this);
    categoriesData.initData(categories);
    this._categoriesData = categoriesData;
    this._categoriesModels = categoriesData.mapArray(function(idx) {
      return categoriesData.getItemModel(idx);
    });
  }
  setZoom(zoom) {
    this.option.zoom = zoom;
  }
  setCenter(center3) {
    this.option.center = center3;
  }
  isAnimationEnabled() {
    return super.isAnimationEnabled() && !(this.get("layout") === "force" && this.get(["force", "layoutAnimation"]));
  }
};
var GraphSeriesModel = GraphSeriesModel2;
GraphSeriesModel.type = "series.graph";
GraphSeriesModel.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"];
GraphSeriesModel.defaultOption = {
  z: 2,
  coordinateSystem: "view",
  legendHoverLink: true,
  layout: null,
  circular: {
    rotateLabel: false
  },
  force: {
    initLayout: null,
    repulsion: [0, 50],
    gravity: 0.1,
    friction: 0.6,
    edgeLength: 30,
    layoutAnimation: true
  },
  left: "center",
  top: "center",
  symbol: "circle",
  symbolSize: 10,
  edgeSymbol: ["none", "none"],
  edgeSymbolSize: 10,
  edgeLabel: {
    position: "middle",
    distance: 5
  },
  draggable: false,
  roam: false,
  center: null,
  zoom: 1,
  nodeScaleRatio: 0.6,
  label: {
    show: false,
    formatter: "{b}"
  },
  itemStyle: {},
  lineStyle: {
    color: "#aaa",
    width: 1,
    opacity: 0.5
  },
  emphasis: {
    scale: true,
    label: {
      show: true
    }
  },
  select: {
    itemStyle: {
      borderColor: "#212121"
    }
  }
};
var GraphSeries_default = GraphSeriesModel;

// src/chart/graph/install.ts
var actionInfo = {
  type: "graphRoam",
  event: "graphRoam",
  update: "none"
};
function install14(registers) {
  registers.registerChartView(GraphView_default);
  registers.registerSeriesModel(GraphSeries_default);
  registers.registerProcessor(categoryFilter);
  registers.registerVisual(categoryVisual);
  registers.registerVisual(graphEdgeVisual);
  registers.registerLayout(graphSimpleLayout);
  registers.registerLayout(registers.PRIORITY.VISUAL.POST_CHART_LAYOUT, graphCircularLayout);
  registers.registerLayout(graphForceLayout);
  registers.registerCoordinateSystem("graphView", {
    dimensions: View_default.dimensions,
    create: createViewCoordSys
  });
  registers.registerAction({
    type: "focusNodeAdjacency",
    event: "focusNodeAdjacency",
    update: "series:focusNodeAdjacency"
  }, noop);
  registers.registerAction({
    type: "unfocusNodeAdjacency",
    event: "unfocusNodeAdjacency",
    update: "series:unfocusNodeAdjacency"
  }, noop);
  registers.registerAction(actionInfo, function(payload, ecModel, api2) {
    ecModel.eachComponent({
      mainType: "series",
      query: payload
    }, function(seriesModel) {
      const coordSys = seriesModel.coordinateSystem;
      const res = updateCenterAndZoom(coordSys, payload, void 0, api2);
      seriesModel.setCenter && seriesModel.setCenter(res.center);
      seriesModel.setZoom && seriesModel.setZoom(res.zoom);
    });
  });
}

// src/chart/gauge/PointerPath.ts
var PointerShape = class {
  constructor() {
    this.angle = 0;
    this.width = 10;
    this.r = 10;
    this.x = 0;
    this.y = 0;
  }
};
var PointerPath = class extends Path_default {
  constructor(opts) {
    super(opts);
    this.type = "pointer";
  }
  getDefaultShape() {
    return new PointerShape();
  }
  buildPath(ctx, shape) {
    const mathCos6 = Math.cos;
    const mathSin6 = Math.sin;
    const r = shape.r;
    const width = shape.width;
    let angle = shape.angle;
    const x = shape.x - mathCos6(angle) * width * (width >= r / 3 ? 1 : 2);
    const y = shape.y - mathSin6(angle) * width * (width >= r / 3 ? 1 : 2);
    angle = shape.angle - Math.PI / 2;
    ctx.moveTo(x, y);
    ctx.lineTo(shape.x + mathCos6(angle) * width, shape.y + mathSin6(angle) * width);
    ctx.lineTo(shape.x + mathCos6(shape.angle) * r, shape.y + mathSin6(shape.angle) * r);
    ctx.lineTo(shape.x - mathCos6(angle) * width, shape.y - mathSin6(angle) * width);
    ctx.lineTo(x, y);
  }
};
var PointerPath_default = PointerPath;

// src/chart/gauge/GaugeView.ts
function parsePosition(seriesModel, api2) {
  const center3 = seriesModel.get("center");
  const width = api2.getWidth();
  const height = api2.getHeight();
  const size = Math.min(width, height);
  const cx = parsePercent2(center3[0], api2.getWidth());
  const cy = parsePercent2(center3[1], api2.getHeight());
  const r = parsePercent2(seriesModel.get("radius"), size / 2);
  return {
    cx,
    cy,
    r
  };
}
function formatLabel(value, labelFormatter) {
  let label = value == null ? "" : value + "";
  if (labelFormatter) {
    if (isString(labelFormatter)) {
      label = labelFormatter.replace("{value}", label);
    } else if (isFunction(labelFormatter)) {
      label = labelFormatter(value);
    }
  }
  return label;
}
var GaugeView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = GaugeView2.type;
  }
  render(seriesModel, ecModel, api2) {
    this.group.removeAll();
    const colorList = seriesModel.get(["axisLine", "lineStyle", "color"]);
    const posInfo = parsePosition(seriesModel, api2);
    this._renderMain(seriesModel, ecModel, api2, colorList, posInfo);
    this._data = seriesModel.getData();
  }
  dispose() {
  }
  _renderMain(seriesModel, ecModel, api2, colorList, posInfo) {
    const group = this.group;
    const clockwise = seriesModel.get("clockwise");
    let startAngle = -seriesModel.get("startAngle") / 180 * Math.PI;
    let endAngle = -seriesModel.get("endAngle") / 180 * Math.PI;
    const axisLineModel = seriesModel.getModel("axisLine");
    const roundCap = axisLineModel.get("roundCap");
    const MainPath = roundCap ? sausage_default : Sector_default;
    const showAxis = axisLineModel.get("show");
    const lineStyleModel = axisLineModel.getModel("lineStyle");
    const axisLineWidth = lineStyleModel.get("width");
    const angles = [startAngle, endAngle];
    normalizeArcAngles(angles, !clockwise);
    startAngle = angles[0];
    endAngle = angles[1];
    const angleRangeSpan = endAngle - startAngle;
    let prevEndAngle = startAngle;
    const sectors = [];
    for (let i = 0; showAxis && i < colorList.length; i++) {
      const percent = Math.min(Math.max(colorList[i][0], 0), 1);
      endAngle = startAngle + angleRangeSpan * percent;
      const sector = new MainPath({
        shape: {
          startAngle: prevEndAngle,
          endAngle,
          cx: posInfo.cx,
          cy: posInfo.cy,
          clockwise,
          r0: posInfo.r - axisLineWidth,
          r: posInfo.r
        },
        silent: true
      });
      sector.setStyle({
        fill: colorList[i][1]
      });
      sector.setStyle(lineStyleModel.getLineStyle(["color", "width"]));
      sectors.push(sector);
      prevEndAngle = endAngle;
    }
    sectors.reverse();
    each(sectors, (sector) => group.add(sector));
    const getColor = function(percent) {
      if (percent <= 0) {
        return colorList[0][1];
      }
      let i;
      for (i = 0; i < colorList.length; i++) {
        if (colorList[i][0] >= percent && (i === 0 ? 0 : colorList[i - 1][0]) < percent) {
          return colorList[i][1];
        }
      }
      return colorList[i - 1][1];
    };
    this._renderTicks(seriesModel, ecModel, api2, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);
    this._renderTitleAndDetail(seriesModel, ecModel, api2, getColor, posInfo);
    this._renderAnchor(seriesModel, posInfo);
    this._renderPointer(seriesModel, ecModel, api2, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);
  }
  _renderTicks(seriesModel, ecModel, api2, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {
    const group = this.group;
    const cx = posInfo.cx;
    const cy = posInfo.cy;
    const r = posInfo.r;
    const minVal = +seriesModel.get("min");
    const maxVal = +seriesModel.get("max");
    const splitLineModel = seriesModel.getModel("splitLine");
    const tickModel = seriesModel.getModel("axisTick");
    const labelModel = seriesModel.getModel("axisLabel");
    const splitNumber = seriesModel.get("splitNumber");
    const subSplitNumber = tickModel.get("splitNumber");
    const splitLineLen = parsePercent2(splitLineModel.get("length"), r);
    const tickLen = parsePercent2(tickModel.get("length"), r);
    let angle = startAngle;
    const step = (endAngle - startAngle) / splitNumber;
    const subStep = step / subSplitNumber;
    const splitLineStyle = splitLineModel.getModel("lineStyle").getLineStyle();
    const tickLineStyle = tickModel.getModel("lineStyle").getLineStyle();
    const splitLineDistance = splitLineModel.get("distance");
    let unitX;
    let unitY;
    for (let i = 0; i <= splitNumber; i++) {
      unitX = Math.cos(angle);
      unitY = Math.sin(angle);
      if (splitLineModel.get("show")) {
        const distance2 = splitLineDistance ? splitLineDistance + axisLineWidth : axisLineWidth;
        const splitLine = new Line_default({
          shape: {
            x1: unitX * (r - distance2) + cx,
            y1: unitY * (r - distance2) + cy,
            x2: unitX * (r - splitLineLen - distance2) + cx,
            y2: unitY * (r - splitLineLen - distance2) + cy
          },
          style: splitLineStyle,
          silent: true
        });
        if (splitLineStyle.stroke === "auto") {
          splitLine.setStyle({
            stroke: getColor(i / splitNumber)
          });
        }
        group.add(splitLine);
      }
      if (labelModel.get("show")) {
        const distance2 = labelModel.get("distance") + splitLineDistance;
        const label = formatLabel(round(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get("formatter"));
        const autoColor = getColor(i / splitNumber);
        const textStyleX = unitX * (r - splitLineLen - distance2) + cx;
        const textStyleY = unitY * (r - splitLineLen - distance2) + cy;
        const rotateType = labelModel.get("rotate");
        let rotate2 = 0;
        if (rotateType === "radial") {
          rotate2 = -angle + 2 * Math.PI;
          if (rotate2 > Math.PI / 2) {
            rotate2 += Math.PI;
          }
        } else if (rotateType === "tangential") {
          rotate2 = -angle - Math.PI / 2;
        } else if (isNumber(rotateType)) {
          rotate2 = rotateType * Math.PI / 180;
        }
        if (rotate2 === 0) {
          group.add(new Text_default({
            style: createTextStyle(labelModel, {
              text: label,
              x: textStyleX,
              y: textStyleY,
              verticalAlign: unitY < -0.8 ? "top" : unitY > 0.8 ? "bottom" : "middle",
              align: unitX < -0.4 ? "left" : unitX > 0.4 ? "right" : "center"
            }, {
              inheritColor: autoColor
            }),
            silent: true
          }));
        } else {
          group.add(new Text_default({
            style: createTextStyle(labelModel, {
              text: label,
              x: textStyleX,
              y: textStyleY,
              verticalAlign: "middle",
              align: "center"
            }, {
              inheritColor: autoColor
            }),
            silent: true,
            originX: textStyleX,
            originY: textStyleY,
            rotation: rotate2
          }));
        }
      }
      if (tickModel.get("show") && i !== splitNumber) {
        let distance2 = tickModel.get("distance");
        distance2 = distance2 ? distance2 + axisLineWidth : axisLineWidth;
        for (let j = 0; j <= subSplitNumber; j++) {
          unitX = Math.cos(angle);
          unitY = Math.sin(angle);
          const tickLine = new Line_default({
            shape: {
              x1: unitX * (r - distance2) + cx,
              y1: unitY * (r - distance2) + cy,
              x2: unitX * (r - tickLen - distance2) + cx,
              y2: unitY * (r - tickLen - distance2) + cy
            },
            silent: true,
            style: tickLineStyle
          });
          if (tickLineStyle.stroke === "auto") {
            tickLine.setStyle({
              stroke: getColor((i + j / subSplitNumber) / splitNumber)
            });
          }
          group.add(tickLine);
          angle += subStep;
        }
        angle -= subStep;
      } else {
        angle += step;
      }
    }
  }
  _renderPointer(seriesModel, ecModel, api2, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {
    const group = this.group;
    const oldData = this._data;
    const oldProgressData = this._progressEls;
    const progressList = [];
    const showPointer2 = seriesModel.get(["pointer", "show"]);
    const progressModel = seriesModel.getModel("progress");
    const showProgress = progressModel.get("show");
    const data = seriesModel.getData();
    const valueDim = data.mapDimension("value");
    const minVal = +seriesModel.get("min");
    const maxVal = +seriesModel.get("max");
    const valueExtent = [minVal, maxVal];
    const angleExtent = [startAngle, endAngle];
    function createPointer(idx, angle) {
      const itemModel = data.getItemModel(idx);
      const pointerModel = itemModel.getModel("pointer");
      const pointerWidth = parsePercent2(pointerModel.get("width"), posInfo.r);
      const pointerLength = parsePercent2(pointerModel.get("length"), posInfo.r);
      const pointerStr = seriesModel.get(["pointer", "icon"]);
      const pointerOffset = pointerModel.get("offsetCenter");
      const pointerOffsetX = parsePercent2(pointerOffset[0], posInfo.r);
      const pointerOffsetY = parsePercent2(pointerOffset[1], posInfo.r);
      const pointerKeepAspect = pointerModel.get("keepAspect");
      let pointer;
      if (pointerStr) {
        pointer = createSymbol(pointerStr, pointerOffsetX - pointerWidth / 2, pointerOffsetY - pointerLength, pointerWidth, pointerLength, null, pointerKeepAspect);
      } else {
        pointer = new PointerPath_default({
          shape: {
            angle: -Math.PI / 2,
            width: pointerWidth,
            r: pointerLength,
            x: pointerOffsetX,
            y: pointerOffsetY
          }
        });
      }
      pointer.rotation = -(angle + Math.PI / 2);
      pointer.x = posInfo.cx;
      pointer.y = posInfo.cy;
      return pointer;
    }
    function createProgress(idx, endAngle2) {
      const roundCap = progressModel.get("roundCap");
      const ProgressPath = roundCap ? sausage_default : Sector_default;
      const isOverlap = progressModel.get("overlap");
      const progressWidth = isOverlap ? progressModel.get("width") : axisLineWidth / data.count();
      const r0 = isOverlap ? posInfo.r - progressWidth : posInfo.r - (idx + 1) * progressWidth;
      const r = isOverlap ? posInfo.r : posInfo.r - idx * progressWidth;
      const progress = new ProgressPath({
        shape: {
          startAngle,
          endAngle: endAngle2,
          cx: posInfo.cx,
          cy: posInfo.cy,
          clockwise,
          r0,
          r
        }
      });
      isOverlap && (progress.z2 = maxVal - data.get(valueDim, idx) % maxVal);
      return progress;
    }
    if (showProgress || showPointer2) {
      data.diff(oldData).add(function(idx) {
        const val = data.get(valueDim, idx);
        if (showPointer2) {
          const pointer = createPointer(idx, startAngle);
          initProps(pointer, {
            rotation: -((isNaN(+val) ? angleExtent[0] : linearMap(val, valueExtent, angleExtent, true)) + Math.PI / 2)
          }, seriesModel);
          group.add(pointer);
          data.setItemGraphicEl(idx, pointer);
        }
        if (showProgress) {
          const progress = createProgress(idx, startAngle);
          const isClip = progressModel.get("clip");
          initProps(progress, {
            shape: {
              endAngle: linearMap(val, valueExtent, angleExtent, isClip)
            }
          }, seriesModel);
          group.add(progress);
          setCommonECData(seriesModel.seriesIndex, data.dataType, idx, progress);
          progressList[idx] = progress;
        }
      }).update(function(newIdx, oldIdx) {
        const val = data.get(valueDim, newIdx);
        if (showPointer2) {
          const previousPointer = oldData.getItemGraphicEl(oldIdx);
          const previousRotate = previousPointer ? previousPointer.rotation : startAngle;
          const pointer = createPointer(newIdx, previousRotate);
          pointer.rotation = previousRotate;
          updateProps(pointer, {
            rotation: -((isNaN(+val) ? angleExtent[0] : linearMap(val, valueExtent, angleExtent, true)) + Math.PI / 2)
          }, seriesModel);
          group.add(pointer);
          data.setItemGraphicEl(newIdx, pointer);
        }
        if (showProgress) {
          const previousProgress = oldProgressData[oldIdx];
          const previousEndAngle = previousProgress ? previousProgress.shape.endAngle : startAngle;
          const progress = createProgress(newIdx, previousEndAngle);
          const isClip = progressModel.get("clip");
          updateProps(progress, {
            shape: {
              endAngle: linearMap(val, valueExtent, angleExtent, isClip)
            }
          }, seriesModel);
          group.add(progress);
          setCommonECData(seriesModel.seriesIndex, data.dataType, newIdx, progress);
          progressList[newIdx] = progress;
        }
      }).execute();
      data.each(function(idx) {
        const itemModel = data.getItemModel(idx);
        const emphasisModel = itemModel.getModel("emphasis");
        const focus = emphasisModel.get("focus");
        const blurScope = emphasisModel.get("blurScope");
        const emphasisDisabled = emphasisModel.get("disabled");
        if (showPointer2) {
          const pointer = data.getItemGraphicEl(idx);
          const symbolStyle = data.getItemVisual(idx, "style");
          const visualColor = symbolStyle.fill;
          if (pointer instanceof Image_default) {
            const pathStyle = pointer.style;
            pointer.useStyle(extend({
              image: pathStyle.image,
              x: pathStyle.x,
              y: pathStyle.y,
              width: pathStyle.width,
              height: pathStyle.height
            }, symbolStyle));
          } else {
            pointer.useStyle(symbolStyle);
            pointer.type !== "pointer" && pointer.setColor(visualColor);
          }
          pointer.setStyle(itemModel.getModel(["pointer", "itemStyle"]).getItemStyle());
          if (pointer.style.fill === "auto") {
            pointer.setStyle("fill", getColor(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)));
          }
          pointer.z2EmphasisLift = 0;
          setStatesStylesFromModel(pointer, itemModel);
          toggleHoverEmphasis(pointer, focus, blurScope, emphasisDisabled);
        }
        if (showProgress) {
          const progress = progressList[idx];
          progress.useStyle(data.getItemVisual(idx, "style"));
          progress.setStyle(itemModel.getModel(["progress", "itemStyle"]).getItemStyle());
          progress.z2EmphasisLift = 0;
          setStatesStylesFromModel(progress, itemModel);
          toggleHoverEmphasis(progress, focus, blurScope, emphasisDisabled);
        }
      });
      this._progressEls = progressList;
    }
  }
  _renderAnchor(seriesModel, posInfo) {
    const anchorModel = seriesModel.getModel("anchor");
    const showAnchor = anchorModel.get("show");
    if (showAnchor) {
      const anchorSize = anchorModel.get("size");
      const anchorType = anchorModel.get("icon");
      const offsetCenter = anchorModel.get("offsetCenter");
      const anchorKeepAspect = anchorModel.get("keepAspect");
      const anchor = createSymbol(anchorType, posInfo.cx - anchorSize / 2 + parsePercent2(offsetCenter[0], posInfo.r), posInfo.cy - anchorSize / 2 + parsePercent2(offsetCenter[1], posInfo.r), anchorSize, anchorSize, null, anchorKeepAspect);
      anchor.z2 = anchorModel.get("showAbove") ? 1 : 0;
      anchor.setStyle(anchorModel.getModel("itemStyle").getItemStyle());
      this.group.add(anchor);
    }
  }
  _renderTitleAndDetail(seriesModel, ecModel, api2, getColor, posInfo) {
    const data = seriesModel.getData();
    const valueDim = data.mapDimension("value");
    const minVal = +seriesModel.get("min");
    const maxVal = +seriesModel.get("max");
    const contentGroup = new Group_default();
    const newTitleEls = [];
    const newDetailEls = [];
    const hasAnimation = seriesModel.isAnimationEnabled();
    const showPointerAbove = seriesModel.get(["pointer", "showAbove"]);
    data.diff(this._data).add((idx) => {
      newTitleEls[idx] = new Text_default({
        silent: true
      });
      newDetailEls[idx] = new Text_default({
        silent: true
      });
    }).update((idx, oldIdx) => {
      newTitleEls[idx] = this._titleEls[oldIdx];
      newDetailEls[idx] = this._detailEls[oldIdx];
    }).execute();
    data.each(function(idx) {
      const itemModel = data.getItemModel(idx);
      const value = data.get(valueDim, idx);
      const itemGroup = new Group_default();
      const autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));
      const itemTitleModel = itemModel.getModel("title");
      if (itemTitleModel.get("show")) {
        const titleOffsetCenter = itemTitleModel.get("offsetCenter");
        const titleX = posInfo.cx + parsePercent2(titleOffsetCenter[0], posInfo.r);
        const titleY = posInfo.cy + parsePercent2(titleOffsetCenter[1], posInfo.r);
        const labelEl = newTitleEls[idx];
        labelEl.attr({
          z2: showPointerAbove ? 0 : 2,
          style: createTextStyle(itemTitleModel, {
            x: titleX,
            y: titleY,
            text: data.getName(idx),
            align: "center",
            verticalAlign: "middle"
          }, {inheritColor: autoColor})
        });
        itemGroup.add(labelEl);
      }
      const itemDetailModel = itemModel.getModel("detail");
      if (itemDetailModel.get("show")) {
        const detailOffsetCenter = itemDetailModel.get("offsetCenter");
        const detailX = posInfo.cx + parsePercent2(detailOffsetCenter[0], posInfo.r);
        const detailY = posInfo.cy + parsePercent2(detailOffsetCenter[1], posInfo.r);
        const width = parsePercent2(itemDetailModel.get("width"), posInfo.r);
        const height = parsePercent2(itemDetailModel.get("height"), posInfo.r);
        const detailColor = seriesModel.get(["progress", "show"]) ? data.getItemVisual(idx, "style").fill : autoColor;
        const labelEl = newDetailEls[idx];
        const formatter = itemDetailModel.get("formatter");
        labelEl.attr({
          z2: showPointerAbove ? 0 : 2,
          style: createTextStyle(itemDetailModel, {
            x: detailX,
            y: detailY,
            text: formatLabel(value, formatter),
            width: isNaN(width) ? null : width,
            height: isNaN(height) ? null : height,
            align: "center",
            verticalAlign: "middle"
          }, {inheritColor: detailColor})
        });
        setLabelValueAnimation(labelEl, {normal: itemDetailModel}, value, (value2) => formatLabel(value2, formatter));
        hasAnimation && animateLabelValue(labelEl, idx, data, seriesModel, {
          getFormattedLabel(labelDataIndex, status, dataType, labelDimIndex, fmt, extendParams) {
            return formatLabel(extendParams ? extendParams.interpolatedValue : value, formatter);
          }
        });
        itemGroup.add(labelEl);
      }
      contentGroup.add(itemGroup);
    });
    this.group.add(contentGroup);
    this._titleEls = newTitleEls;
    this._detailEls = newDetailEls;
  }
};
var GaugeView = GaugeView2;
GaugeView.type = "gauge";
var GaugeView_default = GaugeView;

// src/chart/gauge/GaugeSeries.ts
var GaugeSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = GaugeSeriesModel2.type;
    this.visualStyleAccessPath = "itemStyle";
  }
  getInitialData(option, ecModel) {
    return createSeriesDataSimply(this, ["value"]);
  }
};
var GaugeSeriesModel = GaugeSeriesModel2;
GaugeSeriesModel.type = "series.gauge";
GaugeSeriesModel.defaultOption = {
  z: 2,
  colorBy: "data",
  center: ["50%", "50%"],
  legendHoverLink: true,
  radius: "75%",
  startAngle: 225,
  endAngle: -45,
  clockwise: true,
  min: 0,
  max: 100,
  splitNumber: 10,
  axisLine: {
    show: true,
    roundCap: false,
    lineStyle: {
      color: [[1, "#E6EBF8"]],
      width: 10
    }
  },
  progress: {
    show: false,
    overlap: true,
    width: 10,
    roundCap: false,
    clip: true
  },
  splitLine: {
    show: true,
    length: 10,
    distance: 10,
    lineStyle: {
      color: "#63677A",
      width: 3,
      type: "solid"
    }
  },
  axisTick: {
    show: true,
    splitNumber: 5,
    length: 6,
    distance: 10,
    lineStyle: {
      color: "#63677A",
      width: 1,
      type: "solid"
    }
  },
  axisLabel: {
    show: true,
    distance: 15,
    color: "#464646",
    fontSize: 12,
    rotate: 0
  },
  pointer: {
    icon: null,
    offsetCenter: [0, 0],
    show: true,
    showAbove: true,
    length: "60%",
    width: 6,
    keepAspect: false
  },
  anchor: {
    show: false,
    showAbove: false,
    size: 6,
    icon: "circle",
    offsetCenter: [0, 0],
    keepAspect: false,
    itemStyle: {
      color: "#fff",
      borderWidth: 0,
      borderColor: "#5470c6"
    }
  },
  title: {
    show: true,
    offsetCenter: [0, "20%"],
    color: "#464646",
    fontSize: 16,
    valueAnimation: false
  },
  detail: {
    show: true,
    backgroundColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    borderColor: "#ccc",
    width: 100,
    height: null,
    padding: [5, 10],
    offsetCenter: [0, "40%"],
    color: "#464646",
    fontSize: 30,
    fontWeight: "bold",
    lineHeight: 30,
    valueAnimation: false
  }
};
var GaugeSeries_default = GaugeSeriesModel;

// src/chart/gauge/install.ts
function install15(registers) {
  registers.registerChartView(GaugeView_default);
  registers.registerSeriesModel(GaugeSeries_default);
}

// src/chart/funnel/FunnelView.ts
var opacityAccessPath = ["itemStyle", "opacity"];
var FunnelPiece = class extends Polygon_default {
  constructor(data, idx) {
    super();
    const polygon = this;
    const labelLine = new Polyline_default();
    const text = new Text_default();
    polygon.setTextContent(text);
    this.setTextGuideLine(labelLine);
    this.updateData(data, idx, true);
  }
  updateData(data, idx, firstCreate) {
    const polygon = this;
    const seriesModel = data.hostModel;
    const itemModel = data.getItemModel(idx);
    const layout18 = data.getItemLayout(idx);
    const emphasisModel = itemModel.getModel("emphasis");
    let opacity = itemModel.get(opacityAccessPath);
    opacity = opacity == null ? 1 : opacity;
    if (!firstCreate) {
      saveOldStyle(polygon);
    }
    polygon.useStyle(data.getItemVisual(idx, "style"));
    polygon.style.lineJoin = "round";
    if (firstCreate) {
      polygon.setShape({
        points: layout18.points
      });
      polygon.style.opacity = 0;
      initProps(polygon, {
        style: {
          opacity
        }
      }, seriesModel, idx);
    } else {
      updateProps(polygon, {
        style: {
          opacity
        },
        shape: {
          points: layout18.points
        }
      }, seriesModel, idx);
    }
    setStatesStylesFromModel(polygon, itemModel);
    this._updateLabel(data, idx);
    toggleHoverEmphasis(this, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  }
  _updateLabel(data, idx) {
    const polygon = this;
    const labelLine = this.getTextGuideLine();
    const labelText = polygon.getTextContent();
    const seriesModel = data.hostModel;
    const itemModel = data.getItemModel(idx);
    const layout18 = data.getItemLayout(idx);
    const labelLayout2 = layout18.label;
    const style = data.getItemVisual(idx, "style");
    const visualColor = style.fill;
    setLabelStyle(labelText, getLabelStatesModels(itemModel), {
      labelFetcher: data.hostModel,
      labelDataIndex: idx,
      defaultOpacity: style.opacity,
      defaultText: data.getName(idx)
    }, {normal: {
      align: labelLayout2.textAlign,
      verticalAlign: labelLayout2.verticalAlign
    }});
    polygon.setTextConfig({
      local: true,
      inside: !!labelLayout2.inside,
      insideStroke: visualColor,
      outsideFill: visualColor
    });
    const linePoints = labelLayout2.linePoints;
    labelLine.setShape({
      points: linePoints
    });
    polygon.textGuideLineConfig = {
      anchor: linePoints ? new Point_default(linePoints[0][0], linePoints[0][1]) : null
    };
    updateProps(labelText, {
      style: {
        x: labelLayout2.x,
        y: labelLayout2.y
      }
    }, seriesModel, idx);
    labelText.attr({
      rotation: labelLayout2.rotation,
      originX: labelLayout2.x,
      originY: labelLayout2.y,
      z2: 10
    });
    setLabelLineStyle(polygon, getLabelLineStatesModels(itemModel), {
      stroke: visualColor
    });
  }
};
var FunnelView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = FunnelView2.type;
    this.ignoreLabelLineUpdate = true;
  }
  render(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    const oldData = this._data;
    const group = this.group;
    data.diff(oldData).add(function(idx) {
      const funnelPiece = new FunnelPiece(data, idx);
      data.setItemGraphicEl(idx, funnelPiece);
      group.add(funnelPiece);
    }).update(function(newIdx, oldIdx) {
      const piece = oldData.getItemGraphicEl(oldIdx);
      piece.updateData(data, newIdx);
      group.add(piece);
      data.setItemGraphicEl(newIdx, piece);
    }).remove(function(idx) {
      const piece = oldData.getItemGraphicEl(idx);
      removeElementWithFadeOut(piece, seriesModel, idx);
    }).execute();
    this._data = data;
  }
  remove() {
    this.group.removeAll();
    this._data = null;
  }
  dispose() {
  }
};
var FunnelView = FunnelView2;
FunnelView.type = "funnel";
var FunnelView_default = FunnelView;

// src/chart/funnel/FunnelSeries.ts
var FunnelSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = FunnelSeriesModel2.type;
  }
  init(option) {
    super.init.apply(this, arguments);
    this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this));
    this._defaultLabelLine(option);
  }
  getInitialData(option, ecModel) {
    return createSeriesDataSimply(this, {
      coordDimensions: ["value"],
      encodeDefaulter: curry(makeSeriesEncodeForNameBased, this)
    });
  }
  _defaultLabelLine(option) {
    defaultEmphasis(option, "labelLine", ["show"]);
    const labelLineNormalOpt = option.labelLine;
    const labelLineEmphasisOpt = option.emphasis.labelLine;
    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show;
    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show;
  }
  getDataParams(dataIndex) {
    const data = this.getData();
    const params = super.getDataParams(dataIndex);
    const valueDim = data.mapDimension("value");
    const sum2 = data.getSum(valueDim);
    params.percent = !sum2 ? 0 : +(data.get(valueDim, dataIndex) / sum2 * 100).toFixed(2);
    params.$vars.push("percent");
    return params;
  }
};
var FunnelSeriesModel = FunnelSeriesModel2;
FunnelSeriesModel.type = "series.funnel";
FunnelSeriesModel.defaultOption = {
  z: 2,
  legendHoverLink: true,
  colorBy: "data",
  left: 80,
  top: 60,
  right: 80,
  bottom: 60,
  minSize: "0%",
  maxSize: "100%",
  sort: "descending",
  orient: "vertical",
  gap: 0,
  funnelAlign: "center",
  label: {
    show: true,
    position: "outer"
  },
  labelLine: {
    show: true,
    length: 20,
    lineStyle: {
      width: 1
    }
  },
  itemStyle: {
    borderColor: "#fff",
    borderWidth: 1
  },
  emphasis: {
    label: {
      show: true
    }
  },
  select: {
    itemStyle: {
      borderColor: "#212121"
    }
  }
};
var FunnelSeries_default = FunnelSeriesModel;

// src/chart/funnel/funnelLayout.ts
function getViewRect4(seriesModel, api2) {
  return getLayoutRect(seriesModel.getBoxLayoutParams(), {
    width: api2.getWidth(),
    height: api2.getHeight()
  });
}
function getSortedIndices(data, sort4) {
  const valueDim = data.mapDimension("value");
  const valueArr = data.mapArray(valueDim, function(val) {
    return val;
  });
  const indices = [];
  const isAscending = sort4 === "ascending";
  for (let i = 0, len2 = data.count(); i < len2; i++) {
    indices[i] = i;
  }
  if (isFunction(sort4)) {
    indices.sort(sort4);
  } else if (sort4 !== "none") {
    indices.sort(function(a, b) {
      return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];
    });
  }
  return indices;
}
function labelLayout(data) {
  const seriesModel = data.hostModel;
  const orient = seriesModel.get("orient");
  data.each(function(idx) {
    const itemModel = data.getItemModel(idx);
    const labelModel = itemModel.getModel("label");
    let labelPosition = labelModel.get("position");
    const labelLineModel = itemModel.getModel("labelLine");
    const layout18 = data.getItemLayout(idx);
    const points4 = layout18.points;
    const isLabelInside = labelPosition === "inner" || labelPosition === "inside" || labelPosition === "center" || labelPosition === "insideLeft" || labelPosition === "insideRight";
    let textAlign;
    let textX;
    let textY;
    let linePoints;
    if (isLabelInside) {
      if (labelPosition === "insideLeft") {
        textX = (points4[0][0] + points4[3][0]) / 2 + 5;
        textY = (points4[0][1] + points4[3][1]) / 2;
        textAlign = "left";
      } else if (labelPosition === "insideRight") {
        textX = (points4[1][0] + points4[2][0]) / 2 - 5;
        textY = (points4[1][1] + points4[2][1]) / 2;
        textAlign = "right";
      } else {
        textX = (points4[0][0] + points4[1][0] + points4[2][0] + points4[3][0]) / 4;
        textY = (points4[0][1] + points4[1][1] + points4[2][1] + points4[3][1]) / 4;
        textAlign = "center";
      }
      linePoints = [
        [textX, textY],
        [textX, textY]
      ];
    } else {
      let x1;
      let y1;
      let x2;
      let y2;
      const labelLineLen = labelLineModel.get("length");
      if (true) {
        if (orient === "vertical" && ["top", "bottom"].indexOf(labelPosition) > -1) {
          labelPosition = "left";
          console.warn("Position error: Funnel chart on vertical orient dose not support top and bottom.");
        }
        if (orient === "horizontal" && ["left", "right"].indexOf(labelPosition) > -1) {
          labelPosition = "bottom";
          console.warn("Position error: Funnel chart on horizontal orient dose not support left and right.");
        }
      }
      if (labelPosition === "left") {
        x1 = (points4[3][0] + points4[0][0]) / 2;
        y1 = (points4[3][1] + points4[0][1]) / 2;
        x2 = x1 - labelLineLen;
        textX = x2 - 5;
        textAlign = "right";
      } else if (labelPosition === "right") {
        x1 = (points4[1][0] + points4[2][0]) / 2;
        y1 = (points4[1][1] + points4[2][1]) / 2;
        x2 = x1 + labelLineLen;
        textX = x2 + 5;
        textAlign = "left";
      } else if (labelPosition === "top") {
        x1 = (points4[3][0] + points4[0][0]) / 2;
        y1 = (points4[3][1] + points4[0][1]) / 2;
        y2 = y1 - labelLineLen;
        textY = y2 - 5;
        textAlign = "center";
      } else if (labelPosition === "bottom") {
        x1 = (points4[1][0] + points4[2][0]) / 2;
        y1 = (points4[1][1] + points4[2][1]) / 2;
        y2 = y1 + labelLineLen;
        textY = y2 + 5;
        textAlign = "center";
      } else if (labelPosition === "rightTop") {
        x1 = orient === "horizontal" ? points4[3][0] : points4[1][0];
        y1 = orient === "horizontal" ? points4[3][1] : points4[1][1];
        if (orient === "horizontal") {
          y2 = y1 - labelLineLen;
          textY = y2 - 5;
          textAlign = "center";
        } else {
          x2 = x1 + labelLineLen;
          textX = x2 + 5;
          textAlign = "top";
        }
      } else if (labelPosition === "rightBottom") {
        x1 = points4[2][0];
        y1 = points4[2][1];
        if (orient === "horizontal") {
          y2 = y1 + labelLineLen;
          textY = y2 + 5;
          textAlign = "center";
        } else {
          x2 = x1 + labelLineLen;
          textX = x2 + 5;
          textAlign = "bottom";
        }
      } else if (labelPosition === "leftTop") {
        x1 = points4[0][0];
        y1 = orient === "horizontal" ? points4[0][1] : points4[1][1];
        if (orient === "horizontal") {
          y2 = y1 - labelLineLen;
          textY = y2 - 5;
          textAlign = "center";
        } else {
          x2 = x1 - labelLineLen;
          textX = x2 - 5;
          textAlign = "right";
        }
      } else if (labelPosition === "leftBottom") {
        x1 = orient === "horizontal" ? points4[1][0] : points4[3][0];
        y1 = orient === "horizontal" ? points4[1][1] : points4[2][1];
        if (orient === "horizontal") {
          y2 = y1 + labelLineLen;
          textY = y2 + 5;
          textAlign = "center";
        } else {
          x2 = x1 - labelLineLen;
          textX = x2 - 5;
          textAlign = "right";
        }
      } else {
        x1 = (points4[1][0] + points4[2][0]) / 2;
        y1 = (points4[1][1] + points4[2][1]) / 2;
        if (orient === "horizontal") {
          y2 = y1 + labelLineLen;
          textY = y2 + 5;
          textAlign = "center";
        } else {
          x2 = x1 + labelLineLen;
          textX = x2 + 5;
          textAlign = "left";
        }
      }
      if (orient === "horizontal") {
        x2 = x1;
        textX = x2;
      } else {
        y2 = y1;
        textY = y2;
      }
      linePoints = [[x1, y1], [x2, y2]];
    }
    layout18.label = {
      linePoints,
      x: textX,
      y: textY,
      verticalAlign: "middle",
      textAlign,
      inside: isLabelInside
    };
  });
}
function funnelLayout(ecModel, api2) {
  ecModel.eachSeriesByType("funnel", function(seriesModel) {
    const data = seriesModel.getData();
    const valueDim = data.mapDimension("value");
    const sort4 = seriesModel.get("sort");
    const viewRect2 = getViewRect4(seriesModel, api2);
    const orient = seriesModel.get("orient");
    const viewWidth = viewRect2.width;
    const viewHeight = viewRect2.height;
    let indices = getSortedIndices(data, sort4);
    let x = viewRect2.x;
    let y = viewRect2.y;
    const sizeExtent = orient === "horizontal" ? [
      parsePercent2(seriesModel.get("minSize"), viewHeight),
      parsePercent2(seriesModel.get("maxSize"), viewHeight)
    ] : [
      parsePercent2(seriesModel.get("minSize"), viewWidth),
      parsePercent2(seriesModel.get("maxSize"), viewWidth)
    ];
    const dataExtent = data.getDataExtent(valueDim);
    let min3 = seriesModel.get("min");
    let max3 = seriesModel.get("max");
    if (min3 == null) {
      min3 = Math.min(dataExtent[0], 0);
    }
    if (max3 == null) {
      max3 = dataExtent[1];
    }
    const funnelAlign = seriesModel.get("funnelAlign");
    let gap = seriesModel.get("gap");
    const viewSize = orient === "horizontal" ? viewWidth : viewHeight;
    let itemSize = (viewSize - gap * (data.count() - 1)) / data.count();
    const getLinePoints = function(idx, offset) {
      if (orient === "horizontal") {
        const val2 = data.get(valueDim, idx) || 0;
        const itemHeight = linearMap(val2, [min3, max3], sizeExtent, true);
        let y0;
        switch (funnelAlign) {
          case "top":
            y0 = y;
            break;
          case "center":
            y0 = y + (viewHeight - itemHeight) / 2;
            break;
          case "bottom":
            y0 = y + (viewHeight - itemHeight);
            break;
        }
        return [
          [offset, y0],
          [offset, y0 + itemHeight]
        ];
      }
      const val = data.get(valueDim, idx) || 0;
      const itemWidth = linearMap(val, [min3, max3], sizeExtent, true);
      let x0;
      switch (funnelAlign) {
        case "left":
          x0 = x;
          break;
        case "center":
          x0 = x + (viewWidth - itemWidth) / 2;
          break;
        case "right":
          x0 = x + viewWidth - itemWidth;
          break;
      }
      return [
        [x0, offset],
        [x0 + itemWidth, offset]
      ];
    };
    if (sort4 === "ascending") {
      itemSize = -itemSize;
      gap = -gap;
      if (orient === "horizontal") {
        x += viewWidth;
      } else {
        y += viewHeight;
      }
      indices = indices.reverse();
    }
    for (let i = 0; i < indices.length; i++) {
      const idx = indices[i];
      const nextIdx = indices[i + 1];
      const itemModel = data.getItemModel(idx);
      if (orient === "horizontal") {
        let width = itemModel.get(["itemStyle", "width"]);
        if (width == null) {
          width = itemSize;
        } else {
          width = parsePercent2(width, viewWidth);
          if (sort4 === "ascending") {
            width = -width;
          }
        }
        const start2 = getLinePoints(idx, x);
        const end2 = getLinePoints(nextIdx, x + width);
        x += width + gap;
        data.setItemLayout(idx, {
          points: start2.concat(end2.slice().reverse())
        });
      } else {
        let height = itemModel.get(["itemStyle", "height"]);
        if (height == null) {
          height = itemSize;
        } else {
          height = parsePercent2(height, viewHeight);
          if (sort4 === "ascending") {
            height = -height;
          }
        }
        const start2 = getLinePoints(idx, y);
        const end2 = getLinePoints(nextIdx, y + height);
        y += height + gap;
        data.setItemLayout(idx, {
          points: start2.concat(end2.slice().reverse())
        });
      }
    }
    labelLayout(data);
  });
}

// src/chart/funnel/install.ts
function install16(registers) {
  registers.registerChartView(FunnelView_default);
  registers.registerSeriesModel(FunnelSeries_default);
  registers.registerLayout(funnelLayout);
  registers.registerProcessor(dataFilter("funnel"));
}

// src/chart/parallel/ParallelView.ts
var DEFAULT_SMOOTH = 0.3;
var ParallelView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = ParallelView2.type;
    this._dataGroup = new Group_default();
    this._initialized = false;
  }
  init() {
    this.group.add(this._dataGroup);
  }
  render(seriesModel, ecModel, api2, payload) {
    this._progressiveEls = null;
    const dataGroup = this._dataGroup;
    const data = seriesModel.getData();
    const oldData = this._data;
    const coordSys = seriesModel.coordinateSystem;
    const dimensions = coordSys.dimensions;
    const seriesScope = makeSeriesScope3(seriesModel);
    data.diff(oldData).add(add2).update(update).remove(remove).execute();
    function add2(newDataIndex) {
      const line2 = addEl(data, dataGroup, newDataIndex, dimensions, coordSys);
      updateElCommon(line2, data, newDataIndex, seriesScope);
    }
    function update(newDataIndex, oldDataIndex) {
      const line2 = oldData.getItemGraphicEl(oldDataIndex);
      const points4 = createLinePoints(data, newDataIndex, dimensions, coordSys);
      data.setItemGraphicEl(newDataIndex, line2);
      updateProps(line2, {shape: {points: points4}}, seriesModel, newDataIndex);
      saveOldStyle(line2);
      updateElCommon(line2, data, newDataIndex, seriesScope);
    }
    function remove(oldDataIndex) {
      const line2 = oldData.getItemGraphicEl(oldDataIndex);
      dataGroup.remove(line2);
    }
    if (!this._initialized) {
      this._initialized = true;
      const clipPath = createGridClipShape(coordSys, seriesModel, function() {
        setTimeout(function() {
          dataGroup.removeClipPath();
        });
      });
      dataGroup.setClipPath(clipPath);
    }
    this._data = data;
  }
  incrementalPrepareRender(seriesModel, ecModel, api2) {
    this._initialized = true;
    this._data = null;
    this._dataGroup.removeAll();
  }
  incrementalRender(taskParams, seriesModel, ecModel) {
    const data = seriesModel.getData();
    const coordSys = seriesModel.coordinateSystem;
    const dimensions = coordSys.dimensions;
    const seriesScope = makeSeriesScope3(seriesModel);
    const progressiveEls = this._progressiveEls = [];
    for (let dataIndex = taskParams.start; dataIndex < taskParams.end; dataIndex++) {
      const line2 = addEl(data, this._dataGroup, dataIndex, dimensions, coordSys);
      line2.incremental = true;
      updateElCommon(line2, data, dataIndex, seriesScope);
      progressiveEls.push(line2);
    }
  }
  remove() {
    this._dataGroup && this._dataGroup.removeAll();
    this._data = null;
  }
};
var ParallelView = ParallelView2;
ParallelView.type = "parallel";
function createGridClipShape(coordSys, seriesModel, cb) {
  const parallelModel = coordSys.model;
  const rect = coordSys.getRect();
  const rectEl = new Rect_default({
    shape: {
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    }
  });
  const dim = parallelModel.get("layout") === "horizontal" ? "width" : "height";
  rectEl.setShape(dim, 0);
  initProps(rectEl, {
    shape: {
      width: rect.width,
      height: rect.height
    }
  }, seriesModel, cb);
  return rectEl;
}
function createLinePoints(data, dataIndex, dimensions, coordSys) {
  const points4 = [];
  for (let i = 0; i < dimensions.length; i++) {
    const dimName = dimensions[i];
    const value = data.get(data.mapDimension(dimName), dataIndex);
    if (!isEmptyValue(value, coordSys.getAxis(dimName).type)) {
      points4.push(coordSys.dataToPoint(value, dimName));
    }
  }
  return points4;
}
function addEl(data, dataGroup, dataIndex, dimensions, coordSys) {
  const points4 = createLinePoints(data, dataIndex, dimensions, coordSys);
  const line2 = new Polyline_default({
    shape: {points: points4},
    z2: 10
  });
  dataGroup.add(line2);
  data.setItemGraphicEl(dataIndex, line2);
  return line2;
}
function makeSeriesScope3(seriesModel) {
  let smooth = seriesModel.get("smooth", true);
  smooth === true && (smooth = DEFAULT_SMOOTH);
  smooth = numericToNumber(smooth);
  eqNaN(smooth) && (smooth = 0);
  return {smooth};
}
function updateElCommon(el, data, dataIndex, seriesScope) {
  el.useStyle(data.getItemVisual(dataIndex, "style"));
  el.style.fill = null;
  el.setShape("smooth", seriesScope.smooth);
  const itemModel = data.getItemModel(dataIndex);
  const emphasisModel = itemModel.getModel("emphasis");
  setStatesStylesFromModel(el, itemModel, "lineStyle");
  toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
}
function isEmptyValue(val, axisType) {
  return axisType === "category" ? val == null : val == null || isNaN(val);
}
var ParallelView_default = ParallelView;

// src/chart/parallel/ParallelSeries.ts
var ParallelSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = ParallelSeriesModel2.type;
    this.visualStyleAccessPath = "lineStyle";
    this.visualDrawType = "stroke";
  }
  getInitialData(option, ecModel) {
    return createSeriesData_default(null, this, {
      useEncodeDefaulter: bind(makeDefaultEncode, null, this)
    });
  }
  getRawIndicesByActiveState(activeState) {
    const coordSys = this.coordinateSystem;
    const data = this.getData();
    const indices = [];
    coordSys.eachActiveState(data, function(theActiveState, dataIndex) {
      if (activeState === theActiveState) {
        indices.push(data.getRawIndex(dataIndex));
      }
    });
    return indices;
  }
};
var ParallelSeriesModel = ParallelSeriesModel2;
ParallelSeriesModel.type = "series.parallel";
ParallelSeriesModel.dependencies = ["parallel"];
ParallelSeriesModel.defaultOption = {
  z: 2,
  coordinateSystem: "parallel",
  parallelIndex: 0,
  label: {
    show: false
  },
  inactiveOpacity: 0.05,
  activeOpacity: 1,
  lineStyle: {
    width: 1,
    opacity: 0.45,
    type: "solid"
  },
  emphasis: {
    label: {
      show: false
    }
  },
  progressive: 500,
  smooth: false,
  animationEasing: "linear"
};
function makeDefaultEncode(seriesModel) {
  const parallelModel = seriesModel.ecModel.getComponent("parallel", seriesModel.get("parallelIndex"));
  if (!parallelModel) {
    return;
  }
  const encodeDefine = {};
  each(parallelModel.dimensions, function(axisDim) {
    const dataDimIndex = convertDimNameToNumber(axisDim);
    encodeDefine[axisDim] = dataDimIndex;
  });
  return encodeDefine;
}
function convertDimNameToNumber(dimName) {
  return +dimName.replace("dim", "");
}
var ParallelSeries_default = ParallelSeriesModel;

// src/chart/parallel/parallelVisual.ts
var opacityAccessPath2 = ["lineStyle", "opacity"];
var parallelVisual = {
  seriesType: "parallel",
  reset: function(seriesModel, ecModel) {
    const coordSys = seriesModel.coordinateSystem;
    const opacityMap = {
      normal: seriesModel.get(["lineStyle", "opacity"]),
      active: seriesModel.get("activeOpacity"),
      inactive: seriesModel.get("inactiveOpacity")
    };
    return {
      progress(params, data) {
        coordSys.eachActiveState(data, function(activeState, dataIndex) {
          let opacity = opacityMap[activeState];
          if (activeState === "normal" && data.hasItemOption) {
            const itemOpacity = data.getItemModel(dataIndex).get(opacityAccessPath2, true);
            itemOpacity != null && (opacity = itemOpacity);
          }
          const existsStyle = data.ensureUniqueItemVisual(dataIndex, "style");
          existsStyle.opacity = opacity;
        }, params.start, params.end);
      }
    };
  }
};
var parallelVisual_default = parallelVisual;

// src/coord/parallel/parallelPreprocessor.ts
function parallelPreprocessor(option) {
  createParallelIfNeeded(option);
  mergeAxisOptionFromParallel(option);
}
function createParallelIfNeeded(option) {
  if (option.parallel) {
    return;
  }
  let hasParallelSeries = false;
  each(option.series, function(seriesOpt) {
    if (seriesOpt && seriesOpt.type === "parallel") {
      hasParallelSeries = true;
    }
  });
  if (hasParallelSeries) {
    option.parallel = [{}];
  }
}
function mergeAxisOptionFromParallel(option) {
  const axes = normalizeToArray(option.parallelAxis);
  each(axes, function(axisOption) {
    if (!isObject(axisOption)) {
      return;
    }
    const parallelIndex = axisOption.parallelIndex || 0;
    const parallelOption = normalizeToArray(option.parallel)[parallelIndex];
    if (parallelOption && parallelOption.parallelAxisDefault) {
      merge(axisOption, parallelOption.parallelAxisDefault, false);
    }
  });
}

// src/component/parallel/ParallelView.ts
var CLICK_THRESHOLD = 5;
var ParallelView4 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = ParallelView4.type;
  }
  render(parallelModel, ecModel, api2) {
    this._model = parallelModel;
    this._api = api2;
    if (!this._handlers) {
      this._handlers = {};
      each(handlers, function(handler, eventName) {
        api2.getZr().on(eventName, this._handlers[eventName] = bind(handler, this));
      }, this);
    }
    createOrUpdate(this, "_throttledDispatchExpand", parallelModel.get("axisExpandRate"), "fixRate");
  }
  dispose(ecModel, api2) {
    clear(this, "_throttledDispatchExpand");
    each(this._handlers, function(handler, eventName) {
      api2.getZr().off(eventName, handler);
    });
    this._handlers = null;
  }
  _throttledDispatchExpand(opt) {
    this._dispatchExpand(opt);
  }
  _dispatchExpand(opt) {
    opt && this._api.dispatchAction(extend({type: "parallelAxisExpand"}, opt));
  }
};
var ParallelView3 = ParallelView4;
ParallelView3.type = "parallel";
var handlers = {
  mousedown: function(e2) {
    if (checkTrigger(this, "click")) {
      this._mouseDownPoint = [e2.offsetX, e2.offsetY];
    }
  },
  mouseup: function(e2) {
    const mouseDownPoint = this._mouseDownPoint;
    if (checkTrigger(this, "click") && mouseDownPoint) {
      const point = [e2.offsetX, e2.offsetY];
      const dist3 = Math.pow(mouseDownPoint[0] - point[0], 2) + Math.pow(mouseDownPoint[1] - point[1], 2);
      if (dist3 > CLICK_THRESHOLD) {
        return;
      }
      const result = this._model.coordinateSystem.getSlidedAxisExpandWindow([e2.offsetX, e2.offsetY]);
      result.behavior !== "none" && this._dispatchExpand({
        axisExpandWindow: result.axisExpandWindow
      });
    }
    this._mouseDownPoint = null;
  },
  mousemove: function(e2) {
    if (this._mouseDownPoint || !checkTrigger(this, "mousemove")) {
      return;
    }
    const model = this._model;
    const result = model.coordinateSystem.getSlidedAxisExpandWindow([e2.offsetX, e2.offsetY]);
    const behavior = result.behavior;
    behavior === "jump" && this._throttledDispatchExpand.debounceNextCall(model.get("axisExpandDebounce"));
    this._throttledDispatchExpand(behavior === "none" ? null : {
      axisExpandWindow: result.axisExpandWindow,
      animation: behavior === "jump" ? null : {
        duration: 0
      }
    });
  }
};
function checkTrigger(view, triggerOn) {
  const model = view._model;
  return model.get("axisExpandable") && model.get("axisExpandTriggerOn") === triggerOn;
}
var ParallelView_default2 = ParallelView3;

// src/coord/parallel/ParallelModel.ts
var ParallelModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = ParallelModel2.type;
  }
  init() {
    super.init.apply(this, arguments);
    this.mergeOption({});
  }
  mergeOption(newOption) {
    const thisOption = this.option;
    newOption && merge(thisOption, newOption, true);
    this._initDimensions();
  }
  contains(model, ecModel) {
    const parallelIndex = model.get("parallelIndex");
    return parallelIndex != null && ecModel.getComponent("parallel", parallelIndex) === this;
  }
  setAxisExpand(opt) {
    each([
      "axisExpandable",
      "axisExpandCenter",
      "axisExpandCount",
      "axisExpandWidth",
      "axisExpandWindow"
    ], function(name) {
      if (opt.hasOwnProperty(name)) {
        this.option[name] = opt[name];
      }
    }, this);
  }
  _initDimensions() {
    const dimensions = this.dimensions = [];
    const parallelAxisIndex = this.parallelAxisIndex = [];
    const axisModels = filter(this.ecModel.queryComponents({mainType: "parallelAxis"}), function(axisModel) {
      return (axisModel.get("parallelIndex") || 0) === this.componentIndex;
    }, this);
    each(axisModels, function(axisModel) {
      dimensions.push("dim" + axisModel.get("dim"));
      parallelAxisIndex.push(axisModel.componentIndex);
    });
  }
};
var ParallelModel = ParallelModel2;
ParallelModel.type = "parallel";
ParallelModel.dependencies = ["parallelAxis"];
ParallelModel.layoutMode = "box";
ParallelModel.defaultOption = {
  z: 0,
  left: 80,
  top: 60,
  right: 80,
  bottom: 60,
  layout: "horizontal",
  axisExpandable: false,
  axisExpandCenter: null,
  axisExpandCount: 0,
  axisExpandWidth: 50,
  axisExpandRate: 17,
  axisExpandDebounce: 50,
  axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
  axisExpandTriggerOn: "click",
  parallelAxisDefault: null
};
var ParallelModel_default = ParallelModel;

// src/coord/parallel/ParallelAxis.ts
var ParallelAxis = class extends Axis_default {
  constructor(dim, scale4, coordExtent, axisType, axisIndex) {
    super(dim, scale4, coordExtent);
    this.type = axisType || "value";
    this.axisIndex = axisIndex;
  }
  isHorizontal() {
    return this.coordinateSystem.getModel().get("layout") !== "horizontal";
  }
};
var ParallelAxis_default = ParallelAxis;

// src/component/helper/sliderMove.ts
function sliderMove(delta, handleEnds, extent3, handleIndex, minSpan, maxSpan) {
  delta = delta || 0;
  const extentSpan = extent3[1] - extent3[0];
  if (minSpan != null) {
    minSpan = restrict(minSpan, [0, extentSpan]);
  }
  if (maxSpan != null) {
    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);
  }
  if (handleIndex === "all") {
    let handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);
    handleSpan = restrict(handleSpan, [0, extentSpan]);
    minSpan = maxSpan = restrict(handleSpan, [minSpan, maxSpan]);
    handleIndex = 0;
  }
  handleEnds[0] = restrict(handleEnds[0], extent3);
  handleEnds[1] = restrict(handleEnds[1], extent3);
  const originalDistSign = getSpanSign(handleEnds, handleIndex);
  handleEnds[handleIndex] += delta;
  const extentMinSpan = minSpan || 0;
  const realExtent = extent3.slice();
  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;
  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent);
  let currDistSign;
  currDistSign = getSpanSign(handleEnds, handleIndex);
  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {
    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;
  }
  currDistSign = getSpanSign(handleEnds, handleIndex);
  if (maxSpan != null && currDistSign.span > maxSpan) {
    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;
  }
  return handleEnds;
}
function getSpanSign(handleEnds, handleIndex) {
  const dist3 = handleEnds[handleIndex] - handleEnds[1 - handleIndex];
  return {span: Math.abs(dist3), sign: dist3 > 0 ? -1 : dist3 < 0 ? 1 : handleIndex ? -1 : 1};
}
function restrict(value, extend2) {
  return Math.min(extend2[1] != null ? extend2[1] : Infinity, Math.max(extend2[0] != null ? extend2[0] : -Infinity, value));
}

// src/coord/parallel/Parallel.ts
var each6 = each;
var mathMin9 = Math.min;
var mathMax9 = Math.max;
var mathFloor2 = Math.floor;
var mathCeil2 = Math.ceil;
var round6 = round;
var PI9 = Math.PI;
var Parallel = class {
  constructor(parallelModel, ecModel, api2) {
    this.type = "parallel";
    this._axesMap = createHashMap();
    this._axesLayout = {};
    this.dimensions = parallelModel.dimensions;
    this._model = parallelModel;
    this._init(parallelModel, ecModel, api2);
  }
  _init(parallelModel, ecModel, api2) {
    const dimensions = parallelModel.dimensions;
    const parallelAxisIndex = parallelModel.parallelAxisIndex;
    each6(dimensions, function(dim, idx) {
      const axisIndex = parallelAxisIndex[idx];
      const axisModel = ecModel.getComponent("parallelAxis", axisIndex);
      const axis = this._axesMap.set(dim, new ParallelAxis_default(dim, createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisIndex));
      const isCategory2 = axis.type === "category";
      axis.onBand = isCategory2 && axisModel.get("boundaryGap");
      axis.inverse = axisModel.get("inverse");
      axisModel.axis = axis;
      axis.model = axisModel;
      axis.coordinateSystem = axisModel.coordinateSystem = this;
    }, this);
  }
  update(ecModel, api2) {
    this._updateAxesFromSeries(this._model, ecModel);
  }
  containPoint(point) {
    const layoutInfo = this._makeLayoutInfo();
    const axisBase = layoutInfo.axisBase;
    const layoutBase = layoutInfo.layoutBase;
    const pixelDimIndex = layoutInfo.pixelDimIndex;
    const pAxis = point[1 - pixelDimIndex];
    const pLayout = point[pixelDimIndex];
    return pAxis >= axisBase && pAxis <= axisBase + layoutInfo.axisLength && pLayout >= layoutBase && pLayout <= layoutBase + layoutInfo.layoutLength;
  }
  getModel() {
    return this._model;
  }
  _updateAxesFromSeries(parallelModel, ecModel) {
    ecModel.eachSeries(function(seriesModel) {
      if (!parallelModel.contains(seriesModel, ecModel)) {
        return;
      }
      const data = seriesModel.getData();
      each6(this.dimensions, function(dim) {
        const axis = this._axesMap.get(dim);
        axis.scale.unionExtentFromData(data, data.mapDimension(dim));
        niceScaleExtent(axis.scale, axis.model);
      }, this);
    }, this);
  }
  resize(parallelModel, api2) {
    this._rect = getLayoutRect(parallelModel.getBoxLayoutParams(), {
      width: api2.getWidth(),
      height: api2.getHeight()
    });
    this._layoutAxes();
  }
  getRect() {
    return this._rect;
  }
  _makeLayoutInfo() {
    const parallelModel = this._model;
    const rect = this._rect;
    const xy = ["x", "y"];
    const wh = ["width", "height"];
    const layout18 = parallelModel.get("layout");
    const pixelDimIndex = layout18 === "horizontal" ? 0 : 1;
    const layoutLength = rect[wh[pixelDimIndex]];
    const layoutExtent = [0, layoutLength];
    const axisCount = this.dimensions.length;
    const axisExpandWidth = restrict2(parallelModel.get("axisExpandWidth"), layoutExtent);
    const axisExpandCount = restrict2(parallelModel.get("axisExpandCount") || 0, [0, axisCount]);
    const axisExpandable = parallelModel.get("axisExpandable") && axisCount > 3 && axisCount > axisExpandCount && axisExpandCount > 1 && axisExpandWidth > 0 && layoutLength > 0;
    let axisExpandWindow = parallelModel.get("axisExpandWindow");
    let winSize;
    if (!axisExpandWindow) {
      winSize = restrict2(axisExpandWidth * (axisExpandCount - 1), layoutExtent);
      const axisExpandCenter = parallelModel.get("axisExpandCenter") || mathFloor2(axisCount / 2);
      axisExpandWindow = [axisExpandWidth * axisExpandCenter - winSize / 2];
      axisExpandWindow[1] = axisExpandWindow[0] + winSize;
    } else {
      winSize = restrict2(axisExpandWindow[1] - axisExpandWindow[0], layoutExtent);
      axisExpandWindow[1] = axisExpandWindow[0] + winSize;
    }
    let axisCollapseWidth = (layoutLength - winSize) / (axisCount - axisExpandCount);
    axisCollapseWidth < 3 && (axisCollapseWidth = 0);
    const winInnerIndices = [
      mathFloor2(round6(axisExpandWindow[0] / axisExpandWidth, 1)) + 1,
      mathCeil2(round6(axisExpandWindow[1] / axisExpandWidth, 1)) - 1
    ];
    const axisExpandWindow0Pos = axisCollapseWidth / axisExpandWidth * axisExpandWindow[0];
    return {
      layout: layout18,
      pixelDimIndex,
      layoutBase: rect[xy[pixelDimIndex]],
      layoutLength,
      axisBase: rect[xy[1 - pixelDimIndex]],
      axisLength: rect[wh[1 - pixelDimIndex]],
      axisExpandable,
      axisExpandWidth,
      axisCollapseWidth,
      axisExpandWindow,
      axisCount,
      winInnerIndices,
      axisExpandWindow0Pos
    };
  }
  _layoutAxes() {
    const rect = this._rect;
    const axes = this._axesMap;
    const dimensions = this.dimensions;
    const layoutInfo = this._makeLayoutInfo();
    const layout18 = layoutInfo.layout;
    axes.each(function(axis) {
      const axisExtent = [0, layoutInfo.axisLength];
      const idx = axis.inverse ? 1 : 0;
      axis.setExtent(axisExtent[idx], axisExtent[1 - idx]);
    });
    each6(dimensions, function(dim, idx) {
      const posInfo = (layoutInfo.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)(idx, layoutInfo);
      const positionTable = {
        horizontal: {
          x: posInfo.position,
          y: layoutInfo.axisLength
        },
        vertical: {
          x: 0,
          y: posInfo.position
        }
      };
      const rotationTable = {
        horizontal: PI9 / 2,
        vertical: 0
      };
      const position2 = [
        positionTable[layout18].x + rect.x,
        positionTable[layout18].y + rect.y
      ];
      const rotation = rotationTable[layout18];
      const transform2 = create2();
      rotate(transform2, transform2, rotation);
      translate(transform2, transform2, position2);
      this._axesLayout[dim] = {
        position: position2,
        rotation,
        transform: transform2,
        axisNameAvailableWidth: posInfo.axisNameAvailableWidth,
        axisLabelShow: posInfo.axisLabelShow,
        nameTruncateMaxWidth: posInfo.nameTruncateMaxWidth,
        tickDirection: 1,
        labelDirection: 1
      };
    }, this);
  }
  getAxis(dim) {
    return this._axesMap.get(dim);
  }
  dataToPoint(value, dim) {
    return this.axisCoordToPoint(this._axesMap.get(dim).dataToCoord(value), dim);
  }
  eachActiveState(data, callback, start2, end2) {
    start2 == null && (start2 = 0);
    end2 == null && (end2 = data.count());
    const axesMap = this._axesMap;
    const dimensions = this.dimensions;
    const dataDimensions = [];
    const axisModels = [];
    each(dimensions, function(axisDim) {
      dataDimensions.push(data.mapDimension(axisDim));
      axisModels.push(axesMap.get(axisDim).model);
    });
    const hasActiveSet = this.hasAxisBrushed();
    for (let dataIndex = start2; dataIndex < end2; dataIndex++) {
      let activeState;
      if (!hasActiveSet) {
        activeState = "normal";
      } else {
        activeState = "active";
        const values = data.getValues(dataDimensions, dataIndex);
        for (let j = 0, lenj = dimensions.length; j < lenj; j++) {
          const state = axisModels[j].getActiveState(values[j]);
          if (state === "inactive") {
            activeState = "inactive";
            break;
          }
        }
      }
      callback(activeState, dataIndex);
    }
  }
  hasAxisBrushed() {
    const dimensions = this.dimensions;
    const axesMap = this._axesMap;
    let hasActiveSet = false;
    for (let j = 0, lenj = dimensions.length; j < lenj; j++) {
      if (axesMap.get(dimensions[j]).model.getActiveState() !== "normal") {
        hasActiveSet = true;
      }
    }
    return hasActiveSet;
  }
  axisCoordToPoint(coord, dim) {
    const axisLayout = this._axesLayout[dim];
    return applyTransform2([coord, 0], axisLayout.transform);
  }
  getAxisLayout(dim) {
    return clone(this._axesLayout[dim]);
  }
  getSlidedAxisExpandWindow(point) {
    const layoutInfo = this._makeLayoutInfo();
    const pixelDimIndex = layoutInfo.pixelDimIndex;
    let axisExpandWindow = layoutInfo.axisExpandWindow.slice();
    const winSize = axisExpandWindow[1] - axisExpandWindow[0];
    const extent3 = [0, layoutInfo.axisExpandWidth * (layoutInfo.axisCount - 1)];
    if (!this.containPoint(point)) {
      return {behavior: "none", axisExpandWindow};
    }
    const pointCoord = point[pixelDimIndex] - layoutInfo.layoutBase - layoutInfo.axisExpandWindow0Pos;
    let delta;
    let behavior = "slide";
    const axisCollapseWidth = layoutInfo.axisCollapseWidth;
    const triggerArea = this._model.get("axisExpandSlideTriggerArea");
    const useJump = triggerArea[0] != null;
    if (axisCollapseWidth) {
      if (useJump && axisCollapseWidth && pointCoord < winSize * triggerArea[0]) {
        behavior = "jump";
        delta = pointCoord - winSize * triggerArea[2];
      } else if (useJump && axisCollapseWidth && pointCoord > winSize * (1 - triggerArea[0])) {
        behavior = "jump";
        delta = pointCoord - winSize * (1 - triggerArea[2]);
      } else {
        (delta = pointCoord - winSize * triggerArea[1]) >= 0 && (delta = pointCoord - winSize * (1 - triggerArea[1])) <= 0 && (delta = 0);
      }
      delta *= layoutInfo.axisExpandWidth / axisCollapseWidth;
      delta ? sliderMove(delta, axisExpandWindow, extent3, "all") : behavior = "none";
    } else {
      const winSize2 = axisExpandWindow[1] - axisExpandWindow[0];
      const pos = extent3[1] * pointCoord / winSize2;
      axisExpandWindow = [mathMax9(0, pos - winSize2 / 2)];
      axisExpandWindow[1] = mathMin9(extent3[1], axisExpandWindow[0] + winSize2);
      axisExpandWindow[0] = axisExpandWindow[1] - winSize2;
    }
    return {
      axisExpandWindow,
      behavior
    };
  }
};
function restrict2(len2, extent3) {
  return mathMin9(mathMax9(len2, extent3[0]), extent3[1]);
}
function layoutAxisWithoutExpand(axisIndex, layoutInfo) {
  const step = layoutInfo.layoutLength / (layoutInfo.axisCount - 1);
  return {
    position: step * axisIndex,
    axisNameAvailableWidth: step,
    axisLabelShow: true
  };
}
function layoutAxisWithExpand(axisIndex, layoutInfo) {
  const layoutLength = layoutInfo.layoutLength;
  const axisExpandWidth = layoutInfo.axisExpandWidth;
  const axisCount = layoutInfo.axisCount;
  const axisCollapseWidth = layoutInfo.axisCollapseWidth;
  const winInnerIndices = layoutInfo.winInnerIndices;
  let position2;
  let axisNameAvailableWidth = axisCollapseWidth;
  let axisLabelShow = false;
  let nameTruncateMaxWidth;
  if (axisIndex < winInnerIndices[0]) {
    position2 = axisIndex * axisCollapseWidth;
    nameTruncateMaxWidth = axisCollapseWidth;
  } else if (axisIndex <= winInnerIndices[1]) {
    position2 = layoutInfo.axisExpandWindow0Pos + axisIndex * axisExpandWidth - layoutInfo.axisExpandWindow[0];
    axisNameAvailableWidth = axisExpandWidth;
    axisLabelShow = true;
  } else {
    position2 = layoutLength - (axisCount - 1 - axisIndex) * axisCollapseWidth;
    nameTruncateMaxWidth = axisCollapseWidth;
  }
  return {
    position: position2,
    axisNameAvailableWidth,
    axisLabelShow,
    nameTruncateMaxWidth
  };
}
var Parallel_default = Parallel;

// src/coord/parallel/parallelCreator.ts
function createParallelCoordSys(ecModel, api2) {
  const coordSysList = [];
  ecModel.eachComponent("parallel", function(parallelModel, idx) {
    const coordSys = new Parallel_default(parallelModel, ecModel, api2);
    coordSys.name = "parallel_" + idx;
    coordSys.resize(parallelModel, api2);
    parallelModel.coordinateSystem = coordSys;
    coordSys.model = parallelModel;
    coordSysList.push(coordSys);
  });
  ecModel.eachSeries(function(seriesModel) {
    if (seriesModel.get("coordinateSystem") === "parallel") {
      const parallelModel = seriesModel.getReferringComponents("parallel", SINGLE_REFERRING).models[0];
      seriesModel.coordinateSystem = parallelModel.coordinateSystem;
    }
  });
  return coordSysList;
}
var parallelCoordSysCreator = {
  create: createParallelCoordSys
};
var parallelCreator_default = parallelCoordSysCreator;

// src/coord/parallel/AxisModel.ts
var ParallelAxisModel = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = ParallelAxisModel.type;
    this.activeIntervals = [];
  }
  getAreaSelectStyle() {
    return makeStyleMapper([
      ["fill", "color"],
      ["lineWidth", "borderWidth"],
      ["stroke", "borderColor"],
      ["width", "width"],
      ["opacity", "opacity"]
    ])(this.getModel("areaSelectStyle"));
  }
  setActiveIntervals(intervals) {
    const activeIntervals = this.activeIntervals = clone(intervals);
    if (activeIntervals) {
      for (let i = activeIntervals.length - 1; i >= 0; i--) {
        asc(activeIntervals[i]);
      }
    }
  }
  getActiveState(value) {
    const activeIntervals = this.activeIntervals;
    if (!activeIntervals.length) {
      return "normal";
    }
    if (value == null || isNaN(+value)) {
      return "inactive";
    }
    if (activeIntervals.length === 1) {
      const interval = activeIntervals[0];
      if (interval[0] <= value && value <= interval[1]) {
        return "active";
      }
    } else {
      for (let i = 0, len2 = activeIntervals.length; i < len2; i++) {
        if (activeIntervals[i][0] <= value && value <= activeIntervals[i][1]) {
          return "active";
        }
      }
    }
    return "inactive";
  }
};
mixin(ParallelAxisModel, AxisModelCommonMixin);
var AxisModel_default = ParallelAxisModel;

// src/component/helper/BrushController.ts
var BRUSH_PANEL_GLOBAL = true;
var mathMin10 = Math.min;
var mathMax10 = Math.max;
var mathPow3 = Math.pow;
var COVER_Z = 1e4;
var UNSELECT_THRESHOLD = 6;
var MIN_RESIZE_LINE_WIDTH = 6;
var MUTEX_RESOURCE_KEY = "globalPan";
var DIRECTION_MAP = {
  w: [0, 0],
  e: [0, 1],
  n: [1, 0],
  s: [1, 1]
};
var CURSOR_MAP = {
  w: "ew",
  e: "ew",
  n: "ns",
  s: "ns",
  ne: "nesw",
  sw: "nesw",
  nw: "nwse",
  se: "nwse"
};
var DEFAULT_BRUSH_OPT = {
  brushStyle: {
    lineWidth: 2,
    stroke: "rgba(210,219,238,0.3)",
    fill: "#D2DBEE"
  },
  transformable: true,
  brushMode: "single",
  removeOnClick: false
};
var baseUID = 0;
var BrushController = class extends Eventful_default {
  constructor(zr) {
    super();
    this._track = [];
    this._covers = [];
    this._handlers = {};
    if (true) {
      assert(zr);
    }
    this._zr = zr;
    this.group = new Group_default();
    this._uid = "brushController_" + baseUID++;
    each(pointerHandlers, function(handler, eventName) {
      this._handlers[eventName] = bind(handler, this);
    }, this);
  }
  enableBrush(brushOption) {
    if (true) {
      assert(this._mounted);
    }
    this._brushType && this._doDisableBrush();
    brushOption.brushType && this._doEnableBrush(brushOption);
    return this;
  }
  _doEnableBrush(brushOption) {
    const zr = this._zr;
    if (!this._enableGlobalPan) {
      take(zr, MUTEX_RESOURCE_KEY, this._uid);
    }
    each(this._handlers, function(handler, eventName) {
      zr.on(eventName, handler);
    });
    this._brushType = brushOption.brushType;
    this._brushOption = merge(clone(DEFAULT_BRUSH_OPT), brushOption, true);
  }
  _doDisableBrush() {
    const zr = this._zr;
    release(zr, MUTEX_RESOURCE_KEY, this._uid);
    each(this._handlers, function(handler, eventName) {
      zr.off(eventName, handler);
    });
    this._brushType = this._brushOption = null;
  }
  setPanels(panelOpts) {
    if (panelOpts && panelOpts.length) {
      const panels = this._panels = {};
      each(panelOpts, function(panelOpts2) {
        panels[panelOpts2.panelId] = clone(panelOpts2);
      });
    } else {
      this._panels = null;
    }
    return this;
  }
  mount(opt) {
    opt = opt || {};
    if (true) {
      this._mounted = true;
    }
    this._enableGlobalPan = opt.enableGlobalPan;
    const thisGroup = this.group;
    this._zr.add(thisGroup);
    thisGroup.attr({
      x: opt.x || 0,
      y: opt.y || 0,
      rotation: opt.rotation || 0,
      scaleX: opt.scaleX || 1,
      scaleY: opt.scaleY || 1
    });
    this._transform = thisGroup.getLocalTransform();
    return this;
  }
  updateCovers(coverConfigList) {
    if (true) {
      assert(this._mounted);
    }
    coverConfigList = map(coverConfigList, function(coverConfig) {
      return merge(clone(DEFAULT_BRUSH_OPT), coverConfig, true);
    });
    const tmpIdPrefix = "\0-brush-index-";
    const oldCovers = this._covers;
    const newCovers = this._covers = [];
    const controller = this;
    const creatingCover = this._creatingCover;
    new DataDiffer_default(oldCovers, coverConfigList, oldGetKey, getKey2).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();
    return this;
    function getKey2(brushOption, index) {
      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + "-" + brushOption.brushType;
    }
    function oldGetKey(cover, index) {
      return getKey2(cover.__brushOption, index);
    }
    function addOrUpdate(newIndex, oldIndex) {
      const newBrushInternal = coverConfigList[newIndex];
      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {
        newCovers[newIndex] = oldCovers[oldIndex];
      } else {
        const cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushInternal, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushInternal));
        updateCoverAfterCreation(controller, cover);
      }
    }
    function remove(oldIndex) {
      if (oldCovers[oldIndex] !== creatingCover) {
        controller.group.remove(oldCovers[oldIndex]);
      }
    }
  }
  unmount() {
    if (true) {
      if (!this._mounted) {
        return;
      }
    }
    this.enableBrush(false);
    clearCovers(this);
    this._zr.remove(this.group);
    if (true) {
      this._mounted = false;
    }
    return this;
  }
  dispose() {
    this.unmount();
    this.off();
  }
};
function createCover(controller, brushOption) {
  const cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);
  cover.__brushOption = brushOption;
  updateZ(cover, brushOption);
  controller.group.add(cover);
  return cover;
}
function endCreating(controller, creatingCover) {
  const coverRenderer = getCoverRenderer(creatingCover);
  if (coverRenderer.endCreating) {
    coverRenderer.endCreating(controller, creatingCover);
    updateZ(creatingCover, creatingCover.__brushOption);
  }
  return creatingCover;
}
function updateCoverShape(controller, cover) {
  const brushOption = cover.__brushOption;
  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);
}
function updateZ(cover, brushOption) {
  let z = brushOption.z;
  z == null && (z = COVER_Z);
  cover.traverse(function(el) {
    el.z = z;
    el.z2 = z;
  });
}
function updateCoverAfterCreation(controller, cover) {
  getCoverRenderer(cover).updateCommon(controller, cover);
  updateCoverShape(controller, cover);
}
function getCoverRenderer(cover) {
  return coverRenderers[cover.__brushOption.brushType];
}
function getPanelByPoint(controller, e2, localCursorPoint) {
  const panels = controller._panels;
  if (!panels) {
    return BRUSH_PANEL_GLOBAL;
  }
  let panel;
  const transform2 = controller._transform;
  each(panels, function(pn) {
    pn.isTargetByCursor(e2, localCursorPoint, transform2) && (panel = pn);
  });
  return panel;
}
function getPanelByCover(controller, cover) {
  const panels = controller._panels;
  if (!panels) {
    return BRUSH_PANEL_GLOBAL;
  }
  const panelId = cover.__brushOption.panelId;
  return panelId != null ? panels[panelId] : BRUSH_PANEL_GLOBAL;
}
function clearCovers(controller) {
  const covers = controller._covers;
  const originalLength = covers.length;
  each(covers, function(cover) {
    controller.group.remove(cover);
  }, controller);
  covers.length = 0;
  return !!originalLength;
}
function trigger2(controller, opt) {
  const areas = map(controller._covers, function(cover) {
    const brushOption = cover.__brushOption;
    const range = clone(brushOption.range);
    return {
      brushType: brushOption.brushType,
      panelId: brushOption.panelId,
      range
    };
  });
  controller.trigger("brush", {
    areas,
    isEnd: !!opt.isEnd,
    removeOnClick: !!opt.removeOnClick
  });
}
function shouldShowCover(controller) {
  const track = controller._track;
  if (!track.length) {
    return false;
  }
  const p2 = track[track.length - 1];
  const p1 = track[0];
  const dx = p2[0] - p1[0];
  const dy = p2[1] - p1[1];
  const dist3 = mathPow3(dx * dx + dy * dy, 0.5);
  return dist3 > UNSELECT_THRESHOLD;
}
function getTrackEnds(track) {
  let tail = track.length - 1;
  tail < 0 && (tail = 0);
  return [track[0], track[tail]];
}
function createBaseRectCover(rectRangeConverter, controller, brushOption, edgeNameSequences) {
  const cover = new Group_default();
  cover.add(new Rect_default({
    name: "main",
    style: makeStyle(brushOption),
    silent: true,
    draggable: true,
    cursor: "move",
    drift: curry(driftRect, rectRangeConverter, controller, cover, ["n", "s", "w", "e"]),
    ondragend: curry(trigger2, controller, {isEnd: true})
  }));
  each(edgeNameSequences, function(nameSequence) {
    cover.add(new Rect_default({
      name: nameSequence.join(""),
      style: {opacity: 0},
      draggable: true,
      silent: true,
      invisible: true,
      drift: curry(driftRect, rectRangeConverter, controller, cover, nameSequence),
      ondragend: curry(trigger2, controller, {isEnd: true})
    }));
  });
  return cover;
}
function updateBaseRect(controller, cover, localRange, brushOption) {
  const lineWidth = brushOption.brushStyle.lineWidth || 0;
  const handleSize = mathMax10(lineWidth, MIN_RESIZE_LINE_WIDTH);
  const x = localRange[0][0];
  const y = localRange[1][0];
  const xa = x - lineWidth / 2;
  const ya = y - lineWidth / 2;
  const x2 = localRange[0][1];
  const y2 = localRange[1][1];
  const x2a = x2 - handleSize + lineWidth / 2;
  const y2a = y2 - handleSize + lineWidth / 2;
  const width = x2 - x;
  const height = y2 - y;
  const widtha = width + lineWidth;
  const heighta = height + lineWidth;
  updateRectShape(controller, cover, "main", x, y, width, height);
  if (brushOption.transformable) {
    updateRectShape(controller, cover, "w", xa, ya, handleSize, heighta);
    updateRectShape(controller, cover, "e", x2a, ya, handleSize, heighta);
    updateRectShape(controller, cover, "n", xa, ya, widtha, handleSize);
    updateRectShape(controller, cover, "s", xa, y2a, widtha, handleSize);
    updateRectShape(controller, cover, "nw", xa, ya, handleSize, handleSize);
    updateRectShape(controller, cover, "ne", x2a, ya, handleSize, handleSize);
    updateRectShape(controller, cover, "sw", xa, y2a, handleSize, handleSize);
    updateRectShape(controller, cover, "se", x2a, y2a, handleSize, handleSize);
  }
}
function updateCommon(controller, cover) {
  const brushOption = cover.__brushOption;
  const transformable = brushOption.transformable;
  const mainEl = cover.childAt(0);
  mainEl.useStyle(makeStyle(brushOption));
  mainEl.attr({
    silent: !transformable,
    cursor: transformable ? "move" : "default"
  });
  each([["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]], function(nameSequence) {
    const el = cover.childOfName(nameSequence.join(""));
    const globalDir = nameSequence.length === 1 ? getGlobalDirection1(controller, nameSequence[0]) : getGlobalDirection2(controller, nameSequence);
    el && el.attr({
      silent: !transformable,
      invisible: !transformable,
      cursor: transformable ? CURSOR_MAP[globalDir] + "-resize" : null
    });
  });
}
function updateRectShape(controller, cover, name, x, y, w, h) {
  const el = cover.childOfName(name);
  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));
}
function makeStyle(brushOption) {
  return defaults({strokeNoScale: true}, brushOption.brushStyle);
}
function formatRectRange(x, y, x2, y2) {
  const min3 = [mathMin10(x, x2), mathMin10(y, y2)];
  const max3 = [mathMax10(x, x2), mathMax10(y, y2)];
  return [
    [min3[0], max3[0]],
    [min3[1], max3[1]]
  ];
}
function getTransform2(controller) {
  return getTransform(controller.group);
}
function getGlobalDirection1(controller, localDirName) {
  const map3 = {w: "left", e: "right", n: "top", s: "bottom"};
  const inverseMap = {left: "w", right: "e", top: "n", bottom: "s"};
  const dir3 = transformDirection(map3[localDirName], getTransform2(controller));
  return inverseMap[dir3];
}
function getGlobalDirection2(controller, localDirNameSeq) {
  const globalDir = [
    getGlobalDirection1(controller, localDirNameSeq[0]),
    getGlobalDirection1(controller, localDirNameSeq[1])
  ];
  (globalDir[0] === "e" || globalDir[0] === "w") && globalDir.reverse();
  return globalDir.join("");
}
function driftRect(rectRangeConverter, controller, cover, dirNameSequence, dx, dy) {
  const brushOption = cover.__brushOption;
  const rectRange = rectRangeConverter.toRectRange(brushOption.range);
  const localDelta = toLocalDelta(controller, dx, dy);
  each(dirNameSequence, function(dirName) {
    const ind = DIRECTION_MAP[dirName];
    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];
  });
  brushOption.range = rectRangeConverter.fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));
  updateCoverAfterCreation(controller, cover);
  trigger2(controller, {isEnd: false});
}
function driftPolygon(controller, cover, dx, dy) {
  const range = cover.__brushOption.range;
  const localDelta = toLocalDelta(controller, dx, dy);
  each(range, function(point) {
    point[0] += localDelta[0];
    point[1] += localDelta[1];
  });
  updateCoverAfterCreation(controller, cover);
  trigger2(controller, {isEnd: false});
}
function toLocalDelta(controller, dx, dy) {
  const thisGroup = controller.group;
  const localD = thisGroup.transformCoordToLocal(dx, dy);
  const localZero = thisGroup.transformCoordToLocal(0, 0);
  return [localD[0] - localZero[0], localD[1] - localZero[1]];
}
function clipByPanel(controller, cover, data) {
  const panel = getPanelByCover(controller, cover);
  return panel && panel !== BRUSH_PANEL_GLOBAL ? panel.clipPath(data, controller._transform) : clone(data);
}
function pointsToRect(points4) {
  const xmin = mathMin10(points4[0][0], points4[1][0]);
  const ymin = mathMin10(points4[0][1], points4[1][1]);
  const xmax = mathMax10(points4[0][0], points4[1][0]);
  const ymax = mathMax10(points4[0][1], points4[1][1]);
  return {
    x: xmin,
    y: ymin,
    width: xmax - xmin,
    height: ymax - ymin
  };
}
function resetCursor(controller, e2, localCursorPoint) {
  if (!controller._brushType || isOutsideZrArea(controller, e2.offsetX, e2.offsetY)) {
    return;
  }
  const zr = controller._zr;
  const covers = controller._covers;
  const currPanel = getPanelByPoint(controller, e2, localCursorPoint);
  if (!controller._dragging) {
    for (let i = 0; i < covers.length; i++) {
      const brushOption = covers[i].__brushOption;
      if (currPanel && (currPanel === BRUSH_PANEL_GLOBAL || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {
        return;
      }
    }
  }
  currPanel && zr.setCursorStyle("crosshair");
}
function preventDefault(e2) {
  const rawE = e2.event;
  rawE.preventDefault && rawE.preventDefault();
}
function mainShapeContain(cover, x, y) {
  return cover.childOfName("main").contain(x, y);
}
function updateCoverByMouse(controller, e2, localCursorPoint, isEnd) {
  let creatingCover = controller._creatingCover;
  const panel = controller._creatingPanel;
  const thisBrushOption = controller._brushOption;
  let eventParams;
  controller._track.push(localCursorPoint.slice());
  if (shouldShowCover(controller) || creatingCover) {
    if (panel && !creatingCover) {
      thisBrushOption.brushMode === "single" && clearCovers(controller);
      const brushOption = clone(thisBrushOption);
      brushOption.brushType = determineBrushType(brushOption.brushType, panel);
      brushOption.panelId = panel === BRUSH_PANEL_GLOBAL ? null : panel.panelId;
      creatingCover = controller._creatingCover = createCover(controller, brushOption);
      controller._covers.push(creatingCover);
    }
    if (creatingCover) {
      const coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];
      const coverBrushOption = creatingCover.__brushOption;
      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));
      if (isEnd) {
        endCreating(controller, creatingCover);
        coverRenderer.updateCommon(controller, creatingCover);
      }
      updateCoverShape(controller, creatingCover);
      eventParams = {isEnd};
    }
  } else if (isEnd && thisBrushOption.brushMode === "single" && thisBrushOption.removeOnClick) {
    if (getPanelByPoint(controller, e2, localCursorPoint) && clearCovers(controller)) {
      eventParams = {isEnd, removeOnClick: true};
    }
  }
  return eventParams;
}
function determineBrushType(brushType, panel) {
  if (brushType === "auto") {
    if (true) {
      assert(panel && panel.defaultBrushType, 'MUST have defaultBrushType when brushType is "atuo"');
    }
    return panel.defaultBrushType;
  }
  return brushType;
}
var pointerHandlers = {
  mousedown: function(e2) {
    if (this._dragging) {
      handleDragEnd(this, e2);
    } else if (!e2.target || !e2.target.draggable) {
      preventDefault(e2);
      const localCursorPoint = this.group.transformCoordToLocal(e2.offsetX, e2.offsetY);
      this._creatingCover = null;
      const panel = this._creatingPanel = getPanelByPoint(this, e2, localCursorPoint);
      if (panel) {
        this._dragging = true;
        this._track = [localCursorPoint.slice()];
      }
    }
  },
  mousemove: function(e2) {
    const x = e2.offsetX;
    const y = e2.offsetY;
    const localCursorPoint = this.group.transformCoordToLocal(x, y);
    resetCursor(this, e2, localCursorPoint);
    if (this._dragging) {
      preventDefault(e2);
      const eventParams = updateCoverByMouse(this, e2, localCursorPoint, false);
      eventParams && trigger2(this, eventParams);
    }
  },
  mouseup: function(e2) {
    handleDragEnd(this, e2);
  }
};
function handleDragEnd(controller, e2) {
  if (controller._dragging) {
    preventDefault(e2);
    const x = e2.offsetX;
    const y = e2.offsetY;
    const localCursorPoint = controller.group.transformCoordToLocal(x, y);
    const eventParams = updateCoverByMouse(controller, e2, localCursorPoint, true);
    controller._dragging = false;
    controller._track = [];
    controller._creatingCover = null;
    eventParams && trigger2(controller, eventParams);
  }
}
function isOutsideZrArea(controller, x, y) {
  const zr = controller._zr;
  return x < 0 || x > zr.getWidth() || y < 0 || y > zr.getHeight();
}
var coverRenderers = {
  lineX: getLineRenderer(0),
  lineY: getLineRenderer(1),
  rect: {
    createCover: function(controller, brushOption) {
      function returnInput(range) {
        return range;
      }
      return createBaseRectCover({
        toRectRange: returnInput,
        fromRectRange: returnInput
      }, controller, brushOption, [["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]]);
    },
    getCreatingRange: function(localTrack) {
      const ends = getTrackEnds(localTrack);
      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);
    },
    updateCoverShape: function(controller, cover, localRange, brushOption) {
      updateBaseRect(controller, cover, localRange, brushOption);
    },
    updateCommon,
    contain: mainShapeContain
  },
  polygon: {
    createCover: function(controller, brushOption) {
      const cover = new Group_default();
      cover.add(new Polyline_default({
        name: "main",
        style: makeStyle(brushOption),
        silent: true
      }));
      return cover;
    },
    getCreatingRange: function(localTrack) {
      return localTrack;
    },
    endCreating: function(controller, cover) {
      cover.remove(cover.childAt(0));
      cover.add(new Polygon_default({
        name: "main",
        draggable: true,
        drift: curry(driftPolygon, controller, cover),
        ondragend: curry(trigger2, controller, {isEnd: true})
      }));
    },
    updateCoverShape: function(controller, cover, localRange, brushOption) {
      cover.childAt(0).setShape({
        points: clipByPanel(controller, cover, localRange)
      });
    },
    updateCommon,
    contain: mainShapeContain
  }
};
function getLineRenderer(xyIndex) {
  return {
    createCover: function(controller, brushOption) {
      return createBaseRectCover({
        toRectRange: function(range) {
          const rectRange = [range, [0, 100]];
          xyIndex && rectRange.reverse();
          return rectRange;
        },
        fromRectRange: function(rectRange) {
          return rectRange[xyIndex];
        }
      }, controller, brushOption, [[["w"], ["e"]], [["n"], ["s"]]][xyIndex]);
    },
    getCreatingRange: function(localTrack) {
      const ends = getTrackEnds(localTrack);
      const min3 = mathMin10(ends[0][xyIndex], ends[1][xyIndex]);
      const max3 = mathMax10(ends[0][xyIndex], ends[1][xyIndex]);
      return [min3, max3];
    },
    updateCoverShape: function(controller, cover, localRange, brushOption) {
      let otherExtent;
      const panel = getPanelByCover(controller, cover);
      if (panel !== BRUSH_PANEL_GLOBAL && panel.getLinearBrushOtherExtent) {
        otherExtent = panel.getLinearBrushOtherExtent(xyIndex);
      } else {
        const zr = controller._zr;
        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];
      }
      const rectRange = [localRange, otherExtent];
      xyIndex && rectRange.reverse();
      updateBaseRect(controller, cover, rectRange, brushOption);
    },
    updateCommon,
    contain: mainShapeContain
  };
}
var BrushController_default = BrushController;

// src/component/helper/brushHelper.ts
function makeRectPanelClipPath(rect) {
  rect = normalizeRect(rect);
  return function(localPoints) {
    return clipPointsByRect(localPoints, rect);
  };
}
function makeLinearBrushOtherExtent(rect, specifiedXYIndex) {
  rect = normalizeRect(rect);
  return function(xyIndex) {
    const idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex;
    const brushWidth = idx ? rect.width : rect.height;
    const base2 = idx ? rect.x : rect.y;
    return [base2, base2 + (brushWidth || 0)];
  };
}
function makeRectIsTargetByCursor(rect, api2, targetModel) {
  const boundingRect = normalizeRect(rect);
  return function(e2, localCursorPoint) {
    return boundingRect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e2, api2, targetModel);
  };
}
function normalizeRect(rect) {
  return BoundingRect_default.create(rect);
}

// src/component/axis/ParallelAxisView.ts
var elementList = ["axisLine", "axisTickLabel", "axisName"];
var ParallelAxisView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = ParallelAxisView2.type;
  }
  init(ecModel, api2) {
    super.init.apply(this, arguments);
    (this._brushController = new BrushController_default(api2.getZr())).on("brush", bind(this._onBrush, this));
  }
  render(axisModel, ecModel, api2, payload) {
    if (fromAxisAreaSelect(axisModel, ecModel, payload)) {
      return;
    }
    this.axisModel = axisModel;
    this.api = api2;
    this.group.removeAll();
    const oldAxisGroup = this._axisGroup;
    this._axisGroup = new Group_default();
    this.group.add(this._axisGroup);
    if (!axisModel.get("show")) {
      return;
    }
    const coordSysModel = getCoordSysModel(axisModel, ecModel);
    const coordSys = coordSysModel.coordinateSystem;
    const areaSelectStyle = axisModel.getAreaSelectStyle();
    const areaWidth = areaSelectStyle.width;
    const dim = axisModel.axis.dim;
    const axisLayout = coordSys.getAxisLayout(dim);
    const builderOpt = extend({strokeContainThreshold: areaWidth}, axisLayout);
    const axisBuilder = new AxisBuilder_default(axisModel, builderOpt);
    each(elementList, axisBuilder.add, axisBuilder);
    this._axisGroup.add(axisBuilder.getGroup());
    this._refreshBrushController(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api2);
    groupTransition(oldAxisGroup, this._axisGroup, axisModel);
  }
  _refreshBrushController(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api2) {
    const extent3 = axisModel.axis.getExtent();
    const extentLen = extent3[1] - extent3[0];
    const extra = Math.min(30, Math.abs(extentLen) * 0.1);
    const rect = BoundingRect_default.create({
      x: extent3[0],
      y: -areaWidth / 2,
      width: extentLen,
      height: areaWidth
    });
    rect.x -= extra;
    rect.width += 2 * extra;
    this._brushController.mount({
      enableGlobalPan: true,
      rotation: builderOpt.rotation,
      x: builderOpt.position[0],
      y: builderOpt.position[1]
    }).setPanels([{
      panelId: "pl",
      clipPath: makeRectPanelClipPath(rect),
      isTargetByCursor: makeRectIsTargetByCursor(rect, api2, coordSysModel),
      getLinearBrushOtherExtent: makeLinearBrushOtherExtent(rect, 0)
    }]).enableBrush({
      brushType: "lineX",
      brushStyle: areaSelectStyle,
      removeOnClick: true
    }).updateCovers(getCoverInfoList(axisModel));
  }
  _onBrush(eventParam) {
    const coverInfoList = eventParam.areas;
    const axisModel = this.axisModel;
    const axis = axisModel.axis;
    const intervals = map(coverInfoList, function(coverInfo) {
      return [
        axis.coordToData(coverInfo.range[0], true),
        axis.coordToData(coverInfo.range[1], true)
      ];
    });
    if (!axisModel.option.realtime === eventParam.isEnd || eventParam.removeOnClick) {
      this.api.dispatchAction({
        type: "axisAreaSelect",
        parallelAxisId: axisModel.id,
        intervals
      });
    }
  }
  dispose() {
    this._brushController.dispose();
  }
};
var ParallelAxisView = ParallelAxisView2;
ParallelAxisView.type = "parallelAxis";
function fromAxisAreaSelect(axisModel, ecModel, payload) {
  return payload && payload.type === "axisAreaSelect" && ecModel.findComponents({mainType: "parallelAxis", query: payload})[0] === axisModel;
}
function getCoverInfoList(axisModel) {
  const axis = axisModel.axis;
  return map(axisModel.activeIntervals, function(interval) {
    return {
      brushType: "lineX",
      panelId: "pl",
      range: [
        axis.dataToCoord(interval[0], true),
        axis.dataToCoord(interval[1], true)
      ]
    };
  });
}
function getCoordSysModel(axisModel, ecModel) {
  return ecModel.getComponent("parallel", axisModel.get("parallelIndex"));
}
var ParallelAxisView_default = ParallelAxisView;

// src/component/axis/parallelAxisAction.ts
var actionInfo2 = {
  type: "axisAreaSelect",
  event: "axisAreaSelected"
};
function installParallelActions(registers) {
  registers.registerAction(actionInfo2, function(payload, ecModel) {
    ecModel.eachComponent({mainType: "parallelAxis", query: payload}, function(parallelAxisModel) {
      parallelAxisModel.axis.model.setActiveIntervals(payload.intervals);
    });
  });
  registers.registerAction("parallelAxisExpand", function(payload, ecModel) {
    ecModel.eachComponent({mainType: "parallel", query: payload}, function(parallelModel) {
      parallelModel.setAxisExpand(payload);
    });
  });
}

// src/component/parallel/install.ts
var defaultAxisOption = {
  type: "value",
  areaSelectStyle: {
    width: 20,
    borderWidth: 1,
    borderColor: "rgba(160,197,232)",
    color: "rgba(160,197,232)",
    opacity: 0.3
  },
  realtime: true,
  z: 10
};
function install17(registers) {
  registers.registerComponentView(ParallelView_default2);
  registers.registerComponentModel(ParallelModel_default);
  registers.registerCoordinateSystem("parallel", parallelCreator_default);
  registers.registerPreprocessor(parallelPreprocessor);
  registers.registerComponentModel(AxisModel_default);
  registers.registerComponentView(ParallelAxisView_default);
  axisModelCreator(registers, "parallel", AxisModel_default, defaultAxisOption);
  installParallelActions(registers);
}

// src/chart/parallel/install.ts
function install18(registers) {
  use(install17);
  registers.registerChartView(ParallelView_default);
  registers.registerSeriesModel(ParallelSeries_default);
  registers.registerVisual(registers.PRIORITY.VISUAL.BRUSH, parallelVisual_default);
}

// src/chart/sankey/SankeyView.ts
var SankeyPathShape = class {
  constructor() {
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.cpx1 = 0;
    this.cpy1 = 0;
    this.cpx2 = 0;
    this.cpy2 = 0;
    this.extent = 0;
  }
};
var SankeyPath = class extends Path_default {
  constructor(opts) {
    super(opts);
  }
  getDefaultShape() {
    return new SankeyPathShape();
  }
  buildPath(ctx, shape) {
    const extent3 = shape.extent;
    ctx.moveTo(shape.x1, shape.y1);
    ctx.bezierCurveTo(shape.cpx1, shape.cpy1, shape.cpx2, shape.cpy2, shape.x2, shape.y2);
    if (shape.orient === "vertical") {
      ctx.lineTo(shape.x2 + extent3, shape.y2);
      ctx.bezierCurveTo(shape.cpx2 + extent3, shape.cpy2, shape.cpx1 + extent3, shape.cpy1, shape.x1 + extent3, shape.y1);
    } else {
      ctx.lineTo(shape.x2, shape.y2 + extent3);
      ctx.bezierCurveTo(shape.cpx2, shape.cpy2 + extent3, shape.cpx1, shape.cpy1 + extent3, shape.x1, shape.y1 + extent3);
    }
    ctx.closePath();
  }
  highlight() {
    enterEmphasis(this);
  }
  downplay() {
    leaveEmphasis(this);
  }
};
var SankeyView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = SankeyView2.type;
    this._focusAdjacencyDisabled = false;
  }
  render(seriesModel, ecModel, api2) {
    const sankeyView = this;
    const graph = seriesModel.getGraph();
    const group = this.group;
    const layoutInfo = seriesModel.layoutInfo;
    const width = layoutInfo.width;
    const height = layoutInfo.height;
    const nodeData = seriesModel.getData();
    const edgeData = seriesModel.getData("edge");
    const orient = seriesModel.get("orient");
    this._model = seriesModel;
    group.removeAll();
    group.x = layoutInfo.x;
    group.y = layoutInfo.y;
    graph.eachEdge(function(edge) {
      const curve4 = new SankeyPath();
      const ecData = getECData(curve4);
      ecData.dataIndex = edge.dataIndex;
      ecData.seriesIndex = seriesModel.seriesIndex;
      ecData.dataType = "edge";
      const edgeModel = edge.getModel();
      const lineStyleModel = edgeModel.getModel("lineStyle");
      const curvature = lineStyleModel.get("curveness");
      const n1Layout = edge.node1.getLayout();
      const node1Model = edge.node1.getModel();
      const dragX1 = node1Model.get("localX");
      const dragY1 = node1Model.get("localY");
      const n2Layout = edge.node2.getLayout();
      const node2Model = edge.node2.getModel();
      const dragX2 = node2Model.get("localX");
      const dragY2 = node2Model.get("localY");
      const edgeLayout = edge.getLayout();
      let x1;
      let y1;
      let x2;
      let y2;
      let cpx1;
      let cpy1;
      let cpx2;
      let cpy2;
      curve4.shape.extent = Math.max(1, edgeLayout.dy);
      curve4.shape.orient = orient;
      if (orient === "vertical") {
        x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + edgeLayout.sy;
        y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + n1Layout.dy;
        x2 = (dragX2 != null ? dragX2 * width : n2Layout.x) + edgeLayout.ty;
        y2 = dragY2 != null ? dragY2 * height : n2Layout.y;
        cpx1 = x1;
        cpy1 = y1 * (1 - curvature) + y2 * curvature;
        cpx2 = x2;
        cpy2 = y1 * curvature + y2 * (1 - curvature);
      } else {
        x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + n1Layout.dx;
        y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + edgeLayout.sy;
        x2 = dragX2 != null ? dragX2 * width : n2Layout.x;
        y2 = (dragY2 != null ? dragY2 * height : n2Layout.y) + edgeLayout.ty;
        cpx1 = x1 * (1 - curvature) + x2 * curvature;
        cpy1 = y1;
        cpx2 = x1 * curvature + x2 * (1 - curvature);
        cpy2 = y2;
      }
      curve4.setShape({
        x1,
        y1,
        x2,
        y2,
        cpx1,
        cpy1,
        cpx2,
        cpy2
      });
      curve4.useStyle(lineStyleModel.getItemStyle());
      applyCurveStyle(curve4.style, orient, edge);
      const defaultEdgeLabelText = `${edgeModel.get("value")}`;
      const edgeLabelStateModels = getLabelStatesModels(edgeModel, "edgeLabel");
      setLabelStyle(curve4, edgeLabelStateModels, {
        labelFetcher: {
          getFormattedLabel(dataIndex, stateName, dataType, labelDimIndex, formatter, extendParams) {
            return seriesModel.getFormattedLabel(dataIndex, stateName, "edge", labelDimIndex, retrieve3(formatter, edgeLabelStateModels.normal && edgeLabelStateModels.normal.get("formatter"), defaultEdgeLabelText), extendParams);
          }
        },
        labelDataIndex: edge.dataIndex,
        defaultText: defaultEdgeLabelText
      });
      curve4.setTextConfig({position: "inside"});
      const emphasisModel = edgeModel.getModel("emphasis");
      setStatesStylesFromModel(curve4, edgeModel, "lineStyle", (model) => {
        const style = model.getItemStyle();
        applyCurveStyle(style, orient, edge);
        return style;
      });
      group.add(curve4);
      edgeData.setItemGraphicEl(edge.dataIndex, curve4);
      const focus = emphasisModel.get("focus");
      toggleHoverEmphasis(curve4, focus === "adjacency" ? edge.getAdjacentDataIndices() : focus === "trajectory" ? edge.getTrajectoryDataIndices() : focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    });
    graph.eachNode(function(node) {
      const layout18 = node.getLayout();
      const itemModel = node.getModel();
      const dragX = itemModel.get("localX");
      const dragY = itemModel.get("localY");
      const emphasisModel = itemModel.getModel("emphasis");
      const rect = new Rect_default({
        shape: {
          x: dragX != null ? dragX * width : layout18.x,
          y: dragY != null ? dragY * height : layout18.y,
          width: layout18.dx,
          height: layout18.dy
        },
        style: itemModel.getModel("itemStyle").getItemStyle(),
        z2: 10
      });
      setLabelStyle(rect, getLabelStatesModels(itemModel), {
        labelFetcher: {
          getFormattedLabel(dataIndex, stateName) {
            return seriesModel.getFormattedLabel(dataIndex, stateName, "node");
          }
        },
        labelDataIndex: node.dataIndex,
        defaultText: node.id
      });
      rect.disableLabelAnimation = true;
      rect.setStyle("fill", node.getVisual("color"));
      rect.setStyle("decal", node.getVisual("style").decal);
      setStatesStylesFromModel(rect, itemModel);
      group.add(rect);
      nodeData.setItemGraphicEl(node.dataIndex, rect);
      getECData(rect).dataType = "node";
      const focus = emphasisModel.get("focus");
      toggleHoverEmphasis(rect, focus === "adjacency" ? node.getAdjacentDataIndices() : focus === "trajectory" ? node.getTrajectoryDataIndices() : focus, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    });
    nodeData.eachItemGraphicEl(function(el, dataIndex) {
      const itemModel = nodeData.getItemModel(dataIndex);
      if (itemModel.get("draggable")) {
        el.drift = function(dx, dy) {
          sankeyView._focusAdjacencyDisabled = true;
          this.shape.x += dx;
          this.shape.y += dy;
          this.dirty();
          api2.dispatchAction({
            type: "dragNode",
            seriesId: seriesModel.id,
            dataIndex: nodeData.getRawIndex(dataIndex),
            localX: this.shape.x / width,
            localY: this.shape.y / height
          });
        };
        el.ondragend = function() {
          sankeyView._focusAdjacencyDisabled = false;
        };
        el.draggable = true;
        el.cursor = "move";
      }
    });
    if (!this._data && seriesModel.isAnimationEnabled()) {
      group.setClipPath(createGridClipShape2(group.getBoundingRect(), seriesModel, function() {
        group.removeClipPath();
      }));
    }
    this._data = seriesModel.getData();
  }
  dispose() {
  }
};
var SankeyView = SankeyView2;
SankeyView.type = "sankey";
function applyCurveStyle(curveProps, orient, edge) {
  switch (curveProps.fill) {
    case "source":
      curveProps.fill = edge.node1.getVisual("color");
      curveProps.decal = edge.node1.getVisual("style").decal;
      break;
    case "target":
      curveProps.fill = edge.node2.getVisual("color");
      curveProps.decal = edge.node2.getVisual("style").decal;
      break;
    case "gradient":
      const sourceColor = edge.node1.getVisual("color");
      const targetColor = edge.node2.getVisual("color");
      if (isString(sourceColor) && isString(targetColor)) {
        curveProps.fill = new LinearGradient_default(0, 0, +(orient === "horizontal"), +(orient === "vertical"), [{
          color: sourceColor,
          offset: 0
        }, {
          color: targetColor,
          offset: 1
        }]);
      }
  }
}
function createGridClipShape2(rect, seriesModel, cb) {
  const rectEl = new Rect_default({
    shape: {
      x: rect.x - 10,
      y: rect.y - 10,
      width: 0,
      height: rect.height + 20
    }
  });
  initProps(rectEl, {
    shape: {
      width: rect.width + 20
    }
  }, seriesModel, cb);
  return rectEl;
}
var SankeyView_default = SankeyView;

// src/chart/sankey/SankeySeries.ts
var SankeySeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = SankeySeriesModel2.type;
  }
  getInitialData(option, ecModel) {
    const links = option.edges || option.links;
    const nodes = option.data || option.nodes;
    const levels = option.levels;
    this.levelModels = [];
    const levelModels = this.levelModels;
    for (let i = 0; i < levels.length; i++) {
      if (levels[i].depth != null && levels[i].depth >= 0) {
        levelModels[levels[i].depth] = new Model_default(levels[i], this, ecModel);
      } else {
        if (true) {
          throw new Error("levels[i].depth is mandatory and should be natural number");
        }
      }
    }
    if (nodes && links) {
      const graph = createGraphFromNodeEdge(nodes, links, this, true, beforeLink);
      return graph.data;
    }
    function beforeLink(nodeData, edgeData) {
      nodeData.wrapMethod("getItemModel", function(model, idx) {
        const seriesModel = model.parentModel;
        const layout18 = seriesModel.getData().getItemLayout(idx);
        if (layout18) {
          const nodeDepth = layout18.depth;
          const levelModel = seriesModel.levelModels[nodeDepth];
          if (levelModel) {
            model.parentModel = levelModel;
          }
        }
        return model;
      });
      edgeData.wrapMethod("getItemModel", function(model, idx) {
        const seriesModel = model.parentModel;
        const edge = seriesModel.getGraph().getEdgeByIndex(idx);
        const layout18 = edge.node1.getLayout();
        if (layout18) {
          const depth = layout18.depth;
          const levelModel = seriesModel.levelModels[depth];
          if (levelModel) {
            model.parentModel = levelModel;
          }
        }
        return model;
      });
    }
  }
  setNodePosition(dataIndex, localPosition) {
    const nodes = this.option.data || this.option.nodes;
    const dataItem = nodes[dataIndex];
    dataItem.localX = localPosition[0];
    dataItem.localY = localPosition[1];
  }
  getGraph() {
    return this.getData().graph;
  }
  getEdgeData() {
    return this.getGraph().edgeData;
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    function noValue(val) {
      return isNaN(val) || val == null;
    }
    if (dataType === "edge") {
      const params = this.getDataParams(dataIndex, dataType);
      const rawDataOpt = params.data;
      const edgeValue = params.value;
      const edgeName = rawDataOpt.source + " -- " + rawDataOpt.target;
      return createTooltipMarkup("nameValue", {
        name: edgeName,
        value: edgeValue,
        noValue: noValue(edgeValue)
      });
    } else {
      const node = this.getGraph().getNodeByIndex(dataIndex);
      const value = node.getLayout().value;
      const name = this.getDataParams(dataIndex, dataType).data.name;
      return createTooltipMarkup("nameValue", {
        name: name != null ? name + "" : null,
        value,
        noValue: noValue(value)
      });
    }
  }
  optionUpdated() {
  }
  getDataParams(dataIndex, dataType) {
    const params = super.getDataParams(dataIndex, dataType);
    if (params.value == null && dataType === "node") {
      const node = this.getGraph().getNodeByIndex(dataIndex);
      const nodeValue = node.getLayout().value;
      params.value = nodeValue;
    }
    return params;
  }
};
var SankeySeriesModel = SankeySeriesModel2;
SankeySeriesModel.type = "series.sankey";
SankeySeriesModel.defaultOption = {
  z: 2,
  coordinateSystem: "view",
  left: "5%",
  top: "5%",
  right: "20%",
  bottom: "5%",
  orient: "horizontal",
  nodeWidth: 20,
  nodeGap: 8,
  draggable: true,
  layoutIterations: 32,
  label: {
    show: true,
    position: "right",
    fontSize: 12
  },
  edgeLabel: {
    show: false,
    fontSize: 12
  },
  levels: [],
  nodeAlign: "justify",
  lineStyle: {
    color: "#314656",
    opacity: 0.2,
    curveness: 0.5
  },
  emphasis: {
    label: {
      show: true
    },
    lineStyle: {
      opacity: 0.5
    }
  },
  select: {
    itemStyle: {
      borderColor: "#212121"
    }
  },
  animationEasing: "linear",
  animationDuration: 1e3
};
var SankeySeries_default = SankeySeriesModel;

// src/chart/sankey/sankeyLayout.ts
function sankeyLayout(ecModel, api2) {
  ecModel.eachSeriesByType("sankey", function(seriesModel) {
    const nodeWidth = seriesModel.get("nodeWidth");
    const nodeGap = seriesModel.get("nodeGap");
    const layoutInfo = getViewRect5(seriesModel, api2);
    seriesModel.layoutInfo = layoutInfo;
    const width = layoutInfo.width;
    const height = layoutInfo.height;
    const graph = seriesModel.getGraph();
    const nodes = graph.nodes;
    const edges = graph.edges;
    computeNodeValues(nodes);
    const filteredNodes = filter(nodes, function(node) {
      return node.getLayout().value === 0;
    });
    const iterations = filteredNodes.length !== 0 ? 0 : seriesModel.get("layoutIterations");
    const orient = seriesModel.get("orient");
    const nodeAlign = seriesModel.get("nodeAlign");
    layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign);
  });
}
function getViewRect5(seriesModel, api2) {
  return getLayoutRect(seriesModel.getBoxLayoutParams(), {
    width: api2.getWidth(),
    height: api2.getHeight()
  });
}
function layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign) {
  computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign);
  computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient);
  computeEdgeDepths(nodes, orient);
}
function computeNodeValues(nodes) {
  each(nodes, function(node) {
    const value1 = sum(node.outEdges, getEdgeValue);
    const value2 = sum(node.inEdges, getEdgeValue);
    const nodeRawValue = node.getValue() || 0;
    const value = Math.max(value1, value2, nodeRawValue);
    node.setLayout({value}, true);
  });
}
function computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign) {
  const remainEdges = [];
  const indegreeArr = [];
  let zeroIndegrees = [];
  let nextTargetNode = [];
  let x = 0;
  for (let i = 0; i < edges.length; i++) {
    remainEdges[i] = 1;
  }
  for (let i = 0; i < nodes.length; i++) {
    indegreeArr[i] = nodes[i].inEdges.length;
    if (indegreeArr[i] === 0) {
      zeroIndegrees.push(nodes[i]);
    }
  }
  let maxNodeDepth = -1;
  while (zeroIndegrees.length) {
    for (let idx = 0; idx < zeroIndegrees.length; idx++) {
      const node = zeroIndegrees[idx];
      const item = node.hostGraph.data.getRawDataItem(node.dataIndex);
      const isItemDepth = item.depth != null && item.depth >= 0;
      if (isItemDepth && item.depth > maxNodeDepth) {
        maxNodeDepth = item.depth;
      }
      node.setLayout({depth: isItemDepth ? item.depth : x}, true);
      orient === "vertical" ? node.setLayout({dy: nodeWidth}, true) : node.setLayout({dx: nodeWidth}, true);
      for (let edgeIdx = 0; edgeIdx < node.outEdges.length; edgeIdx++) {
        const edge = node.outEdges[edgeIdx];
        const indexEdge = edges.indexOf(edge);
        remainEdges[indexEdge] = 0;
        const targetNode = edge.node2;
        const nodeIndex = nodes.indexOf(targetNode);
        if (--indegreeArr[nodeIndex] === 0 && nextTargetNode.indexOf(targetNode) < 0) {
          nextTargetNode.push(targetNode);
        }
      }
    }
    ++x;
    zeroIndegrees = nextTargetNode;
    nextTargetNode = [];
  }
  for (let i = 0; i < remainEdges.length; i++) {
    if (remainEdges[i] === 1) {
      throw new Error("Sankey is a DAG, the original data has cycle!");
    }
  }
  const maxDepth = maxNodeDepth > x - 1 ? maxNodeDepth : x - 1;
  if (nodeAlign && nodeAlign !== "left") {
    adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth);
  }
  const kx = orient === "vertical" ? (height - nodeWidth) / maxDepth : (width - nodeWidth) / maxDepth;
  scaleNodeBreadths(nodes, kx, orient);
}
function isNodeDepth(node) {
  const item = node.hostGraph.data.getRawDataItem(node.dataIndex);
  return item.depth != null && item.depth >= 0;
}
function adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth) {
  if (nodeAlign === "right") {
    let nextSourceNode = [];
    let remainNodes = nodes;
    let nodeHeight = 0;
    while (remainNodes.length) {
      for (let i = 0; i < remainNodes.length; i++) {
        const node = remainNodes[i];
        node.setLayout({skNodeHeight: nodeHeight}, true);
        for (let j = 0; j < node.inEdges.length; j++) {
          const edge = node.inEdges[j];
          if (nextSourceNode.indexOf(edge.node1) < 0) {
            nextSourceNode.push(edge.node1);
          }
        }
      }
      remainNodes = nextSourceNode;
      nextSourceNode = [];
      ++nodeHeight;
    }
    each(nodes, function(node) {
      if (!isNodeDepth(node)) {
        node.setLayout({depth: Math.max(0, maxDepth - node.getLayout().skNodeHeight)}, true);
      }
    });
  } else if (nodeAlign === "justify") {
    moveSinksRight(nodes, maxDepth);
  }
}
function moveSinksRight(nodes, maxDepth) {
  each(nodes, function(node) {
    if (!isNodeDepth(node) && !node.outEdges.length) {
      node.setLayout({depth: maxDepth}, true);
    }
  });
}
function scaleNodeBreadths(nodes, kx, orient) {
  each(nodes, function(node) {
    const nodeDepth = node.getLayout().depth * kx;
    orient === "vertical" ? node.setLayout({y: nodeDepth}, true) : node.setLayout({x: nodeDepth}, true);
  });
}
function computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient) {
  const nodesByBreadth = prepareNodesByBreadth(nodes, orient);
  initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient);
  resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
  for (let alpha = 1; iterations > 0; iterations--) {
    alpha *= 0.99;
    relaxRightToLeft(nodesByBreadth, alpha, orient);
    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
    relaxLeftToRight(nodesByBreadth, alpha, orient);
    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);
  }
}
function prepareNodesByBreadth(nodes, orient) {
  const nodesByBreadth = [];
  const keyAttr = orient === "vertical" ? "y" : "x";
  const groupResult = groupData(nodes, function(node) {
    return node.getLayout()[keyAttr];
  });
  groupResult.keys.sort(function(a, b) {
    return a - b;
  });
  each(groupResult.keys, function(key) {
    nodesByBreadth.push(groupResult.buckets.get(key));
  });
  return nodesByBreadth;
}
function initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient) {
  let minKy = Infinity;
  each(nodesByBreadth, function(nodes) {
    const n = nodes.length;
    let sum2 = 0;
    each(nodes, function(node) {
      sum2 += node.getLayout().value;
    });
    const ky = orient === "vertical" ? (width - (n - 1) * nodeGap) / sum2 : (height - (n - 1) * nodeGap) / sum2;
    if (ky < minKy) {
      minKy = ky;
    }
  });
  each(nodesByBreadth, function(nodes) {
    each(nodes, function(node, i) {
      const nodeDy = node.getLayout().value * minKy;
      if (orient === "vertical") {
        node.setLayout({x: i}, true);
        node.setLayout({dx: nodeDy}, true);
      } else {
        node.setLayout({y: i}, true);
        node.setLayout({dy: nodeDy}, true);
      }
    });
  });
  each(edges, function(edge) {
    const edgeDy = +edge.getValue() * minKy;
    edge.setLayout({dy: edgeDy}, true);
  });
}
function resolveCollisions(nodesByBreadth, nodeGap, height, width, orient) {
  const keyAttr = orient === "vertical" ? "x" : "y";
  each(nodesByBreadth, function(nodes) {
    nodes.sort(function(a, b) {
      return a.getLayout()[keyAttr] - b.getLayout()[keyAttr];
    });
    let nodeX;
    let node;
    let dy;
    let y0 = 0;
    const n = nodes.length;
    const nodeDyAttr = orient === "vertical" ? "dx" : "dy";
    for (let i = 0; i < n; i++) {
      node = nodes[i];
      dy = y0 - node.getLayout()[keyAttr];
      if (dy > 0) {
        nodeX = node.getLayout()[keyAttr] + dy;
        orient === "vertical" ? node.setLayout({x: nodeX}, true) : node.setLayout({y: nodeX}, true);
      }
      y0 = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap;
    }
    const viewWidth = orient === "vertical" ? width : height;
    dy = y0 - nodeGap - viewWidth;
    if (dy > 0) {
      nodeX = node.getLayout()[keyAttr] - dy;
      orient === "vertical" ? node.setLayout({x: nodeX}, true) : node.setLayout({y: nodeX}, true);
      y0 = nodeX;
      for (let i = n - 2; i >= 0; --i) {
        node = nodes[i];
        dy = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap - y0;
        if (dy > 0) {
          nodeX = node.getLayout()[keyAttr] - dy;
          orient === "vertical" ? node.setLayout({x: nodeX}, true) : node.setLayout({y: nodeX}, true);
        }
        y0 = node.getLayout()[keyAttr];
      }
    }
  });
}
function relaxRightToLeft(nodesByBreadth, alpha, orient) {
  each(nodesByBreadth.slice().reverse(), function(nodes) {
    each(nodes, function(node) {
      if (node.outEdges.length) {
        let y = sum(node.outEdges, weightedTarget, orient) / sum(node.outEdges, getEdgeValue);
        if (isNaN(y)) {
          const len2 = node.outEdges.length;
          y = len2 ? sum(node.outEdges, centerTarget, orient) / len2 : 0;
        }
        if (orient === "vertical") {
          const nodeX = node.getLayout().x + (y - center2(node, orient)) * alpha;
          node.setLayout({x: nodeX}, true);
        } else {
          const nodeY = node.getLayout().y + (y - center2(node, orient)) * alpha;
          node.setLayout({y: nodeY}, true);
        }
      }
    });
  });
}
function weightedTarget(edge, orient) {
  return center2(edge.node2, orient) * edge.getValue();
}
function centerTarget(edge, orient) {
  return center2(edge.node2, orient);
}
function weightedSource(edge, orient) {
  return center2(edge.node1, orient) * edge.getValue();
}
function centerSource(edge, orient) {
  return center2(edge.node1, orient);
}
function center2(node, orient) {
  return orient === "vertical" ? node.getLayout().x + node.getLayout().dx / 2 : node.getLayout().y + node.getLayout().dy / 2;
}
function getEdgeValue(edge) {
  return edge.getValue();
}
function sum(array, cb, orient) {
  let sum2 = 0;
  const len2 = array.length;
  let i = -1;
  while (++i < len2) {
    const value = +cb(array[i], orient);
    if (!isNaN(value)) {
      sum2 += value;
    }
  }
  return sum2;
}
function relaxLeftToRight(nodesByBreadth, alpha, orient) {
  each(nodesByBreadth, function(nodes) {
    each(nodes, function(node) {
      if (node.inEdges.length) {
        let y = sum(node.inEdges, weightedSource, orient) / sum(node.inEdges, getEdgeValue);
        if (isNaN(y)) {
          const len2 = node.inEdges.length;
          y = len2 ? sum(node.inEdges, centerSource, orient) / len2 : 0;
        }
        if (orient === "vertical") {
          const nodeX = node.getLayout().x + (y - center2(node, orient)) * alpha;
          node.setLayout({x: nodeX}, true);
        } else {
          const nodeY = node.getLayout().y + (y - center2(node, orient)) * alpha;
          node.setLayout({y: nodeY}, true);
        }
      }
    });
  });
}
function computeEdgeDepths(nodes, orient) {
  const keyAttr = orient === "vertical" ? "x" : "y";
  each(nodes, function(node) {
    node.outEdges.sort(function(a, b) {
      return a.node2.getLayout()[keyAttr] - b.node2.getLayout()[keyAttr];
    });
    node.inEdges.sort(function(a, b) {
      return a.node1.getLayout()[keyAttr] - b.node1.getLayout()[keyAttr];
    });
  });
  each(nodes, function(node) {
    let sy = 0;
    let ty = 0;
    each(node.outEdges, function(edge) {
      edge.setLayout({sy}, true);
      sy += edge.getLayout().dy;
    });
    each(node.inEdges, function(edge) {
      edge.setLayout({ty}, true);
      ty += edge.getLayout().dy;
    });
  });
}

// src/chart/sankey/sankeyVisual.ts
function sankeyVisual(ecModel) {
  ecModel.eachSeriesByType("sankey", function(seriesModel) {
    const graph = seriesModel.getGraph();
    const nodes = graph.nodes;
    const edges = graph.edges;
    if (nodes.length) {
      let minValue = Infinity;
      let maxValue = -Infinity;
      each(nodes, function(node) {
        const nodeValue = node.getLayout().value;
        if (nodeValue < minValue) {
          minValue = nodeValue;
        }
        if (nodeValue > maxValue) {
          maxValue = nodeValue;
        }
      });
      each(nodes, function(node) {
        const mapping = new VisualMapping_default({
          type: "color",
          mappingMethod: "linear",
          dataExtent: [minValue, maxValue],
          visual: seriesModel.get("color")
        });
        const mapValueToColor = mapping.mapValueToVisual(node.getLayout().value);
        const customColor = node.getModel().get(["itemStyle", "color"]);
        if (customColor != null) {
          node.setVisual("color", customColor);
          node.setVisual("style", {fill: customColor});
        } else {
          node.setVisual("color", mapValueToColor);
          node.setVisual("style", {fill: mapValueToColor});
        }
      });
    }
    if (edges.length) {
      each(edges, function(edge) {
        const edgeStyle = edge.getModel().get("lineStyle");
        edge.setVisual("style", edgeStyle);
      });
    }
  });
}

// src/chart/sankey/install.ts
function install19(registers) {
  registers.registerChartView(SankeyView_default);
  registers.registerSeriesModel(SankeySeries_default);
  registers.registerLayout(sankeyLayout);
  registers.registerVisual(sankeyVisual);
  registers.registerAction({
    type: "dragNode",
    event: "dragnode",
    update: "update"
  }, function(payload, ecModel) {
    ecModel.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: payload
    }, function(seriesModel) {
      seriesModel.setNodePosition(payload.dataIndex, [payload.localX, payload.localY]);
    });
  });
}

// src/chart/helper/whiskerBoxCommon.ts
var WhiskerBoxCommonMixin = class {
  getInitialData(option, ecModel) {
    let ordinalMeta;
    const xAxisModel = ecModel.getComponent("xAxis", this.get("xAxisIndex"));
    const yAxisModel = ecModel.getComponent("yAxis", this.get("yAxisIndex"));
    const xAxisType = xAxisModel.get("type");
    const yAxisType = yAxisModel.get("type");
    let addOrdinal;
    if (xAxisType === "category") {
      option.layout = "horizontal";
      ordinalMeta = xAxisModel.getOrdinalMeta();
      addOrdinal = true;
    } else if (yAxisType === "category") {
      option.layout = "vertical";
      ordinalMeta = yAxisModel.getOrdinalMeta();
      addOrdinal = true;
    } else {
      option.layout = option.layout || "horizontal";
    }
    const coordDims = ["x", "y"];
    const baseAxisDimIndex = option.layout === "horizontal" ? 0 : 1;
    const baseAxisDim = this._baseAxisDim = coordDims[baseAxisDimIndex];
    const otherAxisDim = coordDims[1 - baseAxisDimIndex];
    const axisModels = [xAxisModel, yAxisModel];
    const baseAxisType = axisModels[baseAxisDimIndex].get("type");
    const otherAxisType = axisModels[1 - baseAxisDimIndex].get("type");
    const data = option.data;
    if (data && addOrdinal) {
      const newOptionData = [];
      each(data, function(item, index) {
        let newItem;
        if (isArray(item)) {
          newItem = item.slice();
          item.unshift(index);
        } else if (isArray(item.value)) {
          newItem = extend({}, item);
          newItem.value = newItem.value.slice();
          item.value.unshift(index);
        } else {
          newItem = item;
        }
        newOptionData.push(newItem);
      });
      option.data = newOptionData;
    }
    const defaultValueDimensions = this.defaultValueDimensions;
    const coordDimensions = [{
      name: baseAxisDim,
      type: getDimensionTypeByAxis(baseAxisType),
      ordinalMeta,
      otherDims: {
        tooltip: false,
        itemName: 0
      },
      dimsDef: ["base"]
    }, {
      name: otherAxisDim,
      type: getDimensionTypeByAxis(otherAxisType),
      dimsDef: defaultValueDimensions.slice()
    }];
    return createSeriesDataSimply(this, {
      coordDimensions,
      dimensionsCount: defaultValueDimensions.length + 1,
      encodeDefaulter: curry(makeSeriesEncodeForAxisCoordSys, coordDimensions, this)
    });
  }
  getBaseAxis() {
    const dim = this._baseAxisDim;
    return this.ecModel.getComponent(dim + "Axis", this.get(dim + "AxisIndex")).axis;
  }
};

// src/chart/boxplot/BoxplotSeries.ts
var BoxplotSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = BoxplotSeriesModel2.type;
    this.defaultValueDimensions = [
      {name: "min", defaultTooltip: true},
      {name: "Q1", defaultTooltip: true},
      {name: "median", defaultTooltip: true},
      {name: "Q3", defaultTooltip: true},
      {name: "max", defaultTooltip: true}
    ];
    this.visualDrawType = "stroke";
  }
};
var BoxplotSeriesModel = BoxplotSeriesModel2;
BoxplotSeriesModel.type = "series.boxplot";
BoxplotSeriesModel.dependencies = ["xAxis", "yAxis", "grid"];
BoxplotSeriesModel.defaultOption = {
  z: 2,
  coordinateSystem: "cartesian2d",
  legendHoverLink: true,
  layout: null,
  boxWidth: [7, 50],
  itemStyle: {
    color: "#fff",
    borderWidth: 1
  },
  emphasis: {
    scale: true,
    itemStyle: {
      borderWidth: 2,
      shadowBlur: 5,
      shadowOffsetX: 1,
      shadowOffsetY: 1,
      shadowColor: "rgba(0,0,0,0.2)"
    }
  },
  animationDuration: 800
};
mixin(BoxplotSeriesModel, WhiskerBoxCommonMixin, true);
var BoxplotSeries_default = BoxplotSeriesModel;

// src/chart/boxplot/BoxplotView.ts
var BoxplotView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = BoxplotView2.type;
  }
  render(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    const group = this.group;
    const oldData = this._data;
    if (!this._data) {
      group.removeAll();
    }
    const constDim = seriesModel.get("layout") === "horizontal" ? 1 : 0;
    data.diff(oldData).add(function(newIdx) {
      if (data.hasValue(newIdx)) {
        const itemLayout = data.getItemLayout(newIdx);
        const symbolEl = createNormalBox(itemLayout, data, newIdx, constDim, true);
        data.setItemGraphicEl(newIdx, symbolEl);
        group.add(symbolEl);
      }
    }).update(function(newIdx, oldIdx) {
      let symbolEl = oldData.getItemGraphicEl(oldIdx);
      if (!data.hasValue(newIdx)) {
        group.remove(symbolEl);
        return;
      }
      const itemLayout = data.getItemLayout(newIdx);
      if (!symbolEl) {
        symbolEl = createNormalBox(itemLayout, data, newIdx, constDim);
      } else {
        saveOldStyle(symbolEl);
        updateNormalBoxData(itemLayout, symbolEl, data, newIdx);
      }
      group.add(symbolEl);
      data.setItemGraphicEl(newIdx, symbolEl);
    }).remove(function(oldIdx) {
      const el = oldData.getItemGraphicEl(oldIdx);
      el && group.remove(el);
    }).execute();
    this._data = data;
  }
  remove(ecModel) {
    const group = this.group;
    const data = this._data;
    this._data = null;
    data && data.eachItemGraphicEl(function(el) {
      el && group.remove(el);
    });
  }
};
var BoxplotView = BoxplotView2;
BoxplotView.type = "boxplot";
var BoxPathShape = class {
};
var BoxPath = class extends Path_default {
  constructor(opts) {
    super(opts);
    this.type = "boxplotBoxPath";
  }
  getDefaultShape() {
    return new BoxPathShape();
  }
  buildPath(ctx, shape) {
    const ends = shape.points;
    let i = 0;
    ctx.moveTo(ends[i][0], ends[i][1]);
    i++;
    for (; i < 4; i++) {
      ctx.lineTo(ends[i][0], ends[i][1]);
    }
    ctx.closePath();
    for (; i < ends.length; i++) {
      ctx.moveTo(ends[i][0], ends[i][1]);
      i++;
      ctx.lineTo(ends[i][0], ends[i][1]);
    }
  }
};
function createNormalBox(itemLayout, data, dataIndex, constDim, isInit) {
  const ends = itemLayout.ends;
  const el = new BoxPath({
    shape: {
      points: isInit ? transInit(ends, constDim, itemLayout) : ends
    }
  });
  updateNormalBoxData(itemLayout, el, data, dataIndex, isInit);
  return el;
}
function updateNormalBoxData(itemLayout, el, data, dataIndex, isInit) {
  const seriesModel = data.hostModel;
  const updateMethod = graphic_exports[isInit ? "initProps" : "updateProps"];
  updateMethod(el, {shape: {points: itemLayout.ends}}, seriesModel, dataIndex);
  el.useStyle(data.getItemVisual(dataIndex, "style"));
  el.style.strokeNoScale = true;
  el.z2 = 100;
  const itemModel = data.getItemModel(dataIndex);
  const emphasisModel = itemModel.getModel("emphasis");
  setStatesStylesFromModel(el, itemModel);
  toggleHoverEmphasis(el, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
}
function transInit(points4, dim, itemLayout) {
  return map(points4, function(point) {
    point = point.slice();
    point[dim] = itemLayout.initBaseline;
    return point;
  });
}
var BoxplotView_default = BoxplotView;

// src/chart/boxplot/boxplotLayout.ts
var each7 = each;
function boxplotLayout(ecModel) {
  const groupResult = groupSeriesByAxis(ecModel);
  each7(groupResult, function(groupItem) {
    const seriesModels = groupItem.seriesModels;
    if (!seriesModels.length) {
      return;
    }
    calculateBase(groupItem);
    each7(seriesModels, function(seriesModel, idx) {
      layoutSingleSeries(seriesModel, groupItem.boxOffsetList[idx], groupItem.boxWidthList[idx]);
    });
  });
}
function groupSeriesByAxis(ecModel) {
  const result = [];
  const axisList = [];
  ecModel.eachSeriesByType("boxplot", function(seriesModel) {
    const baseAxis = seriesModel.getBaseAxis();
    let idx = indexOf(axisList, baseAxis);
    if (idx < 0) {
      idx = axisList.length;
      axisList[idx] = baseAxis;
      result[idx] = {
        axis: baseAxis,
        seriesModels: []
      };
    }
    result[idx].seriesModels.push(seriesModel);
  });
  return result;
}
function calculateBase(groupItem) {
  const baseAxis = groupItem.axis;
  const seriesModels = groupItem.seriesModels;
  const seriesCount = seriesModels.length;
  const boxWidthList = groupItem.boxWidthList = [];
  const boxOffsetList = groupItem.boxOffsetList = [];
  const boundList = [];
  let bandWidth;
  if (baseAxis.type === "category") {
    bandWidth = baseAxis.getBandWidth();
  } else {
    let maxDataCount = 0;
    each7(seriesModels, function(seriesModel) {
      maxDataCount = Math.max(maxDataCount, seriesModel.getData().count());
    });
    const extent3 = baseAxis.getExtent();
    bandWidth = Math.abs(extent3[1] - extent3[0]) / maxDataCount;
  }
  each7(seriesModels, function(seriesModel) {
    let boxWidthBound = seriesModel.get("boxWidth");
    if (!isArray(boxWidthBound)) {
      boxWidthBound = [boxWidthBound, boxWidthBound];
    }
    boundList.push([
      parsePercent2(boxWidthBound[0], bandWidth) || 0,
      parsePercent2(boxWidthBound[1], bandWidth) || 0
    ]);
  });
  const availableWidth = bandWidth * 0.8 - 2;
  const boxGap = availableWidth / seriesCount * 0.3;
  const boxWidth = (availableWidth - boxGap * (seriesCount - 1)) / seriesCount;
  let base2 = boxWidth / 2 - availableWidth / 2;
  each7(seriesModels, function(seriesModel, idx) {
    boxOffsetList.push(base2);
    base2 += boxGap + boxWidth;
    boxWidthList.push(Math.min(Math.max(boxWidth, boundList[idx][0]), boundList[idx][1]));
  });
}
function layoutSingleSeries(seriesModel, offset, boxWidth) {
  const coordSys = seriesModel.coordinateSystem;
  const data = seriesModel.getData();
  const halfWidth = boxWidth / 2;
  const cDimIdx = seriesModel.get("layout") === "horizontal" ? 0 : 1;
  const vDimIdx = 1 - cDimIdx;
  const coordDims = ["x", "y"];
  const cDim = data.mapDimension(coordDims[cDimIdx]);
  const vDims = data.mapDimensionsAll(coordDims[vDimIdx]);
  if (cDim == null || vDims.length < 5) {
    return;
  }
  for (let dataIndex = 0; dataIndex < data.count(); dataIndex++) {
    const axisDimVal = data.get(cDim, dataIndex);
    const median = getPoint(axisDimVal, vDims[2], dataIndex);
    const end1 = getPoint(axisDimVal, vDims[0], dataIndex);
    const end2 = getPoint(axisDimVal, vDims[1], dataIndex);
    const end4 = getPoint(axisDimVal, vDims[3], dataIndex);
    const end5 = getPoint(axisDimVal, vDims[4], dataIndex);
    const ends = [];
    addBodyEnd(ends, end2, false);
    addBodyEnd(ends, end4, true);
    ends.push(end1, end2, end5, end4);
    layEndLine(ends, end1);
    layEndLine(ends, end5);
    layEndLine(ends, median);
    data.setItemLayout(dataIndex, {
      initBaseline: median[vDimIdx],
      ends
    });
  }
  function getPoint(axisDimVal, dim, dataIndex) {
    const val = data.get(dim, dataIndex);
    const p = [];
    p[cDimIdx] = axisDimVal;
    p[vDimIdx] = val;
    let point;
    if (isNaN(axisDimVal) || isNaN(val)) {
      point = [NaN, NaN];
    } else {
      point = coordSys.dataToPoint(p);
      point[cDimIdx] += offset;
    }
    return point;
  }
  function addBodyEnd(ends, point, start2) {
    const point1 = point.slice();
    const point2 = point.slice();
    point1[cDimIdx] += halfWidth;
    point2[cDimIdx] -= halfWidth;
    start2 ? ends.push(point1, point2) : ends.push(point2, point1);
  }
  function layEndLine(ends, endCenter) {
    const from = endCenter.slice();
    const to = endCenter.slice();
    from[cDimIdx] -= halfWidth;
    to[cDimIdx] += halfWidth;
    ends.push(from, to);
  }
}

// src/chart/boxplot/prepareBoxplotData.ts
function prepareBoxplotData(rawData, opt) {
  opt = opt || {};
  const boxData = [];
  const outliers = [];
  const boundIQR = opt.boundIQR;
  const useExtreme = boundIQR === "none" || boundIQR === 0;
  for (let i = 0; i < rawData.length; i++) {
    const ascList = asc(rawData[i].slice());
    const Q1 = quantile(ascList, 0.25);
    const Q2 = quantile(ascList, 0.5);
    const Q3 = quantile(ascList, 0.75);
    const min3 = ascList[0];
    const max3 = ascList[ascList.length - 1];
    const bound = (boundIQR == null ? 1.5 : boundIQR) * (Q3 - Q1);
    const low = useExtreme ? min3 : Math.max(min3, Q1 - bound);
    const high = useExtreme ? max3 : Math.min(max3, Q3 + bound);
    const itemNameFormatter = opt.itemNameFormatter;
    const itemName = isFunction(itemNameFormatter) ? itemNameFormatter({value: i}) : isString(itemNameFormatter) ? itemNameFormatter.replace("{value}", i + "") : i + "";
    boxData.push([itemName, low, Q1, Q2, Q3, high]);
    for (let j = 0; j < ascList.length; j++) {
      const dataItem = ascList[j];
      if (dataItem < low || dataItem > high) {
        const outlier = [itemName, dataItem];
        outliers.push(outlier);
      }
    }
  }
  return {
    boxData,
    outliers
  };
}

// src/chart/boxplot/boxplotTransform.ts
var boxplotTransform = {
  type: "echarts:boxplot",
  transform: function transform(params) {
    const upstream = params.upstream;
    if (upstream.sourceFormat !== SOURCE_FORMAT_ARRAY_ROWS) {
      let errMsg = "";
      if (true) {
        errMsg = makePrintable("source data is not applicable for this boxplot transform. Expect number[][].");
      }
      throwError(errMsg);
    }
    const result = prepareBoxplotData(upstream.getRawData(), params.config);
    return [{
      dimensions: ["ItemName", "Low", "Q1", "Q2", "Q3", "High"],
      data: result.boxData
    }, {
      data: result.outliers
    }];
  }
};

// src/chart/boxplot/install.ts
function install20(registers) {
  registers.registerSeriesModel(BoxplotSeries_default);
  registers.registerChartView(BoxplotView_default);
  registers.registerLayout(boxplotLayout);
  registers.registerTransform(boxplotTransform);
}

// src/chart/candlestick/CandlestickView.ts
var SKIP_PROPS = ["color", "borderColor"];
var CandlestickView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = CandlestickView2.type;
  }
  render(seriesModel, ecModel, api2) {
    this.group.removeClipPath();
    this._progressiveEls = null;
    this._updateDrawMode(seriesModel);
    this._isLargeDraw ? this._renderLarge(seriesModel) : this._renderNormal(seriesModel);
  }
  incrementalPrepareRender(seriesModel, ecModel, api2) {
    this._clear();
    this._updateDrawMode(seriesModel);
  }
  incrementalRender(params, seriesModel, ecModel, api2) {
    this._progressiveEls = [];
    this._isLargeDraw ? this._incrementalRenderLarge(params, seriesModel) : this._incrementalRenderNormal(params, seriesModel);
  }
  eachRendered(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  }
  _updateDrawMode(seriesModel) {
    const isLargeDraw = seriesModel.pipelineContext.large;
    if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {
      this._isLargeDraw = isLargeDraw;
      this._clear();
    }
  }
  _renderNormal(seriesModel) {
    const data = seriesModel.getData();
    const oldData = this._data;
    const group = this.group;
    const isSimpleBox = data.getLayout("isSimpleBox");
    const needsClip = seriesModel.get("clip", true);
    const coord = seriesModel.coordinateSystem;
    const clipArea = coord.getArea && coord.getArea();
    if (!this._data) {
      group.removeAll();
    }
    data.diff(oldData).add(function(newIdx) {
      if (data.hasValue(newIdx)) {
        const itemLayout = data.getItemLayout(newIdx);
        if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
          return;
        }
        const el = createNormalBox2(itemLayout, newIdx, true);
        initProps(el, {shape: {points: itemLayout.ends}}, seriesModel, newIdx);
        setBoxCommon(el, data, newIdx, isSimpleBox);
        group.add(el);
        data.setItemGraphicEl(newIdx, el);
      }
    }).update(function(newIdx, oldIdx) {
      let el = oldData.getItemGraphicEl(oldIdx);
      if (!data.hasValue(newIdx)) {
        group.remove(el);
        return;
      }
      const itemLayout = data.getItemLayout(newIdx);
      if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
        group.remove(el);
        return;
      }
      if (!el) {
        el = createNormalBox2(itemLayout, newIdx);
      } else {
        updateProps(el, {
          shape: {
            points: itemLayout.ends
          }
        }, seriesModel, newIdx);
        saveOldStyle(el);
      }
      setBoxCommon(el, data, newIdx, isSimpleBox);
      group.add(el);
      data.setItemGraphicEl(newIdx, el);
    }).remove(function(oldIdx) {
      const el = oldData.getItemGraphicEl(oldIdx);
      el && group.remove(el);
    }).execute();
    this._data = data;
  }
  _renderLarge(seriesModel) {
    this._clear();
    createLarge2(seriesModel, this.group);
    const clipPath = seriesModel.get("clip", true) ? createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null;
    if (clipPath) {
      this.group.setClipPath(clipPath);
    } else {
      this.group.removeClipPath();
    }
  }
  _incrementalRenderNormal(params, seriesModel) {
    const data = seriesModel.getData();
    const isSimpleBox = data.getLayout("isSimpleBox");
    let dataIndex;
    while ((dataIndex = params.next()) != null) {
      const itemLayout = data.getItemLayout(dataIndex);
      const el = createNormalBox2(itemLayout, dataIndex);
      setBoxCommon(el, data, dataIndex, isSimpleBox);
      el.incremental = true;
      this.group.add(el);
      this._progressiveEls.push(el);
    }
  }
  _incrementalRenderLarge(params, seriesModel) {
    createLarge2(seriesModel, this.group, this._progressiveEls, true);
  }
  remove(ecModel) {
    this._clear();
  }
  _clear() {
    this.group.removeAll();
    this._data = null;
  }
};
var CandlestickView = CandlestickView2;
CandlestickView.type = "candlestick";
var NormalBoxPathShape = class {
};
var NormalBoxPath = class extends Path_default {
  constructor(opts) {
    super(opts);
    this.type = "normalCandlestickBox";
  }
  getDefaultShape() {
    return new NormalBoxPathShape();
  }
  buildPath(ctx, shape) {
    const ends = shape.points;
    if (this.__simpleBox) {
      ctx.moveTo(ends[4][0], ends[4][1]);
      ctx.lineTo(ends[6][0], ends[6][1]);
    } else {
      ctx.moveTo(ends[0][0], ends[0][1]);
      ctx.lineTo(ends[1][0], ends[1][1]);
      ctx.lineTo(ends[2][0], ends[2][1]);
      ctx.lineTo(ends[3][0], ends[3][1]);
      ctx.closePath();
      ctx.moveTo(ends[4][0], ends[4][1]);
      ctx.lineTo(ends[5][0], ends[5][1]);
      ctx.moveTo(ends[6][0], ends[6][1]);
      ctx.lineTo(ends[7][0], ends[7][1]);
    }
  }
};
function createNormalBox2(itemLayout, dataIndex, isInit) {
  const ends = itemLayout.ends;
  return new NormalBoxPath({
    shape: {
      points: isInit ? transInit2(ends, itemLayout) : ends
    },
    z2: 100
  });
}
function isNormalBoxClipped(clipArea, itemLayout) {
  let clipped = true;
  for (let i = 0; i < itemLayout.ends.length; i++) {
    if (clipArea.contain(itemLayout.ends[i][0], itemLayout.ends[i][1])) {
      clipped = false;
      break;
    }
  }
  return clipped;
}
function setBoxCommon(el, data, dataIndex, isSimpleBox) {
  const itemModel = data.getItemModel(dataIndex);
  el.useStyle(data.getItemVisual(dataIndex, "style"));
  el.style.strokeNoScale = true;
  el.__simpleBox = isSimpleBox;
  setStatesStylesFromModel(el, itemModel);
}
function transInit2(points4, itemLayout) {
  return map(points4, function(point) {
    point = point.slice();
    point[1] = itemLayout.initBaseline;
    return point;
  });
}
var LargeBoxPathShape = class {
};
var LargeBoxPath = class extends Path_default {
  constructor(opts) {
    super(opts);
    this.type = "largeCandlestickBox";
  }
  getDefaultShape() {
    return new LargeBoxPathShape();
  }
  buildPath(ctx, shape) {
    const points4 = shape.points;
    for (let i = 0; i < points4.length; ) {
      if (this.__sign === points4[i++]) {
        const x = points4[i++];
        ctx.moveTo(x, points4[i++]);
        ctx.lineTo(x, points4[i++]);
      } else {
        i += 3;
      }
    }
  }
};
function createLarge2(seriesModel, group, progressiveEls, incremental) {
  const data = seriesModel.getData();
  const largePoints = data.getLayout("largePoints");
  const elP = new LargeBoxPath({
    shape: {points: largePoints},
    __sign: 1,
    ignoreCoarsePointer: true
  });
  group.add(elP);
  const elN = new LargeBoxPath({
    shape: {points: largePoints},
    __sign: -1,
    ignoreCoarsePointer: true
  });
  group.add(elN);
  const elDoji = new LargeBoxPath({
    shape: {points: largePoints},
    __sign: 0,
    ignoreCoarsePointer: true
  });
  group.add(elDoji);
  setLargeStyle(1, elP, seriesModel, data);
  setLargeStyle(-1, elN, seriesModel, data);
  setLargeStyle(0, elDoji, seriesModel, data);
  if (incremental) {
    elP.incremental = true;
    elN.incremental = true;
  }
  if (progressiveEls) {
    progressiveEls.push(elP, elN);
  }
}
function setLargeStyle(sign, el, seriesModel, data) {
  let borderColor = seriesModel.get(["itemStyle", sign > 0 ? "borderColor" : "borderColor0"]) || seriesModel.get(["itemStyle", sign > 0 ? "color" : "color0"]);
  if (sign === 0) {
    borderColor = seriesModel.get(["itemStyle", "borderColorDoji"]);
  }
  const itemStyle = seriesModel.getModel("itemStyle").getItemStyle(SKIP_PROPS);
  el.useStyle(itemStyle);
  el.style.fill = null;
  el.style.stroke = borderColor;
}
var CandlestickView_default = CandlestickView;

// src/chart/candlestick/CandlestickSeries.ts
var CandlestickSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = CandlestickSeriesModel2.type;
    this.defaultValueDimensions = [
      {name: "open", defaultTooltip: true},
      {name: "close", defaultTooltip: true},
      {name: "lowest", defaultTooltip: true},
      {name: "highest", defaultTooltip: true}
    ];
  }
  getShadowDim() {
    return "open";
  }
  brushSelector(dataIndex, data, selectors) {
    const itemLayout = data.getItemLayout(dataIndex);
    return itemLayout && selectors.rect(itemLayout.brushRect);
  }
};
var CandlestickSeriesModel = CandlestickSeriesModel2;
CandlestickSeriesModel.type = "series.candlestick";
CandlestickSeriesModel.dependencies = ["xAxis", "yAxis", "grid"];
CandlestickSeriesModel.defaultOption = {
  z: 2,
  coordinateSystem: "cartesian2d",
  legendHoverLink: true,
  layout: null,
  clip: true,
  itemStyle: {
    color: "#eb5454",
    color0: "#47b262",
    borderColor: "#eb5454",
    borderColor0: "#47b262",
    borderColorDoji: null,
    borderWidth: 1
  },
  emphasis: {
    scale: true,
    itemStyle: {
      borderWidth: 2
    }
  },
  barMaxWidth: null,
  barMinWidth: null,
  barWidth: null,
  large: true,
  largeThreshold: 600,
  progressive: 3e3,
  progressiveThreshold: 1e4,
  progressiveChunkMode: "mod",
  animationEasing: "linear",
  animationDuration: 300
};
mixin(CandlestickSeriesModel, WhiskerBoxCommonMixin, true);
var CandlestickSeries_default = CandlestickSeriesModel;

// src/chart/candlestick/preprocessor.ts
function candlestickPreprocessor(option) {
  if (!option || !isArray(option.series)) {
    return;
  }
  each(option.series, function(seriesItem) {
    if (isObject(seriesItem) && seriesItem.type === "k") {
      seriesItem.type = "candlestick";
    }
  });
}

// src/chart/candlestick/candlestickVisual.ts
var positiveBorderColorQuery = ["itemStyle", "borderColor"];
var negativeBorderColorQuery = ["itemStyle", "borderColor0"];
var dojiBorderColorQuery = ["itemStyle", "borderColorDoji"];
var positiveColorQuery = ["itemStyle", "color"];
var negativeColorQuery = ["itemStyle", "color0"];
var candlestickVisual = {
  seriesType: "candlestick",
  plan: createRenderPlanner(),
  performRawSeries: true,
  reset: function(seriesModel, ecModel) {
    function getColor(sign, model) {
      return model.get(sign > 0 ? positiveColorQuery : negativeColorQuery);
    }
    function getBorderColor(sign, model) {
      return model.get(sign === 0 ? dojiBorderColorQuery : sign > 0 ? positiveBorderColorQuery : negativeBorderColorQuery);
    }
    if (ecModel.isSeriesFiltered(seriesModel)) {
      return;
    }
    const isLargeRender = seriesModel.pipelineContext.large;
    return !isLargeRender && {
      progress(params, data) {
        let dataIndex;
        while ((dataIndex = params.next()) != null) {
          const itemModel = data.getItemModel(dataIndex);
          const sign = data.getItemLayout(dataIndex).sign;
          const style = itemModel.getItemStyle();
          style.fill = getColor(sign, itemModel);
          style.stroke = getBorderColor(sign, itemModel) || style.fill;
          const existsStyle = data.ensureUniqueItemVisual(dataIndex, "style");
          extend(existsStyle, style);
        }
      }
    };
  }
};
var candlestickVisual_default = candlestickVisual;

// src/chart/candlestick/candlestickLayout.ts
var candlestickLayout = {
  seriesType: "candlestick",
  plan: createRenderPlanner(),
  reset: function(seriesModel) {
    const coordSys = seriesModel.coordinateSystem;
    const data = seriesModel.getData();
    const candleWidth = calculateCandleWidth(seriesModel, data);
    const cDimIdx = 0;
    const vDimIdx = 1;
    const coordDims = ["x", "y"];
    const cDimI = data.getDimensionIndex(data.mapDimension(coordDims[cDimIdx]));
    const vDimsI = map(data.mapDimensionsAll(coordDims[vDimIdx]), data.getDimensionIndex, data);
    const openDimI = vDimsI[0];
    const closeDimI = vDimsI[1];
    const lowestDimI = vDimsI[2];
    const highestDimI = vDimsI[3];
    data.setLayout({
      candleWidth,
      isSimpleBox: candleWidth <= 1.3
    });
    if (cDimI < 0 || vDimsI.length < 4) {
      return;
    }
    return {
      progress: seriesModel.pipelineContext.large ? largeProgress : normalProgress
    };
    function normalProgress(params, data2) {
      let dataIndex;
      const store = data2.getStore();
      while ((dataIndex = params.next()) != null) {
        const axisDimVal = store.get(cDimI, dataIndex);
        const openVal = store.get(openDimI, dataIndex);
        const closeVal = store.get(closeDimI, dataIndex);
        const lowestVal = store.get(lowestDimI, dataIndex);
        const highestVal = store.get(highestDimI, dataIndex);
        const ocLow = Math.min(openVal, closeVal);
        const ocHigh = Math.max(openVal, closeVal);
        const ocLowPoint = getPoint(ocLow, axisDimVal);
        const ocHighPoint = getPoint(ocHigh, axisDimVal);
        const lowestPoint = getPoint(lowestVal, axisDimVal);
        const highestPoint = getPoint(highestVal, axisDimVal);
        const ends = [];
        addBodyEnd(ends, ocHighPoint, 0);
        addBodyEnd(ends, ocLowPoint, 1);
        ends.push(subPixelOptimizePoint(highestPoint), subPixelOptimizePoint(ocHighPoint), subPixelOptimizePoint(lowestPoint), subPixelOptimizePoint(ocLowPoint));
        const itemModel = data2.getItemModel(dataIndex);
        const hasDojiColor = !!itemModel.get(["itemStyle", "borderColorDoji"]);
        data2.setItemLayout(dataIndex, {
          sign: getSign(store, dataIndex, openVal, closeVal, closeDimI, hasDojiColor),
          initBaseline: openVal > closeVal ? ocHighPoint[vDimIdx] : ocLowPoint[vDimIdx],
          ends,
          brushRect: makeBrushRect(lowestVal, highestVal, axisDimVal)
        });
      }
      function getPoint(val, axisDimVal) {
        const p = [];
        p[cDimIdx] = axisDimVal;
        p[vDimIdx] = val;
        return isNaN(axisDimVal) || isNaN(val) ? [NaN, NaN] : coordSys.dataToPoint(p);
      }
      function addBodyEnd(ends, point, start2) {
        const point1 = point.slice();
        const point2 = point.slice();
        point1[cDimIdx] = subPixelOptimize2(point1[cDimIdx] + candleWidth / 2, 1, false);
        point2[cDimIdx] = subPixelOptimize2(point2[cDimIdx] - candleWidth / 2, 1, true);
        start2 ? ends.push(point1, point2) : ends.push(point2, point1);
      }
      function makeBrushRect(lowestVal, highestVal, axisDimVal) {
        const pmin = getPoint(lowestVal, axisDimVal);
        const pmax = getPoint(highestVal, axisDimVal);
        pmin[cDimIdx] -= candleWidth / 2;
        pmax[cDimIdx] -= candleWidth / 2;
        return {
          x: pmin[0],
          y: pmin[1],
          width: vDimIdx ? candleWidth : pmax[0] - pmin[0],
          height: vDimIdx ? pmax[1] - pmin[1] : candleWidth
        };
      }
      function subPixelOptimizePoint(point) {
        point[cDimIdx] = subPixelOptimize2(point[cDimIdx], 1);
        return point;
      }
    }
    function largeProgress(params, data2) {
      const points4 = createFloat32Array(params.count * 4);
      let offset = 0;
      let point;
      const tmpIn = [];
      const tmpOut = [];
      let dataIndex;
      const store = data2.getStore();
      const hasDojiColor = !!seriesModel.get(["itemStyle", "borderColorDoji"]);
      while ((dataIndex = params.next()) != null) {
        const axisDimVal = store.get(cDimI, dataIndex);
        const openVal = store.get(openDimI, dataIndex);
        const closeVal = store.get(closeDimI, dataIndex);
        const lowestVal = store.get(lowestDimI, dataIndex);
        const highestVal = store.get(highestDimI, dataIndex);
        if (isNaN(axisDimVal) || isNaN(lowestVal) || isNaN(highestVal)) {
          points4[offset++] = NaN;
          offset += 3;
          continue;
        }
        points4[offset++] = getSign(store, dataIndex, openVal, closeVal, closeDimI, hasDojiColor);
        tmpIn[cDimIdx] = axisDimVal;
        tmpIn[vDimIdx] = lowestVal;
        point = coordSys.dataToPoint(tmpIn, null, tmpOut);
        points4[offset++] = point ? point[0] : NaN;
        points4[offset++] = point ? point[1] : NaN;
        tmpIn[vDimIdx] = highestVal;
        point = coordSys.dataToPoint(tmpIn, null, tmpOut);
        points4[offset++] = point ? point[1] : NaN;
      }
      data2.setLayout("largePoints", points4);
    }
  }
};
function getSign(store, dataIndex, openVal, closeVal, closeDimI, hasDojiColor) {
  let sign;
  if (openVal > closeVal) {
    sign = -1;
  } else if (openVal < closeVal) {
    sign = 1;
  } else {
    sign = hasDojiColor ? 0 : dataIndex > 0 ? store.get(closeDimI, dataIndex - 1) <= closeVal ? 1 : -1 : 1;
  }
  return sign;
}
function calculateCandleWidth(seriesModel, data) {
  const baseAxis = seriesModel.getBaseAxis();
  let extent3;
  const bandWidth = baseAxis.type === "category" ? baseAxis.getBandWidth() : (extent3 = baseAxis.getExtent(), Math.abs(extent3[1] - extent3[0]) / data.count());
  const barMaxWidth = parsePercent2(retrieve2(seriesModel.get("barMaxWidth"), bandWidth), bandWidth);
  const barMinWidth = parsePercent2(retrieve2(seriesModel.get("barMinWidth"), 1), bandWidth);
  const barWidth = seriesModel.get("barWidth");
  return barWidth != null ? parsePercent2(barWidth, bandWidth) : Math.max(Math.min(bandWidth / 2, barMaxWidth), barMinWidth);
}
var candlestickLayout_default = candlestickLayout;

// src/chart/candlestick/install.ts
function install21(registers) {
  registers.registerChartView(CandlestickView_default);
  registers.registerSeriesModel(CandlestickSeries_default);
  registers.registerPreprocessor(candlestickPreprocessor);
  registers.registerVisual(candlestickVisual_default);
  registers.registerLayout(candlestickLayout_default);
}

// src/chart/helper/EffectSymbol.ts
function updateRipplePath(rippleGroup, effectCfg) {
  const color2 = effectCfg.rippleEffectColor || effectCfg.color;
  rippleGroup.eachChild(function(ripplePath) {
    ripplePath.attr({
      z: effectCfg.z,
      zlevel: effectCfg.zlevel,
      style: {
        stroke: effectCfg.brushType === "stroke" ? color2 : null,
        fill: effectCfg.brushType === "fill" ? color2 : null
      }
    });
  });
}
var EffectSymbol = class extends Group_default {
  constructor(data, idx) {
    super();
    const symbol = new Symbol_default(data, idx);
    const rippleGroup = new Group_default();
    this.add(symbol);
    this.add(rippleGroup);
    this.updateData(data, idx);
  }
  stopEffectAnimation() {
    this.childAt(1).removeAll();
  }
  startEffectAnimation(effectCfg) {
    const symbolType = effectCfg.symbolType;
    const color2 = effectCfg.color;
    const rippleNumber = effectCfg.rippleNumber;
    const rippleGroup = this.childAt(1);
    for (let i = 0; i < rippleNumber; i++) {
      const ripplePath = createSymbol(symbolType, -1, -1, 2, 2, color2);
      ripplePath.attr({
        style: {
          strokeNoScale: true
        },
        z2: 99,
        silent: true,
        scaleX: 0.5,
        scaleY: 0.5
      });
      const delay = -i / rippleNumber * effectCfg.period + effectCfg.effectOffset;
      ripplePath.animate("", true).when(effectCfg.period, {
        scaleX: effectCfg.rippleScale / 2,
        scaleY: effectCfg.rippleScale / 2
      }).delay(delay).start();
      ripplePath.animateStyle(true).when(effectCfg.period, {
        opacity: 0
      }).delay(delay).start();
      rippleGroup.add(ripplePath);
    }
    updateRipplePath(rippleGroup, effectCfg);
  }
  updateEffectAnimation(effectCfg) {
    const oldEffectCfg = this._effectCfg;
    const rippleGroup = this.childAt(1);
    const DIFFICULT_PROPS = ["symbolType", "period", "rippleScale", "rippleNumber"];
    for (let i = 0; i < DIFFICULT_PROPS.length; i++) {
      const propName = DIFFICULT_PROPS[i];
      if (oldEffectCfg[propName] !== effectCfg[propName]) {
        this.stopEffectAnimation();
        this.startEffectAnimation(effectCfg);
        return;
      }
    }
    updateRipplePath(rippleGroup, effectCfg);
  }
  highlight() {
    enterEmphasis(this);
  }
  downplay() {
    leaveEmphasis(this);
  }
  getSymbolType() {
    const symbol = this.childAt(0);
    return symbol && symbol.getSymbolType();
  }
  updateData(data, idx) {
    const seriesModel = data.hostModel;
    this.childAt(0).updateData(data, idx);
    const rippleGroup = this.childAt(1);
    const itemModel = data.getItemModel(idx);
    const symbolType = data.getItemVisual(idx, "symbol");
    const symbolSize = normalizeSymbolSize(data.getItemVisual(idx, "symbolSize"));
    const symbolStyle = data.getItemVisual(idx, "style");
    const color2 = symbolStyle && symbolStyle.fill;
    const emphasisModel = itemModel.getModel("emphasis");
    rippleGroup.setScale(symbolSize);
    rippleGroup.traverse(function(ripplePath) {
      ripplePath.setStyle("fill", color2);
    });
    const symbolOffset = normalizeSymbolOffset(data.getItemVisual(idx, "symbolOffset"), symbolSize);
    if (symbolOffset) {
      rippleGroup.x = symbolOffset[0];
      rippleGroup.y = symbolOffset[1];
    }
    const symbolRotate = data.getItemVisual(idx, "symbolRotate");
    rippleGroup.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
    const effectCfg = {};
    effectCfg.showEffectOn = seriesModel.get("showEffectOn");
    effectCfg.rippleScale = itemModel.get(["rippleEffect", "scale"]);
    effectCfg.brushType = itemModel.get(["rippleEffect", "brushType"]);
    effectCfg.period = itemModel.get(["rippleEffect", "period"]) * 1e3;
    effectCfg.effectOffset = idx / data.count();
    effectCfg.z = seriesModel.getShallow("z") || 0;
    effectCfg.zlevel = seriesModel.getShallow("zlevel") || 0;
    effectCfg.symbolType = symbolType;
    effectCfg.color = color2;
    effectCfg.rippleEffectColor = itemModel.get(["rippleEffect", "color"]);
    effectCfg.rippleNumber = itemModel.get(["rippleEffect", "number"]);
    if (effectCfg.showEffectOn === "render") {
      this._effectCfg ? this.updateEffectAnimation(effectCfg) : this.startEffectAnimation(effectCfg);
      this._effectCfg = effectCfg;
    } else {
      this._effectCfg = null;
      this.stopEffectAnimation();
      this.onHoverStateChange = (toState) => {
        if (toState === "emphasis") {
          if (effectCfg.showEffectOn !== "render") {
            this.startEffectAnimation(effectCfg);
          }
        } else if (toState === "normal") {
          if (effectCfg.showEffectOn !== "render") {
            this.stopEffectAnimation();
          }
        }
      };
    }
    this._effectCfg = effectCfg;
    toggleHoverEmphasis(this, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  }
  fadeOut(cb) {
    cb && cb();
  }
};
var EffectSymbol_default = EffectSymbol;

// src/chart/effectScatter/EffectScatterView.ts
var EffectScatterView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = EffectScatterView2.type;
  }
  init() {
    this._symbolDraw = new SymbolDraw_default(EffectSymbol_default);
  }
  render(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    const effectSymbolDraw = this._symbolDraw;
    effectSymbolDraw.updateData(data, {clipShape: this._getClipShape(seriesModel)});
    this.group.add(effectSymbolDraw.group);
  }
  _getClipShape(seriesModel) {
    const coordSys = seriesModel.coordinateSystem;
    const clipArea = coordSys && coordSys.getArea && coordSys.getArea();
    return seriesModel.get("clip", true) ? clipArea : null;
  }
  updateTransform(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    this.group.dirty();
    const res = pointsLayout("").reset(seriesModel, ecModel, api2);
    if (res.progress) {
      res.progress({
        start: 0,
        end: data.count(),
        count: data.count()
      }, data);
    }
    this._symbolDraw.updateLayout();
  }
  _updateGroupTransform(seriesModel) {
    const coordSys = seriesModel.coordinateSystem;
    if (coordSys && coordSys.getRoamTransform) {
      this.group.transform = clone3(coordSys.getRoamTransform());
      this.group.decomposeTransform();
    }
  }
  remove(ecModel, api2) {
    this._symbolDraw && this._symbolDraw.remove(true);
  }
};
var EffectScatterView = EffectScatterView2;
EffectScatterView.type = "effectScatter";
var EffectScatterView_default = EffectScatterView;

// src/chart/effectScatter/EffectScatterSeries.ts
var EffectScatterSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = EffectScatterSeriesModel2.type;
    this.hasSymbolVisual = true;
  }
  getInitialData(option, ecModel) {
    return createSeriesData_default(null, this, {useEncodeDefaulter: true});
  }
  brushSelector(dataIndex, data, selectors) {
    return selectors.point(data.getItemLayout(dataIndex));
  }
};
var EffectScatterSeriesModel = EffectScatterSeriesModel2;
EffectScatterSeriesModel.type = "series.effectScatter";
EffectScatterSeriesModel.dependencies = ["grid", "polar"];
EffectScatterSeriesModel.defaultOption = {
  coordinateSystem: "cartesian2d",
  z: 2,
  legendHoverLink: true,
  effectType: "ripple",
  progressive: 0,
  showEffectOn: "render",
  clip: true,
  rippleEffect: {
    period: 4,
    scale: 2.5,
    brushType: "fill",
    number: 3
  },
  universalTransition: {
    divideShape: "clone"
  },
  symbolSize: 10
};
var EffectScatterSeries_default = EffectScatterSeriesModel;

// src/chart/effectScatter/install.ts
function install22(registers) {
  registers.registerChartView(EffectScatterView_default);
  registers.registerSeriesModel(EffectScatterSeries_default);
  registers.registerLayout(pointsLayout("effectScatter"));
}

// src/chart/helper/EffectLine.ts
var EffectLine = class extends Group_default {
  constructor(lineData, idx, seriesScope) {
    super();
    this.add(this.createLine(lineData, idx, seriesScope));
    this._updateEffectSymbol(lineData, idx);
  }
  createLine(lineData, idx, seriesScope) {
    return new Line_default2(lineData, idx, seriesScope);
  }
  _updateEffectSymbol(lineData, idx) {
    const itemModel = lineData.getItemModel(idx);
    const effectModel = itemModel.getModel("effect");
    let size = effectModel.get("symbolSize");
    const symbolType = effectModel.get("symbol");
    if (!isArray(size)) {
      size = [size, size];
    }
    const lineStyle = lineData.getItemVisual(idx, "style");
    const color2 = effectModel.get("color") || lineStyle && lineStyle.stroke;
    let symbol = this.childAt(1);
    if (this._symbolType !== symbolType) {
      this.remove(symbol);
      symbol = createSymbol(symbolType, -0.5, -0.5, 1, 1, color2);
      symbol.z2 = 100;
      symbol.culling = true;
      this.add(symbol);
    }
    if (!symbol) {
      return;
    }
    symbol.setStyle("shadowColor", color2);
    symbol.setStyle(effectModel.getItemStyle(["color"]));
    symbol.scaleX = size[0];
    symbol.scaleY = size[1];
    symbol.setColor(color2);
    this._symbolType = symbolType;
    this._symbolScale = size;
    this._updateEffectAnimation(lineData, effectModel, idx);
  }
  _updateEffectAnimation(lineData, effectModel, idx) {
    const symbol = this.childAt(1);
    if (!symbol) {
      return;
    }
    const points4 = lineData.getItemLayout(idx);
    let period = effectModel.get("period") * 1e3;
    const loop = effectModel.get("loop");
    const roundTrip = effectModel.get("roundTrip");
    const constantSpeed = effectModel.get("constantSpeed");
    const delayExpr = retrieve(effectModel.get("delay"), function(idx2) {
      return idx2 / lineData.count() * period / 3;
    });
    symbol.ignore = true;
    this._updateAnimationPoints(symbol, points4);
    if (constantSpeed > 0) {
      period = this._getLineLength(symbol) / constantSpeed * 1e3;
    }
    if (period !== this._period || loop !== this._loop || roundTrip !== this._roundTrip) {
      symbol.stopAnimation();
      let delayNum;
      if (isFunction(delayExpr)) {
        delayNum = delayExpr(idx);
      } else {
        delayNum = delayExpr;
      }
      if (symbol.__t > 0) {
        delayNum = -period * symbol.__t;
      }
      this._animateSymbol(symbol, period, delayNum, loop, roundTrip);
    }
    this._period = period;
    this._loop = loop;
    this._roundTrip = roundTrip;
  }
  _animateSymbol(symbol, period, delayNum, loop, roundTrip) {
    if (period > 0) {
      symbol.__t = 0;
      const self2 = this;
      const animator = symbol.animate("", loop).when(roundTrip ? period * 2 : period, {
        __t: roundTrip ? 2 : 1
      }).delay(delayNum).during(function() {
        self2._updateSymbolPosition(symbol);
      });
      if (!loop) {
        animator.done(function() {
          self2.remove(symbol);
        });
      }
      animator.start();
    }
  }
  _getLineLength(symbol) {
    return dist(symbol.__p1, symbol.__cp1) + dist(symbol.__cp1, symbol.__p2);
  }
  _updateAnimationPoints(symbol, points4) {
    symbol.__p1 = points4[0];
    symbol.__p2 = points4[1];
    symbol.__cp1 = points4[2] || [
      (points4[0][0] + points4[1][0]) / 2,
      (points4[0][1] + points4[1][1]) / 2
    ];
  }
  updateData(lineData, idx, seriesScope) {
    this.childAt(0).updateData(lineData, idx, seriesScope);
    this._updateEffectSymbol(lineData, idx);
  }
  _updateSymbolPosition(symbol) {
    const p1 = symbol.__p1;
    const p2 = symbol.__p2;
    const cp1 = symbol.__cp1;
    const t = symbol.__t < 1 ? symbol.__t : 2 - symbol.__t;
    const pos = [symbol.x, symbol.y];
    const lastPos = pos.slice();
    const quadraticAt3 = quadraticAt;
    const quadraticDerivativeAt2 = quadraticDerivativeAt;
    pos[0] = quadraticAt3(p1[0], cp1[0], p2[0], t);
    pos[1] = quadraticAt3(p1[1], cp1[1], p2[1], t);
    const tx = symbol.__t < 1 ? quadraticDerivativeAt2(p1[0], cp1[0], p2[0], t) : quadraticDerivativeAt2(p2[0], cp1[0], p1[0], 1 - t);
    const ty = symbol.__t < 1 ? quadraticDerivativeAt2(p1[1], cp1[1], p2[1], t) : quadraticDerivativeAt2(p2[1], cp1[1], p1[1], 1 - t);
    symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
    if (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") {
      if (symbol.__lastT !== void 0 && symbol.__lastT < symbol.__t) {
        symbol.scaleY = dist(lastPos, pos) * 1.05;
        if (t === 1) {
          pos[0] = lastPos[0] + (pos[0] - lastPos[0]) / 2;
          pos[1] = lastPos[1] + (pos[1] - lastPos[1]) / 2;
        }
      } else if (symbol.__lastT === 1) {
        symbol.scaleY = 2 * dist(p1, pos);
      } else {
        symbol.scaleY = this._symbolScale[1];
      }
    }
    symbol.__lastT = symbol.__t;
    symbol.ignore = false;
    symbol.x = pos[0];
    symbol.y = pos[1];
  }
  updateLayout(lineData, idx) {
    this.childAt(0).updateLayout(lineData, idx);
    const effectModel = lineData.getItemModel(idx).getModel("effect");
    this._updateEffectAnimation(lineData, effectModel, idx);
  }
};
var EffectLine_default = EffectLine;

// src/chart/helper/Polyline.ts
var Polyline5 = class extends Group_default {
  constructor(lineData, idx, seriesScope) {
    super();
    this._createPolyline(lineData, idx, seriesScope);
  }
  _createPolyline(lineData, idx, seriesScope) {
    const points4 = lineData.getItemLayout(idx);
    const line2 = new Polyline_default({
      shape: {
        points: points4
      }
    });
    this.add(line2);
    this._updateCommonStl(lineData, idx, seriesScope);
  }
  updateData(lineData, idx, seriesScope) {
    const seriesModel = lineData.hostModel;
    const line2 = this.childAt(0);
    const target = {
      shape: {
        points: lineData.getItemLayout(idx)
      }
    };
    updateProps(line2, target, seriesModel, idx);
    this._updateCommonStl(lineData, idx, seriesScope);
  }
  _updateCommonStl(lineData, idx, seriesScope) {
    const line2 = this.childAt(0);
    const itemModel = lineData.getItemModel(idx);
    let emphasisLineStyle = seriesScope && seriesScope.emphasisLineStyle;
    let focus = seriesScope && seriesScope.focus;
    let blurScope = seriesScope && seriesScope.blurScope;
    let emphasisDisabled = seriesScope && seriesScope.emphasisDisabled;
    if (!seriesScope || lineData.hasItemOption) {
      const emphasisModel = itemModel.getModel("emphasis");
      emphasisLineStyle = emphasisModel.getModel("lineStyle").getLineStyle();
      emphasisDisabled = emphasisModel.get("disabled");
      focus = emphasisModel.get("focus");
      blurScope = emphasisModel.get("blurScope");
    }
    line2.useStyle(lineData.getItemVisual(idx, "style"));
    line2.style.fill = null;
    line2.style.strokeNoScale = true;
    const lineEmphasisState = line2.ensureState("emphasis");
    lineEmphasisState.style = emphasisLineStyle;
    toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled);
  }
  updateLayout(lineData, idx) {
    const polyline = this.childAt(0);
    polyline.setShape("points", lineData.getItemLayout(idx));
  }
};
var Polyline_default2 = Polyline5;

// src/chart/helper/EffectPolyline.ts
var EffectPolyline = class extends EffectLine_default {
  constructor() {
    super(...arguments);
    this._lastFrame = 0;
    this._lastFramePercent = 0;
  }
  createLine(lineData, idx, seriesScope) {
    return new Polyline_default2(lineData, idx, seriesScope);
  }
  _updateAnimationPoints(symbol, points4) {
    this._points = points4;
    const accLenArr = [0];
    let len2 = 0;
    for (let i = 1; i < points4.length; i++) {
      const p1 = points4[i - 1];
      const p2 = points4[i];
      len2 += dist(p1, p2);
      accLenArr.push(len2);
    }
    if (len2 === 0) {
      this._length = 0;
      return;
    }
    for (let i = 0; i < accLenArr.length; i++) {
      accLenArr[i] /= len2;
    }
    this._offsets = accLenArr;
    this._length = len2;
  }
  _getLineLength() {
    return this._length;
  }
  _updateSymbolPosition(symbol) {
    const t = symbol.__t < 1 ? symbol.__t : 2 - symbol.__t;
    const points4 = this._points;
    const offsets = this._offsets;
    const len2 = points4.length;
    if (!offsets) {
      return;
    }
    const lastFrame = this._lastFrame;
    let frame;
    if (t < this._lastFramePercent) {
      const start2 = Math.min(lastFrame + 1, len2 - 1);
      for (frame = start2; frame >= 0; frame--) {
        if (offsets[frame] <= t) {
          break;
        }
      }
      frame = Math.min(frame, len2 - 2);
    } else {
      for (frame = lastFrame; frame < len2; frame++) {
        if (offsets[frame] > t) {
          break;
        }
      }
      frame = Math.min(frame - 1, len2 - 2);
    }
    const p = (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame]);
    const p0 = points4[frame];
    const p1 = points4[frame + 1];
    symbol.x = p0[0] * (1 - p) + p * p1[0];
    symbol.y = p0[1] * (1 - p) + p * p1[1];
    const tx = symbol.__t < 1 ? p1[0] - p0[0] : p0[0] - p1[0];
    const ty = symbol.__t < 1 ? p1[1] - p0[1] : p0[1] - p1[1];
    symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
    this._lastFrame = frame;
    this._lastFramePercent = t;
    symbol.ignore = false;
  }
};
var EffectPolyline_default = EffectPolyline;

// src/chart/helper/LargeLineDraw.ts
var LargeLinesPathShape = class {
  constructor() {
    this.polyline = false;
    this.curveness = 0;
    this.segs = [];
  }
};
var LargeLinesPath = class extends Path_default {
  constructor(opts) {
    super(opts);
    this._off = 0;
    this.hoverDataIdx = -1;
  }
  reset() {
    this.notClear = false;
    this._off = 0;
  }
  getDefaultStyle() {
    return {
      stroke: "#000",
      fill: null
    };
  }
  getDefaultShape() {
    return new LargeLinesPathShape();
  }
  buildPath(ctx, shape) {
    const segs = shape.segs;
    const curveness = shape.curveness;
    let i;
    if (shape.polyline) {
      for (i = this._off; i < segs.length; ) {
        const count2 = segs[i++];
        if (count2 > 0) {
          ctx.moveTo(segs[i++], segs[i++]);
          for (let k = 1; k < count2; k++) {
            ctx.lineTo(segs[i++], segs[i++]);
          }
        }
      }
    } else {
      for (i = this._off; i < segs.length; ) {
        const x0 = segs[i++];
        const y0 = segs[i++];
        const x1 = segs[i++];
        const y1 = segs[i++];
        ctx.moveTo(x0, y0);
        if (curveness > 0) {
          const x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;
          const y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;
          ctx.quadraticCurveTo(x2, y2, x1, y1);
        } else {
          ctx.lineTo(x1, y1);
        }
      }
    }
    if (this.incremental) {
      this._off = i;
      this.notClear = true;
    }
  }
  findDataIndex(x, y) {
    const shape = this.shape;
    const segs = shape.segs;
    const curveness = shape.curveness;
    const lineWidth = this.style.lineWidth;
    if (shape.polyline) {
      let dataIndex = 0;
      for (let i = 0; i < segs.length; ) {
        const count2 = segs[i++];
        if (count2 > 0) {
          const x0 = segs[i++];
          const y0 = segs[i++];
          for (let k = 1; k < count2; k++) {
            const x1 = segs[i++];
            const y1 = segs[i++];
            if (containStroke(x0, y0, x1, y1, lineWidth, x, y)) {
              return dataIndex;
            }
          }
        }
        dataIndex++;
      }
    } else {
      let dataIndex = 0;
      for (let i = 0; i < segs.length; ) {
        const x0 = segs[i++];
        const y0 = segs[i++];
        const x1 = segs[i++];
        const y1 = segs[i++];
        if (curveness > 0) {
          const x2 = (x0 + x1) / 2 - (y0 - y1) * curveness;
          const y2 = (y0 + y1) / 2 - (x1 - x0) * curveness;
          if (containStroke3(x0, y0, x2, y2, x1, y1, lineWidth, x, y)) {
            return dataIndex;
          }
        } else {
          if (containStroke(x0, y0, x1, y1, lineWidth, x, y)) {
            return dataIndex;
          }
        }
        dataIndex++;
      }
    }
    return -1;
  }
  contain(x, y) {
    const localPos = this.transformCoordToLocal(x, y);
    const rect = this.getBoundingRect();
    x = localPos[0];
    y = localPos[1];
    if (rect.contain(x, y)) {
      const dataIdx = this.hoverDataIdx = this.findDataIndex(x, y);
      return dataIdx >= 0;
    }
    this.hoverDataIdx = -1;
    return false;
  }
  getBoundingRect() {
    let rect = this._rect;
    if (!rect) {
      const shape = this.shape;
      const points4 = shape.segs;
      let minX = Infinity;
      let minY = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      for (let i = 0; i < points4.length; ) {
        const x = points4[i++];
        const y = points4[i++];
        minX = Math.min(x, minX);
        maxX = Math.max(x, maxX);
        minY = Math.min(y, minY);
        maxY = Math.max(y, maxY);
      }
      rect = this._rect = new BoundingRect_default(minX, minY, maxX, maxY);
    }
    return rect;
  }
};
var LargeLineDraw = class {
  constructor() {
    this.group = new Group_default();
  }
  updateData(data) {
    this._clear();
    const lineEl = this._create();
    lineEl.setShape({
      segs: data.getLayout("linesPoints")
    });
    this._setCommon(lineEl, data);
  }
  incrementalPrepareUpdate(data) {
    this.group.removeAll();
    this._clear();
  }
  incrementalUpdate(taskParams, data) {
    const lastAdded = this._newAdded[0];
    const linePoints = data.getLayout("linesPoints");
    const oldSegs = lastAdded && lastAdded.shape.segs;
    if (oldSegs && oldSegs.length < 2e4) {
      const oldLen = oldSegs.length;
      const newSegs = new Float32Array(oldLen + linePoints.length);
      newSegs.set(oldSegs);
      newSegs.set(linePoints, oldLen);
      lastAdded.setShape({
        segs: newSegs
      });
    } else {
      this._newAdded = [];
      const lineEl = this._create();
      lineEl.incremental = true;
      lineEl.setShape({
        segs: linePoints
      });
      this._setCommon(lineEl, data);
      lineEl.__startIndex = taskParams.start;
    }
  }
  remove() {
    this._clear();
  }
  eachRendered(cb) {
    this._newAdded[0] && cb(this._newAdded[0]);
  }
  _create() {
    const lineEl = new LargeLinesPath({
      cursor: "default",
      ignoreCoarsePointer: true
    });
    this._newAdded.push(lineEl);
    this.group.add(lineEl);
    return lineEl;
  }
  _setCommon(lineEl, data, isIncremental) {
    const hostModel = data.hostModel;
    lineEl.setShape({
      polyline: hostModel.get("polyline"),
      curveness: hostModel.get(["lineStyle", "curveness"])
    });
    lineEl.useStyle(hostModel.getModel("lineStyle").getLineStyle());
    lineEl.style.strokeNoScale = true;
    const style = data.getVisual("style");
    if (style && style.stroke) {
      lineEl.setStyle("stroke", style.stroke);
    }
    lineEl.setStyle("fill", null);
    const ecData = getECData(lineEl);
    ecData.seriesIndex = hostModel.seriesIndex;
    lineEl.on("mousemove", function(e2) {
      ecData.dataIndex = null;
      const dataIndex = lineEl.hoverDataIdx;
      if (dataIndex > 0) {
        ecData.dataIndex = dataIndex + lineEl.__startIndex;
      }
    });
  }
  _clear() {
    this._newAdded = [];
    this.group.removeAll();
  }
};
var LargeLineDraw_default = LargeLineDraw;

// src/chart/lines/linesLayout.ts
var linesLayout = {
  seriesType: "lines",
  plan: createRenderPlanner(),
  reset: function(seriesModel) {
    const coordSys = seriesModel.coordinateSystem;
    if (!coordSys) {
      if (true) {
        error("The lines series must have a coordinate system.");
      }
      return;
    }
    const isPolyline = seriesModel.get("polyline");
    const isLarge = seriesModel.pipelineContext.large;
    return {
      progress(params, lineData) {
        const lineCoords = [];
        if (isLarge) {
          let points4;
          const segCount = params.end - params.start;
          if (isPolyline) {
            let totalCoordsCount = 0;
            for (let i = params.start; i < params.end; i++) {
              totalCoordsCount += seriesModel.getLineCoordsCount(i);
            }
            points4 = new Float32Array(segCount + totalCoordsCount * 2);
          } else {
            points4 = new Float32Array(segCount * 4);
          }
          let offset = 0;
          let pt = [];
          for (let i = params.start; i < params.end; i++) {
            const len2 = seriesModel.getLineCoords(i, lineCoords);
            if (isPolyline) {
              points4[offset++] = len2;
            }
            for (let k = 0; k < len2; k++) {
              pt = coordSys.dataToPoint(lineCoords[k], false, pt);
              points4[offset++] = pt[0];
              points4[offset++] = pt[1];
            }
          }
          lineData.setLayout("linesPoints", points4);
        } else {
          for (let i = params.start; i < params.end; i++) {
            const itemModel = lineData.getItemModel(i);
            const len2 = seriesModel.getLineCoords(i, lineCoords);
            const pts = [];
            if (isPolyline) {
              for (let j = 0; j < len2; j++) {
                pts.push(coordSys.dataToPoint(lineCoords[j]));
              }
            } else {
              pts[0] = coordSys.dataToPoint(lineCoords[0]);
              pts[1] = coordSys.dataToPoint(lineCoords[1]);
              const curveness = itemModel.get(["lineStyle", "curveness"]);
              if (+curveness) {
                pts[2] = [
                  (pts[0][0] + pts[1][0]) / 2 - (pts[0][1] - pts[1][1]) * curveness,
                  (pts[0][1] + pts[1][1]) / 2 - (pts[1][0] - pts[0][0]) * curveness
                ];
              }
            }
            lineData.setItemLayout(i, pts);
          }
        }
      }
    };
  }
};
var linesLayout_default = linesLayout;

// src/chart/lines/LinesView.ts
var LinesView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = LinesView2.type;
  }
  render(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    const lineDraw = this._updateLineDraw(data, seriesModel);
    const zlevel = seriesModel.get("zlevel");
    const trailLength = seriesModel.get(["effect", "trailLength"]);
    const zr = api2.getZr();
    const isSvg = zr.painter.getType() === "svg";
    if (!isSvg) {
      zr.painter.getLayer(zlevel).clear(true);
    }
    if (this._lastZlevel != null && !isSvg) {
      zr.configLayer(this._lastZlevel, {
        motionBlur: false
      });
    }
    if (this._showEffect(seriesModel) && trailLength > 0) {
      if (!isSvg) {
        zr.configLayer(zlevel, {
          motionBlur: true,
          lastFrameAlpha: Math.max(Math.min(trailLength / 10 + 0.9, 1), 0)
        });
      } else if (true) {
        console.warn("SVG render mode doesn't support lines with trail effect");
      }
    }
    lineDraw.updateData(data);
    const clipPath = seriesModel.get("clip", true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel);
    if (clipPath) {
      this.group.setClipPath(clipPath);
    } else {
      this.group.removeClipPath();
    }
    this._lastZlevel = zlevel;
    this._finished = true;
  }
  incrementalPrepareRender(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    const lineDraw = this._updateLineDraw(data, seriesModel);
    lineDraw.incrementalPrepareUpdate(data);
    this._clearLayer(api2);
    this._finished = false;
  }
  incrementalRender(taskParams, seriesModel, ecModel) {
    this._lineDraw.incrementalUpdate(taskParams, seriesModel.getData());
    this._finished = taskParams.end === seriesModel.getData().count();
  }
  eachRendered(cb) {
    this._lineDraw && this._lineDraw.eachRendered(cb);
  }
  updateTransform(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    const pipelineContext = seriesModel.pipelineContext;
    if (!this._finished || pipelineContext.large || pipelineContext.progressiveRender) {
      return {
        update: true
      };
    } else {
      const res = linesLayout_default.reset(seriesModel, ecModel, api2);
      if (res.progress) {
        res.progress({
          start: 0,
          end: data.count(),
          count: data.count()
        }, data);
      }
      this._lineDraw.updateLayout();
      this._clearLayer(api2);
    }
  }
  _updateLineDraw(data, seriesModel) {
    let lineDraw = this._lineDraw;
    const hasEffect = this._showEffect(seriesModel);
    const isPolyline = !!seriesModel.get("polyline");
    const pipelineContext = seriesModel.pipelineContext;
    const isLargeDraw = pipelineContext.large;
    if (true) {
      if (hasEffect && isLargeDraw) {
        console.warn("Large lines not support effect");
      }
    }
    if (!lineDraw || hasEffect !== this._hasEffet || isPolyline !== this._isPolyline || isLargeDraw !== this._isLargeDraw) {
      if (lineDraw) {
        lineDraw.remove();
      }
      lineDraw = this._lineDraw = isLargeDraw ? new LargeLineDraw_default() : new LineDraw_default(isPolyline ? hasEffect ? EffectPolyline_default : Polyline_default2 : hasEffect ? EffectLine_default : Line_default2);
      this._hasEffet = hasEffect;
      this._isPolyline = isPolyline;
      this._isLargeDraw = isLargeDraw;
    }
    this.group.add(lineDraw.group);
    return lineDraw;
  }
  _showEffect(seriesModel) {
    return !!seriesModel.get(["effect", "show"]);
  }
  _clearLayer(api2) {
    const zr = api2.getZr();
    const isSvg = zr.painter.getType() === "svg";
    if (!isSvg && this._lastZlevel != null) {
      zr.painter.getLayer(this._lastZlevel).clear(true);
    }
  }
  remove(ecModel, api2) {
    this._lineDraw && this._lineDraw.remove();
    this._lineDraw = null;
    this._clearLayer(api2);
  }
  dispose(ecModel, api2) {
    this.remove(ecModel, api2);
  }
};
var LinesView = LinesView2;
LinesView.type = "lines";
var LinesView_default = LinesView;

// src/chart/lines/LinesSeries.ts
var Uint32Arr = typeof Uint32Array === "undefined" ? Array : Uint32Array;
var Float64Arr = typeof Float64Array === "undefined" ? Array : Float64Array;
function compatEc2(seriesOpt) {
  const data = seriesOpt.data;
  if (data && data[0] && data[0][0] && data[0][0].coord) {
    if (true) {
      console.warn("Lines data configuration has been changed to { coords:[[1,2],[2,3]] }");
    }
    seriesOpt.data = map(data, function(itemOpt) {
      const coords = [
        itemOpt[0].coord,
        itemOpt[1].coord
      ];
      const target = {
        coords
      };
      if (itemOpt[0].name) {
        target.fromName = itemOpt[0].name;
      }
      if (itemOpt[1].name) {
        target.toName = itemOpt[1].name;
      }
      return mergeAll([target, itemOpt[0], itemOpt[1]]);
    });
  }
}
var LinesSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = LinesSeriesModel2.type;
    this.visualStyleAccessPath = "lineStyle";
    this.visualDrawType = "stroke";
  }
  init(option) {
    option.data = option.data || [];
    compatEc2(option);
    const result = this._processFlatCoordsArray(option.data);
    this._flatCoords = result.flatCoords;
    this._flatCoordsOffset = result.flatCoordsOffset;
    if (result.flatCoords) {
      option.data = new Float32Array(result.count);
    }
    super.init.apply(this, arguments);
  }
  mergeOption(option) {
    compatEc2(option);
    if (option.data) {
      const result = this._processFlatCoordsArray(option.data);
      this._flatCoords = result.flatCoords;
      this._flatCoordsOffset = result.flatCoordsOffset;
      if (result.flatCoords) {
        option.data = new Float32Array(result.count);
      }
    }
    super.mergeOption.apply(this, arguments);
  }
  appendData(params) {
    const result = this._processFlatCoordsArray(params.data);
    if (result.flatCoords) {
      if (!this._flatCoords) {
        this._flatCoords = result.flatCoords;
        this._flatCoordsOffset = result.flatCoordsOffset;
      } else {
        this._flatCoords = concatArray(this._flatCoords, result.flatCoords);
        this._flatCoordsOffset = concatArray(this._flatCoordsOffset, result.flatCoordsOffset);
      }
      params.data = new Float32Array(result.count);
    }
    this.getRawData().appendData(params.data);
  }
  _getCoordsFromItemModel(idx) {
    const itemModel = this.getData().getItemModel(idx);
    const coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow("coords");
    if (true) {
      if (!(coords instanceof Array && coords.length > 0 && coords[0] instanceof Array)) {
        throw new Error("Invalid coords " + JSON.stringify(coords) + ". Lines must have 2d coords array in data item.");
      }
    }
    return coords;
  }
  getLineCoordsCount(idx) {
    if (this._flatCoordsOffset) {
      return this._flatCoordsOffset[idx * 2 + 1];
    } else {
      return this._getCoordsFromItemModel(idx).length;
    }
  }
  getLineCoords(idx, out2) {
    if (this._flatCoordsOffset) {
      const offset = this._flatCoordsOffset[idx * 2];
      const len2 = this._flatCoordsOffset[idx * 2 + 1];
      for (let i = 0; i < len2; i++) {
        out2[i] = out2[i] || [];
        out2[i][0] = this._flatCoords[offset + i * 2];
        out2[i][1] = this._flatCoords[offset + i * 2 + 1];
      }
      return len2;
    } else {
      const coords = this._getCoordsFromItemModel(idx);
      for (let i = 0; i < coords.length; i++) {
        out2[i] = out2[i] || [];
        out2[i][0] = coords[i][0];
        out2[i][1] = coords[i][1];
      }
      return coords.length;
    }
  }
  _processFlatCoordsArray(data) {
    let startOffset = 0;
    if (this._flatCoords) {
      startOffset = this._flatCoords.length;
    }
    if (isNumber(data[0])) {
      const len2 = data.length;
      const coordsOffsetAndLenStorage = new Uint32Arr(len2);
      const coordsStorage = new Float64Arr(len2);
      let coordsCursor = 0;
      let offsetCursor = 0;
      let dataCount = 0;
      for (let i = 0; i < len2; ) {
        dataCount++;
        const count2 = data[i++];
        coordsOffsetAndLenStorage[offsetCursor++] = coordsCursor + startOffset;
        coordsOffsetAndLenStorage[offsetCursor++] = count2;
        for (let k = 0; k < count2; k++) {
          const x = data[i++];
          const y = data[i++];
          coordsStorage[coordsCursor++] = x;
          coordsStorage[coordsCursor++] = y;
          if (i > len2) {
            if (true) {
              throw new Error("Invalid data format.");
            }
          }
        }
      }
      return {
        flatCoordsOffset: new Uint32Array(coordsOffsetAndLenStorage.buffer, 0, offsetCursor),
        flatCoords: coordsStorage,
        count: dataCount
      };
    }
    return {
      flatCoordsOffset: null,
      flatCoords: null,
      count: data.length
    };
  }
  getInitialData(option, ecModel) {
    if (true) {
      const CoordSys = CoordinateSystem_default.get(option.coordinateSystem);
      if (!CoordSys) {
        throw new Error("Unknown coordinate system " + option.coordinateSystem);
      }
    }
    const lineData = new SeriesData_default(["value"], this);
    lineData.hasItemOption = false;
    lineData.initData(option.data, [], function(dataItem, dimName, dataIndex, dimIndex) {
      if (dataItem instanceof Array) {
        return NaN;
      } else {
        lineData.hasItemOption = true;
        const value = dataItem.value;
        if (value != null) {
          return value instanceof Array ? value[dimIndex] : value;
        }
      }
    });
    return lineData;
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    const data = this.getData();
    const itemModel = data.getItemModel(dataIndex);
    const name = itemModel.get("name");
    if (name) {
      return name;
    }
    const fromName = itemModel.get("fromName");
    const toName = itemModel.get("toName");
    const nameArr = [];
    fromName != null && nameArr.push(fromName);
    toName != null && nameArr.push(toName);
    return createTooltipMarkup("nameValue", {
      name: nameArr.join(" > ")
    });
  }
  preventIncremental() {
    return !!this.get(["effect", "show"]);
  }
  getProgressive() {
    const progressive = this.option.progressive;
    if (progressive == null) {
      return this.option.large ? 1e4 : this.get("progressive");
    }
    return progressive;
  }
  getProgressiveThreshold() {
    const progressiveThreshold = this.option.progressiveThreshold;
    if (progressiveThreshold == null) {
      return this.option.large ? 2e4 : this.get("progressiveThreshold");
    }
    return progressiveThreshold;
  }
  getZLevelKey() {
    const effectModel = this.getModel("effect");
    const trailLength = effectModel.get("trailLength");
    return this.getData().count() > this.getProgressiveThreshold() ? this.id : effectModel.get("show") && trailLength > 0 ? trailLength + "" : "";
  }
};
var LinesSeriesModel = LinesSeriesModel2;
LinesSeriesModel.type = "series.lines";
LinesSeriesModel.dependencies = ["grid", "polar", "geo", "calendar"];
LinesSeriesModel.defaultOption = {
  coordinateSystem: "geo",
  z: 2,
  legendHoverLink: true,
  xAxisIndex: 0,
  yAxisIndex: 0,
  symbol: ["none", "none"],
  symbolSize: [10, 10],
  geoIndex: 0,
  effect: {
    show: false,
    period: 4,
    constantSpeed: 0,
    symbol: "circle",
    symbolSize: 3,
    loop: true,
    trailLength: 0.2
  },
  large: false,
  largeThreshold: 2e3,
  polyline: false,
  clip: true,
  label: {
    show: false,
    position: "end"
  },
  lineStyle: {
    opacity: 0.5
  }
};
var LinesSeries_default = LinesSeriesModel;

// src/chart/lines/linesVisual.ts
function normalize4(a) {
  if (!(a instanceof Array)) {
    a = [a, a];
  }
  return a;
}
var linesVisual = {
  seriesType: "lines",
  reset(seriesModel) {
    const symbolType = normalize4(seriesModel.get("symbol"));
    const symbolSize = normalize4(seriesModel.get("symbolSize"));
    const data = seriesModel.getData();
    data.setVisual("fromSymbol", symbolType && symbolType[0]);
    data.setVisual("toSymbol", symbolType && symbolType[1]);
    data.setVisual("fromSymbolSize", symbolSize && symbolSize[0]);
    data.setVisual("toSymbolSize", symbolSize && symbolSize[1]);
    function dataEach(data2, idx) {
      const itemModel = data2.getItemModel(idx);
      const symbolType2 = normalize4(itemModel.getShallow("symbol", true));
      const symbolSize2 = normalize4(itemModel.getShallow("symbolSize", true));
      symbolType2[0] && data2.setItemVisual(idx, "fromSymbol", symbolType2[0]);
      symbolType2[1] && data2.setItemVisual(idx, "toSymbol", symbolType2[1]);
      symbolSize2[0] && data2.setItemVisual(idx, "fromSymbolSize", symbolSize2[0]);
      symbolSize2[1] && data2.setItemVisual(idx, "toSymbolSize", symbolSize2[1]);
    }
    return {
      dataEach: data.hasItemOption ? dataEach : null
    };
  }
};
var linesVisual_default = linesVisual;

// src/chart/lines/install.ts
function install23(registers) {
  registers.registerChartView(LinesView_default);
  registers.registerSeriesModel(LinesSeries_default);
  registers.registerLayout(linesLayout_default);
  registers.registerVisual(linesVisual_default);
}

// src/chart/heatmap/HeatmapLayer.ts
var GRADIENT_LEVELS = 256;
var HeatmapLayer = class {
  constructor() {
    this.blurSize = 30;
    this.pointSize = 20;
    this.maxOpacity = 1;
    this.minOpacity = 0;
    this._gradientPixels = {
      inRange: null,
      outOfRange: null
    };
    const canvas = platformApi.createCanvas();
    this.canvas = canvas;
  }
  update(data, width, height, normalize5, colorFunc, isInRange) {
    const brush3 = this._getBrush();
    const gradientInRange = this._getGradient(colorFunc, "inRange");
    const gradientOutOfRange = this._getGradient(colorFunc, "outOfRange");
    const r = this.pointSize + this.blurSize;
    const canvas = this.canvas;
    const ctx = canvas.getContext("2d");
    const len2 = data.length;
    canvas.width = width;
    canvas.height = height;
    for (let i = 0; i < len2; ++i) {
      const p = data[i];
      const x = p[0];
      const y = p[1];
      const value = p[2];
      const alpha = normalize5(value);
      ctx.globalAlpha = alpha;
      ctx.drawImage(brush3, x - r, y - r);
    }
    if (!canvas.width || !canvas.height) {
      return canvas;
    }
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const pixels = imageData.data;
    let offset = 0;
    const pixelLen = pixels.length;
    const minOpacity = this.minOpacity;
    const maxOpacity = this.maxOpacity;
    const diffOpacity = maxOpacity - minOpacity;
    while (offset < pixelLen) {
      let alpha = pixels[offset + 3] / 256;
      const gradientOffset = Math.floor(alpha * (GRADIENT_LEVELS - 1)) * 4;
      if (alpha > 0) {
        const gradient = isInRange(alpha) ? gradientInRange : gradientOutOfRange;
        alpha > 0 && (alpha = alpha * diffOpacity + minOpacity);
        pixels[offset++] = gradient[gradientOffset];
        pixels[offset++] = gradient[gradientOffset + 1];
        pixels[offset++] = gradient[gradientOffset + 2];
        pixels[offset++] = gradient[gradientOffset + 3] * alpha * 256;
      } else {
        offset += 4;
      }
    }
    ctx.putImageData(imageData, 0, 0);
    return canvas;
  }
  _getBrush() {
    const brushCanvas = this._brushCanvas || (this._brushCanvas = platformApi.createCanvas());
    const r = this.pointSize + this.blurSize;
    const d = r * 2;
    brushCanvas.width = d;
    brushCanvas.height = d;
    const ctx = brushCanvas.getContext("2d");
    ctx.clearRect(0, 0, d, d);
    ctx.shadowOffsetX = d;
    ctx.shadowBlur = this.blurSize;
    ctx.shadowColor = "#000";
    ctx.beginPath();
    ctx.arc(-r, r, this.pointSize, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.fill();
    return brushCanvas;
  }
  _getGradient(colorFunc, state) {
    const gradientPixels = this._gradientPixels;
    const pixelsSingleState = gradientPixels[state] || (gradientPixels[state] = new Uint8ClampedArray(256 * 4));
    const color2 = [0, 0, 0, 0];
    let off = 0;
    for (let i = 0; i < 256; i++) {
      colorFunc[state](i / 255, true, color2);
      pixelsSingleState[off++] = color2[0];
      pixelsSingleState[off++] = color2[1];
      pixelsSingleState[off++] = color2[2];
      pixelsSingleState[off++] = color2[3];
    }
    return pixelsSingleState;
  }
};
var HeatmapLayer_default = HeatmapLayer;

// src/chart/heatmap/HeatmapView.ts
function getIsInPiecewiseRange(dataExtent, pieceList, selected) {
  const dataSpan = dataExtent[1] - dataExtent[0];
  pieceList = map(pieceList, function(piece) {
    return {
      interval: [
        (piece.interval[0] - dataExtent[0]) / dataSpan,
        (piece.interval[1] - dataExtent[0]) / dataSpan
      ]
    };
  });
  const len2 = pieceList.length;
  let lastIndex = 0;
  return function(val) {
    let i;
    for (i = lastIndex; i < len2; i++) {
      const interval = pieceList[i].interval;
      if (interval[0] <= val && val <= interval[1]) {
        lastIndex = i;
        break;
      }
    }
    if (i === len2) {
      for (i = lastIndex - 1; i >= 0; i--) {
        const interval = pieceList[i].interval;
        if (interval[0] <= val && val <= interval[1]) {
          lastIndex = i;
          break;
        }
      }
    }
    return i >= 0 && i < len2 && selected[i];
  };
}
function getIsInContinuousRange(dataExtent, range) {
  const dataSpan = dataExtent[1] - dataExtent[0];
  range = [
    (range[0] - dataExtent[0]) / dataSpan,
    (range[1] - dataExtent[0]) / dataSpan
  ];
  return function(val) {
    return val >= range[0] && val <= range[1];
  };
}
function isGeoCoordSys(coordSys) {
  const dimensions = coordSys.dimensions;
  return dimensions[0] === "lng" && dimensions[1] === "lat";
}
var HeatmapView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = HeatmapView2.type;
  }
  render(seriesModel, ecModel, api2) {
    let visualMapOfThisSeries;
    ecModel.eachComponent("visualMap", function(visualMap) {
      visualMap.eachTargetSeries(function(targetSeries) {
        if (targetSeries === seriesModel) {
          visualMapOfThisSeries = visualMap;
        }
      });
    });
    if (true) {
      if (!visualMapOfThisSeries) {
        throw new Error("Heatmap must use with visualMap");
      }
    }
    this._progressiveEls = null;
    this.group.removeAll();
    const coordSys = seriesModel.coordinateSystem;
    if (coordSys.type === "cartesian2d" || coordSys.type === "calendar") {
      this._renderOnCartesianAndCalendar(seriesModel, api2, 0, seriesModel.getData().count());
    } else if (isGeoCoordSys(coordSys)) {
      this._renderOnGeo(coordSys, seriesModel, visualMapOfThisSeries, api2);
    }
  }
  incrementalPrepareRender(seriesModel, ecModel, api2) {
    this.group.removeAll();
  }
  incrementalRender(params, seriesModel, ecModel, api2) {
    const coordSys = seriesModel.coordinateSystem;
    if (coordSys) {
      if (isGeoCoordSys(coordSys)) {
        this.render(seriesModel, ecModel, api2);
      } else {
        this._progressiveEls = [];
        this._renderOnCartesianAndCalendar(seriesModel, api2, params.start, params.end, true);
      }
    }
  }
  eachRendered(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  }
  _renderOnCartesianAndCalendar(seriesModel, api2, start2, end2, incremental) {
    const coordSys = seriesModel.coordinateSystem;
    const isCartesian2d = isCoordinateSystemType(coordSys, "cartesian2d");
    let width;
    let height;
    let xAxisExtent;
    let yAxisExtent;
    if (isCartesian2d) {
      const xAxis = coordSys.getAxis("x");
      const yAxis = coordSys.getAxis("y");
      if (true) {
        if (!(xAxis.type === "category" && yAxis.type === "category")) {
          throw new Error("Heatmap on cartesian must have two category axes");
        }
        if (!(xAxis.onBand && yAxis.onBand)) {
          throw new Error("Heatmap on cartesian must have two axes with boundaryGap true");
        }
      }
      width = xAxis.getBandWidth() + 0.5;
      height = yAxis.getBandWidth() + 0.5;
      xAxisExtent = xAxis.scale.getExtent();
      yAxisExtent = yAxis.scale.getExtent();
    }
    const group = this.group;
    const data = seriesModel.getData();
    let emphasisStyle = seriesModel.getModel(["emphasis", "itemStyle"]).getItemStyle();
    let blurStyle = seriesModel.getModel(["blur", "itemStyle"]).getItemStyle();
    let selectStyle = seriesModel.getModel(["select", "itemStyle"]).getItemStyle();
    let borderRadius = seriesModel.get(["itemStyle", "borderRadius"]);
    let labelStatesModels = getLabelStatesModels(seriesModel);
    const emphasisModel = seriesModel.getModel("emphasis");
    let focus = emphasisModel.get("focus");
    let blurScope = emphasisModel.get("blurScope");
    let emphasisDisabled = emphasisModel.get("disabled");
    const dataDims = isCartesian2d ? [
      data.mapDimension("x"),
      data.mapDimension("y"),
      data.mapDimension("value")
    ] : [
      data.mapDimension("time"),
      data.mapDimension("value")
    ];
    for (let idx = start2; idx < end2; idx++) {
      let rect;
      const style = data.getItemVisual(idx, "style");
      if (isCartesian2d) {
        const dataDimX = data.get(dataDims[0], idx);
        const dataDimY = data.get(dataDims[1], idx);
        if (isNaN(data.get(dataDims[2], idx)) || isNaN(dataDimX) || isNaN(dataDimY) || dataDimX < xAxisExtent[0] || dataDimX > xAxisExtent[1] || dataDimY < yAxisExtent[0] || dataDimY > yAxisExtent[1]) {
          continue;
        }
        const point = coordSys.dataToPoint([
          dataDimX,
          dataDimY
        ]);
        rect = new Rect_default({
          shape: {
            x: point[0] - width / 2,
            y: point[1] - height / 2,
            width,
            height
          },
          style
        });
      } else {
        if (isNaN(data.get(dataDims[1], idx))) {
          continue;
        }
        rect = new Rect_default({
          z2: 1,
          shape: coordSys.dataToRect([data.get(dataDims[0], idx)]).contentShape,
          style
        });
      }
      if (data.hasItemOption) {
        const itemModel = data.getItemModel(idx);
        const emphasisModel2 = itemModel.getModel("emphasis");
        emphasisStyle = emphasisModel2.getModel("itemStyle").getItemStyle();
        blurStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
        selectStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
        borderRadius = itemModel.get(["itemStyle", "borderRadius"]);
        focus = emphasisModel2.get("focus");
        blurScope = emphasisModel2.get("blurScope");
        emphasisDisabled = emphasisModel2.get("disabled");
        labelStatesModels = getLabelStatesModels(itemModel);
      }
      rect.shape.r = borderRadius;
      const rawValue = seriesModel.getRawValue(idx);
      let defaultText = "-";
      if (rawValue && rawValue[2] != null) {
        defaultText = rawValue[2] + "";
      }
      setLabelStyle(rect, labelStatesModels, {
        labelFetcher: seriesModel,
        labelDataIndex: idx,
        defaultOpacity: style.opacity,
        defaultText
      });
      rect.ensureState("emphasis").style = emphasisStyle;
      rect.ensureState("blur").style = blurStyle;
      rect.ensureState("select").style = selectStyle;
      toggleHoverEmphasis(rect, focus, blurScope, emphasisDisabled);
      rect.incremental = incremental;
      if (incremental) {
        rect.states.emphasis.hoverLayer = true;
      }
      group.add(rect);
      data.setItemGraphicEl(idx, rect);
      if (this._progressiveEls) {
        this._progressiveEls.push(rect);
      }
    }
  }
  _renderOnGeo(geo, seriesModel, visualMapModel, api2) {
    const inRangeVisuals = visualMapModel.targetVisuals.inRange;
    const outOfRangeVisuals = visualMapModel.targetVisuals.outOfRange;
    const data = seriesModel.getData();
    const hmLayer = this._hmLayer || (this._hmLayer || new HeatmapLayer_default());
    hmLayer.blurSize = seriesModel.get("blurSize");
    hmLayer.pointSize = seriesModel.get("pointSize");
    hmLayer.minOpacity = seriesModel.get("minOpacity");
    hmLayer.maxOpacity = seriesModel.get("maxOpacity");
    const rect = geo.getViewRect().clone();
    const roamTransform = geo.getRoamTransform();
    rect.applyTransform(roamTransform);
    const x = Math.max(rect.x, 0);
    const y = Math.max(rect.y, 0);
    const x2 = Math.min(rect.width + rect.x, api2.getWidth());
    const y2 = Math.min(rect.height + rect.y, api2.getHeight());
    const width = x2 - x;
    const height = y2 - y;
    const dims = [
      data.mapDimension("lng"),
      data.mapDimension("lat"),
      data.mapDimension("value")
    ];
    const points4 = data.mapArray(dims, function(lng, lat, value) {
      const pt = geo.dataToPoint([lng, lat]);
      pt[0] -= x;
      pt[1] -= y;
      pt.push(value);
      return pt;
    });
    const dataExtent = visualMapModel.getExtent();
    const isInRange = visualMapModel.type === "visualMap.continuous" ? getIsInContinuousRange(dataExtent, visualMapModel.option.range) : getIsInPiecewiseRange(dataExtent, visualMapModel.getPieceList(), visualMapModel.option.selected);
    hmLayer.update(points4, width, height, inRangeVisuals.color.getNormalizer(), {
      inRange: inRangeVisuals.color.getColorMapper(),
      outOfRange: outOfRangeVisuals.color.getColorMapper()
    }, isInRange);
    const img = new Image_default({
      style: {
        width,
        height,
        x,
        y,
        image: hmLayer.canvas
      },
      silent: true
    });
    this.group.add(img);
  }
};
var HeatmapView = HeatmapView2;
HeatmapView.type = "heatmap";
var HeatmapView_default = HeatmapView;

// src/chart/heatmap/HeatmapSeries.ts
var HeatmapSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = HeatmapSeriesModel2.type;
  }
  getInitialData(option, ecModel) {
    return createSeriesData_default(null, this, {
      generateCoord: "value"
    });
  }
  preventIncremental() {
    const coordSysCreator = CoordinateSystem_default.get(this.get("coordinateSystem"));
    if (coordSysCreator && coordSysCreator.dimensions) {
      return coordSysCreator.dimensions[0] === "lng" && coordSysCreator.dimensions[1] === "lat";
    }
  }
};
var HeatmapSeriesModel = HeatmapSeriesModel2;
HeatmapSeriesModel.type = "series.heatmap";
HeatmapSeriesModel.dependencies = ["grid", "geo", "calendar"];
HeatmapSeriesModel.defaultOption = {
  coordinateSystem: "cartesian2d",
  z: 2,
  geoIndex: 0,
  blurSize: 30,
  pointSize: 20,
  maxOpacity: 1,
  minOpacity: 0,
  select: {
    itemStyle: {
      borderColor: "#212121"
    }
  }
};
var HeatmapSeries_default = HeatmapSeriesModel;

// src/chart/heatmap/install.ts
function install24(registers) {
  registers.registerChartView(HeatmapView_default);
  registers.registerSeriesModel(HeatmapSeries_default);
}

// src/chart/bar/PictorialBarView.ts
var BAR_BORDER_WIDTH_QUERY = ["itemStyle", "borderWidth"];
var LAYOUT_ATTRS = [
  {xy: "x", wh: "width", index: 0, posDesc: ["left", "right"]},
  {xy: "y", wh: "height", index: 1, posDesc: ["top", "bottom"]}
];
var pathForLineWidth = new Circle_default();
var PictorialBarView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = PictorialBarView2.type;
  }
  render(seriesModel, ecModel, api2) {
    const group = this.group;
    const data = seriesModel.getData();
    const oldData = this._data;
    const cartesian = seriesModel.coordinateSystem;
    const baseAxis = cartesian.getBaseAxis();
    const isHorizontal = baseAxis.isHorizontal();
    const coordSysRect = cartesian.master.getRect();
    const opt = {
      ecSize: {width: api2.getWidth(), height: api2.getHeight()},
      seriesModel,
      coordSys: cartesian,
      coordSysExtent: [
        [coordSysRect.x, coordSysRect.x + coordSysRect.width],
        [coordSysRect.y, coordSysRect.y + coordSysRect.height]
      ],
      isHorizontal,
      valueDim: LAYOUT_ATTRS[+isHorizontal],
      categoryDim: LAYOUT_ATTRS[1 - +isHorizontal]
    };
    data.diff(oldData).add(function(dataIndex) {
      if (!data.hasValue(dataIndex)) {
        return;
      }
      const itemModel = getItemModel(data, dataIndex);
      const symbolMeta = getSymbolMeta(data, dataIndex, itemModel, opt);
      const bar = createBar(data, opt, symbolMeta);
      data.setItemGraphicEl(dataIndex, bar);
      group.add(bar);
      updateCommon2(bar, opt, symbolMeta);
    }).update(function(newIndex, oldIndex) {
      let bar = oldData.getItemGraphicEl(oldIndex);
      if (!data.hasValue(newIndex)) {
        group.remove(bar);
        return;
      }
      const itemModel = getItemModel(data, newIndex);
      const symbolMeta = getSymbolMeta(data, newIndex, itemModel, opt);
      const pictorialShapeStr = getShapeStr(data, symbolMeta);
      if (bar && pictorialShapeStr !== bar.__pictorialShapeStr) {
        group.remove(bar);
        data.setItemGraphicEl(newIndex, null);
        bar = null;
      }
      if (bar) {
        updateBar(bar, opt, symbolMeta);
      } else {
        bar = createBar(data, opt, symbolMeta, true);
      }
      data.setItemGraphicEl(newIndex, bar);
      bar.__pictorialSymbolMeta = symbolMeta;
      group.add(bar);
      updateCommon2(bar, opt, symbolMeta);
    }).remove(function(dataIndex) {
      const bar = oldData.getItemGraphicEl(dataIndex);
      bar && removeBar(oldData, dataIndex, bar.__pictorialSymbolMeta.animationModel, bar);
    }).execute();
    const clipPath = seriesModel.get("clip", true) ? createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null;
    if (clipPath) {
      group.setClipPath(clipPath);
    } else {
      group.removeClipPath();
    }
    this._data = data;
    return this.group;
  }
  remove(ecModel, api2) {
    const group = this.group;
    const data = this._data;
    if (ecModel.get("animation")) {
      if (data) {
        data.eachItemGraphicEl(function(bar) {
          removeBar(data, getECData(bar).dataIndex, ecModel, bar);
        });
      }
    } else {
      group.removeAll();
    }
  }
};
var PictorialBarView = PictorialBarView2;
PictorialBarView.type = "pictorialBar";
function getSymbolMeta(data, dataIndex, itemModel, opt) {
  const layout18 = data.getItemLayout(dataIndex);
  const symbolRepeat = itemModel.get("symbolRepeat");
  const symbolClip = itemModel.get("symbolClip");
  const symbolPosition = itemModel.get("symbolPosition") || "start";
  const symbolRotate = itemModel.get("symbolRotate");
  const rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
  const symbolPatternSize = itemModel.get("symbolPatternSize") || 2;
  const isAnimationEnabled2 = itemModel.isAnimationEnabled();
  const symbolMeta = {
    dataIndex,
    layout: layout18,
    itemModel,
    symbolType: data.getItemVisual(dataIndex, "symbol") || "circle",
    style: data.getItemVisual(dataIndex, "style"),
    symbolClip,
    symbolRepeat,
    symbolRepeatDirection: itemModel.get("symbolRepeatDirection"),
    symbolPatternSize,
    rotation,
    animationModel: isAnimationEnabled2 ? itemModel : null,
    hoverScale: isAnimationEnabled2 && itemModel.get(["emphasis", "scale"]),
    z2: itemModel.getShallow("z", true) || 0
  };
  prepareBarLength(itemModel, symbolRepeat, layout18, opt, symbolMeta);
  prepareSymbolSize(data, dataIndex, layout18, symbolRepeat, symbolClip, symbolMeta.boundingLength, symbolMeta.pxSign, symbolPatternSize, opt, symbolMeta);
  prepareLineWidth(itemModel, symbolMeta.symbolScale, rotation, opt, symbolMeta);
  const symbolSize = symbolMeta.symbolSize;
  const symbolOffset = normalizeSymbolOffset(itemModel.get("symbolOffset"), symbolSize);
  prepareLayoutInfo(itemModel, symbolSize, layout18, symbolRepeat, symbolClip, symbolOffset, symbolPosition, symbolMeta.valueLineWidth, symbolMeta.boundingLength, symbolMeta.repeatCutLength, opt, symbolMeta);
  return symbolMeta;
}
function prepareBarLength(itemModel, symbolRepeat, layout18, opt, outputSymbolMeta) {
  const valueDim = opt.valueDim;
  const symbolBoundingData = itemModel.get("symbolBoundingData");
  const valueAxis2 = opt.coordSys.getOtherAxis(opt.coordSys.getBaseAxis());
  const zeroPx = valueAxis2.toGlobalCoord(valueAxis2.dataToCoord(0));
  const pxSignIdx = 1 - +(layout18[valueDim.wh] <= 0);
  let boundingLength;
  if (isArray(symbolBoundingData)) {
    const symbolBoundingExtent = [
      convertToCoordOnAxis(valueAxis2, symbolBoundingData[0]) - zeroPx,
      convertToCoordOnAxis(valueAxis2, symbolBoundingData[1]) - zeroPx
    ];
    symbolBoundingExtent[1] < symbolBoundingExtent[0] && symbolBoundingExtent.reverse();
    boundingLength = symbolBoundingExtent[pxSignIdx];
  } else if (symbolBoundingData != null) {
    boundingLength = convertToCoordOnAxis(valueAxis2, symbolBoundingData) - zeroPx;
  } else if (symbolRepeat) {
    boundingLength = opt.coordSysExtent[valueDim.index][pxSignIdx] - zeroPx;
  } else {
    boundingLength = layout18[valueDim.wh];
  }
  outputSymbolMeta.boundingLength = boundingLength;
  if (symbolRepeat) {
    outputSymbolMeta.repeatCutLength = layout18[valueDim.wh];
  }
  outputSymbolMeta.pxSign = boundingLength > 0 ? 1 : -1;
}
function convertToCoordOnAxis(axis, value) {
  return axis.toGlobalCoord(axis.dataToCoord(axis.scale.parse(value)));
}
function prepareSymbolSize(data, dataIndex, layout18, symbolRepeat, symbolClip, boundingLength, pxSign, symbolPatternSize, opt, outputSymbolMeta) {
  const valueDim = opt.valueDim;
  const categoryDim = opt.categoryDim;
  const categorySize = Math.abs(layout18[categoryDim.wh]);
  const symbolSize = data.getItemVisual(dataIndex, "symbolSize");
  let parsedSymbolSize;
  if (isArray(symbolSize)) {
    parsedSymbolSize = symbolSize.slice();
  } else {
    if (symbolSize == null) {
      parsedSymbolSize = ["100%", "100%"];
    } else {
      parsedSymbolSize = [symbolSize, symbolSize];
    }
  }
  parsedSymbolSize[categoryDim.index] = parsePercent2(parsedSymbolSize[categoryDim.index], categorySize);
  parsedSymbolSize[valueDim.index] = parsePercent2(parsedSymbolSize[valueDim.index], symbolRepeat ? categorySize : Math.abs(boundingLength));
  outputSymbolMeta.symbolSize = parsedSymbolSize;
  const symbolScale = outputSymbolMeta.symbolScale = [
    parsedSymbolSize[0] / symbolPatternSize,
    parsedSymbolSize[1] / symbolPatternSize
  ];
  symbolScale[valueDim.index] *= (opt.isHorizontal ? -1 : 1) * pxSign;
}
function prepareLineWidth(itemModel, symbolScale, rotation, opt, outputSymbolMeta) {
  let valueLineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;
  if (valueLineWidth) {
    pathForLineWidth.attr({
      scaleX: symbolScale[0],
      scaleY: symbolScale[1],
      rotation
    });
    pathForLineWidth.updateTransform();
    valueLineWidth /= pathForLineWidth.getLineScale();
    valueLineWidth *= symbolScale[opt.valueDim.index];
  }
  outputSymbolMeta.valueLineWidth = valueLineWidth || 0;
}
function prepareLayoutInfo(itemModel, symbolSize, layout18, symbolRepeat, symbolClip, symbolOffset, symbolPosition, valueLineWidth, boundingLength, repeatCutLength, opt, outputSymbolMeta) {
  const categoryDim = opt.categoryDim;
  const valueDim = opt.valueDim;
  const pxSign = outputSymbolMeta.pxSign;
  const unitLength = Math.max(symbolSize[valueDim.index] + valueLineWidth, 0);
  let pathLen = unitLength;
  if (symbolRepeat) {
    const absBoundingLength = Math.abs(boundingLength);
    let symbolMargin = retrieve(itemModel.get("symbolMargin"), "15%") + "";
    let hasEndGap = false;
    if (symbolMargin.lastIndexOf("!") === symbolMargin.length - 1) {
      hasEndGap = true;
      symbolMargin = symbolMargin.slice(0, symbolMargin.length - 1);
    }
    let symbolMarginNumeric = parsePercent2(symbolMargin, symbolSize[valueDim.index]);
    let uLenWithMargin = Math.max(unitLength + symbolMarginNumeric * 2, 0);
    let endFix = hasEndGap ? 0 : symbolMarginNumeric * 2;
    const repeatSpecified = isNumeric(symbolRepeat);
    let repeatTimes = repeatSpecified ? symbolRepeat : toIntTimes((absBoundingLength + endFix) / uLenWithMargin);
    const mDiff = absBoundingLength - repeatTimes * unitLength;
    symbolMarginNumeric = mDiff / 2 / (hasEndGap ? repeatTimes : Math.max(repeatTimes - 1, 1));
    uLenWithMargin = unitLength + symbolMarginNumeric * 2;
    endFix = hasEndGap ? 0 : symbolMarginNumeric * 2;
    if (!repeatSpecified && symbolRepeat !== "fixed") {
      repeatTimes = repeatCutLength ? toIntTimes((Math.abs(repeatCutLength) + endFix) / uLenWithMargin) : 0;
    }
    pathLen = repeatTimes * uLenWithMargin - endFix;
    outputSymbolMeta.repeatTimes = repeatTimes;
    outputSymbolMeta.symbolMargin = symbolMarginNumeric;
  }
  const sizeFix = pxSign * (pathLen / 2);
  const pathPosition = outputSymbolMeta.pathPosition = [];
  pathPosition[categoryDim.index] = layout18[categoryDim.wh] / 2;
  pathPosition[valueDim.index] = symbolPosition === "start" ? sizeFix : symbolPosition === "end" ? boundingLength - sizeFix : boundingLength / 2;
  if (symbolOffset) {
    pathPosition[0] += symbolOffset[0];
    pathPosition[1] += symbolOffset[1];
  }
  const bundlePosition = outputSymbolMeta.bundlePosition = [];
  bundlePosition[categoryDim.index] = layout18[categoryDim.xy];
  bundlePosition[valueDim.index] = layout18[valueDim.xy];
  const barRectShape = outputSymbolMeta.barRectShape = extend({}, layout18);
  barRectShape[valueDim.wh] = pxSign * Math.max(Math.abs(layout18[valueDim.wh]), Math.abs(pathPosition[valueDim.index] + sizeFix));
  barRectShape[categoryDim.wh] = layout18[categoryDim.wh];
  const clipShape = outputSymbolMeta.clipShape = {};
  clipShape[categoryDim.xy] = -layout18[categoryDim.xy];
  clipShape[categoryDim.wh] = opt.ecSize[categoryDim.wh];
  clipShape[valueDim.xy] = 0;
  clipShape[valueDim.wh] = layout18[valueDim.wh];
}
function createPath(symbolMeta) {
  const symbolPatternSize = symbolMeta.symbolPatternSize;
  const path = createSymbol(symbolMeta.symbolType, -symbolPatternSize / 2, -symbolPatternSize / 2, symbolPatternSize, symbolPatternSize);
  path.attr({
    culling: true
  });
  path.type !== "image" && path.setStyle({
    strokeNoScale: true
  });
  return path;
}
function createOrUpdateRepeatSymbols(bar, opt, symbolMeta, isUpdate) {
  const bundle = bar.__pictorialBundle;
  const symbolSize = symbolMeta.symbolSize;
  const valueLineWidth = symbolMeta.valueLineWidth;
  const pathPosition = symbolMeta.pathPosition;
  const valueDim = opt.valueDim;
  const repeatTimes = symbolMeta.repeatTimes || 0;
  let index = 0;
  const unit = symbolSize[opt.valueDim.index] + valueLineWidth + symbolMeta.symbolMargin * 2;
  eachPath(bar, function(path) {
    path.__pictorialAnimationIndex = index;
    path.__pictorialRepeatTimes = repeatTimes;
    if (index < repeatTimes) {
      updateAttr(path, null, makeTarget(index), symbolMeta, isUpdate);
    } else {
      updateAttr(path, null, {scaleX: 0, scaleY: 0}, symbolMeta, isUpdate, function() {
        bundle.remove(path);
      });
    }
    index++;
  });
  for (; index < repeatTimes; index++) {
    const path = createPath(symbolMeta);
    path.__pictorialAnimationIndex = index;
    path.__pictorialRepeatTimes = repeatTimes;
    bundle.add(path);
    const target = makeTarget(index);
    updateAttr(path, {
      x: target.x,
      y: target.y,
      scaleX: 0,
      scaleY: 0
    }, {
      scaleX: target.scaleX,
      scaleY: target.scaleY,
      rotation: target.rotation
    }, symbolMeta, isUpdate);
  }
  function makeTarget(index2) {
    const position2 = pathPosition.slice();
    const pxSign = symbolMeta.pxSign;
    let i = index2;
    if (symbolMeta.symbolRepeatDirection === "start" ? pxSign > 0 : pxSign < 0) {
      i = repeatTimes - 1 - index2;
    }
    position2[valueDim.index] = unit * (i - repeatTimes / 2 + 0.5) + pathPosition[valueDim.index];
    return {
      x: position2[0],
      y: position2[1],
      scaleX: symbolMeta.symbolScale[0],
      scaleY: symbolMeta.symbolScale[1],
      rotation: symbolMeta.rotation
    };
  }
}
function createOrUpdateSingleSymbol(bar, opt, symbolMeta, isUpdate) {
  const bundle = bar.__pictorialBundle;
  let mainPath = bar.__pictorialMainPath;
  if (!mainPath) {
    mainPath = bar.__pictorialMainPath = createPath(symbolMeta);
    bundle.add(mainPath);
    updateAttr(mainPath, {
      x: symbolMeta.pathPosition[0],
      y: symbolMeta.pathPosition[1],
      scaleX: 0,
      scaleY: 0,
      rotation: symbolMeta.rotation
    }, {
      scaleX: symbolMeta.symbolScale[0],
      scaleY: symbolMeta.symbolScale[1]
    }, symbolMeta, isUpdate);
  } else {
    updateAttr(mainPath, null, {
      x: symbolMeta.pathPosition[0],
      y: symbolMeta.pathPosition[1],
      scaleX: symbolMeta.symbolScale[0],
      scaleY: symbolMeta.symbolScale[1],
      rotation: symbolMeta.rotation
    }, symbolMeta, isUpdate);
  }
}
function createOrUpdateBarRect(bar, symbolMeta, isUpdate) {
  const rectShape = extend({}, symbolMeta.barRectShape);
  let barRect = bar.__pictorialBarRect;
  if (!barRect) {
    barRect = bar.__pictorialBarRect = new Rect_default({
      z2: 2,
      shape: rectShape,
      silent: true,
      style: {
        stroke: "transparent",
        fill: "transparent",
        lineWidth: 0
      }
    });
    barRect.disableMorphing = true;
    bar.add(barRect);
  } else {
    updateAttr(barRect, null, {shape: rectShape}, symbolMeta, isUpdate);
  }
}
function createOrUpdateClip(bar, opt, symbolMeta, isUpdate) {
  if (symbolMeta.symbolClip) {
    let clipPath = bar.__pictorialClipPath;
    const clipShape = extend({}, symbolMeta.clipShape);
    const valueDim = opt.valueDim;
    const animationModel = symbolMeta.animationModel;
    const dataIndex = symbolMeta.dataIndex;
    if (clipPath) {
      updateProps(clipPath, {shape: clipShape}, animationModel, dataIndex);
    } else {
      clipShape[valueDim.wh] = 0;
      clipPath = new Rect_default({shape: clipShape});
      bar.__pictorialBundle.setClipPath(clipPath);
      bar.__pictorialClipPath = clipPath;
      const target = {};
      target[valueDim.wh] = symbolMeta.clipShape[valueDim.wh];
      graphic_exports[isUpdate ? "updateProps" : "initProps"](clipPath, {shape: target}, animationModel, dataIndex);
    }
  }
}
function getItemModel(data, dataIndex) {
  const itemModel = data.getItemModel(dataIndex);
  itemModel.getAnimationDelayParams = getAnimationDelayParams;
  itemModel.isAnimationEnabled = isAnimationEnabled;
  return itemModel;
}
function getAnimationDelayParams(path) {
  return {
    index: path.__pictorialAnimationIndex,
    count: path.__pictorialRepeatTimes
  };
}
function isAnimationEnabled() {
  return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
}
function createBar(data, opt, symbolMeta, isUpdate) {
  const bar = new Group_default();
  const bundle = new Group_default();
  bar.add(bundle);
  bar.__pictorialBundle = bundle;
  bundle.x = symbolMeta.bundlePosition[0];
  bundle.y = symbolMeta.bundlePosition[1];
  if (symbolMeta.symbolRepeat) {
    createOrUpdateRepeatSymbols(bar, opt, symbolMeta);
  } else {
    createOrUpdateSingleSymbol(bar, opt, symbolMeta);
  }
  createOrUpdateBarRect(bar, symbolMeta, isUpdate);
  createOrUpdateClip(bar, opt, symbolMeta, isUpdate);
  bar.__pictorialShapeStr = getShapeStr(data, symbolMeta);
  bar.__pictorialSymbolMeta = symbolMeta;
  return bar;
}
function updateBar(bar, opt, symbolMeta) {
  const animationModel = symbolMeta.animationModel;
  const dataIndex = symbolMeta.dataIndex;
  const bundle = bar.__pictorialBundle;
  updateProps(bundle, {
    x: symbolMeta.bundlePosition[0],
    y: symbolMeta.bundlePosition[1]
  }, animationModel, dataIndex);
  if (symbolMeta.symbolRepeat) {
    createOrUpdateRepeatSymbols(bar, opt, symbolMeta, true);
  } else {
    createOrUpdateSingleSymbol(bar, opt, symbolMeta, true);
  }
  createOrUpdateBarRect(bar, symbolMeta, true);
  createOrUpdateClip(bar, opt, symbolMeta, true);
}
function removeBar(data, dataIndex, animationModel, bar) {
  const labelRect = bar.__pictorialBarRect;
  labelRect && labelRect.removeTextContent();
  const paths = [];
  eachPath(bar, function(path) {
    paths.push(path);
  });
  bar.__pictorialMainPath && paths.push(bar.__pictorialMainPath);
  bar.__pictorialClipPath && (animationModel = null);
  each(paths, function(path) {
    removeElement(path, {scaleX: 0, scaleY: 0}, animationModel, dataIndex, function() {
      bar.parent && bar.parent.remove(bar);
    });
  });
  data.setItemGraphicEl(dataIndex, null);
}
function getShapeStr(data, symbolMeta) {
  return [
    data.getItemVisual(symbolMeta.dataIndex, "symbol") || "none",
    !!symbolMeta.symbolRepeat,
    !!symbolMeta.symbolClip
  ].join(":");
}
function eachPath(bar, cb, context) {
  each(bar.__pictorialBundle.children(), function(el) {
    el !== bar.__pictorialBarRect && cb.call(context, el);
  });
}
function updateAttr(el, immediateAttrs, animationAttrs, symbolMeta, isUpdate, cb) {
  immediateAttrs && el.attr(immediateAttrs);
  if (symbolMeta.symbolClip && !isUpdate) {
    animationAttrs && el.attr(animationAttrs);
  } else {
    animationAttrs && graphic_exports[isUpdate ? "updateProps" : "initProps"](el, animationAttrs, symbolMeta.animationModel, symbolMeta.dataIndex, cb);
  }
}
function updateCommon2(bar, opt, symbolMeta) {
  const dataIndex = symbolMeta.dataIndex;
  const itemModel = symbolMeta.itemModel;
  const emphasisModel = itemModel.getModel("emphasis");
  const emphasisStyle = emphasisModel.getModel("itemStyle").getItemStyle();
  const blurStyle = itemModel.getModel(["blur", "itemStyle"]).getItemStyle();
  const selectStyle = itemModel.getModel(["select", "itemStyle"]).getItemStyle();
  const cursorStyle = itemModel.getShallow("cursor");
  const focus = emphasisModel.get("focus");
  const blurScope = emphasisModel.get("blurScope");
  const hoverScale = emphasisModel.get("scale");
  eachPath(bar, function(path) {
    if (path instanceof Image_default) {
      const pathStyle = path.style;
      path.useStyle(extend({
        image: pathStyle.image,
        x: pathStyle.x,
        y: pathStyle.y,
        width: pathStyle.width,
        height: pathStyle.height
      }, symbolMeta.style));
    } else {
      path.useStyle(symbolMeta.style);
    }
    const emphasisState = path.ensureState("emphasis");
    emphasisState.style = emphasisStyle;
    if (hoverScale) {
      emphasisState.scaleX = path.scaleX * 1.1;
      emphasisState.scaleY = path.scaleY * 1.1;
    }
    path.ensureState("blur").style = blurStyle;
    path.ensureState("select").style = selectStyle;
    cursorStyle && (path.cursor = cursorStyle);
    path.z2 = symbolMeta.z2;
  });
  const barPositionOutside = opt.valueDim.posDesc[+(symbolMeta.boundingLength > 0)];
  const barRect = bar.__pictorialBarRect;
  barRect.ignoreClip = true;
  setLabelStyle(barRect, getLabelStatesModels(itemModel), {
    labelFetcher: opt.seriesModel,
    labelDataIndex: dataIndex,
    defaultText: getDefaultLabel(opt.seriesModel.getData(), dataIndex),
    inheritColor: symbolMeta.style.fill,
    defaultOpacity: symbolMeta.style.opacity,
    defaultOutsidePosition: barPositionOutside
  });
  toggleHoverEmphasis(bar, focus, blurScope, emphasisModel.get("disabled"));
}
function toIntTimes(times) {
  const roundedTimes = Math.round(times);
  return Math.abs(times - roundedTimes) < 1e-4 ? roundedTimes : Math.ceil(times);
}
var PictorialBarView_default = PictorialBarView;

// src/chart/bar/PictorialBarSeries.ts
var PictorialBarSeriesModel2 = class extends BaseBarSeries_default {
  constructor() {
    super(...arguments);
    this.type = PictorialBarSeriesModel2.type;
    this.hasSymbolVisual = true;
    this.defaultSymbol = "roundRect";
  }
  getInitialData(option) {
    option.stack = null;
    return super.getInitialData.apply(this, arguments);
  }
};
var PictorialBarSeriesModel = PictorialBarSeriesModel2;
PictorialBarSeriesModel.type = "series.pictorialBar";
PictorialBarSeriesModel.dependencies = ["grid"];
PictorialBarSeriesModel.defaultOption = inheritDefaultOption(BaseBarSeries_default.defaultOption, {
  symbol: "circle",
  symbolSize: null,
  symbolRotate: null,
  symbolPosition: null,
  symbolOffset: null,
  symbolMargin: null,
  symbolRepeat: false,
  symbolRepeatDirection: "end",
  symbolClip: false,
  symbolBoundingData: null,
  symbolPatternSize: 400,
  barGap: "-100%",
  clip: false,
  progressive: 0,
  emphasis: {
    scale: false
  },
  select: {
    itemStyle: {
      borderColor: "#212121"
    }
  }
});
var PictorialBarSeries_default = PictorialBarSeriesModel;

// src/chart/bar/installPictorialBar.ts
function install25(registers) {
  registers.registerChartView(PictorialBarView_default);
  registers.registerSeriesModel(PictorialBarSeries_default);
  registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, curry(layout2, "pictorialBar"));
  registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout("pictorialBar"));
}

// src/chart/themeRiver/ThemeRiverView.ts
var ThemeRiverView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = ThemeRiverView2.type;
    this._layers = [];
  }
  render(seriesModel, ecModel, api2) {
    const data = seriesModel.getData();
    const self2 = this;
    const group = this.group;
    const layersSeries = seriesModel.getLayerSeries();
    const layoutInfo = data.getLayout("layoutInfo");
    const rect = layoutInfo.rect;
    const boundaryGap = layoutInfo.boundaryGap;
    group.x = 0;
    group.y = rect.y + boundaryGap[0];
    function keyGetter(item) {
      return item.name;
    }
    const dataDiffer = new DataDiffer_default(this._layersSeries || [], layersSeries, keyGetter, keyGetter);
    const newLayersGroups = [];
    dataDiffer.add(bind(process2, this, "add")).update(bind(process2, this, "update")).remove(bind(process2, this, "remove")).execute();
    function process2(status, idx, oldIdx) {
      const oldLayersGroups = self2._layers;
      if (status === "remove") {
        group.remove(oldLayersGroups[idx]);
        return;
      }
      const points0 = [];
      const points1 = [];
      let style;
      const indices = layersSeries[idx].indices;
      let j = 0;
      for (; j < indices.length; j++) {
        const layout18 = data.getItemLayout(indices[j]);
        const x = layout18.x;
        const y0 = layout18.y0;
        const y = layout18.y;
        points0.push(x, y0);
        points1.push(x, y0 + y);
        style = data.getItemVisual(indices[j], "style");
      }
      let polygon;
      const textLayout = data.getItemLayout(indices[0]);
      const labelModel = seriesModel.getModel("label");
      const margin = labelModel.get("margin");
      const emphasisModel = seriesModel.getModel("emphasis");
      if (status === "add") {
        const layerGroup = newLayersGroups[idx] = new Group_default();
        polygon = new ECPolygon({
          shape: {
            points: points0,
            stackedOnPoints: points1,
            smooth: 0.4,
            stackedOnSmooth: 0.4,
            smoothConstraint: false
          },
          z2: 0
        });
        layerGroup.add(polygon);
        group.add(layerGroup);
        if (seriesModel.isAnimationEnabled()) {
          polygon.setClipPath(createGridClipShape3(polygon.getBoundingRect(), seriesModel, function() {
            polygon.removeClipPath();
          }));
        }
      } else {
        const layerGroup = oldLayersGroups[oldIdx];
        polygon = layerGroup.childAt(0);
        group.add(layerGroup);
        newLayersGroups[idx] = layerGroup;
        updateProps(polygon, {
          shape: {
            points: points0,
            stackedOnPoints: points1
          }
        }, seriesModel);
        saveOldStyle(polygon);
      }
      setLabelStyle(polygon, getLabelStatesModels(seriesModel), {
        labelDataIndex: indices[j - 1],
        defaultText: data.getName(indices[j - 1]),
        inheritColor: style.fill
      }, {
        normal: {
          verticalAlign: "middle"
        }
      });
      polygon.setTextConfig({
        position: null,
        local: true
      });
      const labelEl = polygon.getTextContent();
      if (labelEl) {
        labelEl.x = textLayout.x - margin;
        labelEl.y = textLayout.y0 + textLayout.y / 2;
      }
      polygon.useStyle(style);
      data.setItemGraphicEl(idx, polygon);
      setStatesStylesFromModel(polygon, seriesModel);
      toggleHoverEmphasis(polygon, emphasisModel.get("focus"), emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
    }
    this._layersSeries = layersSeries;
    this._layers = newLayersGroups;
  }
};
var ThemeRiverView = ThemeRiverView2;
ThemeRiverView.type = "themeRiver";
function createGridClipShape3(rect, seriesModel, cb) {
  const rectEl = new Rect_default({
    shape: {
      x: rect.x - 10,
      y: rect.y - 10,
      width: 0,
      height: rect.height + 20
    }
  });
  initProps(rectEl, {
    shape: {
      x: rect.x - 50,
      width: rect.width + 100,
      height: rect.height + 20
    }
  }, seriesModel, cb);
  return rectEl;
}
var ThemeRiverView_default = ThemeRiverView;

// src/chart/themeRiver/ThemeRiverSeries.ts
var DATA_NAME_INDEX = 2;
var ThemeRiverSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = ThemeRiverSeriesModel2.type;
  }
  init(option) {
    super.init.apply(this, arguments);
    this.legendVisualProvider = new LegendVisualProvider_default(bind(this.getData, this), bind(this.getRawData, this));
  }
  fixData(data) {
    let rawDataLength = data.length;
    const timeValueKeys = {};
    const groupResult = groupData(data, (item) => {
      if (!timeValueKeys.hasOwnProperty(item[0] + "")) {
        timeValueKeys[item[0] + ""] = -1;
      }
      return item[2];
    });
    const layerData = [];
    groupResult.buckets.each(function(items, key) {
      layerData.push({
        name: key,
        dataList: items
      });
    });
    const layerNum = layerData.length;
    for (let k = 0; k < layerNum; ++k) {
      const name = layerData[k].name;
      for (let j = 0; j < layerData[k].dataList.length; ++j) {
        const timeValue = layerData[k].dataList[j][0] + "";
        timeValueKeys[timeValue] = k;
      }
      for (const timeValue in timeValueKeys) {
        if (timeValueKeys.hasOwnProperty(timeValue) && timeValueKeys[timeValue] !== k) {
          timeValueKeys[timeValue] = k;
          data[rawDataLength] = [timeValue, 0, name];
          rawDataLength++;
        }
      }
    }
    return data;
  }
  getInitialData(option, ecModel) {
    const singleAxisModel = this.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
    const axisType = singleAxisModel.get("type");
    const filterData = filter(option.data, function(dataItem) {
      return dataItem[2] !== void 0;
    });
    const data = this.fixData(filterData || []);
    const nameList = [];
    const nameMap = this.nameMap = createHashMap();
    let count2 = 0;
    for (let i = 0; i < data.length; ++i) {
      nameList.push(data[i][DATA_NAME_INDEX]);
      if (!nameMap.get(data[i][DATA_NAME_INDEX])) {
        nameMap.set(data[i][DATA_NAME_INDEX], count2);
        count2++;
      }
    }
    const {dimensions} = prepareSeriesDataSchema(data, {
      coordDimensions: ["single"],
      dimensionsDefine: [
        {
          name: "time",
          type: getDimensionTypeByAxis(axisType)
        },
        {
          name: "value",
          type: "float"
        },
        {
          name: "name",
          type: "ordinal"
        }
      ],
      encodeDefine: {
        single: 0,
        value: 1,
        itemName: 2
      }
    });
    const list = new SeriesData_default(dimensions, this);
    list.initData(data);
    return list;
  }
  getLayerSeries() {
    const data = this.getData();
    const lenCount = data.count();
    const indexArr = [];
    for (let i = 0; i < lenCount; ++i) {
      indexArr[i] = i;
    }
    const timeDim = data.mapDimension("single");
    const groupResult = groupData(indexArr, function(index) {
      return data.get("name", index);
    });
    const layerSeries = [];
    groupResult.buckets.each(function(items, key) {
      items.sort(function(index1, index2) {
        return data.get(timeDim, index1) - data.get(timeDim, index2);
      });
      layerSeries.push({
        name: key,
        indices: items
      });
    });
    return layerSeries;
  }
  getAxisTooltipData(dim, value, baseAxis) {
    if (!isArray(dim)) {
      dim = dim ? [dim] : [];
    }
    const data = this.getData();
    const layerSeries = this.getLayerSeries();
    const indices = [];
    const layerNum = layerSeries.length;
    let nestestValue;
    for (let i = 0; i < layerNum; ++i) {
      let minDist = Number.MAX_VALUE;
      let nearestIdx = -1;
      const pointNum = layerSeries[i].indices.length;
      for (let j = 0; j < pointNum; ++j) {
        const theValue = data.get(dim[0], layerSeries[i].indices[j]);
        const dist3 = Math.abs(theValue - value);
        if (dist3 <= minDist) {
          nestestValue = theValue;
          minDist = dist3;
          nearestIdx = layerSeries[i].indices[j];
        }
      }
      indices.push(nearestIdx);
    }
    return {dataIndices: indices, nestestValue};
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    const data = this.getData();
    const name = data.getName(dataIndex);
    const value = data.get(data.mapDimension("value"), dataIndex);
    return createTooltipMarkup("nameValue", {name, value});
  }
};
var ThemeRiverSeriesModel = ThemeRiverSeriesModel2;
ThemeRiverSeriesModel.type = "series.themeRiver";
ThemeRiverSeriesModel.dependencies = ["singleAxis"];
ThemeRiverSeriesModel.defaultOption = {
  z: 2,
  colorBy: "data",
  coordinateSystem: "singleAxis",
  boundaryGap: ["10%", "10%"],
  singleAxisIndex: 0,
  animationEasing: "linear",
  label: {
    margin: 4,
    show: true,
    position: "left",
    fontSize: 11
  },
  emphasis: {
    label: {
      show: true
    }
  }
};
var ThemeRiverSeries_default = ThemeRiverSeriesModel;

// src/chart/themeRiver/themeRiverLayout.ts
function themeRiverLayout(ecModel, api2) {
  ecModel.eachSeriesByType("themeRiver", function(seriesModel) {
    const data = seriesModel.getData();
    const single = seriesModel.coordinateSystem;
    const layoutInfo = {};
    const rect = single.getRect();
    layoutInfo.rect = rect;
    const boundaryGap = seriesModel.get("boundaryGap");
    const axis = single.getAxis();
    layoutInfo.boundaryGap = boundaryGap;
    if (axis.orient === "horizontal") {
      boundaryGap[0] = parsePercent2(boundaryGap[0], rect.height);
      boundaryGap[1] = parsePercent2(boundaryGap[1], rect.height);
      const height = rect.height - boundaryGap[0] - boundaryGap[1];
      doThemeRiverLayout(data, seriesModel, height);
    } else {
      boundaryGap[0] = parsePercent2(boundaryGap[0], rect.width);
      boundaryGap[1] = parsePercent2(boundaryGap[1], rect.width);
      const width = rect.width - boundaryGap[0] - boundaryGap[1];
      doThemeRiverLayout(data, seriesModel, width);
    }
    data.setLayout("layoutInfo", layoutInfo);
  });
}
function doThemeRiverLayout(data, seriesModel, height) {
  if (!data.count()) {
    return;
  }
  const coordSys = seriesModel.coordinateSystem;
  const layerSeries = seriesModel.getLayerSeries();
  const timeDim = data.mapDimension("single");
  const valueDim = data.mapDimension("value");
  const layerPoints = map(layerSeries, function(singleLayer) {
    return map(singleLayer.indices, function(idx) {
      const pt = coordSys.dataToPoint(data.get(timeDim, idx));
      pt[1] = data.get(valueDim, idx);
      return pt;
    });
  });
  const base2 = computeBaseline(layerPoints);
  const baseLine = base2.y0;
  const ky = height / base2.max;
  const n = layerSeries.length;
  const m2 = layerSeries[0].indices.length;
  let baseY0;
  for (let j = 0; j < m2; ++j) {
    baseY0 = baseLine[j] * ky;
    data.setItemLayout(layerSeries[0].indices[j], {
      layerIndex: 0,
      x: layerPoints[0][j][0],
      y0: baseY0,
      y: layerPoints[0][j][1] * ky
    });
    for (let i = 1; i < n; ++i) {
      baseY0 += layerPoints[i - 1][j][1] * ky;
      data.setItemLayout(layerSeries[i].indices[j], {
        layerIndex: i,
        x: layerPoints[i][j][0],
        y0: baseY0,
        y: layerPoints[i][j][1] * ky
      });
    }
  }
}
function computeBaseline(data) {
  const layerNum = data.length;
  const pointNum = data[0].length;
  const sums = [];
  const y0 = [];
  let max3 = 0;
  for (let i = 0; i < pointNum; ++i) {
    let temp = 0;
    for (let j = 0; j < layerNum; ++j) {
      temp += data[j][i][1];
    }
    if (temp > max3) {
      max3 = temp;
    }
    sums.push(temp);
  }
  for (let k = 0; k < pointNum; ++k) {
    y0[k] = (max3 - sums[k]) / 2;
  }
  max3 = 0;
  for (let l = 0; l < pointNum; ++l) {
    const sum2 = sums[l] + y0[l];
    if (sum2 > max3) {
      max3 = sum2;
    }
  }
  return {
    y0,
    max: max3
  };
}

// src/chart/themeRiver/install.ts
function install26(registers) {
  registers.registerChartView(ThemeRiverView_default);
  registers.registerSeriesModel(ThemeRiverSeries_default);
  registers.registerLayout(themeRiverLayout);
  registers.registerProcessor(dataFilter("themeRiver"));
}

// src/chart/sunburst/SunburstPiece.ts
var DEFAULT_SECTOR_Z = 2;
var DEFAULT_TEXT_Z = 4;
var SunburstPiece = class extends Sector_default {
  constructor(node, seriesModel, ecModel, api2) {
    super();
    this.z2 = DEFAULT_SECTOR_Z;
    this.textConfig = {
      inside: true
    };
    getECData(this).seriesIndex = seriesModel.seriesIndex;
    const text = new Text_default({
      z2: DEFAULT_TEXT_Z,
      silent: node.getModel().get(["label", "silent"])
    });
    this.setTextContent(text);
    this.updateData(true, node, seriesModel, ecModel, api2);
  }
  updateData(firstCreate, node, seriesModel, ecModel, api2) {
    this.node = node;
    node.piece = this;
    seriesModel = seriesModel || this._seriesModel;
    ecModel = ecModel || this._ecModel;
    const sector = this;
    getECData(sector).dataIndex = node.dataIndex;
    const itemModel = node.getModel();
    const emphasisModel = itemModel.getModel("emphasis");
    const layout18 = node.getLayout();
    const sectorShape = extend({}, layout18);
    sectorShape.label = null;
    const normalStyle = node.getVisual("style");
    normalStyle.lineJoin = "bevel";
    const decal = node.getVisual("decal");
    if (decal) {
      normalStyle.decal = createOrUpdatePatternFromDecal(decal, api2);
    }
    const cornerRadius = getSectorCornerRadius(itemModel.getModel("itemStyle"), sectorShape, true);
    extend(sectorShape, cornerRadius);
    each(SPECIAL_STATES, function(stateName) {
      const state = sector.ensureState(stateName);
      const itemStyleModel = itemModel.getModel([stateName, "itemStyle"]);
      state.style = itemStyleModel.getItemStyle();
      const cornerRadius2 = getSectorCornerRadius(itemStyleModel, sectorShape);
      if (cornerRadius2) {
        state.shape = cornerRadius2;
      }
    });
    if (firstCreate) {
      sector.setShape(sectorShape);
      sector.shape.r = layout18.r0;
      initProps(sector, {
        shape: {
          r: layout18.r
        }
      }, seriesModel, node.dataIndex);
    } else {
      updateProps(sector, {
        shape: sectorShape
      }, seriesModel);
      saveOldStyle(sector);
    }
    sector.useStyle(normalStyle);
    this._updateLabel(seriesModel);
    const cursorStyle = itemModel.getShallow("cursor");
    cursorStyle && sector.attr("cursor", cursorStyle);
    this._seriesModel = seriesModel || this._seriesModel;
    this._ecModel = ecModel || this._ecModel;
    const focus = emphasisModel.get("focus");
    const focusOrIndices = focus === "ancestor" ? node.getAncestorsIndices() : focus === "descendant" ? node.getDescendantIndices() : focus;
    toggleHoverEmphasis(this, focusOrIndices, emphasisModel.get("blurScope"), emphasisModel.get("disabled"));
  }
  _updateLabel(seriesModel) {
    const itemModel = this.node.getModel();
    const normalLabelModel = itemModel.getModel("label");
    const layout18 = this.node.getLayout();
    const angle = layout18.endAngle - layout18.startAngle;
    const midAngle = (layout18.startAngle + layout18.endAngle) / 2;
    const dx = Math.cos(midAngle);
    const dy = Math.sin(midAngle);
    const sector = this;
    const label = sector.getTextContent();
    const dataIndex = this.node.dataIndex;
    const labelMinAngle = normalLabelModel.get("minAngle") / 180 * Math.PI;
    const isNormalShown = normalLabelModel.get("show") && !(labelMinAngle != null && Math.abs(angle) < labelMinAngle);
    label.ignore = !isNormalShown;
    each(DISPLAY_STATES, (stateName) => {
      const labelStateModel = stateName === "normal" ? itemModel.getModel("label") : itemModel.getModel([stateName, "label"]);
      const isNormal = stateName === "normal";
      const state = isNormal ? label : label.ensureState(stateName);
      let text = seriesModel.getFormattedLabel(dataIndex, stateName);
      if (isNormal) {
        text = text || this.node.name;
      }
      state.style = createTextStyle(labelStateModel, {}, null, stateName !== "normal", true);
      if (text) {
        state.style.text = text;
      }
      const isShown = labelStateModel.get("show");
      if (isShown != null && !isNormal) {
        state.ignore = !isShown;
      }
      const labelPosition = getLabelAttr(labelStateModel, "position");
      const sectorState = isNormal ? sector : sector.states[stateName];
      const labelColor = sectorState.style.fill;
      sectorState.textConfig = {
        outsideFill: labelStateModel.get("color") === "inherit" ? labelColor : null,
        inside: labelPosition !== "outside"
      };
      let r;
      const labelPadding = getLabelAttr(labelStateModel, "distance") || 0;
      let textAlign = getLabelAttr(labelStateModel, "align");
      const rotateType = getLabelAttr(labelStateModel, "rotate");
      const flipStartAngle = Math.PI * 0.5;
      const flipEndAngle = Math.PI * 1.5;
      const midAngleNormal = normalizeRadian(rotateType === "tangential" ? Math.PI / 2 - midAngle : midAngle);
      const needsFlip = midAngleNormal > flipStartAngle && !isRadianAroundZero(midAngleNormal - flipStartAngle) && midAngleNormal < flipEndAngle;
      if (labelPosition === "outside") {
        r = layout18.r + labelPadding;
        textAlign = needsFlip ? "right" : "left";
      } else {
        if (!textAlign || textAlign === "center") {
          if (angle === 2 * Math.PI && layout18.r0 === 0) {
            r = 0;
          } else {
            r = (layout18.r + layout18.r0) / 2;
          }
          textAlign = "center";
        } else if (textAlign === "left") {
          r = layout18.r0 + labelPadding;
          textAlign = needsFlip ? "right" : "left";
        } else if (textAlign === "right") {
          r = layout18.r - labelPadding;
          textAlign = needsFlip ? "left" : "right";
        }
      }
      state.style.align = textAlign;
      state.style.verticalAlign = getLabelAttr(labelStateModel, "verticalAlign") || "middle";
      state.x = r * dx + layout18.cx;
      state.y = r * dy + layout18.cy;
      let rotate2 = 0;
      if (rotateType === "radial") {
        rotate2 = normalizeRadian(-midAngle) + (needsFlip ? Math.PI : 0);
      } else if (rotateType === "tangential") {
        rotate2 = normalizeRadian(Math.PI / 2 - midAngle) + (needsFlip ? Math.PI : 0);
      } else if (isNumber(rotateType)) {
        rotate2 = rotateType * Math.PI / 180;
      }
      state.rotation = normalizeRadian(rotate2);
    });
    function getLabelAttr(model, name) {
      const stateAttr = model.get(name);
      if (stateAttr == null) {
        return normalLabelModel.get(name);
      }
      return stateAttr;
    }
    label.dirtyStyle();
  }
};
var SunburstPiece_default = SunburstPiece;

// src/chart/sunburst/sunburstAction.ts
var ROOT_TO_NODE_ACTION = "sunburstRootToNode";
var HIGHLIGHT_ACTION = "sunburstHighlight";
var UNHIGHLIGHT_ACTION = "sunburstUnhighlight";
function installSunburstAction(registers) {
  registers.registerAction({type: ROOT_TO_NODE_ACTION, update: "updateView"}, function(payload, ecModel) {
    ecModel.eachComponent({mainType: "series", subType: "sunburst", query: payload}, handleRootToNode);
    function handleRootToNode(model, index) {
      const targetInfo = retrieveTargetInfo(payload, [ROOT_TO_NODE_ACTION], model);
      if (targetInfo) {
        const originViewRoot = model.getViewRoot();
        if (originViewRoot) {
          payload.direction = aboveViewRoot(originViewRoot, targetInfo.node) ? "rollUp" : "drillDown";
        }
        model.resetViewRoot(targetInfo.node);
      }
    }
  });
  registers.registerAction({type: HIGHLIGHT_ACTION, update: "none"}, function(payload, ecModel, api2) {
    payload = extend({}, payload);
    ecModel.eachComponent({mainType: "series", subType: "sunburst", query: payload}, handleHighlight);
    function handleHighlight(model) {
      const targetInfo = retrieveTargetInfo(payload, [HIGHLIGHT_ACTION], model);
      if (targetInfo) {
        payload.dataIndex = targetInfo.node.dataIndex;
      }
    }
    if (true) {
      deprecateReplaceLog("sunburstHighlight", "highlight");
    }
    api2.dispatchAction(extend(payload, {
      type: "highlight"
    }));
  });
  registers.registerAction({type: UNHIGHLIGHT_ACTION, update: "updateView"}, function(payload, ecModel, api2) {
    payload = extend({}, payload);
    if (true) {
      deprecateReplaceLog("sunburstUnhighlight", "downplay");
    }
    api2.dispatchAction(extend(payload, {
      type: "downplay"
    }));
  });
}

// src/chart/sunburst/SunburstView.ts
var SunburstView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = SunburstView2.type;
  }
  render(seriesModel, ecModel, api2, payload) {
    const self2 = this;
    this.seriesModel = seriesModel;
    this.api = api2;
    this.ecModel = ecModel;
    const data = seriesModel.getData();
    const virtualRoot = data.tree.root;
    const newRoot = seriesModel.getViewRoot();
    const group = this.group;
    const renderLabelForZeroData = seriesModel.get("renderLabelForZeroData");
    const newChildren = [];
    newRoot.eachNode(function(node) {
      newChildren.push(node);
    });
    const oldChildren = this._oldChildren || [];
    dualTravel(newChildren, oldChildren);
    renderRollUp(virtualRoot, newRoot);
    this._initEvents();
    this._oldChildren = newChildren;
    function dualTravel(newChildren2, oldChildren2) {
      if (newChildren2.length === 0 && oldChildren2.length === 0) {
        return;
      }
      new DataDiffer_default(oldChildren2, newChildren2, getKey2, getKey2).add(processNode).update(processNode).remove(curry(processNode, null)).execute();
      function getKey2(node) {
        return node.getId();
      }
      function processNode(newIdx, oldIdx) {
        const newNode = newIdx == null ? null : newChildren2[newIdx];
        const oldNode = oldIdx == null ? null : oldChildren2[oldIdx];
        doRenderNode(newNode, oldNode);
      }
    }
    function doRenderNode(newNode, oldNode) {
      if (!renderLabelForZeroData && newNode && !newNode.getValue()) {
        newNode = null;
      }
      if (newNode !== virtualRoot && oldNode !== virtualRoot) {
        if (oldNode && oldNode.piece) {
          if (newNode) {
            oldNode.piece.updateData(false, newNode, seriesModel, ecModel, api2);
            data.setItemGraphicEl(newNode.dataIndex, oldNode.piece);
          } else {
            removeNode2(oldNode);
          }
        } else if (newNode) {
          const piece = new SunburstPiece_default(newNode, seriesModel, ecModel, api2);
          group.add(piece);
          data.setItemGraphicEl(newNode.dataIndex, piece);
        }
      }
    }
    function removeNode2(node) {
      if (!node) {
        return;
      }
      if (node.piece) {
        group.remove(node.piece);
        node.piece = null;
      }
    }
    function renderRollUp(virtualRoot2, viewRoot) {
      if (viewRoot.depth > 0) {
        if (self2.virtualPiece) {
          self2.virtualPiece.updateData(false, virtualRoot2, seriesModel, ecModel, api2);
        } else {
          self2.virtualPiece = new SunburstPiece_default(virtualRoot2, seriesModel, ecModel, api2);
          group.add(self2.virtualPiece);
        }
        viewRoot.piece.off("click");
        self2.virtualPiece.on("click", function(e2) {
          self2._rootToNode(viewRoot.parentNode);
        });
      } else if (self2.virtualPiece) {
        group.remove(self2.virtualPiece);
        self2.virtualPiece = null;
      }
    }
  }
  _initEvents() {
    this.group.off("click");
    this.group.on("click", (e2) => {
      let targetFound = false;
      const viewRoot = this.seriesModel.getViewRoot();
      viewRoot.eachNode((node) => {
        if (!targetFound && node.piece && node.piece === e2.target) {
          const nodeClick = node.getModel().get("nodeClick");
          if (nodeClick === "rootToNode") {
            this._rootToNode(node);
          } else if (nodeClick === "link") {
            const itemModel = node.getModel();
            const link = itemModel.get("link");
            if (link) {
              const linkTarget = itemModel.get("target", true) || "_blank";
              windowOpen(link, linkTarget);
            }
          }
          targetFound = true;
        }
      });
    });
  }
  _rootToNode(node) {
    if (node !== this.seriesModel.getViewRoot()) {
      this.api.dispatchAction({
        type: ROOT_TO_NODE_ACTION,
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: node
      });
    }
  }
  containPoint(point, seriesModel) {
    const treeRoot = seriesModel.getData();
    const itemLayout = treeRoot.getItemLayout(0);
    if (itemLayout) {
      const dx = point[0] - itemLayout.cx;
      const dy = point[1] - itemLayout.cy;
      const radius = Math.sqrt(dx * dx + dy * dy);
      return radius <= itemLayout.r && radius >= itemLayout.r0;
    }
  }
};
var SunburstView = SunburstView2;
SunburstView.type = "sunburst";
var SunburstView_default = SunburstView;

// src/chart/sunburst/SunburstSeries.ts
var SunburstSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = SunburstSeriesModel2.type;
    this.ignoreStyleOnData = true;
  }
  getInitialData(option, ecModel) {
    const root = {name: option.name, children: option.data};
    completeTreeValue2(root);
    const levelModels = this._levelModels = map(option.levels || [], function(levelDefine) {
      return new Model_default(levelDefine, this, ecModel);
    }, this);
    const tree = Tree_default.createTree(root, this, beforeLink);
    function beforeLink(nodeData) {
      nodeData.wrapMethod("getItemModel", function(model, idx) {
        const node = tree.getNodeByDataIndex(idx);
        const levelModel = levelModels[node.depth];
        levelModel && (model.parentModel = levelModel);
        return model;
      });
    }
    return tree.data;
  }
  optionUpdated() {
    this.resetViewRoot();
  }
  getDataParams(dataIndex) {
    const params = super.getDataParams.apply(this, arguments);
    const node = this.getData().tree.getNodeByDataIndex(dataIndex);
    params.treePathInfo = wrapTreePathInfo(node, this);
    return params;
  }
  getLevelModel(node) {
    return this._levelModels && this._levelModels[node.depth];
  }
  getViewRoot() {
    return this._viewRoot;
  }
  resetViewRoot(viewRoot) {
    viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
    const root = this.getRawData().tree.root;
    if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {
      this._viewRoot = root;
    }
  }
  enableAriaDecal() {
    enableAriaDecalForTree(this);
  }
};
var SunburstSeriesModel = SunburstSeriesModel2;
SunburstSeriesModel.type = "series.sunburst";
SunburstSeriesModel.defaultOption = {
  z: 2,
  center: ["50%", "50%"],
  radius: [0, "75%"],
  clockwise: true,
  startAngle: 90,
  minAngle: 0,
  stillShowZeroSum: true,
  nodeClick: "rootToNode",
  renderLabelForZeroData: false,
  label: {
    rotate: "radial",
    show: true,
    opacity: 1,
    align: "center",
    position: "inside",
    distance: 5,
    silent: true
  },
  itemStyle: {
    borderWidth: 1,
    borderColor: "white",
    borderType: "solid",
    shadowBlur: 0,
    shadowColor: "rgba(0, 0, 0, 0.2)",
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    opacity: 1
  },
  emphasis: {
    focus: "descendant"
  },
  blur: {
    itemStyle: {
      opacity: 0.2
    },
    label: {
      opacity: 0.1
    }
  },
  animationType: "expansion",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  data: [],
  sort: "desc"
};
function completeTreeValue2(dataNode) {
  let sum2 = 0;
  each(dataNode.children, function(child) {
    completeTreeValue2(child);
    let childValue = child.value;
    isArray(childValue) && (childValue = childValue[0]);
    sum2 += childValue;
  });
  let thisValue = dataNode.value;
  if (isArray(thisValue)) {
    thisValue = thisValue[0];
  }
  if (thisValue == null || isNaN(thisValue)) {
    thisValue = sum2;
  }
  if (thisValue < 0) {
    thisValue = 0;
  }
  isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
}
var SunburstSeries_default = SunburstSeriesModel;

// src/chart/sunburst/sunburstLayout.ts
var RADIAN3 = Math.PI / 180;
function sunburstLayout(seriesType2, ecModel, api2) {
  ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
    let center3 = seriesModel.get("center");
    let radius = seriesModel.get("radius");
    if (!isArray(radius)) {
      radius = [0, radius];
    }
    if (!isArray(center3)) {
      center3 = [center3, center3];
    }
    const width = api2.getWidth();
    const height = api2.getHeight();
    const size = Math.min(width, height);
    const cx = parsePercent2(center3[0], width);
    const cy = parsePercent2(center3[1], height);
    const r0 = parsePercent2(radius[0], size / 2);
    const r = parsePercent2(radius[1], size / 2);
    const startAngle = -seriesModel.get("startAngle") * RADIAN3;
    const minAngle = seriesModel.get("minAngle") * RADIAN3;
    const virtualRoot = seriesModel.getData().tree.root;
    const treeRoot = seriesModel.getViewRoot();
    const rootDepth = treeRoot.depth;
    const sort4 = seriesModel.get("sort");
    if (sort4 != null) {
      initChildren2(treeRoot, sort4);
    }
    let validDataCount = 0;
    each(treeRoot.children, function(child) {
      !isNaN(child.getValue()) && validDataCount++;
    });
    const sum2 = treeRoot.getValue();
    const unitRadian = Math.PI / (sum2 || validDataCount) * 2;
    const renderRollupNode = treeRoot.depth > 0;
    const levels = treeRoot.height - (renderRollupNode ? -1 : 1);
    const rPerLevel = (r - r0) / (levels || 1);
    const clockwise = seriesModel.get("clockwise");
    const stillShowZeroSum = seriesModel.get("stillShowZeroSum");
    const dir3 = clockwise ? 1 : -1;
    const renderNode2 = function(node, startAngle2) {
      if (!node) {
        return;
      }
      let endAngle = startAngle2;
      if (node !== virtualRoot) {
        const value = node.getValue();
        let angle = sum2 === 0 && stillShowZeroSum ? unitRadian : value * unitRadian;
        if (angle < minAngle) {
          angle = minAngle;
        }
        endAngle = startAngle2 + dir3 * angle;
        const depth = node.depth - rootDepth - (renderRollupNode ? -1 : 1);
        let rStart = r0 + rPerLevel * depth;
        let rEnd = r0 + rPerLevel * (depth + 1);
        const levelModel = seriesModel.getLevelModel(node);
        if (levelModel) {
          let r02 = levelModel.get("r0", true);
          let r2 = levelModel.get("r", true);
          const radius2 = levelModel.get("radius", true);
          if (radius2 != null) {
            r02 = radius2[0];
            r2 = radius2[1];
          }
          r02 != null && (rStart = parsePercent2(r02, size / 2));
          r2 != null && (rEnd = parsePercent2(r2, size / 2));
        }
        node.setLayout({
          angle,
          startAngle: startAngle2,
          endAngle,
          clockwise,
          cx,
          cy,
          r0: rStart,
          r: rEnd
        });
      }
      if (node.children && node.children.length) {
        let siblingAngle = 0;
        each(node.children, function(node2) {
          siblingAngle += renderNode2(node2, startAngle2 + siblingAngle);
        });
      }
      return endAngle - startAngle2;
    };
    if (renderRollupNode) {
      const rStart = r0;
      const rEnd = r0 + rPerLevel;
      const angle = Math.PI * 2;
      virtualRoot.setLayout({
        angle,
        startAngle,
        endAngle: startAngle + angle,
        clockwise,
        cx,
        cy,
        r0: rStart,
        r: rEnd
      });
    }
    renderNode2(treeRoot, startAngle);
  });
}
function initChildren2(node, sortOrder) {
  const children = node.children || [];
  node.children = sort3(children, sortOrder);
  if (children.length) {
    each(node.children, function(child) {
      initChildren2(child, sortOrder);
    });
  }
}
function sort3(children, sortOrder) {
  if (isFunction(sortOrder)) {
    const sortTargets = map(children, (child, idx) => {
      const value = child.getValue();
      return {
        params: {
          depth: child.depth,
          height: child.height,
          dataIndex: child.dataIndex,
          getValue: () => value
        },
        index: idx
      };
    });
    sortTargets.sort((a, b) => {
      return sortOrder(a.params, b.params);
    });
    return map(sortTargets, (target) => {
      return children[target.index];
    });
  } else {
    const isAsc = sortOrder === "asc";
    return children.sort(function(a, b) {
      const diff = (a.getValue() - b.getValue()) * (isAsc ? 1 : -1);
      return diff === 0 ? (a.dataIndex - b.dataIndex) * (isAsc ? -1 : 1) : diff;
    });
  }
}

// src/chart/sunburst/sunburstVisual.ts
function sunburstVisual(ecModel) {
  const paletteScope = {};
  function pickColor(node, seriesModel, treeHeight) {
    let current = node;
    while (current && current.depth > 1) {
      current = current.parentNode;
    }
    let color2 = seriesModel.getColorFromPalette(current.name || current.dataIndex + "", paletteScope);
    if (node.depth > 1 && isString(color2)) {
      color2 = lift(color2, (node.depth - 1) / (treeHeight - 1) * 0.5);
    }
    return color2;
  }
  ecModel.eachSeriesByType("sunburst", function(seriesModel) {
    const data = seriesModel.getData();
    const tree = data.tree;
    tree.eachNode(function(node) {
      const model = node.getModel();
      const style = model.getModel("itemStyle").getItemStyle();
      if (!style.fill) {
        style.fill = pickColor(node, seriesModel, tree.root.height);
      }
      const existsStyle = data.ensureUniqueItemVisual(node.dataIndex, "style");
      extend(existsStyle, style);
    });
  });
}

// src/chart/sunburst/install.ts
function install27(registers) {
  registers.registerChartView(SunburstView_default);
  registers.registerSeriesModel(SunburstSeries_default);
  registers.registerLayout(curry(sunburstLayout, "sunburst"));
  registers.registerProcessor(curry(dataFilter, "sunburst"));
  registers.registerVisual(sunburstVisual);
  installSunburstAction(registers);
}

// src/chart/custom/CustomSeries.ts
var STYLE_VISUAL_TYPE = {
  color: "fill",
  borderColor: "stroke"
};
var NON_STYLE_VISUAL_PROPS = {
  symbol: 1,
  symbolSize: 1,
  symbolKeepAspect: 1,
  legendIcon: 1,
  visualMeta: 1,
  liftZ: 1,
  decal: 1
};
var customInnerStore = makeInner();
var CustomSeriesModel2 = class extends Series_default {
  constructor() {
    super(...arguments);
    this.type = CustomSeriesModel2.type;
  }
  optionUpdated() {
    this.currentZLevel = this.get("zlevel", true);
    this.currentZ = this.get("z", true);
  }
  getInitialData(option, ecModel) {
    return createSeriesData_default(null, this);
  }
  getDataParams(dataIndex, dataType, el) {
    const params = super.getDataParams(dataIndex, dataType);
    el && (params.info = customInnerStore(el).info);
    return params;
  }
};
var CustomSeriesModel = CustomSeriesModel2;
CustomSeriesModel.type = "series.custom";
CustomSeriesModel.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"];
CustomSeriesModel.defaultOption = {
  coordinateSystem: "cartesian2d",
  z: 2,
  legendHoverLink: true,
  clip: false
};
var CustomSeries_default = CustomSeriesModel;

// src/coord/cartesian/prepareCustom.ts
function dataToCoordSize(dataSize, dataItem) {
  dataItem = dataItem || [0, 0];
  return map(["x", "y"], function(dim, dimIdx) {
    const axis = this.getAxis(dim);
    const val = dataItem[dimIdx];
    const halfSize = dataSize[dimIdx] / 2;
    return axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
  }, this);
}
function cartesianPrepareCustom(coordSys) {
  const rect = coordSys.master.getRect();
  return {
    coordSys: {
      type: "cartesian2d",
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    api: {
      coord: function(data) {
        return coordSys.dataToPoint(data);
      },
      size: bind(dataToCoordSize, coordSys)
    }
  };
}

// src/coord/geo/prepareCustom.ts
function dataToCoordSize2(dataSize, dataItem) {
  dataItem = dataItem || [0, 0];
  return map([0, 1], function(dimIdx) {
    const val = dataItem[dimIdx];
    const halfSize = dataSize[dimIdx] / 2;
    const p1 = [];
    const p2 = [];
    p1[dimIdx] = val - halfSize;
    p2[dimIdx] = val + halfSize;
    p1[1 - dimIdx] = p2[1 - dimIdx] = dataItem[1 - dimIdx];
    return Math.abs(this.dataToPoint(p1)[dimIdx] - this.dataToPoint(p2)[dimIdx]);
  }, this);
}
function geoPrepareCustom(coordSys) {
  const rect = coordSys.getBoundingRect();
  return {
    coordSys: {
      type: "geo",
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height,
      zoom: coordSys.getZoom()
    },
    api: {
      coord: function(data) {
        return coordSys.dataToPoint(data);
      },
      size: bind(dataToCoordSize2, coordSys)
    }
  };
}

// src/coord/single/prepareCustom.ts
function dataToCoordSize3(dataSize, dataItem) {
  const axis = this.getAxis();
  const val = dataItem instanceof Array ? dataItem[0] : dataItem;
  const halfSize = (dataSize instanceof Array ? dataSize[0] : dataSize) / 2;
  return axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
}
function singlePrepareCustom(coordSys) {
  const rect = coordSys.getRect();
  return {
    coordSys: {
      type: "singleAxis",
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    api: {
      coord: function(val) {
        return coordSys.dataToPoint(val);
      },
      size: bind(dataToCoordSize3, coordSys)
    }
  };
}

// src/coord/polar/prepareCustom.ts
function dataToCoordSize4(dataSize, dataItem) {
  dataItem = dataItem || [0, 0];
  return map(["Radius", "Angle"], function(dim, dimIdx) {
    const getterName = "get" + dim + "Axis";
    const axis = this[getterName]();
    const val = dataItem[dimIdx];
    const halfSize = dataSize[dimIdx] / 2;
    let result = axis.type === "category" ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize));
    if (dim === "Angle") {
      result = result * Math.PI / 180;
    }
    return result;
  }, this);
}
function polarPrepareCustom(coordSys) {
  const radiusAxis = coordSys.getRadiusAxis();
  const angleAxis = coordSys.getAngleAxis();
  const radius = radiusAxis.getExtent();
  radius[0] > radius[1] && radius.reverse();
  return {
    coordSys: {
      type: "polar",
      cx: coordSys.cx,
      cy: coordSys.cy,
      r: radius[1],
      r0: radius[0]
    },
    api: {
      coord: function(data) {
        const radius2 = radiusAxis.dataToRadius(data[0]);
        const angle = angleAxis.dataToAngle(data[1]);
        const coord = coordSys.coordToPoint([radius2, angle]);
        coord.push(radius2, angle * Math.PI / 180);
        return coord;
      },
      size: bind(dataToCoordSize4, coordSys)
    }
  };
}

// src/coord/calendar/prepareCustom.ts
function calendarPrepareCustom(coordSys) {
  const rect = coordSys.getRect();
  const rangeInfo = coordSys.getRangeInfo();
  return {
    coordSys: {
      type: "calendar",
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height,
      cellWidth: coordSys.getCellWidth(),
      cellHeight: coordSys.getCellHeight(),
      rangeInfo: {
        start: rangeInfo.start,
        end: rangeInfo.end,
        weeks: rangeInfo.weeks,
        dayCount: rangeInfo.allDay
      }
    },
    api: {
      coord: function(data, clamp2) {
        return coordSys.dataToPoint(data, clamp2);
      }
    }
  };
}

// src/util/styleCompat.ts
var deprecatedLogs = {};
function isEC4CompatibleStyle(style, elType, hasOwnTextContentOption, hasOwnTextConfig) {
  return style && (style.legacy || style.legacy !== false && !hasOwnTextContentOption && !hasOwnTextConfig && elType !== "tspan" && (elType === "text" || hasOwn(style, "text")));
}
function convertFromEC4CompatibleStyle(hostStyle, elType, isNormal) {
  const srcStyle = hostStyle;
  let textConfig;
  let textContent;
  let textContentStyle;
  if (elType === "text") {
    textContentStyle = srcStyle;
  } else {
    textContentStyle = {};
    hasOwn(srcStyle, "text") && (textContentStyle.text = srcStyle.text);
    hasOwn(srcStyle, "rich") && (textContentStyle.rich = srcStyle.rich);
    hasOwn(srcStyle, "textFill") && (textContentStyle.fill = srcStyle.textFill);
    hasOwn(srcStyle, "textStroke") && (textContentStyle.stroke = srcStyle.textStroke);
    hasOwn(srcStyle, "fontFamily") && (textContentStyle.fontFamily = srcStyle.fontFamily);
    hasOwn(srcStyle, "fontSize") && (textContentStyle.fontSize = srcStyle.fontSize);
    hasOwn(srcStyle, "fontStyle") && (textContentStyle.fontStyle = srcStyle.fontStyle);
    hasOwn(srcStyle, "fontWeight") && (textContentStyle.fontWeight = srcStyle.fontWeight);
    textContent = {
      type: "text",
      style: textContentStyle,
      silent: true
    };
    textConfig = {};
    const hasOwnPos = hasOwn(srcStyle, "textPosition");
    if (isNormal) {
      textConfig.position = hasOwnPos ? srcStyle.textPosition : "inside";
    } else {
      hasOwnPos && (textConfig.position = srcStyle.textPosition);
    }
    hasOwn(srcStyle, "textPosition") && (textConfig.position = srcStyle.textPosition);
    hasOwn(srcStyle, "textOffset") && (textConfig.offset = srcStyle.textOffset);
    hasOwn(srcStyle, "textRotation") && (textConfig.rotation = srcStyle.textRotation);
    hasOwn(srcStyle, "textDistance") && (textConfig.distance = srcStyle.textDistance);
  }
  convertEC4CompatibleRichItem(textContentStyle, hostStyle);
  each(textContentStyle.rich, function(richItem) {
    convertEC4CompatibleRichItem(richItem, richItem);
  });
  return {
    textConfig,
    textContent
  };
}
function convertEC4CompatibleRichItem(out2, richItem) {
  if (!richItem) {
    return;
  }
  richItem.font = richItem.textFont || richItem.font;
  hasOwn(richItem, "textStrokeWidth") && (out2.lineWidth = richItem.textStrokeWidth);
  hasOwn(richItem, "textAlign") && (out2.align = richItem.textAlign);
  hasOwn(richItem, "textVerticalAlign") && (out2.verticalAlign = richItem.textVerticalAlign);
  hasOwn(richItem, "textLineHeight") && (out2.lineHeight = richItem.textLineHeight);
  hasOwn(richItem, "textWidth") && (out2.width = richItem.textWidth);
  hasOwn(richItem, "textHeight") && (out2.height = richItem.textHeight);
  hasOwn(richItem, "textBackgroundColor") && (out2.backgroundColor = richItem.textBackgroundColor);
  hasOwn(richItem, "textPadding") && (out2.padding = richItem.textPadding);
  hasOwn(richItem, "textBorderColor") && (out2.borderColor = richItem.textBorderColor);
  hasOwn(richItem, "textBorderWidth") && (out2.borderWidth = richItem.textBorderWidth);
  hasOwn(richItem, "textBorderRadius") && (out2.borderRadius = richItem.textBorderRadius);
  hasOwn(richItem, "textBoxShadowColor") && (out2.shadowColor = richItem.textBoxShadowColor);
  hasOwn(richItem, "textBoxShadowBlur") && (out2.shadowBlur = richItem.textBoxShadowBlur);
  hasOwn(richItem, "textBoxShadowOffsetX") && (out2.shadowOffsetX = richItem.textBoxShadowOffsetX);
  hasOwn(richItem, "textBoxShadowOffsetY") && (out2.shadowOffsetY = richItem.textBoxShadowOffsetY);
}
function convertToEC4StyleForCustomSerise(itemStl, txStl, txCfg) {
  const out2 = itemStl;
  out2.textPosition = out2.textPosition || txCfg.position || "inside";
  txCfg.offset != null && (out2.textOffset = txCfg.offset);
  txCfg.rotation != null && (out2.textRotation = txCfg.rotation);
  txCfg.distance != null && (out2.textDistance = txCfg.distance);
  const isInside = out2.textPosition.indexOf("inside") >= 0;
  const hostFill = itemStl.fill || "#000";
  convertToEC4RichItem(out2, txStl);
  const textFillNotSet = out2.textFill == null;
  if (isInside) {
    if (textFillNotSet) {
      out2.textFill = txCfg.insideFill || "#fff";
      !out2.textStroke && txCfg.insideStroke && (out2.textStroke = txCfg.insideStroke);
      !out2.textStroke && (out2.textStroke = hostFill);
      out2.textStrokeWidth == null && (out2.textStrokeWidth = 2);
    }
  } else {
    if (textFillNotSet) {
      out2.textFill = itemStl.fill || txCfg.outsideFill || "#000";
    }
    !out2.textStroke && txCfg.outsideStroke && (out2.textStroke = txCfg.outsideStroke);
  }
  out2.text = txStl.text;
  out2.rich = txStl.rich;
  each(txStl.rich, function(richItem) {
    convertToEC4RichItem(richItem, richItem);
  });
  return out2;
}
function convertToEC4RichItem(out2, richItem) {
  if (!richItem) {
    return;
  }
  hasOwn(richItem, "fill") && (out2.textFill = richItem.fill);
  hasOwn(richItem, "stroke") && (out2.textStroke = richItem.fill);
  hasOwn(richItem, "lineWidth") && (out2.textStrokeWidth = richItem.lineWidth);
  hasOwn(richItem, "font") && (out2.font = richItem.font);
  hasOwn(richItem, "fontStyle") && (out2.fontStyle = richItem.fontStyle);
  hasOwn(richItem, "fontWeight") && (out2.fontWeight = richItem.fontWeight);
  hasOwn(richItem, "fontSize") && (out2.fontSize = richItem.fontSize);
  hasOwn(richItem, "fontFamily") && (out2.fontFamily = richItem.fontFamily);
  hasOwn(richItem, "align") && (out2.textAlign = richItem.align);
  hasOwn(richItem, "verticalAlign") && (out2.textVerticalAlign = richItem.verticalAlign);
  hasOwn(richItem, "lineHeight") && (out2.textLineHeight = richItem.lineHeight);
  hasOwn(richItem, "width") && (out2.textWidth = richItem.width);
  hasOwn(richItem, "height") && (out2.textHeight = richItem.height);
  hasOwn(richItem, "backgroundColor") && (out2.textBackgroundColor = richItem.backgroundColor);
  hasOwn(richItem, "padding") && (out2.textPadding = richItem.padding);
  hasOwn(richItem, "borderColor") && (out2.textBorderColor = richItem.borderColor);
  hasOwn(richItem, "borderWidth") && (out2.textBorderWidth = richItem.borderWidth);
  hasOwn(richItem, "borderRadius") && (out2.textBorderRadius = richItem.borderRadius);
  hasOwn(richItem, "shadowColor") && (out2.textBoxShadowColor = richItem.shadowColor);
  hasOwn(richItem, "shadowBlur") && (out2.textBoxShadowBlur = richItem.shadowBlur);
  hasOwn(richItem, "shadowOffsetX") && (out2.textBoxShadowOffsetX = richItem.shadowOffsetX);
  hasOwn(richItem, "shadowOffsetY") && (out2.textBoxShadowOffsetY = richItem.shadowOffsetY);
  hasOwn(richItem, "textShadowColor") && (out2.textShadowColor = richItem.textShadowColor);
  hasOwn(richItem, "textShadowBlur") && (out2.textShadowBlur = richItem.textShadowBlur);
  hasOwn(richItem, "textShadowOffsetX") && (out2.textShadowOffsetX = richItem.textShadowOffsetX);
  hasOwn(richItem, "textShadowOffsetY") && (out2.textShadowOffsetY = richItem.textShadowOffsetY);
}
function warnDeprecated(deprecated, insteadApproach) {
  if (true) {
    const key = deprecated + "^_^" + insteadApproach;
    if (!deprecatedLogs[key]) {
      console.warn(`[ECharts] DEPRECATED: "${deprecated}" has been deprecated. ${insteadApproach}`);
      deprecatedLogs[key] = true;
    }
  }
}

// src/animation/customGraphicTransition.ts
var LEGACY_TRANSFORM_PROPS_MAP = {
  position: ["x", "y"],
  scale: ["scaleX", "scaleY"],
  origin: ["originX", "originY"]
};
var LEGACY_TRANSFORM_PROPS = keys(LEGACY_TRANSFORM_PROPS_MAP);
var TRANSFORM_PROPS_MAP = reduce(TRANSFORMABLE_PROPS, (obj, key) => {
  obj[key] = 1;
  return obj;
}, {});
var transformPropNamesStr = TRANSFORMABLE_PROPS.join(", ");
var ELEMENT_ANIMATABLE_PROPS = ["", "style", "shape", "extra"];
var transitionInnerStore = makeInner();
function getElementAnimationConfig(animationType, el, elOption, parentModel, dataIndex) {
  const animationProp = `${animationType}Animation`;
  const config = getAnimationConfig(animationType, parentModel, dataIndex) || {};
  const userDuring = transitionInnerStore(el).userDuring;
  if (config.duration > 0) {
    config.during = userDuring ? bind(duringCall, {el, userDuring}) : null;
    config.setToFinal = true;
    config.scope = animationType;
  }
  extend(config, elOption[animationProp]);
  return config;
}
function applyUpdateTransition(el, elOption, animatableModel, opts) {
  opts = opts || {};
  const {dataIndex, isInit, clearStyle} = opts;
  const hasAnimation = animatableModel.isAnimationEnabled();
  const store = transitionInnerStore(el);
  const styleOpt = elOption.style;
  store.userDuring = elOption.during;
  const transFromProps = {};
  const propsToSet = {};
  prepareTransformAllPropsFinal(el, elOption, propsToSet);
  prepareShapeOrExtraAllPropsFinal("shape", elOption, propsToSet);
  prepareShapeOrExtraAllPropsFinal("extra", elOption, propsToSet);
  if (!isInit && hasAnimation) {
    prepareTransformTransitionFrom(el, elOption, transFromProps);
    prepareShapeOrExtraTransitionFrom("shape", el, elOption, transFromProps);
    prepareShapeOrExtraTransitionFrom("extra", el, elOption, transFromProps);
    prepareStyleTransitionFrom(el, elOption, styleOpt, transFromProps);
  }
  propsToSet.style = styleOpt;
  applyPropsDirectly(el, propsToSet, clearStyle);
  applyMiscProps(el, elOption);
  if (hasAnimation) {
    if (isInit) {
      const enterFromProps = {};
      each(ELEMENT_ANIMATABLE_PROPS, (propName) => {
        const prop = propName ? elOption[propName] : elOption;
        if (prop && prop.enterFrom) {
          if (propName) {
            enterFromProps[propName] = enterFromProps[propName] || {};
          }
          extend(propName ? enterFromProps[propName] : enterFromProps, prop.enterFrom);
        }
      });
      const config = getElementAnimationConfig("enter", el, elOption, animatableModel, dataIndex);
      if (config.duration > 0) {
        el.animateFrom(enterFromProps, config);
      }
    } else {
      applyPropsTransition(el, elOption, dataIndex || 0, animatableModel, transFromProps);
    }
  }
  updateLeaveTo(el, elOption);
  styleOpt ? el.dirty() : el.markRedraw();
}
function updateLeaveTo(el, elOption) {
  let leaveToProps = transitionInnerStore(el).leaveToProps;
  for (let i = 0; i < ELEMENT_ANIMATABLE_PROPS.length; i++) {
    const propName = ELEMENT_ANIMATABLE_PROPS[i];
    const prop = propName ? elOption[propName] : elOption;
    if (prop && prop.leaveTo) {
      if (!leaveToProps) {
        leaveToProps = transitionInnerStore(el).leaveToProps = {};
      }
      if (propName) {
        leaveToProps[propName] = leaveToProps[propName] || {};
      }
      extend(propName ? leaveToProps[propName] : leaveToProps, prop.leaveTo);
    }
  }
}
function applyLeaveTransition(el, elOption, animatableModel, onRemove) {
  if (el) {
    const parent = el.parent;
    const leaveToProps = transitionInnerStore(el).leaveToProps;
    if (leaveToProps) {
      const config = getElementAnimationConfig("update", el, elOption, animatableModel, 0);
      config.done = () => {
        parent.remove(el);
        onRemove && onRemove();
      };
      el.animateTo(leaveToProps, config);
    } else {
      parent.remove(el);
      onRemove && onRemove();
    }
  }
}
function isTransitionAll(transition) {
  return transition === "all";
}
function applyPropsDirectly(el, allPropsFinal, clearStyle) {
  const styleOpt = allPropsFinal.style;
  if (!el.isGroup && styleOpt) {
    if (clearStyle) {
      el.useStyle({});
      const animators = el.animators;
      for (let i = 0; i < animators.length; i++) {
        const animator = animators[i];
        if (animator.targetName === "style") {
          animator.changeTarget(el.style);
        }
      }
    }
    el.setStyle(styleOpt);
  }
  if (allPropsFinal) {
    allPropsFinal.style = null;
    allPropsFinal && el.attr(allPropsFinal);
    allPropsFinal.style = styleOpt;
  }
}
function applyPropsTransition(el, elOption, dataIndex, model, transFromProps) {
  if (transFromProps) {
    const config = getElementAnimationConfig("update", el, elOption, model, dataIndex);
    if (config.duration > 0) {
      el.animateFrom(transFromProps, config);
    }
  }
}
function applyMiscProps(el, elOption) {
  hasOwn(elOption, "silent") && (el.silent = elOption.silent);
  hasOwn(elOption, "ignore") && (el.ignore = elOption.ignore);
  if (el instanceof Displayable_default) {
    hasOwn(elOption, "invisible") && (el.invisible = elOption.invisible);
  }
  if (el instanceof Path_default) {
    hasOwn(elOption, "autoBatch") && (el.autoBatch = elOption.autoBatch);
  }
}
var tmpDuringScope = {};
var transitionDuringAPI = {
  setTransform(key, val) {
    if (true) {
      assert(hasOwn(TRANSFORM_PROPS_MAP, key), "Only " + transformPropNamesStr + " available in `setTransform`.");
    }
    tmpDuringScope.el[key] = val;
    return this;
  },
  getTransform(key) {
    if (true) {
      assert(hasOwn(TRANSFORM_PROPS_MAP, key), "Only " + transformPropNamesStr + " available in `getTransform`.");
    }
    return tmpDuringScope.el[key];
  },
  setShape(key, val) {
    if (true) {
      assertNotReserved(key);
    }
    const el = tmpDuringScope.el;
    const shape = el.shape || (el.shape = {});
    shape[key] = val;
    el.dirtyShape && el.dirtyShape();
    return this;
  },
  getShape(key) {
    if (true) {
      assertNotReserved(key);
    }
    const shape = tmpDuringScope.el.shape;
    if (shape) {
      return shape[key];
    }
  },
  setStyle(key, val) {
    if (true) {
      assertNotReserved(key);
    }
    const el = tmpDuringScope.el;
    const style = el.style;
    if (style) {
      if (true) {
        if (eqNaN(val)) {
          warn("style." + key + " must not be assigned with NaN.");
        }
      }
      style[key] = val;
      el.dirtyStyle && el.dirtyStyle();
    }
    return this;
  },
  getStyle(key) {
    if (true) {
      assertNotReserved(key);
    }
    const style = tmpDuringScope.el.style;
    if (style) {
      return style[key];
    }
  },
  setExtra(key, val) {
    if (true) {
      assertNotReserved(key);
    }
    const extra = tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {});
    extra[key] = val;
    return this;
  },
  getExtra(key) {
    if (true) {
      assertNotReserved(key);
    }
    const extra = tmpDuringScope.el.extra;
    if (extra) {
      return extra[key];
    }
  }
};
function assertNotReserved(key) {
  if (true) {
    if (key === "transition" || key === "enterFrom" || key === "leaveTo") {
      throw new Error('key must not be "' + key + '"');
    }
  }
}
function duringCall() {
  const scope = this;
  const el = scope.el;
  if (!el) {
    return;
  }
  const latestUserDuring = transitionInnerStore(el).userDuring;
  const scopeUserDuring = scope.userDuring;
  if (latestUserDuring !== scopeUserDuring) {
    scope.el = scope.userDuring = null;
    return;
  }
  tmpDuringScope.el = el;
  scopeUserDuring(transitionDuringAPI);
}
function prepareShapeOrExtraTransitionFrom(mainAttr, fromEl, elOption, transFromProps) {
  const attrOpt = elOption[mainAttr];
  if (!attrOpt) {
    return;
  }
  const elPropsInAttr = fromEl[mainAttr];
  let transFromPropsInAttr;
  if (elPropsInAttr) {
    const transition = elOption.transition;
    const attrTransition = attrOpt.transition;
    if (attrTransition) {
      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});
      if (isTransitionAll(attrTransition)) {
        extend(transFromPropsInAttr, elPropsInAttr);
      } else {
        const transitionKeys = normalizeToArray(attrTransition);
        for (let i = 0; i < transitionKeys.length; i++) {
          const key = transitionKeys[i];
          const elVal = elPropsInAttr[key];
          transFromPropsInAttr[key] = elVal;
        }
      }
    } else if (isTransitionAll(transition) || indexOf(transition, mainAttr) >= 0) {
      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});
      const elPropsInAttrKeys = keys(elPropsInAttr);
      for (let i = 0; i < elPropsInAttrKeys.length; i++) {
        const key = elPropsInAttrKeys[i];
        const elVal = elPropsInAttr[key];
        if (isNonStyleTransitionEnabled(attrOpt[key], elVal)) {
          transFromPropsInAttr[key] = elVal;
        }
      }
    }
  }
}
function prepareShapeOrExtraAllPropsFinal(mainAttr, elOption, allProps) {
  const attrOpt = elOption[mainAttr];
  if (!attrOpt) {
    return;
  }
  const allPropsInAttr = allProps[mainAttr] = {};
  const keysInAttr = keys(attrOpt);
  for (let i = 0; i < keysInAttr.length; i++) {
    const key = keysInAttr[i];
    allPropsInAttr[key] = cloneValue(attrOpt[key]);
  }
}
function prepareTransformTransitionFrom(el, elOption, transFromProps) {
  const transition = elOption.transition;
  const transitionKeys = isTransitionAll(transition) ? TRANSFORMABLE_PROPS : normalizeToArray(transition || []);
  for (let i = 0; i < transitionKeys.length; i++) {
    const key = transitionKeys[i];
    if (key === "style" || key === "shape" || key === "extra") {
      continue;
    }
    const elVal = el[key];
    if (true) {
      checkTransformPropRefer(key, "el.transition");
    }
    transFromProps[key] = elVal;
  }
}
function prepareTransformAllPropsFinal(el, elOption, allProps) {
  for (let i = 0; i < LEGACY_TRANSFORM_PROPS.length; i++) {
    const legacyName = LEGACY_TRANSFORM_PROPS[i];
    const xyName = LEGACY_TRANSFORM_PROPS_MAP[legacyName];
    const legacyArr = elOption[legacyName];
    if (legacyArr) {
      allProps[xyName[0]] = legacyArr[0];
      allProps[xyName[1]] = legacyArr[1];
    }
  }
  for (let i = 0; i < TRANSFORMABLE_PROPS.length; i++) {
    const key = TRANSFORMABLE_PROPS[i];
    if (elOption[key] != null) {
      allProps[key] = elOption[key];
    }
  }
}
function prepareStyleTransitionFrom(fromEl, elOption, styleOpt, transFromProps) {
  if (!styleOpt) {
    return;
  }
  const fromElStyle = fromEl.style;
  let transFromStyleProps;
  if (fromElStyle) {
    const styleTransition = styleOpt.transition;
    const elTransition = elOption.transition;
    if (styleTransition && !isTransitionAll(styleTransition)) {
      const transitionKeys = normalizeToArray(styleTransition);
      !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});
      for (let i = 0; i < transitionKeys.length; i++) {
        const key = transitionKeys[i];
        const elVal = fromElStyle[key];
        transFromStyleProps[key] = elVal;
      }
    } else if (fromEl.getAnimationStyleProps && (isTransitionAll(elTransition) || isTransitionAll(styleTransition) || indexOf(elTransition, "style") >= 0)) {
      const animationProps = fromEl.getAnimationStyleProps();
      const animationStyleProps = animationProps ? animationProps.style : null;
      if (animationStyleProps) {
        !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});
        const styleKeys = keys(styleOpt);
        for (let i = 0; i < styleKeys.length; i++) {
          const key = styleKeys[i];
          if (animationStyleProps[key]) {
            const elVal = fromElStyle[key];
            transFromStyleProps[key] = elVal;
          }
        }
      }
    }
  }
}
function isNonStyleTransitionEnabled(optVal, elVal) {
  return !isArrayLike(optVal) ? optVal != null && isFinite(optVal) : optVal !== elVal;
}
var checkTransformPropRefer;
if (true) {
  checkTransformPropRefer = function(key, usedIn) {
    if (!hasOwn(TRANSFORM_PROPS_MAP, key)) {
      warn("Prop `" + key + "` is not a permitted in `" + usedIn + "`. Only `" + keys(TRANSFORM_PROPS_MAP).join("`, `") + "` are permitted.");
    }
  };
}

// src/animation/customGraphicKeyframeAnimation.ts
var getStateToRestore = makeInner();
var KEYFRAME_EXCLUDE_KEYS = ["percent", "easing", "shape", "style", "extra"];
function stopPreviousKeyframeAnimationAndRestore(el) {
  el.stopAnimation("keyframe");
  el.attr(getStateToRestore(el));
}
function applyKeyframeAnimation(el, animationOpts, animatableModel) {
  if (!animatableModel.isAnimationEnabled() || !animationOpts) {
    return;
  }
  if (isArray(animationOpts)) {
    each(animationOpts, (singleAnimationOpts) => {
      applyKeyframeAnimation(el, singleAnimationOpts, animatableModel);
    });
    return;
  }
  const keyframes = animationOpts.keyframes;
  let duration = animationOpts.duration;
  if (animatableModel && duration == null) {
    const config = getAnimationConfig("enter", animatableModel, 0);
    duration = config && config.duration;
  }
  if (!keyframes || !duration) {
    return;
  }
  const stateToRestore = getStateToRestore(el);
  each(ELEMENT_ANIMATABLE_PROPS, (targetPropName) => {
    if (targetPropName && !el[targetPropName]) {
      return;
    }
    let animator;
    let endFrameIsSet = false;
    keyframes.sort((a, b) => a.percent - b.percent);
    each(keyframes, (kf) => {
      const animators = el.animators;
      const kfValues = targetPropName ? kf[targetPropName] : kf;
      if (true) {
        if (kf.percent >= 1) {
          endFrameIsSet = true;
        }
      }
      if (!kfValues) {
        return;
      }
      let propKeys = keys(kfValues);
      if (!targetPropName) {
        propKeys = filter(propKeys, (key) => indexOf(KEYFRAME_EXCLUDE_KEYS, key) < 0);
      }
      if (!propKeys.length) {
        return;
      }
      if (!animator) {
        animator = el.animate(targetPropName, animationOpts.loop, true);
        animator.scope = "keyframe";
      }
      for (let i = 0; i < animators.length; i++) {
        if (animators[i] !== animator && animators[i].targetName === animator.targetName) {
          animators[i].stopTracks(propKeys);
        }
      }
      targetPropName && (stateToRestore[targetPropName] = stateToRestore[targetPropName] || {});
      const savedTarget = targetPropName ? stateToRestore[targetPropName] : stateToRestore;
      each(propKeys, (key) => {
        savedTarget[key] = ((targetPropName ? el[targetPropName] : el) || {})[key];
      });
      animator.whenWithKeys(duration * kf.percent, kfValues, propKeys, kf.easing);
    });
    if (!animator) {
      return;
    }
    if (true) {
      if (!endFrameIsSet) {
        warn("End frame with percent: 1 is missing in the keyframeAnimation.", true);
      }
    }
    animator.delay(animationOpts.delay || 0).duration(duration).start(animationOpts.easing);
  });
}

// src/chart/custom/CustomView.ts
var EMPHASIS = "emphasis";
var NORMAL = "normal";
var BLUR = "blur";
var SELECT = "select";
var STATES = [NORMAL, EMPHASIS, BLUR, SELECT];
var PATH_ITEM_STYLE = {
  normal: ["itemStyle"],
  emphasis: [EMPHASIS, "itemStyle"],
  blur: [BLUR, "itemStyle"],
  select: [SELECT, "itemStyle"]
};
var PATH_LABEL = {
  normal: ["label"],
  emphasis: [EMPHASIS, "label"],
  blur: [BLUR, "label"],
  select: [SELECT, "label"]
};
var DEFAULT_TRANSITION = ["x", "y"];
var GROUP_DIFF_PREFIX = "e\0\0";
var attachedTxInfoTmp = {
  normal: {},
  emphasis: {},
  blur: {},
  select: {}
};
var prepareCustoms = {
  cartesian2d: cartesianPrepareCustom,
  geo: geoPrepareCustom,
  single: singlePrepareCustom,
  polar: polarPrepareCustom,
  calendar: calendarPrepareCustom
};
function isPath2(el) {
  return el instanceof Path_default;
}
function isDisplayable(el) {
  return el instanceof Displayable_default;
}
function copyElement(sourceEl, targetEl) {
  targetEl.copyTransform(sourceEl);
  if (isDisplayable(targetEl) && isDisplayable(sourceEl)) {
    targetEl.setStyle(sourceEl.style);
    targetEl.z = sourceEl.z;
    targetEl.z2 = sourceEl.z2;
    targetEl.zlevel = sourceEl.zlevel;
    targetEl.invisible = sourceEl.invisible;
    targetEl.ignore = sourceEl.ignore;
    if (isPath2(targetEl) && isPath2(sourceEl)) {
      targetEl.setShape(sourceEl.shape);
    }
  }
}
var CustomChartView2 = class extends Chart_default {
  constructor() {
    super(...arguments);
    this.type = CustomChartView2.type;
  }
  render(customSeries, ecModel, api2, payload) {
    this._progressiveEls = null;
    const oldData = this._data;
    const data = customSeries.getData();
    const group = this.group;
    const renderItem = makeRenderItem(customSeries, data, ecModel, api2);
    if (!oldData) {
      group.removeAll();
    }
    data.diff(oldData).add(function(newIdx) {
      createOrUpdateItem(api2, null, newIdx, renderItem(newIdx, payload), customSeries, group, data);
    }).remove(function(oldIdx) {
      const el = oldData.getItemGraphicEl(oldIdx);
      el && applyLeaveTransition(el, customInnerStore(el).option, customSeries);
    }).update(function(newIdx, oldIdx) {
      const oldEl = oldData.getItemGraphicEl(oldIdx);
      createOrUpdateItem(api2, oldEl, newIdx, renderItem(newIdx, payload), customSeries, group, data);
    }).execute();
    const clipPath = customSeries.get("clip", true) ? createClipPath(customSeries.coordinateSystem, false, customSeries) : null;
    if (clipPath) {
      group.setClipPath(clipPath);
    } else {
      group.removeClipPath();
    }
    this._data = data;
  }
  incrementalPrepareRender(customSeries, ecModel, api2) {
    this.group.removeAll();
    this._data = null;
  }
  incrementalRender(params, customSeries, ecModel, api2, payload) {
    const data = customSeries.getData();
    const renderItem = makeRenderItem(customSeries, data, ecModel, api2);
    const progressiveEls = this._progressiveEls = [];
    function setIncrementalAndHoverLayer(el) {
      if (!el.isGroup) {
        el.incremental = true;
        el.ensureState("emphasis").hoverLayer = true;
      }
    }
    for (let idx = params.start; idx < params.end; idx++) {
      const el = createOrUpdateItem(null, null, idx, renderItem(idx, payload), customSeries, this.group, data);
      if (el) {
        el.traverse(setIncrementalAndHoverLayer);
        progressiveEls.push(el);
      }
    }
  }
  eachRendered(cb) {
    traverseElements(this._progressiveEls || this.group, cb);
  }
  filterForExposedEvent(eventType, query, targetEl, packedEvent) {
    const elementName = query.element;
    if (elementName == null || targetEl.name === elementName) {
      return true;
    }
    while ((targetEl = targetEl.__hostTarget || targetEl.parent) && targetEl !== this.group) {
      if (targetEl.name === elementName) {
        return true;
      }
    }
    return false;
  }
};
var CustomChartView = CustomChartView2;
CustomChartView.type = "custom";
var CustomView_default = CustomChartView;
function createEl(elOption) {
  const graphicType = elOption.type;
  let el;
  if (graphicType === "path") {
    const shape = elOption.shape;
    const pathRect = shape.width != null && shape.height != null ? {
      x: shape.x || 0,
      y: shape.y || 0,
      width: shape.width,
      height: shape.height
    } : null;
    const pathData = getPathData(shape);
    el = makePath(pathData, null, pathRect, shape.layout || "center");
    customInnerStore(el).customPathData = pathData;
  } else if (graphicType === "image") {
    el = new Image_default({});
    customInnerStore(el).customImagePath = elOption.style.image;
  } else if (graphicType === "text") {
    el = new Text_default({});
  } else if (graphicType === "group") {
    el = new Group_default();
  } else if (graphicType === "compoundPath") {
    throw new Error('"compoundPath" is not supported yet.');
  } else {
    const Clz = getShapeClass(graphicType);
    if (!Clz) {
      let errMsg = "";
      if (true) {
        errMsg = 'graphic type "' + graphicType + '" can not be found.';
      }
      throwError(errMsg);
    }
    el = new Clz();
  }
  customInnerStore(el).customGraphicType = graphicType;
  el.name = elOption.name;
  el.z2EmphasisLift = 1;
  el.z2SelectLift = 1;
  return el;
}
function updateElNormal(api2, el, dataIndex, elOption, attachedTxInfo, seriesModel, isInit) {
  stopPreviousKeyframeAnimationAndRestore(el);
  const txCfgOpt = attachedTxInfo && attachedTxInfo.normal.cfg;
  if (txCfgOpt) {
    el.setTextConfig(txCfgOpt);
  }
  if (elOption && elOption.transition == null) {
    elOption.transition = DEFAULT_TRANSITION;
  }
  const styleOpt = elOption && elOption.style;
  if (styleOpt) {
    if (el.type === "text") {
      const textOptionStyle = styleOpt;
      hasOwn(textOptionStyle, "textFill") && (textOptionStyle.fill = textOptionStyle.textFill);
      hasOwn(textOptionStyle, "textStroke") && (textOptionStyle.stroke = textOptionStyle.textStroke);
    }
    let decalPattern;
    const decalObj = isPath2(el) ? styleOpt.decal : null;
    if (api2 && decalObj) {
      decalObj.dirty = true;
      decalPattern = createOrUpdatePatternFromDecal(decalObj, api2);
    }
    styleOpt.__decalPattern = decalPattern;
  }
  if (isDisplayable(el)) {
    if (styleOpt) {
      const decalPattern = styleOpt.__decalPattern;
      if (decalPattern) {
        styleOpt.decal = decalPattern;
      }
    }
  }
  applyUpdateTransition(el, elOption, seriesModel, {
    dataIndex,
    isInit,
    clearStyle: true
  });
  applyKeyframeAnimation(el, elOption.keyframeAnimation, seriesModel);
}
function updateElOnState(state, el, elStateOpt, styleOpt, attachedTxInfo) {
  const elDisplayable = el.isGroup ? null : el;
  const txCfgOpt = attachedTxInfo && attachedTxInfo[state].cfg;
  if (elDisplayable) {
    const stateObj = elDisplayable.ensureState(state);
    if (styleOpt === false) {
      const existingEmphasisState = elDisplayable.getState(state);
      if (existingEmphasisState) {
        existingEmphasisState.style = null;
      }
    } else {
      stateObj.style = styleOpt || null;
    }
    if (txCfgOpt) {
      stateObj.textConfig = txCfgOpt;
    }
    setDefaultStateProxy(elDisplayable);
  }
}
function updateZ2(el, elOption, seriesModel) {
  if (el.isGroup) {
    return;
  }
  const elDisplayable = el;
  const currentZ = seriesModel.currentZ;
  const currentZLevel = seriesModel.currentZLevel;
  elDisplayable.z = currentZ;
  elDisplayable.zlevel = currentZLevel;
  const optZ2 = elOption.z2;
  optZ2 != null && (elDisplayable.z2 = optZ2 || 0);
  for (let i = 0; i < STATES.length; i++) {
    updateZForEachState(elDisplayable, elOption, STATES[i]);
  }
}
function updateZForEachState(elDisplayable, elOption, state) {
  const isNormal = state === NORMAL;
  const elStateOpt = isNormal ? elOption : retrieveStateOption(elOption, state);
  const optZ2 = elStateOpt ? elStateOpt.z2 : null;
  let stateObj;
  if (optZ2 != null) {
    stateObj = isNormal ? elDisplayable : elDisplayable.ensureState(state);
    stateObj.z2 = optZ2 || 0;
  }
}
function makeRenderItem(customSeries, data, ecModel, api2) {
  const renderItem = customSeries.get("renderItem");
  const coordSys = customSeries.coordinateSystem;
  let prepareResult2 = {};
  if (coordSys) {
    if (true) {
      assert(renderItem, "series.render is required.");
      assert(coordSys.prepareCustoms || prepareCustoms[coordSys.type], "This coordSys does not support custom series.");
    }
    prepareResult2 = coordSys.prepareCustoms ? coordSys.prepareCustoms(coordSys) : prepareCustoms[coordSys.type](coordSys);
  }
  const userAPI = defaults({
    getWidth: api2.getWidth,
    getHeight: api2.getHeight,
    getZr: api2.getZr,
    getDevicePixelRatio: api2.getDevicePixelRatio,
    value,
    style,
    ordinalRawValue,
    styleEmphasis,
    visual,
    barLayout,
    currentSeriesIndices,
    font
  }, prepareResult2.api || {});
  const userParams = {
    context: {},
    seriesId: customSeries.id,
    seriesName: customSeries.name,
    seriesIndex: customSeries.seriesIndex,
    coordSys: prepareResult2.coordSys,
    dataInsideLength: data.count(),
    encode: wrapEncodeDef(customSeries.getData())
  };
  let currDataIndexInside;
  let currItemModel;
  let currItemStyleModels = {};
  let currLabelModels = {};
  const seriesItemStyleModels = {};
  const seriesLabelModels = {};
  for (let i = 0; i < STATES.length; i++) {
    const stateName = STATES[i];
    seriesItemStyleModels[stateName] = customSeries.getModel(PATH_ITEM_STYLE[stateName]);
    seriesLabelModels[stateName] = customSeries.getModel(PATH_LABEL[stateName]);
  }
  function getItemModel2(dataIndexInside) {
    return dataIndexInside === currDataIndexInside ? currItemModel || (currItemModel = data.getItemModel(dataIndexInside)) : data.getItemModel(dataIndexInside);
  }
  function getItemStyleModel(dataIndexInside, state) {
    return !data.hasItemOption ? seriesItemStyleModels[state] : dataIndexInside === currDataIndexInside ? currItemStyleModels[state] || (currItemStyleModels[state] = getItemModel2(dataIndexInside).getModel(PATH_ITEM_STYLE[state])) : getItemModel2(dataIndexInside).getModel(PATH_ITEM_STYLE[state]);
  }
  function getLabelModel(dataIndexInside, state) {
    return !data.hasItemOption ? seriesLabelModels[state] : dataIndexInside === currDataIndexInside ? currLabelModels[state] || (currLabelModels[state] = getItemModel2(dataIndexInside).getModel(PATH_LABEL[state])) : getItemModel2(dataIndexInside).getModel(PATH_LABEL[state]);
  }
  return function(dataIndexInside, payload) {
    currDataIndexInside = dataIndexInside;
    currItemModel = null;
    currItemStyleModels = {};
    currLabelModels = {};
    return renderItem && renderItem(defaults({
      dataIndexInside,
      dataIndex: data.getRawIndex(dataIndexInside),
      actionType: payload ? payload.type : null
    }, userParams), userAPI);
  };
  function value(dim, dataIndexInside) {
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    return data.getStore().get(data.getDimensionIndex(dim || 0), dataIndexInside);
  }
  function ordinalRawValue(dim, dataIndexInside) {
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    dim = dim || 0;
    const dimInfo = data.getDimensionInfo(dim);
    if (!dimInfo) {
      const dimIndex = data.getDimensionIndex(dim);
      return dimIndex >= 0 ? data.getStore().get(dimIndex, dataIndexInside) : void 0;
    }
    const val = data.get(dimInfo.name, dataIndexInside);
    const ordinalMeta = dimInfo && dimInfo.ordinalMeta;
    return ordinalMeta ? ordinalMeta.categories[val] : val;
  }
  function style(userProps, dataIndexInside) {
    if (true) {
      warnDeprecated("api.style", "Please write literal style directly instead.");
    }
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    const style2 = data.getItemVisual(dataIndexInside, "style");
    const visualColor = style2 && style2.fill;
    const opacity = style2 && style2.opacity;
    let itemStyle = getItemStyleModel(dataIndexInside, NORMAL).getItemStyle();
    visualColor != null && (itemStyle.fill = visualColor);
    opacity != null && (itemStyle.opacity = opacity);
    const opt = {inheritColor: isString(visualColor) ? visualColor : "#000"};
    const labelModel = getLabelModel(dataIndexInside, NORMAL);
    const textStyle = createTextStyle(labelModel, null, opt, false, true);
    textStyle.text = labelModel.getShallow("show") ? retrieve2(customSeries.getFormattedLabel(dataIndexInside, NORMAL), getDefaultLabel(data, dataIndexInside)) : null;
    const textConfig = createTextConfig(labelModel, opt, false);
    preFetchFromExtra(userProps, itemStyle);
    itemStyle = convertToEC4StyleForCustomSerise(itemStyle, textStyle, textConfig);
    userProps && applyUserPropsAfter(itemStyle, userProps);
    itemStyle.legacy = true;
    return itemStyle;
  }
  function styleEmphasis(userProps, dataIndexInside) {
    if (true) {
      warnDeprecated("api.styleEmphasis", "Please write literal style directly instead.");
    }
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    let itemStyle = getItemStyleModel(dataIndexInside, EMPHASIS).getItemStyle();
    const labelModel = getLabelModel(dataIndexInside, EMPHASIS);
    const textStyle = createTextStyle(labelModel, null, null, true, true);
    textStyle.text = labelModel.getShallow("show") ? retrieve3(customSeries.getFormattedLabel(dataIndexInside, EMPHASIS), customSeries.getFormattedLabel(dataIndexInside, NORMAL), getDefaultLabel(data, dataIndexInside)) : null;
    const textConfig = createTextConfig(labelModel, null, true);
    preFetchFromExtra(userProps, itemStyle);
    itemStyle = convertToEC4StyleForCustomSerise(itemStyle, textStyle, textConfig);
    userProps && applyUserPropsAfter(itemStyle, userProps);
    itemStyle.legacy = true;
    return itemStyle;
  }
  function applyUserPropsAfter(itemStyle, extra) {
    for (const key in extra) {
      if (hasOwn(extra, key)) {
        itemStyle[key] = extra[key];
      }
    }
  }
  function preFetchFromExtra(extra, itemStyle) {
    if (extra) {
      extra.textFill && (itemStyle.textFill = extra.textFill);
      extra.textPosition && (itemStyle.textPosition = extra.textPosition);
    }
  }
  function visual(visualType, dataIndexInside) {
    dataIndexInside == null && (dataIndexInside = currDataIndexInside);
    if (hasOwn(STYLE_VISUAL_TYPE, visualType)) {
      const style2 = data.getItemVisual(dataIndexInside, "style");
      return style2 ? style2[STYLE_VISUAL_TYPE[visualType]] : null;
    }
    if (hasOwn(NON_STYLE_VISUAL_PROPS, visualType)) {
      return data.getItemVisual(dataIndexInside, visualType);
    }
  }
  function barLayout(opt) {
    if (coordSys.type === "cartesian2d") {
      const baseAxis = coordSys.getBaseAxis();
      return getLayoutOnAxis(defaults({axis: baseAxis}, opt));
    }
  }
  function currentSeriesIndices() {
    return ecModel.getCurrentSeriesIndices();
  }
  function font(opt) {
    return getFont(opt, ecModel);
  }
}
function wrapEncodeDef(data) {
  const encodeDef = {};
  each(data.dimensions, function(dimName) {
    const dimInfo = data.getDimensionInfo(dimName);
    if (!dimInfo.isExtraCoord) {
      const coordDim = dimInfo.coordDim;
      const dataDims = encodeDef[coordDim] = encodeDef[coordDim] || [];
      dataDims[dimInfo.coordDimIndex] = data.getDimensionIndex(dimName);
    }
  });
  return encodeDef;
}
function createOrUpdateItem(api2, existsEl, dataIndex, elOption, seriesModel, group, data) {
  if (!elOption) {
    group.remove(existsEl);
    return;
  }
  const el = doCreateOrUpdateEl(api2, existsEl, dataIndex, elOption, seriesModel, group);
  el && data.setItemGraphicEl(dataIndex, el);
  el && toggleHoverEmphasis(el, elOption.focus, elOption.blurScope, elOption.emphasisDisabled);
  return el;
}
function doCreateOrUpdateEl(api2, existsEl, dataIndex, elOption, seriesModel, group) {
  if (true) {
    assert(elOption, "should not have an null/undefined element setting");
  }
  let toBeReplacedIdx = -1;
  const oldEl = existsEl;
  if (existsEl && doesElNeedRecreate(existsEl, elOption, seriesModel)) {
    toBeReplacedIdx = indexOf(group.childrenRef(), existsEl);
    existsEl = null;
  }
  const isInit = !existsEl;
  let el = existsEl;
  if (!el) {
    el = createEl(elOption);
    if (oldEl) {
      copyElement(oldEl, el);
    }
  } else {
    el.clearStates();
  }
  if (elOption.morph === false) {
    el.disableMorphing = true;
  } else if (el.disableMorphing) {
    el.disableMorphing = false;
  }
  attachedTxInfoTmp.normal.cfg = attachedTxInfoTmp.normal.conOpt = attachedTxInfoTmp.emphasis.cfg = attachedTxInfoTmp.emphasis.conOpt = attachedTxInfoTmp.blur.cfg = attachedTxInfoTmp.blur.conOpt = attachedTxInfoTmp.select.cfg = attachedTxInfoTmp.select.conOpt = null;
  attachedTxInfoTmp.isLegacy = false;
  doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfoTmp);
  doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit);
  updateElNormal(api2, el, dataIndex, elOption, attachedTxInfoTmp, seriesModel, isInit);
  hasOwn(elOption, "info") && (customInnerStore(el).info = elOption.info);
  for (let i = 0; i < STATES.length; i++) {
    const stateName = STATES[i];
    if (stateName !== NORMAL) {
      const otherStateOpt = retrieveStateOption(elOption, stateName);
      const otherStyleOpt = retrieveStyleOptionOnState(elOption, otherStateOpt, stateName);
      updateElOnState(stateName, el, otherStateOpt, otherStyleOpt, attachedTxInfoTmp);
    }
  }
  updateZ2(el, elOption, seriesModel);
  if (elOption.type === "group") {
    mergeChildren(api2, el, dataIndex, elOption, seriesModel);
  }
  if (toBeReplacedIdx >= 0) {
    group.replaceAt(el, toBeReplacedIdx);
  } else {
    group.add(el);
  }
  return el;
}
function doesElNeedRecreate(el, elOption, seriesModel) {
  const elInner = customInnerStore(el);
  const elOptionType = elOption.type;
  const elOptionShape = elOption.shape;
  const elOptionStyle = elOption.style;
  return seriesModel.isUniversalTransitionEnabled() || elOptionType != null && elOptionType !== elInner.customGraphicType || elOptionType === "path" && hasOwnPathData(elOptionShape) && getPathData(elOptionShape) !== elInner.customPathData || elOptionType === "image" && hasOwn(elOptionStyle, "image") && elOptionStyle.image !== elInner.customImagePath;
}
function doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit) {
  const clipPathOpt = elOption.clipPath;
  if (clipPathOpt === false) {
    if (el && el.getClipPath()) {
      el.removeClipPath();
    }
  } else if (clipPathOpt) {
    let clipPath = el.getClipPath();
    if (clipPath && doesElNeedRecreate(clipPath, clipPathOpt, seriesModel)) {
      clipPath = null;
    }
    if (!clipPath) {
      clipPath = createEl(clipPathOpt);
      if (true) {
        assert(isPath2(clipPath), "Only any type of `path` can be used in `clipPath`, rather than " + clipPath.type + ".");
      }
      el.setClipPath(clipPath);
    }
    updateElNormal(null, clipPath, dataIndex, clipPathOpt, null, seriesModel, isInit);
  }
}
function doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfo) {
  if (el.isGroup) {
    return;
  }
  processTxInfo(elOption, null, attachedTxInfo);
  processTxInfo(elOption, EMPHASIS, attachedTxInfo);
  let txConOptNormal = attachedTxInfo.normal.conOpt;
  const txConOptEmphasis = attachedTxInfo.emphasis.conOpt;
  const txConOptBlur = attachedTxInfo.blur.conOpt;
  const txConOptSelect = attachedTxInfo.select.conOpt;
  if (txConOptNormal != null || txConOptEmphasis != null || txConOptSelect != null || txConOptBlur != null) {
    let textContent = el.getTextContent();
    if (txConOptNormal === false) {
      textContent && el.removeTextContent();
    } else {
      txConOptNormal = attachedTxInfo.normal.conOpt = txConOptNormal || {type: "text"};
      if (!textContent) {
        textContent = createEl(txConOptNormal);
        el.setTextContent(textContent);
      } else {
        textContent.clearStates();
      }
      updateElNormal(null, textContent, dataIndex, txConOptNormal, null, seriesModel, isInit);
      const txConStlOptNormal = txConOptNormal && txConOptNormal.style;
      for (let i = 0; i < STATES.length; i++) {
        const stateName = STATES[i];
        if (stateName !== NORMAL) {
          const txConOptOtherState = attachedTxInfo[stateName].conOpt;
          updateElOnState(stateName, textContent, txConOptOtherState, retrieveStyleOptionOnState(txConOptNormal, txConOptOtherState, stateName), null);
        }
      }
      txConStlOptNormal ? textContent.dirty() : textContent.markRedraw();
    }
  }
}
function processTxInfo(elOption, state, attachedTxInfo) {
  const stateOpt = !state ? elOption : retrieveStateOption(elOption, state);
  const styleOpt = !state ? elOption.style : retrieveStyleOptionOnState(elOption, stateOpt, EMPHASIS);
  const elType = elOption.type;
  let txCfg = stateOpt ? stateOpt.textConfig : null;
  const txConOptNormal = elOption.textContent;
  let txConOpt = !txConOptNormal ? null : !state ? txConOptNormal : retrieveStateOption(txConOptNormal, state);
  if (styleOpt && (attachedTxInfo.isLegacy || isEC4CompatibleStyle(styleOpt, elType, !!txCfg, !!txConOpt))) {
    attachedTxInfo.isLegacy = true;
    const convertResult = convertFromEC4CompatibleStyle(styleOpt, elType, !state);
    if (!txCfg && convertResult.textConfig) {
      txCfg = convertResult.textConfig;
    }
    if (!txConOpt && convertResult.textContent) {
      txConOpt = convertResult.textContent;
    }
  }
  if (!state && txConOpt) {
    const txConOptNormal2 = txConOpt;
    !txConOptNormal2.type && (txConOptNormal2.type = "text");
    if (true) {
      assert(txConOptNormal2.type === "text", 'textContent.type must be "text"');
    }
  }
  const info = !state ? attachedTxInfo.normal : attachedTxInfo[state];
  info.cfg = txCfg;
  info.conOpt = txConOpt;
}
function retrieveStateOption(elOption, state) {
  return !state ? elOption : elOption ? elOption[state] : null;
}
function retrieveStyleOptionOnState(stateOptionNormal, stateOption, state) {
  let style = stateOption && stateOption.style;
  if (style == null && state === EMPHASIS && stateOptionNormal) {
    style = stateOptionNormal.styleEmphasis;
  }
  return style;
}
function mergeChildren(api2, el, dataIndex, elOption, seriesModel) {
  const newChildren = elOption.children;
  const newLen = newChildren ? newChildren.length : 0;
  const mergeChildren2 = elOption.$mergeChildren;
  const byName = mergeChildren2 === "byName" || elOption.diffChildrenByName;
  const notMerge = mergeChildren2 === false;
  if (!newLen && !byName && !notMerge) {
    return;
  }
  if (byName) {
    diffGroupChildren({
      api: api2,
      oldChildren: el.children() || [],
      newChildren: newChildren || [],
      dataIndex,
      seriesModel,
      group: el
    });
    return;
  }
  notMerge && el.removeAll();
  let index = 0;
  for (; index < newLen; index++) {
    const newChild = newChildren[index];
    const oldChild = el.childAt(index);
    if (newChild) {
      if (newChild.ignore == null) {
        newChild.ignore = false;
      }
      doCreateOrUpdateEl(api2, oldChild, dataIndex, newChild, seriesModel, el);
    } else {
      if (true) {
        assert(oldChild, "renderItem should not return a group containing elements as null/undefined/{} if they do not exist before.");
      }
      oldChild.ignore = true;
    }
  }
  for (let i = el.childCount() - 1; i >= index; i--) {
    const child = el.childAt(i);
    removeChildFromGroup(el, child, seriesModel);
  }
}
function removeChildFromGroup(group, child, seriesModel) {
  child && applyLeaveTransition(child, customInnerStore(group).option, seriesModel);
}
function diffGroupChildren(context) {
  new DataDiffer_default(context.oldChildren, context.newChildren, getKey, getKey, context).add(processAddUpdate).update(processAddUpdate).remove(processRemove).execute();
}
function getKey(item, idx) {
  const name = item && item.name;
  return name != null ? name : GROUP_DIFF_PREFIX + idx;
}
function processAddUpdate(newIndex, oldIndex) {
  const context = this.context;
  const childOption = newIndex != null ? context.newChildren[newIndex] : null;
  const child = oldIndex != null ? context.oldChildren[oldIndex] : null;
  doCreateOrUpdateEl(context.api, child, context.dataIndex, childOption, context.seriesModel, context.group);
}
function processRemove(oldIndex) {
  const context = this.context;
  const child = context.oldChildren[oldIndex];
  child && applyLeaveTransition(child, customInnerStore(child).option, context.seriesModel);
}
function getPathData(shape) {
  return shape && (shape.pathData || shape.d);
}
function hasOwnPathData(shape) {
  return shape && (hasOwn(shape, "pathData") || hasOwn(shape, "d"));
}

// src/chart/custom/install.ts
function install28(registers) {
  registers.registerChartView(CustomView_default);
  registers.registerSeriesModel(CustomSeries_default);
}

// src/component/graphic/GraphicModel.ts
function setKeyInfoToNewElOption(resultItem, newElOption) {
  const existElOption = resultItem.existing;
  newElOption.id = resultItem.keyInfo.id;
  !newElOption.type && existElOption && (newElOption.type = existElOption.type);
  if (newElOption.parentId == null) {
    const newElParentOption = newElOption.parentOption;
    if (newElParentOption) {
      newElOption.parentId = newElParentOption.id;
    } else if (existElOption) {
      newElOption.parentId = existElOption.parentId;
    }
  }
  newElOption.parentOption = null;
}
function isSetLoc(obj, props) {
  let isSet;
  each(props, function(prop) {
    obj[prop] != null && obj[prop] !== "auto" && (isSet = true);
  });
  return isSet;
}
function mergeNewElOptionToExist(existList, index, newElOption) {
  const newElOptCopy = extend({}, newElOption);
  const existElOption = existList[index];
  const $action = newElOption.$action || "merge";
  if ($action === "merge") {
    if (existElOption) {
      if (true) {
        const newType = newElOption.type;
        assert(!newType || existElOption.type === newType, 'Please set $action: "replace" to change `type`');
      }
      merge(existElOption, newElOptCopy, true);
      mergeLayoutParam(existElOption, newElOptCopy, {ignoreSize: true});
      copyLayoutParams(newElOption, existElOption);
      copyTransitionInfo(newElOption, existElOption);
      copyTransitionInfo(newElOption, existElOption, "shape");
      copyTransitionInfo(newElOption, existElOption, "style");
      copyTransitionInfo(newElOption, existElOption, "extra");
      newElOption.clipPath = existElOption.clipPath;
    } else {
      existList[index] = newElOptCopy;
    }
  } else if ($action === "replace") {
    existList[index] = newElOptCopy;
  } else if ($action === "remove") {
    existElOption && (existList[index] = null);
  }
}
var TRANSITION_PROPS_TO_COPY = ["transition", "enterFrom", "leaveTo"];
var ROOT_TRANSITION_PROPS_TO_COPY = TRANSITION_PROPS_TO_COPY.concat(["enterAnimation", "updateAnimation", "leaveAnimation"]);
function copyTransitionInfo(target, source, targetProp) {
  if (targetProp) {
    if (!target[targetProp] && source[targetProp]) {
      target[targetProp] = {};
    }
    target = target[targetProp];
    source = source[targetProp];
  }
  if (!target || !source) {
    return;
  }
  const props = targetProp ? TRANSITION_PROPS_TO_COPY : ROOT_TRANSITION_PROPS_TO_COPY;
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (target[prop] == null && source[prop] != null) {
      target[prop] = source[prop];
    }
  }
}
function setLayoutInfoToExist(existItem, newElOption) {
  if (!existItem) {
    return;
  }
  existItem.hv = newElOption.hv = [
    isSetLoc(newElOption, ["left", "right"]),
    isSetLoc(newElOption, ["top", "bottom"])
  ];
  if (existItem.type === "group") {
    const existingGroupOpt = existItem;
    const newGroupOpt = newElOption;
    existingGroupOpt.width == null && (existingGroupOpt.width = newGroupOpt.width = 0);
    existingGroupOpt.height == null && (existingGroupOpt.height = newGroupOpt.height = 0);
  }
}
var GraphicComponentModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = GraphicComponentModel2.type;
    this.preventAutoZ = true;
  }
  mergeOption(option, ecModel) {
    const elements = this.option.elements;
    this.option.elements = null;
    super.mergeOption(option, ecModel);
    this.option.elements = elements;
  }
  optionUpdated(newOption, isInit) {
    const thisOption = this.option;
    const newList = (isInit ? thisOption : newOption).elements;
    const existList = thisOption.elements = isInit ? [] : thisOption.elements;
    const flattenedList = [];
    this._flatten(newList, flattenedList, null);
    const mappingResult = mappingToExists(existList, flattenedList, "normalMerge");
    const elOptionsToUpdate = this._elOptionsToUpdate = [];
    each(mappingResult, function(resultItem, index) {
      const newElOption = resultItem.newOption;
      if (true) {
        assert(isObject(newElOption) || resultItem.existing, "Empty graphic option definition");
      }
      if (!newElOption) {
        return;
      }
      elOptionsToUpdate.push(newElOption);
      setKeyInfoToNewElOption(resultItem, newElOption);
      mergeNewElOptionToExist(existList, index, newElOption);
      setLayoutInfoToExist(existList[index], newElOption);
    }, this);
    thisOption.elements = filter(existList, (item) => {
      item && delete item.$action;
      return item != null;
    });
  }
  _flatten(optionList, result, parentOption) {
    each(optionList, function(option) {
      if (!option) {
        return;
      }
      if (parentOption) {
        option.parentOption = parentOption;
      }
      result.push(option);
      const children = option.children;
      if (children && children.length) {
        this._flatten(children, result, option);
      }
      delete option.children;
    }, this);
  }
  useElOptionsToUpdate() {
    const els = this._elOptionsToUpdate;
    this._elOptionsToUpdate = null;
    return els;
  }
};
var GraphicComponentModel = GraphicComponentModel2;
GraphicComponentModel.type = "graphic";
GraphicComponentModel.defaultOption = {
  elements: []
};

// src/component/axisPointer/BaseAxisPointer.ts
var inner11 = makeInner();
var clone4 = clone;
var bind2 = bind;
var BaseAxisPointer = class {
  constructor() {
    this._dragging = false;
    this.animationThreshold = 15;
  }
  render(axisModel, axisPointerModel, api2, forceRender) {
    const value = axisPointerModel.get("value");
    const status = axisPointerModel.get("status");
    this._axisModel = axisModel;
    this._axisPointerModel = axisPointerModel;
    this._api = api2;
    if (!forceRender && this._lastValue === value && this._lastStatus === status) {
      return;
    }
    this._lastValue = value;
    this._lastStatus = status;
    let group = this._group;
    const handle = this._handle;
    if (!status || status === "hide") {
      group && group.hide();
      handle && handle.hide();
      return;
    }
    group && group.show();
    handle && handle.show();
    const elOption = {};
    this.makeElOption(elOption, value, axisModel, axisPointerModel, api2);
    const graphicKey = elOption.graphicKey;
    if (graphicKey !== this._lastGraphicKey) {
      this.clear(api2);
    }
    this._lastGraphicKey = graphicKey;
    const moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);
    if (!group) {
      group = this._group = new Group_default();
      this.createPointerEl(group, elOption, axisModel, axisPointerModel);
      this.createLabelEl(group, elOption, axisModel, axisPointerModel);
      api2.getZr().add(group);
    } else {
      const doUpdateProps = curry(updateProps2, axisPointerModel, moveAnimation);
      this.updatePointerEl(group, elOption, doUpdateProps);
      this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
    }
    updateMandatoryProps(group, axisPointerModel, true);
    this._renderHandle(value);
  }
  remove(api2) {
    this.clear(api2);
  }
  dispose(api2) {
    this.clear(api2);
  }
  determineAnimation(axisModel, axisPointerModel) {
    const animation = axisPointerModel.get("animation");
    const axis = axisModel.axis;
    const isCategoryAxis = axis.type === "category";
    const useSnap = axisPointerModel.get("snap");
    if (!useSnap && !isCategoryAxis) {
      return false;
    }
    if (animation === "auto" || animation == null) {
      const animationThreshold = this.animationThreshold;
      if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
        return true;
      }
      if (useSnap) {
        const seriesDataCount = getAxisInfo(axisModel).seriesDataCount;
        const axisExtent = axis.getExtent();
        return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
      }
      return false;
    }
    return animation === true;
  }
  makeElOption(elOption, value, axisModel, axisPointerModel, api2) {
  }
  createPointerEl(group, elOption, axisModel, axisPointerModel) {
    const pointerOption = elOption.pointer;
    if (pointerOption) {
      const pointerEl = inner11(group).pointerEl = new graphic_exports[pointerOption.type](clone4(elOption.pointer));
      group.add(pointerEl);
    }
  }
  createLabelEl(group, elOption, axisModel, axisPointerModel) {
    if (elOption.label) {
      const labelEl = inner11(group).labelEl = new Text_default(clone4(elOption.label));
      group.add(labelEl);
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  }
  updatePointerEl(group, elOption, updateProps3) {
    const pointerEl = inner11(group).pointerEl;
    if (pointerEl && elOption.pointer) {
      pointerEl.setStyle(elOption.pointer.style);
      updateProps3(pointerEl, {shape: elOption.pointer.shape});
    }
  }
  updateLabelEl(group, elOption, updateProps3, axisPointerModel) {
    const labelEl = inner11(group).labelEl;
    if (labelEl) {
      labelEl.setStyle(elOption.label.style);
      updateProps3(labelEl, {
        x: elOption.label.x,
        y: elOption.label.y
      });
      updateLabelShowHide(labelEl, axisPointerModel);
    }
  }
  _renderHandle(value) {
    if (this._dragging || !this.updateHandleTransform) {
      return;
    }
    const axisPointerModel = this._axisPointerModel;
    const zr = this._api.getZr();
    let handle = this._handle;
    const handleModel = axisPointerModel.getModel("handle");
    const status = axisPointerModel.get("status");
    if (!handleModel.get("show") || !status || status === "hide") {
      handle && zr.remove(handle);
      this._handle = null;
      return;
    }
    let isInit;
    if (!this._handle) {
      isInit = true;
      handle = this._handle = createIcon(handleModel.get("icon"), {
        cursor: "move",
        draggable: true,
        onmousemove(e2) {
          stop(e2.event);
        },
        onmousedown: bind2(this._onHandleDragMove, this, 0, 0),
        drift: bind2(this._onHandleDragMove, this),
        ondragend: bind2(this._onHandleDragEnd, this)
      });
      zr.add(handle);
    }
    updateMandatoryProps(handle, axisPointerModel, false);
    handle.setStyle(handleModel.getItemStyle(null, [
      "color",
      "borderColor",
      "borderWidth",
      "opacity",
      "shadowColor",
      "shadowBlur",
      "shadowOffsetX",
      "shadowOffsetY"
    ]));
    let handleSize = handleModel.get("size");
    if (!isArray(handleSize)) {
      handleSize = [handleSize, handleSize];
    }
    handle.scaleX = handleSize[0] / 2;
    handle.scaleY = handleSize[1] / 2;
    createOrUpdate(this, "_doDispatchAxisPointer", handleModel.get("throttle") || 0, "fixRate");
    this._moveHandleToValue(value, isInit);
  }
  _moveHandleToValue(value, isInit) {
    updateProps2(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
  }
  _onHandleDragMove(dx, dy) {
    const handle = this._handle;
    if (!handle) {
      return;
    }
    this._dragging = true;
    const trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
    this._payloadInfo = trans;
    handle.stopAnimation();
    handle.attr(getHandleTransProps(trans));
    inner11(handle).lastProp = null;
    this._doDispatchAxisPointer();
  }
  _doDispatchAxisPointer() {
    const handle = this._handle;
    if (!handle) {
      return;
    }
    const payloadInfo = this._payloadInfo;
    const axisModel = this._axisModel;
    this._api.dispatchAction({
      type: "updateAxisPointer",
      x: payloadInfo.cursorPoint[0],
      y: payloadInfo.cursorPoint[1],
      tooltipOption: payloadInfo.tooltipOption,
      axesInfo: [{
        axisDim: axisModel.axis.dim,
        axisIndex: axisModel.componentIndex
      }]
    });
  }
  _onHandleDragEnd() {
    this._dragging = false;
    const handle = this._handle;
    if (!handle) {
      return;
    }
    const value = this._axisPointerModel.get("value");
    this._moveHandleToValue(value);
    this._api.dispatchAction({
      type: "hideTip"
    });
  }
  clear(api2) {
    this._lastValue = null;
    this._lastStatus = null;
    const zr = api2.getZr();
    const group = this._group;
    const handle = this._handle;
    if (zr && group) {
      this._lastGraphicKey = null;
      group && zr.remove(group);
      handle && zr.remove(handle);
      this._group = null;
      this._handle = null;
      this._payloadInfo = null;
    }
    clear(this, "_doDispatchAxisPointer");
  }
  doClear() {
  }
  buildLabel(xy, wh, xDimIndex) {
    xDimIndex = xDimIndex || 0;
    return {
      x: xy[xDimIndex],
      y: xy[1 - xDimIndex],
      width: wh[xDimIndex],
      height: wh[1 - xDimIndex]
    };
  }
};
function updateProps2(animationModel, moveAnimation, el, props) {
  if (!propsEqual(inner11(el).lastProp, props)) {
    inner11(el).lastProp = props;
    moveAnimation ? updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));
  }
}
function propsEqual(lastProps, newProps) {
  if (isObject(lastProps) && isObject(newProps)) {
    let equals = true;
    each(newProps, function(item, key) {
      equals = equals && propsEqual(lastProps[key], item);
    });
    return !!equals;
  } else {
    return lastProps === newProps;
  }
}
function updateLabelShowHide(labelEl, axisPointerModel) {
  labelEl[axisPointerModel.get(["label", "show"]) ? "show" : "hide"]();
}
function getHandleTransProps(trans) {
  return {
    x: trans.x || 0,
    y: trans.y || 0,
    rotation: trans.rotation || 0
  };
}
function updateMandatoryProps(group, axisPointerModel, silent) {
  const z = axisPointerModel.get("z");
  const zlevel = axisPointerModel.get("zlevel");
  group && group.traverse(function(el) {
    if (el.type !== "group") {
      z != null && (el.z = z);
      zlevel != null && (el.zlevel = zlevel);
      el.silent = silent;
    }
  });
}
var BaseAxisPointer_default = BaseAxisPointer;

// src/component/axisPointer/viewHelper.ts
function buildElStyle(axisPointerModel) {
  const axisPointerType = axisPointerModel.get("type");
  const styleModel = axisPointerModel.getModel(axisPointerType + "Style");
  let style;
  if (axisPointerType === "line") {
    style = styleModel.getLineStyle();
    style.fill = null;
  } else if (axisPointerType === "shadow") {
    style = styleModel.getAreaStyle();
    style.stroke = null;
  }
  return style;
}
function buildLabelElOption(elOption, axisModel, axisPointerModel, api2, labelPos) {
  const value = axisPointerModel.get("value");
  const text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get("seriesDataIndices"), {
    precision: axisPointerModel.get(["label", "precision"]),
    formatter: axisPointerModel.get(["label", "formatter"])
  });
  const labelModel = axisPointerModel.getModel("label");
  const paddings = normalizeCssArray2(labelModel.get("padding") || 0);
  const font = labelModel.getFont();
  const textRect = getBoundingRect(text, font);
  const position2 = labelPos.position;
  const width = textRect.width + paddings[1] + paddings[3];
  const height = textRect.height + paddings[0] + paddings[2];
  const align = labelPos.align;
  align === "right" && (position2[0] -= width);
  align === "center" && (position2[0] -= width / 2);
  const verticalAlign = labelPos.verticalAlign;
  verticalAlign === "bottom" && (position2[1] -= height);
  verticalAlign === "middle" && (position2[1] -= height / 2);
  confineInContainer(position2, width, height, api2);
  let bgColor = labelModel.get("backgroundColor");
  if (!bgColor || bgColor === "auto") {
    bgColor = axisModel.get(["axisLine", "lineStyle", "color"]);
  }
  elOption.label = {
    x: position2[0],
    y: position2[1],
    style: createTextStyle(labelModel, {
      text,
      font,
      fill: labelModel.getTextColor(),
      padding: paddings,
      backgroundColor: bgColor
    }),
    z2: 10
  };
}
function confineInContainer(position2, width, height, api2) {
  const viewWidth = api2.getWidth();
  const viewHeight = api2.getHeight();
  position2[0] = Math.min(position2[0] + width, viewWidth) - width;
  position2[1] = Math.min(position2[1] + height, viewHeight) - height;
  position2[0] = Math.max(position2[0], 0);
  position2[1] = Math.max(position2[1], 0);
}
function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
  value = axis.scale.parse(value);
  let text = axis.scale.getLabel({
    value
  }, {
    precision: opt.precision
  });
  const formatter = opt.formatter;
  if (formatter) {
    const params = {
      value: getAxisRawValue(axis, {value}),
      axisDimension: axis.dim,
      axisIndex: axis.index,
      seriesData: []
    };
    each(seriesDataIndices, function(idxItem) {
      const series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
      const dataIndex = idxItem.dataIndexInside;
      const dataParams = series && series.getDataParams(dataIndex);
      dataParams && params.seriesData.push(dataParams);
    });
    if (isString(formatter)) {
      text = formatter.replace("{value}", text);
    } else if (isFunction(formatter)) {
      text = formatter(params);
    }
  }
  return text;
}
function getTransformedPosition(axis, value, layoutInfo) {
  const transform2 = create2();
  rotate(transform2, transform2, layoutInfo.rotation);
  translate(transform2, transform2, layoutInfo.position);
  return applyTransform2([
    axis.dataToCoord(value),
    (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)
  ], transform2);
}
function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api2) {
  const textLayout = AxisBuilder_default.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
  layoutInfo.labelMargin = axisPointerModel.get(["label", "margin"]);
  buildLabelElOption(elOption, axisModel, axisPointerModel, api2, {
    position: getTransformedPosition(axisModel.axis, value, layoutInfo),
    align: textLayout.textAlign,
    verticalAlign: textLayout.textVerticalAlign
  });
}
function makeLineShape(p1, p2, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x1: p1[xDimIndex],
    y1: p1[1 - xDimIndex],
    x2: p2[xDimIndex],
    y2: p2[1 - xDimIndex]
  };
}
function makeRectShape(xy, wh, xDimIndex) {
  xDimIndex = xDimIndex || 0;
  return {
    x: xy[xDimIndex],
    y: xy[1 - xDimIndex],
    width: wh[xDimIndex],
    height: wh[1 - xDimIndex]
  };
}
function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {
  return {
    cx,
    cy,
    r0,
    r,
    startAngle,
    endAngle,
    clockwise: true
  };
}

// src/component/axisPointer/CartesianAxisPointer.ts
var CartesianAxisPointer = class extends BaseAxisPointer_default {
  makeElOption(elOption, value, axisModel, axisPointerModel, api2) {
    const axis = axisModel.axis;
    const grid = axis.grid;
    const axisPointerType = axisPointerModel.get("type");
    const otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
    const pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));
    if (axisPointerType && axisPointerType !== "none") {
      const elStyle = buildElStyle(axisPointerModel);
      const pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }
    const layoutInfo = layout4(grid.model, axisModel);
    buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api2);
  }
  getHandleTransform(value, axisModel, axisPointerModel) {
    const layoutInfo = layout4(axisModel.axis.grid.model, axisModel, {
      labelInside: false
    });
    layoutInfo.labelMargin = axisPointerModel.get(["handle", "margin"]);
    const pos = getTransformedPosition(axisModel.axis, value, layoutInfo);
    return {
      x: pos[0],
      y: pos[1],
      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
    };
  }
  updateHandleTransform(transform2, delta, axisModel, axisPointerModel) {
    const axis = axisModel.axis;
    const grid = axis.grid;
    const axisExtent = axis.getGlobalExtent(true);
    const otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
    const dimIndex = axis.dim === "x" ? 0 : 1;
    const currPosition = [transform2.x, transform2.y];
    currPosition[dimIndex] += delta[dimIndex];
    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
    const cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
    const cursorPoint = [cursorOtherValue, cursorOtherValue];
    cursorPoint[dimIndex] = currPosition[dimIndex];
    const tooltipOptions = [
      {verticalAlign: "middle"},
      {align: "center"}
    ];
    return {
      x: currPosition[0],
      y: currPosition[1],
      rotation: transform2.rotation,
      cursorPoint,
      tooltipOption: tooltipOptions[dimIndex]
    };
  }
};
function getCartesian(grid, axis) {
  const opt = {};
  opt[axis.dim + "AxisIndex"] = axis.index;
  return grid.getCartesian(opt);
}
var pointerShapeBuilder = {
  line: function(axis, pixelValue, otherExtent) {
    const targetShape = makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));
    return {
      type: "Line",
      subPixelOptimize: true,
      shape: targetShape
    };
  },
  shadow: function(axis, pixelValue, otherExtent) {
    const bandWidth = Math.max(1, axis.getBandWidth());
    const span = otherExtent[1] - otherExtent[0];
    return {
      type: "Rect",
      shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
    };
  }
};
function getAxisDimIndex(axis) {
  return axis.dim === "x" ? 0 : 1;
}
var CartesianAxisPointer_default = CartesianAxisPointer;

// src/component/axisPointer/AxisPointerModel.ts
var AxisPointerModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = AxisPointerModel2.type;
  }
};
var AxisPointerModel = AxisPointerModel2;
AxisPointerModel.type = "axisPointer";
AxisPointerModel.defaultOption = {
  show: "auto",
  z: 50,
  type: "line",
  snap: false,
  triggerTooltip: true,
  triggerEmphasis: true,
  value: null,
  status: null,
  link: [],
  animation: null,
  animationDurationUpdate: 200,
  lineStyle: {
    color: "#B9BEC9",
    width: 1,
    type: "dashed"
  },
  shadowStyle: {
    color: "rgba(210,219,238,0.2)"
  },
  label: {
    show: true,
    formatter: null,
    precision: "auto",
    margin: 3,
    color: "#fff",
    padding: [5, 7, 5, 7],
    backgroundColor: "auto",
    borderColor: null,
    borderWidth: 0,
    borderRadius: 3
  },
  handle: {
    show: false,
    icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
    size: 45,
    margin: 50,
    color: "#333",
    shadowBlur: 3,
    shadowColor: "#aaa",
    shadowOffsetX: 0,
    shadowOffsetY: 2,
    throttle: 40
  }
};
var AxisPointerModel_default = AxisPointerModel;

// src/component/axisPointer/globalListener.ts
var inner12 = makeInner();
var each8 = each;
function register(key, api2, handler) {
  if (env_default.node) {
    return;
  }
  const zr = api2.getZr();
  inner12(zr).records || (inner12(zr).records = {});
  initGlobalListeners(zr, api2);
  const record = inner12(zr).records[key] || (inner12(zr).records[key] = {});
  record.handler = handler;
}
function initGlobalListeners(zr, api2) {
  if (inner12(zr).initialized) {
    return;
  }
  inner12(zr).initialized = true;
  useHandler("click", curry(doEnter, "click"));
  useHandler("mousemove", curry(doEnter, "mousemove"));
  useHandler("globalout", onLeave);
  function useHandler(eventType, cb) {
    zr.on(eventType, function(e2) {
      const dis = makeDispatchAction(api2);
      each8(inner12(zr).records, function(record) {
        record && cb(record, e2, dis.dispatchAction);
      });
      dispatchTooltipFinally(dis.pendings, api2);
    });
  }
}
function dispatchTooltipFinally(pendings, api2) {
  const showLen = pendings.showTip.length;
  const hideLen = pendings.hideTip.length;
  let actuallyPayload;
  if (showLen) {
    actuallyPayload = pendings.showTip[showLen - 1];
  } else if (hideLen) {
    actuallyPayload = pendings.hideTip[hideLen - 1];
  }
  if (actuallyPayload) {
    actuallyPayload.dispatchAction = null;
    api2.dispatchAction(actuallyPayload);
  }
}
function onLeave(record, e2, dispatchAction3) {
  record.handler("leave", null, dispatchAction3);
}
function doEnter(currTrigger, record, e2, dispatchAction3) {
  record.handler(currTrigger, e2, dispatchAction3);
}
function makeDispatchAction(api2) {
  const pendings = {
    showTip: [],
    hideTip: []
  };
  const dispatchAction3 = function(payload) {
    const pendingList = pendings[payload.type];
    if (pendingList) {
      pendingList.push(payload);
    } else {
      payload.dispatchAction = dispatchAction3;
      api2.dispatchAction(payload);
    }
  };
  return {
    dispatchAction: dispatchAction3,
    pendings
  };
}
function unregister(key, api2) {
  if (env_default.node) {
    return;
  }
  const zr = api2.getZr();
  const record = (inner12(zr).records || {})[key];
  if (record) {
    inner12(zr).records[key] = null;
  }
}

// src/component/axisPointer/AxisPointerView.ts
var AxisPointerView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = AxisPointerView2.type;
  }
  render(globalAxisPointerModel, ecModel, api2) {
    const globalTooltipModel = ecModel.getComponent("tooltip");
    const triggerOn = globalAxisPointerModel.get("triggerOn") || (globalTooltipModel && globalTooltipModel.get("triggerOn") || "mousemove|click");
    register("axisPointer", api2, function(currTrigger, e2, dispatchAction3) {
      if (triggerOn !== "none" && (currTrigger === "leave" || triggerOn.indexOf(currTrigger) >= 0)) {
        dispatchAction3({
          type: "updateAxisPointer",
          currTrigger,
          x: e2 && e2.offsetX,
          y: e2 && e2.offsetY
        });
      }
    });
  }
  remove(ecModel, api2) {
    unregister("axisPointer", api2);
  }
  dispose(ecModel, api2) {
    unregister("axisPointer", api2);
  }
};
var AxisPointerView = AxisPointerView2;
AxisPointerView.type = "axisPointer";
var AxisPointerView_default = AxisPointerView;

// src/component/axisPointer/findPointFromSeries.ts
function findPointFromSeries(finder, ecModel) {
  let point = [];
  const seriesIndex = finder.seriesIndex;
  let seriesModel;
  if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
    return {
      point: []
    };
  }
  const data = seriesModel.getData();
  const dataIndex = queryDataIndex(data, finder);
  if (dataIndex == null || dataIndex < 0 || isArray(dataIndex)) {
    return {point: []};
  }
  const el = data.getItemGraphicEl(dataIndex);
  const coordSys = seriesModel.coordinateSystem;
  if (seriesModel.getTooltipPosition) {
    point = seriesModel.getTooltipPosition(dataIndex) || [];
  } else if (coordSys && coordSys.dataToPoint) {
    if (finder.isStacked) {
      const baseAxis = coordSys.getBaseAxis();
      const valueAxis2 = coordSys.getOtherAxis(baseAxis);
      const valueAxisDim = valueAxis2.dim;
      const baseAxisDim = baseAxis.dim;
      const baseDataOffset = valueAxisDim === "x" || valueAxisDim === "radius" ? 1 : 0;
      const baseDim = data.mapDimension(baseAxisDim);
      const stackedData = [];
      stackedData[baseDataOffset] = data.get(baseDim, dataIndex);
      stackedData[1 - baseDataOffset] = data.get(data.getCalculationInfo("stackResultDimension"), dataIndex);
      point = coordSys.dataToPoint(stackedData) || [];
    } else {
      point = coordSys.dataToPoint(data.getValues(map(coordSys.dimensions, function(dim) {
        return data.mapDimension(dim);
      }), dataIndex)) || [];
    }
  } else if (el) {
    const rect = el.getBoundingRect().clone();
    rect.applyTransform(el.transform);
    point = [
      rect.x + rect.width / 2,
      rect.y + rect.height / 2
    ];
  }
  return {point, el};
}

// src/component/axisPointer/axisTrigger.ts
var inner13 = makeInner();
function axisTrigger(payload, ecModel, api2) {
  const currTrigger = payload.currTrigger;
  let point = [payload.x, payload.y];
  const finder = payload;
  const dispatchAction3 = payload.dispatchAction || bind(api2.dispatchAction, api2);
  const coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
  if (!coordSysAxesInfo) {
    return;
  }
  if (illegalPoint(point)) {
    point = findPointFromSeries({
      seriesIndex: finder.seriesIndex,
      dataIndex: finder.dataIndex
    }, ecModel).point;
  }
  const isIllegalPoint = illegalPoint(point);
  const inputAxesInfo = finder.axesInfo;
  const axesInfo = coordSysAxesInfo.axesInfo;
  const shouldHide = currTrigger === "leave" || illegalPoint(point);
  const outputPayload = {};
  const showValueMap = {};
  const dataByCoordSys = {
    list: [],
    map: {}
  };
  const updaters = {
    showPointer: curry(showPointer, showValueMap),
    showTooltip: curry(showTooltip, dataByCoordSys)
  };
  each(coordSysAxesInfo.coordSysMap, function(coordSys, coordSysKey) {
    const coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
    each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function(axisInfo, key) {
      const axis = axisInfo.axis;
      const inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);
      if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
        let val = inputAxisInfo && inputAxisInfo.value;
        if (val == null && !isIllegalPoint) {
          val = axis.pointToData(point);
        }
        val != null && processOnAxis(axisInfo, val, updaters, false, outputPayload);
      }
    });
  });
  const linkTriggers = {};
  each(axesInfo, function(tarAxisInfo, tarKey) {
    const linkGroup = tarAxisInfo.linkGroup;
    if (linkGroup && !showValueMap[tarKey]) {
      each(linkGroup.axesInfo, function(srcAxisInfo, srcKey) {
        const srcValItem = showValueMap[srcKey];
        if (srcAxisInfo !== tarAxisInfo && srcValItem) {
          let val = srcValItem.value;
          linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
          linkTriggers[tarAxisInfo.key] = val;
        }
      });
    }
  });
  each(linkTriggers, function(val, tarKey) {
    processOnAxis(axesInfo[tarKey], val, updaters, true, outputPayload);
  });
  updateModelActually(showValueMap, axesInfo, outputPayload);
  dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction3);
  dispatchHighDownActually(axesInfo, dispatchAction3, api2);
  return outputPayload;
}
function processOnAxis(axisInfo, newValue, updaters, noSnap, outputFinder) {
  const axis = axisInfo.axis;
  if (axis.scale.isBlank() || !axis.containData(newValue)) {
    return;
  }
  if (!axisInfo.involveSeries) {
    updaters.showPointer(axisInfo, newValue);
    return;
  }
  const payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
  const payloadBatch = payloadInfo.payloadBatch;
  const snapToValue = payloadInfo.snapToValue;
  if (payloadBatch[0] && outputFinder.seriesIndex == null) {
    extend(outputFinder, payloadBatch[0]);
  }
  if (!noSnap && axisInfo.snap) {
    if (axis.containData(snapToValue) && snapToValue != null) {
      newValue = snapToValue;
    }
  }
  updaters.showPointer(axisInfo, newValue, payloadBatch);
  updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
}
function buildPayloadsBySeries(value, axisInfo) {
  const axis = axisInfo.axis;
  const dim = axis.dim;
  let snapToValue = value;
  const payloadBatch = [];
  let minDist = Number.MAX_VALUE;
  let minDiff = -1;
  each(axisInfo.seriesModels, function(series, idx) {
    const dataDim = series.getData().mapDimensionsAll(dim);
    let seriesNestestValue;
    let dataIndices;
    if (series.getAxisTooltipData) {
      const result = series.getAxisTooltipData(dataDim, value, axis);
      dataIndices = result.dataIndices;
      seriesNestestValue = result.nestestValue;
    } else {
      dataIndices = series.getData().indicesOfNearest(dataDim[0], value, axis.type === "category" ? 0.5 : null);
      if (!dataIndices.length) {
        return;
      }
      seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
    }
    if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
      return;
    }
    const diff = value - seriesNestestValue;
    const dist3 = Math.abs(diff);
    if (dist3 <= minDist) {
      if (dist3 < minDist || diff >= 0 && minDiff < 0) {
        minDist = dist3;
        minDiff = diff;
        snapToValue = seriesNestestValue;
        payloadBatch.length = 0;
      }
      each(dataIndices, function(dataIndex) {
        payloadBatch.push({
          seriesIndex: series.seriesIndex,
          dataIndexInside: dataIndex,
          dataIndex: series.getData().getRawIndex(dataIndex)
        });
      });
    }
  });
  return {
    payloadBatch,
    snapToValue
  };
}
function showPointer(showValueMap, axisInfo, value, payloadBatch) {
  showValueMap[axisInfo.key] = {
    value,
    payloadBatch
  };
}
function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
  const payloadBatch = payloadInfo.payloadBatch;
  const axis = axisInfo.axis;
  const axisModel = axis.model;
  const axisPointerModel = axisInfo.axisPointerModel;
  if (!axisInfo.triggerTooltip || !payloadBatch.length) {
    return;
  }
  const coordSysModel = axisInfo.coordSys.model;
  const coordSysKey = makeKey(coordSysModel);
  let coordSysItem = dataByCoordSys.map[coordSysKey];
  if (!coordSysItem) {
    coordSysItem = dataByCoordSys.map[coordSysKey] = {
      coordSysId: coordSysModel.id,
      coordSysIndex: coordSysModel.componentIndex,
      coordSysType: coordSysModel.type,
      coordSysMainType: coordSysModel.mainType,
      dataByAxis: []
    };
    dataByCoordSys.list.push(coordSysItem);
  }
  coordSysItem.dataByAxis.push({
    axisDim: axis.dim,
    axisIndex: axisModel.componentIndex,
    axisType: axisModel.type,
    axisId: axisModel.id,
    value,
    valueLabelOpt: {
      precision: axisPointerModel.get(["label", "precision"]),
      formatter: axisPointerModel.get(["label", "formatter"])
    },
    seriesDataIndices: payloadBatch.slice()
  });
}
function updateModelActually(showValueMap, axesInfo, outputPayload) {
  const outputAxesInfo = outputPayload.axesInfo = [];
  each(axesInfo, function(axisInfo, key) {
    const option = axisInfo.axisPointerModel.option;
    const valItem = showValueMap[key];
    if (valItem) {
      !axisInfo.useHandle && (option.status = "show");
      option.value = valItem.value;
      option.seriesDataIndices = (valItem.payloadBatch || []).slice();
    } else {
      !axisInfo.useHandle && (option.status = "hide");
    }
    option.status === "show" && outputAxesInfo.push({
      axisDim: axisInfo.axis.dim,
      axisIndex: axisInfo.axis.model.componentIndex,
      value: option.value
    });
  });
}
function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction3) {
  if (illegalPoint(point) || !dataByCoordSys.list.length) {
    dispatchAction3({type: "hideTip"});
    return;
  }
  const sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  dispatchAction3({
    type: "showTip",
    escapeConnect: true,
    x: point[0],
    y: point[1],
    tooltipOption: payload.tooltipOption,
    position: payload.position,
    dataIndexInside: sampleItem.dataIndexInside,
    dataIndex: sampleItem.dataIndex,
    seriesIndex: sampleItem.seriesIndex,
    dataByCoordSys: dataByCoordSys.list
  });
}
function dispatchHighDownActually(axesInfo, dispatchAction3, api2) {
  const zr = api2.getZr();
  const highDownKey = "axisPointerLastHighlights";
  const lastHighlights = inner13(zr)[highDownKey] || {};
  const newHighlights = inner13(zr)[highDownKey] = {};
  each(axesInfo, function(axisInfo, key) {
    const option = axisInfo.axisPointerModel.option;
    option.status === "show" && axisInfo.triggerEmphasis && each(option.seriesDataIndices, function(batchItem) {
      const key2 = batchItem.seriesIndex + " | " + batchItem.dataIndex;
      newHighlights[key2] = batchItem;
    });
  });
  const toHighlight = [];
  const toDownplay = [];
  each(lastHighlights, function(batchItem, key) {
    !newHighlights[key] && toDownplay.push(batchItem);
  });
  each(newHighlights, function(batchItem, key) {
    !lastHighlights[key] && toHighlight.push(batchItem);
  });
  toDownplay.length && api2.dispatchAction({
    type: "downplay",
    escapeConnect: true,
    notBlur: true,
    batch: toDownplay
  });
  toHighlight.length && api2.dispatchAction({
    type: "highlight",
    escapeConnect: true,
    notBlur: true,
    batch: toHighlight
  });
}
function findInputAxisInfo(inputAxesInfo, axisInfo) {
  for (let i = 0; i < (inputAxesInfo || []).length; i++) {
    const inputAxisInfo = inputAxesInfo[i];
    if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
      return inputAxisInfo;
    }
  }
}
function makeMapperParam(axisInfo) {
  const axisModel = axisInfo.axis.model;
  const item = {};
  const dim = item.axisDim = axisInfo.axis.dim;
  item.axisIndex = item[dim + "AxisIndex"] = axisModel.componentIndex;
  item.axisName = item[dim + "AxisName"] = axisModel.name;
  item.axisId = item[dim + "AxisId"] = axisModel.id;
  return item;
}
function illegalPoint(point) {
  return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
}

// src/component/axisPointer/install.ts
function install29(registers) {
  AxisView_default.registerAxisPointerClass("CartesianAxisPointer", CartesianAxisPointer_default);
  registers.registerComponentModel(AxisPointerModel_default);
  registers.registerComponentView(AxisPointerView_default);
  registers.registerPreprocessor(function(option) {
    if (option) {
      (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
      const link = option.axisPointer.link;
      if (link && !isArray(link)) {
        option.axisPointer.link = [link];
      }
    }
  });
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, function(ecModel, api2) {
    ecModel.getComponent("axisPointer").coordSysAxesInfo = collect(ecModel, api2);
  });
  registers.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, axisTrigger);
}

// src/component/grid/install.ts
function install30(registers) {
  use(install6);
  use(install29);
}

// src/component/axisPointer/PolarAxisPointer.ts
var PolarAxisPointer = class extends BaseAxisPointer_default {
  makeElOption(elOption, value, axisModel, axisPointerModel, api2) {
    const axis = axisModel.axis;
    if (axis.dim === "angle") {
      this.animationThreshold = Math.PI / 18;
    }
    const polar = axis.polar;
    const otherAxis = polar.getOtherAxis(axis);
    const otherExtent = otherAxis.getExtent();
    const coordValue = axis.dataToCoord(value);
    const axisPointerType = axisPointerModel.get("type");
    if (axisPointerType && axisPointerType !== "none") {
      const elStyle = buildElStyle(axisPointerModel);
      const pointerOption = pointerShapeBuilder2[axisPointerType](axis, polar, coordValue, otherExtent);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }
    const labelMargin = axisPointerModel.get(["label", "margin"]);
    const labelPos = getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin);
    buildLabelElOption(elOption, axisModel, axisPointerModel, api2, labelPos);
  }
};
function getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin) {
  const axis = axisModel.axis;
  const coord = axis.dataToCoord(value);
  let axisAngle = polar.getAngleAxis().getExtent()[0];
  axisAngle = axisAngle / 180 * Math.PI;
  const radiusExtent = polar.getRadiusAxis().getExtent();
  let position2;
  let align;
  let verticalAlign;
  if (axis.dim === "radius") {
    const transform2 = create2();
    rotate(transform2, transform2, axisAngle);
    translate(transform2, transform2, [polar.cx, polar.cy]);
    position2 = applyTransform2([coord, -labelMargin], transform2);
    const labelRotation = axisModel.getModel("axisLabel").get("rotate") || 0;
    const labelLayout2 = AxisBuilder_default.innerTextLayout(axisAngle, labelRotation * Math.PI / 180, -1);
    align = labelLayout2.textAlign;
    verticalAlign = labelLayout2.textVerticalAlign;
  } else {
    const r = radiusExtent[1];
    position2 = polar.coordToPoint([r + labelMargin, coord]);
    const cx = polar.cx;
    const cy = polar.cy;
    align = Math.abs(position2[0] - cx) / r < 0.3 ? "center" : position2[0] > cx ? "left" : "right";
    verticalAlign = Math.abs(position2[1] - cy) / r < 0.3 ? "middle" : position2[1] > cy ? "top" : "bottom";
  }
  return {
    position: position2,
    align,
    verticalAlign
  };
}
var pointerShapeBuilder2 = {
  line: function(axis, polar, coordValue, otherExtent) {
    return axis.dim === "angle" ? {
      type: "Line",
      shape: makeLineShape(polar.coordToPoint([otherExtent[0], coordValue]), polar.coordToPoint([otherExtent[1], coordValue]))
    } : {
      type: "Circle",
      shape: {
        cx: polar.cx,
        cy: polar.cy,
        r: coordValue
      }
    };
  },
  shadow: function(axis, polar, coordValue, otherExtent) {
    const bandWidth = Math.max(1, axis.getBandWidth());
    const radian = Math.PI / 180;
    return axis.dim === "angle" ? {
      type: "Sector",
      shape: makeSectorShape(polar.cx, polar.cy, otherExtent[0], otherExtent[1], (-coordValue - bandWidth / 2) * radian, (-coordValue + bandWidth / 2) * radian)
    } : {
      type: "Sector",
      shape: makeSectorShape(polar.cx, polar.cy, coordValue - bandWidth / 2, coordValue + bandWidth / 2, 0, Math.PI * 2)
    };
  }
};
var PolarAxisPointer_default = PolarAxisPointer;

// src/coord/polar/PolarModel.ts
var PolarModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = PolarModel2.type;
  }
  findAxisModel(axisType) {
    let foundAxisModel;
    const ecModel = this.ecModel;
    ecModel.eachComponent(axisType, function(axisModel) {
      if (axisModel.getCoordSysModel() === this) {
        foundAxisModel = axisModel;
      }
    }, this);
    return foundAxisModel;
  }
};
var PolarModel = PolarModel2;
PolarModel.type = "polar";
PolarModel.dependencies = ["radiusAxis", "angleAxis"];
PolarModel.defaultOption = {
  z: 0,
  center: ["50%", "50%"],
  radius: "80%"
};
var PolarModel_default = PolarModel;

// src/coord/polar/AxisModel.ts
var PolarAxisModel = class extends Component_default {
  getCoordSysModel() {
    return this.getReferringComponents("polar", SINGLE_REFERRING).models[0];
  }
};
PolarAxisModel.type = "polarAxis";
mixin(PolarAxisModel, AxisModelCommonMixin);
var AngleAxisModel2 = class extends PolarAxisModel {
  constructor() {
    super(...arguments);
    this.type = AngleAxisModel2.type;
  }
};
var AngleAxisModel = AngleAxisModel2;
AngleAxisModel.type = "angleAxis";
var RadiusAxisModel2 = class extends PolarAxisModel {
  constructor() {
    super(...arguments);
    this.type = RadiusAxisModel2.type;
  }
};
var RadiusAxisModel = RadiusAxisModel2;
RadiusAxisModel.type = "radiusAxis";

// src/coord/polar/RadiusAxis.ts
var RadiusAxis = class extends Axis_default {
  constructor(scale4, radiusExtent) {
    super("radius", scale4, radiusExtent);
  }
  pointToData(point, clamp2) {
    return this.polar.pointToData(point, clamp2)[this.dim === "radius" ? 0 : 1];
  }
};
RadiusAxis.prototype.dataToRadius = Axis_default.prototype.dataToCoord;
RadiusAxis.prototype.radiusToData = Axis_default.prototype.coordToData;
var RadiusAxis_default = RadiusAxis;

// src/coord/polar/AngleAxis.ts
var inner14 = makeInner();
var AngleAxis = class extends Axis_default {
  constructor(scale4, angleExtent) {
    super("angle", scale4, angleExtent || [0, 360]);
  }
  pointToData(point, clamp2) {
    return this.polar.pointToData(point, clamp2)[this.dim === "radius" ? 0 : 1];
  }
  calculateCategoryInterval() {
    const axis = this;
    const labelModel = axis.getLabelModel();
    const ordinalScale = axis.scale;
    const ordinalExtent = ordinalScale.getExtent();
    const tickCount = ordinalScale.count();
    if (ordinalExtent[1] - ordinalExtent[0] < 1) {
      return 0;
    }
    const tickValue = ordinalExtent[0];
    const unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
    const unitH = Math.abs(unitSpan);
    const rect = getBoundingRect(tickValue == null ? "" : tickValue + "", labelModel.getFont(), "center", "top");
    const maxH = Math.max(rect.height, 7);
    let dh = maxH / unitH;
    isNaN(dh) && (dh = Infinity);
    let interval = Math.max(0, Math.floor(dh));
    const cache = inner14(axis.model);
    const lastAutoInterval = cache.lastAutoInterval;
    const lastTickCount = cache.lastTickCount;
    if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval) {
      interval = lastAutoInterval;
    } else {
      cache.lastTickCount = tickCount;
      cache.lastAutoInterval = interval;
    }
    return interval;
  }
};
AngleAxis.prototype.dataToAngle = Axis_default.prototype.dataToCoord;
AngleAxis.prototype.angleToData = Axis_default.prototype.coordToData;
var AngleAxis_default = AngleAxis;

// src/coord/polar/Polar.ts
var polarDimensions = ["radius", "angle"];
var Polar = class {
  constructor(name) {
    this.dimensions = polarDimensions;
    this.type = "polar";
    this.cx = 0;
    this.cy = 0;
    this._radiusAxis = new RadiusAxis_default();
    this._angleAxis = new AngleAxis_default();
    this.axisPointerEnabled = true;
    this.name = name || "";
    this._radiusAxis.polar = this._angleAxis.polar = this;
  }
  containPoint(point) {
    const coord = this.pointToCoord(point);
    return this._radiusAxis.contain(coord[0]) && this._angleAxis.contain(coord[1]);
  }
  containData(data) {
    return this._radiusAxis.containData(data[0]) && this._angleAxis.containData(data[1]);
  }
  getAxis(dim) {
    const key = "_" + dim + "Axis";
    return this[key];
  }
  getAxes() {
    return [this._radiusAxis, this._angleAxis];
  }
  getAxesByScale(scaleType) {
    const axes = [];
    const angleAxis = this._angleAxis;
    const radiusAxis = this._radiusAxis;
    angleAxis.scale.type === scaleType && axes.push(angleAxis);
    radiusAxis.scale.type === scaleType && axes.push(radiusAxis);
    return axes;
  }
  getAngleAxis() {
    return this._angleAxis;
  }
  getRadiusAxis() {
    return this._radiusAxis;
  }
  getOtherAxis(axis) {
    const angleAxis = this._angleAxis;
    return axis === angleAxis ? this._radiusAxis : angleAxis;
  }
  getBaseAxis() {
    return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
  }
  getTooltipAxes(dim) {
    const baseAxis = dim != null && dim !== "auto" ? this.getAxis(dim) : this.getBaseAxis();
    return {
      baseAxes: [baseAxis],
      otherAxes: [this.getOtherAxis(baseAxis)]
    };
  }
  dataToPoint(data, clamp2) {
    return this.coordToPoint([
      this._radiusAxis.dataToRadius(data[0], clamp2),
      this._angleAxis.dataToAngle(data[1], clamp2)
    ]);
  }
  pointToData(point, clamp2) {
    const coord = this.pointToCoord(point);
    return [
      this._radiusAxis.radiusToData(coord[0], clamp2),
      this._angleAxis.angleToData(coord[1], clamp2)
    ];
  }
  pointToCoord(point) {
    let dx = point[0] - this.cx;
    let dy = point[1] - this.cy;
    const angleAxis = this.getAngleAxis();
    const extent3 = angleAxis.getExtent();
    let minAngle = Math.min(extent3[0], extent3[1]);
    let maxAngle = Math.max(extent3[0], extent3[1]);
    angleAxis.inverse ? minAngle = maxAngle - 360 : maxAngle = minAngle + 360;
    const radius = Math.sqrt(dx * dx + dy * dy);
    dx /= radius;
    dy /= radius;
    let radian = Math.atan2(-dy, dx) / Math.PI * 180;
    const dir3 = radian < minAngle ? 1 : -1;
    while (radian < minAngle || radian > maxAngle) {
      radian += dir3 * 360;
    }
    return [radius, radian];
  }
  coordToPoint(coord) {
    const radius = coord[0];
    const radian = coord[1] / 180 * Math.PI;
    const x = Math.cos(radian) * radius + this.cx;
    const y = -Math.sin(radian) * radius + this.cy;
    return [x, y];
  }
  getArea() {
    const angleAxis = this.getAngleAxis();
    const radiusAxis = this.getRadiusAxis();
    const radiusExtent = radiusAxis.getExtent().slice();
    radiusExtent[0] > radiusExtent[1] && radiusExtent.reverse();
    const angleExtent = angleAxis.getExtent();
    const RADIAN4 = Math.PI / 180;
    return {
      cx: this.cx,
      cy: this.cy,
      r0: radiusExtent[0],
      r: radiusExtent[1],
      startAngle: -angleExtent[0] * RADIAN4,
      endAngle: -angleExtent[1] * RADIAN4,
      clockwise: angleAxis.inverse,
      contain(x, y) {
        const dx = x - this.cx;
        const dy = y - this.cy;
        const d2 = dx * dx + dy * dy - 1e-4;
        const r = this.r;
        const r0 = this.r0;
        return d2 <= r * r && d2 >= r0 * r0;
      }
    };
  }
  convertToPixel(ecModel, finder, value) {
    const coordSys = getCoordSys3(finder);
    return coordSys === this ? this.dataToPoint(value) : null;
  }
  convertFromPixel(ecModel, finder, pixel) {
    const coordSys = getCoordSys3(finder);
    return coordSys === this ? this.pointToData(pixel) : null;
  }
};
function getCoordSys3(finder) {
  const seriesModel = finder.seriesModel;
  const polarModel = finder.polarModel;
  return polarModel && polarModel.coordinateSystem || seriesModel && seriesModel.coordinateSystem;
}
var Polar_default = Polar;

// src/coord/polar/polarCreator.ts
function resizePolar(polar, polarModel, api2) {
  const center3 = polarModel.get("center");
  const width = api2.getWidth();
  const height = api2.getHeight();
  polar.cx = parsePercent2(center3[0], width);
  polar.cy = parsePercent2(center3[1], height);
  const radiusAxis = polar.getRadiusAxis();
  const size = Math.min(width, height) / 2;
  let radius = polarModel.get("radius");
  if (radius == null) {
    radius = [0, "100%"];
  } else if (!isArray(radius)) {
    radius = [0, radius];
  }
  const parsedRadius = [
    parsePercent2(radius[0], size),
    parsePercent2(radius[1], size)
  ];
  radiusAxis.inverse ? radiusAxis.setExtent(parsedRadius[1], parsedRadius[0]) : radiusAxis.setExtent(parsedRadius[0], parsedRadius[1]);
}
function updatePolarScale(ecModel, api2) {
  const polar = this;
  const angleAxis = polar.getAngleAxis();
  const radiusAxis = polar.getRadiusAxis();
  angleAxis.scale.setExtent(Infinity, -Infinity);
  radiusAxis.scale.setExtent(Infinity, -Infinity);
  ecModel.eachSeries(function(seriesModel) {
    if (seriesModel.coordinateSystem === polar) {
      const data = seriesModel.getData();
      each(getDataDimensionsOnAxis(data, "radius"), function(dim) {
        radiusAxis.scale.unionExtentFromData(data, dim);
      });
      each(getDataDimensionsOnAxis(data, "angle"), function(dim) {
        angleAxis.scale.unionExtentFromData(data, dim);
      });
    }
  });
  niceScaleExtent(angleAxis.scale, angleAxis.model);
  niceScaleExtent(radiusAxis.scale, radiusAxis.model);
  if (angleAxis.type === "category" && !angleAxis.onBand) {
    const extent3 = angleAxis.getExtent();
    const diff = 360 / angleAxis.scale.count();
    angleAxis.inverse ? extent3[1] += diff : extent3[1] -= diff;
    angleAxis.setExtent(extent3[0], extent3[1]);
  }
}
function isAngleAxisModel(axisModel) {
  return axisModel.mainType === "angleAxis";
}
function setAxis(axis, axisModel) {
  axis.type = axisModel.get("type");
  axis.scale = createScaleByModel(axisModel);
  axis.onBand = axisModel.get("boundaryGap") && axis.type === "category";
  axis.inverse = axisModel.get("inverse");
  if (isAngleAxisModel(axisModel)) {
    axis.inverse = axis.inverse !== axisModel.get("clockwise");
    const startAngle = axisModel.get("startAngle");
    const endAngle = axisModel.get("endAngle") ?? startAngle + (axis.inverse ? -360 : 360);
    axis.setExtent(startAngle, endAngle);
  }
  axisModel.axis = axis;
  axis.model = axisModel;
}
var polarCreator = {
  dimensions: polarDimensions,
  create: function(ecModel, api2) {
    const polarList = [];
    ecModel.eachComponent("polar", function(polarModel, idx) {
      const polar = new Polar_default(idx + "");
      polar.update = updatePolarScale;
      const radiusAxis = polar.getRadiusAxis();
      const angleAxis = polar.getAngleAxis();
      const radiusAxisModel = polarModel.findAxisModel("radiusAxis");
      const angleAxisModel = polarModel.findAxisModel("angleAxis");
      setAxis(radiusAxis, radiusAxisModel);
      setAxis(angleAxis, angleAxisModel);
      resizePolar(polar, polarModel, api2);
      polarList.push(polar);
      polarModel.coordinateSystem = polar;
      polar.model = polarModel;
    });
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.get("coordinateSystem") === "polar") {
        const polarModel = seriesModel.getReferringComponents("polar", SINGLE_REFERRING).models[0];
        if (true) {
          if (!polarModel) {
            throw new Error('Polar "' + retrieve(seriesModel.get("polarIndex"), seriesModel.get("polarId"), 0) + '" not found');
          }
        }
        seriesModel.coordinateSystem = polarModel.coordinateSystem;
      }
    });
    return polarList;
  }
};
var polarCreator_default = polarCreator;

// src/component/axis/AngleAxisView.ts
var elementList2 = [
  "axisLine",
  "axisLabel",
  "axisTick",
  "minorTick",
  "splitLine",
  "minorSplitLine",
  "splitArea"
];
function getAxisLineShape(polar, rExtent, angle) {
  rExtent[1] > rExtent[0] && (rExtent = rExtent.slice().reverse());
  const start2 = polar.coordToPoint([rExtent[0], angle]);
  const end2 = polar.coordToPoint([rExtent[1], angle]);
  return {
    x1: start2[0],
    y1: start2[1],
    x2: end2[0],
    y2: end2[1]
  };
}
function getRadiusIdx(polar) {
  const radiusAxis = polar.getRadiusAxis();
  return radiusAxis.inverse ? 0 : 1;
}
function fixAngleOverlap(list) {
  const firstItem = list[0];
  const lastItem = list[list.length - 1];
  if (firstItem && lastItem && Math.abs(Math.abs(firstItem.coord - lastItem.coord) - 360) < 1e-4) {
    list.pop();
  }
}
var AngleAxisView2 = class extends AxisView_default {
  constructor() {
    super(...arguments);
    this.type = AngleAxisView2.type;
    this.axisPointerClass = "PolarAxisPointer";
  }
  render(angleAxisModel, ecModel) {
    this.group.removeAll();
    if (!angleAxisModel.get("show")) {
      return;
    }
    const angleAxis = angleAxisModel.axis;
    const polar = angleAxis.polar;
    const radiusExtent = polar.getRadiusAxis().getExtent();
    const ticksAngles = angleAxis.getTicksCoords();
    const minorTickAngles = angleAxis.getMinorTicksCoords();
    const labels = map(angleAxis.getViewLabels(), function(labelItem) {
      labelItem = clone(labelItem);
      const scale4 = angleAxis.scale;
      const tickValue = scale4.type === "ordinal" ? scale4.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue;
      labelItem.coord = angleAxis.dataToCoord(tickValue);
      return labelItem;
    });
    fixAngleOverlap(labels);
    fixAngleOverlap(ticksAngles);
    each(elementList2, function(name) {
      if (angleAxisModel.get([name, "show"]) && (!angleAxis.scale.isBlank() || name === "axisLine")) {
        angelAxisElementsBuilders[name](this.group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels);
      }
    }, this);
  }
};
var AngleAxisView = AngleAxisView2;
AngleAxisView.type = "angleAxis";
var angelAxisElementsBuilders = {
  axisLine(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    const lineStyleModel = angleAxisModel.getModel(["axisLine", "lineStyle"]);
    const angleAxis = polar.getAngleAxis();
    const RADIAN4 = Math.PI / 180;
    const angleExtent = angleAxis.getExtent();
    const rId = getRadiusIdx(polar);
    const r0Id = rId ? 0 : 1;
    let shape;
    const shapeType = Math.abs(angleExtent[1] - angleExtent[0]) === 360 ? "Circle" : "Arc";
    if (radiusExtent[r0Id] === 0) {
      shape = new graphic_exports[shapeType]({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r: radiusExtent[rId],
          startAngle: -angleExtent[0] * RADIAN4,
          endAngle: -angleExtent[1] * RADIAN4,
          clockwise: angleAxis.inverse
        },
        style: lineStyleModel.getLineStyle(),
        z2: 1,
        silent: true
      });
    } else {
      shape = new Ring_default({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r: radiusExtent[rId],
          r0: radiusExtent[r0Id]
        },
        style: lineStyleModel.getLineStyle(),
        z2: 1,
        silent: true
      });
    }
    shape.style.fill = null;
    group.add(shape);
  },
  axisTick(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    const tickModel = angleAxisModel.getModel("axisTick");
    const tickLen = (tickModel.get("inside") ? -1 : 1) * tickModel.get("length");
    const radius = radiusExtent[getRadiusIdx(polar)];
    const lines = map(ticksAngles, function(tickAngleItem) {
      return new Line_default({
        shape: getAxisLineShape(polar, [radius, radius + tickLen], tickAngleItem.coord)
      });
    });
    group.add(mergePath2(lines, {
      style: defaults(tickModel.getModel("lineStyle").getLineStyle(), {
        stroke: angleAxisModel.get(["axisLine", "lineStyle", "color"])
      })
    }));
  },
  minorTick(group, angleAxisModel, polar, tickAngles, minorTickAngles, radiusExtent) {
    if (!minorTickAngles.length) {
      return;
    }
    const tickModel = angleAxisModel.getModel("axisTick");
    const minorTickModel = angleAxisModel.getModel("minorTick");
    const tickLen = (tickModel.get("inside") ? -1 : 1) * minorTickModel.get("length");
    const radius = radiusExtent[getRadiusIdx(polar)];
    const lines = [];
    for (let i = 0; i < minorTickAngles.length; i++) {
      for (let k = 0; k < minorTickAngles[i].length; k++) {
        lines.push(new Line_default({
          shape: getAxisLineShape(polar, [radius, radius + tickLen], minorTickAngles[i][k].coord)
        }));
      }
    }
    group.add(mergePath2(lines, {
      style: defaults(minorTickModel.getModel("lineStyle").getLineStyle(), defaults(tickModel.getLineStyle(), {
        stroke: angleAxisModel.get(["axisLine", "lineStyle", "color"])
      }))
    }));
  },
  axisLabel(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels) {
    const rawCategoryData = angleAxisModel.getCategories(true);
    const commonLabelModel = angleAxisModel.getModel("axisLabel");
    const labelMargin = commonLabelModel.get("margin");
    const triggerEvent = angleAxisModel.get("triggerEvent");
    each(labels, function(labelItem, idx) {
      let labelModel = commonLabelModel;
      const tickValue = labelItem.tickValue;
      const r = radiusExtent[getRadiusIdx(polar)];
      const p = polar.coordToPoint([r + labelMargin, labelItem.coord]);
      const cx = polar.cx;
      const cy = polar.cy;
      const labelTextAlign = Math.abs(p[0] - cx) / r < 0.3 ? "center" : p[0] > cx ? "left" : "right";
      const labelTextVerticalAlign = Math.abs(p[1] - cy) / r < 0.3 ? "middle" : p[1] > cy ? "top" : "bottom";
      if (rawCategoryData && rawCategoryData[tickValue]) {
        const rawCategoryItem = rawCategoryData[tickValue];
        if (isObject(rawCategoryItem) && rawCategoryItem.textStyle) {
          labelModel = new Model_default(rawCategoryItem.textStyle, commonLabelModel, commonLabelModel.ecModel);
        }
      }
      const textEl = new Text_default({
        silent: AxisBuilder_default.isLabelSilent(angleAxisModel),
        style: createTextStyle(labelModel, {
          x: p[0],
          y: p[1],
          fill: labelModel.getTextColor() || angleAxisModel.get(["axisLine", "lineStyle", "color"]),
          text: labelItem.formattedLabel,
          align: labelTextAlign,
          verticalAlign: labelTextVerticalAlign
        })
      });
      group.add(textEl);
      if (triggerEvent) {
        const eventData = AxisBuilder_default.makeAxisEventDataBase(angleAxisModel);
        eventData.targetType = "axisLabel";
        eventData.value = labelItem.rawLabel;
        getECData(textEl).eventData = eventData;
      }
    }, this);
  },
  splitLine(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    const splitLineModel = angleAxisModel.getModel("splitLine");
    const lineStyleModel = splitLineModel.getModel("lineStyle");
    let lineColors = lineStyleModel.get("color");
    let lineCount = 0;
    lineColors = lineColors instanceof Array ? lineColors : [lineColors];
    const splitLines = [];
    for (let i = 0; i < ticksAngles.length; i++) {
      const colorIndex = lineCount++ % lineColors.length;
      splitLines[colorIndex] = splitLines[colorIndex] || [];
      splitLines[colorIndex].push(new Line_default({
        shape: getAxisLineShape(polar, radiusExtent, ticksAngles[i].coord)
      }));
    }
    for (let i = 0; i < splitLines.length; i++) {
      group.add(mergePath2(splitLines[i], {
        style: defaults({
          stroke: lineColors[i % lineColors.length]
        }, lineStyleModel.getLineStyle()),
        silent: true,
        z: angleAxisModel.get("z")
      }));
    }
  },
  minorSplitLine(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    if (!minorTickAngles.length) {
      return;
    }
    const minorSplitLineModel = angleAxisModel.getModel("minorSplitLine");
    const lineStyleModel = minorSplitLineModel.getModel("lineStyle");
    const lines = [];
    for (let i = 0; i < minorTickAngles.length; i++) {
      for (let k = 0; k < minorTickAngles[i].length; k++) {
        lines.push(new Line_default({
          shape: getAxisLineShape(polar, radiusExtent, minorTickAngles[i][k].coord)
        }));
      }
    }
    group.add(mergePath2(lines, {
      style: lineStyleModel.getLineStyle(),
      silent: true,
      z: angleAxisModel.get("z")
    }));
  },
  splitArea(group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
    if (!ticksAngles.length) {
      return;
    }
    const splitAreaModel = angleAxisModel.getModel("splitArea");
    const areaStyleModel = splitAreaModel.getModel("areaStyle");
    let areaColors = areaStyleModel.get("color");
    let lineCount = 0;
    areaColors = areaColors instanceof Array ? areaColors : [areaColors];
    const splitAreas = [];
    const RADIAN4 = Math.PI / 180;
    let prevAngle = -ticksAngles[0].coord * RADIAN4;
    const r0 = Math.min(radiusExtent[0], radiusExtent[1]);
    const r1 = Math.max(radiusExtent[0], radiusExtent[1]);
    const clockwise = angleAxisModel.get("clockwise");
    for (let i = 1, len2 = ticksAngles.length; i <= len2; i++) {
      const coord = i === len2 ? ticksAngles[0].coord : ticksAngles[i].coord;
      const colorIndex = lineCount++ % areaColors.length;
      splitAreas[colorIndex] = splitAreas[colorIndex] || [];
      splitAreas[colorIndex].push(new Sector_default({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r0,
          r: r1,
          startAngle: prevAngle,
          endAngle: -coord * RADIAN4,
          clockwise
        },
        silent: true
      }));
      prevAngle = -coord * RADIAN4;
    }
    for (let i = 0; i < splitAreas.length; i++) {
      group.add(mergePath2(splitAreas[i], {
        style: defaults({
          fill: areaColors[i % areaColors.length]
        }, areaStyleModel.getAreaStyle()),
        silent: true
      }));
    }
  }
};
var AngleAxisView_default = AngleAxisView;

// src/component/axis/RadiusAxisView.ts
var axisBuilderAttrs3 = [
  "axisLine",
  "axisTickLabel",
  "axisName"
];
var selfBuilderAttrs2 = [
  "splitLine",
  "splitArea",
  "minorSplitLine"
];
var RadiusAxisView2 = class extends AxisView_default {
  constructor() {
    super(...arguments);
    this.type = RadiusAxisView2.type;
    this.axisPointerClass = "PolarAxisPointer";
  }
  render(radiusAxisModel, ecModel) {
    this.group.removeAll();
    if (!radiusAxisModel.get("show")) {
      return;
    }
    const oldAxisGroup = this._axisGroup;
    const newAxisGroup = this._axisGroup = new Group_default();
    this.group.add(newAxisGroup);
    const radiusAxis = radiusAxisModel.axis;
    const polar = radiusAxis.polar;
    const angleAxis = polar.getAngleAxis();
    const ticksCoords = radiusAxis.getTicksCoords();
    const minorTicksCoords = radiusAxis.getMinorTicksCoords();
    const axisAngle = angleAxis.getExtent()[0];
    const radiusExtent = radiusAxis.getExtent();
    const layout18 = layoutAxis(polar, radiusAxisModel, axisAngle);
    const axisBuilder = new AxisBuilder_default(radiusAxisModel, layout18);
    each(axisBuilderAttrs3, axisBuilder.add, axisBuilder);
    newAxisGroup.add(axisBuilder.getGroup());
    groupTransition(oldAxisGroup, newAxisGroup, radiusAxisModel);
    each(selfBuilderAttrs2, function(name) {
      if (radiusAxisModel.get([name, "show"]) && !radiusAxis.scale.isBlank()) {
        axisElementBuilders2[name](this.group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords);
      }
    }, this);
  }
};
var RadiusAxisView = RadiusAxisView2;
RadiusAxisView.type = "radiusAxis";
var axisElementBuilders2 = {
  splitLine(group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
    const splitLineModel = radiusAxisModel.getModel("splitLine");
    const lineStyleModel = splitLineModel.getModel("lineStyle");
    let lineColors = lineStyleModel.get("color");
    let lineCount = 0;
    const angleAxis = polar.getAngleAxis();
    const RADIAN4 = Math.PI / 180;
    const angleExtent = angleAxis.getExtent();
    const shapeType = Math.abs(angleExtent[1] - angleExtent[0]) === 360 ? "Circle" : "Arc";
    lineColors = lineColors instanceof Array ? lineColors : [lineColors];
    const splitLines = [];
    for (let i = 0; i < ticksCoords.length; i++) {
      const colorIndex = lineCount++ % lineColors.length;
      splitLines[colorIndex] = splitLines[colorIndex] || [];
      splitLines[colorIndex].push(new graphic_exports[shapeType]({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r: Math.max(ticksCoords[i].coord, 0),
          startAngle: -angleExtent[0] * RADIAN4,
          endAngle: -angleExtent[1] * RADIAN4,
          clockwise: angleAxis.inverse
        }
      }));
    }
    for (let i = 0; i < splitLines.length; i++) {
      group.add(mergePath2(splitLines[i], {
        style: defaults({
          stroke: lineColors[i % lineColors.length],
          fill: null
        }, lineStyleModel.getLineStyle()),
        silent: true
      }));
    }
  },
  minorSplitLine(group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords) {
    if (!minorTicksCoords.length) {
      return;
    }
    const minorSplitLineModel = radiusAxisModel.getModel("minorSplitLine");
    const lineStyleModel = minorSplitLineModel.getModel("lineStyle");
    const lines = [];
    for (let i = 0; i < minorTicksCoords.length; i++) {
      for (let k = 0; k < minorTicksCoords[i].length; k++) {
        lines.push(new Circle_default({
          shape: {
            cx: polar.cx,
            cy: polar.cy,
            r: minorTicksCoords[i][k].coord
          }
        }));
      }
    }
    group.add(mergePath2(lines, {
      style: defaults({
        fill: null
      }, lineStyleModel.getLineStyle()),
      silent: true
    }));
  },
  splitArea(group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
    if (!ticksCoords.length) {
      return;
    }
    const splitAreaModel = radiusAxisModel.getModel("splitArea");
    const areaStyleModel = splitAreaModel.getModel("areaStyle");
    let areaColors = areaStyleModel.get("color");
    let lineCount = 0;
    areaColors = areaColors instanceof Array ? areaColors : [areaColors];
    const splitAreas = [];
    let prevRadius = ticksCoords[0].coord;
    for (let i = 1; i < ticksCoords.length; i++) {
      const colorIndex = lineCount++ % areaColors.length;
      splitAreas[colorIndex] = splitAreas[colorIndex] || [];
      splitAreas[colorIndex].push(new Sector_default({
        shape: {
          cx: polar.cx,
          cy: polar.cy,
          r0: prevRadius,
          r: ticksCoords[i].coord,
          startAngle: 0,
          endAngle: Math.PI * 2
        },
        silent: true
      }));
      prevRadius = ticksCoords[i].coord;
    }
    for (let i = 0; i < splitAreas.length; i++) {
      group.add(mergePath2(splitAreas[i], {
        style: defaults({
          fill: areaColors[i % areaColors.length]
        }, areaStyleModel.getAreaStyle()),
        silent: true
      }));
    }
  }
};
function layoutAxis(polar, radiusAxisModel, axisAngle) {
  return {
    position: [polar.cx, polar.cy],
    rotation: axisAngle / 180 * Math.PI,
    labelDirection: -1,
    tickDirection: -1,
    nameDirection: 1,
    labelRotate: radiusAxisModel.getModel("axisLabel").get("rotate"),
    z2: 1
  };
}
var RadiusAxisView_default = RadiusAxisView;

// src/layout/barPolar.ts
function getSeriesStackId2(seriesModel) {
  return seriesModel.get("stack") || "__ec_stack_" + seriesModel.seriesIndex;
}
function getAxisKey2(polar, axis) {
  return axis.dim + polar.model.componentIndex;
}
function barLayoutPolar(seriesType2, ecModel, api2) {
  const lastStackCoords = {};
  const barWidthAndOffset = calRadialBar(filter(ecModel.getSeriesByType(seriesType2), function(seriesModel) {
    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === "polar";
  }));
  ecModel.eachSeriesByType(seriesType2, function(seriesModel) {
    if (seriesModel.coordinateSystem.type !== "polar") {
      return;
    }
    const data = seriesModel.getData();
    const polar = seriesModel.coordinateSystem;
    const baseAxis = polar.getBaseAxis();
    const axisKey = getAxisKey2(polar, baseAxis);
    const stackId = getSeriesStackId2(seriesModel);
    const columnLayoutInfo = barWidthAndOffset[axisKey][stackId];
    const columnOffset = columnLayoutInfo.offset;
    const columnWidth = columnLayoutInfo.width;
    const valueAxis2 = polar.getOtherAxis(baseAxis);
    const cx = seriesModel.coordinateSystem.cx;
    const cy = seriesModel.coordinateSystem.cy;
    const barMinHeight = seriesModel.get("barMinHeight") || 0;
    const barMinAngle = seriesModel.get("barMinAngle") || 0;
    lastStackCoords[stackId] = lastStackCoords[stackId] || [];
    const valueDim = data.mapDimension(valueAxis2.dim);
    const baseDim = data.mapDimension(baseAxis.dim);
    const stacked = isDimensionStacked(data, valueDim);
    const clampLayout = baseAxis.dim !== "radius" || !seriesModel.get("roundCap", true);
    const valueAxisStart = valueAxis2.dataToCoord(0);
    for (let idx = 0, len2 = data.count(); idx < len2; idx++) {
      const value = data.get(valueDim, idx);
      const baseValue = data.get(baseDim, idx);
      const sign = value >= 0 ? "p" : "n";
      let baseCoord = valueAxisStart;
      if (stacked) {
        if (!lastStackCoords[stackId][baseValue]) {
          lastStackCoords[stackId][baseValue] = {
            p: valueAxisStart,
            n: valueAxisStart
          };
        }
        baseCoord = lastStackCoords[stackId][baseValue][sign];
      }
      let r0;
      let r;
      let startAngle;
      let endAngle;
      if (valueAxis2.dim === "radius") {
        let radiusSpan = valueAxis2.dataToCoord(value) - valueAxisStart;
        const angle = baseAxis.dataToCoord(baseValue);
        if (Math.abs(radiusSpan) < barMinHeight) {
          radiusSpan = (radiusSpan < 0 ? -1 : 1) * barMinHeight;
        }
        r0 = baseCoord;
        r = baseCoord + radiusSpan;
        startAngle = angle - columnOffset;
        endAngle = startAngle - columnWidth;
        stacked && (lastStackCoords[stackId][baseValue][sign] = r);
      } else {
        let angleSpan = valueAxis2.dataToCoord(value, clampLayout) - valueAxisStart;
        const radius = baseAxis.dataToCoord(baseValue);
        if (Math.abs(angleSpan) < barMinAngle) {
          angleSpan = (angleSpan < 0 ? -1 : 1) * barMinAngle;
        }
        r0 = radius + columnOffset;
        r = r0 + columnWidth;
        startAngle = baseCoord;
        endAngle = baseCoord + angleSpan;
        stacked && (lastStackCoords[stackId][baseValue][sign] = endAngle);
      }
      data.setItemLayout(idx, {
        cx,
        cy,
        r0,
        r,
        startAngle: -startAngle * Math.PI / 180,
        endAngle: -endAngle * Math.PI / 180,
        clockwise: startAngle >= endAngle
      });
    }
  });
}
function calRadialBar(barSeries) {
  const columnsMap = {};
  each(barSeries, function(seriesModel, idx) {
    const data = seriesModel.getData();
    const polar = seriesModel.coordinateSystem;
    const baseAxis = polar.getBaseAxis();
    const axisKey = getAxisKey2(polar, baseAxis);
    const axisExtent = baseAxis.getExtent();
    const bandWidth = baseAxis.type === "category" ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
    const columnsOnAxis = columnsMap[axisKey] || {
      bandWidth,
      remainedWidth: bandWidth,
      autoWidthCount: 0,
      categoryGap: "20%",
      gap: "30%",
      stacks: {}
    };
    const stacks = columnsOnAxis.stacks;
    columnsMap[axisKey] = columnsOnAxis;
    const stackId = getSeriesStackId2(seriesModel);
    if (!stacks[stackId]) {
      columnsOnAxis.autoWidthCount++;
    }
    stacks[stackId] = stacks[stackId] || {
      width: 0,
      maxWidth: 0
    };
    let barWidth = parsePercent2(seriesModel.get("barWidth"), bandWidth);
    const barMaxWidth = parsePercent2(seriesModel.get("barMaxWidth"), bandWidth);
    const barGap = seriesModel.get("barGap");
    const barCategoryGap = seriesModel.get("barCategoryGap");
    if (barWidth && !stacks[stackId].width) {
      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
      stacks[stackId].width = barWidth;
      columnsOnAxis.remainedWidth -= barWidth;
    }
    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
    barGap != null && (columnsOnAxis.gap = barGap);
    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
  });
  const result = {};
  each(columnsMap, function(columnsOnAxis, coordSysName) {
    result[coordSysName] = {};
    const stacks = columnsOnAxis.stacks;
    const bandWidth = columnsOnAxis.bandWidth;
    const categoryGap = parsePercent2(columnsOnAxis.categoryGap, bandWidth);
    const barGapPercent = parsePercent2(columnsOnAxis.gap, 1);
    let remainedWidth = columnsOnAxis.remainedWidth;
    let autoWidthCount = columnsOnAxis.autoWidthCount;
    let autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    each(stacks, function(column, stack) {
      let maxWidth = column.maxWidth;
      if (maxWidth && maxWidth < autoWidth) {
        maxWidth = Math.min(maxWidth, remainedWidth);
        if (column.width) {
          maxWidth = Math.min(maxWidth, column.width);
        }
        remainedWidth -= maxWidth;
        column.width = maxWidth;
        autoWidthCount--;
      }
    });
    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
    autoWidth = Math.max(autoWidth, 0);
    let widthSum = 0;
    let lastColumn;
    each(stacks, function(column, idx) {
      if (!column.width) {
        column.width = autoWidth;
      }
      lastColumn = column;
      widthSum += column.width * (1 + barGapPercent);
    });
    if (lastColumn) {
      widthSum -= lastColumn.width * barGapPercent;
    }
    let offset = -widthSum / 2;
    each(stacks, function(column, stackId) {
      result[coordSysName][stackId] = result[coordSysName][stackId] || {
        offset,
        width: column.width
      };
      offset += column.width * (1 + barGapPercent);
    });
  });
  return result;
}
var barPolar_default = barLayoutPolar;

// src/component/polar/install.ts
var angleAxisExtraOption = {
  startAngle: 90,
  clockwise: true,
  splitNumber: 12,
  axisLabel: {
    rotate: 0
  }
};
var radiusAxisExtraOption = {
  splitNumber: 5
};
var PolarView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = PolarView2.type;
  }
};
var PolarView = PolarView2;
PolarView.type = "polar";
function install31(registers) {
  use(install29);
  AxisView_default.registerAxisPointerClass("PolarAxisPointer", PolarAxisPointer_default);
  registers.registerCoordinateSystem("polar", polarCreator_default);
  registers.registerComponentModel(PolarModel_default);
  registers.registerComponentView(PolarView);
  axisModelCreator(registers, "angle", AngleAxisModel, angleAxisExtraOption);
  axisModelCreator(registers, "radius", RadiusAxisModel, radiusAxisExtraOption);
  registers.registerComponentView(AngleAxisView_default);
  registers.registerComponentView(RadiusAxisView_default);
  registers.registerLayout(curry(barPolar_default, "bar"));
}

// src/coord/single/singleAxisHelper.ts
function layout11(axisModel, opt) {
  opt = opt || {};
  const single = axisModel.coordinateSystem;
  const axis = axisModel.axis;
  const layout18 = {};
  const axisPosition = axis.position;
  const orient = axis.orient;
  const rect = single.getRect();
  const rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
  const positionMap = {
    horizontal: {top: rectBound[2], bottom: rectBound[3]},
    vertical: {left: rectBound[0], right: rectBound[1]}
  };
  layout18.position = [
    orient === "vertical" ? positionMap.vertical[axisPosition] : rectBound[0],
    orient === "horizontal" ? positionMap.horizontal[axisPosition] : rectBound[3]
  ];
  const r = {horizontal: 0, vertical: 1};
  layout18.rotation = Math.PI / 2 * r[orient];
  const directionMap = {top: -1, bottom: 1, right: 1, left: -1};
  layout18.labelDirection = layout18.tickDirection = layout18.nameDirection = directionMap[axisPosition];
  if (axisModel.get(["axisTick", "inside"])) {
    layout18.tickDirection = -layout18.tickDirection;
  }
  if (retrieve(opt.labelInside, axisModel.get(["axisLabel", "inside"]))) {
    layout18.labelDirection = -layout18.labelDirection;
  }
  let labelRotation = opt.rotate;
  labelRotation == null && (labelRotation = axisModel.get(["axisLabel", "rotate"]));
  layout18.labelRotation = axisPosition === "top" ? -labelRotation : labelRotation;
  layout18.z2 = 1;
  return layout18;
}

// src/component/axis/SingleAxisView.ts
var axisBuilderAttrs4 = [
  "axisLine",
  "axisTickLabel",
  "axisName"
];
var selfBuilderAttrs3 = ["splitArea", "splitLine"];
var SingleAxisView2 = class extends AxisView_default {
  constructor() {
    super(...arguments);
    this.type = SingleAxisView2.type;
    this.axisPointerClass = "SingleAxisPointer";
  }
  render(axisModel, ecModel, api2, payload) {
    const group = this.group;
    group.removeAll();
    const oldAxisGroup = this._axisGroup;
    this._axisGroup = new Group_default();
    const layout18 = layout11(axisModel);
    const axisBuilder = new AxisBuilder_default(axisModel, layout18);
    each(axisBuilderAttrs4, axisBuilder.add, axisBuilder);
    group.add(this._axisGroup);
    group.add(axisBuilder.getGroup());
    each(selfBuilderAttrs3, function(name) {
      if (axisModel.get([name, "show"])) {
        axisElementBuilders3[name](this, this.group, this._axisGroup, axisModel);
      }
    }, this);
    groupTransition(oldAxisGroup, this._axisGroup, axisModel);
    super.render(axisModel, ecModel, api2, payload);
  }
  remove() {
    rectCoordAxisHandleRemove(this);
  }
};
var SingleAxisView = SingleAxisView2;
SingleAxisView.type = "singleAxis";
var axisElementBuilders3 = {
  splitLine(axisView, group, axisGroup, axisModel) {
    const axis = axisModel.axis;
    if (axis.scale.isBlank()) {
      return;
    }
    const splitLineModel = axisModel.getModel("splitLine");
    const lineStyleModel = splitLineModel.getModel("lineStyle");
    let lineColors = lineStyleModel.get("color");
    lineColors = lineColors instanceof Array ? lineColors : [lineColors];
    const lineWidth = lineStyleModel.get("width");
    const gridRect = axisModel.coordinateSystem.getRect();
    const isHorizontal = axis.isHorizontal();
    const splitLines = [];
    let lineCount = 0;
    const ticksCoords = axis.getTicksCoords({
      tickModel: splitLineModel
    });
    const p1 = [];
    const p2 = [];
    for (let i = 0; i < ticksCoords.length; ++i) {
      const tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
      if (isHorizontal) {
        p1[0] = tickCoord;
        p1[1] = gridRect.y;
        p2[0] = tickCoord;
        p2[1] = gridRect.y + gridRect.height;
      } else {
        p1[0] = gridRect.x;
        p1[1] = tickCoord;
        p2[0] = gridRect.x + gridRect.width;
        p2[1] = tickCoord;
      }
      const line2 = new Line_default({
        shape: {
          x1: p1[0],
          y1: p1[1],
          x2: p2[0],
          y2: p2[1]
        },
        silent: true
      });
      subPixelOptimizeLine2(line2.shape, lineWidth);
      const colorIndex = lineCount++ % lineColors.length;
      splitLines[colorIndex] = splitLines[colorIndex] || [];
      splitLines[colorIndex].push(line2);
    }
    const lineStyle = lineStyleModel.getLineStyle(["color"]);
    for (let i = 0; i < splitLines.length; ++i) {
      group.add(mergePath2(splitLines[i], {
        style: defaults({
          stroke: lineColors[i % lineColors.length]
        }, lineStyle),
        silent: true
      }));
    }
  },
  splitArea(axisView, group, axisGroup, axisModel) {
    rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, axisModel);
  }
};
var SingleAxisView_default = SingleAxisView;

// src/coord/single/AxisModel.ts
var SingleAxisModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = SingleAxisModel2.type;
  }
  getCoordSysModel() {
    return this;
  }
};
var SingleAxisModel = SingleAxisModel2;
SingleAxisModel.type = "singleAxis";
SingleAxisModel.layoutMode = "box";
SingleAxisModel.defaultOption = {
  left: "5%",
  top: "5%",
  right: "5%",
  bottom: "5%",
  type: "value",
  position: "bottom",
  orient: "horizontal",
  axisLine: {
    show: true,
    lineStyle: {
      width: 1,
      type: "solid"
    }
  },
  tooltip: {
    show: true
  },
  axisTick: {
    show: true,
    length: 6,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: true,
    interval: "auto"
  },
  splitLine: {
    show: true,
    lineStyle: {
      type: "dashed",
      opacity: 0.2
    }
  }
};
mixin(SingleAxisModel, AxisModelCommonMixin.prototype);
var AxisModel_default2 = SingleAxisModel;

// src/coord/single/SingleAxis.ts
var SingleAxis = class extends Axis_default {
  constructor(dim, scale4, coordExtent, axisType, position2) {
    super(dim, scale4, coordExtent);
    this.type = axisType || "value";
    this.position = position2 || "bottom";
  }
  isHorizontal() {
    const position2 = this.position;
    return position2 === "top" || position2 === "bottom";
  }
  pointToData(point, clamp2) {
    return this.coordinateSystem.pointToData(point)[0];
  }
};
var SingleAxis_default = SingleAxis;

// src/coord/single/Single.ts
var singleDimensions = ["single"];
var Single = class {
  constructor(axisModel, ecModel, api2) {
    this.type = "single";
    this.dimension = "single";
    this.dimensions = singleDimensions;
    this.axisPointerEnabled = true;
    this.model = axisModel;
    this._init(axisModel, ecModel, api2);
  }
  _init(axisModel, ecModel, api2) {
    const dim = this.dimension;
    const axis = new SingleAxis_default(dim, createScaleByModel(axisModel), [0, 0], axisModel.get("type"), axisModel.get("position"));
    const isCategory2 = axis.type === "category";
    axis.onBand = isCategory2 && axisModel.get("boundaryGap");
    axis.inverse = axisModel.get("inverse");
    axis.orient = axisModel.get("orient");
    axisModel.axis = axis;
    axis.model = axisModel;
    axis.coordinateSystem = this;
    this._axis = axis;
  }
  update(ecModel, api2) {
    ecModel.eachSeries(function(seriesModel) {
      if (seriesModel.coordinateSystem === this) {
        const data = seriesModel.getData();
        each(data.mapDimensionsAll(this.dimension), function(dim) {
          this._axis.scale.unionExtentFromData(data, dim);
        }, this);
        niceScaleExtent(this._axis.scale, this._axis.model);
      }
    }, this);
  }
  resize(axisModel, api2) {
    this._rect = getLayoutRect({
      left: axisModel.get("left"),
      top: axisModel.get("top"),
      right: axisModel.get("right"),
      bottom: axisModel.get("bottom"),
      width: axisModel.get("width"),
      height: axisModel.get("height")
    }, {
      width: api2.getWidth(),
      height: api2.getHeight()
    });
    this._adjustAxis();
  }
  getRect() {
    return this._rect;
  }
  _adjustAxis() {
    const rect = this._rect;
    const axis = this._axis;
    const isHorizontal = axis.isHorizontal();
    const extent3 = isHorizontal ? [0, rect.width] : [0, rect.height];
    const idx = axis.inverse ? 1 : 0;
    axis.setExtent(extent3[idx], extent3[1 - idx]);
    this._updateAxisTransform(axis, isHorizontal ? rect.x : rect.y);
  }
  _updateAxisTransform(axis, coordBase) {
    const axisExtent = axis.getExtent();
    const extentSum = axisExtent[0] + axisExtent[1];
    const isHorizontal = axis.isHorizontal();
    axis.toGlobalCoord = isHorizontal ? function(coord) {
      return coord + coordBase;
    } : function(coord) {
      return extentSum - coord + coordBase;
    };
    axis.toLocalCoord = isHorizontal ? function(coord) {
      return coord - coordBase;
    } : function(coord) {
      return extentSum - coord + coordBase;
    };
  }
  getAxis() {
    return this._axis;
  }
  getBaseAxis() {
    return this._axis;
  }
  getAxes() {
    return [this._axis];
  }
  getTooltipAxes() {
    return {
      baseAxes: [this.getAxis()],
      otherAxes: []
    };
  }
  containPoint(point) {
    const rect = this.getRect();
    const axis = this.getAxis();
    const orient = axis.orient;
    if (orient === "horizontal") {
      return axis.contain(axis.toLocalCoord(point[0])) && (point[1] >= rect.y && point[1] <= rect.y + rect.height);
    } else {
      return axis.contain(axis.toLocalCoord(point[1])) && (point[0] >= rect.y && point[0] <= rect.y + rect.height);
    }
  }
  pointToData(point) {
    const axis = this.getAxis();
    return [axis.coordToData(axis.toLocalCoord(point[axis.orient === "horizontal" ? 0 : 1]))];
  }
  dataToPoint(val) {
    const axis = this.getAxis();
    const rect = this.getRect();
    const pt = [];
    const idx = axis.orient === "horizontal" ? 0 : 1;
    if (val instanceof Array) {
      val = val[0];
    }
    pt[idx] = axis.toGlobalCoord(axis.dataToCoord(+val));
    pt[1 - idx] = idx === 0 ? rect.y + rect.height / 2 : rect.x + rect.width / 2;
    return pt;
  }
  convertToPixel(ecModel, finder, value) {
    const coordSys = getCoordSys4(finder);
    return coordSys === this ? this.dataToPoint(value) : null;
  }
  convertFromPixel(ecModel, finder, pixel) {
    const coordSys = getCoordSys4(finder);
    return coordSys === this ? this.pointToData(pixel) : null;
  }
};
function getCoordSys4(finder) {
  const seriesModel = finder.seriesModel;
  const singleModel = finder.singleAxisModel;
  return singleModel && singleModel.coordinateSystem || seriesModel && seriesModel.coordinateSystem;
}
var Single_default = Single;

// src/coord/single/singleCreator.ts
function create3(ecModel, api2) {
  const singles = [];
  ecModel.eachComponent("singleAxis", function(axisModel, idx) {
    const single = new Single_default(axisModel, ecModel, api2);
    single.name = "single_" + idx;
    single.resize(axisModel, api2);
    axisModel.coordinateSystem = single;
    singles.push(single);
  });
  ecModel.eachSeries(function(seriesModel) {
    if (seriesModel.get("coordinateSystem") === "singleAxis") {
      const singleAxisModel = seriesModel.getReferringComponents("singleAxis", SINGLE_REFERRING).models[0];
      seriesModel.coordinateSystem = singleAxisModel && singleAxisModel.coordinateSystem;
    }
  });
  return singles;
}
var singleCreator = {
  create: create3,
  dimensions: singleDimensions
};
var singleCreator_default = singleCreator;

// src/component/axisPointer/SingleAxisPointer.ts
var XY = ["x", "y"];
var WH = ["width", "height"];
var SingleAxisPointer = class extends BaseAxisPointer_default {
  makeElOption(elOption, value, axisModel, axisPointerModel, api2) {
    const axis = axisModel.axis;
    const coordSys = axis.coordinateSystem;
    const otherExtent = getGlobalExtent(coordSys, 1 - getPointDimIndex(axis));
    const pixelValue = coordSys.dataToPoint(value)[0];
    const axisPointerType = axisPointerModel.get("type");
    if (axisPointerType && axisPointerType !== "none") {
      const elStyle = buildElStyle(axisPointerModel);
      const pointerOption = pointerShapeBuilder3[axisPointerType](axis, pixelValue, otherExtent);
      pointerOption.style = elStyle;
      elOption.graphicKey = pointerOption.type;
      elOption.pointer = pointerOption;
    }
    const layoutInfo = layout11(axisModel);
    buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api2);
  }
  getHandleTransform(value, axisModel, axisPointerModel) {
    const layoutInfo = layout11(axisModel, {labelInside: false});
    layoutInfo.labelMargin = axisPointerModel.get(["handle", "margin"]);
    const position2 = getTransformedPosition(axisModel.axis, value, layoutInfo);
    return {
      x: position2[0],
      y: position2[1],
      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
    };
  }
  updateHandleTransform(transform2, delta, axisModel, axisPointerModel) {
    const axis = axisModel.axis;
    const coordSys = axis.coordinateSystem;
    const dimIndex = getPointDimIndex(axis);
    const axisExtent = getGlobalExtent(coordSys, dimIndex);
    const currPosition = [transform2.x, transform2.y];
    currPosition[dimIndex] += delta[dimIndex];
    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
    const otherExtent = getGlobalExtent(coordSys, 1 - dimIndex);
    const cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
    const cursorPoint = [cursorOtherValue, cursorOtherValue];
    cursorPoint[dimIndex] = currPosition[dimIndex];
    return {
      x: currPosition[0],
      y: currPosition[1],
      rotation: transform2.rotation,
      cursorPoint,
      tooltipOption: {
        verticalAlign: "middle"
      }
    };
  }
};
var pointerShapeBuilder3 = {
  line: function(axis, pixelValue, otherExtent) {
    const targetShape = makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getPointDimIndex(axis));
    return {
      type: "Line",
      subPixelOptimize: true,
      shape: targetShape
    };
  },
  shadow: function(axis, pixelValue, otherExtent) {
    const bandWidth = axis.getBandWidth();
    const span = otherExtent[1] - otherExtent[0];
    return {
      type: "Rect",
      shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getPointDimIndex(axis))
    };
  }
};
function getPointDimIndex(axis) {
  return axis.isHorizontal() ? 0 : 1;
}
function getGlobalExtent(coordSys, dimIndex) {
  const rect = coordSys.getRect();
  return [rect[XY[dimIndex]], rect[XY[dimIndex]] + rect[WH[dimIndex]]];
}
var SingleAxisPointer_default = SingleAxisPointer;

// src/component/singleAxis/install.ts
var SingleView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = SingleView2.type;
  }
};
var SingleView = SingleView2;
SingleView.type = "single";
function install32(registers) {
  use(install29);
  AxisView_default.registerAxisPointerClass("SingleAxisPointer", SingleAxisPointer_default);
  registers.registerComponentView(SingleView);
  registers.registerComponentView(SingleAxisView_default);
  registers.registerComponentModel(AxisModel_default2);
  axisModelCreator(registers, "single", AxisModel_default2, AxisModel_default2.defaultOption);
  registers.registerCoordinateSystem("single", singleCreator_default);
}

// src/coord/calendar/CalendarModel.ts
var CalendarModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = CalendarModel2.type;
  }
  init(option, parentModel, ecModel) {
    const inputPositionParams = getLayoutParams(option);
    super.init.apply(this, arguments);
    mergeAndNormalizeLayoutParams(option, inputPositionParams);
  }
  mergeOption(option) {
    super.mergeOption.apply(this, arguments);
    mergeAndNormalizeLayoutParams(this.option, option);
  }
  getCellSize() {
    return this.option.cellSize;
  }
};
var CalendarModel = CalendarModel2;
CalendarModel.type = "calendar";
CalendarModel.defaultOption = {
  z: 2,
  left: 80,
  top: 60,
  cellSize: 20,
  orient: "horizontal",
  splitLine: {
    show: true,
    lineStyle: {
      color: "#000",
      width: 1,
      type: "solid"
    }
  },
  itemStyle: {
    color: "#fff",
    borderWidth: 1,
    borderColor: "#ccc"
  },
  dayLabel: {
    show: true,
    firstDay: 0,
    position: "start",
    margin: "50%",
    color: "#000"
  },
  monthLabel: {
    show: true,
    position: "start",
    margin: 5,
    align: "center",
    formatter: null,
    color: "#000"
  },
  yearLabel: {
    show: true,
    position: null,
    margin: 30,
    formatter: null,
    color: "#ccc",
    fontFamily: "sans-serif",
    fontWeight: "bolder",
    fontSize: 20
  }
};
function mergeAndNormalizeLayoutParams(target, raw) {
  const cellSize = target.cellSize;
  let cellSizeArr;
  if (!isArray(cellSize)) {
    cellSizeArr = target.cellSize = [cellSize, cellSize];
  } else {
    cellSizeArr = cellSize;
  }
  if (cellSizeArr.length === 1) {
    cellSizeArr[1] = cellSizeArr[0];
  }
  const ignoreSize = map([0, 1], function(hvIdx) {
    if (sizeCalculable(raw, hvIdx)) {
      cellSizeArr[hvIdx] = "auto";
    }
    return cellSizeArr[hvIdx] != null && cellSizeArr[hvIdx] !== "auto";
  });
  mergeLayoutParam(target, raw, {
    type: "box",
    ignoreSize
  });
}
var CalendarModel_default = CalendarModel;

// src/component/calendar/CalendarView.ts
var CalendarView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = CalendarView2.type;
  }
  render(calendarModel, ecModel, api2) {
    const group = this.group;
    group.removeAll();
    const coordSys = calendarModel.coordinateSystem;
    const rangeData = coordSys.getRangeInfo();
    const orient = coordSys.getOrient();
    const localeModel = ecModel.getLocaleModel();
    this._renderDayRect(calendarModel, rangeData, group);
    this._renderLines(calendarModel, rangeData, orient, group);
    this._renderYearText(calendarModel, rangeData, orient, group);
    this._renderMonthText(calendarModel, localeModel, orient, group);
    this._renderWeekText(calendarModel, localeModel, rangeData, orient, group);
  }
  _renderDayRect(calendarModel, rangeData, group) {
    const coordSys = calendarModel.coordinateSystem;
    const itemRectStyleModel = calendarModel.getModel("itemStyle").getItemStyle();
    const sw = coordSys.getCellWidth();
    const sh = coordSys.getCellHeight();
    for (let i = rangeData.start.time; i <= rangeData.end.time; i = coordSys.getNextNDay(i, 1).time) {
      const point = coordSys.dataToRect([i], false).tl;
      const rect = new Rect_default({
        shape: {
          x: point[0],
          y: point[1],
          width: sw,
          height: sh
        },
        cursor: "default",
        style: itemRectStyleModel
      });
      group.add(rect);
    }
  }
  _renderLines(calendarModel, rangeData, orient, group) {
    const self2 = this;
    const coordSys = calendarModel.coordinateSystem;
    const lineStyleModel = calendarModel.getModel(["splitLine", "lineStyle"]).getLineStyle();
    const show = calendarModel.get(["splitLine", "show"]);
    const lineWidth = lineStyleModel.lineWidth;
    this._tlpoints = [];
    this._blpoints = [];
    this._firstDayOfMonth = [];
    this._firstDayPoints = [];
    let firstDay = rangeData.start;
    for (let i = 0; firstDay.time <= rangeData.end.time; i++) {
      addPoints(firstDay.formatedDate);
      if (i === 0) {
        firstDay = coordSys.getDateInfo(rangeData.start.y + "-" + rangeData.start.m);
      }
      const date = firstDay.date;
      date.setMonth(date.getMonth() + 1);
      firstDay = coordSys.getDateInfo(date);
    }
    addPoints(coordSys.getNextNDay(rangeData.end.time, 1).formatedDate);
    function addPoints(date) {
      self2._firstDayOfMonth.push(coordSys.getDateInfo(date));
      self2._firstDayPoints.push(coordSys.dataToRect([date], false).tl);
      const points4 = self2._getLinePointsOfOneWeek(calendarModel, date, orient);
      self2._tlpoints.push(points4[0]);
      self2._blpoints.push(points4[points4.length - 1]);
      show && self2._drawSplitline(points4, lineStyleModel, group);
    }
    show && this._drawSplitline(self2._getEdgesPoints(self2._tlpoints, lineWidth, orient), lineStyleModel, group);
    show && this._drawSplitline(self2._getEdgesPoints(self2._blpoints, lineWidth, orient), lineStyleModel, group);
  }
  _getEdgesPoints(points4, lineWidth, orient) {
    const rs = [points4[0].slice(), points4[points4.length - 1].slice()];
    const idx = orient === "horizontal" ? 0 : 1;
    rs[0][idx] = rs[0][idx] - lineWidth / 2;
    rs[1][idx] = rs[1][idx] + lineWidth / 2;
    return rs;
  }
  _drawSplitline(points4, lineStyle, group) {
    const poyline = new Polyline_default({
      z2: 20,
      shape: {
        points: points4
      },
      style: lineStyle
    });
    group.add(poyline);
  }
  _getLinePointsOfOneWeek(calendarModel, date, orient) {
    const coordSys = calendarModel.coordinateSystem;
    const parsedDate = coordSys.getDateInfo(date);
    const points4 = [];
    for (let i = 0; i < 7; i++) {
      const tmpD = coordSys.getNextNDay(parsedDate.time, i);
      const point = coordSys.dataToRect([tmpD.time], false);
      points4[2 * tmpD.day] = point.tl;
      points4[2 * tmpD.day + 1] = point[orient === "horizontal" ? "bl" : "tr"];
    }
    return points4;
  }
  _formatterLabel(formatter, params) {
    if (isString(formatter) && formatter) {
      return formatTplSimple(formatter, params);
    }
    if (isFunction(formatter)) {
      return formatter(params);
    }
    return params.nameMap;
  }
  _yearTextPositionControl(textEl, point, orient, position2, margin) {
    let x = point[0];
    let y = point[1];
    let aligns = ["center", "bottom"];
    if (position2 === "bottom") {
      y += margin;
      aligns = ["center", "top"];
    } else if (position2 === "left") {
      x -= margin;
    } else if (position2 === "right") {
      x += margin;
      aligns = ["center", "top"];
    } else {
      y -= margin;
    }
    let rotate2 = 0;
    if (position2 === "left" || position2 === "right") {
      rotate2 = Math.PI / 2;
    }
    return {
      rotation: rotate2,
      x,
      y,
      style: {
        align: aligns[0],
        verticalAlign: aligns[1]
      }
    };
  }
  _renderYearText(calendarModel, rangeData, orient, group) {
    const yearLabel = calendarModel.getModel("yearLabel");
    if (!yearLabel.get("show")) {
      return;
    }
    const margin = yearLabel.get("margin");
    let pos = yearLabel.get("position");
    if (!pos) {
      pos = orient !== "horizontal" ? "top" : "left";
    }
    const points4 = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]];
    const xc = (points4[0][0] + points4[1][0]) / 2;
    const yc = (points4[0][1] + points4[1][1]) / 2;
    const idx = orient === "horizontal" ? 0 : 1;
    const posPoints = {
      top: [xc, points4[idx][1]],
      bottom: [xc, points4[1 - idx][1]],
      left: [points4[1 - idx][0], yc],
      right: [points4[idx][0], yc]
    };
    let name = rangeData.start.y;
    if (+rangeData.end.y > +rangeData.start.y) {
      name = name + "-" + rangeData.end.y;
    }
    const formatter = yearLabel.get("formatter");
    const params = {
      start: rangeData.start.y,
      end: rangeData.end.y,
      nameMap: name
    };
    const content = this._formatterLabel(formatter, params);
    const yearText = new Text_default({
      z2: 30,
      style: createTextStyle(yearLabel, {
        text: content
      })
    });
    yearText.attr(this._yearTextPositionControl(yearText, posPoints[pos], orient, pos, margin));
    group.add(yearText);
  }
  _monthTextPositionControl(point, isCenter, orient, position2, margin) {
    let align = "left";
    let vAlign = "top";
    let x = point[0];
    let y = point[1];
    if (orient === "horizontal") {
      y = y + margin;
      if (isCenter) {
        align = "center";
      }
      if (position2 === "start") {
        vAlign = "bottom";
      }
    } else {
      x = x + margin;
      if (isCenter) {
        vAlign = "middle";
      }
      if (position2 === "start") {
        align = "right";
      }
    }
    return {
      x,
      y,
      align,
      verticalAlign: vAlign
    };
  }
  _renderMonthText(calendarModel, localeModel, orient, group) {
    const monthLabel = calendarModel.getModel("monthLabel");
    if (!monthLabel.get("show")) {
      return;
    }
    let nameMap = monthLabel.get("nameMap");
    let margin = monthLabel.get("margin");
    const pos = monthLabel.get("position");
    const align = monthLabel.get("align");
    const termPoints = [this._tlpoints, this._blpoints];
    if (!nameMap || isString(nameMap)) {
      if (nameMap) {
        localeModel = getLocaleModel(nameMap) || localeModel;
      }
      nameMap = localeModel.get(["time", "monthAbbr"]) || [];
    }
    const idx = pos === "start" ? 0 : 1;
    const axis = orient === "horizontal" ? 0 : 1;
    margin = pos === "start" ? -margin : margin;
    const isCenter = align === "center";
    for (let i = 0; i < termPoints[idx].length - 1; i++) {
      const tmp = termPoints[idx][i].slice();
      const firstDay = this._firstDayOfMonth[i];
      if (isCenter) {
        const firstDayPoints = this._firstDayPoints[i];
        tmp[axis] = (firstDayPoints[axis] + termPoints[0][i + 1][axis]) / 2;
      }
      const formatter = monthLabel.get("formatter");
      const name = nameMap[+firstDay.m - 1];
      const params = {
        yyyy: firstDay.y,
        yy: (firstDay.y + "").slice(2),
        MM: firstDay.m,
        M: +firstDay.m,
        nameMap: name
      };
      const content = this._formatterLabel(formatter, params);
      const monthText = new Text_default({
        z2: 30,
        style: extend(createTextStyle(monthLabel, {text: content}), this._monthTextPositionControl(tmp, isCenter, orient, pos, margin))
      });
      group.add(monthText);
    }
  }
  _weekTextPositionControl(point, orient, position2, margin, cellSize) {
    let align = "center";
    let vAlign = "middle";
    let x = point[0];
    let y = point[1];
    const isStart = position2 === "start";
    if (orient === "horizontal") {
      x = x + margin + (isStart ? 1 : -1) * cellSize[0] / 2;
      align = isStart ? "right" : "left";
    } else {
      y = y + margin + (isStart ? 1 : -1) * cellSize[1] / 2;
      vAlign = isStart ? "bottom" : "top";
    }
    return {
      x,
      y,
      align,
      verticalAlign: vAlign
    };
  }
  _renderWeekText(calendarModel, localeModel, rangeData, orient, group) {
    const dayLabel = calendarModel.getModel("dayLabel");
    if (!dayLabel.get("show")) {
      return;
    }
    const coordSys = calendarModel.coordinateSystem;
    const pos = dayLabel.get("position");
    let nameMap = dayLabel.get("nameMap");
    let margin = dayLabel.get("margin");
    const firstDayOfWeek = coordSys.getFirstDayOfWeek();
    if (!nameMap || isString(nameMap)) {
      if (nameMap) {
        localeModel = getLocaleModel(nameMap) || localeModel;
      }
      const dayOfWeekShort = localeModel.get(["time", "dayOfWeekShort"]);
      nameMap = dayOfWeekShort || map(localeModel.get(["time", "dayOfWeekAbbr"]), (val) => val[0]);
    }
    let start2 = coordSys.getNextNDay(rangeData.end.time, 7 - rangeData.lweek).time;
    const cellSize = [coordSys.getCellWidth(), coordSys.getCellHeight()];
    margin = parsePercent2(margin, Math.min(cellSize[1], cellSize[0]));
    if (pos === "start") {
      start2 = coordSys.getNextNDay(rangeData.start.time, -(7 + rangeData.fweek)).time;
      margin = -margin;
    }
    for (let i = 0; i < 7; i++) {
      const tmpD = coordSys.getNextNDay(start2, i);
      const point = coordSys.dataToRect([tmpD.time], false).center;
      let day = i;
      day = Math.abs((i + firstDayOfWeek) % 7);
      const weekText = new Text_default({
        z2: 30,
        style: extend(createTextStyle(dayLabel, {text: nameMap[day]}), this._weekTextPositionControl(point, orient, pos, margin, cellSize))
      });
      group.add(weekText);
    }
  }
};
var CalendarView = CalendarView2;
CalendarView.type = "calendar";
var CalendarView_default = CalendarView;

// src/coord/calendar/Calendar.ts
var PROXIMATE_ONE_DAY = 864e5;
var Calendar2 = class {
  constructor(calendarModel, ecModel, api2) {
    this.type = "calendar";
    this.dimensions = Calendar2.dimensions;
    this.getDimensionsInfo = Calendar2.getDimensionsInfo;
    this._model = calendarModel;
  }
  static getDimensionsInfo() {
    return [{
      name: "time",
      type: "time"
    }, "value"];
  }
  getRangeInfo() {
    return this._rangeInfo;
  }
  getModel() {
    return this._model;
  }
  getRect() {
    return this._rect;
  }
  getCellWidth() {
    return this._sw;
  }
  getCellHeight() {
    return this._sh;
  }
  getOrient() {
    return this._orient;
  }
  getFirstDayOfWeek() {
    return this._firstDayOfWeek;
  }
  getDateInfo(date) {
    date = parseDate(date);
    const y = date.getFullYear();
    const m2 = date.getMonth() + 1;
    const mStr = m2 < 10 ? "0" + m2 : "" + m2;
    const d = date.getDate();
    const dStr = d < 10 ? "0" + d : "" + d;
    let day = date.getDay();
    day = Math.abs((day + 7 - this.getFirstDayOfWeek()) % 7);
    return {
      y: y + "",
      m: mStr,
      d: dStr,
      day,
      time: date.getTime(),
      formatedDate: y + "-" + mStr + "-" + dStr,
      date
    };
  }
  getNextNDay(date, n) {
    n = n || 0;
    if (n === 0) {
      return this.getDateInfo(date);
    }
    date = new Date(this.getDateInfo(date).time);
    date.setDate(date.getDate() + n);
    return this.getDateInfo(date);
  }
  update(ecModel, api2) {
    this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay");
    this._orient = this._model.get("orient");
    this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0;
    this._rangeInfo = this._getRangeInfo(this._initRangeOption());
    const weeks = this._rangeInfo.weeks || 1;
    const whNames = ["width", "height"];
    const cellSize = this._model.getCellSize().slice();
    const layoutParams = this._model.getBoxLayoutParams();
    const cellNumbers = this._orient === "horizontal" ? [weeks, 7] : [7, weeks];
    each([0, 1], function(idx) {
      if (cellSizeSpecified(cellSize, idx)) {
        layoutParams[whNames[idx]] = cellSize[idx] * cellNumbers[idx];
      }
    });
    const whGlobal = {
      width: api2.getWidth(),
      height: api2.getHeight()
    };
    const calendarRect = this._rect = getLayoutRect(layoutParams, whGlobal);
    each([0, 1], function(idx) {
      if (!cellSizeSpecified(cellSize, idx)) {
        cellSize[idx] = calendarRect[whNames[idx]] / cellNumbers[idx];
      }
    });
    function cellSizeSpecified(cellSize2, idx) {
      return cellSize2[idx] != null && cellSize2[idx] !== "auto";
    }
    this._sw = cellSize[0];
    this._sh = cellSize[1];
  }
  dataToPoint(data, clamp2) {
    isArray(data) && (data = data[0]);
    clamp2 == null && (clamp2 = true);
    const dayInfo = this.getDateInfo(data);
    const range = this._rangeInfo;
    const date = dayInfo.formatedDate;
    if (clamp2 && !(dayInfo.time >= range.start.time && dayInfo.time < range.end.time + PROXIMATE_ONE_DAY)) {
      return [NaN, NaN];
    }
    const week = dayInfo.day;
    const nthWeek = this._getRangeInfo([range.start.time, date]).nthWeek;
    if (this._orient === "vertical") {
      return [
        this._rect.x + week * this._sw + this._sw / 2,
        this._rect.y + nthWeek * this._sh + this._sh / 2
      ];
    }
    return [
      this._rect.x + nthWeek * this._sw + this._sw / 2,
      this._rect.y + week * this._sh + this._sh / 2
    ];
  }
  pointToData(point) {
    const date = this.pointToDate(point);
    return date && date.time;
  }
  dataToRect(data, clamp2) {
    const point = this.dataToPoint(data, clamp2);
    return {
      contentShape: {
        x: point[0] - (this._sw - this._lineWidth) / 2,
        y: point[1] - (this._sh - this._lineWidth) / 2,
        width: this._sw - this._lineWidth,
        height: this._sh - this._lineWidth
      },
      center: point,
      tl: [
        point[0] - this._sw / 2,
        point[1] - this._sh / 2
      ],
      tr: [
        point[0] + this._sw / 2,
        point[1] - this._sh / 2
      ],
      br: [
        point[0] + this._sw / 2,
        point[1] + this._sh / 2
      ],
      bl: [
        point[0] - this._sw / 2,
        point[1] + this._sh / 2
      ]
    };
  }
  pointToDate(point) {
    const nthX = Math.floor((point[0] - this._rect.x) / this._sw) + 1;
    const nthY = Math.floor((point[1] - this._rect.y) / this._sh) + 1;
    const range = this._rangeInfo.range;
    if (this._orient === "vertical") {
      return this._getDateByWeeksAndDay(nthY, nthX - 1, range);
    }
    return this._getDateByWeeksAndDay(nthX, nthY - 1, range);
  }
  convertToPixel(ecModel, finder, value) {
    const coordSys = getCoordSys5(finder);
    return coordSys === this ? coordSys.dataToPoint(value) : null;
  }
  convertFromPixel(ecModel, finder, pixel) {
    const coordSys = getCoordSys5(finder);
    return coordSys === this ? coordSys.pointToData(pixel) : null;
  }
  containPoint(point) {
    console.warn("Not implemented.");
    return false;
  }
  _initRangeOption() {
    let range = this._model.get("range");
    let normalizedRange;
    if (isArray(range) && range.length === 1) {
      range = range[0];
    }
    if (!isArray(range)) {
      const rangeStr = range.toString();
      if (/^\d{4}$/.test(rangeStr)) {
        normalizedRange = [rangeStr + "-01-01", rangeStr + "-12-31"];
      }
      if (/^\d{4}[\/|-]\d{1,2}$/.test(rangeStr)) {
        const start2 = this.getDateInfo(rangeStr);
        const firstDay = start2.date;
        firstDay.setMonth(firstDay.getMonth() + 1);
        const end2 = this.getNextNDay(firstDay, -1);
        normalizedRange = [start2.formatedDate, end2.formatedDate];
      }
      if (/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(rangeStr)) {
        normalizedRange = [rangeStr, rangeStr];
      }
    } else {
      normalizedRange = range;
    }
    if (!normalizedRange) {
      if (true) {
        logError("Invalid date range.");
      }
      return range;
    }
    const tmp = this._getRangeInfo(normalizedRange);
    if (tmp.start.time > tmp.end.time) {
      normalizedRange.reverse();
    }
    return normalizedRange;
  }
  _getRangeInfo(range) {
    const parsedRange = [
      this.getDateInfo(range[0]),
      this.getDateInfo(range[1])
    ];
    let reversed;
    if (parsedRange[0].time > parsedRange[1].time) {
      reversed = true;
      parsedRange.reverse();
    }
    let allDay = Math.floor(parsedRange[1].time / PROXIMATE_ONE_DAY) - Math.floor(parsedRange[0].time / PROXIMATE_ONE_DAY) + 1;
    const date = new Date(parsedRange[0].time);
    const startDateNum = date.getDate();
    const endDateNum = parsedRange[1].date.getDate();
    date.setDate(startDateNum + allDay - 1);
    let dateNum = date.getDate();
    if (dateNum !== endDateNum) {
      const sign = date.getTime() - parsedRange[1].time > 0 ? 1 : -1;
      while ((dateNum = date.getDate()) !== endDateNum && (date.getTime() - parsedRange[1].time) * sign > 0) {
        allDay -= sign;
        date.setDate(dateNum - sign);
      }
    }
    const weeks = Math.floor((allDay + parsedRange[0].day + 6) / 7);
    const nthWeek = reversed ? -weeks + 1 : weeks - 1;
    reversed && parsedRange.reverse();
    return {
      range: [parsedRange[0].formatedDate, parsedRange[1].formatedDate],
      start: parsedRange[0],
      end: parsedRange[1],
      allDay,
      weeks,
      nthWeek,
      fweek: parsedRange[0].day,
      lweek: parsedRange[1].day
    };
  }
  _getDateByWeeksAndDay(nthWeek, day, range) {
    const rangeInfo = this._getRangeInfo(range);
    if (nthWeek > rangeInfo.weeks || nthWeek === 0 && day < rangeInfo.fweek || nthWeek === rangeInfo.weeks && day > rangeInfo.lweek) {
      return null;
    }
    const nthDay = (nthWeek - 1) * 7 - rangeInfo.fweek + day;
    const date = new Date(rangeInfo.start.time);
    date.setDate(+rangeInfo.start.d + nthDay);
    return this.getDateInfo(date);
  }
  static create(ecModel, api2) {
    const calendarList = [];
    ecModel.eachComponent("calendar", function(calendarModel) {
      const calendar = new Calendar2(calendarModel, ecModel, api2);
      calendarList.push(calendar);
      calendarModel.coordinateSystem = calendar;
    });
    ecModel.eachSeries(function(calendarSeries) {
      if (calendarSeries.get("coordinateSystem") === "calendar") {
        calendarSeries.coordinateSystem = calendarList[calendarSeries.get("calendarIndex") || 0];
      }
    });
    return calendarList;
  }
};
var Calendar = Calendar2;
Calendar.dimensions = ["time", "value"];
function getCoordSys5(finder) {
  const calendarModel = finder.calendarModel;
  const seriesModel = finder.seriesModel;
  const coordSys = calendarModel ? calendarModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem : null;
  return coordSys;
}
var Calendar_default = Calendar;

// src/component/calendar/install.ts
function install33(registers) {
  registers.registerComponentModel(CalendarModel_default);
  registers.registerComponentView(CalendarView_default);
  registers.registerCoordinateSystem("calendar", Calendar_default);
}

// src/component/graphic/GraphicView.ts
var nonShapeGraphicElements = {
  path: null,
  compoundPath: null,
  group: Group_default,
  image: Image_default,
  text: Text_default
};
var inner15 = makeInner();
var GraphicComponentView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = GraphicComponentView2.type;
  }
  init() {
    this._elMap = createHashMap();
  }
  render(graphicModel, ecModel, api2) {
    if (graphicModel !== this._lastGraphicModel) {
      this._clear();
    }
    this._lastGraphicModel = graphicModel;
    this._updateElements(graphicModel);
    this._relocate(graphicModel, api2);
  }
  _updateElements(graphicModel) {
    const elOptionsToUpdate = graphicModel.useElOptionsToUpdate();
    if (!elOptionsToUpdate) {
      return;
    }
    const elMap = this._elMap;
    const rootGroup = this.group;
    const globalZ = graphicModel.get("z");
    const globalZLevel = graphicModel.get("zlevel");
    each(elOptionsToUpdate, function(elOption) {
      const id = convertOptionIdName(elOption.id, null);
      const elExisting = id != null ? elMap.get(id) : null;
      const parentId = convertOptionIdName(elOption.parentId, null);
      const targetElParent = parentId != null ? elMap.get(parentId) : rootGroup;
      const elType = elOption.type;
      const elOptionStyle = elOption.style;
      if (elType === "text" && elOptionStyle) {
        if (elOption.hv && elOption.hv[1]) {
          elOptionStyle.textVerticalAlign = elOptionStyle.textBaseline = elOptionStyle.verticalAlign = elOptionStyle.align = null;
        }
      }
      let textContentOption = elOption.textContent;
      let textConfig = elOption.textConfig;
      if (elOptionStyle && isEC4CompatibleStyle(elOptionStyle, elType, !!textConfig, !!textContentOption)) {
        const convertResult = convertFromEC4CompatibleStyle(elOptionStyle, elType, true);
        if (!textConfig && convertResult.textConfig) {
          textConfig = elOption.textConfig = convertResult.textConfig;
        }
        if (!textContentOption && convertResult.textContent) {
          textContentOption = convertResult.textContent;
        }
      }
      const elOptionCleaned = getCleanedElOption(elOption);
      if (true) {
        elExisting && assert(targetElParent === elExisting.parent, "Changing parent is not supported.");
      }
      const $action = elOption.$action || "merge";
      const isMerge = $action === "merge";
      const isReplace = $action === "replace";
      if (isMerge) {
        const isInit = !elExisting;
        let el2 = elExisting;
        if (isInit) {
          el2 = createEl2(id, targetElParent, elOption.type, elMap);
        } else {
          el2 && (inner15(el2).isNew = false);
          stopPreviousKeyframeAnimationAndRestore(el2);
        }
        if (el2) {
          applyUpdateTransition(el2, elOptionCleaned, graphicModel, {isInit});
          updateCommonAttrs(el2, elOption, globalZ, globalZLevel);
        }
      } else if (isReplace) {
        removeEl(elExisting, elOption, elMap, graphicModel);
        const el2 = createEl2(id, targetElParent, elOption.type, elMap);
        if (el2) {
          applyUpdateTransition(el2, elOptionCleaned, graphicModel, {isInit: true});
          updateCommonAttrs(el2, elOption, globalZ, globalZLevel);
        }
      } else if ($action === "remove") {
        updateLeaveTo(elExisting, elOption);
        removeEl(elExisting, elOption, elMap, graphicModel);
      }
      const el = elMap.get(id);
      if (el && textContentOption) {
        if (isMerge) {
          const textContentExisting = el.getTextContent();
          textContentExisting ? textContentExisting.attr(textContentOption) : el.setTextContent(new Text_default(textContentOption));
        } else if (isReplace) {
          el.setTextContent(new Text_default(textContentOption));
        }
      }
      if (el) {
        const clipPathOption = elOption.clipPath;
        if (clipPathOption) {
          const clipPathType = clipPathOption.type;
          let clipPath;
          let isInit = false;
          if (isMerge) {
            const oldClipPath = el.getClipPath();
            isInit = !oldClipPath || inner15(oldClipPath).type !== clipPathType;
            clipPath = isInit ? newEl(clipPathType) : oldClipPath;
          } else if (isReplace) {
            isInit = true;
            clipPath = newEl(clipPathType);
          }
          el.setClipPath(clipPath);
          applyUpdateTransition(clipPath, clipPathOption, graphicModel, {isInit});
          applyKeyframeAnimation(clipPath, clipPathOption.keyframeAnimation, graphicModel);
        }
        const elInner = inner15(el);
        el.setTextConfig(textConfig);
        elInner.option = elOption;
        setEventData(el, graphicModel, elOption);
        setTooltipConfig({
          el,
          componentModel: graphicModel,
          itemName: el.name,
          itemTooltipOption: elOption.tooltip
        });
        applyKeyframeAnimation(el, elOption.keyframeAnimation, graphicModel);
      }
    });
  }
  _relocate(graphicModel, api2) {
    const elOptions = graphicModel.option.elements;
    const rootGroup = this.group;
    const elMap = this._elMap;
    const apiWidth = api2.getWidth();
    const apiHeight = api2.getHeight();
    const xy = ["x", "y"];
    for (let i = 0; i < elOptions.length; i++) {
      const elOption = elOptions[i];
      const id = convertOptionIdName(elOption.id, null);
      const el = id != null ? elMap.get(id) : null;
      if (!el || !el.isGroup) {
        continue;
      }
      const parentEl = el.parent;
      const isParentRoot = parentEl === rootGroup;
      const elInner = inner15(el);
      const parentElInner = inner15(parentEl);
      elInner.width = parsePercent2(elInner.option.width, isParentRoot ? apiWidth : parentElInner.width) || 0;
      elInner.height = parsePercent2(elInner.option.height, isParentRoot ? apiHeight : parentElInner.height) || 0;
    }
    for (let i = elOptions.length - 1; i >= 0; i--) {
      const elOption = elOptions[i];
      const id = convertOptionIdName(elOption.id, null);
      const el = id != null ? elMap.get(id) : null;
      if (!el) {
        continue;
      }
      const parentEl = el.parent;
      const parentElInner = inner15(parentEl);
      const containerInfo = parentEl === rootGroup ? {
        width: apiWidth,
        height: apiHeight
      } : {
        width: parentElInner.width,
        height: parentElInner.height
      };
      const layoutPos = {};
      const layouted = positionElement(el, elOption, containerInfo, null, {hv: elOption.hv, boundingMode: elOption.bounding}, layoutPos);
      if (!inner15(el).isNew && layouted) {
        const transition = elOption.transition;
        const animatePos = {};
        for (let k = 0; k < xy.length; k++) {
          const key = xy[k];
          const val = layoutPos[key];
          if (transition && (isTransitionAll(transition) || indexOf(transition, key) >= 0)) {
            animatePos[key] = val;
          } else {
            el[key] = val;
          }
        }
        updateProps(el, animatePos, graphicModel, 0);
      } else {
        el.attr(layoutPos);
      }
    }
  }
  _clear() {
    const elMap = this._elMap;
    elMap.each((el) => {
      removeEl(el, inner15(el).option, elMap, this._lastGraphicModel);
    });
    this._elMap = createHashMap();
  }
  dispose() {
    this._clear();
  }
};
var GraphicComponentView = GraphicComponentView2;
GraphicComponentView.type = "graphic";
function newEl(graphicType) {
  if (true) {
    assert(graphicType, "graphic type MUST be set");
  }
  const Clz = hasOwn(nonShapeGraphicElements, graphicType) ? nonShapeGraphicElements[graphicType] : getShapeClass(graphicType);
  if (true) {
    assert(Clz, `graphic type ${graphicType} can not be found`);
  }
  const el = new Clz({});
  inner15(el).type = graphicType;
  return el;
}
function createEl2(id, targetElParent, graphicType, elMap) {
  const el = newEl(graphicType);
  targetElParent.add(el);
  elMap.set(id, el);
  inner15(el).id = id;
  inner15(el).isNew = true;
  return el;
}
function removeEl(elExisting, elOption, elMap, graphicModel) {
  const existElParent = elExisting && elExisting.parent;
  if (existElParent) {
    elExisting.type === "group" && elExisting.traverse(function(el) {
      removeEl(el, elOption, elMap, graphicModel);
    });
    applyLeaveTransition(elExisting, elOption, graphicModel);
    elMap.removeKey(inner15(elExisting).id);
  }
}
function updateCommonAttrs(el, elOption, defaultZ, defaultZlevel) {
  if (!el.isGroup) {
    each([
      ["cursor", Displayable_default.prototype.cursor],
      ["zlevel", defaultZlevel || 0],
      ["z", defaultZ || 0],
      ["z2", 0]
    ], (item) => {
      const prop = item[0];
      if (hasOwn(elOption, prop)) {
        el[prop] = retrieve2(elOption[prop], item[1]);
      } else if (el[prop] == null) {
        el[prop] = item[1];
      }
    });
  }
  each(keys(elOption), (key) => {
    if (key.indexOf("on") === 0) {
      const val = elOption[key];
      el[key] = isFunction(val) ? val : null;
    }
  });
  if (hasOwn(elOption, "draggable")) {
    el.draggable = elOption.draggable;
  }
  elOption.name != null && (el.name = elOption.name);
  elOption.id != null && (el.id = elOption.id);
}
function getCleanedElOption(elOption) {
  elOption = extend({}, elOption);
  each(["id", "parentId", "$action", "hv", "bounding", "textContent", "clipPath"].concat(LOCATION_PARAMS), function(name) {
    delete elOption[name];
  });
  return elOption;
}
function setEventData(el, graphicModel, elOption) {
  let eventData = getECData(el).eventData;
  if (!el.silent && !el.ignore && !eventData) {
    eventData = getECData(el).eventData = {
      componentType: "graphic",
      componentIndex: graphicModel.componentIndex,
      name: el.name
    };
  }
  if (eventData) {
    eventData.info = elOption.info;
  }
}

// src/component/graphic/install.ts
function install34(registers) {
  registers.registerComponentModel(GraphicComponentModel);
  registers.registerComponentView(GraphicComponentView);
  registers.registerPreprocessor(function(option) {
    const graphicOption = option.graphic;
    if (isArray(graphicOption)) {
      if (!graphicOption[0] || !graphicOption[0].elements) {
        option.graphic = [{elements: graphicOption}];
      } else {
        option.graphic = [option.graphic[0]];
      }
    } else if (graphicOption && !graphicOption.elements) {
      option.graphic = [{elements: [graphicOption]}];
    }
  });
}

// src/component/dataZoom/helper.ts
var DATA_ZOOM_AXIS_DIMENSIONS = [
  "x",
  "y",
  "radius",
  "angle",
  "single"
];
var SERIES_COORDS = ["cartesian2d", "polar", "singleAxis"];
function isCoordSupported(seriesModel) {
  const coordType = seriesModel.get("coordinateSystem");
  return indexOf(SERIES_COORDS, coordType) >= 0;
}
function getAxisMainType(axisDim) {
  if (true) {
    assert(axisDim);
  }
  return axisDim + "Axis";
}
function findEffectedDataZooms(ecModel, payload) {
  const axisRecords = createHashMap();
  const effectedModels = [];
  const effectedModelMap = createHashMap();
  ecModel.eachComponent({mainType: "dataZoom", query: payload}, function(dataZoomModel) {
    if (!effectedModelMap.get(dataZoomModel.uid)) {
      addToEffected(dataZoomModel);
    }
  });
  let foundNewLink;
  do {
    foundNewLink = false;
    ecModel.eachComponent("dataZoom", processSingle);
  } while (foundNewLink);
  function processSingle(dataZoomModel) {
    if (!effectedModelMap.get(dataZoomModel.uid) && isLinked(dataZoomModel)) {
      addToEffected(dataZoomModel);
      foundNewLink = true;
    }
  }
  function addToEffected(dataZoom) {
    effectedModelMap.set(dataZoom.uid, true);
    effectedModels.push(dataZoom);
    markAxisControlled(dataZoom);
  }
  function isLinked(dataZoomModel) {
    let isLink = false;
    dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
      const axisIdxArr = axisRecords.get(axisDim);
      if (axisIdxArr && axisIdxArr[axisIndex]) {
        isLink = true;
      }
    });
    return isLink;
  }
  function markAxisControlled(dataZoomModel) {
    dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
      (axisRecords.get(axisDim) || axisRecords.set(axisDim, []))[axisIndex] = true;
    });
  }
  return effectedModels;
}
function collectReferCoordSysModelInfo(dataZoomModel) {
  const ecModel = dataZoomModel.ecModel;
  const coordSysInfoWrap = {
    infoList: [],
    infoMap: createHashMap()
  };
  dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
    const axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
    if (!axisModel) {
      return;
    }
    const coordSysModel = axisModel.getCoordSysModel();
    if (!coordSysModel) {
      return;
    }
    const coordSysUid = coordSysModel.uid;
    let coordSysInfo = coordSysInfoWrap.infoMap.get(coordSysUid);
    if (!coordSysInfo) {
      coordSysInfo = {model: coordSysModel, axisModels: []};
      coordSysInfoWrap.infoList.push(coordSysInfo);
      coordSysInfoWrap.infoMap.set(coordSysUid, coordSysInfo);
    }
    coordSysInfo.axisModels.push(axisModel);
  });
  return coordSysInfoWrap;
}

// src/component/dataZoom/DataZoomModel.ts
var DataZoomAxisInfo = class {
  constructor() {
    this.indexList = [];
    this.indexMap = [];
  }
  add(axisCmptIdx) {
    if (!this.indexMap[axisCmptIdx]) {
      this.indexList.push(axisCmptIdx);
      this.indexMap[axisCmptIdx] = true;
    }
  }
};
var DataZoomModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = DataZoomModel2.type;
    this._autoThrottle = true;
    this._noTarget = true;
    this._rangePropMode = ["percent", "percent"];
  }
  init(option, parentModel, ecModel) {
    const inputRawOption = retrieveRawOption(option);
    this.settledOption = inputRawOption;
    this.mergeDefaultAndTheme(option, ecModel);
    this._doInit(inputRawOption);
  }
  mergeOption(newOption) {
    const inputRawOption = retrieveRawOption(newOption);
    merge(this.option, newOption, true);
    merge(this.settledOption, inputRawOption, true);
    this._doInit(inputRawOption);
  }
  _doInit(inputRawOption) {
    const thisOption = this.option;
    this._setDefaultThrottle(inputRawOption);
    this._updateRangeUse(inputRawOption);
    const settledOption = this.settledOption;
    each([["start", "startValue"], ["end", "endValue"]], function(names, index) {
      if (this._rangePropMode[index] === "value") {
        thisOption[names[0]] = settledOption[names[0]] = null;
      }
    }, this);
    this._resetTarget();
  }
  _resetTarget() {
    const optionOrient = this.get("orient", true);
    const targetAxisIndexMap = this._targetAxisInfoMap = createHashMap();
    const hasAxisSpecified = this._fillSpecifiedTargetAxis(targetAxisIndexMap);
    if (hasAxisSpecified) {
      this._orient = optionOrient || this._makeAutoOrientByTargetAxis();
    } else {
      this._orient = optionOrient || "horizontal";
      this._fillAutoTargetAxisByOrient(targetAxisIndexMap, this._orient);
    }
    this._noTarget = true;
    targetAxisIndexMap.each(function(axisInfo) {
      if (axisInfo.indexList.length) {
        this._noTarget = false;
      }
    }, this);
  }
  _fillSpecifiedTargetAxis(targetAxisIndexMap) {
    let hasAxisSpecified = false;
    each(DATA_ZOOM_AXIS_DIMENSIONS, function(axisDim) {
      const refering = this.getReferringComponents(getAxisMainType(axisDim), MULTIPLE_REFERRING);
      if (!refering.specified) {
        return;
      }
      hasAxisSpecified = true;
      const axisInfo = new DataZoomAxisInfo();
      each(refering.models, function(axisModel) {
        axisInfo.add(axisModel.componentIndex);
      });
      targetAxisIndexMap.set(axisDim, axisInfo);
    }, this);
    return hasAxisSpecified;
  }
  _fillAutoTargetAxisByOrient(targetAxisIndexMap, orient) {
    const ecModel = this.ecModel;
    let needAuto = true;
    if (needAuto) {
      const axisDim = orient === "vertical" ? "y" : "x";
      const axisModels = ecModel.findComponents({mainType: axisDim + "Axis"});
      setParallelAxis(axisModels, axisDim);
    }
    if (needAuto) {
      const axisModels = ecModel.findComponents({
        mainType: "singleAxis",
        filter: (axisModel) => axisModel.get("orient", true) === orient
      });
      setParallelAxis(axisModels, "single");
    }
    function setParallelAxis(axisModels, axisDim) {
      const axisModel = axisModels[0];
      if (!axisModel) {
        return;
      }
      const axisInfo = new DataZoomAxisInfo();
      axisInfo.add(axisModel.componentIndex);
      targetAxisIndexMap.set(axisDim, axisInfo);
      needAuto = false;
      if (axisDim === "x" || axisDim === "y") {
        const gridModel = axisModel.getReferringComponents("grid", SINGLE_REFERRING).models[0];
        gridModel && each(axisModels, function(axModel) {
          if (axisModel.componentIndex !== axModel.componentIndex && gridModel === axModel.getReferringComponents("grid", SINGLE_REFERRING).models[0]) {
            axisInfo.add(axModel.componentIndex);
          }
        });
      }
    }
    if (needAuto) {
      each(DATA_ZOOM_AXIS_DIMENSIONS, function(axisDim) {
        if (!needAuto) {
          return;
        }
        const axisModels = ecModel.findComponents({
          mainType: getAxisMainType(axisDim),
          filter: (axisModel) => axisModel.get("type", true) === "category"
        });
        if (axisModels[0]) {
          const axisInfo = new DataZoomAxisInfo();
          axisInfo.add(axisModels[0].componentIndex);
          targetAxisIndexMap.set(axisDim, axisInfo);
          needAuto = false;
        }
      }, this);
    }
  }
  _makeAutoOrientByTargetAxis() {
    let dim;
    this.eachTargetAxis(function(axisDim) {
      !dim && (dim = axisDim);
    }, this);
    return dim === "y" ? "vertical" : "horizontal";
  }
  _setDefaultThrottle(inputRawOption) {
    if (inputRawOption.hasOwnProperty("throttle")) {
      this._autoThrottle = false;
    }
    if (this._autoThrottle) {
      const globalOption = this.ecModel.option;
      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;
    }
  }
  _updateRangeUse(inputRawOption) {
    const rangePropMode = this._rangePropMode;
    const rangeModeInOption = this.get("rangeMode");
    each([["start", "startValue"], ["end", "endValue"]], function(names, index) {
      const percentSpecified = inputRawOption[names[0]] != null;
      const valueSpecified = inputRawOption[names[1]] != null;
      if (percentSpecified && !valueSpecified) {
        rangePropMode[index] = "percent";
      } else if (!percentSpecified && valueSpecified) {
        rangePropMode[index] = "value";
      } else if (rangeModeInOption) {
        rangePropMode[index] = rangeModeInOption[index];
      } else if (percentSpecified) {
        rangePropMode[index] = "percent";
      }
    });
  }
  noTarget() {
    return this._noTarget;
  }
  getFirstTargetAxisModel() {
    let firstAxisModel;
    this.eachTargetAxis(function(axisDim, axisIndex) {
      if (firstAxisModel == null) {
        firstAxisModel = this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
      }
    }, this);
    return firstAxisModel;
  }
  eachTargetAxis(callback, context) {
    this._targetAxisInfoMap.each(function(axisInfo, axisDim) {
      each(axisInfo.indexList, function(axisIndex) {
        callback.call(context, axisDim, axisIndex);
      });
    });
  }
  getAxisProxy(axisDim, axisIndex) {
    const axisModel = this.getAxisModel(axisDim, axisIndex);
    if (axisModel) {
      return axisModel.__dzAxisProxy;
    }
  }
  getAxisModel(axisDim, axisIndex) {
    if (true) {
      assert(axisDim && axisIndex != null);
    }
    const axisInfo = this._targetAxisInfoMap.get(axisDim);
    if (axisInfo && axisInfo.indexMap[axisIndex]) {
      return this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
    }
  }
  setRawRange(opt) {
    const thisOption = this.option;
    const settledOption = this.settledOption;
    each([["start", "startValue"], ["end", "endValue"]], function(names) {
      if (opt[names[0]] != null || opt[names[1]] != null) {
        thisOption[names[0]] = settledOption[names[0]] = opt[names[0]];
        thisOption[names[1]] = settledOption[names[1]] = opt[names[1]];
      }
    }, this);
    this._updateRangeUse(opt);
  }
  setCalculatedRange(opt) {
    const option = this.option;
    each(["start", "startValue", "end", "endValue"], function(name) {
      option[name] = opt[name];
    });
  }
  getPercentRange() {
    const axisProxy = this.findRepresentativeAxisProxy();
    if (axisProxy) {
      return axisProxy.getDataPercentWindow();
    }
  }
  getValueRange(axisDim, axisIndex) {
    if (axisDim == null && axisIndex == null) {
      const axisProxy = this.findRepresentativeAxisProxy();
      if (axisProxy) {
        return axisProxy.getDataValueWindow();
      }
    } else {
      return this.getAxisProxy(axisDim, axisIndex).getDataValueWindow();
    }
  }
  findRepresentativeAxisProxy(axisModel) {
    if (axisModel) {
      return axisModel.__dzAxisProxy;
    }
    let firstProxy;
    const axisDimList = this._targetAxisInfoMap.keys();
    for (let i = 0; i < axisDimList.length; i++) {
      const axisDim = axisDimList[i];
      const axisInfo = this._targetAxisInfoMap.get(axisDim);
      for (let j = 0; j < axisInfo.indexList.length; j++) {
        const proxy = this.getAxisProxy(axisDim, axisInfo.indexList[j]);
        if (proxy.hostedBy(this)) {
          return proxy;
        }
        if (!firstProxy) {
          firstProxy = proxy;
        }
      }
    }
    return firstProxy;
  }
  getRangePropMode() {
    return this._rangePropMode.slice();
  }
  getOrient() {
    if (true) {
      assert(this._orient);
    }
    return this._orient;
  }
};
var DataZoomModel = DataZoomModel2;
DataZoomModel.type = "dataZoom";
DataZoomModel.dependencies = [
  "xAxis",
  "yAxis",
  "radiusAxis",
  "angleAxis",
  "singleAxis",
  "series",
  "toolbox"
];
DataZoomModel.defaultOption = {
  z: 4,
  filterMode: "filter",
  start: 0,
  end: 100
};
function retrieveRawOption(option) {
  const ret = {};
  each(["start", "end", "startValue", "endValue", "throttle"], function(name) {
    option.hasOwnProperty(name) && (ret[name] = option[name]);
  });
  return ret;
}
var DataZoomModel_default = DataZoomModel;

// src/component/dataZoom/SelectZoomModel.ts
var SelectDataZoomModel2 = class extends DataZoomModel_default {
  constructor() {
    super(...arguments);
    this.type = SelectDataZoomModel2.type;
  }
};
var SelectDataZoomModel = SelectDataZoomModel2;
SelectDataZoomModel.type = "dataZoom.select";
var SelectZoomModel_default = SelectDataZoomModel;

// src/component/dataZoom/DataZoomView.ts
var DataZoomView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = DataZoomView2.type;
  }
  render(dataZoomModel, ecModel, api2, payload) {
    this.dataZoomModel = dataZoomModel;
    this.ecModel = ecModel;
    this.api = api2;
  }
};
var DataZoomView = DataZoomView2;
DataZoomView.type = "dataZoom";
var DataZoomView_default = DataZoomView;

// src/component/dataZoom/SelectZoomView.ts
var SelectDataZoomView2 = class extends DataZoomView_default {
  constructor() {
    super(...arguments);
    this.type = SelectDataZoomView2.type;
  }
};
var SelectDataZoomView = SelectDataZoomView2;
SelectDataZoomView.type = "dataZoom.select";
var SelectZoomView_default = SelectDataZoomView;

// src/component/dataZoom/AxisProxy.ts
var each9 = each;
var asc2 = asc;
var AxisProxy = class {
  constructor(dimName, axisIndex, dataZoomModel, ecModel) {
    this._dimName = dimName;
    this._axisIndex = axisIndex;
    this.ecModel = ecModel;
    this._dataZoomModel = dataZoomModel;
  }
  hostedBy(dataZoomModel) {
    return this._dataZoomModel === dataZoomModel;
  }
  getDataValueWindow() {
    return this._valueWindow.slice();
  }
  getDataPercentWindow() {
    return this._percentWindow.slice();
  }
  getTargetSeriesModels() {
    const seriesModels = [];
    this.ecModel.eachSeries(function(seriesModel) {
      if (isCoordSupported(seriesModel)) {
        const axisMainType = getAxisMainType(this._dimName);
        const axisModel = seriesModel.getReferringComponents(axisMainType, SINGLE_REFERRING).models[0];
        if (axisModel && this._axisIndex === axisModel.componentIndex) {
          seriesModels.push(seriesModel);
        }
      }
    }, this);
    return seriesModels;
  }
  getAxisModel() {
    return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
  }
  getMinMaxSpan() {
    return clone(this._minMaxSpan);
  }
  calculateDataWindow(opt) {
    const dataExtent = this._dataExtent;
    const axisModel = this.getAxisModel();
    const scale4 = axisModel.axis.scale;
    const rangePropMode = this._dataZoomModel.getRangePropMode();
    const percentExtent = [0, 100];
    const percentWindow = [];
    const valueWindow = [];
    let hasPropModeValue;
    each9(["start", "end"], function(prop, idx) {
      let boundPercent = opt[prop];
      let boundValue = opt[prop + "Value"];
      if (rangePropMode[idx] === "percent") {
        boundPercent == null && (boundPercent = percentExtent[idx]);
        boundValue = scale4.parse(linearMap(boundPercent, percentExtent, dataExtent));
      } else {
        hasPropModeValue = true;
        boundValue = boundValue == null ? dataExtent[idx] : scale4.parse(boundValue);
        boundPercent = linearMap(boundValue, dataExtent, percentExtent);
      }
      valueWindow[idx] = boundValue == null || isNaN(boundValue) ? dataExtent[idx] : boundValue;
      percentWindow[idx] = boundPercent == null || isNaN(boundPercent) ? percentExtent[idx] : boundPercent;
    });
    asc2(valueWindow);
    asc2(percentWindow);
    const spans = this._minMaxSpan;
    hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);
    function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {
      const suffix = toValue ? "Span" : "ValueSpan";
      sliderMove(0, fromWindow, fromExtent, "all", spans["min" + suffix], spans["max" + suffix]);
      for (let i = 0; i < 2; i++) {
        toWindow[i] = linearMap(fromWindow[i], fromExtent, toExtent, true);
        toValue && (toWindow[i] = scale4.parse(toWindow[i]));
      }
    }
    return {
      valueWindow,
      percentWindow
    };
  }
  reset(dataZoomModel) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    }
    const targetSeries = this.getTargetSeriesModels();
    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries);
    this._updateMinMaxSpan();
    const dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);
    this._valueWindow = dataWindow.valueWindow;
    this._percentWindow = dataWindow.percentWindow;
    this._setAxisModel();
  }
  filterData(dataZoomModel, api2) {
    if (dataZoomModel !== this._dataZoomModel) {
      return;
    }
    const axisDim = this._dimName;
    const seriesModels = this.getTargetSeriesModels();
    const filterMode = dataZoomModel.get("filterMode");
    const valueWindow = this._valueWindow;
    if (filterMode === "none") {
      return;
    }
    each9(seriesModels, function(seriesModel) {
      let seriesData = seriesModel.getData();
      const dataDims = seriesData.mapDimensionsAll(axisDim);
      if (!dataDims.length) {
        return;
      }
      if (filterMode === "weakFilter") {
        const store = seriesData.getStore();
        const dataDimIndices = map(dataDims, (dim) => seriesData.getDimensionIndex(dim), seriesData);
        seriesData.filterSelf(function(dataIndex) {
          let leftOut;
          let rightOut;
          let hasValue;
          for (let i = 0; i < dataDims.length; i++) {
            const value = store.get(dataDimIndices[i], dataIndex);
            const thisHasValue = !isNaN(value);
            const thisLeftOut = value < valueWindow[0];
            const thisRightOut = value > valueWindow[1];
            if (thisHasValue && !thisLeftOut && !thisRightOut) {
              return true;
            }
            thisHasValue && (hasValue = true);
            thisLeftOut && (leftOut = true);
            thisRightOut && (rightOut = true);
          }
          return hasValue && leftOut && rightOut;
        });
      } else {
        each9(dataDims, function(dim) {
          if (filterMode === "empty") {
            seriesModel.setData(seriesData = seriesData.map(dim, function(value) {
              return !isInWindow(value) ? NaN : value;
            }));
          } else {
            const range = {};
            range[dim] = valueWindow;
            seriesData.selectRange(range);
          }
        });
      }
      each9(dataDims, function(dim) {
        seriesData.setApproximateExtent(valueWindow, dim);
      });
    });
    function isInWindow(value) {
      return value >= valueWindow[0] && value <= valueWindow[1];
    }
  }
  _updateMinMaxSpan() {
    const minMaxSpan = this._minMaxSpan = {};
    const dataZoomModel = this._dataZoomModel;
    const dataExtent = this._dataExtent;
    each9(["min", "max"], function(minMax) {
      let percentSpan = dataZoomModel.get(minMax + "Span");
      let valueSpan = dataZoomModel.get(minMax + "ValueSpan");
      valueSpan != null && (valueSpan = this.getAxisModel().axis.scale.parse(valueSpan));
      if (valueSpan != null) {
        percentSpan = linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);
      } else if (percentSpan != null) {
        valueSpan = linearMap(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];
      }
      minMaxSpan[minMax + "Span"] = percentSpan;
      minMaxSpan[minMax + "ValueSpan"] = valueSpan;
    }, this);
  }
  _setAxisModel() {
    const axisModel = this.getAxisModel();
    const percentWindow = this._percentWindow;
    const valueWindow = this._valueWindow;
    if (!percentWindow) {
      return;
    }
    let precision = getPixelPrecision(valueWindow, [0, 500]);
    precision = Math.min(precision, 20);
    const rawExtentInfo = axisModel.axis.scale.rawExtentInfo;
    if (percentWindow[0] !== 0) {
      rawExtentInfo.setDeterminedMinMax("min", +valueWindow[0].toFixed(precision));
    }
    if (percentWindow[1] !== 100) {
      rawExtentInfo.setDeterminedMinMax("max", +valueWindow[1].toFixed(precision));
    }
    rawExtentInfo.freeze();
  }
};
function calculateDataExtent(axisProxy, axisDim, seriesModels) {
  const dataExtent = [Infinity, -Infinity];
  each9(seriesModels, function(seriesModel) {
    unionAxisExtentFromData(dataExtent, seriesModel.getData(), axisDim);
  });
  const axisModel = axisProxy.getAxisModel();
  const rawExtentResult = ensureScaleRawExtentInfo(axisModel.axis.scale, axisModel, dataExtent).calculate();
  return [rawExtentResult.min, rawExtentResult.max];
}
var AxisProxy_default = AxisProxy;

// src/component/dataZoom/dataZoomProcessor.ts
var dataZoomProcessor = {
  getTargetSeries(ecModel) {
    function eachAxisModel(cb) {
      ecModel.eachComponent("dataZoom", function(dataZoomModel) {
        dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
          const axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
          cb(axisDim, axisIndex, axisModel, dataZoomModel);
        });
      });
    }
    eachAxisModel(function(axisDim, axisIndex, axisModel, dataZoomModel) {
      axisModel.__dzAxisProxy = null;
    });
    const proxyList = [];
    eachAxisModel(function(axisDim, axisIndex, axisModel, dataZoomModel) {
      if (!axisModel.__dzAxisProxy) {
        axisModel.__dzAxisProxy = new AxisProxy_default(axisDim, axisIndex, dataZoomModel, ecModel);
        proxyList.push(axisModel.__dzAxisProxy);
      }
    });
    const seriesModelMap = createHashMap();
    each(proxyList, function(axisProxy) {
      each(axisProxy.getTargetSeriesModels(), function(seriesModel) {
        seriesModelMap.set(seriesModel.uid, seriesModel);
      });
    });
    return seriesModelMap;
  },
  overallReset(ecModel, api2) {
    ecModel.eachComponent("dataZoom", function(dataZoomModel) {
      dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
        dataZoomModel.getAxisProxy(axisDim, axisIndex).reset(dataZoomModel);
      });
      dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
        dataZoomModel.getAxisProxy(axisDim, axisIndex).filterData(dataZoomModel, api2);
      });
    });
    ecModel.eachComponent("dataZoom", function(dataZoomModel) {
      const axisProxy = dataZoomModel.findRepresentativeAxisProxy();
      if (axisProxy) {
        const percentRange = axisProxy.getDataPercentWindow();
        const valueRange = axisProxy.getDataValueWindow();
        dataZoomModel.setCalculatedRange({
          start: percentRange[0],
          end: percentRange[1],
          startValue: valueRange[0],
          endValue: valueRange[1]
        });
      }
    });
  }
};
var dataZoomProcessor_default = dataZoomProcessor;

// src/component/dataZoom/dataZoomAction.ts
function installDataZoomAction(registers) {
  registers.registerAction("dataZoom", function(payload, ecModel) {
    const effectedModels = findEffectedDataZooms(ecModel, payload);
    each(effectedModels, function(dataZoomModel) {
      dataZoomModel.setRawRange({
        start: payload.start,
        end: payload.end,
        startValue: payload.startValue,
        endValue: payload.endValue
      });
    });
  });
}

// src/component/dataZoom/installCommon.ts
var installed = false;
function installCommon(registers) {
  if (installed) {
    return;
  }
  installed = true;
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, dataZoomProcessor_default);
  installDataZoomAction(registers);
  registers.registerSubTypeDefaulter("dataZoom", function() {
    return "slider";
  });
}

// src/component/dataZoom/installDataZoomSelect.ts
function install35(registers) {
  registers.registerComponentModel(SelectZoomModel_default);
  registers.registerComponentView(SelectZoomView_default);
  installCommon(registers);
}

// src/component/toolbox/featureManager.ts
var ToolboxFeature = class {
};
var features = {};
function registerFeature(name, ctor) {
  features[name] = ctor;
}
function getFeature(name) {
  return features[name];
}

// src/component/toolbox/ToolboxModel.ts
var ToolboxModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = ToolboxModel2.type;
  }
  optionUpdated() {
    super.optionUpdated.apply(this, arguments);
    const {ecModel} = this;
    each(this.option.feature, function(featureOpt, featureName) {
      const Feature = getFeature(featureName);
      if (Feature) {
        if (Feature.getDefaultOption) {
          Feature.defaultOption = Feature.getDefaultOption(ecModel);
        }
        merge(featureOpt, Feature.defaultOption);
      }
    });
  }
};
var ToolboxModel = ToolboxModel2;
ToolboxModel.type = "toolbox";
ToolboxModel.layoutMode = {
  type: "box",
  ignoreSize: true
};
ToolboxModel.defaultOption = {
  show: true,
  z: 6,
  orient: "horizontal",
  left: "right",
  top: "top",
  backgroundColor: "transparent",
  borderColor: "#ccc",
  borderRadius: 0,
  borderWidth: 0,
  padding: 5,
  itemSize: 15,
  itemGap: 8,
  showTitle: true,
  iconStyle: {
    borderColor: "#666",
    color: "none"
  },
  emphasis: {
    iconStyle: {
      borderColor: "#3E98C5"
    }
  },
  tooltip: {
    show: false,
    position: "bottom"
  }
};
var ToolboxModel_default = ToolboxModel;

// src/component/helper/listComponent.ts
function layout13(group, componentModel, api2) {
  const boxLayoutParams = componentModel.getBoxLayoutParams();
  const padding = componentModel.get("padding");
  const viewportSize = {width: api2.getWidth(), height: api2.getHeight()};
  const rect = getLayoutRect(boxLayoutParams, viewportSize, padding);
  box(componentModel.get("orient"), group, componentModel.get("itemGap"), rect.width, rect.height);
  positionElement(group, boxLayoutParams, viewportSize, padding);
}
function makeBackground(rect, componentModel) {
  const padding = normalizeCssArray2(componentModel.get("padding"));
  const style = componentModel.getItemStyle(["color", "opacity"]);
  style.fill = componentModel.get("backgroundColor");
  rect = new Rect_default({
    shape: {
      x: rect.x - padding[3],
      y: rect.y - padding[0],
      width: rect.width + padding[1] + padding[3],
      height: rect.height + padding[0] + padding[2],
      r: componentModel.get("borderRadius")
    },
    style,
    silent: true,
    z2: -1
  });
  return rect;
}

// src/component/toolbox/ToolboxView.ts
var ToolboxView = class extends Component_default2 {
  render(toolboxModel, ecModel, api2, payload) {
    const group = this.group;
    group.removeAll();
    if (!toolboxModel.get("show")) {
      return;
    }
    const itemSize = +toolboxModel.get("itemSize");
    const isVertical = toolboxModel.get("orient") === "vertical";
    const featureOpts = toolboxModel.get("feature") || {};
    const features2 = this._features || (this._features = {});
    const featureNames = [];
    each(featureOpts, function(opt, name) {
      featureNames.push(name);
    });
    new DataDiffer_default(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(curry(processFeature, null)).execute();
    this._featureNames = featureNames;
    function processFeature(newIndex, oldIndex) {
      const featureName = featureNames[newIndex];
      const oldName = featureNames[oldIndex];
      const featureOpt = featureOpts[featureName];
      const featureModel = new Model_default(featureOpt, toolboxModel, toolboxModel.ecModel);
      let feature;
      if (payload && payload.newTitle != null && payload.featureName === featureName) {
        featureOpt.title = payload.newTitle;
      }
      if (featureName && !oldName) {
        if (isUserFeatureName(featureName)) {
          feature = {
            onclick: featureModel.option.onclick,
            featureName
          };
        } else {
          const Feature = getFeature(featureName);
          if (!Feature) {
            return;
          }
          feature = new Feature();
        }
        features2[featureName] = feature;
      } else {
        feature = features2[oldName];
        if (!feature) {
          return;
        }
      }
      feature.uid = getUID("toolbox-feature");
      feature.model = featureModel;
      feature.ecModel = ecModel;
      feature.api = api2;
      const isToolboxFeature = feature instanceof ToolboxFeature;
      if (!featureName && oldName) {
        isToolboxFeature && feature.dispose && feature.dispose(ecModel, api2);
        return;
      }
      if (!featureModel.get("show") || isToolboxFeature && feature.unusable) {
        isToolboxFeature && feature.remove && feature.remove(ecModel, api2);
        return;
      }
      createIconPaths(featureModel, feature, featureName);
      featureModel.setIconStatus = function(iconName, status) {
        const option = this.option;
        const iconPaths = this.iconPaths;
        option.iconStatus = option.iconStatus || {};
        option.iconStatus[iconName] = status;
        if (iconPaths[iconName]) {
          (status === "emphasis" ? enterEmphasis : leaveEmphasis)(iconPaths[iconName]);
        }
      };
      if (feature instanceof ToolboxFeature) {
        if (feature.render) {
          feature.render(featureModel, ecModel, api2, payload);
        }
      }
    }
    function createIconPaths(featureModel, feature, featureName) {
      const iconStyleModel = featureModel.getModel("iconStyle");
      const iconStyleEmphasisModel = featureModel.getModel(["emphasis", "iconStyle"]);
      const icons = feature instanceof ToolboxFeature && feature.getIcons ? feature.getIcons() : featureModel.get("icon");
      const titles = featureModel.get("title") || {};
      let iconsMap;
      let titlesMap;
      if (isString(icons)) {
        iconsMap = {};
        iconsMap[featureName] = icons;
      } else {
        iconsMap = icons;
      }
      if (isString(titles)) {
        titlesMap = {};
        titlesMap[featureName] = titles;
      } else {
        titlesMap = titles;
      }
      const iconPaths = featureModel.iconPaths = {};
      each(iconsMap, function(iconStr, iconName) {
        const path = createIcon(iconStr, {}, {
          x: -itemSize / 2,
          y: -itemSize / 2,
          width: itemSize,
          height: itemSize
        });
        path.setStyle(iconStyleModel.getItemStyle());
        const pathEmphasisState = path.ensureState("emphasis");
        pathEmphasisState.style = iconStyleEmphasisModel.getItemStyle();
        const textContent = new Text_default({
          style: {
            text: titlesMap[iconName],
            align: iconStyleEmphasisModel.get("textAlign"),
            borderRadius: iconStyleEmphasisModel.get("textBorderRadius"),
            padding: iconStyleEmphasisModel.get("textPadding"),
            fill: null,
            font: getFont({
              fontStyle: iconStyleEmphasisModel.get("textFontStyle"),
              fontFamily: iconStyleEmphasisModel.get("textFontFamily"),
              fontSize: iconStyleEmphasisModel.get("textFontSize"),
              fontWeight: iconStyleEmphasisModel.get("textFontWeight")
            }, ecModel)
          },
          ignore: true
        });
        path.setTextContent(textContent);
        setTooltipConfig({
          el: path,
          componentModel: toolboxModel,
          itemName: iconName,
          formatterParamsExtra: {
            title: titlesMap[iconName]
          }
        });
        path.__title = titlesMap[iconName];
        path.on("mouseover", function() {
          const hoverStyle = iconStyleEmphasisModel.getItemStyle();
          const defaultTextPosition = isVertical ? toolboxModel.get("right") == null && toolboxModel.get("left") !== "right" ? "right" : "left" : toolboxModel.get("bottom") == null && toolboxModel.get("top") !== "bottom" ? "bottom" : "top";
          textContent.setStyle({
            fill: iconStyleEmphasisModel.get("textFill") || hoverStyle.fill || hoverStyle.stroke || "#000",
            backgroundColor: iconStyleEmphasisModel.get("textBackgroundColor")
          });
          path.setTextConfig({
            position: iconStyleEmphasisModel.get("textPosition") || defaultTextPosition
          });
          textContent.ignore = !toolboxModel.get("showTitle");
          api2.enterEmphasis(this);
        }).on("mouseout", function() {
          if (featureModel.get(["iconStatus", iconName]) !== "emphasis") {
            api2.leaveEmphasis(this);
          }
          textContent.hide();
        });
        (featureModel.get(["iconStatus", iconName]) === "emphasis" ? enterEmphasis : leaveEmphasis)(path);
        group.add(path);
        path.on("click", bind(feature.onclick, feature, ecModel, api2, iconName));
        iconPaths[iconName] = path;
      });
    }
    layout13(group, toolboxModel, api2);
    group.add(makeBackground(group.getBoundingRect(), toolboxModel));
    isVertical || group.eachChild(function(icon) {
      const titleText = icon.__title;
      const emphasisState = icon.ensureState("emphasis");
      const emphasisTextConfig = emphasisState.textConfig || (emphasisState.textConfig = {});
      const textContent = icon.getTextContent();
      const emphasisTextState = textContent && textContent.ensureState("emphasis");
      if (emphasisTextState && !isFunction(emphasisTextState) && titleText) {
        const emphasisTextStyle = emphasisTextState.style || (emphasisTextState.style = {});
        const rect = getBoundingRect(titleText, Text_default.makeFont(emphasisTextStyle));
        const offsetX = icon.x + group.x;
        const offsetY = icon.y + group.y + itemSize;
        let needPutOnTop = false;
        if (offsetY + rect.height > api2.getHeight()) {
          emphasisTextConfig.position = "top";
          needPutOnTop = true;
        }
        const topOffset = needPutOnTop ? -5 - rect.height : itemSize + 10;
        if (offsetX + rect.width / 2 > api2.getWidth()) {
          emphasisTextConfig.position = ["100%", topOffset];
          emphasisTextStyle.align = "right";
        } else if (offsetX - rect.width / 2 < 0) {
          emphasisTextConfig.position = [0, topOffset];
          emphasisTextStyle.align = "left";
        }
      }
    });
  }
  updateView(toolboxModel, ecModel, api2, payload) {
    each(this._features, function(feature) {
      feature instanceof ToolboxFeature && feature.updateView && feature.updateView(feature.model, ecModel, api2, payload);
    });
  }
  remove(ecModel, api2) {
    each(this._features, function(feature) {
      feature instanceof ToolboxFeature && feature.remove && feature.remove(ecModel, api2);
    });
    this.group.removeAll();
  }
  dispose(ecModel, api2) {
    each(this._features, function(feature) {
      feature instanceof ToolboxFeature && feature.dispose && feature.dispose(ecModel, api2);
    });
  }
};
ToolboxView.type = "toolbox";
function isUserFeatureName(featureName) {
  return featureName.indexOf("my") === 0;
}
var ToolboxView_default = ToolboxView;

// src/component/toolbox/feature/SaveAsImage.ts
var SaveAsImage = class extends ToolboxFeature {
  onclick(ecModel, api2) {
    const model = this.model;
    const title = model.get("name") || ecModel.get("title.0.text") || "echarts";
    const isSvg = api2.getZr().painter.getType() === "svg";
    const type = isSvg ? "svg" : model.get("type", true) || "png";
    const url = api2.getConnectedDataURL({
      type,
      backgroundColor: model.get("backgroundColor", true) || ecModel.get("backgroundColor") || "#fff",
      connectedBackgroundColor: model.get("connectedBackgroundColor"),
      excludeComponents: model.get("excludeComponents"),
      pixelRatio: model.get("pixelRatio")
    });
    const browser = env_default.browser;
    if (typeof MouseEvent === "function" && (browser.newEdge || !browser.ie && !browser.edge)) {
      const $a = document.createElement("a");
      $a.download = title + "." + type;
      $a.target = "_blank";
      $a.href = url;
      const evt = new MouseEvent("click", {
        view: document.defaultView,
        bubbles: true,
        cancelable: false
      });
      $a.dispatchEvent(evt);
    } else {
      if (window.navigator.msSaveOrOpenBlob || isSvg) {
        const parts = url.split(",");
        const base64Encoded = parts[0].indexOf("base64") > -1;
        let bstr = isSvg ? decodeURIComponent(parts[1]) : parts[1];
        base64Encoded && (bstr = window.atob(bstr));
        const filename = title + "." + type;
        if (window.navigator.msSaveOrOpenBlob) {
          let n = bstr.length;
          const u8arr = new Uint8Array(n);
          while (n--) {
            u8arr[n] = bstr.charCodeAt(n);
          }
          const blob = new Blob([u8arr]);
          window.navigator.msSaveOrOpenBlob(blob, filename);
        } else {
          const frame = document.createElement("iframe");
          document.body.appendChild(frame);
          const cw = frame.contentWindow;
          const doc = cw.document;
          doc.open("image/svg+xml", "replace");
          doc.write(bstr);
          doc.close();
          cw.focus();
          doc.execCommand("SaveAs", true, filename);
          document.body.removeChild(frame);
        }
      } else {
        const lang = model.get("lang");
        const html = '<body style="margin:0;"><img src="' + url + '" style="max-width:100%;" title="' + (lang && lang[0] || "") + '" /></body>';
        const tab = window.open();
        tab.document.write(html);
        tab.document.title = title;
      }
    }
  }
  static getDefaultOption(ecModel) {
    const defaultOption3 = {
      show: true,
      icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
      title: ecModel.getLocaleModel().get(["toolbox", "saveAsImage", "title"]),
      type: "png",
      connectedBackgroundColor: "#fff",
      name: "",
      excludeComponents: ["toolbox"],
      lang: ecModel.getLocaleModel().get(["toolbox", "saveAsImage", "lang"])
    };
    return defaultOption3;
  }
};
var SaveAsImage_default = SaveAsImage;

// src/component/toolbox/feature/MagicType.ts
var INNER_STACK_KEYWORD = "__ec_magicType_stack__";
var radioTypes = [
  ["line", "bar"],
  ["stack"]
];
var MagicType = class extends ToolboxFeature {
  getIcons() {
    const model = this.model;
    const availableIcons = model.get("icon");
    const icons = {};
    each(model.get("type"), function(type) {
      if (availableIcons[type]) {
        icons[type] = availableIcons[type];
      }
    });
    return icons;
  }
  static getDefaultOption(ecModel) {
    const defaultOption3 = {
      show: true,
      type: [],
      icon: {
        line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
        bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
        stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
      },
      title: ecModel.getLocaleModel().get(["toolbox", "magicType", "title"]),
      option: {},
      seriesIndex: {}
    };
    return defaultOption3;
  }
  onclick(ecModel, api2, type) {
    const model = this.model;
    const seriesIndex = model.get(["seriesIndex", type]);
    if (!seriesOptGenreator[type]) {
      return;
    }
    const newOption = {
      series: []
    };
    const generateNewSeriesTypes = function(seriesModel) {
      const seriesType2 = seriesModel.subType;
      const seriesId = seriesModel.id;
      const newSeriesOpt = seriesOptGenreator[type](seriesType2, seriesId, seriesModel, model);
      if (newSeriesOpt) {
        defaults(newSeriesOpt, seriesModel.option);
        newOption.series.push(newSeriesOpt);
      }
      const coordSys = seriesModel.coordinateSystem;
      if (coordSys && coordSys.type === "cartesian2d" && (type === "line" || type === "bar")) {
        const categoryAxis2 = coordSys.getAxesByScale("ordinal")[0];
        if (categoryAxis2) {
          const axisDim = categoryAxis2.dim;
          const axisType = axisDim + "Axis";
          const axisModel = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0];
          const axisIndex = axisModel.componentIndex;
          newOption[axisType] = newOption[axisType] || [];
          for (let i = 0; i <= axisIndex; i++) {
            newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {};
          }
          newOption[axisType][axisIndex].boundaryGap = type === "bar";
        }
      }
    };
    each(radioTypes, function(radio) {
      if (indexOf(radio, type) >= 0) {
        each(radio, function(item) {
          model.setIconStatus(item, "normal");
        });
      }
    });
    model.setIconStatus(type, "emphasis");
    ecModel.eachComponent({
      mainType: "series",
      query: seriesIndex == null ? null : {
        seriesIndex
      }
    }, generateNewSeriesTypes);
    let newTitle;
    let currentType = type;
    if (type === "stack") {
      newTitle = merge({
        stack: model.option.title.tiled,
        tiled: model.option.title.stack
      }, model.option.title);
      if (model.get(["iconStatus", type]) !== "emphasis") {
        currentType = "tiled";
      }
    }
    api2.dispatchAction({
      type: "changeMagicType",
      currentType,
      newOption,
      newTitle,
      featureName: "magicType"
    });
  }
};
var seriesOptGenreator = {
  line: function(seriesType2, seriesId, seriesModel, model) {
    if (seriesType2 === "bar") {
      return merge({
        id: seriesId,
        type: "line",
        data: seriesModel.get("data"),
        stack: seriesModel.get("stack"),
        markPoint: seriesModel.get("markPoint"),
        markLine: seriesModel.get("markLine")
      }, model.get(["option", "line"]) || {}, true);
    }
  },
  bar: function(seriesType2, seriesId, seriesModel, model) {
    if (seriesType2 === "line") {
      return merge({
        id: seriesId,
        type: "bar",
        data: seriesModel.get("data"),
        stack: seriesModel.get("stack"),
        markPoint: seriesModel.get("markPoint"),
        markLine: seriesModel.get("markLine")
      }, model.get(["option", "bar"]) || {}, true);
    }
  },
  stack: function(seriesType2, seriesId, seriesModel, model) {
    const isStack = seriesModel.get("stack") === INNER_STACK_KEYWORD;
    if (seriesType2 === "line" || seriesType2 === "bar") {
      model.setIconStatus("stack", isStack ? "normal" : "emphasis");
      return merge({
        id: seriesId,
        stack: isStack ? "" : INNER_STACK_KEYWORD
      }, model.get(["option", "stack"]) || {}, true);
    }
  }
};
registerAction({
  type: "changeMagicType",
  event: "magicTypeChanged",
  update: "prepareAndUpdate"
}, function(payload, ecModel) {
  ecModel.mergeOption(payload.newOption);
});
var MagicType_default = MagicType;

// src/component/toolbox/feature/DataView.ts
var BLOCK_SPLITER = new Array(60).join("-");
var ITEM_SPLITER = "	";
function groupSeries(ecModel) {
  const seriesGroupByCategoryAxis = {};
  const otherSeries = [];
  const meta = [];
  ecModel.eachRawSeries(function(seriesModel) {
    const coordSys = seriesModel.coordinateSystem;
    if (coordSys && (coordSys.type === "cartesian2d" || coordSys.type === "polar")) {
      const baseAxis = coordSys.getBaseAxis();
      if (baseAxis.type === "category") {
        const key = baseAxis.dim + "_" + baseAxis.index;
        if (!seriesGroupByCategoryAxis[key]) {
          seriesGroupByCategoryAxis[key] = {
            categoryAxis: baseAxis,
            valueAxis: coordSys.getOtherAxis(baseAxis),
            series: []
          };
          meta.push({
            axisDim: baseAxis.dim,
            axisIndex: baseAxis.index
          });
        }
        seriesGroupByCategoryAxis[key].series.push(seriesModel);
      } else {
        otherSeries.push(seriesModel);
      }
    } else {
      otherSeries.push(seriesModel);
    }
  });
  return {
    seriesGroupByCategoryAxis,
    other: otherSeries,
    meta
  };
}
function assembleSeriesWithCategoryAxis(groups) {
  const tables = [];
  each(groups, function(group, key) {
    const categoryAxis2 = group.categoryAxis;
    const valueAxis2 = group.valueAxis;
    const valueAxisDim = valueAxis2.dim;
    const headers = [" "].concat(map(group.series, function(series) {
      return series.name;
    }));
    const columns = [categoryAxis2.model.getCategories()];
    each(group.series, function(series) {
      const rawData = series.getRawData();
      columns.push(series.getRawData().mapArray(rawData.mapDimension(valueAxisDim), function(val) {
        return val;
      }));
    });
    const lines = [headers.join(ITEM_SPLITER)];
    for (let i = 0; i < columns[0].length; i++) {
      const items = [];
      for (let j = 0; j < columns.length; j++) {
        items.push(columns[j][i]);
      }
      lines.push(items.join(ITEM_SPLITER));
    }
    tables.push(lines.join("\n"));
  });
  return tables.join("\n\n" + BLOCK_SPLITER + "\n\n");
}
function assembleOtherSeries(series) {
  return map(series, function(series2) {
    const data = series2.getRawData();
    const lines = [series2.name];
    const vals = [];
    data.each(data.dimensions, function() {
      const argLen = arguments.length;
      const dataIndex = arguments[argLen - 1];
      const name = data.getName(dataIndex);
      for (let i = 0; i < argLen - 1; i++) {
        vals[i] = arguments[i];
      }
      lines.push((name ? name + ITEM_SPLITER : "") + vals.join(ITEM_SPLITER));
    });
    return lines.join("\n");
  }).join("\n\n" + BLOCK_SPLITER + "\n\n");
}
function getContentFromModel(ecModel) {
  const result = groupSeries(ecModel);
  return {
    value: filter([
      assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis),
      assembleOtherSeries(result.other)
    ], function(str) {
      return !!str.replace(/[\n\t\s]/g, "");
    }).join("\n\n" + BLOCK_SPLITER + "\n\n"),
    meta: result.meta
  };
}
function trim2(str) {
  return str.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function isTSVFormat(block) {
  const firstLine = block.slice(0, block.indexOf("\n"));
  if (firstLine.indexOf(ITEM_SPLITER) >= 0) {
    return true;
  }
}
var itemSplitRegex = new RegExp("[" + ITEM_SPLITER + "]+", "g");
function parseTSVContents(tsv) {
  const tsvLines = tsv.split(/\n+/g);
  const headers = trim2(tsvLines.shift()).split(itemSplitRegex);
  const categories = [];
  const series = map(headers, function(header) {
    return {
      name: header,
      data: []
    };
  });
  for (let i = 0; i < tsvLines.length; i++) {
    const items = trim2(tsvLines[i]).split(itemSplitRegex);
    categories.push(items.shift());
    for (let j = 0; j < items.length; j++) {
      series[j] && (series[j].data[i] = items[j]);
    }
  }
  return {
    series,
    categories
  };
}
function parseListContents(str) {
  const lines = str.split(/\n+/g);
  const seriesName = trim2(lines.shift());
  const data = [];
  for (let i = 0; i < lines.length; i++) {
    const line2 = trim2(lines[i]);
    if (!line2) {
      continue;
    }
    let items = line2.split(itemSplitRegex);
    let name = "";
    let value;
    let hasName = false;
    if (isNaN(items[0])) {
      hasName = true;
      name = items[0];
      items = items.slice(1);
      data[i] = {
        name,
        value: []
      };
      value = data[i].value;
    } else {
      value = data[i] = [];
    }
    for (let j = 0; j < items.length; j++) {
      value.push(+items[j]);
    }
    if (value.length === 1) {
      hasName ? data[i].value = value[0] : data[i] = value[0];
    }
  }
  return {
    name: seriesName,
    data
  };
}
function parseContents(str, blockMetaList) {
  const blocks = str.split(new RegExp("\n*" + BLOCK_SPLITER + "\n*", "g"));
  const newOption = {
    series: []
  };
  each(blocks, function(block, idx) {
    if (isTSVFormat(block)) {
      const result = parseTSVContents(block);
      const blockMeta = blockMetaList[idx];
      const axisKey = blockMeta.axisDim + "Axis";
      if (blockMeta) {
        newOption[axisKey] = newOption[axisKey] || [];
        newOption[axisKey][blockMeta.axisIndex] = {
          data: result.categories
        };
        newOption.series = newOption.series.concat(result.series);
      }
    } else {
      const result = parseListContents(block);
      newOption.series.push(result);
    }
  });
  return newOption;
}
var DataView = class extends ToolboxFeature {
  onclick(ecModel, api2) {
    setTimeout(() => {
      api2.dispatchAction({
        type: "hideTip"
      });
    });
    const container = api2.getDom();
    const model = this.model;
    if (this._dom) {
      container.removeChild(this._dom);
    }
    const root = document.createElement("div");
    root.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px";
    root.style.backgroundColor = model.get("backgroundColor") || "#fff";
    const header = document.createElement("h4");
    const lang = model.get("lang") || [];
    header.innerHTML = lang[0] || model.get("title");
    header.style.cssText = "margin:10px 20px";
    header.style.color = model.get("textColor");
    const viewMain = document.createElement("div");
    const textarea = document.createElement("textarea");
    viewMain.style.cssText = "overflow:auto";
    const optionToContent = model.get("optionToContent");
    const contentToOption = model.get("contentToOption");
    const result = getContentFromModel(ecModel);
    if (isFunction(optionToContent)) {
      const htmlOrDom = optionToContent(api2.getOption());
      if (isString(htmlOrDom)) {
        viewMain.innerHTML = htmlOrDom;
      } else if (isDom(htmlOrDom)) {
        viewMain.appendChild(htmlOrDom);
      }
    } else {
      textarea.readOnly = model.get("readOnly");
      const style = textarea.style;
      style.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none";
      style.color = model.get("textColor");
      style.borderColor = model.get("textareaBorderColor");
      style.backgroundColor = model.get("textareaColor");
      textarea.value = result.value;
      viewMain.appendChild(textarea);
    }
    const blockMetaList = result.meta;
    const buttonContainer = document.createElement("div");
    buttonContainer.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
    let buttonStyle = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px";
    const closeButton = document.createElement("div");
    const refreshButton = document.createElement("div");
    buttonStyle += ";background-color:" + model.get("buttonColor");
    buttonStyle += ";color:" + model.get("buttonTextColor");
    const self2 = this;
    function close() {
      container.removeChild(root);
      self2._dom = null;
    }
    addEventListener(closeButton, "click", close);
    addEventListener(refreshButton, "click", function() {
      if (contentToOption == null && optionToContent != null || contentToOption != null && optionToContent == null) {
        if (true) {
          warn("It seems you have just provided one of `contentToOption` and `optionToContent` functions but missed the other one. Data change is ignored.");
        }
        close();
        return;
      }
      let newOption;
      try {
        if (isFunction(contentToOption)) {
          newOption = contentToOption(viewMain, api2.getOption());
        } else {
          newOption = parseContents(textarea.value, blockMetaList);
        }
      } catch (e2) {
        close();
        throw new Error("Data view format error " + e2);
      }
      if (newOption) {
        api2.dispatchAction({
          type: "changeDataView",
          newOption
        });
      }
      close();
    });
    closeButton.innerHTML = lang[1];
    refreshButton.innerHTML = lang[2];
    refreshButton.style.cssText = closeButton.style.cssText = buttonStyle;
    !model.get("readOnly") && buttonContainer.appendChild(refreshButton);
    buttonContainer.appendChild(closeButton);
    root.appendChild(header);
    root.appendChild(viewMain);
    root.appendChild(buttonContainer);
    viewMain.style.height = container.clientHeight - 80 + "px";
    container.appendChild(root);
    this._dom = root;
  }
  remove(ecModel, api2) {
    this._dom && api2.getDom().removeChild(this._dom);
  }
  dispose(ecModel, api2) {
    this.remove(ecModel, api2);
  }
  static getDefaultOption(ecModel) {
    const defaultOption3 = {
      show: true,
      readOnly: false,
      optionToContent: null,
      contentToOption: null,
      icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
      title: ecModel.getLocaleModel().get(["toolbox", "dataView", "title"]),
      lang: ecModel.getLocaleModel().get(["toolbox", "dataView", "lang"]),
      backgroundColor: "#fff",
      textColor: "#000",
      textareaColor: "#fff",
      textareaBorderColor: "#333",
      buttonColor: "#c23531",
      buttonTextColor: "#fff"
    };
    return defaultOption3;
  }
};
function tryMergeDataOption(newData, originalData) {
  return map(newData, function(newVal, idx) {
    const original = originalData && originalData[idx];
    if (isObject(original) && !isArray(original)) {
      const newValIsObject = isObject(newVal) && !isArray(newVal);
      if (!newValIsObject) {
        newVal = {
          value: newVal
        };
      }
      const shouldDeleteName = original.name != null && newVal.name == null;
      newVal = defaults(newVal, original);
      shouldDeleteName && delete newVal.name;
      return newVal;
    } else {
      return newVal;
    }
  });
}
registerAction({
  type: "changeDataView",
  event: "dataViewChanged",
  update: "prepareAndUpdate"
}, function(payload, ecModel) {
  const newSeriesOptList = [];
  each(payload.newOption.series, function(seriesOpt) {
    const seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];
    if (!seriesModel) {
      newSeriesOptList.push(extend({
        type: "scatter"
      }, seriesOpt));
    } else {
      const originalData = seriesModel.get("data");
      newSeriesOptList.push({
        name: seriesOpt.name,
        data: tryMergeDataOption(seriesOpt.data, originalData)
      });
    }
  });
  ecModel.mergeOption(defaults({
    series: newSeriesOptList
  }, payload.newOption));
});
var DataView_default = DataView;

// src/component/dataZoom/history.ts
var each10 = each;
var inner16 = makeInner();
function push(ecModel, newSnapshot) {
  const storedSnapshots = getStoreSnapshots(ecModel);
  each10(newSnapshot, function(batchItem, dataZoomId) {
    let i = storedSnapshots.length - 1;
    for (; i >= 0; i--) {
      const snapshot = storedSnapshots[i];
      if (snapshot[dataZoomId]) {
        break;
      }
    }
    if (i < 0) {
      const dataZoomModel = ecModel.queryComponents({mainType: "dataZoom", subType: "select", id: dataZoomId})[0];
      if (dataZoomModel) {
        const percentRange = dataZoomModel.getPercentRange();
        storedSnapshots[0][dataZoomId] = {
          dataZoomId,
          start: percentRange[0],
          end: percentRange[1]
        };
      }
    }
  });
  storedSnapshots.push(newSnapshot);
}
function pop(ecModel) {
  const storedSnapshots = getStoreSnapshots(ecModel);
  const head = storedSnapshots[storedSnapshots.length - 1];
  storedSnapshots.length > 1 && storedSnapshots.pop();
  const snapshot = {};
  each10(head, function(batchItem, dataZoomId) {
    for (let i = storedSnapshots.length - 1; i >= 0; i--) {
      batchItem = storedSnapshots[i][dataZoomId];
      if (batchItem) {
        snapshot[dataZoomId] = batchItem;
        break;
      }
    }
  });
  return snapshot;
}
function clear2(ecModel) {
  inner16(ecModel).snapshots = null;
}
function count(ecModel) {
  return getStoreSnapshots(ecModel).length;
}
function getStoreSnapshots(ecModel) {
  const store = inner16(ecModel);
  if (!store.snapshots) {
    store.snapshots = [{}];
  }
  return store.snapshots;
}

// src/component/toolbox/feature/Restore.ts
var RestoreOption = class extends ToolboxFeature {
  onclick(ecModel, api2) {
    clear2(ecModel);
    api2.dispatchAction({
      type: "restore",
      from: this.uid
    });
  }
  static getDefaultOption(ecModel) {
    const defaultOption3 = {
      show: true,
      icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
      title: ecModel.getLocaleModel().get(["toolbox", "restore", "title"])
    };
    return defaultOption3;
  }
};
registerAction({type: "restore", event: "restore", update: "prepareAndUpdate"}, function(payload, ecModel) {
  ecModel.resetOption("recreate");
});
var Restore_default = RestoreOption;

// src/component/helper/BrushTargetManager.ts
var INCLUDE_FINDER_MAIN_TYPES = [
  "grid",
  "xAxis",
  "yAxis",
  "geo",
  "graph",
  "polar",
  "radiusAxis",
  "angleAxis",
  "bmap"
];
var BrushTargetManager = class {
  constructor(finder, ecModel, opt) {
    this._targetInfoList = [];
    const foundCpts = parseFinder2(ecModel, finder);
    each(targetInfoBuilders, (builder, type) => {
      if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {
        builder(foundCpts, this._targetInfoList);
      }
    });
  }
  setOutputRanges(areas, ecModel) {
    this.matchOutputRanges(areas, ecModel, function(area, coordRange, coordSys) {
      (area.coordRanges || (area.coordRanges = [])).push(coordRange);
      if (!area.coordRange) {
        area.coordRange = coordRange;
        const result = coordConvert[area.brushType](0, coordSys, coordRange);
        area.__rangeOffset = {
          offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),
          xyMinMax: result.xyMinMax
        };
      }
    });
    return areas;
  }
  matchOutputRanges(areas, ecModel, cb) {
    each(areas, function(area) {
      const targetInfo = this.findTargetInfo(area, ecModel);
      if (targetInfo && targetInfo !== true) {
        each(targetInfo.coordSyses, function(coordSys) {
          const result = coordConvert[area.brushType](1, coordSys, area.range, true);
          cb(area, result.values, coordSys, ecModel);
        });
      }
    }, this);
  }
  setInputRanges(areas, ecModel) {
    each(areas, function(area) {
      const targetInfo = this.findTargetInfo(area, ecModel);
      if (true) {
        assert(!targetInfo || targetInfo === true || area.coordRange, "coordRange must be specified when coord index specified.");
        assert(!targetInfo || targetInfo !== true || area.range, "range must be specified in global brush.");
      }
      area.range = area.range || [];
      if (targetInfo && targetInfo !== true) {
        area.panelId = targetInfo.panelId;
        const result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange);
        const rangeOffset = area.__rangeOffset;
        area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values;
      }
    }, this);
  }
  makePanelOpts(api2, getDefaultBrushType) {
    return map(this._targetInfoList, function(targetInfo) {
      const rect = targetInfo.getPanelRect();
      return {
        panelId: targetInfo.panelId,
        defaultBrushType: getDefaultBrushType ? getDefaultBrushType(targetInfo) : null,
        clipPath: makeRectPanelClipPath(rect),
        isTargetByCursor: makeRectIsTargetByCursor(rect, api2, targetInfo.coordSysModel),
        getLinearBrushOtherExtent: makeLinearBrushOtherExtent(rect)
      };
    });
  }
  controlSeries(area, seriesModel, ecModel) {
    const targetInfo = this.findTargetInfo(area, ecModel);
    return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0;
  }
  findTargetInfo(area, ecModel) {
    const targetInfoList = this._targetInfoList;
    const foundCpts = parseFinder2(ecModel, area);
    for (let i = 0; i < targetInfoList.length; i++) {
      const targetInfo = targetInfoList[i];
      const areaPanelId = area.panelId;
      if (areaPanelId) {
        if (targetInfo.panelId === areaPanelId) {
          return targetInfo;
        }
      } else {
        for (let j = 0; j < targetInfoMatchers.length; j++) {
          if (targetInfoMatchers[j](foundCpts, targetInfo)) {
            return targetInfo;
          }
        }
      }
    }
    return true;
  }
};
function formatMinMax(minMax) {
  minMax[0] > minMax[1] && minMax.reverse();
  return minMax;
}
function parseFinder2(ecModel, finder) {
  return parseFinder(ecModel, finder, {includeMainTypes: INCLUDE_FINDER_MAIN_TYPES});
}
var targetInfoBuilders = {
  grid: function(foundCpts, targetInfoList) {
    const xAxisModels = foundCpts.xAxisModels;
    const yAxisModels = foundCpts.yAxisModels;
    const gridModels = foundCpts.gridModels;
    const gridModelMap = createHashMap();
    const xAxesHas = {};
    const yAxesHas = {};
    if (!xAxisModels && !yAxisModels && !gridModels) {
      return;
    }
    each(xAxisModels, function(axisModel) {
      const gridModel = axisModel.axis.grid.model;
      gridModelMap.set(gridModel.id, gridModel);
      xAxesHas[gridModel.id] = true;
    });
    each(yAxisModels, function(axisModel) {
      const gridModel = axisModel.axis.grid.model;
      gridModelMap.set(gridModel.id, gridModel);
      yAxesHas[gridModel.id] = true;
    });
    each(gridModels, function(gridModel) {
      gridModelMap.set(gridModel.id, gridModel);
      xAxesHas[gridModel.id] = true;
      yAxesHas[gridModel.id] = true;
    });
    gridModelMap.each(function(gridModel) {
      const grid = gridModel.coordinateSystem;
      const cartesians = [];
      each(grid.getCartesians(), function(cartesian, index) {
        if (indexOf(xAxisModels, cartesian.getAxis("x").model) >= 0 || indexOf(yAxisModels, cartesian.getAxis("y").model) >= 0) {
          cartesians.push(cartesian);
        }
      });
      targetInfoList.push({
        panelId: "grid--" + gridModel.id,
        gridModel,
        coordSysModel: gridModel,
        coordSys: cartesians[0],
        coordSyses: cartesians,
        getPanelRect: panelRectBuilders.grid,
        xAxisDeclared: xAxesHas[gridModel.id],
        yAxisDeclared: yAxesHas[gridModel.id]
      });
    });
  },
  geo: function(foundCpts, targetInfoList) {
    each(foundCpts.geoModels, function(geoModel) {
      const coordSys = geoModel.coordinateSystem;
      targetInfoList.push({
        panelId: "geo--" + geoModel.id,
        geoModel,
        coordSysModel: geoModel,
        coordSys,
        coordSyses: [coordSys],
        getPanelRect: panelRectBuilders.geo
      });
    });
  }
};
var targetInfoMatchers = [
  function(foundCpts, targetInfo) {
    const xAxisModel = foundCpts.xAxisModel;
    const yAxisModel = foundCpts.yAxisModel;
    let gridModel = foundCpts.gridModel;
    !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model);
    !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model);
    return gridModel && gridModel === targetInfo.gridModel;
  },
  function(foundCpts, targetInfo) {
    const geoModel = foundCpts.geoModel;
    return geoModel && geoModel === targetInfo.geoModel;
  }
];
var panelRectBuilders = {
  grid: function() {
    return this.coordSys.master.getRect().clone();
  },
  geo: function() {
    const coordSys = this.coordSys;
    const rect = coordSys.getBoundingRect().clone();
    rect.applyTransform(getTransform(coordSys));
    return rect;
  }
};
var coordConvert = {
  lineX: curry(axisConvert, 0),
  lineY: curry(axisConvert, 1),
  rect: function(to, coordSys, rangeOrCoordRange, clamp2) {
    const xminymin = to ? coordSys.pointToData([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp2) : coordSys.dataToPoint([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp2);
    const xmaxymax = to ? coordSys.pointToData([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp2) : coordSys.dataToPoint([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp2);
    const values = [
      formatMinMax([xminymin[0], xmaxymax[0]]),
      formatMinMax([xminymin[1], xmaxymax[1]])
    ];
    return {values, xyMinMax: values};
  },
  polygon: function(to, coordSys, rangeOrCoordRange, clamp2) {
    const xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]];
    const values = map(rangeOrCoordRange, function(item) {
      const p = to ? coordSys.pointToData(item, clamp2) : coordSys.dataToPoint(item, clamp2);
      xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0]);
      xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1]);
      xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0]);
      xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1]);
      return p;
    });
    return {values, xyMinMax};
  }
};
function axisConvert(axisNameIndex, to, coordSys, rangeOrCoordRange) {
  if (true) {
    assert(coordSys.type === "cartesian2d", "lineX/lineY brush is available only in cartesian2d.");
  }
  const axis = coordSys.getAxis(["x", "y"][axisNameIndex]);
  const values = formatMinMax(map([0, 1], function(i) {
    return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i]), true) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]));
  }));
  const xyMinMax = [];
  xyMinMax[axisNameIndex] = values;
  xyMinMax[1 - axisNameIndex] = [NaN, NaN];
  return {values, xyMinMax};
}
var diffProcessor = {
  lineX: curry(axisDiffProcessor, 0),
  lineY: curry(axisDiffProcessor, 1),
  rect: function(values, refer, scales) {
    return [
      [values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]],
      [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]
    ];
  },
  polygon: function(values, refer, scales) {
    return map(values, function(item, idx) {
      return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]];
    });
  }
};
function axisDiffProcessor(axisNameIndex, values, refer, scales) {
  return [
    values[0] - scales[axisNameIndex] * refer[0],
    values[1] - scales[axisNameIndex] * refer[1]
  ];
}
function getScales(xyMinMaxCurr, xyMinMaxOrigin) {
  const sizeCurr = getSize2(xyMinMaxCurr);
  const sizeOrigin = getSize2(xyMinMaxOrigin);
  const scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]];
  isNaN(scales[0]) && (scales[0] = 1);
  isNaN(scales[1]) && (scales[1] = 1);
  return scales;
}
function getSize2(xyMinMax) {
  return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN];
}
var BrushTargetManager_default = BrushTargetManager;

// src/component/toolbox/feature/DataZoom.ts
var each11 = each;
var DATA_ZOOM_ID_BASE = makeInternalComponentId("toolbox-dataZoom_");
var DataZoomFeature = class extends ToolboxFeature {
  render(featureModel, ecModel, api2, payload) {
    if (!this._brushController) {
      this._brushController = new BrushController_default(api2.getZr());
      this._brushController.on("brush", bind(this._onBrush, this)).mount();
    }
    updateZoomBtnStatus(featureModel, ecModel, this, payload, api2);
    updateBackBtnStatus(featureModel, ecModel);
  }
  onclick(ecModel, api2, type) {
    handlers2[type].call(this);
  }
  remove(ecModel, api2) {
    this._brushController && this._brushController.unmount();
  }
  dispose(ecModel, api2) {
    this._brushController && this._brushController.dispose();
  }
  _onBrush(eventParam) {
    const areas = eventParam.areas;
    if (!eventParam.isEnd || !areas.length) {
      return;
    }
    const snapshot = {};
    const ecModel = this.ecModel;
    this._brushController.updateCovers([]);
    const brushTargetManager = new BrushTargetManager_default(makeAxisFinder(this.model), ecModel, {include: ["grid"]});
    brushTargetManager.matchOutputRanges(areas, ecModel, function(area, coordRange, coordSys) {
      if (coordSys.type !== "cartesian2d") {
        return;
      }
      const brushType = area.brushType;
      if (brushType === "rect") {
        setBatch("x", coordSys, coordRange[0]);
        setBatch("y", coordSys, coordRange[1]);
      } else {
        setBatch({lineX: "x", lineY: "y"}[brushType], coordSys, coordRange);
      }
    });
    push(ecModel, snapshot);
    this._dispatchZoomAction(snapshot);
    function setBatch(dimName, coordSys, minMax) {
      const axis = coordSys.getAxis(dimName);
      const axisModel = axis.model;
      const dataZoomModel = findDataZoom(dimName, axisModel, ecModel);
      const minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan();
      if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {
        minMax = sliderMove(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan);
      }
      dataZoomModel && (snapshot[dataZoomModel.id] = {
        dataZoomId: dataZoomModel.id,
        startValue: minMax[0],
        endValue: minMax[1]
      });
    }
    function findDataZoom(dimName, axisModel, ecModel2) {
      let found;
      ecModel2.eachComponent({mainType: "dataZoom", subType: "select"}, function(dzModel) {
        const has3 = dzModel.getAxisModel(dimName, axisModel.componentIndex);
        has3 && (found = dzModel);
      });
      return found;
    }
  }
  _dispatchZoomAction(snapshot) {
    const batch = [];
    each11(snapshot, function(batchItem, dataZoomId) {
      batch.push(clone(batchItem));
    });
    batch.length && this.api.dispatchAction({
      type: "dataZoom",
      from: this.uid,
      batch
    });
  }
  static getDefaultOption(ecModel) {
    const defaultOption3 = {
      show: true,
      filterMode: "filter",
      icon: {
        zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
        back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
      },
      title: ecModel.getLocaleModel().get(["toolbox", "dataZoom", "title"]),
      brushStyle: {
        borderWidth: 0,
        color: "rgba(210,219,238,0.2)"
      }
    };
    return defaultOption3;
  }
};
var handlers2 = {
  zoom: function() {
    const nextActive = !this._isZoomActive;
    this.api.dispatchAction({
      type: "takeGlobalCursor",
      key: "dataZoomSelect",
      dataZoomSelectActive: nextActive
    });
  },
  back: function() {
    this._dispatchZoomAction(pop(this.ecModel));
  }
};
function makeAxisFinder(dzFeatureModel) {
  const setting = {
    xAxisIndex: dzFeatureModel.get("xAxisIndex", true),
    yAxisIndex: dzFeatureModel.get("yAxisIndex", true),
    xAxisId: dzFeatureModel.get("xAxisId", true),
    yAxisId: dzFeatureModel.get("yAxisId", true)
  };
  if (setting.xAxisIndex == null && setting.xAxisId == null) {
    setting.xAxisIndex = "all";
  }
  if (setting.yAxisIndex == null && setting.yAxisId == null) {
    setting.yAxisIndex = "all";
  }
  return setting;
}
function updateBackBtnStatus(featureModel, ecModel) {
  featureModel.setIconStatus("back", count(ecModel) > 1 ? "emphasis" : "normal");
}
function updateZoomBtnStatus(featureModel, ecModel, view, payload, api2) {
  let zoomActive = view._isZoomActive;
  if (payload && payload.type === "takeGlobalCursor") {
    zoomActive = payload.key === "dataZoomSelect" ? payload.dataZoomSelectActive : false;
  }
  view._isZoomActive = zoomActive;
  featureModel.setIconStatus("zoom", zoomActive ? "emphasis" : "normal");
  const brushTargetManager = new BrushTargetManager_default(makeAxisFinder(featureModel), ecModel, {include: ["grid"]});
  const panels = brushTargetManager.makePanelOpts(api2, function(targetInfo) {
    return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? "lineX" : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? "lineY" : "rect";
  });
  view._brushController.setPanels(panels).enableBrush(zoomActive && panels.length ? {
    brushType: "auto",
    brushStyle: featureModel.getModel("brushStyle").getItemStyle()
  } : false);
}
registerInternalOptionCreator("dataZoom", function(ecModel) {
  const toolboxModel = ecModel.getComponent("toolbox", 0);
  const featureDataZoomPath = ["feature", "dataZoom"];
  if (!toolboxModel || toolboxModel.get(featureDataZoomPath) == null) {
    return;
  }
  const dzFeatureModel = toolboxModel.getModel(featureDataZoomPath);
  const dzOptions = [];
  const finder = makeAxisFinder(dzFeatureModel);
  const finderResult = parseFinder(ecModel, finder);
  each11(finderResult.xAxisModels, (axisModel) => buildInternalOptions(axisModel, "xAxis", "xAxisIndex"));
  each11(finderResult.yAxisModels, (axisModel) => buildInternalOptions(axisModel, "yAxis", "yAxisIndex"));
  function buildInternalOptions(axisModel, axisMainType, axisIndexPropName) {
    const axisIndex = axisModel.componentIndex;
    const newOpt = {
      type: "select",
      $fromToolbox: true,
      filterMode: dzFeatureModel.get("filterMode", true) || "filter",
      id: DATA_ZOOM_ID_BASE + axisMainType + axisIndex
    };
    newOpt[axisIndexPropName] = axisIndex;
    dzOptions.push(newOpt);
  }
  return dzOptions;
});
var DataZoom_default = DataZoomFeature;

// src/component/toolbox/install.ts
function install36(registers) {
  registers.registerComponentModel(ToolboxModel_default);
  registers.registerComponentView(ToolboxView_default);
  registerFeature("saveAsImage", SaveAsImage_default);
  registerFeature("magicType", MagicType_default);
  registerFeature("dataView", DataView_default);
  registerFeature("dataZoom", DataZoom_default);
  registerFeature("restore", Restore_default);
  use(install35);
}

// src/component/tooltip/TooltipModel.ts
var TooltipModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = TooltipModel2.type;
  }
};
var TooltipModel = TooltipModel2;
TooltipModel.type = "tooltip";
TooltipModel.dependencies = ["axisPointer"];
TooltipModel.defaultOption = {
  z: 60,
  show: true,
  showContent: true,
  trigger: "item",
  triggerOn: "mousemove|click",
  alwaysShowContent: false,
  displayMode: "single",
  renderMode: "auto",
  confine: null,
  showDelay: 0,
  hideDelay: 100,
  transitionDuration: 0.4,
  enterable: false,
  backgroundColor: "#fff",
  shadowBlur: 10,
  shadowColor: "rgba(0, 0, 0, .2)",
  shadowOffsetX: 1,
  shadowOffsetY: 2,
  borderRadius: 4,
  borderWidth: 1,
  padding: null,
  extraCssText: "",
  axisPointer: {
    type: "line",
    axis: "auto",
    animation: "auto",
    animationDurationUpdate: 200,
    animationEasingUpdate: "exponentialOut",
    crossStyle: {
      color: "#999",
      width: 1,
      type: "dashed",
      textStyle: {}
    }
  },
  textStyle: {
    color: "#666",
    fontSize: 14
  }
};
var TooltipModel_default = TooltipModel;

// src/component/tooltip/helper.ts
function shouldTooltipConfine(tooltipModel) {
  const confineOption = tooltipModel.get("confine");
  return confineOption != null ? !!confineOption : tooltipModel.get("renderMode") === "richText";
}
function testStyle(styleProps) {
  if (!env_default.domSupported) {
    return;
  }
  const style = document.documentElement.style;
  for (let i = 0, len2 = styleProps.length; i < len2; i++) {
    if (styleProps[i] in style) {
      return styleProps[i];
    }
  }
}
var TRANSFORM_VENDOR = testStyle(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]);
var TRANSITION_VENDOR = testStyle(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function toCSSVendorPrefix(styleVendor, styleProp) {
  if (!styleVendor) {
    return styleProp;
  }
  styleProp = toCamelCase(styleProp, true);
  const idx = styleVendor.indexOf(styleProp);
  styleVendor = idx === -1 ? styleProp : `-${styleVendor.slice(0, idx)}-${styleProp}`;
  return styleVendor.toLowerCase();
}
function getComputedStyle(el, style) {
  const stl = el.currentStyle || document.defaultView && document.defaultView.getComputedStyle(el);
  return stl ? style ? stl[style] : stl : null;
}

// src/component/tooltip/TooltipHTMLContent.ts
var CSS_TRANSITION_VENDOR = toCSSVendorPrefix(TRANSITION_VENDOR, "transition");
var CSS_TRANSFORM_VENDOR = toCSSVendorPrefix(TRANSFORM_VENDOR, "transform");
var gCssText = `position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;${env_default.transform3dSupported ? "will-change:transform;" : ""}`;
function mirrorPos(pos) {
  pos = pos === "left" ? "right" : pos === "right" ? "left" : pos === "top" ? "bottom" : "top";
  return pos;
}
function assembleArrow(tooltipModel, borderColor, arrowPosition) {
  if (!isString(arrowPosition) || arrowPosition === "inside") {
    return "";
  }
  const backgroundColor2 = tooltipModel.get("backgroundColor");
  const borderWidth = tooltipModel.get("borderWidth");
  borderColor = convertToColorString(borderColor);
  const arrowPos = mirrorPos(arrowPosition);
  const arrowSize = Math.max(Math.round(borderWidth) * 1.5, 6);
  let positionStyle = "";
  let transformStyle = CSS_TRANSFORM_VENDOR + ":";
  let rotateDeg;
  if (indexOf(["left", "right"], arrowPos) > -1) {
    positionStyle += "top:50%";
    transformStyle += `translateY(-50%) rotate(${rotateDeg = arrowPos === "left" ? -225 : -45}deg)`;
  } else {
    positionStyle += "left:50%";
    transformStyle += `translateX(-50%) rotate(${rotateDeg = arrowPos === "top" ? 225 : 45}deg)`;
  }
  const rotateRadian = rotateDeg * Math.PI / 180;
  const arrowWH = arrowSize + borderWidth;
  const rotatedWH = arrowWH * Math.abs(Math.cos(rotateRadian)) + arrowWH * Math.abs(Math.sin(rotateRadian));
  const arrowOffset = Math.round(((rotatedWH - Math.SQRT2 * borderWidth) / 2 + Math.SQRT2 * borderWidth - (rotatedWH - arrowWH) / 2) * 100) / 100;
  positionStyle += `;${arrowPos}:-${arrowOffset}px`;
  const borderStyle = `${borderColor} solid ${borderWidth}px;`;
  const styleCss = [
    `position:absolute;width:${arrowSize}px;height:${arrowSize}px;z-index:-1;`,
    `${positionStyle};${transformStyle};`,
    `border-bottom:${borderStyle}`,
    `border-right:${borderStyle}`,
    `background-color:${backgroundColor2};`
  ];
  return `<div style="${styleCss.join("")}"></div>`;
}
function assembleTransition(duration, onlyFade) {
  const transitionCurve = "cubic-bezier(0.23,1,0.32,1)";
  let transitionOption = ` ${duration / 2}s ${transitionCurve}`;
  let transitionText = `opacity${transitionOption},visibility${transitionOption}`;
  if (!onlyFade) {
    transitionOption = ` ${duration}s ${transitionCurve}`;
    transitionText += env_default.transformSupported ? `,${CSS_TRANSFORM_VENDOR}${transitionOption}` : `,left${transitionOption},top${transitionOption}`;
  }
  return CSS_TRANSITION_VENDOR + ":" + transitionText;
}
function assembleTransform(x, y, toString) {
  const x0 = x.toFixed(0) + "px";
  const y0 = y.toFixed(0) + "px";
  if (!env_default.transformSupported) {
    return toString ? `top:${y0};left:${x0};` : [["top", y0], ["left", x0]];
  }
  const is3d = env_default.transform3dSupported;
  const translate2 = `translate${is3d ? "3d" : ""}(${x0},${y0}${is3d ? ",0" : ""})`;
  return toString ? "top:0;left:0;" + CSS_TRANSFORM_VENDOR + ":" + translate2 + ";" : [["top", 0], ["left", 0], [TRANSFORM_VENDOR, translate2]];
}
function assembleFont(textStyleModel) {
  const cssText = [];
  const fontSize = textStyleModel.get("fontSize");
  const color2 = textStyleModel.getTextColor();
  color2 && cssText.push("color:" + color2);
  cssText.push("font:" + textStyleModel.getFont());
  fontSize && cssText.push("line-height:" + Math.round(fontSize * 3 / 2) + "px");
  const shadowColor = textStyleModel.get("textShadowColor");
  const shadowBlur = textStyleModel.get("textShadowBlur") || 0;
  const shadowOffsetX = textStyleModel.get("textShadowOffsetX") || 0;
  const shadowOffsetY = textStyleModel.get("textShadowOffsetY") || 0;
  shadowColor && shadowBlur && cssText.push("text-shadow:" + shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor);
  each(["decoration", "align"], function(name) {
    const val = textStyleModel.get(name);
    val && cssText.push("text-" + name + ":" + val);
  });
  return cssText.join(";");
}
function assembleCssText(tooltipModel, enableTransition, onlyFade) {
  const cssText = [];
  const transitionDuration = tooltipModel.get("transitionDuration");
  const backgroundColor2 = tooltipModel.get("backgroundColor");
  const shadowBlur = tooltipModel.get("shadowBlur");
  const shadowColor = tooltipModel.get("shadowColor");
  const shadowOffsetX = tooltipModel.get("shadowOffsetX");
  const shadowOffsetY = tooltipModel.get("shadowOffsetY");
  const textStyleModel = tooltipModel.getModel("textStyle");
  const padding = getPaddingFromTooltipModel(tooltipModel, "html");
  const boxShadow = `${shadowOffsetX}px ${shadowOffsetY}px ${shadowBlur}px ${shadowColor}`;
  cssText.push("box-shadow:" + boxShadow);
  enableTransition && transitionDuration && cssText.push(assembleTransition(transitionDuration, onlyFade));
  if (backgroundColor2) {
    cssText.push("background-color:" + backgroundColor2);
  }
  each(["width", "color", "radius"], function(name) {
    const borderName = "border-" + name;
    const camelCase = toCamelCase(borderName);
    const val = tooltipModel.get(camelCase);
    val != null && cssText.push(borderName + ":" + val + (name === "color" ? "" : "px"));
  });
  cssText.push(assembleFont(textStyleModel));
  if (padding != null) {
    cssText.push("padding:" + normalizeCssArray2(padding).join("px ") + "px");
  }
  return cssText.join(";") + ";";
}
function makeStyleCoord(out2, zr, container, zrX, zrY) {
  const zrPainter = zr && zr.painter;
  if (container) {
    const zrViewportRoot = zrPainter && zrPainter.getViewportRoot();
    if (zrViewportRoot) {
      transformLocalCoord(out2, zrViewportRoot, container, zrX, zrY);
    }
  } else {
    out2[0] = zrX;
    out2[1] = zrY;
    const viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset();
    if (viewportRootOffset) {
      out2[0] += viewportRootOffset.offsetLeft;
      out2[1] += viewportRootOffset.offsetTop;
    }
  }
  out2[2] = out2[0] / zr.getWidth();
  out2[3] = out2[1] / zr.getHeight();
}
var TooltipHTMLContent = class {
  constructor(api2, opt) {
    this._show = false;
    this._styleCoord = [0, 0, 0, 0];
    this._enterable = true;
    this._alwaysShowContent = false;
    this._firstShow = true;
    this._longHide = true;
    if (env_default.wxa) {
      return null;
    }
    const el = document.createElement("div");
    el.domBelongToZr = true;
    this.el = el;
    const zr = this._zr = api2.getZr();
    const appendTo = opt.appendTo;
    const container = appendTo && (isString(appendTo) ? document.querySelector(appendTo) : isDom(appendTo) ? appendTo : isFunction(appendTo) && appendTo(api2.getDom()));
    makeStyleCoord(this._styleCoord, zr, container, api2.getWidth() / 2, api2.getHeight() / 2);
    (container || api2.getDom()).appendChild(el);
    this._api = api2;
    this._container = container;
    const self2 = this;
    el.onmouseenter = function() {
      if (self2._enterable) {
        clearTimeout(self2._hideTimeout);
        self2._show = true;
      }
      self2._inContent = true;
    };
    el.onmousemove = function(e2) {
      e2 = e2 || window.event;
      if (!self2._enterable) {
        const handler = zr.handler;
        const zrViewportRoot = zr.painter.getViewportRoot();
        normalizeEvent(zrViewportRoot, e2, true);
        handler.dispatch("mousemove", e2);
      }
    };
    el.onmouseleave = function() {
      self2._inContent = false;
      if (self2._enterable) {
        if (self2._show) {
          self2.hideLater(self2._hideDelay);
        }
      }
    };
  }
  update(tooltipModel) {
    if (!this._container) {
      const container = this._api.getDom();
      const position2 = getComputedStyle(container, "position");
      const domStyle = container.style;
      if (domStyle.position !== "absolute" && position2 !== "absolute") {
        domStyle.position = "relative";
      }
    }
    const alwaysShowContent = tooltipModel.get("alwaysShowContent");
    alwaysShowContent && this._moveIfResized();
    this._alwaysShowContent = alwaysShowContent;
    this.el.className = tooltipModel.get("className") || "";
  }
  show(tooltipModel, nearPointColor) {
    clearTimeout(this._hideTimeout);
    clearTimeout(this._longHideTimeout);
    const el = this.el;
    const style = el.style;
    const styleCoord = this._styleCoord;
    if (!el.innerHTML) {
      style.display = "none";
    } else {
      style.cssText = gCssText + assembleCssText(tooltipModel, !this._firstShow, this._longHide) + assembleTransform(styleCoord[0], styleCoord[1], true) + `border-color:${convertToColorString(nearPointColor)};` + (tooltipModel.get("extraCssText") || "") + `;pointer-events:${this._enterable ? "auto" : "none"}`;
    }
    this._show = true;
    this._firstShow = false;
    this._longHide = false;
  }
  setContent(content, markers, tooltipModel, borderColor, arrowPosition) {
    const el = this.el;
    if (content == null) {
      el.innerHTML = "";
      return;
    }
    let arrow = "";
    if (isString(arrowPosition) && tooltipModel.get("trigger") === "item" && !shouldTooltipConfine(tooltipModel)) {
      arrow = assembleArrow(tooltipModel, borderColor, arrowPosition);
    }
    if (isString(content)) {
      el.innerHTML = content + arrow;
    } else if (content) {
      el.innerHTML = "";
      if (!isArray(content)) {
        content = [content];
      }
      for (let i = 0; i < content.length; i++) {
        if (isDom(content[i]) && content[i].parentNode !== el) {
          el.appendChild(content[i]);
        }
      }
      if (arrow && el.childNodes.length) {
        const arrowEl = document.createElement("div");
        arrowEl.innerHTML = arrow;
        el.appendChild(arrowEl);
      }
    }
  }
  setEnterable(enterable) {
    this._enterable = enterable;
  }
  getSize() {
    const el = this.el;
    return [el.offsetWidth, el.offsetHeight];
  }
  moveTo(zrX, zrY) {
    const styleCoord = this._styleCoord;
    makeStyleCoord(styleCoord, this._zr, this._container, zrX, zrY);
    if (styleCoord[0] != null && styleCoord[1] != null) {
      const style = this.el.style;
      const transforms = assembleTransform(styleCoord[0], styleCoord[1]);
      each(transforms, (transform2) => {
        style[transform2[0]] = transform2[1];
      });
    }
  }
  _moveIfResized() {
    const ratioX = this._styleCoord[2];
    const ratioY = this._styleCoord[3];
    this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
  }
  hide() {
    const style = this.el.style;
    style.visibility = "hidden";
    style.opacity = "0";
    env_default.transform3dSupported && (style.willChange = "");
    this._show = false;
    this._longHideTimeout = setTimeout(() => this._longHide = true, 500);
  }
  hideLater(time) {
    if (this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent) {
      if (time) {
        this._hideDelay = time;
        this._show = false;
        this._hideTimeout = setTimeout(bind(this.hide, this), time);
      } else {
        this.hide();
      }
    }
  }
  isShow() {
    return this._show;
  }
  dispose() {
    clearTimeout(this._hideTimeout);
    clearTimeout(this._longHideTimeout);
    const parentNode2 = this.el.parentNode;
    parentNode2 && parentNode2.removeChild(this.el);
    this.el = this._container = null;
  }
};
var TooltipHTMLContent_default = TooltipHTMLContent;

// src/component/tooltip/TooltipRichContent.ts
var TooltipRichContent = class {
  constructor(api2) {
    this._show = false;
    this._styleCoord = [0, 0, 0, 0];
    this._alwaysShowContent = false;
    this._enterable = true;
    this._zr = api2.getZr();
    makeStyleCoord2(this._styleCoord, this._zr, api2.getWidth() / 2, api2.getHeight() / 2);
  }
  update(tooltipModel) {
    const alwaysShowContent = tooltipModel.get("alwaysShowContent");
    alwaysShowContent && this._moveIfResized();
    this._alwaysShowContent = alwaysShowContent;
  }
  show() {
    if (this._hideTimeout) {
      clearTimeout(this._hideTimeout);
    }
    this.el.show();
    this._show = true;
  }
  setContent(content, markupStyleCreator, tooltipModel, borderColor, arrowPosition) {
    if (isObject(content)) {
      throwError(true ? "Passing DOM nodes as content is not supported in richText tooltip!" : "");
    }
    if (this.el) {
      this._zr.remove(this.el);
    }
    const textStyleModel = tooltipModel.getModel("textStyle");
    this.el = new Text_default({
      style: {
        rich: markupStyleCreator.richTextStyles,
        text: content,
        lineHeight: 22,
        borderWidth: 1,
        borderColor,
        textShadowColor: textStyleModel.get("textShadowColor"),
        fill: tooltipModel.get(["textStyle", "color"]),
        padding: getPaddingFromTooltipModel(tooltipModel, "richText"),
        verticalAlign: "top",
        align: "left"
      },
      z: tooltipModel.get("z")
    });
    each([
      "backgroundColor",
      "borderRadius",
      "shadowColor",
      "shadowBlur",
      "shadowOffsetX",
      "shadowOffsetY"
    ], (propName) => {
      this.el.style[propName] = tooltipModel.get(propName);
    });
    each([
      "textShadowBlur",
      "textShadowOffsetX",
      "textShadowOffsetY"
    ], (propName) => {
      this.el.style[propName] = textStyleModel.get(propName) || 0;
    });
    this._zr.add(this.el);
    const self2 = this;
    this.el.on("mouseover", function() {
      if (self2._enterable) {
        clearTimeout(self2._hideTimeout);
        self2._show = true;
      }
      self2._inContent = true;
    });
    this.el.on("mouseout", function() {
      if (self2._enterable) {
        if (self2._show) {
          self2.hideLater(self2._hideDelay);
        }
      }
      self2._inContent = false;
    });
  }
  setEnterable(enterable) {
    this._enterable = enterable;
  }
  getSize() {
    const el = this.el;
    const bounding = this.el.getBoundingRect();
    const shadowOuterSize = calcShadowOuterSize(el.style);
    return [
      bounding.width + shadowOuterSize.left + shadowOuterSize.right,
      bounding.height + shadowOuterSize.top + shadowOuterSize.bottom
    ];
  }
  moveTo(x, y) {
    const el = this.el;
    if (el) {
      const styleCoord = this._styleCoord;
      makeStyleCoord2(styleCoord, this._zr, x, y);
      x = styleCoord[0];
      y = styleCoord[1];
      const style = el.style;
      const borderWidth = mathMaxWith0(style.borderWidth || 0);
      const shadowOuterSize = calcShadowOuterSize(style);
      el.x = x + borderWidth + shadowOuterSize.left;
      el.y = y + borderWidth + shadowOuterSize.top;
      el.markRedraw();
    }
  }
  _moveIfResized() {
    const ratioX = this._styleCoord[2];
    const ratioY = this._styleCoord[3];
    this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
  }
  hide() {
    if (this.el) {
      this.el.hide();
    }
    this._show = false;
  }
  hideLater(time) {
    if (this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent) {
      if (time) {
        this._hideDelay = time;
        this._show = false;
        this._hideTimeout = setTimeout(bind(this.hide, this), time);
      } else {
        this.hide();
      }
    }
  }
  isShow() {
    return this._show;
  }
  dispose() {
    this._zr.remove(this.el);
  }
};
function mathMaxWith0(val) {
  return Math.max(0, val);
}
function calcShadowOuterSize(style) {
  const shadowBlur = mathMaxWith0(style.shadowBlur || 0);
  const shadowOffsetX = mathMaxWith0(style.shadowOffsetX || 0);
  const shadowOffsetY = mathMaxWith0(style.shadowOffsetY || 0);
  return {
    left: mathMaxWith0(shadowBlur - shadowOffsetX),
    right: mathMaxWith0(shadowBlur + shadowOffsetX),
    top: mathMaxWith0(shadowBlur - shadowOffsetY),
    bottom: mathMaxWith0(shadowBlur + shadowOffsetY)
  };
}
function makeStyleCoord2(out2, zr, zrX, zrY) {
  out2[0] = zrX;
  out2[1] = zrY;
  out2[2] = out2[0] / zr.getWidth();
  out2[3] = out2[1] / zr.getHeight();
}
var TooltipRichContent_default = TooltipRichContent;

// src/component/tooltip/TooltipView.ts
var proxyRect = new Rect_default({
  shape: {x: -1, y: -1, width: 2, height: 2}
});
var TooltipView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = TooltipView2.type;
  }
  init(ecModel, api2) {
    if (env_default.node || !api2.getDom()) {
      return;
    }
    const tooltipModel = ecModel.getComponent("tooltip");
    const renderMode = this._renderMode = getTooltipRenderMode(tooltipModel.get("renderMode"));
    this._tooltipContent = renderMode === "richText" ? new TooltipRichContent_default(api2) : new TooltipHTMLContent_default(api2, {
      appendTo: tooltipModel.get("appendToBody", true) ? "body" : tooltipModel.get("appendTo", true)
    });
  }
  render(tooltipModel, ecModel, api2) {
    if (env_default.node || !api2.getDom()) {
      return;
    }
    this.group.removeAll();
    this._tooltipModel = tooltipModel;
    this._ecModel = ecModel;
    this._api = api2;
    const tooltipContent = this._tooltipContent;
    tooltipContent.update(tooltipModel);
    tooltipContent.setEnterable(tooltipModel.get("enterable"));
    this._initGlobalListener();
    this._keepShow();
    if (this._renderMode !== "richText" && tooltipModel.get("transitionDuration")) {
      createOrUpdate(this, "_updatePosition", 50, "fixRate");
    } else {
      clear(this, "_updatePosition");
    }
  }
  _initGlobalListener() {
    const tooltipModel = this._tooltipModel;
    const triggerOn = tooltipModel.get("triggerOn");
    register("itemTooltip", this._api, bind(function(currTrigger, e2, dispatchAction3) {
      if (triggerOn !== "none") {
        if (triggerOn.indexOf(currTrigger) >= 0) {
          this._tryShow(e2, dispatchAction3);
        } else if (currTrigger === "leave") {
          this._hide(dispatchAction3);
        }
      }
    }, this));
  }
  _keepShow() {
    const tooltipModel = this._tooltipModel;
    const ecModel = this._ecModel;
    const api2 = this._api;
    const triggerOn = tooltipModel.get("triggerOn");
    if (this._lastX != null && this._lastY != null && triggerOn !== "none" && triggerOn !== "click") {
      const self2 = this;
      clearTimeout(this._refreshUpdateTimeout);
      this._refreshUpdateTimeout = setTimeout(function() {
        !api2.isDisposed() && self2.manuallyShowTip(tooltipModel, ecModel, api2, {
          x: self2._lastX,
          y: self2._lastY,
          dataByCoordSys: self2._lastDataByCoordSys
        });
      });
    }
  }
  manuallyShowTip(tooltipModel, ecModel, api2, payload) {
    if (payload.from === this.uid || env_default.node || !api2.getDom()) {
      return;
    }
    const dispatchAction3 = makeDispatchAction2(payload, api2);
    this._ticket = "";
    const dataByCoordSys = payload.dataByCoordSys;
    const cmptRef = findComponentReference(payload, ecModel, api2);
    if (cmptRef) {
      const rect = cmptRef.el.getBoundingRect().clone();
      rect.applyTransform(cmptRef.el.transform);
      this._tryShow({
        offsetX: rect.x + rect.width / 2,
        offsetY: rect.y + rect.height / 2,
        target: cmptRef.el,
        position: payload.position,
        positionDefault: "bottom"
      }, dispatchAction3);
    } else if (payload.tooltip && payload.x != null && payload.y != null) {
      const el = proxyRect;
      el.x = payload.x;
      el.y = payload.y;
      el.update();
      getECData(el).tooltipConfig = {
        name: null,
        option: payload.tooltip
      };
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        target: el
      }, dispatchAction3);
    } else if (dataByCoordSys) {
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        dataByCoordSys,
        tooltipOption: payload.tooltipOption
      }, dispatchAction3);
    } else if (payload.seriesIndex != null) {
      if (this._manuallyAxisShowTip(tooltipModel, ecModel, api2, payload)) {
        return;
      }
      const pointInfo = findPointFromSeries(payload, ecModel);
      const cx = pointInfo.point[0];
      const cy = pointInfo.point[1];
      if (cx != null && cy != null) {
        this._tryShow({
          offsetX: cx,
          offsetY: cy,
          target: pointInfo.el,
          position: payload.position,
          positionDefault: "bottom"
        }, dispatchAction3);
      }
    } else if (payload.x != null && payload.y != null) {
      api2.dispatchAction({
        type: "updateAxisPointer",
        x: payload.x,
        y: payload.y
      });
      this._tryShow({
        offsetX: payload.x,
        offsetY: payload.y,
        position: payload.position,
        target: api2.getZr().findHover(payload.x, payload.y).target
      }, dispatchAction3);
    }
  }
  manuallyHideTip(tooltipModel, ecModel, api2, payload) {
    const tooltipContent = this._tooltipContent;
    if (this._tooltipModel) {
      tooltipContent.hideLater(this._tooltipModel.get("hideDelay"));
    }
    this._lastX = this._lastY = this._lastDataByCoordSys = null;
    if (payload.from !== this.uid) {
      this._hide(makeDispatchAction2(payload, api2));
    }
  }
  _manuallyAxisShowTip(tooltipModel, ecModel, api2, payload) {
    const seriesIndex = payload.seriesIndex;
    const dataIndex = payload.dataIndex;
    const coordSysAxesInfo = ecModel.getComponent("axisPointer").coordSysAxesInfo;
    if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
      return;
    }
    const seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    if (!seriesModel) {
      return;
    }
    const data = seriesModel.getData();
    const tooltipCascadedModel = buildTooltipModel([
      data.getItemModel(dataIndex),
      seriesModel,
      (seriesModel.coordinateSystem || {}).model
    ], this._tooltipModel);
    if (tooltipCascadedModel.get("trigger") !== "axis") {
      return;
    }
    api2.dispatchAction({
      type: "updateAxisPointer",
      seriesIndex,
      dataIndex,
      position: payload.position
    });
    return true;
  }
  _tryShow(e2, dispatchAction3) {
    const el = e2.target;
    const tooltipModel = this._tooltipModel;
    if (!tooltipModel) {
      return;
    }
    this._lastX = e2.offsetX;
    this._lastY = e2.offsetY;
    const dataByCoordSys = e2.dataByCoordSys;
    if (dataByCoordSys && dataByCoordSys.length) {
      this._showAxisTooltip(dataByCoordSys, e2);
    } else if (el) {
      const ecData = getECData(el);
      if (ecData.ssrType === "legend") {
        return;
      }
      this._lastDataByCoordSys = null;
      let seriesDispatcher;
      let cmptDispatcher;
      findEventDispatcher(el, (target) => {
        if (getECData(target).dataIndex != null) {
          seriesDispatcher = target;
          return true;
        }
        if (getECData(target).tooltipConfig != null) {
          cmptDispatcher = target;
          return true;
        }
      }, true);
      if (seriesDispatcher) {
        this._showSeriesItemTooltip(e2, seriesDispatcher, dispatchAction3);
      } else if (cmptDispatcher) {
        this._showComponentItemTooltip(e2, cmptDispatcher, dispatchAction3);
      } else {
        this._hide(dispatchAction3);
      }
    } else {
      this._lastDataByCoordSys = null;
      this._hide(dispatchAction3);
    }
  }
  _showOrMove(tooltipModel, cb) {
    const delay = tooltipModel.get("showDelay");
    cb = bind(cb, this);
    clearTimeout(this._showTimout);
    delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
  }
  _showAxisTooltip(dataByCoordSys, e2) {
    const ecModel = this._ecModel;
    const globalTooltipModel = this._tooltipModel;
    const point = [e2.offsetX, e2.offsetY];
    const singleTooltipModel = buildTooltipModel([e2.tooltipOption], globalTooltipModel);
    const renderMode = this._renderMode;
    const cbParamsList = [];
    const articleMarkup = createTooltipMarkup("section", {
      blocks: [],
      noHeader: true
    });
    const markupTextArrLegacy = [];
    const markupStyleCreator = new TooltipMarkupStyleCreator();
    each(dataByCoordSys, function(itemCoordSys) {
      each(itemCoordSys.dataByAxis, function(axisItem) {
        const axisModel = ecModel.getComponent(axisItem.axisDim + "Axis", axisItem.axisIndex);
        const axisValue = axisItem.value;
        if (!axisModel || axisValue == null) {
          return;
        }
        const axisValueLabel = getValueLabel(axisValue, axisModel.axis, ecModel, axisItem.seriesDataIndices, axisItem.valueLabelOpt);
        const axisSectionMarkup = createTooltipMarkup("section", {
          header: axisValueLabel,
          noHeader: !trim(axisValueLabel),
          sortBlocks: true,
          blocks: []
        });
        articleMarkup.blocks.push(axisSectionMarkup);
        each(axisItem.seriesDataIndices, function(idxItem) {
          const series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
          const dataIndex = idxItem.dataIndexInside;
          const cbParams = series.getDataParams(dataIndex);
          if (cbParams.dataIndex < 0) {
            return;
          }
          cbParams.axisDim = axisItem.axisDim;
          cbParams.axisIndex = axisItem.axisIndex;
          cbParams.axisType = axisItem.axisType;
          cbParams.axisId = axisItem.axisId;
          cbParams.axisValue = getAxisRawValue(axisModel.axis, {value: axisValue});
          cbParams.axisValueLabel = axisValueLabel;
          cbParams.marker = markupStyleCreator.makeTooltipMarker("item", convertToColorString(cbParams.color), renderMode);
          const seriesTooltipResult = normalizeTooltipFormatResult(series.formatTooltip(dataIndex, true, null));
          const frag = seriesTooltipResult.frag;
          if (frag) {
            const valueFormatter = buildTooltipModel([series], globalTooltipModel).get("valueFormatter");
            axisSectionMarkup.blocks.push(valueFormatter ? extend({valueFormatter}, frag) : frag);
          }
          if (seriesTooltipResult.text) {
            markupTextArrLegacy.push(seriesTooltipResult.text);
          }
          cbParamsList.push(cbParams);
        });
      });
    });
    articleMarkup.blocks.reverse();
    markupTextArrLegacy.reverse();
    const positionExpr = e2.position;
    const orderMode = singleTooltipModel.get("order");
    const builtMarkupText = buildTooltipMarkup(articleMarkup, markupStyleCreator, renderMode, orderMode, ecModel.get("useUTC"), singleTooltipModel.get("textStyle"));
    builtMarkupText && markupTextArrLegacy.unshift(builtMarkupText);
    const blockBreak = renderMode === "richText" ? "\n\n" : "<br/>";
    const allMarkupText = markupTextArrLegacy.join(blockBreak);
    this._showOrMove(singleTooltipModel, function() {
      if (this._updateContentNotChangedOnAxis(dataByCoordSys, cbParamsList)) {
        this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, cbParamsList);
      } else {
        this._showTooltipContent(singleTooltipModel, allMarkupText, cbParamsList, Math.random() + "", point[0], point[1], positionExpr, null, markupStyleCreator);
      }
    });
  }
  _showSeriesItemTooltip(e2, dispatcher, dispatchAction3) {
    const ecModel = this._ecModel;
    const ecData = getECData(dispatcher);
    const seriesIndex = ecData.seriesIndex;
    const seriesModel = ecModel.getSeriesByIndex(seriesIndex);
    const dataModel = ecData.dataModel || seriesModel;
    const dataIndex = ecData.dataIndex;
    const dataType = ecData.dataType;
    const data = dataModel.getData(dataType);
    const renderMode = this._renderMode;
    const positionDefault = e2.positionDefault;
    const tooltipModel = buildTooltipModel([
      data.getItemModel(dataIndex),
      dataModel,
      seriesModel && (seriesModel.coordinateSystem || {}).model
    ], this._tooltipModel, positionDefault ? {position: positionDefault} : null);
    const tooltipTrigger = tooltipModel.get("trigger");
    if (tooltipTrigger != null && tooltipTrigger !== "item") {
      return;
    }
    const params = dataModel.getDataParams(dataIndex, dataType);
    const markupStyleCreator = new TooltipMarkupStyleCreator();
    params.marker = markupStyleCreator.makeTooltipMarker("item", convertToColorString(params.color), renderMode);
    const seriesTooltipResult = normalizeTooltipFormatResult(dataModel.formatTooltip(dataIndex, false, dataType));
    const orderMode = tooltipModel.get("order");
    const valueFormatter = tooltipModel.get("valueFormatter");
    const frag = seriesTooltipResult.frag;
    const markupText = frag ? buildTooltipMarkup(valueFormatter ? extend({valueFormatter}, frag) : frag, markupStyleCreator, renderMode, orderMode, ecModel.get("useUTC"), tooltipModel.get("textStyle")) : seriesTooltipResult.text;
    const asyncTicket = "item_" + dataModel.name + "_" + dataIndex;
    this._showOrMove(tooltipModel, function() {
      this._showTooltipContent(tooltipModel, markupText, params, asyncTicket, e2.offsetX, e2.offsetY, e2.position, e2.target, markupStyleCreator);
    });
    dispatchAction3({
      type: "showTip",
      dataIndexInside: dataIndex,
      dataIndex: data.getRawIndex(dataIndex),
      seriesIndex,
      from: this.uid
    });
  }
  _showComponentItemTooltip(e2, el, dispatchAction3) {
    const ecData = getECData(el);
    const tooltipConfig = ecData.tooltipConfig;
    let tooltipOpt = tooltipConfig.option || {};
    if (isString(tooltipOpt)) {
      const content = tooltipOpt;
      tooltipOpt = {
        content,
        formatter: content
      };
    }
    const tooltipModelCascade = [tooltipOpt];
    const cmpt = this._ecModel.getComponent(ecData.componentMainType, ecData.componentIndex);
    if (cmpt) {
      tooltipModelCascade.push(cmpt);
    }
    tooltipModelCascade.push({formatter: tooltipOpt.content});
    const positionDefault = e2.positionDefault;
    const subTooltipModel = buildTooltipModel(tooltipModelCascade, this._tooltipModel, positionDefault ? {position: positionDefault} : null);
    const defaultHtml = subTooltipModel.get("content");
    const asyncTicket = Math.random() + "";
    const markupStyleCreator = new TooltipMarkupStyleCreator();
    this._showOrMove(subTooltipModel, function() {
      const formatterParams = clone(subTooltipModel.get("formatterParams") || {});
      this._showTooltipContent(subTooltipModel, defaultHtml, formatterParams, asyncTicket, e2.offsetX, e2.offsetY, e2.position, el, markupStyleCreator);
    });
    dispatchAction3({
      type: "showTip",
      from: this.uid
    });
  }
  _showTooltipContent(tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el, markupStyleCreator) {
    this._ticket = "";
    if (!tooltipModel.get("showContent") || !tooltipModel.get("show")) {
      return;
    }
    const tooltipContent = this._tooltipContent;
    tooltipContent.setEnterable(tooltipModel.get("enterable"));
    const formatter = tooltipModel.get("formatter");
    positionExpr = positionExpr || tooltipModel.get("position");
    let html = defaultHtml;
    const nearPoint = this._getNearestPoint([x, y], params, tooltipModel.get("trigger"), tooltipModel.get("borderColor"));
    const nearPointColor = nearPoint.color;
    if (formatter) {
      if (isString(formatter)) {
        const useUTC = tooltipModel.ecModel.get("useUTC");
        const params0 = isArray(params) ? params[0] : params;
        const isTimeAxis = params0 && params0.axisType && params0.axisType.indexOf("time") >= 0;
        html = formatter;
        if (isTimeAxis) {
          html = format(params0.axisValue, html, useUTC);
        }
        html = formatTpl(html, params, true);
      } else if (isFunction(formatter)) {
        const callback = bind(function(cbTicket, html2) {
          if (cbTicket === this._ticket) {
            tooltipContent.setContent(html2, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
            this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
          }
        }, this);
        this._ticket = asyncTicket;
        html = formatter(params, asyncTicket, callback);
      } else {
        html = formatter;
      }
    }
    tooltipContent.setContent(html, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);
    tooltipContent.show(tooltipModel, nearPointColor);
    this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
  }
  _getNearestPoint(point, tooltipDataParams, trigger3, borderColor) {
    if (trigger3 === "axis" || isArray(tooltipDataParams)) {
      return {
        color: borderColor || (this._renderMode === "html" ? "#fff" : "none")
      };
    }
    if (!isArray(tooltipDataParams)) {
      return {
        color: borderColor || tooltipDataParams.color || tooltipDataParams.borderColor
      };
    }
  }
  _updatePosition(tooltipModel, positionExpr, x, y, content, params, el) {
    const viewWidth = this._api.getWidth();
    const viewHeight = this._api.getHeight();
    positionExpr = positionExpr || tooltipModel.get("position");
    const contentSize = content.getSize();
    let align = tooltipModel.get("align");
    let vAlign = tooltipModel.get("verticalAlign");
    const rect = el && el.getBoundingRect().clone();
    el && rect.applyTransform(el.transform);
    if (isFunction(positionExpr)) {
      positionExpr = positionExpr([x, y], params, content.el, rect, {
        viewSize: [viewWidth, viewHeight],
        contentSize: contentSize.slice()
      });
    }
    if (isArray(positionExpr)) {
      x = parsePercent2(positionExpr[0], viewWidth);
      y = parsePercent2(positionExpr[1], viewHeight);
    } else if (isObject(positionExpr)) {
      const boxLayoutPosition = positionExpr;
      boxLayoutPosition.width = contentSize[0];
      boxLayoutPosition.height = contentSize[1];
      const layoutRect = getLayoutRect(boxLayoutPosition, {width: viewWidth, height: viewHeight});
      x = layoutRect.x;
      y = layoutRect.y;
      align = null;
      vAlign = null;
    } else if (isString(positionExpr) && el) {
      const pos = calcTooltipPosition(positionExpr, rect, contentSize, tooltipModel.get("borderWidth"));
      x = pos[0];
      y = pos[1];
    } else {
      const pos = refixTooltipPosition(x, y, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
      x = pos[0];
      y = pos[1];
    }
    align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === "right" ? contentSize[0] : 0);
    vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === "bottom" ? contentSize[1] : 0);
    if (shouldTooltipConfine(tooltipModel)) {
      const pos = confineTooltipPosition(x, y, content, viewWidth, viewHeight);
      x = pos[0];
      y = pos[1];
    }
    content.moveTo(x, y);
  }
  _updateContentNotChangedOnAxis(dataByCoordSys, cbParamsList) {
    const lastCoordSys = this._lastDataByCoordSys;
    const lastCbParamsList = this._cbParamsList;
    let contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
    contentNotChanged && each(lastCoordSys, (lastItemCoordSys, indexCoordSys) => {
      const lastDataByAxis = lastItemCoordSys.dataByAxis || [];
      const thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
      const thisDataByAxis = thisItemCoordSys.dataByAxis || [];
      contentNotChanged = contentNotChanged && lastDataByAxis.length === thisDataByAxis.length;
      contentNotChanged && each(lastDataByAxis, (lastItem, indexAxis) => {
        const thisItem = thisDataByAxis[indexAxis] || {};
        const lastIndices = lastItem.seriesDataIndices || [];
        const newIndices = thisItem.seriesDataIndices || [];
        contentNotChanged = contentNotChanged && lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
        contentNotChanged && each(lastIndices, (lastIdxItem, j) => {
          const newIdxItem = newIndices[j];
          contentNotChanged = contentNotChanged && lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
        });
        lastCbParamsList && each(lastItem.seriesDataIndices, (idxItem) => {
          const seriesIdx = idxItem.seriesIndex;
          const cbParams = cbParamsList[seriesIdx];
          const lastCbParams = lastCbParamsList[seriesIdx];
          if (cbParams && lastCbParams && lastCbParams.data !== cbParams.data) {
            contentNotChanged = false;
          }
        });
      });
    });
    this._lastDataByCoordSys = dataByCoordSys;
    this._cbParamsList = cbParamsList;
    return !!contentNotChanged;
  }
  _hide(dispatchAction3) {
    this._lastDataByCoordSys = null;
    dispatchAction3({
      type: "hideTip",
      from: this.uid
    });
  }
  dispose(ecModel, api2) {
    if (env_default.node || !api2.getDom()) {
      return;
    }
    clear(this, "_updatePosition");
    this._tooltipContent.dispose();
    unregister("itemTooltip", api2);
  }
};
var TooltipView = TooltipView2;
TooltipView.type = "tooltip";
function buildTooltipModel(modelCascade, globalTooltipModel, defaultTooltipOption) {
  const ecModel = globalTooltipModel.ecModel;
  let resultModel;
  if (defaultTooltipOption) {
    resultModel = new Model_default(defaultTooltipOption, ecModel, ecModel);
    resultModel = new Model_default(globalTooltipModel.option, resultModel, ecModel);
  } else {
    resultModel = globalTooltipModel;
  }
  for (let i = modelCascade.length - 1; i >= 0; i--) {
    let tooltipOpt = modelCascade[i];
    if (tooltipOpt) {
      if (tooltipOpt instanceof Model_default) {
        tooltipOpt = tooltipOpt.get("tooltip", true);
      }
      if (isString(tooltipOpt)) {
        tooltipOpt = {
          formatter: tooltipOpt
        };
      }
      if (tooltipOpt) {
        resultModel = new Model_default(tooltipOpt, resultModel, ecModel);
      }
    }
  }
  return resultModel;
}
function makeDispatchAction2(payload, api2) {
  return payload.dispatchAction || bind(api2.dispatchAction, api2);
}
function refixTooltipPosition(x, y, content, viewWidth, viewHeight, gapH, gapV) {
  const size = content.getSize();
  const width = size[0];
  const height = size[1];
  if (gapH != null) {
    if (x + width + gapH + 2 > viewWidth) {
      x -= width + gapH;
    } else {
      x += gapH;
    }
  }
  if (gapV != null) {
    if (y + height + gapV > viewHeight) {
      y -= height + gapV;
    } else {
      y += gapV;
    }
  }
  return [x, y];
}
function confineTooltipPosition(x, y, content, viewWidth, viewHeight) {
  const size = content.getSize();
  const width = size[0];
  const height = size[1];
  x = Math.min(x + width, viewWidth) - width;
  y = Math.min(y + height, viewHeight) - height;
  x = Math.max(x, 0);
  y = Math.max(y, 0);
  return [x, y];
}
function calcTooltipPosition(position2, rect, contentSize, borderWidth) {
  const domWidth = contentSize[0];
  const domHeight = contentSize[1];
  const offset = Math.ceil(Math.SQRT2 * borderWidth) + 8;
  let x = 0;
  let y = 0;
  const rectWidth = rect.width;
  const rectHeight = rect.height;
  switch (position2) {
    case "inside":
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y + rectHeight / 2 - domHeight / 2;
      break;
    case "top":
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y - domHeight - offset;
      break;
    case "bottom":
      x = rect.x + rectWidth / 2 - domWidth / 2;
      y = rect.y + rectHeight + offset;
      break;
    case "left":
      x = rect.x - domWidth - offset;
      y = rect.y + rectHeight / 2 - domHeight / 2;
      break;
    case "right":
      x = rect.x + rectWidth + offset;
      y = rect.y + rectHeight / 2 - domHeight / 2;
  }
  return [x, y];
}
function isCenterAlign(align) {
  return align === "center" || align === "middle";
}
function findComponentReference(payload, ecModel, api2) {
  const {queryOptionMap} = preParseFinder(payload);
  const componentMainType = queryOptionMap.keys()[0];
  if (!componentMainType || componentMainType === "series") {
    return;
  }
  const queryResult = queryReferringComponents(ecModel, componentMainType, queryOptionMap.get(componentMainType), {useDefault: false, enableAll: false, enableNone: false});
  const model = queryResult.models[0];
  if (!model) {
    return;
  }
  const view = api2.getViewOfComponentModel(model);
  let el;
  view.group.traverse((subEl) => {
    const tooltipConfig = getECData(subEl).tooltipConfig;
    if (tooltipConfig && tooltipConfig.name === payload.name) {
      el = subEl;
      return true;
    }
  });
  if (el) {
    return {
      componentMainType,
      componentIndex: model.componentIndex,
      el
    };
  }
}
var TooltipView_default = TooltipView;

// src/component/tooltip/install.ts
function install37(registers) {
  use(install29);
  registers.registerComponentModel(TooltipModel_default);
  registers.registerComponentView(TooltipView_default);
  registers.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, noop);
  registers.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, noop);
}

// src/component/brush/preprocessor.ts
var DEFAULT_TOOLBOX_BTNS = ["rect", "polygon", "keep", "clear"];
function brushPreprocessor(option, isNew) {
  const brushComponents = normalizeToArray(option ? option.brush : []);
  if (!brushComponents.length) {
    return;
  }
  let brushComponentSpecifiedBtns = [];
  each(brushComponents, function(brushOpt) {
    const tbs = brushOpt.hasOwnProperty("toolbox") ? brushOpt.toolbox : [];
    if (tbs instanceof Array) {
      brushComponentSpecifiedBtns = brushComponentSpecifiedBtns.concat(tbs);
    }
  });
  let toolbox = option && option.toolbox;
  if (isArray(toolbox)) {
    toolbox = toolbox[0];
  }
  if (!toolbox) {
    toolbox = {feature: {}};
    option.toolbox = [toolbox];
  }
  const toolboxFeature = toolbox.feature || (toolbox.feature = {});
  const toolboxBrush = toolboxFeature.brush || (toolboxFeature.brush = {});
  const brushTypes = toolboxBrush.type || (toolboxBrush.type = []);
  brushTypes.push.apply(brushTypes, brushComponentSpecifiedBtns);
  removeDuplicate(brushTypes);
  if (isNew && !brushTypes.length) {
    brushTypes.push.apply(brushTypes, DEFAULT_TOOLBOX_BTNS);
  }
}
function removeDuplicate(arr) {
  const map3 = {};
  each(arr, function(val) {
    map3[val] = 1;
  });
  arr.length = 0;
  each(map3, function(flag, val) {
    arr.push(val);
  });
}

// src/visual/visualSolution.ts
var each12 = each;
function hasKeys(obj) {
  if (obj) {
    for (const name in obj) {
      if (obj.hasOwnProperty(name)) {
        return true;
      }
    }
  }
}
function createVisualMappings(option, stateList, supplementVisualOption) {
  const visualMappings = {};
  each12(stateList, function(state) {
    const mappings = visualMappings[state] = createMappings();
    each12(option[state], function(visualData, visualType) {
      if (!VisualMapping_default.isValidType(visualType)) {
        return;
      }
      let mappingOption = {
        type: visualType,
        visual: visualData
      };
      supplementVisualOption && supplementVisualOption(mappingOption, state);
      mappings[visualType] = new VisualMapping_default(mappingOption);
      if (visualType === "opacity") {
        mappingOption = clone(mappingOption);
        mappingOption.type = "colorAlpha";
        mappings.__hidden.__alphaForOpacity = new VisualMapping_default(mappingOption);
      }
    });
  });
  return visualMappings;
  function createMappings() {
    const Creater = function() {
    };
    Creater.prototype.__hidden = Creater.prototype;
    const obj = new Creater();
    return obj;
  }
}
function replaceVisualOption(thisOption, newOption, keys2) {
  let has3;
  each(keys2, function(key) {
    if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
      has3 = true;
    }
  });
  has3 && each(keys2, function(key) {
    if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
      thisOption[key] = clone(newOption[key]);
    } else {
      delete thisOption[key];
    }
  });
}
function applyVisual(stateList, visualMappings, data, getValueState, scope, dimension) {
  const visualTypesMap = {};
  each(stateList, function(state) {
    const visualTypes = VisualMapping_default.prepareVisualTypes(visualMappings[state]);
    visualTypesMap[state] = visualTypes;
  });
  let dataIndex;
  function getVisual(key) {
    return getItemVisualFromData(data, dataIndex, key);
  }
  function setVisual(key, value) {
    setItemVisualFromData(data, dataIndex, key, value);
  }
  if (dimension == null) {
    data.each(eachItem);
  } else {
    data.each([dimension], eachItem);
  }
  function eachItem(valueOrIndex, index) {
    dataIndex = dimension == null ? valueOrIndex : index;
    const rawDataItem = data.getRawDataItem(dataIndex);
    if (rawDataItem && rawDataItem.visualMap === false) {
      return;
    }
    const valueState = getValueState.call(scope, valueOrIndex);
    const mappings = visualMappings[valueState];
    const visualTypes = visualTypesMap[valueState];
    for (let i = 0, len2 = visualTypes.length; i < len2; i++) {
      const type = visualTypes[i];
      mappings[type] && mappings[type].applyVisual(valueOrIndex, getVisual, setVisual);
    }
  }
}
function incrementalApplyVisual(stateList, visualMappings, getValueState, dim) {
  const visualTypesMap = {};
  each(stateList, function(state) {
    const visualTypes = VisualMapping_default.prepareVisualTypes(visualMappings[state]);
    visualTypesMap[state] = visualTypes;
  });
  return {
    progress: function progress(params, data) {
      let dimIndex;
      if (dim != null) {
        dimIndex = data.getDimensionIndex(dim);
      }
      function getVisual(key) {
        return getItemVisualFromData(data, dataIndex, key);
      }
      function setVisual(key, value) {
        setItemVisualFromData(data, dataIndex, key, value);
      }
      let dataIndex;
      const store = data.getStore();
      while ((dataIndex = params.next()) != null) {
        const rawDataItem = data.getRawDataItem(dataIndex);
        if (rawDataItem && rawDataItem.visualMap === false) {
          continue;
        }
        const value = dim != null ? store.get(dimIndex, dataIndex) : dataIndex;
        const valueState = getValueState(value);
        const mappings = visualMappings[valueState];
        const visualTypes = visualTypesMap[valueState];
        for (let i = 0, len2 = visualTypes.length; i < len2; i++) {
          const type = visualTypes[i];
          mappings[type] && mappings[type].applyVisual(value, getVisual, setVisual);
        }
      }
    }
  };
}

// src/component/brush/selector.ts
function makeBrushCommonSelectorForSeries(area) {
  const brushType = area.brushType;
  const selectors = {
    point(itemLayout) {
      return selector[brushType].point(itemLayout, selectors, area);
    },
    rect(itemLayout) {
      return selector[brushType].rect(itemLayout, selectors, area);
    }
  };
  return selectors;
}
var selector = {
  lineX: getLineSelectors(0),
  lineY: getLineSelectors(1),
  rect: {
    point: function(itemLayout, selectors, area) {
      return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]);
    },
    rect: function(itemLayout, selectors, area) {
      return itemLayout && area.boundingRect.intersect(itemLayout);
    }
  },
  polygon: {
    point: function(itemLayout, selectors, area) {
      return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]) && contain3(area.range, itemLayout[0], itemLayout[1]);
    },
    rect: function(itemLayout, selectors, area) {
      const points4 = area.range;
      if (!itemLayout || points4.length <= 1) {
        return false;
      }
      const x = itemLayout.x;
      const y = itemLayout.y;
      const width = itemLayout.width;
      const height = itemLayout.height;
      const p = points4[0];
      if (contain3(points4, x, y) || contain3(points4, x + width, y) || contain3(points4, x, y + height) || contain3(points4, x + width, y + height) || BoundingRect_default.create(itemLayout).contain(p[0], p[1]) || linePolygonIntersect(x, y, x + width, y, points4) || linePolygonIntersect(x, y, x, y + height, points4) || linePolygonIntersect(x + width, y, x + width, y + height, points4) || linePolygonIntersect(x, y + height, x + width, y + height, points4)) {
        return true;
      }
    }
  }
};
function getLineSelectors(xyIndex) {
  const xy = ["x", "y"];
  const wh = ["width", "height"];
  return {
    point: function(itemLayout, selectors, area) {
      if (itemLayout) {
        const range = area.range;
        const p = itemLayout[xyIndex];
        return inLineRange(p, range);
      }
    },
    rect: function(itemLayout, selectors, area) {
      if (itemLayout) {
        const range = area.range;
        const layoutRange = [
          itemLayout[xy[xyIndex]],
          itemLayout[xy[xyIndex]] + itemLayout[wh[xyIndex]]
        ];
        layoutRange[1] < layoutRange[0] && layoutRange.reverse();
        return inLineRange(layoutRange[0], range) || inLineRange(layoutRange[1], range) || inLineRange(range[0], layoutRange) || inLineRange(range[1], layoutRange);
      }
    }
  };
}
function inLineRange(p, range) {
  return range[0] <= p && p <= range[1];
}

// src/component/brush/visualEncoding.ts
var STATE_LIST = ["inBrush", "outOfBrush"];
var DISPATCH_METHOD = "__ecBrushSelect";
var DISPATCH_FLAG = "__ecInBrushSelectEvent";
function layoutCovers(ecModel) {
  ecModel.eachComponent({mainType: "brush"}, function(brushModel) {
    const brushTargetManager = brushModel.brushTargetManager = new BrushTargetManager_default(brushModel.option, ecModel);
    brushTargetManager.setInputRanges(brushModel.areas, ecModel);
  });
}
function brushVisual(ecModel, api2, payload) {
  const brushSelected = [];
  let throttleType;
  let throttleDelay;
  ecModel.eachComponent({mainType: "brush"}, function(brushModel) {
    payload && payload.type === "takeGlobalCursor" && brushModel.setBrushOption(payload.key === "brush" ? payload.brushOption : {brushType: false});
  });
  layoutCovers(ecModel);
  ecModel.eachComponent({mainType: "brush"}, function(brushModel, brushIndex) {
    const thisBrushSelected = {
      brushId: brushModel.id,
      brushIndex,
      brushName: brushModel.name,
      areas: clone(brushModel.areas),
      selected: []
    };
    brushSelected.push(thisBrushSelected);
    const brushOption = brushModel.option;
    const brushLink = brushOption.brushLink;
    const linkedSeriesMap = [];
    const selectedDataIndexForLink = [];
    const rangeInfoBySeries = [];
    let hasBrushExists = false;
    if (!brushIndex) {
      throttleType = brushOption.throttleType;
      throttleDelay = brushOption.throttleDelay;
    }
    const areas = map(brushModel.areas, function(area) {
      const builder = boundingRectBuilders[area.brushType];
      const selectableArea = defaults({boundingRect: builder ? builder(area) : void 0}, area);
      selectableArea.selectors = makeBrushCommonSelectorForSeries(selectableArea);
      return selectableArea;
    });
    const visualMappings = createVisualMappings(brushModel.option, STATE_LIST, function(mappingOption) {
      mappingOption.mappingMethod = "fixed";
    });
    isArray(brushLink) && each(brushLink, function(seriesIndex) {
      linkedSeriesMap[seriesIndex] = 1;
    });
    function linkOthers(seriesIndex) {
      return brushLink === "all" || !!linkedSeriesMap[seriesIndex];
    }
    function brushed(rangeInfoList) {
      return !!rangeInfoList.length;
    }
    ecModel.eachSeries(function(seriesModel, seriesIndex) {
      const rangeInfoList = rangeInfoBySeries[seriesIndex] = [];
      seriesModel.subType === "parallel" ? stepAParallel(seriesModel, seriesIndex) : stepAOthers(seriesModel, seriesIndex, rangeInfoList);
    });
    function stepAParallel(seriesModel, seriesIndex) {
      const coordSys = seriesModel.coordinateSystem;
      hasBrushExists = hasBrushExists || coordSys.hasAxisBrushed();
      linkOthers(seriesIndex) && coordSys.eachActiveState(seriesModel.getData(), function(activeState, dataIndex) {
        activeState === "active" && (selectedDataIndexForLink[dataIndex] = 1);
      });
    }
    function stepAOthers(seriesModel, seriesIndex, rangeInfoList) {
      if (!seriesModel.brushSelector || brushModelNotControll(brushModel, seriesIndex)) {
        return;
      }
      each(areas, function(area) {
        if (brushModel.brushTargetManager.controlSeries(area, seriesModel, ecModel)) {
          rangeInfoList.push(area);
        }
        hasBrushExists = hasBrushExists || brushed(rangeInfoList);
      });
      if (linkOthers(seriesIndex) && brushed(rangeInfoList)) {
        const data = seriesModel.getData();
        data.each(function(dataIndex) {
          if (checkInRange(seriesModel, rangeInfoList, data, dataIndex)) {
            selectedDataIndexForLink[dataIndex] = 1;
          }
        });
      }
    }
    ecModel.eachSeries(function(seriesModel, seriesIndex) {
      const seriesBrushSelected = {
        seriesId: seriesModel.id,
        seriesIndex,
        seriesName: seriesModel.name,
        dataIndex: []
      };
      thisBrushSelected.selected.push(seriesBrushSelected);
      const rangeInfoList = rangeInfoBySeries[seriesIndex];
      const data = seriesModel.getData();
      const getValueState = linkOthers(seriesIndex) ? function(dataIndex) {
        return selectedDataIndexForLink[dataIndex] ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), "inBrush") : "outOfBrush";
      } : function(dataIndex) {
        return checkInRange(seriesModel, rangeInfoList, data, dataIndex) ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), "inBrush") : "outOfBrush";
      };
      (linkOthers(seriesIndex) ? hasBrushExists : brushed(rangeInfoList)) && applyVisual(STATE_LIST, visualMappings, data, getValueState);
    });
  });
  dispatchAction(api2, throttleType, throttleDelay, brushSelected, payload);
}
function dispatchAction(api2, throttleType, throttleDelay, brushSelected, payload) {
  if (!payload) {
    return;
  }
  const zr = api2.getZr();
  if (zr[DISPATCH_FLAG]) {
    return;
  }
  if (!zr[DISPATCH_METHOD]) {
    zr[DISPATCH_METHOD] = doDispatch;
  }
  const fn = createOrUpdate(zr, DISPATCH_METHOD, throttleDelay, throttleType);
  fn(api2, brushSelected);
}
function doDispatch(api2, brushSelected) {
  if (!api2.isDisposed()) {
    const zr = api2.getZr();
    zr[DISPATCH_FLAG] = true;
    api2.dispatchAction({
      type: "brushSelect",
      batch: brushSelected
    });
    zr[DISPATCH_FLAG] = false;
  }
}
function checkInRange(seriesModel, rangeInfoList, data, dataIndex) {
  for (let i = 0, len2 = rangeInfoList.length; i < len2; i++) {
    const area = rangeInfoList[i];
    if (seriesModel.brushSelector(dataIndex, data, area.selectors, area)) {
      return true;
    }
  }
}
function brushModelNotControll(brushModel, seriesIndex) {
  const seriesIndices = brushModel.option.seriesIndex;
  return seriesIndices != null && seriesIndices !== "all" && (isArray(seriesIndices) ? indexOf(seriesIndices, seriesIndex) < 0 : seriesIndex !== seriesIndices);
}
var boundingRectBuilders = {
  rect: function(area) {
    return getBoundingRectFromMinMax(area.range);
  },
  polygon: function(area) {
    let minMax;
    const range = area.range;
    for (let i = 0, len2 = range.length; i < len2; i++) {
      minMax = minMax || [[Infinity, -Infinity], [Infinity, -Infinity]];
      const rg = range[i];
      rg[0] < minMax[0][0] && (minMax[0][0] = rg[0]);
      rg[0] > minMax[0][1] && (minMax[0][1] = rg[0]);
      rg[1] < minMax[1][0] && (minMax[1][0] = rg[1]);
      rg[1] > minMax[1][1] && (minMax[1][1] = rg[1]);
    }
    return minMax && getBoundingRectFromMinMax(minMax);
  }
};
function getBoundingRectFromMinMax(minMax) {
  return new BoundingRect_default(minMax[0][0], minMax[1][0], minMax[0][1] - minMax[0][0], minMax[1][1] - minMax[1][0]);
}

// src/component/brush/BrushView.ts
var BrushView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = BrushView2.type;
  }
  init(ecModel, api2) {
    this.ecModel = ecModel;
    this.api = api2;
    this.model;
    (this._brushController = new BrushController_default(api2.getZr())).on("brush", bind(this._onBrush, this)).mount();
  }
  render(brushModel, ecModel, api2, payload) {
    this.model = brushModel;
    this._updateController(brushModel, ecModel, api2, payload);
  }
  updateTransform(brushModel, ecModel, api2, payload) {
    layoutCovers(ecModel);
    this._updateController(brushModel, ecModel, api2, payload);
  }
  updateVisual(brushModel, ecModel, api2, payload) {
    this.updateTransform(brushModel, ecModel, api2, payload);
  }
  updateView(brushModel, ecModel, api2, payload) {
    this._updateController(brushModel, ecModel, api2, payload);
  }
  _updateController(brushModel, ecModel, api2, payload) {
    (!payload || payload.$from !== brushModel.id) && this._brushController.setPanels(brushModel.brushTargetManager.makePanelOpts(api2)).enableBrush(brushModel.brushOption).updateCovers(brushModel.areas.slice());
  }
  dispose() {
    this._brushController.dispose();
  }
  _onBrush(eventParam) {
    const modelId = this.model.id;
    const areas = this.model.brushTargetManager.setOutputRanges(eventParam.areas, this.ecModel);
    (!eventParam.isEnd || eventParam.removeOnClick) && this.api.dispatchAction({
      type: "brush",
      brushId: modelId,
      areas: clone(areas),
      $from: modelId
    });
    eventParam.isEnd && this.api.dispatchAction({
      type: "brushEnd",
      brushId: modelId,
      areas: clone(areas),
      $from: modelId
    });
  }
};
var BrushView = BrushView2;
BrushView.type = "brush";
var BrushView_default = BrushView;

// src/component/brush/BrushModel.ts
var DEFAULT_OUT_OF_BRUSH_COLOR = "#ddd";
var BrushModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = BrushModel2.type;
    this.areas = [];
    this.brushOption = {};
  }
  optionUpdated(newOption, isInit) {
    const thisOption = this.option;
    !isInit && replaceVisualOption(thisOption, newOption, ["inBrush", "outOfBrush"]);
    const inBrush = thisOption.inBrush = thisOption.inBrush || {};
    thisOption.outOfBrush = thisOption.outOfBrush || {color: DEFAULT_OUT_OF_BRUSH_COLOR};
    if (!inBrush.hasOwnProperty("liftZ")) {
      inBrush.liftZ = 5;
    }
  }
  setAreas(areas) {
    if (true) {
      assert(isArray(areas));
      each(areas, function(area) {
        assert(area.brushType, "Illegal areas");
      });
    }
    if (!areas) {
      return;
    }
    this.areas = map(areas, function(area) {
      return generateBrushOption(this.option, area);
    }, this);
  }
  setBrushOption(brushOption) {
    this.brushOption = generateBrushOption(this.option, brushOption);
    this.brushType = this.brushOption.brushType;
  }
};
var BrushModel = BrushModel2;
BrushModel.type = "brush";
BrushModel.dependencies = ["geo", "grid", "xAxis", "yAxis", "parallel", "series"];
BrushModel.defaultOption = {
  seriesIndex: "all",
  brushType: "rect",
  brushMode: "single",
  transformable: true,
  brushStyle: {
    borderWidth: 1,
    color: "rgba(210,219,238,0.3)",
    borderColor: "#D2DBEE"
  },
  throttleType: "fixRate",
  throttleDelay: 0,
  removeOnClick: true,
  z: 1e4
};
function generateBrushOption(option, brushOption) {
  return merge({
    brushType: option.brushType,
    brushMode: option.brushMode,
    transformable: option.transformable,
    brushStyle: new Model_default(option.brushStyle).getItemStyle(),
    removeOnClick: option.removeOnClick,
    z: option.z
  }, brushOption, true);
}
var BrushModel_default = BrushModel;

// src/component/toolbox/feature/Brush.ts
var ICON_TYPES = ["rect", "polygon", "lineX", "lineY", "keep", "clear"];
var BrushFeature = class extends ToolboxFeature {
  render(featureModel, ecModel, api2) {
    let brushType;
    let brushMode;
    let isBrushed;
    ecModel.eachComponent({mainType: "brush"}, function(brushModel) {
      brushType = brushModel.brushType;
      brushMode = brushModel.brushOption.brushMode || "single";
      isBrushed = isBrushed || !!brushModel.areas.length;
    });
    this._brushType = brushType;
    this._brushMode = brushMode;
    each(featureModel.get("type", true), function(type) {
      featureModel.setIconStatus(type, (type === "keep" ? brushMode === "multiple" : type === "clear" ? isBrushed : type === brushType) ? "emphasis" : "normal");
    });
  }
  updateView(featureModel, ecModel, api2) {
    this.render(featureModel, ecModel, api2);
  }
  getIcons() {
    const model = this.model;
    const availableIcons = model.get("icon", true);
    const icons = {};
    each(model.get("type", true), function(type) {
      if (availableIcons[type]) {
        icons[type] = availableIcons[type];
      }
    });
    return icons;
  }
  onclick(ecModel, api2, type) {
    const brushType = this._brushType;
    const brushMode = this._brushMode;
    if (type === "clear") {
      api2.dispatchAction({
        type: "axisAreaSelect",
        intervals: []
      });
      api2.dispatchAction({
        type: "brush",
        command: "clear",
        areas: []
      });
    } else {
      api2.dispatchAction({
        type: "takeGlobalCursor",
        key: "brush",
        brushOption: {
          brushType: type === "keep" ? brushType : brushType === type ? false : type,
          brushMode: type === "keep" ? brushMode === "multiple" ? "single" : "multiple" : brushMode
        }
      });
    }
  }
  static getDefaultOption(ecModel) {
    const defaultOption3 = {
      show: true,
      type: ICON_TYPES.slice(),
      icon: {
        rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
        polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
        lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
        lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
        keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
        clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
      },
      title: ecModel.getLocaleModel().get(["toolbox", "brush", "title"])
    };
    return defaultOption3;
  }
};
var Brush_default = BrushFeature;

// src/component/brush/install.ts
function install38(registers) {
  registers.registerComponentView(BrushView_default);
  registers.registerComponentModel(BrushModel_default);
  registers.registerPreprocessor(brushPreprocessor);
  registers.registerVisual(registers.PRIORITY.VISUAL.BRUSH, brushVisual);
  registers.registerAction({type: "brush", event: "brush", update: "updateVisual"}, function(payload, ecModel) {
    ecModel.eachComponent({mainType: "brush", query: payload}, function(brushModel) {
      brushModel.setAreas(payload.areas);
    });
  });
  registers.registerAction({type: "brushSelect", event: "brushSelected", update: "none"}, noop);
  registers.registerAction({type: "brushEnd", event: "brushEnd", update: "none"}, noop);
  registerFeature("brush", Brush_default);
}

// src/component/title/install.ts
var TitleModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = TitleModel2.type;
    this.layoutMode = {type: "box", ignoreSize: true};
  }
};
var TitleModel = TitleModel2;
TitleModel.type = "title";
TitleModel.defaultOption = {
  z: 6,
  show: true,
  text: "",
  target: "blank",
  subtext: "",
  subtarget: "blank",
  left: 0,
  top: 0,
  backgroundColor: "rgba(0,0,0,0)",
  borderColor: "#ccc",
  borderWidth: 0,
  padding: 5,
  itemGap: 10,
  textStyle: {
    fontSize: 18,
    fontWeight: "bold",
    color: "#464646"
  },
  subtextStyle: {
    fontSize: 12,
    color: "#6E7079"
  }
};
var TitleView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = TitleView2.type;
  }
  render(titleModel, ecModel, api2) {
    this.group.removeAll();
    if (!titleModel.get("show")) {
      return;
    }
    const group = this.group;
    const textStyleModel = titleModel.getModel("textStyle");
    const subtextStyleModel = titleModel.getModel("subtextStyle");
    let textAlign = titleModel.get("textAlign");
    let textVerticalAlign = retrieve2(titleModel.get("textBaseline"), titleModel.get("textVerticalAlign"));
    const textEl = new Text_default({
      style: createTextStyle(textStyleModel, {
        text: titleModel.get("text"),
        fill: textStyleModel.getTextColor()
      }, {disableBox: true}),
      z2: 10
    });
    const textRect = textEl.getBoundingRect();
    const subText = titleModel.get("subtext");
    const subTextEl = new Text_default({
      style: createTextStyle(subtextStyleModel, {
        text: subText,
        fill: subtextStyleModel.getTextColor(),
        y: textRect.height + titleModel.get("itemGap"),
        verticalAlign: "top"
      }, {disableBox: true}),
      z2: 10
    });
    const link = titleModel.get("link");
    const sublink = titleModel.get("sublink");
    const triggerEvent = titleModel.get("triggerEvent", true);
    textEl.silent = !link && !triggerEvent;
    subTextEl.silent = !sublink && !triggerEvent;
    if (link) {
      textEl.on("click", function() {
        windowOpen(link, "_" + titleModel.get("target"));
      });
    }
    if (sublink) {
      subTextEl.on("click", function() {
        windowOpen(sublink, "_" + titleModel.get("subtarget"));
      });
    }
    getECData(textEl).eventData = getECData(subTextEl).eventData = triggerEvent ? {
      componentType: "title",
      componentIndex: titleModel.componentIndex
    } : null;
    group.add(textEl);
    subText && group.add(subTextEl);
    let groupRect = group.getBoundingRect();
    const layoutOption = titleModel.getBoxLayoutParams();
    layoutOption.width = groupRect.width;
    layoutOption.height = groupRect.height;
    const layoutRect = getLayoutRect(layoutOption, {
      width: api2.getWidth(),
      height: api2.getHeight()
    }, titleModel.get("padding"));
    if (!textAlign) {
      textAlign = titleModel.get("left") || titleModel.get("right");
      if (textAlign === "middle") {
        textAlign = "center";
      }
      if (textAlign === "right") {
        layoutRect.x += layoutRect.width;
      } else if (textAlign === "center") {
        layoutRect.x += layoutRect.width / 2;
      }
    }
    if (!textVerticalAlign) {
      textVerticalAlign = titleModel.get("top") || titleModel.get("bottom");
      if (textVerticalAlign === "center") {
        textVerticalAlign = "middle";
      }
      if (textVerticalAlign === "bottom") {
        layoutRect.y += layoutRect.height;
      } else if (textVerticalAlign === "middle") {
        layoutRect.y += layoutRect.height / 2;
      }
      textVerticalAlign = textVerticalAlign || "top";
    }
    group.x = layoutRect.x;
    group.y = layoutRect.y;
    group.markRedraw();
    const alignStyle = {
      align: textAlign,
      verticalAlign: textVerticalAlign
    };
    textEl.setStyle(alignStyle);
    subTextEl.setStyle(alignStyle);
    groupRect = group.getBoundingRect();
    const padding = layoutRect.margin;
    const style = titleModel.getItemStyle(["color", "opacity"]);
    style.fill = titleModel.get("backgroundColor");
    const rect = new Rect_default({
      shape: {
        x: groupRect.x - padding[3],
        y: groupRect.y - padding[0],
        width: groupRect.width + padding[1] + padding[3],
        height: groupRect.height + padding[0] + padding[2],
        r: titleModel.get("borderRadius")
      },
      style,
      subPixelOptimize: true,
      silent: true
    });
    group.add(rect);
  }
};
var TitleView = TitleView2;
TitleView.type = "title";
function install39(registers) {
  registers.registerComponentModel(TitleModel);
  registers.registerComponentView(TitleView);
}

// src/component/timeline/TimelineModel.ts
var TimelineModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = TimelineModel2.type;
    this.layoutMode = "box";
  }
  init(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
    this._initData();
  }
  mergeOption(option) {
    super.mergeOption.apply(this, arguments);
    this._initData();
  }
  setCurrentIndex(currentIndex) {
    if (currentIndex == null) {
      currentIndex = this.option.currentIndex;
    }
    const count2 = this._data.count();
    if (this.option.loop) {
      currentIndex = (currentIndex % count2 + count2) % count2;
    } else {
      currentIndex >= count2 && (currentIndex = count2 - 1);
      currentIndex < 0 && (currentIndex = 0);
    }
    this.option.currentIndex = currentIndex;
  }
  getCurrentIndex() {
    return this.option.currentIndex;
  }
  isIndexMax() {
    return this.getCurrentIndex() >= this._data.count() - 1;
  }
  setPlayState(state) {
    this.option.autoPlay = !!state;
  }
  getPlayState() {
    return !!this.option.autoPlay;
  }
  _initData() {
    const thisOption = this.option;
    const dataArr = thisOption.data || [];
    const axisType = thisOption.axisType;
    const names = this._names = [];
    let processedDataArr;
    if (axisType === "category") {
      processedDataArr = [];
      each(dataArr, function(item, index) {
        const value = convertOptionIdName(getDataItemValue(item), "");
        let newItem;
        if (isObject(item)) {
          newItem = clone(item);
          newItem.value = index;
        } else {
          newItem = index;
        }
        processedDataArr.push(newItem);
        names.push(value);
      });
    } else {
      processedDataArr = dataArr;
    }
    const dimType = {
      category: "ordinal",
      time: "time",
      value: "number"
    }[axisType] || "number";
    const data = this._data = new SeriesData_default([{
      name: "value",
      type: dimType
    }], this);
    data.initData(processedDataArr, names);
  }
  getData() {
    return this._data;
  }
  getCategories() {
    if (this.get("axisType") === "category") {
      return this._names.slice();
    }
  }
};
var TimelineModel = TimelineModel2;
TimelineModel.type = "timeline";
TimelineModel.defaultOption = {
  z: 4,
  show: true,
  axisType: "time",
  realtime: true,
  left: "20%",
  top: null,
  right: "20%",
  bottom: 0,
  width: null,
  height: 40,
  padding: 5,
  controlPosition: "left",
  autoPlay: false,
  rewind: false,
  loop: true,
  playInterval: 2e3,
  currentIndex: 0,
  itemStyle: {},
  label: {
    color: "#000"
  },
  data: []
};
var TimelineModel_default = TimelineModel;

// src/component/timeline/SliderTimelineModel.ts
var SliderTimelineModel2 = class extends TimelineModel_default {
  constructor() {
    super(...arguments);
    this.type = SliderTimelineModel2.type;
  }
};
var SliderTimelineModel = SliderTimelineModel2;
SliderTimelineModel.type = "timeline.slider";
SliderTimelineModel.defaultOption = inheritDefaultOption(TimelineModel_default.defaultOption, {
  backgroundColor: "rgba(0,0,0,0)",
  borderColor: "#ccc",
  borderWidth: 0,
  orient: "horizontal",
  inverse: false,
  tooltip: {
    trigger: "item"
  },
  symbol: "circle",
  symbolSize: 12,
  lineStyle: {
    show: true,
    width: 2,
    color: "#DAE1F5"
  },
  label: {
    position: "auto",
    show: true,
    interval: "auto",
    rotate: 0,
    color: "#A4B1D7"
  },
  itemStyle: {
    color: "#A4B1D7",
    borderWidth: 1
  },
  checkpointStyle: {
    symbol: "circle",
    symbolSize: 15,
    color: "#316bf3",
    borderColor: "#fff",
    borderWidth: 2,
    shadowBlur: 2,
    shadowOffsetX: 1,
    shadowOffsetY: 1,
    shadowColor: "rgba(0, 0, 0, 0.3)",
    animation: true,
    animationDuration: 300,
    animationEasing: "quinticInOut"
  },
  controlStyle: {
    show: true,
    showPlayBtn: true,
    showPrevBtn: true,
    showNextBtn: true,
    itemSize: 24,
    itemGap: 12,
    position: "left",
    playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
    stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
    nextIcon: "M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z",
    prevIcon: "M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z",
    prevBtnSize: 18,
    nextBtnSize: 18,
    color: "#A4B1D7",
    borderColor: "#A4B1D7",
    borderWidth: 1
  },
  emphasis: {
    label: {
      show: true,
      color: "#6f778d"
    },
    itemStyle: {
      color: "#316BF3"
    },
    controlStyle: {
      color: "#316BF3",
      borderColor: "#316BF3",
      borderWidth: 2
    }
  },
  progress: {
    lineStyle: {
      color: "#316BF3"
    },
    itemStyle: {
      color: "#316BF3"
    },
    label: {
      color: "#6f778d"
    }
  },
  data: []
});
mixin(SliderTimelineModel, DataFormatMixin.prototype);
var SliderTimelineModel_default = SliderTimelineModel;

// src/component/timeline/TimelineView.ts
var TimelineView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = TimelineView2.type;
  }
};
var TimelineView = TimelineView2;
TimelineView.type = "timeline";
var TimelineView_default = TimelineView;

// src/component/timeline/TimelineAxis.ts
var TimelineAxis = class extends Axis_default {
  constructor(dim, scale4, coordExtent, axisType) {
    super(dim, scale4, coordExtent);
    this.type = axisType || "value";
  }
  getLabelModel() {
    return this.model.getModel("label");
  }
  isHorizontal() {
    return this.model.get("orient") === "horizontal";
  }
};
var TimelineAxis_default = TimelineAxis;

// src/component/timeline/SliderTimelineView.ts
var PI10 = Math.PI;
var labelDataIndexStore = makeInner();
var SliderTimelineView2 = class extends TimelineView_default {
  constructor() {
    super(...arguments);
    this.type = SliderTimelineView2.type;
  }
  init(ecModel, api2) {
    this.api = api2;
  }
  render(timelineModel, ecModel, api2) {
    this.model = timelineModel;
    this.api = api2;
    this.ecModel = ecModel;
    this.group.removeAll();
    if (timelineModel.get("show", true)) {
      const layoutInfo = this._layout(timelineModel, api2);
      const mainGroup = this._createGroup("_mainGroup");
      const labelGroup = this._createGroup("_labelGroup");
      const axis = this._axis = this._createAxis(layoutInfo, timelineModel);
      timelineModel.formatTooltip = function(dataIndex) {
        const name = axis.scale.getLabel({value: dataIndex});
        return createTooltipMarkup("nameValue", {noName: true, value: name});
      };
      each(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(name) {
        this["_render" + name](layoutInfo, mainGroup, axis, timelineModel);
      }, this);
      this._renderAxisLabel(layoutInfo, labelGroup, axis, timelineModel);
      this._position(layoutInfo, timelineModel);
    }
    this._doPlayStop();
    this._updateTicksStatus();
  }
  remove() {
    this._clearTimer();
    this.group.removeAll();
  }
  dispose() {
    this._clearTimer();
  }
  _layout(timelineModel, api2) {
    const labelPosOpt = timelineModel.get(["label", "position"]);
    const orient = timelineModel.get("orient");
    const viewRect2 = getViewRect6(timelineModel, api2);
    let parsedLabelPos;
    if (labelPosOpt == null || labelPosOpt === "auto") {
      parsedLabelPos = orient === "horizontal" ? viewRect2.y + viewRect2.height / 2 < api2.getHeight() / 2 ? "-" : "+" : viewRect2.x + viewRect2.width / 2 < api2.getWidth() / 2 ? "+" : "-";
    } else if (isString(labelPosOpt)) {
      parsedLabelPos = {
        horizontal: {top: "-", bottom: "+"},
        vertical: {left: "-", right: "+"}
      }[orient][labelPosOpt];
    } else {
      parsedLabelPos = labelPosOpt;
    }
    const labelAlignMap = {
      horizontal: "center",
      vertical: parsedLabelPos >= 0 || parsedLabelPos === "+" ? "left" : "right"
    };
    const labelBaselineMap = {
      horizontal: parsedLabelPos >= 0 || parsedLabelPos === "+" ? "top" : "bottom",
      vertical: "middle"
    };
    const rotationMap = {
      horizontal: 0,
      vertical: PI10 / 2
    };
    const mainLength = orient === "vertical" ? viewRect2.height : viewRect2.width;
    const controlModel = timelineModel.getModel("controlStyle");
    const showControl = controlModel.get("show", true);
    const controlSize = showControl ? controlModel.get("itemSize") : 0;
    const controlGap = showControl ? controlModel.get("itemGap") : 0;
    const sizePlusGap = controlSize + controlGap;
    let labelRotation = timelineModel.get(["label", "rotate"]) || 0;
    labelRotation = labelRotation * PI10 / 180;
    let playPosition;
    let prevBtnPosition;
    let nextBtnPosition;
    const controlPosition = controlModel.get("position", true);
    const showPlayBtn = showControl && controlModel.get("showPlayBtn", true);
    const showPrevBtn = showControl && controlModel.get("showPrevBtn", true);
    const showNextBtn = showControl && controlModel.get("showNextBtn", true);
    let xLeft = 0;
    let xRight = mainLength;
    if (controlPosition === "left" || controlPosition === "bottom") {
      showPlayBtn && (playPosition = [0, 0], xLeft += sizePlusGap);
      showPrevBtn && (prevBtnPosition = [xLeft, 0], xLeft += sizePlusGap);
      showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
    } else {
      showPlayBtn && (playPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
      showPrevBtn && (prevBtnPosition = [0, 0], xLeft += sizePlusGap);
      showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap);
    }
    const axisExtent = [xLeft, xRight];
    if (timelineModel.get("inverse")) {
      axisExtent.reverse();
    }
    return {
      viewRect: viewRect2,
      mainLength,
      orient,
      rotation: rotationMap[orient],
      labelRotation,
      labelPosOpt: parsedLabelPos,
      labelAlign: timelineModel.get(["label", "align"]) || labelAlignMap[orient],
      labelBaseline: timelineModel.get(["label", "verticalAlign"]) || timelineModel.get(["label", "baseline"]) || labelBaselineMap[orient],
      playPosition,
      prevBtnPosition,
      nextBtnPosition,
      axisExtent,
      controlSize,
      controlGap
    };
  }
  _position(layoutInfo, timelineModel) {
    const mainGroup = this._mainGroup;
    const labelGroup = this._labelGroup;
    let viewRect2 = layoutInfo.viewRect;
    if (layoutInfo.orient === "vertical") {
      const m2 = create2();
      const rotateOriginX = viewRect2.x;
      const rotateOriginY = viewRect2.y + viewRect2.height;
      translate(m2, m2, [-rotateOriginX, -rotateOriginY]);
      rotate(m2, m2, -PI10 / 2);
      translate(m2, m2, [rotateOriginX, rotateOriginY]);
      viewRect2 = viewRect2.clone();
      viewRect2.applyTransform(m2);
    }
    const viewBound = getBound(viewRect2);
    const mainBound = getBound(mainGroup.getBoundingRect());
    const labelBound = getBound(labelGroup.getBoundingRect());
    const mainPosition = [mainGroup.x, mainGroup.y];
    const labelsPosition = [labelGroup.x, labelGroup.y];
    labelsPosition[0] = mainPosition[0] = viewBound[0][0];
    const labelPosOpt = layoutInfo.labelPosOpt;
    if (labelPosOpt == null || isString(labelPosOpt)) {
      const mainBoundIdx = labelPosOpt === "+" ? 0 : 1;
      toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
      toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx);
    } else {
      const mainBoundIdx = labelPosOpt >= 0 ? 0 : 1;
      toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
      labelsPosition[1] = mainPosition[1] + labelPosOpt;
    }
    mainGroup.setPosition(mainPosition);
    labelGroup.setPosition(labelsPosition);
    mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation;
    setOrigin(mainGroup);
    setOrigin(labelGroup);
    function setOrigin(targetGroup) {
      targetGroup.originX = viewBound[0][0] - targetGroup.x;
      targetGroup.originY = viewBound[1][0] - targetGroup.y;
    }
    function getBound(rect) {
      return [
        [rect.x, rect.x + rect.width],
        [rect.y, rect.y + rect.height]
      ];
    }
    function toBound(fromPos, from, to, dimIdx, boundIdx) {
      fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx];
    }
  }
  _createAxis(layoutInfo, timelineModel) {
    const data = timelineModel.getData();
    const axisType = timelineModel.get("axisType");
    const scale4 = createScaleByModel2(timelineModel, axisType);
    scale4.getTicks = function() {
      return data.mapArray(["value"], function(value) {
        return {value};
      });
    };
    const dataExtent = data.getDataExtent("value");
    scale4.setExtent(dataExtent[0], dataExtent[1]);
    scale4.calcNiceTicks();
    const axis = new TimelineAxis_default("value", scale4, layoutInfo.axisExtent, axisType);
    axis.model = timelineModel;
    return axis;
  }
  _createGroup(key) {
    const newGroup = this[key] = new Group_default();
    this.group.add(newGroup);
    return newGroup;
  }
  _renderAxisLine(layoutInfo, group, axis, timelineModel) {
    const axisExtent = axis.getExtent();
    if (!timelineModel.get(["lineStyle", "show"])) {
      return;
    }
    const line2 = new Line_default({
      shape: {
        x1: axisExtent[0],
        y1: 0,
        x2: axisExtent[1],
        y2: 0
      },
      style: extend({lineCap: "round"}, timelineModel.getModel("lineStyle").getLineStyle()),
      silent: true,
      z2: 1
    });
    group.add(line2);
    const progressLine = this._progressLine = new Line_default({
      shape: {
        x1: axisExtent[0],
        x2: this._currentPointer ? this._currentPointer.x : axisExtent[0],
        y1: 0,
        y2: 0
      },
      style: defaults({lineCap: "round", lineWidth: line2.style.lineWidth}, timelineModel.getModel(["progress", "lineStyle"]).getLineStyle()),
      silent: true,
      z2: 1
    });
    group.add(progressLine);
  }
  _renderAxisTick(layoutInfo, group, axis, timelineModel) {
    const data = timelineModel.getData();
    const ticks = axis.scale.getTicks();
    this._tickSymbols = [];
    each(ticks, (tick) => {
      const tickCoord = axis.dataToCoord(tick.value);
      const itemModel = data.getItemModel(tick.value);
      const itemStyleModel = itemModel.getModel("itemStyle");
      const hoverStyleModel = itemModel.getModel(["emphasis", "itemStyle"]);
      const progressStyleModel = itemModel.getModel(["progress", "itemStyle"]);
      const symbolOpt = {
        x: tickCoord,
        y: 0,
        onclick: bind(this._changeTimeline, this, tick.value)
      };
      const el = giveSymbol(itemModel, itemStyleModel, group, symbolOpt);
      el.ensureState("emphasis").style = hoverStyleModel.getItemStyle();
      el.ensureState("progress").style = progressStyleModel.getItemStyle();
      enableHoverEmphasis(el);
      const ecData = getECData(el);
      if (itemModel.get("tooltip")) {
        ecData.dataIndex = tick.value;
        ecData.dataModel = timelineModel;
      } else {
        ecData.dataIndex = ecData.dataModel = null;
      }
      this._tickSymbols.push(el);
    });
  }
  _renderAxisLabel(layoutInfo, group, axis, timelineModel) {
    const labelModel = axis.getLabelModel();
    if (!labelModel.get("show")) {
      return;
    }
    const data = timelineModel.getData();
    const labels = axis.getViewLabels();
    this._tickLabels = [];
    each(labels, (labelItem) => {
      const dataIndex = labelItem.tickValue;
      const itemModel = data.getItemModel(dataIndex);
      const normalLabelModel = itemModel.getModel("label");
      const hoverLabelModel = itemModel.getModel(["emphasis", "label"]);
      const progressLabelModel = itemModel.getModel(["progress", "label"]);
      const tickCoord = axis.dataToCoord(labelItem.tickValue);
      const textEl = new Text_default({
        x: tickCoord,
        y: 0,
        rotation: layoutInfo.labelRotation - layoutInfo.rotation,
        onclick: bind(this._changeTimeline, this, dataIndex),
        silent: false,
        style: createTextStyle(normalLabelModel, {
          text: labelItem.formattedLabel,
          align: layoutInfo.labelAlign,
          verticalAlign: layoutInfo.labelBaseline
        })
      });
      textEl.ensureState("emphasis").style = createTextStyle(hoverLabelModel);
      textEl.ensureState("progress").style = createTextStyle(progressLabelModel);
      group.add(textEl);
      enableHoverEmphasis(textEl);
      labelDataIndexStore(textEl).dataIndex = dataIndex;
      this._tickLabels.push(textEl);
    });
  }
  _renderControl(layoutInfo, group, axis, timelineModel) {
    const controlSize = layoutInfo.controlSize;
    const rotation = layoutInfo.rotation;
    const itemStyle = timelineModel.getModel("controlStyle").getItemStyle();
    const hoverStyle = timelineModel.getModel(["emphasis", "controlStyle"]).getItemStyle();
    const playState = timelineModel.getPlayState();
    const inverse = timelineModel.get("inverse", true);
    makeBtn(layoutInfo.nextBtnPosition, "next", bind(this._changeTimeline, this, inverse ? "-" : "+"));
    makeBtn(layoutInfo.prevBtnPosition, "prev", bind(this._changeTimeline, this, inverse ? "+" : "-"));
    makeBtn(layoutInfo.playPosition, playState ? "stop" : "play", bind(this._handlePlayClick, this, !playState), true);
    function makeBtn(position2, iconName, onclick, willRotate) {
      if (!position2) {
        return;
      }
      const iconSize = parsePercent(retrieve2(timelineModel.get(["controlStyle", iconName + "BtnSize"]), controlSize), controlSize);
      const rect = [0, -iconSize / 2, iconSize, iconSize];
      const btn = makeControlIcon(timelineModel, iconName + "Icon", rect, {
        x: position2[0],
        y: position2[1],
        originX: controlSize / 2,
        originY: 0,
        rotation: willRotate ? -rotation : 0,
        rectHover: true,
        style: itemStyle,
        onclick
      });
      btn.ensureState("emphasis").style = hoverStyle;
      group.add(btn);
      enableHoverEmphasis(btn);
    }
  }
  _renderCurrentPointer(layoutInfo, group, axis, timelineModel) {
    const data = timelineModel.getData();
    const currentIndex = timelineModel.getCurrentIndex();
    const pointerModel = data.getItemModel(currentIndex).getModel("checkpointStyle");
    const me = this;
    const callback = {
      onCreate(pointer) {
        pointer.draggable = true;
        pointer.drift = bind(me._handlePointerDrag, me);
        pointer.ondragend = bind(me._handlePointerDragend, me);
        pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel, true);
      },
      onUpdate(pointer) {
        pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel);
      }
    };
    this._currentPointer = giveSymbol(pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, callback);
  }
  _handlePlayClick(nextState) {
    this._clearTimer();
    this.api.dispatchAction({
      type: "timelinePlayChange",
      playState: nextState,
      from: this.uid
    });
  }
  _handlePointerDrag(dx, dy, e2) {
    this._clearTimer();
    this._pointerChangeTimeline([e2.offsetX, e2.offsetY]);
  }
  _handlePointerDragend(e2) {
    this._pointerChangeTimeline([e2.offsetX, e2.offsetY], true);
  }
  _pointerChangeTimeline(mousePos, trigger3) {
    let toCoord = this._toAxisCoord(mousePos)[0];
    const axis = this._axis;
    const axisExtent = asc(axis.getExtent().slice());
    toCoord > axisExtent[1] && (toCoord = axisExtent[1]);
    toCoord < axisExtent[0] && (toCoord = axisExtent[0]);
    this._currentPointer.x = toCoord;
    this._currentPointer.markRedraw();
    const progressLine = this._progressLine;
    if (progressLine) {
      progressLine.shape.x2 = toCoord;
      progressLine.dirty();
    }
    const targetDataIndex = this._findNearestTick(toCoord);
    const timelineModel = this.model;
    if (trigger3 || targetDataIndex !== timelineModel.getCurrentIndex() && timelineModel.get("realtime")) {
      this._changeTimeline(targetDataIndex);
    }
  }
  _doPlayStop() {
    this._clearTimer();
    if (this.model.getPlayState()) {
      this._timer = setTimeout(() => {
        const timelineModel = this.model;
        this._changeTimeline(timelineModel.getCurrentIndex() + (timelineModel.get("rewind", true) ? -1 : 1));
      }, this.model.get("playInterval"));
    }
  }
  _toAxisCoord(vertex) {
    const trans = this._mainGroup.getLocalTransform();
    return applyTransform2(vertex, trans, true);
  }
  _findNearestTick(axisCoord) {
    const data = this.model.getData();
    let dist3 = Infinity;
    let targetDataIndex;
    const axis = this._axis;
    data.each(["value"], function(value, dataIndex) {
      const coord = axis.dataToCoord(value);
      const d = Math.abs(coord - axisCoord);
      if (d < dist3) {
        dist3 = d;
        targetDataIndex = dataIndex;
      }
    });
    return targetDataIndex;
  }
  _clearTimer() {
    if (this._timer) {
      clearTimeout(this._timer);
      this._timer = null;
    }
  }
  _changeTimeline(nextIndex) {
    const currentIndex = this.model.getCurrentIndex();
    if (nextIndex === "+") {
      nextIndex = currentIndex + 1;
    } else if (nextIndex === "-") {
      nextIndex = currentIndex - 1;
    }
    this.api.dispatchAction({
      type: "timelineChange",
      currentIndex: nextIndex,
      from: this.uid
    });
  }
  _updateTicksStatus() {
    const currentIndex = this.model.getCurrentIndex();
    const tickSymbols = this._tickSymbols;
    const tickLabels = this._tickLabels;
    if (tickSymbols) {
      for (let i = 0; i < tickSymbols.length; i++) {
        tickSymbols && tickSymbols[i] && tickSymbols[i].toggleState("progress", i < currentIndex);
      }
    }
    if (tickLabels) {
      for (let i = 0; i < tickLabels.length; i++) {
        tickLabels && tickLabels[i] && tickLabels[i].toggleState("progress", labelDataIndexStore(tickLabels[i]).dataIndex <= currentIndex);
      }
    }
  }
};
var SliderTimelineView = SliderTimelineView2;
SliderTimelineView.type = "timeline.slider";
function createScaleByModel2(model, axisType) {
  axisType = axisType || model.get("type");
  if (axisType) {
    switch (axisType) {
      case "category":
        return new Ordinal_default({
          ordinalMeta: model.getCategories(),
          extent: [Infinity, -Infinity]
        });
      case "time":
        return new Time_default({
          locale: model.ecModel.getLocaleModel(),
          useUTC: model.ecModel.get("useUTC")
        });
      default:
        return new Interval_default();
    }
  }
}
function getViewRect6(model, api2) {
  return getLayoutRect(model.getBoxLayoutParams(), {
    width: api2.getWidth(),
    height: api2.getHeight()
  }, model.get("padding"));
}
function makeControlIcon(timelineModel, objPath, rect, opts) {
  const style = opts.style;
  const icon = createIcon(timelineModel.get(["controlStyle", objPath]), opts || {}, new BoundingRect_default(rect[0], rect[1], rect[2], rect[3]));
  if (style) {
    icon.setStyle(style);
  }
  return icon;
}
function giveSymbol(hostModel, itemStyleModel, group, opt, symbol, callback) {
  const color2 = itemStyleModel.get("color");
  if (!symbol) {
    const symbolType = hostModel.get("symbol");
    symbol = createSymbol(symbolType, -1, -1, 2, 2, color2);
    symbol.setStyle("strokeNoScale", true);
    group.add(symbol);
    callback && callback.onCreate(symbol);
  } else {
    symbol.setColor(color2);
    group.add(symbol);
    callback && callback.onUpdate(symbol);
  }
  const itemStyle = itemStyleModel.getItemStyle(["color"]);
  symbol.setStyle(itemStyle);
  opt = merge({
    rectHover: true,
    z2: 100
  }, opt, true);
  const symbolSize = normalizeSymbolSize(hostModel.get("symbolSize"));
  opt.scaleX = symbolSize[0] / 2;
  opt.scaleY = symbolSize[1] / 2;
  const symbolOffset = normalizeSymbolOffset(hostModel.get("symbolOffset"), symbolSize);
  if (symbolOffset) {
    opt.x = (opt.x || 0) + symbolOffset[0];
    opt.y = (opt.y || 0) + symbolOffset[1];
  }
  const symbolRotate = hostModel.get("symbolRotate");
  opt.rotation = (symbolRotate || 0) * Math.PI / 180 || 0;
  symbol.attr(opt);
  symbol.updateTransform();
  return symbol;
}
function pointerMoveTo(pointer, progressLine, dataIndex, axis, timelineModel, noAnimation) {
  if (pointer.dragging) {
    return;
  }
  const pointerModel = timelineModel.getModel("checkpointStyle");
  const toCoord = axis.dataToCoord(timelineModel.getData().get("value", dataIndex));
  if (noAnimation || !pointerModel.get("animation", true)) {
    pointer.attr({
      x: toCoord,
      y: 0
    });
    progressLine && progressLine.attr({
      shape: {x2: toCoord}
    });
  } else {
    const animationCfg = {
      duration: pointerModel.get("animationDuration", true),
      easing: pointerModel.get("animationEasing", true)
    };
    pointer.stopAnimation(null, true);
    pointer.animateTo({
      x: toCoord,
      y: 0
    }, animationCfg);
    progressLine && progressLine.animateTo({
      shape: {x2: toCoord}
    }, animationCfg);
  }
}
var SliderTimelineView_default = SliderTimelineView;

// src/component/timeline/timelineAction.ts
function installTimelineAction(registers) {
  registers.registerAction({type: "timelineChange", event: "timelineChanged", update: "prepareAndUpdate"}, function(payload, ecModel, api2) {
    const timelineModel = ecModel.getComponent("timeline");
    if (timelineModel && payload.currentIndex != null) {
      timelineModel.setCurrentIndex(payload.currentIndex);
      if (!timelineModel.get("loop", true) && timelineModel.isIndexMax() && timelineModel.getPlayState()) {
        timelineModel.setPlayState(false);
        api2.dispatchAction({
          type: "timelinePlayChange",
          playState: false,
          from: payload.from
        });
      }
    }
    ecModel.resetOption("timeline", {replaceMerge: timelineModel.get("replaceMerge", true)});
    return defaults({
      currentIndex: timelineModel.option.currentIndex
    }, payload);
  });
  registers.registerAction({type: "timelinePlayChange", event: "timelinePlayChanged", update: "update"}, function(payload, ecModel) {
    const timelineModel = ecModel.getComponent("timeline");
    if (timelineModel && payload.playState != null) {
      timelineModel.setPlayState(payload.playState);
    }
  });
}

// src/component/timeline/preprocessor.ts
function timelinePreprocessor(option) {
  let timelineOpt = option && option.timeline;
  if (!isArray(timelineOpt)) {
    timelineOpt = timelineOpt ? [timelineOpt] : [];
  }
  each(timelineOpt, function(opt) {
    if (!opt) {
      return;
    }
    compatibleEC2(opt);
  });
}
function compatibleEC2(opt) {
  const type = opt.type;
  const ec2Types = {number: "value", time: "time"};
  if (ec2Types[type]) {
    opt.axisType = ec2Types[type];
    delete opt.type;
  }
  transferItem(opt);
  if (has(opt, "controlPosition")) {
    const controlStyle = opt.controlStyle || (opt.controlStyle = {});
    if (!has(controlStyle, "position")) {
      controlStyle.position = opt.controlPosition;
    }
    if (controlStyle.position === "none" && !has(controlStyle, "show")) {
      controlStyle.show = false;
      delete controlStyle.position;
    }
    delete opt.controlPosition;
  }
  each(opt.data || [], function(dataItem) {
    if (isObject(dataItem) && !isArray(dataItem)) {
      if (!has(dataItem, "value") && has(dataItem, "name")) {
        dataItem.value = dataItem.name;
      }
      transferItem(dataItem);
    }
  });
}
function transferItem(opt) {
  const itemStyle = opt.itemStyle || (opt.itemStyle = {});
  const itemStyleEmphasis = itemStyle.emphasis || (itemStyle.emphasis = {});
  const label = opt.label || (opt.label || {});
  const labelNormal = label.normal || (label.normal = {});
  const excludeLabelAttr = {normal: 1, emphasis: 1};
  each(label, function(value, name) {
    if (!excludeLabelAttr[name] && !has(labelNormal, name)) {
      labelNormal[name] = value;
    }
  });
  if (itemStyleEmphasis.label && !has(label, "emphasis")) {
    label.emphasis = itemStyleEmphasis.label;
    delete itemStyleEmphasis.label;
  }
}
function has(obj, attr) {
  return obj.hasOwnProperty(attr);
}

// src/component/timeline/install.ts
function install40(registers) {
  registers.registerComponentModel(SliderTimelineModel_default);
  registers.registerComponentView(SliderTimelineView_default);
  registers.registerSubTypeDefaulter("timeline", function() {
    return "slider";
  });
  installTimelineAction(registers);
  registers.registerPreprocessor(timelinePreprocessor);
}

// src/component/marker/checkMarkerInSeries.ts
function checkMarkerInSeries(seriesOpts, markerType) {
  if (!seriesOpts) {
    return false;
  }
  const seriesOptArr = isArray(seriesOpts) ? seriesOpts : [seriesOpts];
  for (let idx = 0; idx < seriesOptArr.length; idx++) {
    if (seriesOptArr[idx] && seriesOptArr[idx][markerType]) {
      return true;
    }
  }
  return false;
}

// src/component/marker/MarkerModel.ts
function fillLabel(opt) {
  defaultEmphasis(opt, "label", ["show"]);
}
var inner17 = makeInner();
var MarkerModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = MarkerModel2.type;
    this.createdBySelf = false;
  }
  init(option, parentModel, ecModel) {
    if (true) {
      if (this.type === "marker") {
        throw new Error("Marker component is abstract component. Use markLine, markPoint, markArea instead.");
      }
    }
    this.mergeDefaultAndTheme(option, ecModel);
    this._mergeOption(option, ecModel, false, true);
  }
  isAnimationEnabled() {
    if (env_default.node) {
      return false;
    }
    const hostSeries = this.__hostSeries;
    return this.getShallow("animation") && hostSeries && hostSeries.isAnimationEnabled();
  }
  mergeOption(newOpt, ecModel) {
    this._mergeOption(newOpt, ecModel, false, false);
  }
  _mergeOption(newOpt, ecModel, createdBySelf, isInit) {
    const componentType = this.mainType;
    if (!createdBySelf) {
      ecModel.eachSeries(function(seriesModel) {
        const markerOpt = seriesModel.get(this.mainType, true);
        let markerModel = inner17(seriesModel)[componentType];
        if (!markerOpt || !markerOpt.data) {
          inner17(seriesModel)[componentType] = null;
          return;
        }
        if (!markerModel) {
          if (isInit) {
            fillLabel(markerOpt);
          }
          each(markerOpt.data, function(item) {
            if (item instanceof Array) {
              fillLabel(item[0]);
              fillLabel(item[1]);
            } else {
              fillLabel(item);
            }
          });
          markerModel = this.createMarkerModelFromSeries(markerOpt, this, ecModel);
          extend(markerModel, {
            mainType: this.mainType,
            seriesIndex: seriesModel.seriesIndex,
            name: seriesModel.name,
            createdBySelf: true
          });
          markerModel.__hostSeries = seriesModel;
        } else {
          markerModel._mergeOption(markerOpt, ecModel, true);
        }
        inner17(seriesModel)[componentType] = markerModel;
      }, this);
    }
  }
  formatTooltip(dataIndex, multipleSeries, dataType) {
    const data = this.getData();
    const value = this.getRawValue(dataIndex);
    const itemName = data.getName(dataIndex);
    return createTooltipMarkup("section", {
      header: this.name,
      blocks: [createTooltipMarkup("nameValue", {
        name: itemName,
        value,
        noName: !itemName,
        noValue: value == null
      })]
    });
  }
  getData() {
    return this._data;
  }
  setData(data) {
    this._data = data;
  }
  static getMarkerModelFromSeries(seriesModel, componentType) {
    return inner17(seriesModel)[componentType];
  }
};
var MarkerModel = MarkerModel2;
MarkerModel.type = "marker";
MarkerModel.dependencies = ["series", "grid", "polar", "geo"];
mixin(MarkerModel, DataFormatMixin.prototype);
var MarkerModel_default = MarkerModel;

// src/component/marker/MarkPointModel.ts
var MarkPointModel2 = class extends MarkerModel_default {
  constructor() {
    super(...arguments);
    this.type = MarkPointModel2.type;
  }
  createMarkerModelFromSeries(markerOpt, masterMarkerModel, ecModel) {
    return new MarkPointModel2(markerOpt, masterMarkerModel, ecModel);
  }
};
var MarkPointModel = MarkPointModel2;
MarkPointModel.type = "markPoint";
MarkPointModel.defaultOption = {
  z: 5,
  symbol: "pin",
  symbolSize: 50,
  tooltip: {
    trigger: "item"
  },
  label: {
    show: true,
    position: "inside"
  },
  itemStyle: {
    borderWidth: 2
  },
  emphasis: {
    label: {
      show: true
    }
  }
};
var MarkPointModel_default = MarkPointModel;

// src/component/marker/markerHelper.ts
function hasXOrY(item) {
  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));
}
function hasXAndY(item) {
  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));
}
function markerTypeCalculatorWithExtent(markerType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {
  const coordArr = [];
  const stacked = isDimensionStacked(data, targetDataDim);
  const calcDataDim = stacked ? data.getCalculationInfo("stackResultDimension") : targetDataDim;
  const value = numCalculate(data, calcDataDim, markerType);
  const dataIndex = data.indicesOfNearest(calcDataDim, value)[0];
  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);
  coordArr[targetCoordIndex] = data.get(calcDataDim, dataIndex);
  const coordArrValue = data.get(targetDataDim, dataIndex);
  let precision = getPrecision(data.get(targetDataDim, dataIndex));
  precision = Math.min(precision, 20);
  if (precision >= 0) {
    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);
  }
  return [coordArr, coordArrValue];
}
var markerTypeCalculator = {
  min: curry(markerTypeCalculatorWithExtent, "min"),
  max: curry(markerTypeCalculatorWithExtent, "max"),
  average: curry(markerTypeCalculatorWithExtent, "average"),
  median: curry(markerTypeCalculatorWithExtent, "median")
};
function dataTransform(seriesModel, item) {
  if (!item) {
    return;
  }
  const data = seriesModel.getData();
  const coordSys = seriesModel.coordinateSystem;
  const dims = coordSys && coordSys.dimensions;
  if (!hasXAndY(item) && !isArray(item.coord) && isArray(dims)) {
    const axisInfo = getAxisInfo2(item, data, coordSys, seriesModel);
    item = clone(item);
    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {
      const otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);
      const targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);
      const coordInfo = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex);
      item.coord = coordInfo[0];
      item.value = coordInfo[1];
    } else {
      item.coord = [
        item.xAxis != null ? item.xAxis : item.radiusAxis,
        item.yAxis != null ? item.yAxis : item.angleAxis
      ];
    }
  }
  if (item.coord == null || !isArray(dims)) {
    item.coord = [];
  } else {
    const coord = item.coord;
    for (let i = 0; i < 2; i++) {
      if (markerTypeCalculator[coord[i]]) {
        coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);
      }
    }
  }
  return item;
}
function getAxisInfo2(item, data, coordSys, seriesModel) {
  const ret = {};
  if (item.valueIndex != null || item.valueDim != null) {
    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;
    ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));
    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);
    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
  } else {
    ret.baseAxis = seriesModel.getBaseAxis();
    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);
    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
    ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);
  }
  return ret;
}
function dataDimToCoordDim(seriesModel, dataDim) {
  const dimItem = seriesModel.getData().getDimensionInfo(dataDim);
  return dimItem && dimItem.coordDim;
}
function dataFilter2(coordSys, item) {
  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;
}
function zoneFilter(coordSys, item1, item2) {
  return coordSys && coordSys.containZone && item1.coord && item2.coord && !hasXOrY(item1) && !hasXOrY(item2) ? coordSys.containZone(item1.coord, item2.coord) : true;
}
function createMarkerDimValueGetter(inCoordSys, dims) {
  return inCoordSys ? function(item, dimName, dataIndex, dimIndex) {
    const rawVal = dimIndex < 2 ? item.coord && item.coord[dimIndex] : item.value;
    return parseDataValue(rawVal, dims[dimIndex]);
  } : function(item, dimName, dataIndex, dimIndex) {
    return parseDataValue(item.value, dims[dimIndex]);
  };
}
function numCalculate(data, valueDataDim, type) {
  if (type === "average") {
    let sum2 = 0;
    let count2 = 0;
    data.each(valueDataDim, function(val, idx) {
      if (!isNaN(val)) {
        sum2 += val;
        count2++;
      }
    });
    return sum2 / count2;
  } else if (type === "median") {
    return data.getMedian(valueDataDim);
  } else {
    return data.getDataExtent(valueDataDim)[type === "max" ? 1 : 0];
  }
}

// src/component/marker/MarkerView.ts
var inner18 = makeInner();
var MarkerView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = MarkerView2.type;
  }
  init() {
    this.markerGroupMap = createHashMap();
  }
  render(markerModel, ecModel, api2) {
    const markerGroupMap = this.markerGroupMap;
    markerGroupMap.each(function(item) {
      inner18(item).keep = false;
    });
    ecModel.eachSeries((seriesModel) => {
      const markerModel2 = MarkerModel_default.getMarkerModelFromSeries(seriesModel, this.type);
      markerModel2 && this.renderSeries(seriesModel, markerModel2, ecModel, api2);
    });
    markerGroupMap.each((item) => {
      !inner18(item).keep && this.group.remove(item.group);
    });
  }
  markKeep(drawGroup) {
    inner18(drawGroup).keep = true;
  }
  toggleBlurSeries(seriesModelList, isBlur) {
    each(seriesModelList, (seriesModel) => {
      const markerModel = MarkerModel_default.getMarkerModelFromSeries(seriesModel, this.type);
      if (markerModel) {
        const data = markerModel.getData();
        data.eachItemGraphicEl(function(el) {
          if (el) {
            isBlur ? enterBlur(el) : leaveBlur(el);
          }
        });
      }
    });
  }
};
var MarkerView = MarkerView2;
MarkerView.type = "marker";
var MarkerView_default = MarkerView;

// src/component/marker/MarkPointView.ts
function updateMarkerLayout(mpData, seriesModel, api2) {
  const coordSys = seriesModel.coordinateSystem;
  mpData.each(function(idx) {
    const itemModel = mpData.getItemModel(idx);
    let point;
    const xPx = parsePercent2(itemModel.get("x"), api2.getWidth());
    const yPx = parsePercent2(itemModel.get("y"), api2.getHeight());
    if (!isNaN(xPx) && !isNaN(yPx)) {
      point = [xPx, yPx];
    } else if (seriesModel.getMarkerPosition) {
      point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));
    } else if (coordSys) {
      const x = mpData.get(coordSys.dimensions[0], idx);
      const y = mpData.get(coordSys.dimensions[1], idx);
      point = coordSys.dataToPoint([x, y]);
    }
    if (!isNaN(xPx)) {
      point[0] = xPx;
    }
    if (!isNaN(yPx)) {
      point[1] = yPx;
    }
    mpData.setItemLayout(idx, point);
  });
}
var MarkPointView2 = class extends MarkerView_default {
  constructor() {
    super(...arguments);
    this.type = MarkPointView2.type;
  }
  updateTransform(markPointModel, ecModel, api2) {
    ecModel.eachSeries(function(seriesModel) {
      const mpModel = MarkerModel_default.getMarkerModelFromSeries(seriesModel, "markPoint");
      if (mpModel) {
        updateMarkerLayout(mpModel.getData(), seriesModel, api2);
        this.markerGroupMap.get(seriesModel.id).updateLayout();
      }
    }, this);
  }
  renderSeries(seriesModel, mpModel, ecModel, api2) {
    const coordSys = seriesModel.coordinateSystem;
    const seriesId = seriesModel.id;
    const seriesData = seriesModel.getData();
    const symbolDrawMap = this.markerGroupMap;
    const symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw_default());
    const mpData = createData(coordSys, seriesModel, mpModel);
    mpModel.setData(mpData);
    updateMarkerLayout(mpModel.getData(), seriesModel, api2);
    mpData.each(function(idx) {
      const itemModel = mpData.getItemModel(idx);
      let symbol = itemModel.getShallow("symbol");
      let symbolSize = itemModel.getShallow("symbolSize");
      let symbolRotate = itemModel.getShallow("symbolRotate");
      let symbolOffset = itemModel.getShallow("symbolOffset");
      const symbolKeepAspect = itemModel.getShallow("symbolKeepAspect");
      if (isFunction(symbol) || isFunction(symbolSize) || isFunction(symbolRotate) || isFunction(symbolOffset)) {
        const rawIdx = mpModel.getRawValue(idx);
        const dataParams = mpModel.getDataParams(idx);
        if (isFunction(symbol)) {
          symbol = symbol(rawIdx, dataParams);
        }
        if (isFunction(symbolSize)) {
          symbolSize = symbolSize(rawIdx, dataParams);
        }
        if (isFunction(symbolRotate)) {
          symbolRotate = symbolRotate(rawIdx, dataParams);
        }
        if (isFunction(symbolOffset)) {
          symbolOffset = symbolOffset(rawIdx, dataParams);
        }
      }
      const style = itemModel.getModel("itemStyle").getItemStyle();
      const color2 = getVisualFromData(seriesData, "color");
      if (!style.fill) {
        style.fill = color2;
      }
      mpData.setItemVisual(idx, {
        symbol,
        symbolSize,
        symbolRotate,
        symbolOffset,
        symbolKeepAspect,
        style
      });
    });
    symbolDraw.updateData(mpData);
    this.group.add(symbolDraw.group);
    mpData.eachItemGraphicEl(function(el) {
      el.traverse(function(child) {
        getECData(child).dataModel = mpModel;
      });
    });
    this.markKeep(symbolDraw);
    symbolDraw.group.silent = mpModel.get("silent") || seriesModel.get("silent");
  }
};
var MarkPointView = MarkPointView2;
MarkPointView.type = "markPoint";
function createData(coordSys, seriesModel, mpModel) {
  let coordDimsInfos;
  if (coordSys) {
    coordDimsInfos = map(coordSys && coordSys.dimensions, function(coordDim) {
      const info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};
      return extend(extend({}, info), {
        name: coordDim,
        ordinalMeta: null
      });
    });
  } else {
    coordDimsInfos = [{
      name: "value",
      type: "float"
    }];
  }
  const mpData = new SeriesData_default(coordDimsInfos, mpModel);
  let dataOpt = map(mpModel.get("data"), curry(dataTransform, seriesModel));
  if (coordSys) {
    dataOpt = filter(dataOpt, curry(dataFilter2, coordSys));
  }
  const dimValueGetter = createMarkerDimValueGetter(!!coordSys, coordDimsInfos);
  mpData.initData(dataOpt, null, dimValueGetter);
  return mpData;
}
var MarkPointView_default = MarkPointView;

// src/component/marker/installMarkPoint.ts
function install41(registers) {
  registers.registerComponentModel(MarkPointModel_default);
  registers.registerComponentView(MarkPointView_default);
  registers.registerPreprocessor(function(opt) {
    if (checkMarkerInSeries(opt.series, "markPoint")) {
      opt.markPoint = opt.markPoint || {};
    }
  });
}

// src/component/marker/MarkLineModel.ts
var MarkLineModel2 = class extends MarkerModel_default {
  constructor() {
    super(...arguments);
    this.type = MarkLineModel2.type;
  }
  createMarkerModelFromSeries(markerOpt, masterMarkerModel, ecModel) {
    return new MarkLineModel2(markerOpt, masterMarkerModel, ecModel);
  }
};
var MarkLineModel = MarkLineModel2;
MarkLineModel.type = "markLine";
MarkLineModel.defaultOption = {
  z: 5,
  symbol: ["circle", "arrow"],
  symbolSize: [8, 16],
  symbolOffset: 0,
  precision: 2,
  tooltip: {
    trigger: "item"
  },
  label: {
    show: true,
    position: "end",
    distance: 5
  },
  lineStyle: {
    type: "dashed"
  },
  emphasis: {
    label: {
      show: true
    },
    lineStyle: {
      width: 3
    }
  },
  animationEasing: "linear"
};
var MarkLineModel_default = MarkLineModel;

// src/component/marker/MarkLineView.ts
var inner19 = makeInner();
var markLineTransform = function(seriesModel, coordSys, mlModel, item) {
  const data = seriesModel.getData();
  let itemArray;
  if (!isArray(item)) {
    const mlType = item.type;
    if (mlType === "min" || mlType === "max" || mlType === "average" || mlType === "median" || (item.xAxis != null || item.yAxis != null)) {
      let valueAxis2;
      let value;
      if (item.yAxis != null || item.xAxis != null) {
        valueAxis2 = coordSys.getAxis(item.yAxis != null ? "y" : "x");
        value = retrieve(item.yAxis, item.xAxis);
      } else {
        const axisInfo = getAxisInfo2(item, data, coordSys, seriesModel);
        valueAxis2 = axisInfo.valueAxis;
        const valueDataDim = getStackedDimension(data, axisInfo.valueDataDim);
        value = numCalculate(data, valueDataDim, mlType);
      }
      const valueIndex = valueAxis2.dim === "x" ? 0 : 1;
      const baseIndex = 1 - valueIndex;
      const mlFrom = clone(item);
      const mlTo = {
        coord: []
      };
      mlFrom.type = null;
      mlFrom.coord = [];
      mlFrom.coord[baseIndex] = -Infinity;
      mlTo.coord[baseIndex] = Infinity;
      const precision = mlModel.get("precision");
      if (precision >= 0 && isNumber(value)) {
        value = +value.toFixed(Math.min(precision, 20));
      }
      mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;
      itemArray = [mlFrom, mlTo, {
        type: mlType,
        valueIndex: item.valueIndex,
        value
      }];
    } else {
      if (true) {
        logError("Invalid markLine data.");
      }
      itemArray = [];
    }
  } else {
    itemArray = item;
  }
  const normalizedItem = [
    dataTransform(seriesModel, itemArray[0]),
    dataTransform(seriesModel, itemArray[1]),
    extend({}, itemArray[2])
  ];
  normalizedItem[2].type = normalizedItem[2].type || null;
  merge(normalizedItem[2], normalizedItem[0]);
  merge(normalizedItem[2], normalizedItem[1]);
  return normalizedItem;
};
function isInfinity(val) {
  return !isNaN(val) && !isFinite(val);
}
function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
  const otherDimIndex = 1 - dimIndex;
  const dimName = coordSys.dimensions[dimIndex];
  return isInfinity(fromCoord[otherDimIndex]) && isInfinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);
}
function markLineFilter(coordSys, item) {
  if (coordSys.type === "cartesian2d") {
    const fromCoord = item[0].coord;
    const toCoord = item[1].coord;
    if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
      return true;
    }
  }
  return dataFilter2(coordSys, item[0]) && dataFilter2(coordSys, item[1]);
}
function updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api2) {
  const coordSys = seriesModel.coordinateSystem;
  const itemModel = data.getItemModel(idx);
  let point;
  const xPx = parsePercent2(itemModel.get("x"), api2.getWidth());
  const yPx = parsePercent2(itemModel.get("y"), api2.getHeight());
  if (!isNaN(xPx) && !isNaN(yPx)) {
    point = [xPx, yPx];
  } else {
    if (seriesModel.getMarkerPosition) {
      point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));
    } else {
      const dims = coordSys.dimensions;
      const x = data.get(dims[0], idx);
      const y = data.get(dims[1], idx);
      point = coordSys.dataToPoint([x, y]);
    }
    if (isCoordinateSystemType(coordSys, "cartesian2d")) {
      const xAxis = coordSys.getAxis("x");
      const yAxis = coordSys.getAxis("y");
      const dims = coordSys.dimensions;
      if (isInfinity(data.get(dims[0], idx))) {
        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);
      } else if (isInfinity(data.get(dims[1], idx))) {
        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);
      }
    }
    if (!isNaN(xPx)) {
      point[0] = xPx;
    }
    if (!isNaN(yPx)) {
      point[1] = yPx;
    }
  }
  data.setItemLayout(idx, point);
}
var MarkLineView2 = class extends MarkerView_default {
  constructor() {
    super(...arguments);
    this.type = MarkLineView2.type;
  }
  updateTransform(markLineModel, ecModel, api2) {
    ecModel.eachSeries(function(seriesModel) {
      const mlModel = MarkerModel_default.getMarkerModelFromSeries(seriesModel, "markLine");
      if (mlModel) {
        const mlData = mlModel.getData();
        const fromData = inner19(mlModel).from;
        const toData = inner19(mlModel).to;
        fromData.each(function(idx) {
          updateSingleMarkerEndLayout(fromData, idx, true, seriesModel, api2);
          updateSingleMarkerEndLayout(toData, idx, false, seriesModel, api2);
        });
        mlData.each(function(idx) {
          mlData.setItemLayout(idx, [
            fromData.getItemLayout(idx),
            toData.getItemLayout(idx)
          ]);
        });
        this.markerGroupMap.get(seriesModel.id).updateLayout();
      }
    }, this);
  }
  renderSeries(seriesModel, mlModel, ecModel, api2) {
    const coordSys = seriesModel.coordinateSystem;
    const seriesId = seriesModel.id;
    const seriesData = seriesModel.getData();
    const lineDrawMap = this.markerGroupMap;
    const lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw_default());
    this.group.add(lineDraw.group);
    const mlData = createList2(coordSys, seriesModel, mlModel);
    const fromData = mlData.from;
    const toData = mlData.to;
    const lineData = mlData.line;
    inner19(mlModel).from = fromData;
    inner19(mlModel).to = toData;
    mlModel.setData(lineData);
    let symbolType = mlModel.get("symbol");
    let symbolSize = mlModel.get("symbolSize");
    let symbolRotate = mlModel.get("symbolRotate");
    let symbolOffset = mlModel.get("symbolOffset");
    if (!isArray(symbolType)) {
      symbolType = [symbolType, symbolType];
    }
    if (!isArray(symbolSize)) {
      symbolSize = [symbolSize, symbolSize];
    }
    if (!isArray(symbolRotate)) {
      symbolRotate = [symbolRotate, symbolRotate];
    }
    if (!isArray(symbolOffset)) {
      symbolOffset = [symbolOffset, symbolOffset];
    }
    mlData.from.each(function(idx) {
      updateDataVisualAndLayout(fromData, idx, true);
      updateDataVisualAndLayout(toData, idx, false);
    });
    lineData.each(function(idx) {
      const lineStyle = lineData.getItemModel(idx).getModel("lineStyle").getLineStyle();
      lineData.setItemLayout(idx, [
        fromData.getItemLayout(idx),
        toData.getItemLayout(idx)
      ]);
      if (lineStyle.stroke == null) {
        lineStyle.stroke = fromData.getItemVisual(idx, "style").fill;
      }
      lineData.setItemVisual(idx, {
        fromSymbolKeepAspect: fromData.getItemVisual(idx, "symbolKeepAspect"),
        fromSymbolOffset: fromData.getItemVisual(idx, "symbolOffset"),
        fromSymbolRotate: fromData.getItemVisual(idx, "symbolRotate"),
        fromSymbolSize: fromData.getItemVisual(idx, "symbolSize"),
        fromSymbol: fromData.getItemVisual(idx, "symbol"),
        toSymbolKeepAspect: toData.getItemVisual(idx, "symbolKeepAspect"),
        toSymbolOffset: toData.getItemVisual(idx, "symbolOffset"),
        toSymbolRotate: toData.getItemVisual(idx, "symbolRotate"),
        toSymbolSize: toData.getItemVisual(idx, "symbolSize"),
        toSymbol: toData.getItemVisual(idx, "symbol"),
        style: lineStyle
      });
    });
    lineDraw.updateData(lineData);
    mlData.line.eachItemGraphicEl(function(el) {
      getECData(el).dataModel = mlModel;
      el.traverse(function(child) {
        getECData(child).dataModel = mlModel;
      });
    });
    function updateDataVisualAndLayout(data, idx, isFrom) {
      const itemModel = data.getItemModel(idx);
      updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api2);
      const style = itemModel.getModel("itemStyle").getItemStyle();
      if (style.fill == null) {
        style.fill = getVisualFromData(seriesData, "color");
      }
      data.setItemVisual(idx, {
        symbolKeepAspect: itemModel.get("symbolKeepAspect"),
        symbolOffset: retrieve2(itemModel.get("symbolOffset", true), symbolOffset[isFrom ? 0 : 1]),
        symbolRotate: retrieve2(itemModel.get("symbolRotate", true), symbolRotate[isFrom ? 0 : 1]),
        symbolSize: retrieve2(itemModel.get("symbolSize"), symbolSize[isFrom ? 0 : 1]),
        symbol: retrieve2(itemModel.get("symbol", true), symbolType[isFrom ? 0 : 1]),
        style
      });
    }
    this.markKeep(lineDraw);
    lineDraw.group.silent = mlModel.get("silent") || seriesModel.get("silent");
  }
};
var MarkLineView = MarkLineView2;
MarkLineView.type = "markLine";
function createList2(coordSys, seriesModel, mlModel) {
  let coordDimsInfos;
  if (coordSys) {
    coordDimsInfos = map(coordSys && coordSys.dimensions, function(coordDim) {
      const info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};
      return extend(extend({}, info), {
        name: coordDim,
        ordinalMeta: null
      });
    });
  } else {
    coordDimsInfos = [{
      name: "value",
      type: "float"
    }];
  }
  const fromData = new SeriesData_default(coordDimsInfos, mlModel);
  const toData = new SeriesData_default(coordDimsInfos, mlModel);
  const lineData = new SeriesData_default([], mlModel);
  let optData = map(mlModel.get("data"), curry(markLineTransform, seriesModel, coordSys, mlModel));
  if (coordSys) {
    optData = filter(optData, curry(markLineFilter, coordSys));
  }
  const dimValueGetter = createMarkerDimValueGetter(!!coordSys, coordDimsInfos);
  fromData.initData(map(optData, function(item) {
    return item[0];
  }), null, dimValueGetter);
  toData.initData(map(optData, function(item) {
    return item[1];
  }), null, dimValueGetter);
  lineData.initData(map(optData, function(item) {
    return item[2];
  }));
  lineData.hasItemOption = true;
  return {
    from: fromData,
    to: toData,
    line: lineData
  };
}
var MarkLineView_default = MarkLineView;

// src/component/marker/installMarkLine.ts
function install42(registers) {
  registers.registerComponentModel(MarkLineModel_default);
  registers.registerComponentView(MarkLineView_default);
  registers.registerPreprocessor(function(opt) {
    if (checkMarkerInSeries(opt.series, "markLine")) {
      opt.markLine = opt.markLine || {};
    }
  });
}

// src/component/marker/MarkAreaModel.ts
var MarkAreaModel2 = class extends MarkerModel_default {
  constructor() {
    super(...arguments);
    this.type = MarkAreaModel2.type;
  }
  createMarkerModelFromSeries(markerOpt, masterMarkerModel, ecModel) {
    return new MarkAreaModel2(markerOpt, masterMarkerModel, ecModel);
  }
};
var MarkAreaModel = MarkAreaModel2;
MarkAreaModel.type = "markArea";
MarkAreaModel.defaultOption = {
  z: 1,
  tooltip: {
    trigger: "item"
  },
  animation: false,
  label: {
    show: true,
    position: "top"
  },
  itemStyle: {
    borderWidth: 0
  },
  emphasis: {
    label: {
      show: true,
      position: "top"
    }
  }
};
var MarkAreaModel_default = MarkAreaModel;

// src/component/marker/MarkAreaView.ts
var inner20 = makeInner();
var markAreaTransform = function(seriesModel, coordSys, maModel, item) {
  const item0 = item[0];
  const item1 = item[1];
  if (!item0 || !item1) {
    return;
  }
  const lt2 = dataTransform(seriesModel, item0);
  const rb2 = dataTransform(seriesModel, item1);
  const ltCoord = lt2.coord;
  const rbCoord = rb2.coord;
  ltCoord[0] = retrieve(ltCoord[0], -Infinity);
  ltCoord[1] = retrieve(ltCoord[1], -Infinity);
  rbCoord[0] = retrieve(rbCoord[0], Infinity);
  rbCoord[1] = retrieve(rbCoord[1], Infinity);
  const result = mergeAll([{}, lt2, rb2]);
  result.coord = [
    lt2.coord,
    rb2.coord
  ];
  result.x0 = lt2.x;
  result.y0 = lt2.y;
  result.x1 = rb2.x;
  result.y1 = rb2.y;
  return result;
};
function isInfinity2(val) {
  return !isNaN(val) && !isFinite(val);
}
function ifMarkAreaHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
  const otherDimIndex = 1 - dimIndex;
  return isInfinity2(fromCoord[otherDimIndex]) && isInfinity2(toCoord[otherDimIndex]);
}
function markAreaFilter(coordSys, item) {
  const fromCoord = item.coord[0];
  const toCoord = item.coord[1];
  const item0 = {
    coord: fromCoord,
    x: item.x0,
    y: item.y0
  };
  const item1 = {
    coord: toCoord,
    x: item.x1,
    y: item.y1
  };
  if (isCoordinateSystemType(coordSys, "cartesian2d")) {
    if (fromCoord && toCoord && (ifMarkAreaHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkAreaHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
      return true;
    }
    return zoneFilter(coordSys, item0, item1);
  }
  return dataFilter2(coordSys, item0) || dataFilter2(coordSys, item1);
}
function getSingleMarkerEndPoint(data, idx, dims, seriesModel, api2) {
  const coordSys = seriesModel.coordinateSystem;
  const itemModel = data.getItemModel(idx);
  let point;
  const xPx = parsePercent2(itemModel.get(dims[0]), api2.getWidth());
  const yPx = parsePercent2(itemModel.get(dims[1]), api2.getHeight());
  if (!isNaN(xPx) && !isNaN(yPx)) {
    point = [xPx, yPx];
  } else {
    if (seriesModel.getMarkerPosition) {
      const pointValue0 = data.getValues(["x0", "y0"], idx);
      const pointValue1 = data.getValues(["x1", "y1"], idx);
      const clampPointValue0 = coordSys.clampData(pointValue0);
      const clampPointValue1 = coordSys.clampData(pointValue1);
      const pointValue = [];
      if (dims[0] === "x0") {
        pointValue[0] = clampPointValue0[0] > clampPointValue1[0] ? pointValue1[0] : pointValue0[0];
      } else {
        pointValue[0] = clampPointValue0[0] > clampPointValue1[0] ? pointValue0[0] : pointValue1[0];
      }
      if (dims[1] === "y0") {
        pointValue[1] = clampPointValue0[1] > clampPointValue1[1] ? pointValue1[1] : pointValue0[1];
      } else {
        pointValue[1] = clampPointValue0[1] > clampPointValue1[1] ? pointValue0[1] : pointValue1[1];
      }
      point = seriesModel.getMarkerPosition(pointValue, dims, true);
    } else {
      const x = data.get(dims[0], idx);
      const y = data.get(dims[1], idx);
      const pt = [x, y];
      coordSys.clampData && coordSys.clampData(pt, pt);
      point = coordSys.dataToPoint(pt, true);
    }
    if (isCoordinateSystemType(coordSys, "cartesian2d")) {
      const xAxis = coordSys.getAxis("x");
      const yAxis = coordSys.getAxis("y");
      const x = data.get(dims[0], idx);
      const y = data.get(dims[1], idx);
      if (isInfinity2(x)) {
        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === "x0" ? 0 : 1]);
      } else if (isInfinity2(y)) {
        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === "y0" ? 0 : 1]);
      }
    }
    if (!isNaN(xPx)) {
      point[0] = xPx;
    }
    if (!isNaN(yPx)) {
      point[1] = yPx;
    }
  }
  return point;
}
var dimPermutations = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]];
var MarkAreaView2 = class extends MarkerView_default {
  constructor() {
    super(...arguments);
    this.type = MarkAreaView2.type;
  }
  updateTransform(markAreaModel, ecModel, api2) {
    ecModel.eachSeries(function(seriesModel) {
      const maModel = MarkerModel_default.getMarkerModelFromSeries(seriesModel, "markArea");
      if (maModel) {
        const areaData = maModel.getData();
        areaData.each(function(idx) {
          const points4 = map(dimPermutations, function(dim) {
            return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api2);
          });
          areaData.setItemLayout(idx, points4);
          const el = areaData.getItemGraphicEl(idx);
          el.setShape("points", points4);
        });
      }
    }, this);
  }
  renderSeries(seriesModel, maModel, ecModel, api2) {
    const coordSys = seriesModel.coordinateSystem;
    const seriesId = seriesModel.id;
    const seriesData = seriesModel.getData();
    const areaGroupMap = this.markerGroupMap;
    const polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, {group: new Group_default()});
    this.group.add(polygonGroup.group);
    this.markKeep(polygonGroup);
    const areaData = createList3(coordSys, seriesModel, maModel);
    maModel.setData(areaData);
    areaData.each(function(idx) {
      const points4 = map(dimPermutations, function(dim) {
        return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api2);
      });
      const xAxisScale = coordSys.getAxis("x").scale;
      const yAxisScale = coordSys.getAxis("y").scale;
      const xAxisExtent = xAxisScale.getExtent();
      const yAxisExtent = yAxisScale.getExtent();
      const xPointExtent = [xAxisScale.parse(areaData.get("x0", idx)), xAxisScale.parse(areaData.get("x1", idx))];
      const yPointExtent = [yAxisScale.parse(areaData.get("y0", idx)), yAxisScale.parse(areaData.get("y1", idx))];
      asc(xPointExtent);
      asc(yPointExtent);
      const overlapped = !(xAxisExtent[0] > xPointExtent[1] || xAxisExtent[1] < xPointExtent[0] || yAxisExtent[0] > yPointExtent[1] || yAxisExtent[1] < yPointExtent[0]);
      const allClipped = !overlapped;
      areaData.setItemLayout(idx, {
        points: points4,
        allClipped
      });
      const style = areaData.getItemModel(idx).getModel("itemStyle").getItemStyle();
      const color2 = getVisualFromData(seriesData, "color");
      if (!style.fill) {
        style.fill = color2;
        if (isString(style.fill)) {
          style.fill = modifyAlpha(style.fill, 0.4);
        }
      }
      if (!style.stroke) {
        style.stroke = color2;
      }
      areaData.setItemVisual(idx, "style", style);
    });
    areaData.diff(inner20(polygonGroup).data).add(function(idx) {
      const layout18 = areaData.getItemLayout(idx);
      if (!layout18.allClipped) {
        const polygon = new Polygon_default({
          shape: {
            points: layout18.points
          }
        });
        areaData.setItemGraphicEl(idx, polygon);
        polygonGroup.group.add(polygon);
      }
    }).update(function(newIdx, oldIdx) {
      let polygon = inner20(polygonGroup).data.getItemGraphicEl(oldIdx);
      const layout18 = areaData.getItemLayout(newIdx);
      if (!layout18.allClipped) {
        if (polygon) {
          updateProps(polygon, {
            shape: {
              points: layout18.points
            }
          }, maModel, newIdx);
        } else {
          polygon = new Polygon_default({
            shape: {
              points: layout18.points
            }
          });
        }
        areaData.setItemGraphicEl(newIdx, polygon);
        polygonGroup.group.add(polygon);
      } else if (polygon) {
        polygonGroup.group.remove(polygon);
      }
    }).remove(function(idx) {
      const polygon = inner20(polygonGroup).data.getItemGraphicEl(idx);
      polygonGroup.group.remove(polygon);
    }).execute();
    areaData.eachItemGraphicEl(function(polygon, idx) {
      const itemModel = areaData.getItemModel(idx);
      const style = areaData.getItemVisual(idx, "style");
      polygon.useStyle(areaData.getItemVisual(idx, "style"));
      setLabelStyle(polygon, getLabelStatesModels(itemModel), {
        labelFetcher: maModel,
        labelDataIndex: idx,
        defaultText: areaData.getName(idx) || "",
        inheritColor: isString(style.fill) ? modifyAlpha(style.fill, 1) : "#000"
      });
      setStatesStylesFromModel(polygon, itemModel);
      toggleHoverEmphasis(polygon, null, null, itemModel.get(["emphasis", "disabled"]));
      getECData(polygon).dataModel = maModel;
    });
    inner20(polygonGroup).data = areaData;
    polygonGroup.group.silent = maModel.get("silent") || seriesModel.get("silent");
  }
};
var MarkAreaView = MarkAreaView2;
MarkAreaView.type = "markArea";
function createList3(coordSys, seriesModel, maModel) {
  let areaData;
  let dataDims;
  const dims = ["x0", "y0", "x1", "y1"];
  if (coordSys) {
    const coordDimsInfos = map(coordSys && coordSys.dimensions, function(coordDim) {
      const data = seriesModel.getData();
      const info = data.getDimensionInfo(data.mapDimension(coordDim)) || {};
      return extend(extend({}, info), {
        name: coordDim,
        ordinalMeta: null
      });
    });
    dataDims = map(dims, (dim, idx) => ({
      name: dim,
      type: coordDimsInfos[idx % 2].type
    }));
    areaData = new SeriesData_default(dataDims, maModel);
  } else {
    dataDims = [{
      name: "value",
      type: "float"
    }];
    areaData = new SeriesData_default(dataDims, maModel);
  }
  let optData = map(maModel.get("data"), curry(markAreaTransform, seriesModel, coordSys, maModel));
  if (coordSys) {
    optData = filter(optData, curry(markAreaFilter, coordSys));
  }
  const dimValueGetter = coordSys ? function(item, dimName, dataIndex, dimIndex) {
    const rawVal = item.coord[Math.floor(dimIndex / 2)][dimIndex % 2];
    return parseDataValue(rawVal, dataDims[dimIndex]);
  } : function(item, dimName, dataIndex, dimIndex) {
    return parseDataValue(item.value, dataDims[dimIndex]);
  };
  areaData.initData(optData, null, dimValueGetter);
  areaData.hasItemOption = true;
  return areaData;
}
var MarkAreaView_default = MarkAreaView;

// src/component/marker/installMarkArea.ts
function install43(registers) {
  registers.registerComponentModel(MarkAreaModel_default);
  registers.registerComponentView(MarkAreaView_default);
  registers.registerPreprocessor(function(opt) {
    if (checkMarkerInSeries(opt.series, "markArea")) {
      opt.markArea = opt.markArea || {};
    }
  });
}

// src/component/legend/LegendModel.ts
var getDefaultSelectorOptions = function(ecModel, type) {
  if (type === "all") {
    return {
      type: "all",
      title: ecModel.getLocaleModel().get(["legend", "selector", "all"])
    };
  } else if (type === "inverse") {
    return {
      type: "inverse",
      title: ecModel.getLocaleModel().get(["legend", "selector", "inverse"])
    };
  }
};
var LegendModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = LegendModel2.type;
    this.layoutMode = {
      type: "box",
      ignoreSize: true
    };
  }
  init(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
    option.selected = option.selected || {};
    this._updateSelector(option);
  }
  mergeOption(option, ecModel) {
    super.mergeOption(option, ecModel);
    this._updateSelector(option);
  }
  _updateSelector(option) {
    let selector2 = option.selector;
    const {ecModel} = this;
    if (selector2 === true) {
      selector2 = option.selector = ["all", "inverse"];
    }
    if (isArray(selector2)) {
      each(selector2, function(item, index) {
        isString(item) && (item = {type: item});
        selector2[index] = merge(item, getDefaultSelectorOptions(ecModel, item.type));
      });
    }
  }
  optionUpdated() {
    this._updateData(this.ecModel);
    const legendData = this._data;
    if (legendData[0] && this.get("selectedMode") === "single") {
      let hasSelected = false;
      for (let i = 0; i < legendData.length; i++) {
        const name = legendData[i].get("name");
        if (this.isSelected(name)) {
          this.select(name);
          hasSelected = true;
          break;
        }
      }
      !hasSelected && this.select(legendData[0].get("name"));
    }
  }
  _updateData(ecModel) {
    let potentialData = [];
    let availableNames = [];
    ecModel.eachRawSeries(function(seriesModel) {
      const seriesName = seriesModel.name;
      availableNames.push(seriesName);
      let isPotential;
      if (seriesModel.legendVisualProvider) {
        const provider = seriesModel.legendVisualProvider;
        const names = provider.getAllNames();
        if (!ecModel.isSeriesFiltered(seriesModel)) {
          availableNames = availableNames.concat(names);
        }
        if (names.length) {
          potentialData = potentialData.concat(names);
        } else {
          isPotential = true;
        }
      } else {
        isPotential = true;
      }
      if (isPotential && isNameSpecified(seriesModel)) {
        potentialData.push(seriesModel.name);
      }
    });
    this._availableNames = availableNames;
    const rawData = this.get("data") || potentialData;
    const legendNameMap = createHashMap();
    const legendData = map(rawData, function(dataItem) {
      if (isString(dataItem) || isNumber(dataItem)) {
        dataItem = {
          name: dataItem
        };
      }
      if (legendNameMap.get(dataItem.name)) {
        return null;
      }
      legendNameMap.set(dataItem.name, true);
      return new Model_default(dataItem, this, this.ecModel);
    }, this);
    this._data = filter(legendData, (item) => !!item);
  }
  getData() {
    return this._data;
  }
  select(name) {
    const selected = this.option.selected;
    const selectedMode = this.get("selectedMode");
    if (selectedMode === "single") {
      const data = this._data;
      each(data, function(dataItem) {
        selected[dataItem.get("name")] = false;
      });
    }
    selected[name] = true;
  }
  unSelect(name) {
    if (this.get("selectedMode") !== "single") {
      this.option.selected[name] = false;
    }
  }
  toggleSelected(name) {
    const selected = this.option.selected;
    if (!selected.hasOwnProperty(name)) {
      selected[name] = true;
    }
    this[selected[name] ? "unSelect" : "select"](name);
  }
  allSelect() {
    const data = this._data;
    const selected = this.option.selected;
    each(data, function(dataItem) {
      selected[dataItem.get("name", true)] = true;
    });
  }
  inverseSelect() {
    const data = this._data;
    const selected = this.option.selected;
    each(data, function(dataItem) {
      const name = dataItem.get("name", true);
      if (!selected.hasOwnProperty(name)) {
        selected[name] = true;
      }
      selected[name] = !selected[name];
    });
  }
  isSelected(name) {
    const selected = this.option.selected;
    return !(selected.hasOwnProperty(name) && !selected[name]) && indexOf(this._availableNames, name) >= 0;
  }
  getOrient() {
    return this.get("orient") === "vertical" ? {index: 1, name: "vertical"} : {index: 0, name: "horizontal"};
  }
};
var LegendModel = LegendModel2;
LegendModel.type = "legend.plain";
LegendModel.dependencies = ["series"];
LegendModel.defaultOption = {
  z: 4,
  show: true,
  orient: "horizontal",
  left: "center",
  top: 0,
  align: "auto",
  backgroundColor: "rgba(0,0,0,0)",
  borderColor: "#ccc",
  borderRadius: 0,
  borderWidth: 0,
  padding: 5,
  itemGap: 10,
  itemWidth: 25,
  itemHeight: 14,
  symbolRotate: "inherit",
  symbolKeepAspect: true,
  inactiveColor: "#ccc",
  inactiveBorderColor: "#ccc",
  inactiveBorderWidth: "auto",
  itemStyle: {
    color: "inherit",
    opacity: "inherit",
    borderColor: "inherit",
    borderWidth: "auto",
    borderCap: "inherit",
    borderJoin: "inherit",
    borderDashOffset: "inherit",
    borderMiterLimit: "inherit"
  },
  lineStyle: {
    width: "auto",
    color: "inherit",
    inactiveColor: "#ccc",
    inactiveWidth: 2,
    opacity: "inherit",
    type: "inherit",
    cap: "inherit",
    join: "inherit",
    dashOffset: "inherit",
    miterLimit: "inherit"
  },
  textStyle: {
    color: "#333"
  },
  selectedMode: true,
  selector: false,
  selectorLabel: {
    show: true,
    borderRadius: 10,
    padding: [3, 5, 3, 5],
    fontSize: 12,
    fontFamily: "sans-serif",
    color: "#666",
    borderWidth: 1,
    borderColor: "#666"
  },
  emphasis: {
    selectorLabel: {
      show: true,
      color: "#eee",
      backgroundColor: "#666"
    }
  },
  selectorPosition: "auto",
  selectorItemGap: 7,
  selectorButtonGap: 10,
  tooltip: {
    show: false
  }
};
var LegendModel_default = LegendModel;

// src/component/legend/LegendView.ts
var curry2 = curry;
var each13 = each;
var Group3 = Group_default;
var LegendView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = LegendView2.type;
    this.newlineDisabled = false;
  }
  init() {
    this.group.add(this._contentGroup = new Group3());
    this.group.add(this._selectorGroup = new Group3());
    this._isFirstRender = true;
  }
  getContentGroup() {
    return this._contentGroup;
  }
  getSelectorGroup() {
    return this._selectorGroup;
  }
  render(legendModel, ecModel, api2) {
    const isFirstRender = this._isFirstRender;
    this._isFirstRender = false;
    this.resetInner();
    if (!legendModel.get("show", true)) {
      return;
    }
    let itemAlign = legendModel.get("align");
    const orient = legendModel.get("orient");
    if (!itemAlign || itemAlign === "auto") {
      itemAlign = legendModel.get("left") === "right" && orient === "vertical" ? "right" : "left";
    }
    const selector2 = legendModel.get("selector", true);
    let selectorPosition = legendModel.get("selectorPosition", true);
    if (selector2 && (!selectorPosition || selectorPosition === "auto")) {
      selectorPosition = orient === "horizontal" ? "end" : "start";
    }
    this.renderInner(itemAlign, legendModel, ecModel, api2, selector2, orient, selectorPosition);
    const positionInfo = legendModel.getBoxLayoutParams();
    const viewportSize = {width: api2.getWidth(), height: api2.getHeight()};
    const padding = legendModel.get("padding");
    const maxSize = getLayoutRect(positionInfo, viewportSize, padding);
    const mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector2, selectorPosition);
    const layoutRect = getLayoutRect(defaults({
      width: mainRect.width,
      height: mainRect.height
    }, positionInfo), viewportSize, padding);
    this.group.x = layoutRect.x - mainRect.x;
    this.group.y = layoutRect.y - mainRect.y;
    this.group.markRedraw();
    this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel));
  }
  resetInner() {
    this.getContentGroup().removeAll();
    this._backgroundEl && this.group.remove(this._backgroundEl);
    this.getSelectorGroup().removeAll();
  }
  renderInner(itemAlign, legendModel, ecModel, api2, selector2, orient, selectorPosition) {
    const contentGroup = this.getContentGroup();
    const legendDrawnMap = createHashMap();
    const selectMode = legendModel.get("selectedMode");
    const excludeSeriesId = [];
    ecModel.eachRawSeries(function(seriesModel) {
      !seriesModel.get("legendHoverLink") && excludeSeriesId.push(seriesModel.id);
    });
    each13(legendModel.getData(), function(legendItemModel, dataIndex) {
      const name = legendItemModel.get("name");
      if (!this.newlineDisabled && (name === "" || name === "\n")) {
        const g = new Group3();
        g.newline = true;
        contentGroup.add(g);
        return;
      }
      const seriesModel = ecModel.getSeriesByName(name)[0];
      if (legendDrawnMap.get(name)) {
        return;
      }
      if (seriesModel) {
        const data = seriesModel.getData();
        const lineVisualStyle = data.getVisual("legendLineStyle") || {};
        const legendIcon = data.getVisual("legendIcon");
        const style = data.getVisual("style");
        const itemGroup = this._createItem(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, style, legendIcon, selectMode, api2);
        itemGroup.on("click", curry2(dispatchSelectAction, name, null, api2, excludeSeriesId)).on("mouseover", curry2(dispatchHighlightAction, seriesModel.name, null, api2, excludeSeriesId)).on("mouseout", curry2(dispatchDownplayAction, seriesModel.name, null, api2, excludeSeriesId));
        if (ecModel.ssr) {
          itemGroup.eachChild((child) => {
            const ecData = getECData(child);
            ecData.seriesIndex = seriesModel.seriesIndex;
            ecData.dataIndex = dataIndex;
            ecData.ssrType = "legend";
          });
        }
        legendDrawnMap.set(name, true);
      } else {
        ecModel.eachRawSeries(function(seriesModel2) {
          if (legendDrawnMap.get(name)) {
            return;
          }
          if (seriesModel2.legendVisualProvider) {
            const provider = seriesModel2.legendVisualProvider;
            if (!provider.containName(name)) {
              return;
            }
            const idx = provider.indexOfName(name);
            let style = provider.getItemVisual(idx, "style");
            const legendIcon = provider.getItemVisual(idx, "legendIcon");
            const colorArr = parse(style.fill);
            if (colorArr && colorArr[3] === 0) {
              colorArr[3] = 0.2;
              style = extend(extend({}, style), {fill: stringify(colorArr, "rgba")});
            }
            const itemGroup = this._createItem(seriesModel2, name, dataIndex, legendItemModel, legendModel, itemAlign, {}, style, legendIcon, selectMode, api2);
            itemGroup.on("click", curry2(dispatchSelectAction, null, name, api2, excludeSeriesId)).on("mouseover", curry2(dispatchHighlightAction, null, name, api2, excludeSeriesId)).on("mouseout", curry2(dispatchDownplayAction, null, name, api2, excludeSeriesId));
            if (ecModel.ssr) {
              itemGroup.eachChild((child) => {
                const ecData = getECData(child);
                ecData.seriesIndex = seriesModel2.seriesIndex;
                ecData.dataIndex = dataIndex;
                ecData.ssrType = "legend";
              });
            }
            legendDrawnMap.set(name, true);
          }
        }, this);
      }
      if (true) {
        if (!legendDrawnMap.get(name)) {
          console.warn(name + " series not exists. Legend data should be same with series name or data name.");
        }
      }
    }, this);
    if (selector2) {
      this._createSelector(selector2, legendModel, api2, orient, selectorPosition);
    }
  }
  _createSelector(selector2, legendModel, api2, orient, selectorPosition) {
    const selectorGroup = this.getSelectorGroup();
    each13(selector2, function createSelectorButton(selectorItem) {
      const type = selectorItem.type;
      const labelText = new Text_default({
        style: {
          x: 0,
          y: 0,
          align: "center",
          verticalAlign: "middle"
        },
        onclick() {
          api2.dispatchAction({
            type: type === "all" ? "legendAllSelect" : "legendInverseSelect"
          });
        }
      });
      selectorGroup.add(labelText);
      const labelModel = legendModel.getModel("selectorLabel");
      const emphasisLabelModel = legendModel.getModel(["emphasis", "selectorLabel"]);
      setLabelStyle(labelText, {normal: labelModel, emphasis: emphasisLabelModel}, {
        defaultText: selectorItem.title
      });
      enableHoverEmphasis(labelText);
    });
  }
  _createItem(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, itemVisualStyle, legendIcon, selectMode, api2) {
    const drawType = seriesModel.visualDrawType;
    const itemWidth = legendModel.get("itemWidth");
    const itemHeight = legendModel.get("itemHeight");
    const isSelected = legendModel.isSelected(name);
    const iconRotate = legendItemModel.get("symbolRotate");
    const symbolKeepAspect = legendItemModel.get("symbolKeepAspect");
    const legendIconType = legendItemModel.get("icon");
    legendIcon = legendIconType || legendIcon || "roundRect";
    const style = getLegendStyle(legendIcon, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api2);
    const itemGroup = new Group3();
    const textStyleModel = legendItemModel.getModel("textStyle");
    if (isFunction(seriesModel.getLegendIcon) && (!legendIconType || legendIconType === "inherit")) {
      itemGroup.add(seriesModel.getLegendIcon({
        itemWidth,
        itemHeight,
        icon: legendIcon,
        iconRotate,
        itemStyle: style.itemStyle,
        lineStyle: style.lineStyle,
        symbolKeepAspect
      }));
    } else {
      const rotate2 = legendIconType === "inherit" && seriesModel.getData().getVisual("symbol") ? iconRotate === "inherit" ? seriesModel.getData().getVisual("symbolRotate") : iconRotate : 0;
      itemGroup.add(getDefaultLegendIcon({
        itemWidth,
        itemHeight,
        icon: legendIcon,
        iconRotate: rotate2,
        itemStyle: style.itemStyle,
        lineStyle: style.lineStyle,
        symbolKeepAspect
      }));
    }
    const textX = itemAlign === "left" ? itemWidth + 5 : -5;
    const textAlign = itemAlign;
    const formatter = legendModel.get("formatter");
    let content = name;
    if (isString(formatter) && formatter) {
      content = formatter.replace("{name}", name != null ? name : "");
    } else if (isFunction(formatter)) {
      content = formatter(name);
    }
    const textColor = isSelected ? textStyleModel.getTextColor() : legendItemModel.get("inactiveColor");
    itemGroup.add(new Text_default({
      style: createTextStyle(textStyleModel, {
        text: content,
        x: textX,
        y: itemHeight / 2,
        fill: textColor,
        align: textAlign,
        verticalAlign: "middle"
      }, {inheritColor: textColor})
    }));
    const hitRect = new Rect_default({
      shape: itemGroup.getBoundingRect(),
      style: {
        fill: "transparent"
      }
    });
    const tooltipModel = legendItemModel.getModel("tooltip");
    if (tooltipModel.get("show")) {
      setTooltipConfig({
        el: hitRect,
        componentModel: legendModel,
        itemName: name,
        itemTooltipOption: tooltipModel.option
      });
    }
    itemGroup.add(hitRect);
    itemGroup.eachChild(function(child) {
      child.silent = true;
    });
    hitRect.silent = !selectMode;
    this.getContentGroup().add(itemGroup);
    enableHoverEmphasis(itemGroup);
    itemGroup.__legendDataIndex = dataIndex;
    return itemGroup;
  }
  layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector2, selectorPosition) {
    const contentGroup = this.getContentGroup();
    const selectorGroup = this.getSelectorGroup();
    box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), maxSize.width, maxSize.height);
    const contentRect = contentGroup.getBoundingRect();
    const contentPos = [-contentRect.x, -contentRect.y];
    selectorGroup.markRedraw();
    contentGroup.markRedraw();
    if (selector2) {
      box("horizontal", selectorGroup, legendModel.get("selectorItemGap", true));
      const selectorRect = selectorGroup.getBoundingRect();
      const selectorPos = [-selectorRect.x, -selectorRect.y];
      const selectorButtonGap = legendModel.get("selectorButtonGap", true);
      const orientIdx = legendModel.getOrient().index;
      const wh = orientIdx === 0 ? "width" : "height";
      const hw = orientIdx === 0 ? "height" : "width";
      const yx = orientIdx === 0 ? "y" : "x";
      if (selectorPosition === "end") {
        selectorPos[orientIdx] += contentRect[wh] + selectorButtonGap;
      } else {
        contentPos[orientIdx] += selectorRect[wh] + selectorButtonGap;
      }
      selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2;
      selectorGroup.x = selectorPos[0];
      selectorGroup.y = selectorPos[1];
      contentGroup.x = contentPos[0];
      contentGroup.y = contentPos[1];
      const mainRect = {x: 0, y: 0};
      mainRect[wh] = contentRect[wh] + selectorButtonGap + selectorRect[wh];
      mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw]);
      mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx]);
      return mainRect;
    } else {
      contentGroup.x = contentPos[0];
      contentGroup.y = contentPos[1];
      return this.group.getBoundingRect();
    }
  }
  remove() {
    this.getContentGroup().removeAll();
    this._isFirstRender = true;
  }
};
var LegendView = LegendView2;
LegendView.type = "legend.plain";
function getLegendStyle(iconType, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api2) {
  function handleCommonProps(style, visualStyle) {
    if (style.lineWidth === "auto") {
      style.lineWidth = visualStyle.lineWidth > 0 ? 2 : 0;
    }
    each13(style, (propVal, propName) => {
      style[propName] === "inherit" && (style[propName] = visualStyle[propName]);
    });
  }
  const itemStyleModel = legendItemModel.getModel("itemStyle");
  const itemStyle = itemStyleModel.getItemStyle();
  const iconBrushType = iconType.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke";
  const decalStyle = itemStyleModel.getShallow("decal");
  itemStyle.decal = !decalStyle || decalStyle === "inherit" ? itemVisualStyle.decal : createOrUpdatePatternFromDecal(decalStyle, api2);
  if (itemStyle.fill === "inherit") {
    itemStyle.fill = itemVisualStyle[drawType];
  }
  if (itemStyle.stroke === "inherit") {
    itemStyle.stroke = itemVisualStyle[iconBrushType];
  }
  if (itemStyle.opacity === "inherit") {
    itemStyle.opacity = (drawType === "fill" ? itemVisualStyle : lineVisualStyle).opacity;
  }
  handleCommonProps(itemStyle, itemVisualStyle);
  const legendLineModel = legendItemModel.getModel("lineStyle");
  const lineStyle = legendLineModel.getLineStyle();
  handleCommonProps(lineStyle, lineVisualStyle);
  itemStyle.fill === "auto" && (itemStyle.fill = itemVisualStyle.fill);
  itemStyle.stroke === "auto" && (itemStyle.stroke = itemVisualStyle.fill);
  lineStyle.stroke === "auto" && (lineStyle.stroke = itemVisualStyle.fill);
  if (!isSelected) {
    const borderWidth = legendItemModel.get("inactiveBorderWidth");
    const visualHasBorder = itemStyle[iconBrushType];
    itemStyle.lineWidth = borderWidth === "auto" ? itemVisualStyle.lineWidth > 0 && visualHasBorder ? 2 : 0 : itemStyle.lineWidth;
    itemStyle.fill = legendItemModel.get("inactiveColor");
    itemStyle.stroke = legendItemModel.get("inactiveBorderColor");
    lineStyle.stroke = legendLineModel.get("inactiveColor");
    lineStyle.lineWidth = legendLineModel.get("inactiveWidth");
  }
  return {itemStyle, lineStyle};
}
function getDefaultLegendIcon(opt) {
  const symboType = opt.icon || "roundRect";
  const icon = createSymbol(symboType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill, opt.symbolKeepAspect);
  icon.setStyle(opt.itemStyle);
  icon.rotation = (opt.iconRotate || 0) * Math.PI / 180;
  icon.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2]);
  if (symboType.indexOf("empty") > -1) {
    icon.style.stroke = icon.style.fill;
    icon.style.fill = "#fff";
    icon.style.lineWidth = 2;
  }
  return icon;
}
function dispatchSelectAction(seriesName, dataName, api2, excludeSeriesId) {
  dispatchDownplayAction(seriesName, dataName, api2, excludeSeriesId);
  api2.dispatchAction({
    type: "legendToggleSelect",
    name: seriesName != null ? seriesName : dataName
  });
  dispatchHighlightAction(seriesName, dataName, api2, excludeSeriesId);
}
function isUseHoverLayer(api2) {
  const list = api2.getZr().storage.getDisplayList();
  let emphasisState;
  let i = 0;
  const len2 = list.length;
  while (i < len2 && !(emphasisState = list[i].states.emphasis)) {
    i++;
  }
  return emphasisState && emphasisState.hoverLayer;
}
function dispatchHighlightAction(seriesName, dataName, api2, excludeSeriesId) {
  if (!isUseHoverLayer(api2)) {
    api2.dispatchAction({
      type: "highlight",
      seriesName,
      name: dataName,
      excludeSeriesId
    });
  }
}
function dispatchDownplayAction(seriesName, dataName, api2, excludeSeriesId) {
  if (!isUseHoverLayer(api2)) {
    api2.dispatchAction({
      type: "downplay",
      seriesName,
      name: dataName,
      excludeSeriesId
    });
  }
}
var LegendView_default = LegendView;

// src/component/legend/legendFilter.ts
function legendFilter(ecModel) {
  const legendModels = ecModel.findComponents({
    mainType: "legend"
  });
  if (legendModels && legendModels.length) {
    ecModel.filterSeries(function(series) {
      for (let i = 0; i < legendModels.length; i++) {
        if (!legendModels[i].isSelected(series.name)) {
          return false;
        }
      }
      return true;
    });
  }
}

// src/component/legend/legendAction.ts
function legendSelectActionHandler(methodName, payload, ecModel) {
  const selectedMap = {};
  const isToggleSelect = methodName === "toggleSelected";
  let isSelected;
  ecModel.eachComponent("legend", function(legendModel) {
    if (isToggleSelect && isSelected != null) {
      legendModel[isSelected ? "select" : "unSelect"](payload.name);
    } else if (methodName === "allSelect" || methodName === "inverseSelect") {
      legendModel[methodName]();
    } else {
      legendModel[methodName](payload.name);
      isSelected = legendModel.isSelected(payload.name);
    }
    const legendData = legendModel.getData();
    each(legendData, function(model) {
      const name = model.get("name");
      if (name === "\n" || name === "") {
        return;
      }
      const isItemSelected = legendModel.isSelected(name);
      if (selectedMap.hasOwnProperty(name)) {
        selectedMap[name] = selectedMap[name] && isItemSelected;
      } else {
        selectedMap[name] = isItemSelected;
      }
    });
  });
  return methodName === "allSelect" || methodName === "inverseSelect" ? {
    selected: selectedMap
  } : {
    name: payload.name,
    selected: selectedMap
  };
}
function installLegendAction(registers) {
  registers.registerAction("legendToggleSelect", "legendselectchanged", curry(legendSelectActionHandler, "toggleSelected"));
  registers.registerAction("legendAllSelect", "legendselectall", curry(legendSelectActionHandler, "allSelect"));
  registers.registerAction("legendInverseSelect", "legendinverseselect", curry(legendSelectActionHandler, "inverseSelect"));
  registers.registerAction("legendSelect", "legendselected", curry(legendSelectActionHandler, "select"));
  registers.registerAction("legendUnSelect", "legendunselected", curry(legendSelectActionHandler, "unSelect"));
}

// src/component/legend/installLegendPlain.ts
function install44(registers) {
  registers.registerComponentModel(LegendModel_default);
  registers.registerComponentView(LegendView_default);
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter);
  registers.registerSubTypeDefaulter("legend", function() {
    return "plain";
  });
  installLegendAction(registers);
}

// src/component/legend/ScrollableLegendModel.ts
var ScrollableLegendModel2 = class extends LegendModel_default {
  constructor() {
    super(...arguments);
    this.type = ScrollableLegendModel2.type;
  }
  setScrollDataIndex(scrollDataIndex) {
    this.option.scrollDataIndex = scrollDataIndex;
  }
  init(option, parentModel, ecModel) {
    const inputPositionParams = getLayoutParams(option);
    super.init(option, parentModel, ecModel);
    mergeAndNormalizeLayoutParams2(this, option, inputPositionParams);
  }
  mergeOption(option, ecModel) {
    super.mergeOption(option, ecModel);
    mergeAndNormalizeLayoutParams2(this, this.option, option);
  }
};
var ScrollableLegendModel = ScrollableLegendModel2;
ScrollableLegendModel.type = "legend.scroll";
ScrollableLegendModel.defaultOption = inheritDefaultOption(LegendModel_default.defaultOption, {
  scrollDataIndex: 0,
  pageButtonItemGap: 5,
  pageButtonGap: null,
  pageButtonPosition: "end",
  pageFormatter: "{current}/{total}",
  pageIcons: {
    horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
    vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
  },
  pageIconColor: "#2f4554",
  pageIconInactiveColor: "#aaa",
  pageIconSize: 15,
  pageTextStyle: {
    color: "#333"
  },
  animationDurationUpdate: 800
});
function mergeAndNormalizeLayoutParams2(legendModel, target, raw) {
  const orient = legendModel.getOrient();
  const ignoreSize = [1, 1];
  ignoreSize[orient.index] = 0;
  mergeLayoutParam(target, raw, {
    type: "box",
    ignoreSize: !!ignoreSize
  });
}
var ScrollableLegendModel_default = ScrollableLegendModel;

// src/component/legend/ScrollableLegendView.ts
var Group4 = Group_default;
var WH2 = ["width", "height"];
var XY2 = ["x", "y"];
var ScrollableLegendView2 = class extends LegendView_default {
  constructor() {
    super(...arguments);
    this.type = ScrollableLegendView2.type;
    this.newlineDisabled = true;
    this._currentIndex = 0;
  }
  init() {
    super.init();
    this.group.add(this._containerGroup = new Group4());
    this._containerGroup.add(this.getContentGroup());
    this.group.add(this._controllerGroup = new Group4());
  }
  resetInner() {
    super.resetInner();
    this._controllerGroup.removeAll();
    this._containerGroup.removeClipPath();
    this._containerGroup.__rectSize = null;
  }
  renderInner(itemAlign, legendModel, ecModel, api2, selector2, orient, selectorPosition) {
    const self2 = this;
    super.renderInner(itemAlign, legendModel, ecModel, api2, selector2, orient, selectorPosition);
    const controllerGroup = this._controllerGroup;
    const pageIconSize = legendModel.get("pageIconSize", true);
    const pageIconSizeArr = isArray(pageIconSize) ? pageIconSize : [pageIconSize, pageIconSize];
    createPageButton("pagePrev", 0);
    const pageTextStyleModel = legendModel.getModel("pageTextStyle");
    controllerGroup.add(new Text_default({
      name: "pageText",
      style: {
        text: "xx/xx",
        fill: pageTextStyleModel.getTextColor(),
        font: pageTextStyleModel.getFont(),
        verticalAlign: "middle",
        align: "center"
      },
      silent: true
    }));
    createPageButton("pageNext", 1);
    function createPageButton(name, iconIdx) {
      const pageDataIndexName = name + "DataIndex";
      const icon = createIcon(legendModel.get("pageIcons", true)[legendModel.getOrient().name][iconIdx], {
        onclick: bind(self2._pageGo, self2, pageDataIndexName, legendModel, api2)
      }, {
        x: -pageIconSizeArr[0] / 2,
        y: -pageIconSizeArr[1] / 2,
        width: pageIconSizeArr[0],
        height: pageIconSizeArr[1]
      });
      icon.name = name;
      controllerGroup.add(icon);
    }
  }
  layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector2, selectorPosition) {
    const selectorGroup = this.getSelectorGroup();
    const orientIdx = legendModel.getOrient().index;
    const wh = WH2[orientIdx];
    const xy = XY2[orientIdx];
    const hw = WH2[1 - orientIdx];
    const yx = XY2[1 - orientIdx];
    selector2 && box("horizontal", selectorGroup, legendModel.get("selectorItemGap", true));
    const selectorButtonGap = legendModel.get("selectorButtonGap", true);
    const selectorRect = selectorGroup.getBoundingRect();
    const selectorPos = [-selectorRect.x, -selectorRect.y];
    const processMaxSize = clone(maxSize);
    selector2 && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap);
    const mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx, xy);
    if (selector2) {
      if (selectorPosition === "end") {
        selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap;
      } else {
        const offset = selectorRect[wh] + selectorButtonGap;
        selectorPos[orientIdx] -= offset;
        mainRect[xy] -= offset;
      }
      mainRect[wh] += selectorRect[wh] + selectorButtonGap;
      selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2;
      mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw]);
      mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx]);
      selectorGroup.x = selectorPos[0];
      selectorGroup.y = selectorPos[1];
      selectorGroup.markRedraw();
    }
    return mainRect;
  }
  _layoutContentAndController(legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx, xy) {
    const contentGroup = this.getContentGroup();
    const containerGroup = this._containerGroup;
    const controllerGroup = this._controllerGroup;
    box(legendModel.get("orient"), contentGroup, legendModel.get("itemGap"), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height);
    box("horizontal", controllerGroup, legendModel.get("pageButtonItemGap", true));
    const contentRect = contentGroup.getBoundingRect();
    const controllerRect = controllerGroup.getBoundingRect();
    const showController = this._showController = contentRect[wh] > maxSize[wh];
    const contentPos = [-contentRect.x, -contentRect.y];
    if (!isFirstRender) {
      contentPos[orientIdx] = contentGroup[xy];
    }
    const containerPos = [0, 0];
    const controllerPos = [-controllerRect.x, -controllerRect.y];
    const pageButtonGap = retrieve2(legendModel.get("pageButtonGap", true), legendModel.get("itemGap", true));
    if (showController) {
      const pageButtonPosition = legendModel.get("pageButtonPosition", true);
      if (pageButtonPosition === "end") {
        controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh];
      } else {
        containerPos[orientIdx] += controllerRect[wh] + pageButtonGap;
      }
    }
    controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2;
    contentGroup.setPosition(contentPos);
    containerGroup.setPosition(containerPos);
    controllerGroup.setPosition(controllerPos);
    const mainRect = {x: 0, y: 0};
    mainRect[wh] = showController ? maxSize[wh] : contentRect[wh];
    mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]);
    mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx]);
    containerGroup.__rectSize = maxSize[wh];
    if (showController) {
      const clipShape = {x: 0, y: 0};
      clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0);
      clipShape[hw] = mainRect[hw];
      containerGroup.setClipPath(new Rect_default({shape: clipShape}));
      containerGroup.__rectSize = clipShape[wh];
    } else {
      controllerGroup.eachChild(function(child) {
        child.attr({
          invisible: true,
          silent: true
        });
      });
    }
    const pageInfo = this._getPageInfo(legendModel);
    pageInfo.pageIndex != null && updateProps(contentGroup, {x: pageInfo.contentPosition[0], y: pageInfo.contentPosition[1]}, showController ? legendModel : null);
    this._updatePageInfoView(legendModel, pageInfo);
    return mainRect;
  }
  _pageGo(to, legendModel, api2) {
    const scrollDataIndex = this._getPageInfo(legendModel)[to];
    scrollDataIndex != null && api2.dispatchAction({
      type: "legendScroll",
      scrollDataIndex,
      legendId: legendModel.id
    });
  }
  _updatePageInfoView(legendModel, pageInfo) {
    const controllerGroup = this._controllerGroup;
    each(["pagePrev", "pageNext"], function(name) {
      const key = name + "DataIndex";
      const canJump = pageInfo[key] != null;
      const icon = controllerGroup.childOfName(name);
      if (icon) {
        icon.setStyle("fill", canJump ? legendModel.get("pageIconColor", true) : legendModel.get("pageIconInactiveColor", true));
        icon.cursor = canJump ? "pointer" : "default";
      }
    });
    const pageText = controllerGroup.childOfName("pageText");
    const pageFormatter = legendModel.get("pageFormatter");
    const pageIndex = pageInfo.pageIndex;
    const current = pageIndex != null ? pageIndex + 1 : 0;
    const total = pageInfo.pageCount;
    pageText && pageFormatter && pageText.setStyle("text", isString(pageFormatter) ? pageFormatter.replace("{current}", current == null ? "" : current + "").replace("{total}", total == null ? "" : total + "") : pageFormatter({current, total}));
  }
  _getPageInfo(legendModel) {
    const scrollDataIndex = legendModel.get("scrollDataIndex", true);
    const contentGroup = this.getContentGroup();
    const containerRectSize = this._containerGroup.__rectSize;
    const orientIdx = legendModel.getOrient().index;
    const wh = WH2[orientIdx];
    const xy = XY2[orientIdx];
    const targetItemIndex = this._findTargetItemIndex(scrollDataIndex);
    const children = contentGroup.children();
    const targetItem = children[targetItemIndex];
    const itemCount = children.length;
    const pCount = !itemCount ? 0 : 1;
    const result = {
      contentPosition: [contentGroup.x, contentGroup.y],
      pageCount: pCount,
      pageIndex: pCount - 1,
      pagePrevDataIndex: null,
      pageNextDataIndex: null
    };
    if (!targetItem) {
      return result;
    }
    const targetItemInfo = getItemInfo(targetItem);
    result.contentPosition[orientIdx] = -targetItemInfo.s;
    for (let i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {
      currItemInfo = getItemInfo(children[i]);
      if (!currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || currItemInfo && !intersect2(currItemInfo, winStartItemInfo.s)) {
        if (winEndItemInfo.i > winStartItemInfo.i) {
          winStartItemInfo = winEndItemInfo;
        } else {
          winStartItemInfo = currItemInfo;
        }
        if (winStartItemInfo) {
          if (result.pageNextDataIndex == null) {
            result.pageNextDataIndex = winStartItemInfo.i;
          }
          ++result.pageCount;
        }
      }
      winEndItemInfo = currItemInfo;
    }
    for (let i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {
      currItemInfo = getItemInfo(children[i]);
      if ((!currItemInfo || !intersect2(winEndItemInfo, currItemInfo.s)) && winStartItemInfo.i < winEndItemInfo.i) {
        winEndItemInfo = winStartItemInfo;
        if (result.pagePrevDataIndex == null) {
          result.pagePrevDataIndex = winStartItemInfo.i;
        }
        ++result.pageCount;
        ++result.pageIndex;
      }
      winStartItemInfo = currItemInfo;
    }
    return result;
    function getItemInfo(el) {
      if (el) {
        const itemRect = el.getBoundingRect();
        const start2 = itemRect[xy] + el[xy];
        return {
          s: start2,
          e: start2 + itemRect[wh],
          i: el.__legendDataIndex
        };
      }
    }
    function intersect2(itemInfo, winStart) {
      return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize;
    }
  }
  _findTargetItemIndex(targetDataIndex) {
    if (!this._showController) {
      return 0;
    }
    let index;
    const contentGroup = this.getContentGroup();
    let defaultIndex;
    contentGroup.eachChild(function(child, idx) {
      const legendDataIdx = child.__legendDataIndex;
      if (defaultIndex == null && legendDataIdx != null) {
        defaultIndex = idx;
      }
      if (legendDataIdx === targetDataIndex) {
        index = idx;
      }
    });
    return index != null ? index : defaultIndex;
  }
};
var ScrollableLegendView = ScrollableLegendView2;
ScrollableLegendView.type = "legend.scroll";
var ScrollableLegendView_default = ScrollableLegendView;

// src/component/legend/scrollableLegendAction.ts
function installScrollableLegendAction(registers) {
  registers.registerAction("legendScroll", "legendscroll", function(payload, ecModel) {
    const scrollDataIndex = payload.scrollDataIndex;
    scrollDataIndex != null && ecModel.eachComponent({mainType: "legend", subType: "scroll", query: payload}, function(legendModel) {
      legendModel.setScrollDataIndex(scrollDataIndex);
    });
  });
}

// src/component/legend/installLegendScroll.ts
function install45(registers) {
  use(install44);
  registers.registerComponentModel(ScrollableLegendModel_default);
  registers.registerComponentView(ScrollableLegendView_default);
  installScrollableLegendAction(registers);
}

// src/component/legend/install.ts
function install46(registers) {
  use(install44);
  use(install45);
}

// src/component/dataZoom/InsideZoomModel.ts
var InsideZoomModel2 = class extends DataZoomModel_default {
  constructor() {
    super(...arguments);
    this.type = InsideZoomModel2.type;
  }
};
var InsideZoomModel = InsideZoomModel2;
InsideZoomModel.type = "dataZoom.inside";
InsideZoomModel.defaultOption = inheritDefaultOption(DataZoomModel_default.defaultOption, {
  disabled: false,
  zoomLock: false,
  zoomOnMouseWheel: true,
  moveOnMouseMove: true,
  moveOnMouseWheel: false,
  preventDefaultMouseMove: true
});
var InsideZoomModel_default = InsideZoomModel;

// src/component/dataZoom/roams.ts
var inner21 = makeInner();
function setViewInfoToCoordSysRecord(api2, dataZoomModel, getRange) {
  inner21(api2).coordSysRecordMap.each(function(coordSysRecord) {
    const dzInfo = coordSysRecord.dataZoomInfoMap.get(dataZoomModel.uid);
    if (dzInfo) {
      dzInfo.getRange = getRange;
    }
  });
}
function disposeCoordSysRecordIfNeeded(api2, dataZoomModel) {
  const coordSysRecordMap = inner21(api2).coordSysRecordMap;
  const coordSysKeyArr = coordSysRecordMap.keys();
  for (let i = 0; i < coordSysKeyArr.length; i++) {
    const coordSysKey = coordSysKeyArr[i];
    const coordSysRecord = coordSysRecordMap.get(coordSysKey);
    const dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;
    if (dataZoomInfoMap) {
      const dzUid = dataZoomModel.uid;
      const dzInfo = dataZoomInfoMap.get(dzUid);
      if (dzInfo) {
        dataZoomInfoMap.removeKey(dzUid);
        if (!dataZoomInfoMap.keys().length) {
          disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);
        }
      }
    }
  }
}
function disposeCoordSysRecord(coordSysRecordMap, coordSysRecord) {
  if (coordSysRecord) {
    coordSysRecordMap.removeKey(coordSysRecord.model.uid);
    const controller = coordSysRecord.controller;
    controller && controller.dispose();
  }
}
function createCoordSysRecord(api2, coordSysModel) {
  const coordSysRecord = {
    model: coordSysModel,
    containsPoint: curry(containsPoint, coordSysModel),
    dispatchAction: curry(dispatchAction2, api2),
    dataZoomInfoMap: null,
    controller: null
  };
  const controller = coordSysRecord.controller = new RoamController_default(api2.getZr());
  each(["pan", "zoom", "scrollMove"], function(eventName) {
    controller.on(eventName, function(event) {
      const batch = [];
      coordSysRecord.dataZoomInfoMap.each(function(dzInfo) {
        if (!event.isAvailableBehavior(dzInfo.model.option)) {
          return;
        }
        const method = (dzInfo.getRange || {})[eventName];
        const range = method && method(dzInfo.dzReferCoordSysInfo, coordSysRecord.model.mainType, coordSysRecord.controller, event);
        !dzInfo.model.get("disabled", true) && range && batch.push({
          dataZoomId: dzInfo.model.id,
          start: range[0],
          end: range[1]
        });
      });
      batch.length && coordSysRecord.dispatchAction(batch);
    });
  });
  return coordSysRecord;
}
function dispatchAction2(api2, batch) {
  if (!api2.isDisposed()) {
    api2.dispatchAction({
      type: "dataZoom",
      animation: {
        easing: "cubicOut",
        duration: 100
      },
      batch
    });
  }
}
function containsPoint(coordSysModel, e2, x, y) {
  return coordSysModel.coordinateSystem.containPoint([x, y]);
}
function mergeControllerParams(dataZoomInfoMap) {
  let controlType;
  const prefix = "type_";
  const typePriority = {
    type_true: 2,
    type_move: 1,
    type_false: 0,
    type_undefined: -1
  };
  let preventDefaultMouseMove = true;
  dataZoomInfoMap.each(function(dataZoomInfo) {
    const dataZoomModel = dataZoomInfo.model;
    const oneType = dataZoomModel.get("disabled", true) ? false : dataZoomModel.get("zoomLock", true) ? "move" : true;
    if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {
      controlType = oneType;
    }
    preventDefaultMouseMove = preventDefaultMouseMove && dataZoomModel.get("preventDefaultMouseMove", true);
  });
  return {
    controlType,
    opt: {
      zoomOnMouseWheel: true,
      moveOnMouseMove: true,
      moveOnMouseWheel: true,
      preventDefaultMouseMove: !!preventDefaultMouseMove
    }
  };
}
function installDataZoomRoamProcessor(registers) {
  registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, function(ecModel, api2) {
    const apiInner = inner21(api2);
    const coordSysRecordMap = apiInner.coordSysRecordMap || (apiInner.coordSysRecordMap = createHashMap());
    coordSysRecordMap.each(function(coordSysRecord) {
      coordSysRecord.dataZoomInfoMap = null;
    });
    ecModel.eachComponent({mainType: "dataZoom", subType: "inside"}, function(dataZoomModel) {
      const dzReferCoordSysWrap = collectReferCoordSysModelInfo(dataZoomModel);
      each(dzReferCoordSysWrap.infoList, function(dzCoordSysInfo) {
        const coordSysUid = dzCoordSysInfo.model.uid;
        const coordSysRecord = coordSysRecordMap.get(coordSysUid) || coordSysRecordMap.set(coordSysUid, createCoordSysRecord(api2, dzCoordSysInfo.model));
        const dataZoomInfoMap = coordSysRecord.dataZoomInfoMap || (coordSysRecord.dataZoomInfoMap = createHashMap());
        dataZoomInfoMap.set(dataZoomModel.uid, {
          dzReferCoordSysInfo: dzCoordSysInfo,
          model: dataZoomModel,
          getRange: null
        });
      });
    });
    coordSysRecordMap.each(function(coordSysRecord) {
      const controller = coordSysRecord.controller;
      let firstDzInfo;
      const dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;
      if (dataZoomInfoMap) {
        const firstDzKey = dataZoomInfoMap.keys()[0];
        if (firstDzKey != null) {
          firstDzInfo = dataZoomInfoMap.get(firstDzKey);
        }
      }
      if (!firstDzInfo) {
        disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);
        return;
      }
      const controllerParams = mergeControllerParams(dataZoomInfoMap);
      controller.enable(controllerParams.controlType, controllerParams.opt);
      controller.setPointerChecker(coordSysRecord.containsPoint);
      createOrUpdate(coordSysRecord, "dispatchAction", firstDzInfo.model.get("throttle", true), "fixRate");
    });
  });
}

// src/component/dataZoom/InsideZoomView.ts
var InsideZoomView = class extends DataZoomView_default {
  constructor() {
    super(...arguments);
    this.type = "dataZoom.inside";
  }
  render(dataZoomModel, ecModel, api2) {
    super.render.apply(this, arguments);
    if (dataZoomModel.noTarget()) {
      this._clear();
      return;
    }
    this.range = dataZoomModel.getPercentRange();
    setViewInfoToCoordSysRecord(api2, dataZoomModel, {
      pan: bind(getRangeHandlers.pan, this),
      zoom: bind(getRangeHandlers.zoom, this),
      scrollMove: bind(getRangeHandlers.scrollMove, this)
    });
  }
  dispose() {
    this._clear();
    super.dispose.apply(this, arguments);
  }
  _clear() {
    disposeCoordSysRecordIfNeeded(this.api, this.dataZoomModel);
    this.range = null;
  }
};
InsideZoomView.type = "dataZoom.inside";
var getRangeHandlers = {
  zoom(coordSysInfo, coordSysMainType, controller, e2) {
    const lastRange = this.range;
    const range = lastRange.slice();
    const axisModel = coordSysInfo.axisModels[0];
    if (!axisModel) {
      return;
    }
    const directionInfo = getDirectionInfo[coordSysMainType](null, [e2.originX, e2.originY], axisModel, controller, coordSysInfo);
    const percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];
    const scale4 = Math.max(1 / e2.scale, 0);
    range[0] = (range[0] - percentPoint) * scale4 + percentPoint;
    range[1] = (range[1] - percentPoint) * scale4 + percentPoint;
    const minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
    sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);
    this.range = range;
    if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
      return range;
    }
  },
  pan: makeMover(function(range, axisModel, coordSysInfo, coordSysMainType, controller, e2) {
    const directionInfo = getDirectionInfo[coordSysMainType]([e2.oldX, e2.oldY], [e2.newX, e2.newY], axisModel, controller, coordSysInfo);
    return directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;
  }),
  scrollMove: makeMover(function(range, axisModel, coordSysInfo, coordSysMainType, controller, e2) {
    const directionInfo = getDirectionInfo[coordSysMainType]([0, 0], [e2.scrollDelta, e2.scrollDelta], axisModel, controller, coordSysInfo);
    return directionInfo.signal * (range[1] - range[0]) * e2.scrollDelta;
  })
};
function makeMover(getPercentDelta) {
  return function(coordSysInfo, coordSysMainType, controller, e2) {
    const lastRange = this.range;
    const range = lastRange.slice();
    const axisModel = coordSysInfo.axisModels[0];
    if (!axisModel) {
      return;
    }
    const percentDelta = getPercentDelta(range, axisModel, coordSysInfo, coordSysMainType, controller, e2);
    sliderMove(percentDelta, range, [0, 100], "all");
    this.range = range;
    if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
      return range;
    }
  };
}
var getDirectionInfo = {
  grid(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
    const axis = axisModel.axis;
    const ret = {};
    const rect = coordSysInfo.model.coordinateSystem.getRect();
    oldPoint = oldPoint || [0, 0];
    if (axis.dim === "x") {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = rect.width;
      ret.pixelStart = rect.x;
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = rect.height;
      ret.pixelStart = rect.y;
      ret.signal = axis.inverse ? -1 : 1;
    }
    return ret;
  },
  polar(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
    const axis = axisModel.axis;
    const ret = {};
    const polar = coordSysInfo.model.coordinateSystem;
    const radiusExtent = polar.getRadiusAxis().getExtent();
    const angleExtent = polar.getAngleAxis().getExtent();
    oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];
    newPoint = polar.pointToCoord(newPoint);
    if (axisModel.mainType === "radiusAxis") {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = radiusExtent[1] - radiusExtent[0];
      ret.pixelStart = radiusExtent[0];
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = angleExtent[1] - angleExtent[0];
      ret.pixelStart = angleExtent[0];
      ret.signal = axis.inverse ? -1 : 1;
    }
    return ret;
  },
  singleAxis(oldPoint, newPoint, axisModel, controller, coordSysInfo) {
    const axis = axisModel.axis;
    const rect = coordSysInfo.model.coordinateSystem.getRect();
    const ret = {};
    oldPoint = oldPoint || [0, 0];
    if (axis.orient === "horizontal") {
      ret.pixel = newPoint[0] - oldPoint[0];
      ret.pixelLength = rect.width;
      ret.pixelStart = rect.x;
      ret.signal = axis.inverse ? 1 : -1;
    } else {
      ret.pixel = newPoint[1] - oldPoint[1];
      ret.pixelLength = rect.height;
      ret.pixelStart = rect.y;
      ret.signal = axis.inverse ? -1 : 1;
    }
    return ret;
  }
};
var InsideZoomView_default = InsideZoomView;

// src/component/dataZoom/installDataZoomInside.ts
function install47(registers) {
  installCommon(registers);
  registers.registerComponentModel(InsideZoomModel_default);
  registers.registerComponentView(InsideZoomView_default);
  installDataZoomRoamProcessor(registers);
}

// src/component/dataZoom/SliderZoomModel.ts
var SliderZoomModel2 = class extends DataZoomModel_default {
  constructor() {
    super(...arguments);
    this.type = SliderZoomModel2.type;
  }
};
var SliderZoomModel = SliderZoomModel2;
SliderZoomModel.type = "dataZoom.slider";
SliderZoomModel.layoutMode = "box";
SliderZoomModel.defaultOption = inheritDefaultOption(DataZoomModel_default.defaultOption, {
  show: true,
  right: "ph",
  top: "ph",
  width: "ph",
  height: "ph",
  left: null,
  bottom: null,
  borderColor: "#d2dbee",
  borderRadius: 3,
  backgroundColor: "rgba(47,69,84,0)",
  dataBackground: {
    lineStyle: {
      color: "#d2dbee",
      width: 0.5
    },
    areaStyle: {
      color: "#d2dbee",
      opacity: 0.2
    }
  },
  selectedDataBackground: {
    lineStyle: {
      color: "#8fb0f7",
      width: 0.5
    },
    areaStyle: {
      color: "#8fb0f7",
      opacity: 0.2
    }
  },
  fillerColor: "rgba(135,175,274,0.2)",
  handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
  handleSize: "100%",
  handleStyle: {
    color: "#fff",
    borderColor: "#ACB8D1"
  },
  moveHandleSize: 7,
  moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
  moveHandleStyle: {
    color: "#D2DBEE",
    opacity: 0.7
  },
  showDetail: true,
  showDataShadow: "auto",
  realtime: true,
  zoomLock: false,
  textStyle: {
    color: "#6E7079"
  },
  brushSelect: true,
  brushStyle: {
    color: "rgba(135,175,274,0.15)"
  },
  emphasis: {
    handleStyle: {
      borderColor: "#8FB0F7"
    },
    moveHandleStyle: {
      color: "#8FB0F7"
    }
  }
});
var SliderZoomModel_default = SliderZoomModel;

// src/component/dataZoom/SliderZoomView.ts
var Rect3 = Rect_default;
var DEFAULT_LOCATION_EDGE_GAP = 7;
var DEFAULT_FRAME_BORDER_WIDTH = 1;
var DEFAULT_FILLER_SIZE = 30;
var DEFAULT_MOVE_HANDLE_SIZE = 7;
var HORIZONTAL = "horizontal";
var VERTICAL = "vertical";
var LABEL_GAP = 5;
var SHOW_DATA_SHADOW_SERIES_TYPE = ["line", "bar", "candlestick", "scatter"];
var REALTIME_ANIMATION_CONFIG = {
  easing: "cubicOut",
  duration: 100,
  delay: 0
};
var SliderZoomView2 = class extends DataZoomView_default {
  constructor() {
    super(...arguments);
    this.type = SliderZoomView2.type;
    this._displayables = {};
  }
  init(ecModel, api2) {
    this.api = api2;
    this._onBrush = bind(this._onBrush, this);
    this._onBrushEnd = bind(this._onBrushEnd, this);
  }
  render(dataZoomModel, ecModel, api2, payload) {
    super.render.apply(this, arguments);
    createOrUpdate(this, "_dispatchZoomAction", dataZoomModel.get("throttle"), "fixRate");
    this._orient = dataZoomModel.getOrient();
    if (dataZoomModel.get("show") === false) {
      this.group.removeAll();
      return;
    }
    if (dataZoomModel.noTarget()) {
      this._clear();
      this.group.removeAll();
      return;
    }
    if (!payload || payload.type !== "dataZoom" || payload.from !== this.uid) {
      this._buildView();
    }
    this._updateView();
  }
  dispose() {
    this._clear();
    super.dispose.apply(this, arguments);
  }
  _clear() {
    clear(this, "_dispatchZoomAction");
    const zr = this.api.getZr();
    zr.off("mousemove", this._onBrush);
    zr.off("mouseup", this._onBrushEnd);
  }
  _buildView() {
    const thisGroup = this.group;
    thisGroup.removeAll();
    this._brushing = false;
    this._displayables.brushRect = null;
    this._resetLocation();
    this._resetInterval();
    const barGroup = this._displayables.sliderGroup = new Group_default();
    this._renderBackground();
    this._renderHandle();
    this._renderDataShadow();
    thisGroup.add(barGroup);
    this._positionGroup();
  }
  _resetLocation() {
    const dataZoomModel = this.dataZoomModel;
    const api2 = this.api;
    const showMoveHandle = dataZoomModel.get("brushSelect");
    const moveHandleSize = showMoveHandle ? DEFAULT_MOVE_HANDLE_SIZE : 0;
    const coordRect = this._findCoordRect();
    const ecSize = {width: api2.getWidth(), height: api2.getHeight()};
    const positionInfo = this._orient === HORIZONTAL ? {
      right: ecSize.width - coordRect.x - coordRect.width,
      top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP - moveHandleSize,
      width: coordRect.width,
      height: DEFAULT_FILLER_SIZE
    } : {
      right: DEFAULT_LOCATION_EDGE_GAP,
      top: coordRect.y,
      width: DEFAULT_FILLER_SIZE,
      height: coordRect.height
    };
    const layoutParams = getLayoutParams(dataZoomModel.option);
    each(["right", "top", "width", "height"], function(name) {
      if (layoutParams[name] === "ph") {
        layoutParams[name] = positionInfo[name];
      }
    });
    const layoutRect = getLayoutRect(layoutParams, ecSize);
    this._location = {x: layoutRect.x, y: layoutRect.y};
    this._size = [layoutRect.width, layoutRect.height];
    this._orient === VERTICAL && this._size.reverse();
  }
  _positionGroup() {
    const thisGroup = this.group;
    const location = this._location;
    const orient = this._orient;
    const targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();
    const inverse = targetAxisModel && targetAxisModel.get("inverse");
    const sliderGroup = this._displayables.sliderGroup;
    const otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse;
    sliderGroup.attr(orient === HORIZONTAL && !inverse ? {scaleY: otherAxisInverse ? 1 : -1, scaleX: 1} : orient === HORIZONTAL && inverse ? {scaleY: otherAxisInverse ? 1 : -1, scaleX: -1} : orient === VERTICAL && !inverse ? {scaleY: otherAxisInverse ? -1 : 1, scaleX: 1, rotation: Math.PI / 2} : {scaleY: otherAxisInverse ? -1 : 1, scaleX: -1, rotation: Math.PI / 2});
    const rect = thisGroup.getBoundingRect([sliderGroup]);
    thisGroup.x = location.x - rect.x;
    thisGroup.y = location.y - rect.y;
    thisGroup.markRedraw();
  }
  _getViewExtent() {
    return [0, this._size[0]];
  }
  _renderBackground() {
    const dataZoomModel = this.dataZoomModel;
    const size = this._size;
    const barGroup = this._displayables.sliderGroup;
    const brushSelect = dataZoomModel.get("brushSelect");
    barGroup.add(new Rect3({
      silent: true,
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1]
      },
      style: {
        fill: dataZoomModel.get("backgroundColor")
      },
      z2: -40
    }));
    const clickPanel = new Rect3({
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1]
      },
      style: {
        fill: "transparent"
      },
      z2: 0,
      onclick: bind(this._onClickPanel, this)
    });
    const zr = this.api.getZr();
    if (brushSelect) {
      clickPanel.on("mousedown", this._onBrushStart, this);
      clickPanel.cursor = "crosshair";
      zr.on("mousemove", this._onBrush);
      zr.on("mouseup", this._onBrushEnd);
    } else {
      zr.off("mousemove", this._onBrush);
      zr.off("mouseup", this._onBrushEnd);
    }
    barGroup.add(clickPanel);
  }
  _renderDataShadow() {
    const info = this._dataShadowInfo = this._prepareDataShadowInfo();
    this._displayables.dataShadowSegs = [];
    if (!info) {
      return;
    }
    const size = this._size;
    const oldSize = this._shadowSize || [];
    const seriesModel = info.series;
    const data = seriesModel.getRawData();
    const candlestickDim = seriesModel.getShadowDim && seriesModel.getShadowDim();
    const otherDim = candlestickDim && data.getDimensionInfo(candlestickDim) ? seriesModel.getShadowDim() : info.otherDim;
    if (otherDim == null) {
      return;
    }
    let polygonPts = this._shadowPolygonPts;
    let polylinePts = this._shadowPolylinePts;
    if (data !== this._shadowData || otherDim !== this._shadowDim || size[0] !== oldSize[0] || size[1] !== oldSize[1]) {
      let otherDataExtent = data.getDataExtent(otherDim);
      const otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;
      otherDataExtent = [
        otherDataExtent[0] - otherOffset,
        otherDataExtent[1] + otherOffset
      ];
      const otherShadowExtent = [0, size[1]];
      const thisShadowExtent = [0, size[0]];
      const areaPoints = [[size[0], 0], [0, 0]];
      const linePoints = [];
      const step = thisShadowExtent[1] / (data.count() - 1);
      let thisCoord = 0;
      const stride = Math.round(data.count() / size[0]);
      let lastIsEmpty;
      data.each([otherDim], function(value, index) {
        if (stride > 0 && index % stride) {
          thisCoord += step;
          return;
        }
        const isEmpty = value == null || isNaN(value) || value === "";
        const otherCoord = isEmpty ? 0 : linearMap(value, otherDataExtent, otherShadowExtent, true);
        if (isEmpty && !lastIsEmpty && index) {
          areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);
          linePoints.push([linePoints[linePoints.length - 1][0], 0]);
        } else if (!isEmpty && lastIsEmpty) {
          areaPoints.push([thisCoord, 0]);
          linePoints.push([thisCoord, 0]);
        }
        areaPoints.push([thisCoord, otherCoord]);
        linePoints.push([thisCoord, otherCoord]);
        thisCoord += step;
        lastIsEmpty = isEmpty;
      });
      polygonPts = this._shadowPolygonPts = areaPoints;
      polylinePts = this._shadowPolylinePts = linePoints;
    }
    this._shadowData = data;
    this._shadowDim = otherDim;
    this._shadowSize = [size[0], size[1]];
    const dataZoomModel = this.dataZoomModel;
    function createDataShadowGroup(isSelectedArea) {
      const model = dataZoomModel.getModel(isSelectedArea ? "selectedDataBackground" : "dataBackground");
      const group = new Group_default();
      const polygon = new Polygon_default({
        shape: {points: polygonPts},
        segmentIgnoreThreshold: 1,
        style: model.getModel("areaStyle").getAreaStyle(),
        silent: true,
        z2: -20
      });
      const polyline = new Polyline_default({
        shape: {points: polylinePts},
        segmentIgnoreThreshold: 1,
        style: model.getModel("lineStyle").getLineStyle(),
        silent: true,
        z2: -19
      });
      group.add(polygon);
      group.add(polyline);
      return group;
    }
    for (let i = 0; i < 3; i++) {
      const group = createDataShadowGroup(i === 1);
      this._displayables.sliderGroup.add(group);
      this._displayables.dataShadowSegs.push(group);
    }
  }
  _prepareDataShadowInfo() {
    const dataZoomModel = this.dataZoomModel;
    const showDataShadow = dataZoomModel.get("showDataShadow");
    if (showDataShadow === false) {
      return;
    }
    let result;
    const ecModel = this.ecModel;
    dataZoomModel.eachTargetAxis(function(axisDim, axisIndex) {
      const seriesModels = dataZoomModel.getAxisProxy(axisDim, axisIndex).getTargetSeriesModels();
      each(seriesModels, function(seriesModel) {
        if (result) {
          return;
        }
        if (showDataShadow !== true && indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get("type")) < 0) {
          return;
        }
        const thisAxis = ecModel.getComponent(getAxisMainType(axisDim), axisIndex).axis;
        let otherDim = getOtherDim(axisDim);
        let otherAxisInverse;
        const coordSys = seriesModel.coordinateSystem;
        if (otherDim != null && coordSys.getOtherAxis) {
          otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;
        }
        otherDim = seriesModel.getData().mapDimension(otherDim);
        result = {
          thisAxis,
          series: seriesModel,
          thisDim: axisDim,
          otherDim,
          otherAxisInverse
        };
      }, this);
    }, this);
    return result;
  }
  _renderHandle() {
    const thisGroup = this.group;
    const displayables = this._displayables;
    const handles = displayables.handles = [null, null];
    const handleLabels = displayables.handleLabels = [null, null];
    const sliderGroup = this._displayables.sliderGroup;
    const size = this._size;
    const dataZoomModel = this.dataZoomModel;
    const api2 = this.api;
    const borderRadius = dataZoomModel.get("borderRadius") || 0;
    const brushSelect = dataZoomModel.get("brushSelect");
    const filler = displayables.filler = new Rect3({
      silent: brushSelect,
      style: {
        fill: dataZoomModel.get("fillerColor")
      },
      textConfig: {
        position: "inside"
      }
    });
    sliderGroup.add(filler);
    sliderGroup.add(new Rect3({
      silent: true,
      subPixelOptimize: true,
      shape: {
        x: 0,
        y: 0,
        width: size[0],
        height: size[1],
        r: borderRadius
      },
      style: {
        stroke: dataZoomModel.get("dataBackgroundColor") || dataZoomModel.get("borderColor"),
        lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
        fill: "rgba(0,0,0,0)"
      }
    }));
    each([0, 1], function(handleIndex) {
      let iconStr = dataZoomModel.get("handleIcon");
      if (!symbolBuildProxies[iconStr] && iconStr.indexOf("path://") < 0 && iconStr.indexOf("image://") < 0) {
        iconStr = "path://" + iconStr;
        if (true) {
          deprecateLog("handleIcon now needs 'path://' prefix when using a path string");
        }
      }
      const path = createSymbol(iconStr, -1, 0, 2, 2, null, true);
      path.attr({
        cursor: getCursor(this._orient),
        draggable: true,
        drift: bind(this._onDragMove, this, handleIndex),
        ondragend: bind(this._onDragEnd, this),
        onmouseover: bind(this._showDataInfo, this, true),
        onmouseout: bind(this._showDataInfo, this, false),
        z2: 5
      });
      const bRect = path.getBoundingRect();
      const handleSize = dataZoomModel.get("handleSize");
      this._handleHeight = parsePercent2(handleSize, this._size[1]);
      this._handleWidth = bRect.width / bRect.height * this._handleHeight;
      path.setStyle(dataZoomModel.getModel("handleStyle").getItemStyle());
      path.style.strokeNoScale = true;
      path.rectHover = true;
      path.ensureState("emphasis").style = dataZoomModel.getModel(["emphasis", "handleStyle"]).getItemStyle();
      enableHoverEmphasis(path);
      const handleColor = dataZoomModel.get("handleColor");
      if (handleColor != null) {
        path.style.fill = handleColor;
      }
      sliderGroup.add(handles[handleIndex] = path);
      const textStyleModel = dataZoomModel.getModel("textStyle");
      thisGroup.add(handleLabels[handleIndex] = new Text_default({
        silent: true,
        invisible: true,
        style: createTextStyle(textStyleModel, {
          x: 0,
          y: 0,
          text: "",
          verticalAlign: "middle",
          align: "center",
          fill: textStyleModel.getTextColor(),
          font: textStyleModel.getFont()
        }),
        z2: 10
      }));
    }, this);
    let actualMoveZone = filler;
    if (brushSelect) {
      const moveHandleHeight = parsePercent2(dataZoomModel.get("moveHandleSize"), size[1]);
      const moveHandle = displayables.moveHandle = new Rect_default({
        style: dataZoomModel.getModel("moveHandleStyle").getItemStyle(),
        silent: true,
        shape: {
          r: [0, 0, 2, 2],
          y: size[1] - 0.5,
          height: moveHandleHeight
        }
      });
      const iconSize = moveHandleHeight * 0.8;
      const moveHandleIcon = displayables.moveHandleIcon = createSymbol(dataZoomModel.get("moveHandleIcon"), -iconSize / 2, -iconSize / 2, iconSize, iconSize, "#fff", true);
      moveHandleIcon.silent = true;
      moveHandleIcon.y = size[1] + moveHandleHeight / 2 - 0.5;
      moveHandle.ensureState("emphasis").style = dataZoomModel.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
      const moveZoneExpandSize = Math.min(size[1] / 2, Math.max(moveHandleHeight, 10));
      actualMoveZone = displayables.moveZone = new Rect_default({
        invisible: true,
        shape: {
          y: size[1] - moveZoneExpandSize,
          height: moveHandleHeight + moveZoneExpandSize
        }
      });
      actualMoveZone.on("mouseover", () => {
        api2.enterEmphasis(moveHandle);
      }).on("mouseout", () => {
        api2.leaveEmphasis(moveHandle);
      });
      sliderGroup.add(moveHandle);
      sliderGroup.add(moveHandleIcon);
      sliderGroup.add(actualMoveZone);
    }
    actualMoveZone.attr({
      draggable: true,
      cursor: getCursor(this._orient),
      drift: bind(this._onDragMove, this, "all"),
      ondragstart: bind(this._showDataInfo, this, true),
      ondragend: bind(this._onDragEnd, this),
      onmouseover: bind(this._showDataInfo, this, true),
      onmouseout: bind(this._showDataInfo, this, false)
    });
  }
  _resetInterval() {
    const range = this._range = this.dataZoomModel.getPercentRange();
    const viewExtent = this._getViewExtent();
    this._handleEnds = [
      linearMap(range[0], [0, 100], viewExtent, true),
      linearMap(range[1], [0, 100], viewExtent, true)
    ];
  }
  _updateInterval(handleIndex, delta) {
    const dataZoomModel = this.dataZoomModel;
    const handleEnds = this._handleEnds;
    const viewExtend = this._getViewExtent();
    const minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
    const percentExtent = [0, 100];
    sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get("zoomLock") ? "all" : handleIndex, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);
    const lastRange = this._range;
    const range = this._range = asc([
      linearMap(handleEnds[0], viewExtend, percentExtent, true),
      linearMap(handleEnds[1], viewExtend, percentExtent, true)
    ]);
    return !lastRange || lastRange[0] !== range[0] || lastRange[1] !== range[1];
  }
  _updateView(nonRealtime) {
    const displaybles = this._displayables;
    const handleEnds = this._handleEnds;
    const handleInterval = asc(handleEnds.slice());
    const size = this._size;
    each([0, 1], function(handleIndex) {
      const handle = displaybles.handles[handleIndex];
      const handleHeight = this._handleHeight;
      handle.attr({
        scaleX: handleHeight / 2,
        scaleY: handleHeight / 2,
        x: handleEnds[handleIndex] + (handleIndex ? -1 : 1),
        y: size[1] / 2 - handleHeight / 2
      });
    }, this);
    displaybles.filler.setShape({
      x: handleInterval[0],
      y: 0,
      width: handleInterval[1] - handleInterval[0],
      height: size[1]
    });
    const viewExtent = {
      x: handleInterval[0],
      width: handleInterval[1] - handleInterval[0]
    };
    if (displaybles.moveHandle) {
      displaybles.moveHandle.setShape(viewExtent);
      displaybles.moveZone.setShape(viewExtent);
      displaybles.moveZone.getBoundingRect();
      displaybles.moveHandleIcon && displaybles.moveHandleIcon.attr("x", viewExtent.x + viewExtent.width / 2);
    }
    const dataShadowSegs = displaybles.dataShadowSegs;
    const segIntervals = [0, handleInterval[0], handleInterval[1], size[0]];
    for (let i = 0; i < dataShadowSegs.length; i++) {
      const segGroup = dataShadowSegs[i];
      let clipPath = segGroup.getClipPath();
      if (!clipPath) {
        clipPath = new Rect_default();
        segGroup.setClipPath(clipPath);
      }
      clipPath.setShape({
        x: segIntervals[i],
        y: 0,
        width: segIntervals[i + 1] - segIntervals[i],
        height: size[1]
      });
    }
    this._updateDataInfo(nonRealtime);
  }
  _updateDataInfo(nonRealtime) {
    const dataZoomModel = this.dataZoomModel;
    const displaybles = this._displayables;
    const handleLabels = displaybles.handleLabels;
    const orient = this._orient;
    let labelTexts = ["", ""];
    if (dataZoomModel.get("showDetail")) {
      const axisProxy = dataZoomModel.findRepresentativeAxisProxy();
      if (axisProxy) {
        const axis = axisProxy.getAxisModel().axis;
        const range = this._range;
        const dataInterval = nonRealtime ? axisProxy.calculateDataWindow({
          start: range[0],
          end: range[1]
        }).valueWindow : axisProxy.getDataValueWindow();
        labelTexts = [
          this._formatLabel(dataInterval[0], axis),
          this._formatLabel(dataInterval[1], axis)
        ];
      }
    }
    const orderedHandleEnds = asc(this._handleEnds.slice());
    setLabel.call(this, 0);
    setLabel.call(this, 1);
    function setLabel(handleIndex) {
      const barTransform = getTransform(displaybles.handles[handleIndex].parent, this.group);
      const direction = transformDirection(handleIndex === 0 ? "right" : "left", barTransform);
      const offset = this._handleWidth / 2 + LABEL_GAP;
      const textPoint = applyTransform2([
        orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset),
        this._size[1] / 2
      ], barTransform);
      handleLabels[handleIndex].setStyle({
        x: textPoint[0],
        y: textPoint[1],
        verticalAlign: orient === HORIZONTAL ? "middle" : direction,
        align: orient === HORIZONTAL ? direction : "center",
        text: labelTexts[handleIndex]
      });
    }
  }
  _formatLabel(value, axis) {
    const dataZoomModel = this.dataZoomModel;
    const labelFormatter = dataZoomModel.get("labelFormatter");
    let labelPrecision = dataZoomModel.get("labelPrecision");
    if (labelPrecision == null || labelPrecision === "auto") {
      labelPrecision = axis.getPixelPrecision();
    }
    const valueStr = value == null || isNaN(value) ? "" : axis.type === "category" || axis.type === "time" ? axis.scale.getLabel({
      value: Math.round(value)
    }) : value.toFixed(Math.min(labelPrecision, 20));
    return isFunction(labelFormatter) ? labelFormatter(value, valueStr) : isString(labelFormatter) ? labelFormatter.replace("{value}", valueStr) : valueStr;
  }
  _showDataInfo(showOrHide) {
    showOrHide = this._dragging || showOrHide;
    const displayables = this._displayables;
    const handleLabels = displayables.handleLabels;
    handleLabels[0].attr("invisible", !showOrHide);
    handleLabels[1].attr("invisible", !showOrHide);
    displayables.moveHandle && this.api[showOrHide ? "enterEmphasis" : "leaveEmphasis"](displayables.moveHandle, 1);
  }
  _onDragMove(handleIndex, dx, dy, event) {
    this._dragging = true;
    stop(event.event);
    const barTransform = this._displayables.sliderGroup.getLocalTransform();
    const vertex = applyTransform2([dx, dy], barTransform, true);
    const changed = this._updateInterval(handleIndex, vertex[0]);
    const realtime = this.dataZoomModel.get("realtime");
    this._updateView(!realtime);
    changed && realtime && this._dispatchZoomAction(true);
  }
  _onDragEnd() {
    this._dragging = false;
    this._showDataInfo(false);
    const realtime = this.dataZoomModel.get("realtime");
    !realtime && this._dispatchZoomAction(false);
  }
  _onClickPanel(e2) {
    const size = this._size;
    const localPoint = this._displayables.sliderGroup.transformCoordToLocal(e2.offsetX, e2.offsetY);
    if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {
      return;
    }
    const handleEnds = this._handleEnds;
    const center3 = (handleEnds[0] + handleEnds[1]) / 2;
    const changed = this._updateInterval("all", localPoint[0] - center3);
    this._updateView();
    changed && this._dispatchZoomAction(false);
  }
  _onBrushStart(e2) {
    const x = e2.offsetX;
    const y = e2.offsetY;
    this._brushStart = new Point_default(x, y);
    this._brushing = true;
    this._brushStartTime = +new Date();
  }
  _onBrushEnd(e2) {
    if (!this._brushing) {
      return;
    }
    const brushRect = this._displayables.brushRect;
    this._brushing = false;
    if (!brushRect) {
      return;
    }
    brushRect.attr("ignore", true);
    const brushShape = brushRect.shape;
    const brushEndTime = +new Date();
    if (brushEndTime - this._brushStartTime < 200 && Math.abs(brushShape.width) < 5) {
      return;
    }
    const viewExtend = this._getViewExtent();
    const percentExtent = [0, 100];
    this._range = asc([
      linearMap(brushShape.x, viewExtend, percentExtent, true),
      linearMap(brushShape.x + brushShape.width, viewExtend, percentExtent, true)
    ]);
    this._handleEnds = [brushShape.x, brushShape.x + brushShape.width];
    this._updateView();
    this._dispatchZoomAction(false);
  }
  _onBrush(e2) {
    if (this._brushing) {
      stop(e2.event);
      this._updateBrushRect(e2.offsetX, e2.offsetY);
    }
  }
  _updateBrushRect(mouseX, mouseY) {
    const displayables = this._displayables;
    const dataZoomModel = this.dataZoomModel;
    let brushRect = displayables.brushRect;
    if (!brushRect) {
      brushRect = displayables.brushRect = new Rect3({
        silent: true,
        style: dataZoomModel.getModel("brushStyle").getItemStyle()
      });
      displayables.sliderGroup.add(brushRect);
    }
    brushRect.attr("ignore", false);
    const brushStart = this._brushStart;
    const sliderGroup = this._displayables.sliderGroup;
    const endPoint = sliderGroup.transformCoordToLocal(mouseX, mouseY);
    const startPoint = sliderGroup.transformCoordToLocal(brushStart.x, brushStart.y);
    const size = this._size;
    endPoint[0] = Math.max(Math.min(size[0], endPoint[0]), 0);
    brushRect.setShape({
      x: startPoint[0],
      y: 0,
      width: endPoint[0] - startPoint[0],
      height: size[1]
    });
  }
  _dispatchZoomAction(realtime) {
    const range = this._range;
    this.api.dispatchAction({
      type: "dataZoom",
      from: this.uid,
      dataZoomId: this.dataZoomModel.id,
      animation: realtime ? REALTIME_ANIMATION_CONFIG : null,
      start: range[0],
      end: range[1]
    });
  }
  _findCoordRect() {
    let rect;
    const coordSysInfoList = collectReferCoordSysModelInfo(this.dataZoomModel).infoList;
    if (!rect && coordSysInfoList.length) {
      const coordSys = coordSysInfoList[0].model.coordinateSystem;
      rect = coordSys.getRect && coordSys.getRect();
    }
    if (!rect) {
      const width = this.api.getWidth();
      const height = this.api.getHeight();
      rect = {
        x: width * 0.2,
        y: height * 0.2,
        width: width * 0.6,
        height: height * 0.6
      };
    }
    return rect;
  }
};
var SliderZoomView = SliderZoomView2;
SliderZoomView.type = "dataZoom.slider";
function getOtherDim(thisDim) {
  const map3 = {x: "y", y: "x", radius: "angle", angle: "radius"};
  return map3[thisDim];
}
function getCursor(orient) {
  return orient === "vertical" ? "ns-resize" : "ew-resize";
}
var SliderZoomView_default = SliderZoomView;

// src/component/dataZoom/installDataZoomSlider.ts
function install48(registers) {
  registers.registerComponentModel(SliderZoomModel_default);
  registers.registerComponentView(SliderZoomView_default);
  installCommon(registers);
}

// src/component/dataZoom/install.ts
function install49(registers) {
  use(install47);
  use(install48);
}

// src/visual/visualDefault.ts
var visualDefault = {
  get: function(visualType, key, isCategory2) {
    const value = clone((defaultOption2[visualType] || {})[key]);
    return isCategory2 ? isArray(value) ? value[value.length - 1] : value : value;
  }
};
var defaultOption2 = {
  color: {
    active: ["#006edd", "#e0ffff"],
    inactive: ["rgba(0,0,0,0)"]
  },
  colorHue: {
    active: [0, 360],
    inactive: [0, 0]
  },
  colorSaturation: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  colorLightness: {
    active: [0.9, 0.5],
    inactive: [0, 0]
  },
  colorAlpha: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  opacity: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  symbol: {
    active: ["circle", "roundRect", "diamond"],
    inactive: ["none"]
  },
  symbolSize: {
    active: [10, 50],
    inactive: [0, 0]
  }
};
var visualDefault_default = visualDefault;

// src/component/visualMap/VisualMapModel.ts
var mapVisual2 = VisualMapping_default.mapVisual;
var eachVisual = VisualMapping_default.eachVisual;
var isArray2 = isArray;
var each14 = each;
var asc3 = asc;
var linearMap2 = linearMap;
var VisualMapModel2 = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = VisualMapModel2.type;
    this.stateList = ["inRange", "outOfRange"];
    this.replacableOptionKeys = [
      "inRange",
      "outOfRange",
      "target",
      "controller",
      "color"
    ];
    this.layoutMode = {
      type: "box",
      ignoreSize: true
    };
    this.dataBound = [-Infinity, Infinity];
    this.targetVisuals = {};
    this.controllerVisuals = {};
  }
  init(option, parentModel, ecModel) {
    this.mergeDefaultAndTheme(option, ecModel);
  }
  optionUpdated(newOption, isInit) {
    const thisOption = this.option;
    !isInit && replaceVisualOption(thisOption, newOption, this.replacableOptionKeys);
    this.textStyleModel = this.getModel("textStyle");
    this.resetItemSize();
    this.completeVisualOption();
  }
  resetVisual(supplementVisualOption) {
    const stateList = this.stateList;
    supplementVisualOption = bind(supplementVisualOption, this);
    this.controllerVisuals = createVisualMappings(this.option.controller, stateList, supplementVisualOption);
    this.targetVisuals = createVisualMappings(this.option.target, stateList, supplementVisualOption);
  }
  getItemSymbol() {
    return null;
  }
  getTargetSeriesIndices() {
    const optionSeriesIndex = this.option.seriesIndex;
    let seriesIndices = [];
    if (optionSeriesIndex == null || optionSeriesIndex === "all") {
      this.ecModel.eachSeries(function(seriesModel, index) {
        seriesIndices.push(index);
      });
    } else {
      seriesIndices = normalizeToArray(optionSeriesIndex);
    }
    return seriesIndices;
  }
  eachTargetSeries(callback, context) {
    each(this.getTargetSeriesIndices(), function(seriesIndex) {
      const seriesModel = this.ecModel.getSeriesByIndex(seriesIndex);
      if (seriesModel) {
        callback.call(context, seriesModel);
      }
    }, this);
  }
  isTargetSeries(seriesModel) {
    let is = false;
    this.eachTargetSeries(function(model) {
      model === seriesModel && (is = true);
    });
    return is;
  }
  formatValueText(value, isCategory2, edgeSymbols) {
    const option = this.option;
    const precision = option.precision;
    const dataBound = this.dataBound;
    const formatter = option.formatter;
    let isMinMax;
    edgeSymbols = edgeSymbols || ["<", ">"];
    if (isArray(value)) {
      value = value.slice();
      isMinMax = true;
    }
    const textValue = isCategory2 ? value : isMinMax ? [toFixed(value[0]), toFixed(value[1])] : toFixed(value);
    if (isString(formatter)) {
      return formatter.replace("{value}", isMinMax ? textValue[0] : textValue).replace("{value2}", isMinMax ? textValue[1] : textValue);
    } else if (isFunction(formatter)) {
      return isMinMax ? formatter(value[0], value[1]) : formatter(value);
    }
    if (isMinMax) {
      if (value[0] === dataBound[0]) {
        return edgeSymbols[0] + " " + textValue[1];
      } else if (value[1] === dataBound[1]) {
        return edgeSymbols[1] + " " + textValue[0];
      } else {
        return textValue[0] + " - " + textValue[1];
      }
    } else {
      return textValue;
    }
    function toFixed(val) {
      return val === dataBound[0] ? "min" : val === dataBound[1] ? "max" : (+val).toFixed(Math.min(precision, 20));
    }
  }
  resetExtent() {
    const thisOption = this.option;
    const extent3 = asc3([thisOption.min, thisOption.max]);
    this._dataExtent = extent3;
  }
  getDataDimensionIndex(data) {
    const optDim = this.option.dimension;
    if (optDim != null) {
      return data.getDimensionIndex(optDim);
    }
    const dimNames = data.dimensions;
    for (let i = dimNames.length - 1; i >= 0; i--) {
      const dimName = dimNames[i];
      const dimInfo = data.getDimensionInfo(dimName);
      if (!dimInfo.isCalculationCoord) {
        return dimInfo.storeDimIndex;
      }
    }
  }
  getExtent() {
    return this._dataExtent.slice();
  }
  completeVisualOption() {
    const ecModel = this.ecModel;
    const thisOption = this.option;
    const base2 = {
      inRange: thisOption.inRange,
      outOfRange: thisOption.outOfRange
    };
    const target = thisOption.target || (thisOption.target = {});
    const controller = thisOption.controller || (thisOption.controller = {});
    merge(target, base2);
    merge(controller, base2);
    const isCategory2 = this.isCategory();
    completeSingle.call(this, target);
    completeSingle.call(this, controller);
    completeInactive.call(this, target, "inRange", "outOfRange");
    completeController.call(this, controller);
    function completeSingle(base3) {
      if (isArray2(thisOption.color) && !base3.inRange) {
        base3.inRange = {color: thisOption.color.slice().reverse()};
      }
      base3.inRange = base3.inRange || {color: ecModel.get("gradientColor")};
    }
    function completeInactive(base3, stateExist, stateAbsent) {
      const optExist = base3[stateExist];
      let optAbsent = base3[stateAbsent];
      if (optExist && !optAbsent) {
        optAbsent = base3[stateAbsent] = {};
        each14(optExist, function(visualData, visualType) {
          if (!VisualMapping_default.isValidType(visualType)) {
            return;
          }
          const defa = visualDefault_default.get(visualType, "inactive", isCategory2);
          if (defa != null) {
            optAbsent[visualType] = defa;
            if (visualType === "color" && !optAbsent.hasOwnProperty("opacity") && !optAbsent.hasOwnProperty("colorAlpha")) {
              optAbsent.opacity = [0, 0];
            }
          }
        });
      }
    }
    function completeController(controller2) {
      const symbolExists = (controller2.inRange || {}).symbol || (controller2.outOfRange || {}).symbol;
      const symbolSizeExists = (controller2.inRange || {}).symbolSize || (controller2.outOfRange || {}).symbolSize;
      const inactiveColor = this.get("inactiveColor");
      const itemSymbol = this.getItemSymbol();
      const defaultSymbol = itemSymbol || "roundRect";
      each14(this.stateList, function(state) {
        const itemSize = this.itemSize;
        let visuals = controller2[state];
        if (!visuals) {
          visuals = controller2[state] = {
            color: isCategory2 ? inactiveColor : [inactiveColor]
          };
        }
        if (visuals.symbol == null) {
          visuals.symbol = symbolExists && clone(symbolExists) || (isCategory2 ? defaultSymbol : [defaultSymbol]);
        }
        if (visuals.symbolSize == null) {
          visuals.symbolSize = symbolSizeExists && clone(symbolSizeExists) || (isCategory2 ? itemSize[0] : [itemSize[0], itemSize[0]]);
        }
        visuals.symbol = mapVisual2(visuals.symbol, function(symbol) {
          return symbol === "none" ? defaultSymbol : symbol;
        });
        const symbolSize = visuals.symbolSize;
        if (symbolSize != null) {
          let max3 = -Infinity;
          eachVisual(symbolSize, function(value) {
            value > max3 && (max3 = value);
          });
          visuals.symbolSize = mapVisual2(symbolSize, function(value) {
            return linearMap2(value, [0, max3], [0, itemSize[0]], true);
          });
        }
      }, this);
    }
  }
  resetItemSize() {
    this.itemSize = [
      parseFloat(this.get("itemWidth")),
      parseFloat(this.get("itemHeight"))
    ];
  }
  isCategory() {
    return !!this.option.categories;
  }
  setSelected(selected) {
  }
  getSelected() {
    return null;
  }
  getValueState(value) {
    return null;
  }
  getVisualMeta(getColorVisual2) {
    return null;
  }
};
var VisualMapModel = VisualMapModel2;
VisualMapModel.type = "visualMap";
VisualMapModel.dependencies = ["series"];
VisualMapModel.defaultOption = {
  show: true,
  z: 4,
  seriesIndex: "all",
  min: 0,
  max: 200,
  left: 0,
  right: null,
  top: null,
  bottom: 0,
  itemWidth: null,
  itemHeight: null,
  inverse: false,
  orient: "vertical",
  backgroundColor: "rgba(0,0,0,0)",
  borderColor: "#ccc",
  contentColor: "#5793f3",
  inactiveColor: "#aaa",
  borderWidth: 0,
  padding: 5,
  textGap: 10,
  precision: 0,
  textStyle: {
    color: "#333"
  }
};
var VisualMapModel_default = VisualMapModel;

// src/component/visualMap/ContinuousModel.ts
var DEFAULT_BAR_BOUND = [20, 140];
var ContinuousModel2 = class extends VisualMapModel_default {
  constructor() {
    super(...arguments);
    this.type = ContinuousModel2.type;
  }
  optionUpdated(newOption, isInit) {
    super.optionUpdated.apply(this, arguments);
    this.resetExtent();
    this.resetVisual(function(mappingOption) {
      mappingOption.mappingMethod = "linear";
      mappingOption.dataExtent = this.getExtent();
    });
    this._resetRange();
  }
  resetItemSize() {
    super.resetItemSize.apply(this, arguments);
    const itemSize = this.itemSize;
    (itemSize[0] == null || isNaN(itemSize[0])) && (itemSize[0] = DEFAULT_BAR_BOUND[0]);
    (itemSize[1] == null || isNaN(itemSize[1])) && (itemSize[1] = DEFAULT_BAR_BOUND[1]);
  }
  _resetRange() {
    const dataExtent = this.getExtent();
    const range = this.option.range;
    if (!range || range.auto) {
      dataExtent.auto = 1;
      this.option.range = dataExtent;
    } else if (isArray(range)) {
      if (range[0] > range[1]) {
        range.reverse();
      }
      range[0] = Math.max(range[0], dataExtent[0]);
      range[1] = Math.min(range[1], dataExtent[1]);
    }
  }
  completeVisualOption() {
    super.completeVisualOption.apply(this, arguments);
    each(this.stateList, function(state) {
      const symbolSize = this.option.controller[state].symbolSize;
      if (symbolSize && symbolSize[0] !== symbolSize[1]) {
        symbolSize[0] = symbolSize[1] / 3;
      }
    }, this);
  }
  setSelected(selected) {
    this.option.range = selected.slice();
    this._resetRange();
  }
  getSelected() {
    const dataExtent = this.getExtent();
    const dataInterval = asc((this.get("range") || []).slice());
    dataInterval[0] > dataExtent[1] && (dataInterval[0] = dataExtent[1]);
    dataInterval[1] > dataExtent[1] && (dataInterval[1] = dataExtent[1]);
    dataInterval[0] < dataExtent[0] && (dataInterval[0] = dataExtent[0]);
    dataInterval[1] < dataExtent[0] && (dataInterval[1] = dataExtent[0]);
    return dataInterval;
  }
  getValueState(value) {
    const range = this.option.range;
    const dataExtent = this.getExtent();
    return (range[0] <= dataExtent[0] || range[0] <= value) && (range[1] >= dataExtent[1] || value <= range[1]) ? "inRange" : "outOfRange";
  }
  findTargetDataIndices(range) {
    const result = [];
    this.eachTargetSeries(function(seriesModel) {
      const dataIndices = [];
      const data = seriesModel.getData();
      data.each(this.getDataDimensionIndex(data), function(value, dataIndex) {
        range[0] <= value && value <= range[1] && dataIndices.push(dataIndex);
      }, this);
      result.push({
        seriesId: seriesModel.id,
        dataIndex: dataIndices
      });
    }, this);
    return result;
  }
  getVisualMeta(getColorVisual2) {
    const oVals = getColorStopValues(this, "outOfRange", this.getExtent());
    const iVals = getColorStopValues(this, "inRange", this.option.range.slice());
    const stops = [];
    function setStop(value, valueState) {
      stops.push({
        value,
        color: getColorVisual2(value, valueState)
      });
    }
    let iIdx = 0;
    let oIdx = 0;
    const iLen = iVals.length;
    const oLen = oVals.length;
    for (; oIdx < oLen && (!iVals.length || oVals[oIdx] <= iVals[0]); oIdx++) {
      if (oVals[oIdx] < iVals[iIdx]) {
        setStop(oVals[oIdx], "outOfRange");
      }
    }
    for (let first = 1; iIdx < iLen; iIdx++, first = 0) {
      first && stops.length && setStop(iVals[iIdx], "outOfRange");
      setStop(iVals[iIdx], "inRange");
    }
    for (let first = 1; oIdx < oLen; oIdx++) {
      if (!iVals.length || iVals[iVals.length - 1] < oVals[oIdx]) {
        if (first) {
          stops.length && setStop(stops[stops.length - 1].value, "outOfRange");
          first = 0;
        }
        setStop(oVals[oIdx], "outOfRange");
      }
    }
    const stopsLen = stops.length;
    return {
      stops,
      outerColors: [
        stopsLen ? stops[0].color : "transparent",
        stopsLen ? stops[stopsLen - 1].color : "transparent"
      ]
    };
  }
};
var ContinuousModel = ContinuousModel2;
ContinuousModel.type = "visualMap.continuous";
ContinuousModel.defaultOption = inheritDefaultOption(VisualMapModel_default.defaultOption, {
  align: "auto",
  calculable: false,
  hoverLink: true,
  realtime: true,
  handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
  handleSize: "120%",
  handleStyle: {
    borderColor: "#fff",
    borderWidth: 1
  },
  indicatorIcon: "circle",
  indicatorSize: "50%",
  indicatorStyle: {
    borderColor: "#fff",
    borderWidth: 2,
    shadowBlur: 2,
    shadowOffsetX: 1,
    shadowOffsetY: 1,
    shadowColor: "rgba(0,0,0,0.2)"
  }
});
function getColorStopValues(visualMapModel, valueState, dataExtent) {
  if (dataExtent[0] === dataExtent[1]) {
    return dataExtent.slice();
  }
  const count2 = 200;
  const step = (dataExtent[1] - dataExtent[0]) / count2;
  let value = dataExtent[0];
  const stopValues = [];
  for (let i = 0; i <= count2 && value < dataExtent[1]; i++) {
    stopValues.push(value);
    value += step;
  }
  stopValues.push(dataExtent[1]);
  return stopValues;
}
var ContinuousModel_default = ContinuousModel;

// src/component/visualMap/VisualMapView.ts
var VisualMapView2 = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = VisualMapView2.type;
    this.autoPositionValues = {left: 1, right: 1, top: 1, bottom: 1};
  }
  init(ecModel, api2) {
    this.ecModel = ecModel;
    this.api = api2;
  }
  render(visualMapModel, ecModel, api2, payload) {
    this.visualMapModel = visualMapModel;
    if (visualMapModel.get("show") === false) {
      this.group.removeAll();
      return;
    }
    this.doRender(visualMapModel, ecModel, api2, payload);
  }
  renderBackground(group) {
    const visualMapModel = this.visualMapModel;
    const padding = normalizeCssArray2(visualMapModel.get("padding") || 0);
    const rect = group.getBoundingRect();
    group.add(new Rect_default({
      z2: -1,
      silent: true,
      shape: {
        x: rect.x - padding[3],
        y: rect.y - padding[0],
        width: rect.width + padding[3] + padding[1],
        height: rect.height + padding[0] + padding[2]
      },
      style: {
        fill: visualMapModel.get("backgroundColor"),
        stroke: visualMapModel.get("borderColor"),
        lineWidth: visualMapModel.get("borderWidth")
      }
    }));
  }
  getControllerVisual(targetValue, visualCluster, opts) {
    opts = opts || {};
    const forceState = opts.forceState;
    const visualMapModel = this.visualMapModel;
    const visualObj = {};
    if (visualCluster === "color") {
      const defaultColor = visualMapModel.get("contentColor");
      visualObj.color = defaultColor;
    }
    function getter(key) {
      return visualObj[key];
    }
    function setter(key, value) {
      visualObj[key] = value;
    }
    const mappings = visualMapModel.controllerVisuals[forceState || visualMapModel.getValueState(targetValue)];
    const visualTypes = VisualMapping_default.prepareVisualTypes(mappings);
    each(visualTypes, function(type) {
      let visualMapping = mappings[type];
      if (opts.convertOpacityToAlpha && type === "opacity") {
        type = "colorAlpha";
        visualMapping = mappings.__alphaForOpacity;
      }
      if (VisualMapping_default.dependsOn(type, visualCluster)) {
        visualMapping && visualMapping.applyVisual(targetValue, getter, setter);
      }
    });
    return visualObj[visualCluster];
  }
  positionGroup(group) {
    const model = this.visualMapModel;
    const api2 = this.api;
    positionElement(group, model.getBoxLayoutParams(), {width: api2.getWidth(), height: api2.getHeight()});
  }
  doRender(visualMapModel, ecModel, api2, payload) {
  }
};
var VisualMapView = VisualMapView2;
VisualMapView.type = "visualMap";
var VisualMapView_default = VisualMapView;

// src/component/visualMap/helper.ts
var paramsSet = [
  ["left", "right", "width"],
  ["top", "bottom", "height"]
];
function getItemAlign(visualMapModel, api2, itemSize) {
  const modelOption = visualMapModel.option;
  const itemAlign = modelOption.align;
  if (itemAlign != null && itemAlign !== "auto") {
    return itemAlign;
  }
  const ecSize = {width: api2.getWidth(), height: api2.getHeight()};
  const realIndex = modelOption.orient === "horizontal" ? 1 : 0;
  const reals = paramsSet[realIndex];
  const fakeValue = [0, null, 10];
  const layoutInput = {};
  for (let i = 0; i < 3; i++) {
    layoutInput[paramsSet[1 - realIndex][i]] = fakeValue[i];
    layoutInput[reals[i]] = i === 2 ? itemSize[0] : modelOption[reals[i]];
  }
  const rParam = [["x", "width", 3], ["y", "height", 0]][realIndex];
  const rect = getLayoutRect(layoutInput, ecSize, modelOption.padding);
  return reals[(rect.margin[rParam[2]] || 0) + rect[rParam[0]] + rect[rParam[1]] * 0.5 < ecSize[rParam[1]] * 0.5 ? 0 : 1];
}
function makeHighDownBatch(batch, visualMapModel) {
  each(batch || [], function(batchItem) {
    if (batchItem.dataIndex != null) {
      batchItem.dataIndexInside = batchItem.dataIndex;
      batchItem.dataIndex = null;
    }
    batchItem.highlightKey = "visualMap" + (visualMapModel ? visualMapModel.componentIndex : "");
  });
  return batch;
}

// src/component/visualMap/ContinuousView.ts
var linearMap3 = linearMap;
var each15 = each;
var mathMin11 = Math.min;
var mathMax11 = Math.max;
var HOVER_LINK_SIZE = 12;
var HOVER_LINK_OUT = 6;
var ContinuousView2 = class extends VisualMapView_default {
  constructor() {
    super(...arguments);
    this.type = ContinuousView2.type;
    this._shapes = {};
    this._dataInterval = [];
    this._handleEnds = [];
    this._hoverLinkDataIndices = [];
  }
  init(ecModel, api2) {
    super.init(ecModel, api2);
    this._hoverLinkFromSeriesMouseOver = bind(this._hoverLinkFromSeriesMouseOver, this);
    this._hideIndicator = bind(this._hideIndicator, this);
  }
  doRender(visualMapModel, ecModel, api2, payload) {
    if (!payload || payload.type !== "selectDataRange" || payload.from !== this.uid) {
      this._buildView();
    }
  }
  _buildView() {
    this.group.removeAll();
    const visualMapModel = this.visualMapModel;
    const thisGroup = this.group;
    this._orient = visualMapModel.get("orient");
    this._useHandle = visualMapModel.get("calculable");
    this._resetInterval();
    this._renderBar(thisGroup);
    const dataRangeText = visualMapModel.get("text");
    this._renderEndsText(thisGroup, dataRangeText, 0);
    this._renderEndsText(thisGroup, dataRangeText, 1);
    this._updateView(true);
    this.renderBackground(thisGroup);
    this._updateView();
    this._enableHoverLinkToSeries();
    this._enableHoverLinkFromSeries();
    this.positionGroup(thisGroup);
  }
  _renderEndsText(group, dataRangeText, endsIndex) {
    if (!dataRangeText) {
      return;
    }
    let text = dataRangeText[1 - endsIndex];
    text = text != null ? text + "" : "";
    const visualMapModel = this.visualMapModel;
    const textGap = visualMapModel.get("textGap");
    const itemSize = visualMapModel.itemSize;
    const barGroup = this._shapes.mainGroup;
    const position2 = this._applyTransform([
      itemSize[0] / 2,
      endsIndex === 0 ? -textGap : itemSize[1] + textGap
    ], barGroup);
    const align = this._applyTransform(endsIndex === 0 ? "bottom" : "top", barGroup);
    const orient = this._orient;
    const textStyleModel = this.visualMapModel.textStyleModel;
    this.group.add(new Text_default({
      style: createTextStyle(textStyleModel, {
        x: position2[0],
        y: position2[1],
        verticalAlign: orient === "horizontal" ? "middle" : align,
        align: orient === "horizontal" ? align : "center",
        text
      })
    }));
  }
  _renderBar(targetGroup) {
    const visualMapModel = this.visualMapModel;
    const shapes = this._shapes;
    const itemSize = visualMapModel.itemSize;
    const orient = this._orient;
    const useHandle = this._useHandle;
    const itemAlign = getItemAlign(visualMapModel, this.api, itemSize);
    const mainGroup = shapes.mainGroup = this._createBarGroup(itemAlign);
    const gradientBarGroup = new Group_default();
    mainGroup.add(gradientBarGroup);
    gradientBarGroup.add(shapes.outOfRange = createPolygon());
    gradientBarGroup.add(shapes.inRange = createPolygon(null, useHandle ? getCursor2(this._orient) : null, bind(this._dragHandle, this, "all", false), bind(this._dragHandle, this, "all", true)));
    gradientBarGroup.setClipPath(new Rect_default({
      shape: {
        x: 0,
        y: 0,
        width: itemSize[0],
        height: itemSize[1],
        r: 3
      }
    }));
    const textRect = visualMapModel.textStyleModel.getTextRect("\u56FD");
    const textSize = mathMax11(textRect.width, textRect.height);
    if (useHandle) {
      shapes.handleThumbs = [];
      shapes.handleLabels = [];
      shapes.handleLabelPoints = [];
      this._createHandle(visualMapModel, mainGroup, 0, itemSize, textSize, orient);
      this._createHandle(visualMapModel, mainGroup, 1, itemSize, textSize, orient);
    }
    this._createIndicator(visualMapModel, mainGroup, itemSize, textSize, orient);
    targetGroup.add(mainGroup);
  }
  _createHandle(visualMapModel, mainGroup, handleIndex, itemSize, textSize, orient) {
    const onDrift = bind(this._dragHandle, this, handleIndex, false);
    const onDragEnd = bind(this._dragHandle, this, handleIndex, true);
    const handleSize = parsePercent(visualMapModel.get("handleSize"), itemSize[0]);
    const handleThumb = createSymbol(visualMapModel.get("handleIcon"), -handleSize / 2, -handleSize / 2, handleSize, handleSize, null, true);
    const cursor = getCursor2(this._orient);
    handleThumb.attr({
      cursor,
      draggable: true,
      drift: onDrift,
      ondragend: onDragEnd,
      onmousemove(e2) {
        stop(e2.event);
      }
    });
    handleThumb.x = itemSize[0] / 2;
    handleThumb.useStyle(visualMapModel.getModel("handleStyle").getItemStyle());
    handleThumb.setStyle({
      strokeNoScale: true,
      strokeFirst: true
    });
    handleThumb.style.lineWidth *= 2;
    handleThumb.ensureState("emphasis").style = visualMapModel.getModel(["emphasis", "handleStyle"]).getItemStyle();
    setAsHighDownDispatcher(handleThumb, true);
    mainGroup.add(handleThumb);
    const textStyleModel = this.visualMapModel.textStyleModel;
    const handleLabel = new Text_default({
      cursor,
      draggable: true,
      drift: onDrift,
      onmousemove(e2) {
        stop(e2.event);
      },
      ondragend: onDragEnd,
      style: createTextStyle(textStyleModel, {
        x: 0,
        y: 0,
        text: ""
      })
    });
    handleLabel.ensureState("blur").style = {
      opacity: 0.1
    };
    handleLabel.stateTransition = {duration: 200};
    this.group.add(handleLabel);
    const handleLabelPoint = [handleSize, 0];
    const shapes = this._shapes;
    shapes.handleThumbs[handleIndex] = handleThumb;
    shapes.handleLabelPoints[handleIndex] = handleLabelPoint;
    shapes.handleLabels[handleIndex] = handleLabel;
  }
  _createIndicator(visualMapModel, mainGroup, itemSize, textSize, orient) {
    const scale4 = parsePercent(visualMapModel.get("indicatorSize"), itemSize[0]);
    const indicator = createSymbol(visualMapModel.get("indicatorIcon"), -scale4 / 2, -scale4 / 2, scale4, scale4, null, true);
    indicator.attr({
      cursor: "move",
      invisible: true,
      silent: true,
      x: itemSize[0] / 2
    });
    const indicatorStyle = visualMapModel.getModel("indicatorStyle").getItemStyle();
    if (indicator instanceof Image_default) {
      const pathStyle = indicator.style;
      indicator.useStyle(extend({
        image: pathStyle.image,
        x: pathStyle.x,
        y: pathStyle.y,
        width: pathStyle.width,
        height: pathStyle.height
      }, indicatorStyle));
    } else {
      indicator.useStyle(indicatorStyle);
    }
    mainGroup.add(indicator);
    const textStyleModel = this.visualMapModel.textStyleModel;
    const indicatorLabel = new Text_default({
      silent: true,
      invisible: true,
      style: createTextStyle(textStyleModel, {
        x: 0,
        y: 0,
        text: ""
      })
    });
    this.group.add(indicatorLabel);
    const indicatorLabelPoint = [
      (orient === "horizontal" ? textSize / 2 : HOVER_LINK_OUT) + itemSize[0] / 2,
      0
    ];
    const shapes = this._shapes;
    shapes.indicator = indicator;
    shapes.indicatorLabel = indicatorLabel;
    shapes.indicatorLabelPoint = indicatorLabelPoint;
    this._firstShowIndicator = true;
  }
  _dragHandle(handleIndex, isEnd, dx, dy) {
    if (!this._useHandle) {
      return;
    }
    this._dragging = !isEnd;
    if (!isEnd) {
      const vertex = this._applyTransform([dx, dy], this._shapes.mainGroup, true);
      this._updateInterval(handleIndex, vertex[1]);
      this._hideIndicator();
      this._updateView();
    }
    if (isEnd === !this.visualMapModel.get("realtime")) {
      this.api.dispatchAction({
        type: "selectDataRange",
        from: this.uid,
        visualMapId: this.visualMapModel.id,
        selected: this._dataInterval.slice()
      });
    }
    if (isEnd) {
      !this._hovering && this._clearHoverLinkToSeries();
    } else if (useHoverLinkOnHandle(this.visualMapModel)) {
      this._doHoverLinkToSeries(this._handleEnds[handleIndex], false);
    }
  }
  _resetInterval() {
    const visualMapModel = this.visualMapModel;
    const dataInterval = this._dataInterval = visualMapModel.getSelected();
    const dataExtent = visualMapModel.getExtent();
    const sizeExtent = [0, visualMapModel.itemSize[1]];
    this._handleEnds = [
      linearMap3(dataInterval[0], dataExtent, sizeExtent, true),
      linearMap3(dataInterval[1], dataExtent, sizeExtent, true)
    ];
  }
  _updateInterval(handleIndex, delta) {
    delta = delta || 0;
    const visualMapModel = this.visualMapModel;
    const handleEnds = this._handleEnds;
    const sizeExtent = [0, visualMapModel.itemSize[1]];
    sliderMove(delta, handleEnds, sizeExtent, handleIndex, 0);
    const dataExtent = visualMapModel.getExtent();
    this._dataInterval = [
      linearMap3(handleEnds[0], sizeExtent, dataExtent, true),
      linearMap3(handleEnds[1], sizeExtent, dataExtent, true)
    ];
  }
  _updateView(forSketch) {
    const visualMapModel = this.visualMapModel;
    const dataExtent = visualMapModel.getExtent();
    const shapes = this._shapes;
    const outOfRangeHandleEnds = [0, visualMapModel.itemSize[1]];
    const inRangeHandleEnds = forSketch ? outOfRangeHandleEnds : this._handleEnds;
    const visualInRange = this._createBarVisual(this._dataInterval, dataExtent, inRangeHandleEnds, "inRange");
    const visualOutOfRange = this._createBarVisual(dataExtent, dataExtent, outOfRangeHandleEnds, "outOfRange");
    shapes.inRange.setStyle({
      fill: visualInRange.barColor
    }).setShape("points", visualInRange.barPoints);
    shapes.outOfRange.setStyle({
      fill: visualOutOfRange.barColor
    }).setShape("points", visualOutOfRange.barPoints);
    this._updateHandle(inRangeHandleEnds, visualInRange);
  }
  _createBarVisual(dataInterval, dataExtent, handleEnds, forceState) {
    const opts = {
      forceState,
      convertOpacityToAlpha: true
    };
    const colorStops = this._makeColorGradient(dataInterval, opts);
    const symbolSizes = [
      this.getControllerVisual(dataInterval[0], "symbolSize", opts),
      this.getControllerVisual(dataInterval[1], "symbolSize", opts)
    ];
    const barPoints = this._createBarPoints(handleEnds, symbolSizes);
    return {
      barColor: new LinearGradient_default(0, 0, 0, 1, colorStops),
      barPoints,
      handlesColor: [
        colorStops[0].color,
        colorStops[colorStops.length - 1].color
      ]
    };
  }
  _makeColorGradient(dataInterval, opts) {
    const sampleNumber = 100;
    const colorStops = [];
    const step = (dataInterval[1] - dataInterval[0]) / sampleNumber;
    colorStops.push({
      color: this.getControllerVisual(dataInterval[0], "color", opts),
      offset: 0
    });
    for (let i = 1; i < sampleNumber; i++) {
      const currValue = dataInterval[0] + step * i;
      if (currValue > dataInterval[1]) {
        break;
      }
      colorStops.push({
        color: this.getControllerVisual(currValue, "color", opts),
        offset: i / sampleNumber
      });
    }
    colorStops.push({
      color: this.getControllerVisual(dataInterval[1], "color", opts),
      offset: 1
    });
    return colorStops;
  }
  _createBarPoints(handleEnds, symbolSizes) {
    const itemSize = this.visualMapModel.itemSize;
    return [
      [itemSize[0] - symbolSizes[0], handleEnds[0]],
      [itemSize[0], handleEnds[0]],
      [itemSize[0], handleEnds[1]],
      [itemSize[0] - symbolSizes[1], handleEnds[1]]
    ];
  }
  _createBarGroup(itemAlign) {
    const orient = this._orient;
    const inverse = this.visualMapModel.get("inverse");
    return new Group_default(orient === "horizontal" && !inverse ? {scaleX: itemAlign === "bottom" ? 1 : -1, rotation: Math.PI / 2} : orient === "horizontal" && inverse ? {scaleX: itemAlign === "bottom" ? -1 : 1, rotation: -Math.PI / 2} : orient === "vertical" && !inverse ? {scaleX: itemAlign === "left" ? 1 : -1, scaleY: -1} : {scaleX: itemAlign === "left" ? 1 : -1});
  }
  _updateHandle(handleEnds, visualInRange) {
    if (!this._useHandle) {
      return;
    }
    const shapes = this._shapes;
    const visualMapModel = this.visualMapModel;
    const handleThumbs = shapes.handleThumbs;
    const handleLabels = shapes.handleLabels;
    const itemSize = visualMapModel.itemSize;
    const dataExtent = visualMapModel.getExtent();
    each15([0, 1], function(handleIndex) {
      const handleThumb = handleThumbs[handleIndex];
      handleThumb.setStyle("fill", visualInRange.handlesColor[handleIndex]);
      handleThumb.y = handleEnds[handleIndex];
      const val = linearMap3(handleEnds[handleIndex], [0, itemSize[1]], dataExtent, true);
      const symbolSize = this.getControllerVisual(val, "symbolSize");
      handleThumb.scaleX = handleThumb.scaleY = symbolSize / itemSize[0];
      handleThumb.x = itemSize[0] - symbolSize / 2;
      const textPoint = applyTransform2(shapes.handleLabelPoints[handleIndex], getTransform(handleThumb, this.group));
      handleLabels[handleIndex].setStyle({
        x: textPoint[0],
        y: textPoint[1],
        text: visualMapModel.formatValueText(this._dataInterval[handleIndex]),
        verticalAlign: "middle",
        align: this._orient === "vertical" ? this._applyTransform("left", shapes.mainGroup) : "center"
      });
    }, this);
  }
  _showIndicator(cursorValue, textValue, rangeSymbol, halfHoverLinkSize) {
    const visualMapModel = this.visualMapModel;
    const dataExtent = visualMapModel.getExtent();
    const itemSize = visualMapModel.itemSize;
    const sizeExtent = [0, itemSize[1]];
    const shapes = this._shapes;
    const indicator = shapes.indicator;
    if (!indicator) {
      return;
    }
    indicator.attr("invisible", false);
    const opts = {convertOpacityToAlpha: true};
    const color2 = this.getControllerVisual(cursorValue, "color", opts);
    const symbolSize = this.getControllerVisual(cursorValue, "symbolSize");
    const y = linearMap3(cursorValue, dataExtent, sizeExtent, true);
    const x = itemSize[0] - symbolSize / 2;
    const oldIndicatorPos = {x: indicator.x, y: indicator.y};
    indicator.y = y;
    indicator.x = x;
    const textPoint = applyTransform2(shapes.indicatorLabelPoint, getTransform(indicator, this.group));
    const indicatorLabel = shapes.indicatorLabel;
    indicatorLabel.attr("invisible", false);
    const align = this._applyTransform("left", shapes.mainGroup);
    const orient = this._orient;
    const isHorizontal = orient === "horizontal";
    indicatorLabel.setStyle({
      text: (rangeSymbol ? rangeSymbol : "") + visualMapModel.formatValueText(textValue),
      verticalAlign: isHorizontal ? align : "middle",
      align: isHorizontal ? "center" : align
    });
    const indicatorNewProps = {
      x,
      y,
      style: {
        fill: color2
      }
    };
    const labelNewProps = {
      style: {
        x: textPoint[0],
        y: textPoint[1]
      }
    };
    if (visualMapModel.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
      const animationCfg = {
        duration: 100,
        easing: "cubicInOut",
        additive: true
      };
      indicator.x = oldIndicatorPos.x;
      indicator.y = oldIndicatorPos.y;
      indicator.animateTo(indicatorNewProps, animationCfg);
      indicatorLabel.animateTo(labelNewProps, animationCfg);
    } else {
      indicator.attr(indicatorNewProps);
      indicatorLabel.attr(labelNewProps);
    }
    this._firstShowIndicator = false;
    const handleLabels = this._shapes.handleLabels;
    if (handleLabels) {
      for (let i = 0; i < handleLabels.length; i++) {
        this.api.enterBlur(handleLabels[i]);
      }
    }
  }
  _enableHoverLinkToSeries() {
    const self2 = this;
    this._shapes.mainGroup.on("mousemove", function(e2) {
      self2._hovering = true;
      if (!self2._dragging) {
        const itemSize = self2.visualMapModel.itemSize;
        const pos = self2._applyTransform([e2.offsetX, e2.offsetY], self2._shapes.mainGroup, true, true);
        pos[1] = mathMin11(mathMax11(0, pos[1]), itemSize[1]);
        self2._doHoverLinkToSeries(pos[1], 0 <= pos[0] && pos[0] <= itemSize[0]);
      }
    }).on("mouseout", function() {
      self2._hovering = false;
      !self2._dragging && self2._clearHoverLinkToSeries();
    });
  }
  _enableHoverLinkFromSeries() {
    const zr = this.api.getZr();
    if (this.visualMapModel.option.hoverLink) {
      zr.on("mouseover", this._hoverLinkFromSeriesMouseOver, this);
      zr.on("mouseout", this._hideIndicator, this);
    } else {
      this._clearHoverLinkFromSeries();
    }
  }
  _doHoverLinkToSeries(cursorPos, hoverOnBar) {
    const visualMapModel = this.visualMapModel;
    const itemSize = visualMapModel.itemSize;
    if (!visualMapModel.option.hoverLink) {
      return;
    }
    const sizeExtent = [0, itemSize[1]];
    const dataExtent = visualMapModel.getExtent();
    cursorPos = mathMin11(mathMax11(sizeExtent[0], cursorPos), sizeExtent[1]);
    const halfHoverLinkSize = getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent);
    const hoverRange = [cursorPos - halfHoverLinkSize, cursorPos + halfHoverLinkSize];
    const cursorValue = linearMap3(cursorPos, sizeExtent, dataExtent, true);
    const valueRange = [
      linearMap3(hoverRange[0], sizeExtent, dataExtent, true),
      linearMap3(hoverRange[1], sizeExtent, dataExtent, true)
    ];
    hoverRange[0] < sizeExtent[0] && (valueRange[0] = -Infinity);
    hoverRange[1] > sizeExtent[1] && (valueRange[1] = Infinity);
    if (hoverOnBar) {
      if (valueRange[0] === -Infinity) {
        this._showIndicator(cursorValue, valueRange[1], "< ", halfHoverLinkSize);
      } else if (valueRange[1] === Infinity) {
        this._showIndicator(cursorValue, valueRange[0], "> ", halfHoverLinkSize);
      } else {
        this._showIndicator(cursorValue, cursorValue, "\u2248 ", halfHoverLinkSize);
      }
    }
    const oldBatch = this._hoverLinkDataIndices;
    let newBatch = [];
    if (hoverOnBar || useHoverLinkOnHandle(visualMapModel)) {
      newBatch = this._hoverLinkDataIndices = visualMapModel.findTargetDataIndices(valueRange);
    }
    const resultBatches = compressBatches(oldBatch, newBatch);
    this._dispatchHighDown("downplay", makeHighDownBatch(resultBatches[0], visualMapModel));
    this._dispatchHighDown("highlight", makeHighDownBatch(resultBatches[1], visualMapModel));
  }
  _hoverLinkFromSeriesMouseOver(e2) {
    let ecData;
    findEventDispatcher(e2.target, (target) => {
      const currECData = getECData(target);
      if (currECData.dataIndex != null) {
        ecData = currECData;
        return true;
      }
    }, true);
    if (!ecData) {
      return;
    }
    const dataModel = this.ecModel.getSeriesByIndex(ecData.seriesIndex);
    const visualMapModel = this.visualMapModel;
    if (!visualMapModel.isTargetSeries(dataModel)) {
      return;
    }
    const data = dataModel.getData(ecData.dataType);
    const value = data.getStore().get(visualMapModel.getDataDimensionIndex(data), ecData.dataIndex);
    if (!isNaN(value)) {
      this._showIndicator(value, value);
    }
  }
  _hideIndicator() {
    const shapes = this._shapes;
    shapes.indicator && shapes.indicator.attr("invisible", true);
    shapes.indicatorLabel && shapes.indicatorLabel.attr("invisible", true);
    const handleLabels = this._shapes.handleLabels;
    if (handleLabels) {
      for (let i = 0; i < handleLabels.length; i++) {
        this.api.leaveBlur(handleLabels[i]);
      }
    }
  }
  _clearHoverLinkToSeries() {
    this._hideIndicator();
    const indices = this._hoverLinkDataIndices;
    this._dispatchHighDown("downplay", makeHighDownBatch(indices, this.visualMapModel));
    indices.length = 0;
  }
  _clearHoverLinkFromSeries() {
    this._hideIndicator();
    const zr = this.api.getZr();
    zr.off("mouseover", this._hoverLinkFromSeriesMouseOver);
    zr.off("mouseout", this._hideIndicator);
  }
  _applyTransform(vertex, element, inverse, global2) {
    const transform2 = getTransform(element, global2 ? null : this.group);
    return isArray(vertex) ? applyTransform2(vertex, transform2, inverse) : transformDirection(vertex, transform2, inverse);
  }
  _dispatchHighDown(type, batch) {
    batch && batch.length && this.api.dispatchAction({
      type,
      batch
    });
  }
  dispose() {
    this._clearHoverLinkFromSeries();
    this._clearHoverLinkToSeries();
  }
};
var ContinuousView = ContinuousView2;
ContinuousView.type = "visualMap.continuous";
function createPolygon(points4, cursor, onDrift, onDragEnd) {
  return new Polygon_default({
    shape: {points: points4},
    draggable: !!onDrift,
    cursor,
    drift: onDrift,
    onmousemove(e2) {
      stop(e2.event);
    },
    ondragend: onDragEnd
  });
}
function getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent) {
  let halfHoverLinkSize = HOVER_LINK_SIZE / 2;
  const hoverLinkDataSize = visualMapModel.get("hoverLinkDataSize");
  if (hoverLinkDataSize) {
    halfHoverLinkSize = linearMap3(hoverLinkDataSize, dataExtent, sizeExtent, true) / 2;
  }
  return halfHoverLinkSize;
}
function useHoverLinkOnHandle(visualMapModel) {
  const hoverLinkOnHandle = visualMapModel.get("hoverLinkOnHandle");
  return !!(hoverLinkOnHandle == null ? visualMapModel.get("realtime") : hoverLinkOnHandle);
}
function getCursor2(orient) {
  return orient === "vertical" ? "ns-resize" : "ew-resize";
}
var ContinuousView_default = ContinuousView;

// src/component/visualMap/visualMapAction.ts
var visualMapActionInfo = {
  type: "selectDataRange",
  event: "dataRangeSelected",
  update: "update"
};
var visualMapActionHander = function(payload, ecModel) {
  ecModel.eachComponent({mainType: "visualMap", query: payload}, function(model) {
    model.setSelected(payload.selected);
  });
};

// src/component/visualMap/visualEncoding.ts
var visualMapEncodingHandlers = [
  {
    createOnAllSeries: true,
    reset: function(seriesModel, ecModel) {
      const resetDefines = [];
      ecModel.eachComponent("visualMap", function(visualMapModel) {
        const pipelineContext = seriesModel.pipelineContext;
        if (!visualMapModel.isTargetSeries(seriesModel) || pipelineContext && pipelineContext.large) {
          return;
        }
        resetDefines.push(incrementalApplyVisual(visualMapModel.stateList, visualMapModel.targetVisuals, bind(visualMapModel.getValueState, visualMapModel), visualMapModel.getDataDimensionIndex(seriesModel.getData())));
      });
      return resetDefines;
    }
  },
  {
    createOnAllSeries: true,
    reset: function(seriesModel, ecModel) {
      const data = seriesModel.getData();
      const visualMetaList = [];
      ecModel.eachComponent("visualMap", function(visualMapModel) {
        if (visualMapModel.isTargetSeries(seriesModel)) {
          const visualMeta = visualMapModel.getVisualMeta(bind(getColorVisual, null, seriesModel, visualMapModel)) || {
            stops: [],
            outerColors: []
          };
          const dimIdx = visualMapModel.getDataDimensionIndex(data);
          if (dimIdx >= 0) {
            visualMeta.dimension = dimIdx;
            visualMetaList.push(visualMeta);
          }
        }
      });
      seriesModel.getData().setVisual("visualMeta", visualMetaList);
    }
  }
];
function getColorVisual(seriesModel, visualMapModel, value, valueState) {
  const mappings = visualMapModel.targetVisuals[valueState];
  const visualTypes = VisualMapping_default.prepareVisualTypes(mappings);
  const resultVisual = {
    color: getVisualFromData(seriesModel.getData(), "color")
  };
  for (let i = 0, len2 = visualTypes.length; i < len2; i++) {
    const type = visualTypes[i];
    const mapping = mappings[type === "opacity" ? "__alphaForOpacity" : type];
    mapping && mapping.applyVisual(value, getVisual, setVisual);
  }
  return resultVisual.color;
  function getVisual(key) {
    return resultVisual[key];
  }
  function setVisual(key, value2) {
    resultVisual[key] = value2;
  }
}

// src/component/visualMap/preprocessor.ts
var each16 = each;
function visualMapPreprocessor(option) {
  let visualMap = option && option.visualMap;
  if (!isArray(visualMap)) {
    visualMap = visualMap ? [visualMap] : [];
  }
  each16(visualMap, function(opt) {
    if (!opt) {
      return;
    }
    if (has2(opt, "splitList") && !has2(opt, "pieces")) {
      opt.pieces = opt.splitList;
      delete opt.splitList;
    }
    const pieces = opt.pieces;
    if (pieces && isArray(pieces)) {
      each16(pieces, function(piece) {
        if (isObject(piece)) {
          if (has2(piece, "start") && !has2(piece, "min")) {
            piece.min = piece.start;
          }
          if (has2(piece, "end") && !has2(piece, "max")) {
            piece.max = piece.end;
          }
        }
      });
    }
  });
}
function has2(obj, name) {
  return obj && obj.hasOwnProperty && obj.hasOwnProperty(name);
}

// src/component/visualMap/installCommon.ts
var installed2 = false;
function installCommon2(registers) {
  if (installed2) {
    return;
  }
  installed2 = true;
  registers.registerSubTypeDefaulter("visualMap", function(option) {
    return !option.categories && (!(option.pieces ? option.pieces.length > 0 : option.splitNumber > 0) || option.calculable) ? "continuous" : "piecewise";
  });
  registers.registerAction(visualMapActionInfo, visualMapActionHander);
  each(visualMapEncodingHandlers, (handler) => {
    registers.registerVisual(registers.PRIORITY.VISUAL.COMPONENT, handler);
  });
  registers.registerPreprocessor(visualMapPreprocessor);
}

// src/component/visualMap/installVisualMapContinuous.ts
function install50(registers) {
  registers.registerComponentModel(ContinuousModel_default);
  registers.registerComponentView(ContinuousView_default);
  installCommon2(registers);
}

// src/component/visualMap/PiecewiseModel.ts
var PiecewiseModel2 = class extends VisualMapModel_default {
  constructor() {
    super(...arguments);
    this.type = PiecewiseModel2.type;
    this._pieceList = [];
  }
  optionUpdated(newOption, isInit) {
    super.optionUpdated.apply(this, arguments);
    this.resetExtent();
    const mode = this._mode = this._determineMode();
    this._pieceList = [];
    resetMethods[this._mode].call(this, this._pieceList);
    this._resetSelected(newOption, isInit);
    const categories = this.option.categories;
    this.resetVisual(function(mappingOption, state) {
      if (mode === "categories") {
        mappingOption.mappingMethod = "category";
        mappingOption.categories = clone(categories);
      } else {
        mappingOption.dataExtent = this.getExtent();
        mappingOption.mappingMethod = "piecewise";
        mappingOption.pieceList = map(this._pieceList, function(piece) {
          piece = clone(piece);
          if (state !== "inRange") {
            piece.visual = null;
          }
          return piece;
        });
      }
    });
  }
  completeVisualOption() {
    const option = this.option;
    const visualTypesInPieces = {};
    const visualTypes = VisualMapping_default.listVisualTypes();
    const isCategory2 = this.isCategory();
    each(option.pieces, function(piece) {
      each(visualTypes, function(visualType) {
        if (piece.hasOwnProperty(visualType)) {
          visualTypesInPieces[visualType] = 1;
        }
      });
    });
    each(visualTypesInPieces, function(v, visualType) {
      let exists = false;
      each(this.stateList, function(state) {
        exists = exists || has3(option, state, visualType) || has3(option.target, state, visualType);
      }, this);
      !exists && each(this.stateList, function(state) {
        (option[state] || (option[state] = {}))[visualType] = visualDefault_default.get(visualType, state === "inRange" ? "active" : "inactive", isCategory2);
      });
    }, this);
    function has3(obj, state, visualType) {
      return obj && obj[state] && obj[state].hasOwnProperty(visualType);
    }
    super.completeVisualOption.apply(this, arguments);
  }
  _resetSelected(newOption, isInit) {
    const thisOption = this.option;
    const pieceList = this._pieceList;
    const selected = (isInit ? thisOption : newOption).selected || {};
    thisOption.selected = selected;
    each(pieceList, function(piece, index) {
      const key = this.getSelectedMapKey(piece);
      if (!selected.hasOwnProperty(key)) {
        selected[key] = true;
      }
    }, this);
    if (thisOption.selectedMode === "single") {
      let hasSel = false;
      each(pieceList, function(piece, index) {
        const key = this.getSelectedMapKey(piece);
        if (selected[key]) {
          hasSel ? selected[key] = false : hasSel = true;
        }
      }, this);
    }
  }
  getItemSymbol() {
    return this.get("itemSymbol");
  }
  getSelectedMapKey(piece) {
    return this._mode === "categories" ? piece.value + "" : piece.index + "";
  }
  getPieceList() {
    return this._pieceList;
  }
  _determineMode() {
    const option = this.option;
    return option.pieces && option.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
  }
  setSelected(selected) {
    this.option.selected = clone(selected);
  }
  getValueState(value) {
    const index = VisualMapping_default.findPieceIndex(value, this._pieceList);
    return index != null ? this.option.selected[this.getSelectedMapKey(this._pieceList[index])] ? "inRange" : "outOfRange" : "outOfRange";
  }
  findTargetDataIndices(pieceIndex) {
    const result = [];
    const pieceList = this._pieceList;
    this.eachTargetSeries(function(seriesModel) {
      const dataIndices = [];
      const data = seriesModel.getData();
      data.each(this.getDataDimensionIndex(data), function(value, dataIndex) {
        const pIdx = VisualMapping_default.findPieceIndex(value, pieceList);
        pIdx === pieceIndex && dataIndices.push(dataIndex);
      }, this);
      result.push({seriesId: seriesModel.id, dataIndex: dataIndices});
    }, this);
    return result;
  }
  getRepresentValue(piece) {
    let representValue;
    if (this.isCategory()) {
      representValue = piece.value;
    } else {
      if (piece.value != null) {
        representValue = piece.value;
      } else {
        const pieceInterval = piece.interval || [];
        representValue = pieceInterval[0] === -Infinity && pieceInterval[1] === Infinity ? 0 : (pieceInterval[0] + pieceInterval[1]) / 2;
      }
    }
    return representValue;
  }
  getVisualMeta(getColorVisual2) {
    if (this.isCategory()) {
      return;
    }
    const stops = [];
    const outerColors = ["", ""];
    const visualMapModel = this;
    function setStop(interval, valueState) {
      const representValue = visualMapModel.getRepresentValue({
        interval
      });
      if (!valueState) {
        valueState = visualMapModel.getValueState(representValue);
      }
      const color2 = getColorVisual2(representValue, valueState);
      if (interval[0] === -Infinity) {
        outerColors[0] = color2;
      } else if (interval[1] === Infinity) {
        outerColors[1] = color2;
      } else {
        stops.push({value: interval[0], color: color2}, {value: interval[1], color: color2});
      }
    }
    const pieceList = this._pieceList.slice();
    if (!pieceList.length) {
      pieceList.push({interval: [-Infinity, Infinity]});
    } else {
      let edge = pieceList[0].interval[0];
      edge !== -Infinity && pieceList.unshift({interval: [-Infinity, edge]});
      edge = pieceList[pieceList.length - 1].interval[1];
      edge !== Infinity && pieceList.push({interval: [edge, Infinity]});
    }
    let curr = -Infinity;
    each(pieceList, function(piece) {
      const interval = piece.interval;
      if (interval) {
        interval[0] > curr && setStop([curr, interval[0]], "outOfRange");
        setStop(interval.slice());
        curr = interval[1];
      }
    }, this);
    return {stops, outerColors};
  }
};
var PiecewiseModel = PiecewiseModel2;
PiecewiseModel.type = "visualMap.piecewise";
PiecewiseModel.defaultOption = inheritDefaultOption(VisualMapModel_default.defaultOption, {
  selected: null,
  minOpen: false,
  maxOpen: false,
  align: "auto",
  itemWidth: 20,
  itemHeight: 14,
  itemSymbol: "roundRect",
  pieces: null,
  categories: null,
  splitNumber: 5,
  selectedMode: "multiple",
  itemGap: 10,
  hoverLink: true
});
var resetMethods = {
  splitNumber(outPieceList) {
    const thisOption = this.option;
    let precision = Math.min(thisOption.precision, 20);
    const dataExtent = this.getExtent();
    let splitNumber = thisOption.splitNumber;
    splitNumber = Math.max(parseInt(splitNumber, 10), 1);
    thisOption.splitNumber = splitNumber;
    let splitStep = (dataExtent[1] - dataExtent[0]) / splitNumber;
    while (+splitStep.toFixed(precision) !== splitStep && precision < 5) {
      precision++;
    }
    thisOption.precision = precision;
    splitStep = +splitStep.toFixed(precision);
    if (thisOption.minOpen) {
      outPieceList.push({
        interval: [-Infinity, dataExtent[0]],
        close: [0, 0]
      });
    }
    for (let index = 0, curr = dataExtent[0]; index < splitNumber; curr += splitStep, index++) {
      const max3 = index === splitNumber - 1 ? dataExtent[1] : curr + splitStep;
      outPieceList.push({
        interval: [curr, max3],
        close: [1, 1]
      });
    }
    if (thisOption.maxOpen) {
      outPieceList.push({
        interval: [dataExtent[1], Infinity],
        close: [0, 0]
      });
    }
    reformIntervals(outPieceList);
    each(outPieceList, function(piece, index) {
      piece.index = index;
      piece.text = this.formatValueText(piece.interval);
    }, this);
  },
  categories(outPieceList) {
    const thisOption = this.option;
    each(thisOption.categories, function(cate) {
      outPieceList.push({
        text: this.formatValueText(cate, true),
        value: cate
      });
    }, this);
    normalizeReverse(thisOption, outPieceList);
  },
  pieces(outPieceList) {
    const thisOption = this.option;
    each(thisOption.pieces, function(pieceListItem, index) {
      if (!isObject(pieceListItem)) {
        pieceListItem = {value: pieceListItem};
      }
      const item = {text: "", index};
      if (pieceListItem.label != null) {
        item.text = pieceListItem.label;
      }
      if (pieceListItem.hasOwnProperty("value")) {
        const value = item.value = pieceListItem.value;
        item.interval = [value, value];
        item.close = [1, 1];
      } else {
        const interval = item.interval = [];
        const close = item.close = [0, 0];
        const closeList = [1, 0, 1];
        const infinityList = [-Infinity, Infinity];
        const useMinMax = [];
        for (let lg = 0; lg < 2; lg++) {
          const names = [["gte", "gt", "min"], ["lte", "lt", "max"]][lg];
          for (let i = 0; i < 3 && interval[lg] == null; i++) {
            interval[lg] = pieceListItem[names[i]];
            close[lg] = closeList[i];
            useMinMax[lg] = i === 2;
          }
          interval[lg] == null && (interval[lg] = infinityList[lg]);
        }
        useMinMax[0] && interval[1] === Infinity && (close[0] = 0);
        useMinMax[1] && interval[0] === -Infinity && (close[1] = 0);
        if (true) {
          if (interval[0] > interval[1]) {
            console.warn("Piece " + index + "is illegal: " + interval + " lower bound should not greater then uppper bound.");
          }
        }
        if (interval[0] === interval[1] && close[0] && close[1]) {
          item.value = interval[0];
        }
      }
      item.visual = VisualMapping_default.retrieveVisuals(pieceListItem);
      outPieceList.push(item);
    }, this);
    normalizeReverse(thisOption, outPieceList);
    reformIntervals(outPieceList);
    each(outPieceList, function(piece) {
      const close = piece.close;
      const edgeSymbols = [["<", "\u2264"][close[1]], [">", "\u2265"][close[0]]];
      piece.text = piece.text || this.formatValueText(piece.value != null ? piece.value : piece.interval, false, edgeSymbols);
    }, this);
  }
};
function normalizeReverse(thisOption, pieceList) {
  const inverse = thisOption.inverse;
  if (thisOption.orient === "vertical" ? !inverse : inverse) {
    pieceList.reverse();
  }
}
var PiecewiseModel_default = PiecewiseModel;

// src/component/visualMap/PiecewiseView.ts
var PiecewiseVisualMapView2 = class extends VisualMapView_default {
  constructor() {
    super(...arguments);
    this.type = PiecewiseVisualMapView2.type;
  }
  doRender() {
    const thisGroup = this.group;
    thisGroup.removeAll();
    const visualMapModel = this.visualMapModel;
    const textGap = visualMapModel.get("textGap");
    const textStyleModel = visualMapModel.textStyleModel;
    const textFont = textStyleModel.getFont();
    const textFill = textStyleModel.getTextColor();
    const itemAlign = this._getItemAlign();
    const itemSize = visualMapModel.itemSize;
    const viewData = this._getViewData();
    const endsText = viewData.endsText;
    const showLabel = retrieve(visualMapModel.get("showLabel", true), !endsText);
    endsText && this._renderEndsText(thisGroup, endsText[0], itemSize, showLabel, itemAlign);
    each(viewData.viewPieceList, function(item) {
      const piece = item.piece;
      const itemGroup = new Group_default();
      itemGroup.onclick = bind(this._onItemClick, this, piece);
      this._enableHoverLink(itemGroup, item.indexInModelPieceList);
      const representValue = visualMapModel.getRepresentValue(piece);
      this._createItemSymbol(itemGroup, representValue, [0, 0, itemSize[0], itemSize[1]]);
      if (showLabel) {
        const visualState = this.visualMapModel.getValueState(representValue);
        itemGroup.add(new Text_default({
          style: {
            x: itemAlign === "right" ? -textGap : itemSize[0] + textGap,
            y: itemSize[1] / 2,
            text: piece.text,
            verticalAlign: "middle",
            align: itemAlign,
            font: textFont,
            fill: textFill,
            opacity: visualState === "outOfRange" ? 0.5 : 1
          }
        }));
      }
      thisGroup.add(itemGroup);
    }, this);
    endsText && this._renderEndsText(thisGroup, endsText[1], itemSize, showLabel, itemAlign);
    box(visualMapModel.get("orient"), thisGroup, visualMapModel.get("itemGap"));
    this.renderBackground(thisGroup);
    this.positionGroup(thisGroup);
  }
  _enableHoverLink(itemGroup, pieceIndex) {
    itemGroup.on("mouseover", () => onHoverLink("highlight")).on("mouseout", () => onHoverLink("downplay"));
    const onHoverLink = (method) => {
      const visualMapModel = this.visualMapModel;
      visualMapModel.option.hoverLink && this.api.dispatchAction({
        type: method,
        batch: makeHighDownBatch(visualMapModel.findTargetDataIndices(pieceIndex), visualMapModel)
      });
    };
  }
  _getItemAlign() {
    const visualMapModel = this.visualMapModel;
    const modelOption = visualMapModel.option;
    if (modelOption.orient === "vertical") {
      return getItemAlign(visualMapModel, this.api, visualMapModel.itemSize);
    } else {
      let align = modelOption.align;
      if (!align || align === "auto") {
        align = "left";
      }
      return align;
    }
  }
  _renderEndsText(group, text, itemSize, showLabel, itemAlign) {
    if (!text) {
      return;
    }
    const itemGroup = new Group_default();
    const textStyleModel = this.visualMapModel.textStyleModel;
    itemGroup.add(new Text_default({
      style: createTextStyle(textStyleModel, {
        x: showLabel ? itemAlign === "right" ? itemSize[0] : 0 : itemSize[0] / 2,
        y: itemSize[1] / 2,
        verticalAlign: "middle",
        align: showLabel ? itemAlign : "center",
        text
      })
    }));
    group.add(itemGroup);
  }
  _getViewData() {
    const visualMapModel = this.visualMapModel;
    const viewPieceList = map(visualMapModel.getPieceList(), function(piece, index) {
      return {piece, indexInModelPieceList: index};
    });
    let endsText = visualMapModel.get("text");
    const orient = visualMapModel.get("orient");
    const inverse = visualMapModel.get("inverse");
    if (orient === "horizontal" ? inverse : !inverse) {
      viewPieceList.reverse();
    } else if (endsText) {
      endsText = endsText.slice().reverse();
    }
    return {viewPieceList, endsText};
  }
  _createItemSymbol(group, representValue, shapeParam) {
    group.add(createSymbol(this.getControllerVisual(representValue, "symbol"), shapeParam[0], shapeParam[1], shapeParam[2], shapeParam[3], this.getControllerVisual(representValue, "color")));
  }
  _onItemClick(piece) {
    const visualMapModel = this.visualMapModel;
    const option = visualMapModel.option;
    const selectedMode = option.selectedMode;
    if (!selectedMode) {
      return;
    }
    const selected = clone(option.selected);
    const newKey = visualMapModel.getSelectedMapKey(piece);
    if (selectedMode === "single" || selectedMode === true) {
      selected[newKey] = true;
      each(selected, function(o, key) {
        selected[key] = key === newKey;
      });
    } else {
      selected[newKey] = !selected[newKey];
    }
    this.api.dispatchAction({
      type: "selectDataRange",
      from: this.uid,
      visualMapId: this.visualMapModel.id,
      selected
    });
  }
};
var PiecewiseVisualMapView = PiecewiseVisualMapView2;
PiecewiseVisualMapView.type = "visualMap.piecewise";
var PiecewiseView_default = PiecewiseVisualMapView;

// src/component/visualMap/installVisualMapPiecewise.ts
function install51(registers) {
  registers.registerComponentModel(PiecewiseModel_default);
  registers.registerComponentView(PiecewiseView_default);
  installCommon2(registers);
}

// src/component/visualMap/install.ts
function install52(registers) {
  use(install50);
  use(install51);
}

// src/visual/aria.ts
var DEFAULT_OPTION = {
  label: {
    enabled: true
  },
  decal: {
    show: false
  }
};
var inner22 = makeInner();
var decalPaletteScope = {};
function ariaVisual(ecModel, api2) {
  const ariaModel = ecModel.getModel("aria");
  if (!ariaModel.get("enabled")) {
    return;
  }
  const defaultOption3 = clone(DEFAULT_OPTION);
  merge(defaultOption3.label, ecModel.getLocaleModel().get("aria"), false);
  merge(ariaModel.option, defaultOption3, false);
  setDecal();
  setLabel();
  function setDecal() {
    const decalModel = ariaModel.getModel("decal");
    const useDecal = decalModel.get("show");
    if (useDecal) {
      const paletteScopeGroupByType = createHashMap();
      ecModel.eachSeries((seriesModel) => {
        if (seriesModel.isColorBySeries()) {
          return;
        }
        let decalScope = paletteScopeGroupByType.get(seriesModel.type);
        if (!decalScope) {
          decalScope = {};
          paletteScopeGroupByType.set(seriesModel.type, decalScope);
        }
        inner22(seriesModel).scope = decalScope;
      });
      ecModel.eachRawSeries((seriesModel) => {
        if (ecModel.isSeriesFiltered(seriesModel)) {
          return;
        }
        if (isFunction(seriesModel.enableAriaDecal)) {
          seriesModel.enableAriaDecal();
          return;
        }
        const data = seriesModel.getData();
        if (!seriesModel.isColorBySeries()) {
          const dataAll = seriesModel.getRawData();
          const idxMap = {};
          const decalScope = inner22(seriesModel).scope;
          data.each(function(idx) {
            const rawIdx = data.getRawIndex(idx);
            idxMap[rawIdx] = idx;
          });
          const dataCount = dataAll.count();
          dataAll.each((rawIdx) => {
            const idx = idxMap[rawIdx];
            const name = dataAll.getName(rawIdx) || rawIdx + "";
            const paletteDecal = getDecalFromPalette(seriesModel.ecModel, name, decalScope, dataCount);
            const specifiedDecal = data.getItemVisual(idx, "decal");
            data.setItemVisual(idx, "decal", mergeDecal(specifiedDecal, paletteDecal));
          });
        } else {
          const paletteDecal = getDecalFromPalette(seriesModel.ecModel, seriesModel.name, decalPaletteScope, ecModel.getSeriesCount());
          const specifiedDecal = data.getVisual("decal");
          data.setVisual("decal", mergeDecal(specifiedDecal, paletteDecal));
        }
        function mergeDecal(specifiedDecal, paletteDecal) {
          const resultDecal = specifiedDecal ? extend(extend({}, paletteDecal), specifiedDecal) : paletteDecal;
          resultDecal.dirty = true;
          return resultDecal;
        }
      });
    }
  }
  function setLabel() {
    const labelLocale = ecModel.getLocaleModel().get("aria");
    const labelModel = ariaModel.getModel("label");
    labelModel.option = defaults(labelModel.option, labelLocale);
    if (!labelModel.get("enabled")) {
      return;
    }
    const dom = api2.getZr().dom;
    if (labelModel.get("description")) {
      dom.setAttribute("aria-label", labelModel.get("description"));
      return;
    }
    const seriesCnt = ecModel.getSeriesCount();
    const maxDataCnt = labelModel.get(["data", "maxCount"]) || 10;
    const maxSeriesCnt = labelModel.get(["series", "maxCount"]) || 10;
    const displaySeriesCnt = Math.min(seriesCnt, maxSeriesCnt);
    let ariaLabel;
    if (seriesCnt < 1) {
      return;
    } else {
      const title = getTitle();
      if (title) {
        const withTitle = labelModel.get(["general", "withTitle"]);
        ariaLabel = replace(withTitle, {
          title
        });
      } else {
        ariaLabel = labelModel.get(["general", "withoutTitle"]);
      }
      const seriesLabels = [];
      const prefix = seriesCnt > 1 ? labelModel.get(["series", "multiple", "prefix"]) : labelModel.get(["series", "single", "prefix"]);
      ariaLabel += replace(prefix, {seriesCount: seriesCnt});
      ecModel.eachSeries(function(seriesModel, idx) {
        if (idx < displaySeriesCnt) {
          let seriesLabel;
          const seriesName = seriesModel.get("name");
          const withName = seriesName ? "withName" : "withoutName";
          seriesLabel = seriesCnt > 1 ? labelModel.get(["series", "multiple", withName]) : labelModel.get(["series", "single", withName]);
          seriesLabel = replace(seriesLabel, {
            seriesId: seriesModel.seriesIndex,
            seriesName: seriesModel.get("name"),
            seriesType: getSeriesTypeName(seriesModel.subType)
          });
          const data = seriesModel.getData();
          if (data.count() > maxDataCnt) {
            const partialLabel = labelModel.get(["data", "partialData"]);
            seriesLabel += replace(partialLabel, {
              displayCnt: maxDataCnt
            });
          } else {
            seriesLabel += labelModel.get(["data", "allData"]);
          }
          const middleSeparator2 = labelModel.get(["data", "separator", "middle"]);
          const endSeparator2 = labelModel.get(["data", "separator", "end"]);
          const dataLabels = [];
          for (let i = 0; i < data.count(); i++) {
            if (i < maxDataCnt) {
              const name = data.getName(i);
              const value = data.getValues(i);
              const dataLabel = labelModel.get(["data", name ? "withName" : "withoutName"]);
              dataLabels.push(replace(dataLabel, {
                name,
                value: value.join(middleSeparator2)
              }));
            }
          }
          seriesLabel += dataLabels.join(middleSeparator2) + endSeparator2;
          seriesLabels.push(seriesLabel);
        }
      });
      const separatorModel = labelModel.getModel(["series", "multiple", "separator"]);
      const middleSeparator = separatorModel.get("middle");
      const endSeparator = separatorModel.get("end");
      ariaLabel += seriesLabels.join(middleSeparator) + endSeparator;
      dom.setAttribute("aria-label", ariaLabel);
    }
  }
  function replace(str, keyValues) {
    if (!isString(str)) {
      return str;
    }
    let result = str;
    each(keyValues, function(value, key) {
      result = result.replace(new RegExp("\\{\\s*" + key + "\\s*\\}", "g"), value);
    });
    return result;
  }
  function getTitle() {
    let title = ecModel.get("title");
    if (title && title.length) {
      title = title[0];
    }
    return title && title.text;
  }
  function getSeriesTypeName(type) {
    const typeNames = ecModel.getLocaleModel().get(["series", "typeNames"]);
    return typeNames[type] || typeNames.chart;
  }
}

// src/component/aria/preprocessor.ts
function ariaPreprocessor(option) {
  if (!option || !option.aria) {
    return;
  }
  const aria = option.aria;
  if (aria.show != null) {
    aria.enabled = aria.show;
  }
  aria.label = aria.label || {};
  each(["description", "general", "series", "data"], (name) => {
    if (aria[name] != null) {
      aria.label[name] = aria[name];
    }
  });
}

// src/component/aria/install.ts
function install53(registers) {
  registers.registerPreprocessor(ariaPreprocessor);
  registers.registerVisual(registers.PRIORITY.VISUAL.ARIA, ariaVisual);
}

// src/util/conditionalExpression.ts
var RELATIONAL_EXPRESSION_OP_ALIAS_MAP = {
  value: "eq",
  "<": "lt",
  "<=": "lte",
  ">": "gt",
  ">=": "gte",
  "=": "eq",
  "!=": "ne",
  "<>": "ne"
};
var RegExpEvaluator = class {
  constructor(rVal) {
    const condValue = this._condVal = isString(rVal) ? new RegExp(rVal) : isRegExp(rVal) ? rVal : null;
    if (condValue == null) {
      let errMsg = "";
      if (true) {
        errMsg = makePrintable("Illegal regexp", rVal, "in");
      }
      throwError(errMsg);
    }
  }
  evaluate(lVal) {
    const type = typeof lVal;
    return isString(type) ? this._condVal.test(lVal) : isNumber(type) ? this._condVal.test(lVal + "") : false;
  }
};
var ConstConditionInternal = class {
  evaluate() {
    return this.value;
  }
};
var AndConditionInternal = class {
  evaluate() {
    const children = this.children;
    for (let i = 0; i < children.length; i++) {
      if (!children[i].evaluate()) {
        return false;
      }
    }
    return true;
  }
};
var OrConditionInternal = class {
  evaluate() {
    const children = this.children;
    for (let i = 0; i < children.length; i++) {
      if (children[i].evaluate()) {
        return true;
      }
    }
    return false;
  }
};
var NotConditionInternal = class {
  evaluate() {
    return !this.child.evaluate();
  }
};
var RelationalConditionInternal = class {
  evaluate() {
    const needParse = !!this.valueParser;
    const getValue = this.getValue;
    const tarValRaw = getValue(this.valueGetterParam);
    const tarValParsed = needParse ? this.valueParser(tarValRaw) : null;
    for (let i = 0; i < this.subCondList.length; i++) {
      if (!this.subCondList[i].evaluate(needParse ? tarValParsed : tarValRaw)) {
        return false;
      }
    }
    return true;
  }
};
function parseOption(exprOption, getters) {
  if (exprOption === true || exprOption === false) {
    const cond = new ConstConditionInternal();
    cond.value = exprOption;
    return cond;
  }
  let errMsg = "";
  if (!isObjectNotArray(exprOption)) {
    if (true) {
      errMsg = makePrintable("Illegal config. Expect a plain object but actually", exprOption);
    }
    throwError(errMsg);
  }
  if (exprOption.and) {
    return parseAndOrOption("and", exprOption, getters);
  } else if (exprOption.or) {
    return parseAndOrOption("or", exprOption, getters);
  } else if (exprOption.not) {
    return parseNotOption(exprOption, getters);
  }
  return parseRelationalOption(exprOption, getters);
}
function parseAndOrOption(op, exprOption, getters) {
  const subOptionArr = exprOption[op];
  let errMsg = "";
  if (true) {
    errMsg = makePrintable('"and"/"or" condition should only be `' + op + ": [...]` and must not be empty array.", "Illegal condition:", exprOption);
  }
  if (!isArray(subOptionArr)) {
    throwError(errMsg);
  }
  if (!subOptionArr.length) {
    throwError(errMsg);
  }
  const cond = op === "and" ? new AndConditionInternal() : new OrConditionInternal();
  cond.children = map(subOptionArr, (subOption) => parseOption(subOption, getters));
  if (!cond.children.length) {
    throwError(errMsg);
  }
  return cond;
}
function parseNotOption(exprOption, getters) {
  const subOption = exprOption.not;
  let errMsg = "";
  if (true) {
    errMsg = makePrintable('"not" condition should only be `not: {}`.', "Illegal condition:", exprOption);
  }
  if (!isObjectNotArray(subOption)) {
    throwError(errMsg);
  }
  const cond = new NotConditionInternal();
  cond.child = parseOption(subOption, getters);
  if (!cond.child) {
    throwError(errMsg);
  }
  return cond;
}
function parseRelationalOption(exprOption, getters) {
  let errMsg = "";
  const valueGetterParam = getters.prepareGetValue(exprOption);
  const subCondList = [];
  const exprKeys = keys(exprOption);
  const parserName = exprOption.parser;
  const valueParser = parserName ? getRawValueParser(parserName) : null;
  for (let i = 0; i < exprKeys.length; i++) {
    const keyRaw = exprKeys[i];
    if (keyRaw === "parser" || getters.valueGetterAttrMap.get(keyRaw)) {
      continue;
    }
    const op = hasOwn(RELATIONAL_EXPRESSION_OP_ALIAS_MAP, keyRaw) ? RELATIONAL_EXPRESSION_OP_ALIAS_MAP[keyRaw] : keyRaw;
    const condValueRaw = exprOption[keyRaw];
    const condValueParsed = valueParser ? valueParser(condValueRaw) : condValueRaw;
    const evaluator = createFilterComparator(op, condValueParsed) || op === "reg" && new RegExpEvaluator(condValueParsed);
    if (!evaluator) {
      if (true) {
        errMsg = makePrintable('Illegal relational operation: "' + keyRaw + '" in condition:', exprOption);
      }
      throwError(errMsg);
    }
    subCondList.push(evaluator);
  }
  if (!subCondList.length) {
    if (true) {
      errMsg = makePrintable("Relational condition must have at least one operator.", "Illegal condition:", exprOption);
    }
    throwError(errMsg);
  }
  const cond = new RelationalConditionInternal();
  cond.valueGetterParam = valueGetterParam;
  cond.valueParser = valueParser;
  cond.getValue = getters.getValue;
  cond.subCondList = subCondList;
  return cond;
}
function isObjectNotArray(val) {
  return isObject(val) && !isArrayLike(val);
}
var ConditionalExpressionParsed = class {
  constructor(exprOption, getters) {
    this._cond = parseOption(exprOption, getters);
  }
  evaluate() {
    return this._cond.evaluate();
  }
};
function parseConditionalExpression(exprOption, getters) {
  return new ConditionalExpressionParsed(exprOption, getters);
}

// src/component/transform/filterTransform.ts
var filterTransform = {
  type: "echarts:filter",
  transform: function(params) {
    const upstream = params.upstream;
    let rawItem;
    const condition = parseConditionalExpression(params.config, {
      valueGetterAttrMap: createHashMap({dimension: true}),
      prepareGetValue: function(exprOption) {
        let errMsg = "";
        const dimLoose = exprOption.dimension;
        if (!hasOwn(exprOption, "dimension")) {
          if (true) {
            errMsg = makePrintable('Relation condition must has prop "dimension" specified.', "Illegal condition:", exprOption);
          }
          throwError(errMsg);
        }
        const dimInfo = upstream.getDimensionInfo(dimLoose);
        if (!dimInfo) {
          if (true) {
            errMsg = makePrintable("Can not find dimension info via: " + dimLoose + ".\n", "Existing dimensions: ", upstream.cloneAllDimensionInfo(), ".\n", "Illegal condition:", exprOption, ".\n");
          }
          throwError(errMsg);
        }
        return {dimIdx: dimInfo.index};
      },
      getValue: function(param) {
        return upstream.retrieveValueFromItem(rawItem, param.dimIdx);
      }
    });
    const resultData = [];
    for (let i = 0, len2 = upstream.count(); i < len2; i++) {
      rawItem = upstream.getRawDataItem(i);
      if (condition.evaluate()) {
        resultData.push(rawItem);
      }
    }
    return {
      data: resultData
    };
  }
};

// src/component/transform/sortTransform.ts
var sampleLog = "";
if (true) {
  sampleLog = [
    "Valid config is like:",
    '{ dimension: "age", order: "asc" }',
    'or [{ dimension: "age", order: "asc"], { dimension: "date", order: "desc" }]'
  ].join(" ");
}
var sortTransform = {
  type: "echarts:sort",
  transform: function(params) {
    const upstream = params.upstream;
    const config = params.config;
    let errMsg = "";
    const orderExprList = normalizeToArray(config);
    if (!orderExprList.length) {
      if (true) {
        errMsg = "Empty `config` in sort transform.";
      }
      throwError(errMsg);
    }
    const orderDefList = [];
    each(orderExprList, function(orderExpr) {
      const dimLoose = orderExpr.dimension;
      const order = orderExpr.order;
      const parserName = orderExpr.parser;
      const incomparable = orderExpr.incomparable;
      if (dimLoose == null) {
        if (true) {
          errMsg = 'Sort transform config must has "dimension" specified.' + sampleLog;
        }
        throwError(errMsg);
      }
      if (order !== "asc" && order !== "desc") {
        if (true) {
          errMsg = 'Sort transform config must has "order" specified.' + sampleLog;
        }
        throwError(errMsg);
      }
      if (incomparable && (incomparable !== "min" && incomparable !== "max")) {
        let errMsg2 = "";
        if (true) {
          errMsg2 = 'incomparable must be "min" or "max" rather than "' + incomparable + '".';
        }
        throwError(errMsg2);
      }
      if (order !== "asc" && order !== "desc") {
        let errMsg2 = "";
        if (true) {
          errMsg2 = 'order must be "asc" or "desc" rather than "' + order + '".';
        }
        throwError(errMsg2);
      }
      const dimInfo = upstream.getDimensionInfo(dimLoose);
      if (!dimInfo) {
        if (true) {
          errMsg = makePrintable("Can not find dimension info via: " + dimLoose + ".\n", "Existing dimensions: ", upstream.cloneAllDimensionInfo(), ".\n", "Illegal config:", orderExpr, ".\n");
        }
        throwError(errMsg);
      }
      const parser = parserName ? getRawValueParser(parserName) : null;
      if (parserName && !parser) {
        if (true) {
          errMsg = makePrintable("Invalid parser name " + parserName + ".\n", "Illegal config:", orderExpr, ".\n");
        }
        throwError(errMsg);
      }
      orderDefList.push({
        dimIdx: dimInfo.index,
        parser,
        comparator: new SortOrderComparator(order, incomparable)
      });
    });
    const sourceFormat = upstream.sourceFormat;
    if (sourceFormat !== SOURCE_FORMAT_ARRAY_ROWS && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {
      if (true) {
        errMsg = 'sourceFormat "' + sourceFormat + '" is not supported yet';
      }
      throwError(errMsg);
    }
    const resultData = [];
    for (let i = 0, len2 = upstream.count(); i < len2; i++) {
      resultData.push(upstream.getRawDataItem(i));
    }
    resultData.sort(function(item0, item1) {
      for (let i = 0; i < orderDefList.length; i++) {
        const orderDef = orderDefList[i];
        let val0 = upstream.retrieveValueFromItem(item0, orderDef.dimIdx);
        let val1 = upstream.retrieveValueFromItem(item1, orderDef.dimIdx);
        if (orderDef.parser) {
          val0 = orderDef.parser(val0);
          val1 = orderDef.parser(val1);
        }
        const result = orderDef.comparator.evaluate(val0, val1);
        if (result !== 0) {
          return result;
        }
      }
      return 0;
    });
    return {
      data: resultData
    };
  }
};

// src/component/transform/install.ts
function install54(registers) {
  registers.registerTransform(filterTransform);
  registers.registerTransform(sortTransform);
}

// src/component/dataset/install.ts
var DatasetModel = class extends Component_default {
  constructor() {
    super(...arguments);
    this.type = "dataset";
  }
  init(option, parentModel, ecModel) {
    super.init(option, parentModel, ecModel);
    this._sourceManager = new SourceManager(this);
    disableTransformOptionMerge(this);
  }
  mergeOption(newOption, ecModel) {
    super.mergeOption(newOption, ecModel);
    disableTransformOptionMerge(this);
  }
  optionUpdated() {
    this._sourceManager.dirty();
  }
  getSourceManager() {
    return this._sourceManager;
  }
};
DatasetModel.type = "dataset";
DatasetModel.defaultOption = {
  seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN
};
var DatasetView = class extends Component_default2 {
  constructor() {
    super(...arguments);
    this.type = "dataset";
  }
};
DatasetView.type = "dataset";
function install55(registers) {
  registers.registerComponentModel(DatasetModel);
  registers.registerComponentView(DatasetView);
}

// node_modules/zrender/src/tool/convertPath.ts
var CMD5 = PathProxy_default.CMD;
function aroundEqual(a, b) {
  return Math.abs(a - b) < 1e-5;
}
function pathToBezierCurves(path) {
  const data = path.data;
  const len2 = path.len();
  const bezierArrayGroups = [];
  let currentSubpath;
  let xi = 0;
  let yi = 0;
  let x0 = 0;
  let y0 = 0;
  function createNewSubpath(x, y) {
    if (currentSubpath && currentSubpath.length > 2) {
      bezierArrayGroups.push(currentSubpath);
    }
    currentSubpath = [x, y];
  }
  function addLine(x02, y02, x12, y12) {
    if (!(aroundEqual(x02, x12) && aroundEqual(y02, y12))) {
      currentSubpath.push(x02, y02, x12, y12, x12, y12);
    }
  }
  function addArc(startAngle, endAngle, cx, cy, rx, ry) {
    const delta = Math.abs(endAngle - startAngle);
    const len3 = Math.tan(delta / 4) * 4 / 3;
    const dir3 = endAngle < startAngle ? -1 : 1;
    const c1 = Math.cos(startAngle);
    const s1 = Math.sin(startAngle);
    const c2 = Math.cos(endAngle);
    const s2 = Math.sin(endAngle);
    const x12 = c1 * rx + cx;
    const y12 = s1 * ry + cy;
    const x4 = c2 * rx + cx;
    const y4 = s2 * ry + cy;
    const hx = rx * len3 * dir3;
    const hy = ry * len3 * dir3;
    currentSubpath.push(x12 - hx * s1, y12 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);
  }
  let x1;
  let y1;
  let x2;
  let y2;
  for (let i = 0; i < len2; ) {
    const cmd = data[i++];
    const isFirst = i === 1;
    if (isFirst) {
      xi = data[i];
      yi = data[i + 1];
      x0 = xi;
      y0 = yi;
      if (cmd === CMD5.L || cmd === CMD5.C || cmd === CMD5.Q) {
        currentSubpath = [x0, y0];
      }
    }
    switch (cmd) {
      case CMD5.M:
        xi = x0 = data[i++];
        yi = y0 = data[i++];
        createNewSubpath(x0, y0);
        break;
      case CMD5.L:
        x1 = data[i++];
        y1 = data[i++];
        addLine(xi, yi, x1, y1);
        xi = x1;
        yi = y1;
        break;
      case CMD5.C:
        currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);
        break;
      case CMD5.Q:
        x1 = data[i++];
        y1 = data[i++];
        x2 = data[i++];
        y2 = data[i++];
        currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);
        xi = x2;
        yi = y2;
        break;
      case CMD5.A:
        const cx = data[i++];
        const cy = data[i++];
        const rx = data[i++];
        const ry = data[i++];
        const startAngle = data[i++];
        const endAngle = data[i++] + startAngle;
        i += 1;
        const anticlockwise = !data[i++];
        x1 = Math.cos(startAngle) * rx + cx;
        y1 = Math.sin(startAngle) * ry + cy;
        if (isFirst) {
          x0 = x1;
          y0 = y1;
          createNewSubpath(x0, y0);
        } else {
          addLine(xi, yi, x1, y1);
        }
        xi = Math.cos(endAngle) * rx + cx;
        yi = Math.sin(endAngle) * ry + cy;
        const step = (anticlockwise ? -1 : 1) * Math.PI / 2;
        for (let angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {
          const nextAngle = anticlockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);
          addArc(angle, nextAngle, cx, cy, rx, ry);
        }
        break;
      case CMD5.R:
        x0 = xi = data[i++];
        y0 = yi = data[i++];
        x1 = x0 + data[i++];
        y1 = y0 + data[i++];
        createNewSubpath(x1, y0);
        addLine(x1, y0, x1, y1);
        addLine(x1, y1, x0, y1);
        addLine(x0, y1, x0, y0);
        addLine(x0, y0, x1, y0);
        break;
      case CMD5.Z:
        currentSubpath && addLine(xi, yi, x0, y0);
        xi = x0;
        yi = y0;
        break;
    }
  }
  if (currentSubpath && currentSubpath.length > 2) {
    bezierArrayGroups.push(currentSubpath);
  }
  return bezierArrayGroups;
}
function adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, out2, scale4) {
  if (aroundEqual(x0, x1) && aroundEqual(y0, y1) && aroundEqual(x2, x3) && aroundEqual(y2, y3)) {
    out2.push(x3, y3);
    return;
  }
  const PIXEL_DISTANCE = 2 / scale4;
  const PIXEL_DISTANCE_SQR = PIXEL_DISTANCE * PIXEL_DISTANCE;
  let dx = x3 - x0;
  let dy = y3 - y0;
  const d = Math.sqrt(dx * dx + dy * dy);
  dx /= d;
  dy /= d;
  const dx1 = x1 - x0;
  const dy1 = y1 - y0;
  const dx2 = x2 - x3;
  const dy2 = y2 - y3;
  const cp1LenSqr = dx1 * dx1 + dy1 * dy1;
  const cp2LenSqr = dx2 * dx2 + dy2 * dy2;
  if (cp1LenSqr < PIXEL_DISTANCE_SQR && cp2LenSqr < PIXEL_DISTANCE_SQR) {
    out2.push(x3, y3);
    return;
  }
  const projLen1 = dx * dx1 + dy * dy1;
  const projLen2 = -dx * dx2 - dy * dy2;
  const d1Sqr = cp1LenSqr - projLen1 * projLen1;
  const d2Sqr = cp2LenSqr - projLen2 * projLen2;
  if (d1Sqr < PIXEL_DISTANCE_SQR && projLen1 >= 0 && d2Sqr < PIXEL_DISTANCE_SQR && projLen2 >= 0) {
    out2.push(x3, y3);
    return;
  }
  const tmpSegX = [];
  const tmpSegY = [];
  cubicSubdivide(x0, x1, x2, x3, 0.5, tmpSegX);
  cubicSubdivide(y0, y1, y2, y3, 0.5, tmpSegY);
  adpativeBezier(tmpSegX[0], tmpSegY[0], tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], tmpSegX[3], tmpSegY[3], out2, scale4);
  adpativeBezier(tmpSegX[4], tmpSegY[4], tmpSegX[5], tmpSegY[5], tmpSegX[6], tmpSegY[6], tmpSegX[7], tmpSegY[7], out2, scale4);
}
function pathToPolygons(path, scale4) {
  const bezierArrayGroups = pathToBezierCurves(path);
  const polygons = [];
  scale4 = scale4 || 1;
  for (let i = 0; i < bezierArrayGroups.length; i++) {
    const beziers = bezierArrayGroups[i];
    const polygon = [];
    let x0 = beziers[0];
    let y0 = beziers[1];
    polygon.push(x0, y0);
    for (let k = 2; k < beziers.length; ) {
      const x1 = beziers[k++];
      const y1 = beziers[k++];
      const x2 = beziers[k++];
      const y2 = beziers[k++];
      const x3 = beziers[k++];
      const y3 = beziers[k++];
      adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, polygon, scale4);
      x0 = x3;
      y0 = y3;
    }
    polygons.push(polygon);
  }
  return polygons;
}

// node_modules/zrender/src/tool/dividePath.ts
function getDividingGrids(dimSize, rowDim, count2) {
  const rowSize = dimSize[rowDim];
  const columnSize = dimSize[1 - rowDim];
  const ratio = Math.abs(rowSize / columnSize);
  let rowCount = Math.ceil(Math.sqrt(ratio * count2));
  let columnCount = Math.floor(count2 / rowCount);
  if (columnCount === 0) {
    columnCount = 1;
    rowCount = count2;
  }
  const grids = [];
  for (let i = 0; i < rowCount; i++) {
    grids.push(columnCount);
  }
  const currentCount = rowCount * columnCount;
  const remained = count2 - currentCount;
  if (remained > 0) {
    for (let i = 0; i < remained; i++) {
      grids[i % rowCount] += 1;
    }
  }
  return grids;
}
function divideSector(sectorShape, count2, outShapes) {
  const r0 = sectorShape.r0;
  const r = sectorShape.r;
  const startAngle = sectorShape.startAngle;
  const endAngle = sectorShape.endAngle;
  const angle = Math.abs(endAngle - startAngle);
  const arcLen = angle * r;
  const deltaR = r - r0;
  const isAngleRow = arcLen > Math.abs(deltaR);
  const grids = getDividingGrids([arcLen, deltaR], isAngleRow ? 0 : 1, count2);
  const rowSize = (isAngleRow ? angle : deltaR) / grids.length;
  for (let row = 0; row < grids.length; row++) {
    const columnSize = (isAngleRow ? deltaR : angle) / grids[row];
    for (let column = 0; column < grids[row]; column++) {
      const newShape = {};
      if (isAngleRow) {
        newShape.startAngle = startAngle + rowSize * row;
        newShape.endAngle = startAngle + rowSize * (row + 1);
        newShape.r0 = r0 + columnSize * column;
        newShape.r = r0 + columnSize * (column + 1);
      } else {
        newShape.startAngle = startAngle + columnSize * column;
        newShape.endAngle = startAngle + columnSize * (column + 1);
        newShape.r0 = r0 + rowSize * row;
        newShape.r = r0 + rowSize * (row + 1);
      }
      newShape.clockwise = sectorShape.clockwise;
      newShape.cx = sectorShape.cx;
      newShape.cy = sectorShape.cy;
      outShapes.push(newShape);
    }
  }
}
function divideRect(rectShape, count2, outShapes) {
  const width = rectShape.width;
  const height = rectShape.height;
  const isHorizontalRow = width > height;
  const grids = getDividingGrids([width, height], isHorizontalRow ? 0 : 1, count2);
  const rowSizeDim = isHorizontalRow ? "width" : "height";
  const columnSizeDim = isHorizontalRow ? "height" : "width";
  const rowDim = isHorizontalRow ? "x" : "y";
  const columnDim = isHorizontalRow ? "y" : "x";
  const rowSize = rectShape[rowSizeDim] / grids.length;
  for (let row = 0; row < grids.length; row++) {
    const columnSize = rectShape[columnSizeDim] / grids[row];
    for (let column = 0; column < grids[row]; column++) {
      const newShape = {};
      newShape[rowDim] = row * rowSize;
      newShape[columnDim] = column * columnSize;
      newShape[rowSizeDim] = rowSize;
      newShape[columnSizeDim] = columnSize;
      newShape.x += rectShape.x;
      newShape.y += rectShape.y;
      outShapes.push(newShape);
    }
  }
}
function crossProduct2d2(x1, y1, x2, y2) {
  return x1 * y2 - x2 * y1;
}
function lineLineIntersect2(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
  const mx = a2x - a1x;
  const my = a2y - a1y;
  const nx = b2x - b1x;
  const ny = b2y - b1y;
  const nmCrossProduct = crossProduct2d2(nx, ny, mx, my);
  if (Math.abs(nmCrossProduct) < 1e-6) {
    return null;
  }
  const b1a1x = a1x - b1x;
  const b1a1y = a1y - b1y;
  const p = crossProduct2d2(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
  if (p < 0 || p > 1) {
    return null;
  }
  return new Point_default(p * mx + a1x, p * my + a1y);
}
function projPtOnLine(pt, lineA, lineB) {
  const dir3 = new Point_default();
  Point_default.sub(dir3, lineB, lineA);
  dir3.normalize();
  const dir22 = new Point_default();
  Point_default.sub(dir22, pt, lineA);
  const len2 = dir22.dot(dir3);
  return len2;
}
function addToPoly(poly, pt) {
  const last = poly[poly.length - 1];
  if (last && last[0] === pt[0] && last[1] === pt[1]) {
    return;
  }
  poly.push(pt);
}
function splitPolygonByLine(points4, lineA, lineB) {
  const len2 = points4.length;
  const intersections = [];
  for (let i = 0; i < len2; i++) {
    const p0 = points4[i];
    const p1 = points4[(i + 1) % len2];
    const intersectionPt = lineLineIntersect2(p0[0], p0[1], p1[0], p1[1], lineA.x, lineA.y, lineB.x, lineB.y);
    if (intersectionPt) {
      intersections.push({
        projPt: projPtOnLine(intersectionPt, lineA, lineB),
        pt: intersectionPt,
        idx: i
      });
    }
  }
  if (intersections.length < 2) {
    return [{points: points4}, {points: points4}];
  }
  intersections.sort((a, b) => {
    return a.projPt - b.projPt;
  });
  let splitPt0 = intersections[0];
  let splitPt1 = intersections[intersections.length - 1];
  if (splitPt1.idx < splitPt0.idx) {
    const tmp = splitPt0;
    splitPt0 = splitPt1;
    splitPt1 = tmp;
  }
  const splitPt0Arr = [splitPt0.pt.x, splitPt0.pt.y];
  const splitPt1Arr = [splitPt1.pt.x, splitPt1.pt.y];
  const newPolyA = [splitPt0Arr];
  const newPolyB = [splitPt1Arr];
  for (let i = splitPt0.idx + 1; i <= splitPt1.idx; i++) {
    addToPoly(newPolyA, points4[i].slice());
  }
  addToPoly(newPolyA, splitPt1Arr);
  addToPoly(newPolyA, splitPt0Arr);
  for (let i = splitPt1.idx + 1; i <= splitPt0.idx + len2; i++) {
    addToPoly(newPolyB, points4[i % len2].slice());
  }
  addToPoly(newPolyB, splitPt0Arr);
  addToPoly(newPolyB, splitPt1Arr);
  return [{
    points: newPolyA
  }, {
    points: newPolyB
  }];
}
function binaryDividePolygon(polygonShape) {
  const points4 = polygonShape.points;
  const min3 = [];
  const max3 = [];
  fromPoints(points4, min3, max3);
  const boundingRect = new BoundingRect_default(min3[0], min3[1], max3[0] - min3[0], max3[1] - min3[1]);
  const width = boundingRect.width;
  const height = boundingRect.height;
  const x = boundingRect.x;
  const y = boundingRect.y;
  const pt02 = new Point_default();
  const pt12 = new Point_default();
  if (width > height) {
    pt02.x = pt12.x = x + width / 2;
    pt02.y = y;
    pt12.y = y + height;
  } else {
    pt02.y = pt12.y = y + height / 2;
    pt02.x = x;
    pt12.x = x + width;
  }
  return splitPolygonByLine(points4, pt02, pt12);
}
function binaryDivideRecursive(divider, shape, count2, out2) {
  if (count2 === 1) {
    out2.push(shape);
  } else {
    const mid = Math.floor(count2 / 2);
    const sub2 = divider(shape);
    binaryDivideRecursive(divider, sub2[0], mid, out2);
    binaryDivideRecursive(divider, sub2[1], count2 - mid, out2);
  }
  return out2;
}
function clone5(path, count2) {
  const paths = [];
  for (let i = 0; i < count2; i++) {
    paths.push(clonePath(path));
  }
  return paths;
}
function copyPathProps(source, target) {
  target.setStyle(source.style);
  target.z = source.z;
  target.z2 = source.z2;
  target.zlevel = source.zlevel;
}
function polygonConvert(points4) {
  const out2 = [];
  for (let i = 0; i < points4.length; ) {
    out2.push([points4[i++], points4[i++]]);
  }
  return out2;
}
function split(path, count2) {
  const outShapes = [];
  const shape = path.shape;
  let OutShapeCtor;
  switch (path.type) {
    case "rect":
      divideRect(shape, count2, outShapes);
      OutShapeCtor = Rect_default;
      break;
    case "sector":
      divideSector(shape, count2, outShapes);
      OutShapeCtor = Sector_default;
      break;
    case "circle":
      divideSector({
        r0: 0,
        r: shape.r,
        startAngle: 0,
        endAngle: Math.PI * 2,
        cx: shape.cx,
        cy: shape.cy
      }, count2, outShapes);
      OutShapeCtor = Sector_default;
      break;
    default:
      const m2 = path.getComputedTransform();
      const scale4 = m2 ? Math.sqrt(Math.max(m2[0] * m2[0] + m2[1] * m2[1], m2[2] * m2[2] + m2[3] * m2[3])) : 1;
      const polygons = map(pathToPolygons(path.getUpdatedPathProxy(), scale4), (poly) => polygonConvert(poly));
      const polygonCount = polygons.length;
      if (polygonCount === 0) {
        binaryDivideRecursive(binaryDividePolygon, {
          points: polygons[0]
        }, count2, outShapes);
      } else if (polygonCount === count2) {
        for (let i = 0; i < polygonCount; i++) {
          outShapes.push({
            points: polygons[i]
          });
        }
      } else {
        let totalArea = 0;
        const items = map(polygons, (poly) => {
          const min3 = [];
          const max3 = [];
          fromPoints(poly, min3, max3);
          const area = (max3[1] - min3[1]) * (max3[0] - min3[0]);
          totalArea += area;
          return {poly, area};
        });
        items.sort((a, b) => b.area - a.area);
        let left = count2;
        for (let i = 0; i < polygonCount; i++) {
          const item = items[i];
          if (left <= 0) {
            break;
          }
          const selfCount = i === polygonCount - 1 ? left : Math.ceil(item.area / totalArea * count2);
          if (selfCount < 0) {
            continue;
          }
          binaryDivideRecursive(binaryDividePolygon, {
            points: item.poly
          }, selfCount, outShapes);
          left -= selfCount;
        }
        ;
      }
      OutShapeCtor = Polygon_default;
      break;
  }
  if (!OutShapeCtor) {
    return clone5(path, count2);
  }
  const out2 = [];
  for (let i = 0; i < outShapes.length; i++) {
    const subPath = new OutShapeCtor();
    subPath.setShape(outShapes[i]);
    copyPathProps(path, subPath);
    out2.push(subPath);
  }
  return out2;
}

// node_modules/zrender/src/tool/morphPath.ts
function alignSubpath(subpath1, subpath2) {
  const len1 = subpath1.length;
  const len2 = subpath2.length;
  if (len1 === len2) {
    return [subpath1, subpath2];
  }
  const tmpSegX = [];
  const tmpSegY = [];
  const shorterPath = len1 < len2 ? subpath1 : subpath2;
  const shorterLen = Math.min(len1, len2);
  const diff = Math.abs(len2 - len1) / 6;
  const shorterBezierCount = (shorterLen - 2) / 6;
  const eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;
  const newSubpath = [shorterPath[0], shorterPath[1]];
  let remained = diff;
  for (let i = 2; i < shorterLen; ) {
    let x0 = shorterPath[i - 2];
    let y0 = shorterPath[i - 1];
    let x1 = shorterPath[i++];
    let y1 = shorterPath[i++];
    let x2 = shorterPath[i++];
    let y2 = shorterPath[i++];
    let x3 = shorterPath[i++];
    let y3 = shorterPath[i++];
    if (remained <= 0) {
      newSubpath.push(x1, y1, x2, y2, x3, y3);
      continue;
    }
    let actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;
    for (let k = 1; k <= actualSubDivCount; k++) {
      const p = k / actualSubDivCount;
      cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);
      cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);
      x0 = tmpSegX[3];
      y0 = tmpSegY[3];
      newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);
      x1 = tmpSegX[5];
      y1 = tmpSegY[5];
      x2 = tmpSegX[6];
      y2 = tmpSegY[6];
    }
    remained -= actualSubDivCount - 1;
  }
  return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];
}
function createSubpath(lastSubpathSubpath, otherSubpath) {
  const len2 = lastSubpathSubpath.length;
  const lastX = lastSubpathSubpath[len2 - 2];
  const lastY = lastSubpathSubpath[len2 - 1];
  const newSubpath = [];
  for (let i = 0; i < otherSubpath.length; ) {
    newSubpath[i++] = lastX;
    newSubpath[i++] = lastY;
  }
  return newSubpath;
}
function alignBezierCurves(array1, array2) {
  let lastSubpath1;
  let lastSubpath2;
  let newArray1 = [];
  let newArray2 = [];
  for (let i = 0; i < Math.max(array1.length, array2.length); i++) {
    const subpath1 = array1[i];
    const subpath2 = array2[i];
    let newSubpath1;
    let newSubpath2;
    if (!subpath1) {
      newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);
      newSubpath2 = subpath2;
    } else if (!subpath2) {
      newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);
      newSubpath1 = subpath1;
    } else {
      [newSubpath1, newSubpath2] = alignSubpath(subpath1, subpath2);
      lastSubpath1 = newSubpath1;
      lastSubpath2 = newSubpath2;
    }
    newArray1.push(newSubpath1);
    newArray2.push(newSubpath2);
  }
  return [newArray1, newArray2];
}
function centroid2(array) {
  let signedArea = 0;
  let cx = 0;
  let cy = 0;
  const len2 = array.length;
  for (let i = 0, j = len2 - 2; i < len2; j = i, i += 2) {
    const x0 = array[j];
    const y0 = array[j + 1];
    const x1 = array[i];
    const y1 = array[i + 1];
    const a = x0 * y1 - x1 * y0;
    signedArea += a;
    cx += (x0 + x1) * a;
    cy += (y0 + y1) * a;
  }
  if (signedArea === 0) {
    return [array[0] || 0, array[1] || 0];
  }
  return [cx / signedArea / 3, cy / signedArea / 3, signedArea];
}
function findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {
  const bezierCount = (fromSubBeziers.length - 2) / 6;
  let bestScore = Infinity;
  let bestOffset = 0;
  const len2 = fromSubBeziers.length;
  const len22 = len2 - 2;
  for (let offset = 0; offset < bezierCount; offset++) {
    const cursorOffset = offset * 6;
    let score = 0;
    for (let k = 0; k < len2; k += 2) {
      let idx = k === 0 ? cursorOffset : (cursorOffset + k - 2) % len22 + 2;
      const x0 = fromSubBeziers[idx] - fromCp[0];
      const y0 = fromSubBeziers[idx + 1] - fromCp[1];
      const x1 = toSubBeziers[k] - toCp[0];
      const y1 = toSubBeziers[k + 1] - toCp[1];
      const dx = x1 - x0;
      const dy = y1 - y0;
      score += dx * dx + dy * dy;
    }
    if (score < bestScore) {
      bestScore = score;
      bestOffset = offset;
    }
  }
  return bestOffset;
}
function reverse(array) {
  const newArr = [];
  const len2 = array.length;
  for (let i = 0; i < len2; i += 2) {
    newArr[i] = array[len2 - i - 2];
    newArr[i + 1] = array[len2 - i - 1];
  }
  return newArr;
}
function findBestMorphingRotation(fromArr, toArr2, searchAngleIteration, searchAngleRange) {
  const result = [];
  let fromNeedsReverse;
  for (let i = 0; i < fromArr.length; i++) {
    let fromSubpathBezier = fromArr[i];
    const toSubpathBezier = toArr2[i];
    const fromCp = centroid2(fromSubpathBezier);
    const toCp = centroid2(toSubpathBezier);
    if (fromNeedsReverse == null) {
      fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;
    }
    const newFromSubpathBezier = [];
    const newToSubpathBezier = [];
    let bestAngle = 0;
    let bestScore = Infinity;
    let tmpArr2 = [];
    const len2 = fromSubpathBezier.length;
    if (fromNeedsReverse) {
      fromSubpathBezier = reverse(fromSubpathBezier);
    }
    const offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;
    const len22 = len2 - 2;
    for (let k = 0; k < len22; k += 2) {
      const idx = (offset + k) % len22 + 2;
      newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];
      newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];
    }
    newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];
    newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];
    if (searchAngleIteration > 0) {
      const step = searchAngleRange / searchAngleIteration;
      for (let angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {
        const sa = Math.sin(angle);
        const ca = Math.cos(angle);
        let score = 0;
        for (let k = 0; k < fromSubpathBezier.length; k += 2) {
          const x0 = newFromSubpathBezier[k];
          const y0 = newFromSubpathBezier[k + 1];
          const x1 = toSubpathBezier[k] - toCp[0];
          const y1 = toSubpathBezier[k + 1] - toCp[1];
          const newX1 = x1 * ca - y1 * sa;
          const newY1 = x1 * sa + y1 * ca;
          tmpArr2[k] = newX1;
          tmpArr2[k + 1] = newY1;
          const dx = newX1 - x0;
          const dy = newY1 - y0;
          score += dx * dx + dy * dy;
        }
        if (score < bestScore) {
          bestScore = score;
          bestAngle = angle;
          for (let m2 = 0; m2 < tmpArr2.length; m2++) {
            newToSubpathBezier[m2] = tmpArr2[m2];
          }
        }
      }
    } else {
      for (let i2 = 0; i2 < len2; i2 += 2) {
        newToSubpathBezier[i2] = toSubpathBezier[i2] - toCp[0];
        newToSubpathBezier[i2 + 1] = toSubpathBezier[i2 + 1] - toCp[1];
      }
    }
    result.push({
      from: newFromSubpathBezier,
      to: newToSubpathBezier,
      fromCp,
      toCp,
      rotation: -bestAngle
    });
  }
  return result;
}
function isCombineMorphing(path) {
  return path.__isCombineMorphing;
}
var SAVED_METHOD_PREFIX = "__mOriginal_";
function saveAndModifyMethod(obj, methodName, modifiers) {
  const savedMethodName = SAVED_METHOD_PREFIX + methodName;
  const originalMethod = obj[savedMethodName] || obj[methodName];
  if (!obj[savedMethodName]) {
    obj[savedMethodName] = obj[methodName];
  }
  const replace = modifiers.replace;
  const after = modifiers.after;
  const before = modifiers.before;
  obj[methodName] = function() {
    const args = arguments;
    let res;
    before && before.apply(this, args);
    if (replace) {
      res = replace.apply(this, args);
    } else {
      res = originalMethod.apply(this, args);
    }
    after && after.apply(this, args);
    return res;
  };
}
function restoreMethod(obj, methodName) {
  const savedMethodName = SAVED_METHOD_PREFIX + methodName;
  if (obj[savedMethodName]) {
    obj[methodName] = obj[savedMethodName];
    obj[savedMethodName] = null;
  }
}
function applyTransformOnBeziers(bezierCurves, mm) {
  for (let i = 0; i < bezierCurves.length; i++) {
    const subBeziers = bezierCurves[i];
    for (let k = 0; k < subBeziers.length; ) {
      const x = subBeziers[k];
      const y = subBeziers[k + 1];
      subBeziers[k++] = mm[0] * x + mm[2] * y + mm[4];
      subBeziers[k++] = mm[1] * x + mm[3] * y + mm[5];
    }
  }
}
function prepareMorphPath(fromPath, toPath) {
  const fromPathProxy = fromPath.getUpdatedPathProxy();
  const toPathProxy = toPath.getUpdatedPathProxy();
  const [fromBezierCurves, toBezierCurves] = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy));
  const fromPathTransform = fromPath.getComputedTransform();
  const toPathTransform = toPath.getComputedTransform();
  function updateIdentityTransform() {
    this.transform = null;
  }
  fromPathTransform && applyTransformOnBeziers(fromBezierCurves, fromPathTransform);
  toPathTransform && applyTransformOnBeziers(toBezierCurves, toPathTransform);
  saveAndModifyMethod(toPath, "updateTransform", {replace: updateIdentityTransform});
  toPath.transform = null;
  const morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);
  const tmpArr2 = [];
  saveAndModifyMethod(toPath, "buildPath", {replace(path) {
    const t = toPath.__morphT;
    const onet = 1 - t;
    const newCp = [];
    for (let i = 0; i < morphingData.length; i++) {
      const item = morphingData[i];
      const from = item.from;
      const to = item.to;
      const angle = item.rotation * t;
      const fromCp = item.fromCp;
      const toCp = item.toCp;
      const sa = Math.sin(angle);
      const ca = Math.cos(angle);
      lerp(newCp, fromCp, toCp, t);
      for (let m2 = 0; m2 < from.length; m2 += 2) {
        const x02 = from[m2];
        const y02 = from[m2 + 1];
        const x1 = to[m2];
        const y1 = to[m2 + 1];
        const x = x02 * onet + x1 * t;
        const y = y02 * onet + y1 * t;
        tmpArr2[m2] = x * ca - y * sa + newCp[0];
        tmpArr2[m2 + 1] = x * sa + y * ca + newCp[1];
      }
      let x0 = tmpArr2[0];
      let y0 = tmpArr2[1];
      path.moveTo(x0, y0);
      for (let m2 = 2; m2 < from.length; ) {
        const x1 = tmpArr2[m2++];
        const y1 = tmpArr2[m2++];
        const x2 = tmpArr2[m2++];
        const y2 = tmpArr2[m2++];
        const x3 = tmpArr2[m2++];
        const y3 = tmpArr2[m2++];
        if (x0 === x1 && y0 === y1 && x2 === x3 && y2 === y3) {
          path.lineTo(x3, y3);
        } else {
          path.bezierCurveTo(x1, y1, x2, y2, x3, y3);
        }
        x0 = x3;
        y0 = y3;
      }
    }
  }});
}
function morphPath(fromPath, toPath, animationOpts) {
  if (!fromPath || !toPath) {
    return toPath;
  }
  const oldDone = animationOpts.done;
  const oldDuring = animationOpts.during;
  prepareMorphPath(fromPath, toPath);
  toPath.__morphT = 0;
  function restoreToPath() {
    restoreMethod(toPath, "buildPath");
    restoreMethod(toPath, "updateTransform");
    toPath.__morphT = -1;
    toPath.createPathProxy();
    toPath.dirtyShape();
  }
  toPath.animateTo({
    __morphT: 1
  }, defaults({
    during(p) {
      toPath.dirtyShape();
      oldDuring && oldDuring(p);
    },
    done() {
      restoreToPath();
      oldDone && oldDone();
    }
  }, animationOpts));
  return toPath;
}
function hilbert(x, y, minX, minY, maxX, maxY) {
  const bits = 16;
  x = maxX === minX ? 0 : Math.round(32767 * (x - minX) / (maxX - minX));
  y = maxY === minY ? 0 : Math.round(32767 * (y - minY) / (maxY - minY));
  let d = 0;
  let tmp;
  for (let s = (1 << bits) / 2; s > 0; s /= 2) {
    let rx = 0;
    let ry = 0;
    if ((x & s) > 0) {
      rx = 1;
    }
    if ((y & s) > 0) {
      ry = 1;
    }
    d += s * s * (3 * rx ^ ry);
    if (ry === 0) {
      if (rx === 1) {
        x = s - 1 - x;
        y = s - 1 - y;
      }
      tmp = x;
      x = y;
      y = tmp;
    }
  }
  return d;
}
function sortPaths(pathList) {
  let xMin = Infinity;
  let yMin = Infinity;
  let xMax = -Infinity;
  let yMax = -Infinity;
  const cps = map(pathList, (path) => {
    const rect = path.getBoundingRect();
    const m2 = path.getComputedTransform();
    const x = rect.x + rect.width / 2 + (m2 ? m2[4] : 0);
    const y = rect.y + rect.height / 2 + (m2 ? m2[5] : 0);
    xMin = Math.min(x, xMin);
    yMin = Math.min(y, yMin);
    xMax = Math.max(x, xMax);
    yMax = Math.max(y, yMax);
    return [x, y];
  });
  const items = map(cps, (cp, idx) => {
    return {
      cp,
      z: hilbert(cp[0], cp[1], xMin, yMin, xMax, yMax),
      path: pathList[idx]
    };
  });
  return items.sort((a, b) => a.z - b.z).map((item) => item.path);
}
function defaultDividePath(param) {
  return split(param.path, param.count);
}
function createEmptyReturn() {
  return {
    fromIndividuals: [],
    toIndividuals: [],
    count: 0
  };
}
function combineMorph(fromList, toPath, animationOpts) {
  let fromPathList = [];
  function addFromPath(fromList2) {
    for (let i = 0; i < fromList2.length; i++) {
      const from = fromList2[i];
      if (isCombineMorphing(from)) {
        addFromPath(from.childrenRef());
      } else if (from instanceof Path_default) {
        fromPathList.push(from);
      }
    }
  }
  addFromPath(fromList);
  const separateCount = fromPathList.length;
  if (!separateCount) {
    return createEmptyReturn();
  }
  const dividePath = animationOpts.dividePath || defaultDividePath;
  let toSubPathList = dividePath({
    path: toPath,
    count: separateCount
  });
  if (toSubPathList.length !== separateCount) {
    console.error("Invalid morphing: unmatched splitted path");
    return createEmptyReturn();
  }
  fromPathList = sortPaths(fromPathList);
  toSubPathList = sortPaths(toSubPathList);
  const oldDone = animationOpts.done;
  const oldDuring = animationOpts.during;
  const individualDelay = animationOpts.individualDelay;
  const identityTransform = new Transformable_default();
  for (let i = 0; i < separateCount; i++) {
    const from = fromPathList[i];
    const to = toSubPathList[i];
    to.parent = toPath;
    to.copyTransform(identityTransform);
    if (!individualDelay) {
      prepareMorphPath(from, to);
    }
  }
  toPath.__isCombineMorphing = true;
  toPath.childrenRef = function() {
    return toSubPathList;
  };
  function addToSubPathListToZr(zr) {
    for (let i = 0; i < toSubPathList.length; i++) {
      toSubPathList[i].addSelfToZr(zr);
    }
  }
  saveAndModifyMethod(toPath, "addSelfToZr", {
    after(zr) {
      addToSubPathListToZr(zr);
    }
  });
  saveAndModifyMethod(toPath, "removeSelfFromZr", {
    after(zr) {
      for (let i = 0; i < toSubPathList.length; i++) {
        toSubPathList[i].removeSelfFromZr(zr);
      }
    }
  });
  function restoreToPath() {
    toPath.__isCombineMorphing = false;
    toPath.__morphT = -1;
    toPath.childrenRef = null;
    restoreMethod(toPath, "addSelfToZr");
    restoreMethod(toPath, "removeSelfFromZr");
  }
  const toLen = toSubPathList.length;
  if (individualDelay) {
    let animating = toLen;
    const eachDone = () => {
      animating--;
      if (animating === 0) {
        restoreToPath();
        oldDone && oldDone();
      }
    };
    for (let i = 0; i < toLen; i++) {
      const indivdualAnimationOpts = individualDelay ? defaults({
        delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toSubPathList[i]),
        done: eachDone
      }, animationOpts) : animationOpts;
      morphPath(fromPathList[i], toSubPathList[i], indivdualAnimationOpts);
    }
  } else {
    toPath.__morphT = 0;
    toPath.animateTo({
      __morphT: 1
    }, defaults({
      during(p) {
        for (let i = 0; i < toLen; i++) {
          const child = toSubPathList[i];
          child.__morphT = toPath.__morphT;
          child.dirtyShape();
        }
        oldDuring && oldDuring(p);
      },
      done() {
        restoreToPath();
        for (let i = 0; i < fromList.length; i++) {
          restoreMethod(fromList[i], "updateTransform");
        }
        oldDone && oldDone();
      }
    }, animationOpts));
  }
  if (toPath.__zr) {
    addToSubPathListToZr(toPath.__zr);
  }
  return {
    fromIndividuals: fromPathList,
    toIndividuals: toSubPathList,
    count: toLen
  };
}
function separateMorph(fromPath, toPathList, animationOpts) {
  const toLen = toPathList.length;
  let fromPathList = [];
  const dividePath = animationOpts.dividePath || defaultDividePath;
  function addFromPath(fromList) {
    for (let i = 0; i < fromList.length; i++) {
      const from = fromList[i];
      if (isCombineMorphing(from)) {
        addFromPath(from.childrenRef());
      } else if (from instanceof Path_default) {
        fromPathList.push(from);
      }
    }
  }
  if (isCombineMorphing(fromPath)) {
    addFromPath(fromPath.childrenRef());
    const fromLen = fromPathList.length;
    if (fromLen < toLen) {
      let k = 0;
      for (let i = fromLen; i < toLen; i++) {
        fromPathList.push(clonePath(fromPathList[k++ % fromLen]));
      }
    }
    fromPathList.length = toLen;
  } else {
    fromPathList = dividePath({path: fromPath, count: toLen});
    const fromPathTransform = fromPath.getComputedTransform();
    for (let i = 0; i < fromPathList.length; i++) {
      fromPathList[i].setLocalTransform(fromPathTransform);
    }
    if (fromPathList.length !== toLen) {
      console.error("Invalid morphing: unmatched splitted path");
      return createEmptyReturn();
    }
  }
  fromPathList = sortPaths(fromPathList);
  toPathList = sortPaths(toPathList);
  const individualDelay = animationOpts.individualDelay;
  for (let i = 0; i < toLen; i++) {
    const indivdualAnimationOpts = individualDelay ? defaults({
      delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toPathList[i])
    }, animationOpts) : animationOpts;
    morphPath(fromPathList[i], toPathList[i], indivdualAnimationOpts);
  }
  return {
    fromIndividuals: fromPathList,
    toIndividuals: toPathList,
    count: toPathList.length
  };
}

// src/animation/morphTransitionHelper.ts
function isMultiple(elements) {
  return isArray(elements[0]);
}
function prepareMorphBatches(one, many) {
  const batches = [];
  const batchCount = one.length;
  for (let i = 0; i < batchCount; i++) {
    batches.push({
      one: one[i],
      many: []
    });
  }
  for (let i = 0; i < many.length; i++) {
    const len2 = many[i].length;
    let k;
    for (k = 0; k < len2; k++) {
      batches[k % batchCount].many.push(many[i][k]);
    }
  }
  let off = 0;
  for (let i = batchCount - 1; i >= 0; i--) {
    if (!batches[i].many.length) {
      const moveFrom = batches[off].many;
      if (moveFrom.length <= 1) {
        if (off) {
          off = 0;
        } else {
          return batches;
        }
      }
      const len2 = moveFrom.length;
      const mid = Math.ceil(len2 / 2);
      batches[i].many = moveFrom.slice(mid, len2);
      batches[off].many = moveFrom.slice(0, mid);
      off++;
    }
  }
  return batches;
}
var pathDividers = {
  clone(params) {
    const ret = [];
    const approxOpacity = 1 - Math.pow(1 - params.path.style.opacity, 1 / params.count);
    for (let i = 0; i < params.count; i++) {
      const cloned = clonePath(params.path);
      cloned.setStyle("opacity", approxOpacity);
      ret.push(cloned);
    }
    return ret;
  },
  split: null
};
function applyMorphAnimation(from, to, divideShape, seriesModel, dataIndex, animateOtherProps) {
  if (!from.length || !to.length) {
    return;
  }
  const updateAnimationCfg = getAnimationConfig("update", seriesModel, dataIndex);
  if (!(updateAnimationCfg && updateAnimationCfg.duration > 0)) {
    return;
  }
  const animationDelay = seriesModel.getModel("universalTransition").get("delay");
  const animationCfg = Object.assign({
    setToFinal: true
  }, updateAnimationCfg);
  let many;
  let one;
  if (isMultiple(from)) {
    many = from;
    one = to;
  }
  if (isMultiple(to)) {
    many = to;
    one = from;
  }
  function morphOneBatch(batch, fromIsMany2, animateIndex2, animateCount2, forceManyOne) {
    const batchMany = batch.many;
    const batchOne = batch.one;
    if (batchMany.length === 1 && !forceManyOne) {
      const batchFrom = fromIsMany2 ? batchMany[0] : batchOne;
      const batchTo = fromIsMany2 ? batchOne : batchMany[0];
      if (isCombineMorphing(batchFrom)) {
        morphOneBatch({
          many: [batchFrom],
          one: batchTo
        }, true, animateIndex2, animateCount2, true);
      } else {
        const individualAnimationCfg = animationDelay ? defaults({
          delay: animationDelay(animateIndex2, animateCount2)
        }, animationCfg) : animationCfg;
        morphPath(batchFrom, batchTo, individualAnimationCfg);
        animateOtherProps(batchFrom, batchTo, batchFrom, batchTo, individualAnimationCfg);
      }
    } else {
      const separateAnimationCfg = defaults({
        dividePath: pathDividers[divideShape],
        individualDelay: animationDelay && function(idx, count3, fromPath, toPath) {
          return animationDelay(idx + animateIndex2, animateCount2);
        }
      }, animationCfg);
      const {
        fromIndividuals,
        toIndividuals
      } = fromIsMany2 ? combineMorph(batchMany, batchOne, separateAnimationCfg) : separateMorph(batchOne, batchMany, separateAnimationCfg);
      const count2 = fromIndividuals.length;
      for (let k = 0; k < count2; k++) {
        const individualAnimationCfg = animationDelay ? defaults({
          delay: animationDelay(k, count2)
        }, animationCfg) : animationCfg;
        animateOtherProps(fromIndividuals[k], toIndividuals[k], fromIsMany2 ? batchMany[k] : batch.one, fromIsMany2 ? batch.one : batchMany[k], individualAnimationCfg);
      }
    }
  }
  const fromIsMany = many ? many === from : from.length > to.length;
  const morphBatches = many ? prepareMorphBatches(one, many) : prepareMorphBatches(fromIsMany ? to : from, [fromIsMany ? from : to]);
  let animateCount = 0;
  for (let i = 0; i < morphBatches.length; i++) {
    animateCount += morphBatches[i].many.length;
  }
  let animateIndex = 0;
  for (let i = 0; i < morphBatches.length; i++) {
    morphOneBatch(morphBatches[i], fromIsMany, animateIndex, animateCount);
    animateIndex += morphBatches[i].many.length;
  }
}
function getPathList(elements) {
  if (!elements) {
    return [];
  }
  if (isArray(elements)) {
    const pathList2 = [];
    for (let i = 0; i < elements.length; i++) {
      pathList2.push(getPathList(elements[i]));
    }
    return pathList2;
  }
  const pathList = [];
  elements.traverse((el) => {
    if (el instanceof Path_default && !el.disableMorphing && !el.invisible && !el.ignore) {
      pathList.push(el);
    }
  });
  return pathList;
}

// src/animation/universalTransition.ts
var DATA_COUNT_THRESHOLD = 1e4;
var TRANSITION_NONE = 0;
var TRANSITION_P2C = 1;
var TRANSITION_C2P = 2;
var getUniversalTransitionGlobalStore = makeInner();
function getDimension(data, visualDimension) {
  const dimensions = data.dimensions;
  for (let i = 0; i < dimensions.length; i++) {
    const dimInfo = data.getDimensionInfo(dimensions[i]);
    if (dimInfo && dimInfo.otherDims[visualDimension] === 0) {
      return dimensions[i];
    }
  }
}
function getValueByDimension(data, dataIndex, dimension) {
  const dimInfo = data.getDimensionInfo(dimension);
  const dimOrdinalMeta = dimInfo && dimInfo.ordinalMeta;
  if (dimInfo) {
    const value = data.get(dimInfo.name, dataIndex);
    if (dimOrdinalMeta) {
      return dimOrdinalMeta.categories[value] || value + "";
    }
    return value + "";
  }
}
function getGroupId(data, dataIndex, dataGroupId, isChild) {
  const visualDimension = isChild ? "itemChildGroupId" : "itemGroupId";
  const groupIdDim = getDimension(data, visualDimension);
  if (groupIdDim) {
    const groupId = getValueByDimension(data, dataIndex, groupIdDim);
    return groupId;
  }
  const rawDataItem = data.getRawDataItem(dataIndex);
  const property = isChild ? "childGroupId" : "groupId";
  if (rawDataItem && rawDataItem[property]) {
    return rawDataItem[property] + "";
  }
  if (isChild) {
    return;
  }
  return dataGroupId || data.getId(dataIndex);
}
function flattenDataDiffItems(list) {
  const items = [];
  each(list, (seriesInfo) => {
    const data = seriesInfo.data;
    const dataGroupId = seriesInfo.dataGroupId;
    if (data.count() > DATA_COUNT_THRESHOLD) {
      if (true) {
        warn("Universal transition is disabled on large data > 10k.");
      }
      return;
    }
    const indices = data.getIndices();
    for (let dataIndex = 0; dataIndex < indices.length; dataIndex++) {
      items.push({
        data,
        groupId: getGroupId(data, dataIndex, dataGroupId, false),
        childGroupId: getGroupId(data, dataIndex, dataGroupId, true),
        divide: seriesInfo.divide,
        dataIndex
      });
    }
  });
  return items;
}
function fadeInElement(newEl2, newSeries, newIndex) {
  newEl2.traverse((el) => {
    if (el instanceof Path_default) {
      initProps(el, {
        style: {
          opacity: 0
        }
      }, newSeries, {
        dataIndex: newIndex,
        isFrom: true
      });
    }
  });
}
function removeEl2(el) {
  if (el.parent) {
    const computedTransform = el.getComputedTransform();
    el.setLocalTransform(computedTransform);
    el.parent.remove(el);
  }
}
function stopAnimation(el) {
  el.stopAnimation();
  if (el.isGroup) {
    el.traverse((child) => {
      child.stopAnimation();
    });
  }
}
function animateElementStyles(el, dataIndex, seriesModel) {
  const animationConfig = getAnimationConfig("update", seriesModel, dataIndex);
  animationConfig && el.traverse((child) => {
    if (child instanceof Displayable_default) {
      const oldStyle = getOldStyle(child);
      if (oldStyle) {
        child.animateFrom({
          style: oldStyle
        }, animationConfig);
      }
    }
  });
}
function isAllIdSame(oldDiffItems, newDiffItems) {
  const len2 = oldDiffItems.length;
  if (len2 !== newDiffItems.length) {
    return false;
  }
  for (let i = 0; i < len2; i++) {
    const oldItem = oldDiffItems[i];
    const newItem = newDiffItems[i];
    if (oldItem.data.getId(oldItem.dataIndex) !== newItem.data.getId(newItem.dataIndex)) {
      return false;
    }
  }
  return true;
}
function transitionBetween(oldList, newList, api2) {
  const oldDiffItems = flattenDataDiffItems(oldList);
  const newDiffItems = flattenDataDiffItems(newList);
  function updateMorphingPathProps(from, to, rawFrom, rawTo, animationCfg) {
    if (rawFrom || from) {
      to.animateFrom({
        style: rawFrom && rawFrom !== from ? extend(extend({}, rawFrom.style), from.style) : from.style
      }, animationCfg);
    }
  }
  let hasMorphAnimation = false;
  let direction = TRANSITION_NONE;
  const oldGroupIds = createHashMap();
  const oldChildGroupIds = createHashMap();
  oldDiffItems.forEach((item) => {
    item.groupId && oldGroupIds.set(item.groupId, true);
    item.childGroupId && oldChildGroupIds.set(item.childGroupId, true);
  });
  for (let i = 0; i < newDiffItems.length; i++) {
    const newGroupId = newDiffItems[i].groupId;
    if (oldChildGroupIds.get(newGroupId)) {
      direction = TRANSITION_P2C;
      break;
    }
    const newChildGroupId = newDiffItems[i].childGroupId;
    if (newChildGroupId && oldGroupIds.get(newChildGroupId)) {
      direction = TRANSITION_C2P;
      break;
    }
  }
  function createKeyGetter(isOld, onlyGetId) {
    return function(diffItem) {
      const data = diffItem.data;
      const dataIndex = diffItem.dataIndex;
      if (onlyGetId) {
        return data.getId(dataIndex);
      }
      if (isOld) {
        return direction === TRANSITION_P2C ? diffItem.childGroupId : diffItem.groupId;
      } else {
        return direction === TRANSITION_C2P ? diffItem.childGroupId : diffItem.groupId;
      }
    };
  }
  const useId = isAllIdSame(oldDiffItems, newDiffItems);
  const isElementStillInChart = {};
  if (!useId) {
    for (let i = 0; i < newDiffItems.length; i++) {
      const newItem = newDiffItems[i];
      const el = newItem.data.getItemGraphicEl(newItem.dataIndex);
      if (el) {
        isElementStillInChart[el.id] = true;
      }
    }
  }
  function updateOneToOne(newIndex, oldIndex) {
    const oldItem = oldDiffItems[oldIndex];
    const newItem = newDiffItems[newIndex];
    const newSeries = newItem.data.hostModel;
    const oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);
    const newEl2 = newItem.data.getItemGraphicEl(newItem.dataIndex);
    if (oldEl === newEl2) {
      newEl2 && animateElementStyles(newEl2, newItem.dataIndex, newSeries);
      return;
    }
    if (oldEl && isElementStillInChart[oldEl.id]) {
      return;
    }
    if (newEl2) {
      stopAnimation(newEl2);
      if (oldEl) {
        stopAnimation(oldEl);
        removeEl2(oldEl);
        hasMorphAnimation = true;
        applyMorphAnimation(getPathList(oldEl), getPathList(newEl2), newItem.divide, newSeries, newIndex, updateMorphingPathProps);
      } else {
        fadeInElement(newEl2, newSeries, newIndex);
      }
    }
  }
  new DataDiffer_default(oldDiffItems, newDiffItems, createKeyGetter(true, useId), createKeyGetter(false, useId), null, "multiple").update(updateOneToOne).updateManyToOne(function(newIndex, oldIndices) {
    const newItem = newDiffItems[newIndex];
    const newData = newItem.data;
    const newSeries = newData.hostModel;
    const newEl2 = newData.getItemGraphicEl(newItem.dataIndex);
    const oldElsList = filter(map(oldIndices, (idx) => oldDiffItems[idx].data.getItemGraphicEl(oldDiffItems[idx].dataIndex)), (oldEl) => oldEl && oldEl !== newEl2 && !isElementStillInChart[oldEl.id]);
    if (newEl2) {
      stopAnimation(newEl2);
      if (oldElsList.length) {
        each(oldElsList, (oldEl) => {
          stopAnimation(oldEl);
          removeEl2(oldEl);
        });
        hasMorphAnimation = true;
        applyMorphAnimation(getPathList(oldElsList), getPathList(newEl2), newItem.divide, newSeries, newIndex, updateMorphingPathProps);
      } else {
        fadeInElement(newEl2, newSeries, newItem.dataIndex);
      }
    }
  }).updateOneToMany(function(newIndices, oldIndex) {
    const oldItem = oldDiffItems[oldIndex];
    const oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex);
    if (oldEl && isElementStillInChart[oldEl.id]) {
      return;
    }
    const newElsList = filter(map(newIndices, (idx) => newDiffItems[idx].data.getItemGraphicEl(newDiffItems[idx].dataIndex)), (el) => el && el !== oldEl);
    const newSeris = newDiffItems[newIndices[0]].data.hostModel;
    if (newElsList.length) {
      each(newElsList, (newEl2) => stopAnimation(newEl2));
      if (oldEl) {
        stopAnimation(oldEl);
        removeEl2(oldEl);
        hasMorphAnimation = true;
        applyMorphAnimation(getPathList(oldEl), getPathList(newElsList), oldItem.divide, newSeris, newIndices[0], updateMorphingPathProps);
      } else {
        each(newElsList, (newEl2) => fadeInElement(newEl2, newSeris, newIndices[0]));
      }
    }
  }).updateManyToMany(function(newIndices, oldIndices) {
    new DataDiffer_default(oldIndices, newIndices, (rawIdx) => oldDiffItems[rawIdx].data.getId(oldDiffItems[rawIdx].dataIndex), (rawIdx) => newDiffItems[rawIdx].data.getId(newDiffItems[rawIdx].dataIndex)).update((newIndex, oldIndex) => {
      updateOneToOne(newIndices[newIndex], oldIndices[oldIndex]);
    }).execute();
  }).execute();
  if (hasMorphAnimation) {
    each(newList, ({data}) => {
      const seriesModel = data.hostModel;
      const view = seriesModel && api2.getViewOfSeriesModel(seriesModel);
      const animationCfg = getAnimationConfig("update", seriesModel, 0);
      if (view && seriesModel.isAnimationEnabled() && animationCfg && animationCfg.duration > 0) {
        view.group.traverse((el) => {
          if (el instanceof Path_default && !el.animators.length) {
            el.animateFrom({
              style: {
                opacity: 0
              }
            }, animationCfg);
          }
        });
      }
    });
  }
}
function getSeriesTransitionKey(series) {
  const seriesKey = series.getModel("universalTransition").get("seriesKey");
  if (!seriesKey) {
    return series.id;
  }
  return seriesKey;
}
function convertArraySeriesKeyToString(seriesKey) {
  if (isArray(seriesKey)) {
    return seriesKey.sort().join(",");
  }
  return seriesKey;
}
function getDivideShapeFromData(data) {
  if (data.hostModel) {
    return data.hostModel.getModel("universalTransition").get("divideShape");
  }
}
function findTransitionSeriesBatches(globalStore, params) {
  const updateBatches = createHashMap();
  const oldDataMap = createHashMap();
  const oldDataMapForSplit = createHashMap();
  each(globalStore.oldSeries, (series, idx) => {
    const oldDataGroupId = globalStore.oldDataGroupIds[idx];
    const oldData = globalStore.oldData[idx];
    const transitionKey = getSeriesTransitionKey(series);
    const transitionKeyStr = convertArraySeriesKeyToString(transitionKey);
    oldDataMap.set(transitionKeyStr, {
      dataGroupId: oldDataGroupId,
      data: oldData
    });
    if (isArray(transitionKey)) {
      each(transitionKey, (key) => {
        oldDataMapForSplit.set(key, {
          key: transitionKeyStr,
          dataGroupId: oldDataGroupId,
          data: oldData
        });
      });
    }
  });
  function checkTransitionSeriesKeyDuplicated(transitionKeyStr) {
    if (updateBatches.get(transitionKeyStr)) {
      warn(`Duplicated seriesKey in universalTransition ${transitionKeyStr}`);
    }
  }
  each(params.updatedSeries, (series) => {
    if (series.isUniversalTransitionEnabled() && series.isAnimationEnabled()) {
      const newDataGroupId = series.get("dataGroupId");
      const newData = series.getData();
      const transitionKey = getSeriesTransitionKey(series);
      const transitionKeyStr = convertArraySeriesKeyToString(transitionKey);
      const oldData = oldDataMap.get(transitionKeyStr);
      if (oldData) {
        if (true) {
          checkTransitionSeriesKeyDuplicated(transitionKeyStr);
        }
        updateBatches.set(transitionKeyStr, {
          oldSeries: [{
            dataGroupId: oldData.dataGroupId,
            divide: getDivideShapeFromData(oldData.data),
            data: oldData.data
          }],
          newSeries: [{
            dataGroupId: newDataGroupId,
            divide: getDivideShapeFromData(newData),
            data: newData
          }]
        });
      } else {
        if (isArray(transitionKey)) {
          if (true) {
            checkTransitionSeriesKeyDuplicated(transitionKeyStr);
          }
          const oldSeries = [];
          each(transitionKey, (key) => {
            const oldData2 = oldDataMap.get(key);
            if (oldData2.data) {
              oldSeries.push({
                dataGroupId: oldData2.dataGroupId,
                divide: getDivideShapeFromData(oldData2.data),
                data: oldData2.data
              });
            }
          });
          if (oldSeries.length) {
            updateBatches.set(transitionKeyStr, {
              oldSeries,
              newSeries: [{
                dataGroupId: newDataGroupId,
                data: newData,
                divide: getDivideShapeFromData(newData)
              }]
            });
          }
        } else {
          const oldData2 = oldDataMapForSplit.get(transitionKey);
          if (oldData2) {
            let batch = updateBatches.get(oldData2.key);
            if (!batch) {
              batch = {
                oldSeries: [{
                  dataGroupId: oldData2.dataGroupId,
                  data: oldData2.data,
                  divide: getDivideShapeFromData(oldData2.data)
                }],
                newSeries: []
              };
              updateBatches.set(oldData2.key, batch);
            }
            batch.newSeries.push({
              dataGroupId: newDataGroupId,
              data: newData,
              divide: getDivideShapeFromData(newData)
            });
          }
        }
      }
    }
  });
  return updateBatches;
}
function querySeries(series, finder) {
  for (let i = 0; i < series.length; i++) {
    const found = finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id;
    if (found) {
      return i;
    }
  }
}
function transitionSeriesFromOpt(transitionOpt, globalStore, params, api2) {
  const from = [];
  const to = [];
  each(normalizeToArray(transitionOpt.from), (finder) => {
    const idx = querySeries(globalStore.oldSeries, finder);
    if (idx >= 0) {
      from.push({
        dataGroupId: globalStore.oldDataGroupIds[idx],
        data: globalStore.oldData[idx],
        divide: getDivideShapeFromData(globalStore.oldData[idx]),
        groupIdDim: finder.dimension
      });
    }
  });
  each(normalizeToArray(transitionOpt.to), (finder) => {
    const idx = querySeries(params.updatedSeries, finder);
    if (idx >= 0) {
      const data = params.updatedSeries[idx].getData();
      to.push({
        dataGroupId: globalStore.oldDataGroupIds[idx],
        data,
        divide: getDivideShapeFromData(data),
        groupIdDim: finder.dimension
      });
    }
  });
  if (from.length > 0 && to.length > 0) {
    transitionBetween(from, to, api2);
  }
}
function installUniversalTransition(registers) {
  registers.registerUpdateLifecycle("series:beforeupdate", (ecMOdel, api2, params) => {
    each(normalizeToArray(params.seriesTransition), (transOpt) => {
      each(normalizeToArray(transOpt.to), (finder) => {
        const series = params.updatedSeries;
        for (let i = 0; i < series.length; i++) {
          if (finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id) {
            series[i][SERIES_UNIVERSAL_TRANSITION_PROP] = true;
          }
        }
      });
    });
  });
  registers.registerUpdateLifecycle("series:transition", (ecModel, api2, params) => {
    const globalStore = getUniversalTransitionGlobalStore(api2);
    if (globalStore.oldSeries && params.updatedSeries && params.optionChanged) {
      const transitionOpt = params.seriesTransition;
      if (transitionOpt) {
        each(normalizeToArray(transitionOpt), (opt) => {
          transitionSeriesFromOpt(opt, globalStore, params, api2);
        });
      } else {
        const updateBatches = findTransitionSeriesBatches(globalStore, params);
        each(updateBatches.keys(), (key) => {
          const batch = updateBatches.get(key);
          transitionBetween(batch.oldSeries, batch.newSeries, api2);
        });
      }
      each(params.updatedSeries, (series) => {
        if (series[SERIES_UNIVERSAL_TRANSITION_PROP]) {
          series[SERIES_UNIVERSAL_TRANSITION_PROP] = false;
        }
      });
    }
    const allSeries = ecModel.getSeries();
    const savedSeries = globalStore.oldSeries = [];
    const savedDataGroupIds = globalStore.oldDataGroupIds = [];
    const savedData = globalStore.oldData = [];
    for (let i = 0; i < allSeries.length; i++) {
      const data = allSeries[i].getData();
      if (data.count() < DATA_COUNT_THRESHOLD) {
        savedSeries.push(allSeries[i]);
        savedDataGroupIds.push(allSeries[i].get("dataGroupId"));
        savedData.push(data);
      }
    }
  });
}

// src/echarts.all.ts
use([install2]);
use([install]);
use([
  install3,
  install4,
  install5,
  install7,
  install9,
  install11,
  install12,
  install13,
  install14,
  install15,
  install16,
  install18,
  install19,
  install20,
  install21,
  install22,
  install23,
  install24,
  install25,
  install26,
  install27,
  install28
]);
use(install30);
use(install31);
use(install10);
use(install32);
use(install17);
use(install33);
use(install34);
use(install36);
use(install37);
use(install29);
use(install38);
use(install39);
use(install40);
use(install41);
use(install42);
use(install43);
use(install46);
use(install49);
use(install47);
use(install48);
use(install52);
use(install50);
use(install51);
use(install53);
use(install54);
use(install55);
use(installUniversalTransition);
use(installLabelLayout);

}));
//# sourceMappingURL=echarts.js.map
