(function(_global){
var require, define;
(function () {
    var mods = {};

    define = function (id, deps, factory) {
        mods[id] = {
            id: id,
            deps: deps,
            factory: factory,
            defined: 0,
            exports: {},
            require: createRequire(id)
        };
    };

    require = createRequire('');

    function normalize(id, baseId) {
        if (!baseId) {
            return id;
        }

        if (id.indexOf('.') === 0) {
            var basePath = baseId.split('/');
            var namePath = id.split('/');
            var baseLen = basePath.length - 1;
            var nameLen = namePath.length;
            var cutBaseTerms = 0;
            var cutNameTerms = 0;

            pathLoop: for (var i = 0; i < nameLen; i++) {
                switch (namePath[i]) {
                    case '..':
                        if (cutBaseTerms < baseLen) {
                            cutBaseTerms++;
                            cutNameTerms++;
                        }
                        else {
                            break pathLoop;
                        }
                        break;
                    case '.':
                        cutNameTerms++;
                        break;
                    default:
                        break pathLoop;
                }
            }

            basePath.length = baseLen - cutBaseTerms;
            namePath = namePath.slice(cutNameTerms);

            return basePath.concat(namePath).join('/');
        }

        return id;
    }

    function createRequire(baseId) {
        var cacheMods = {};

        function localRequire(id, callback) {
            if (typeof id === 'string') {
                var exports = cacheMods[id];
                if (!exports) {
                    exports = getModExports(normalize(id, baseId));
                    cacheMods[id] = exports;
                }

                return exports;
            }
            else if (id instanceof Array) {
                callback = callback || function () {};
                callback.apply(this, getModsExports(id, callback, baseId));
            }
        };

        return localRequire;
    }

    function getModsExports(ids, factory, baseId) {
        var es = [];
        var mod = mods[baseId];

        for (var i = 0, l = Math.min(ids.length, factory.length); i < l; i++) {
            var id = normalize(ids[i], baseId);
            var arg;
            switch (id) {
                case 'require':
                    arg = (mod && mod.require) || require;
                    break;
                case 'exports':
                    arg = mod.exports;
                    break;
                case 'module':
                    arg = mod;
                    break;
                default:
                    arg = getModExports(id);
            }
            es.push(arg);
        }

        return es;
    }

    function getModExports(id) {
        var mod = mods[id];
        if (!mod) {
            throw new Error('No ' + id);
        }

        if (!mod.defined) {
            var factory = mod.factory;
            var factoryReturn = factory.apply(
                this,
                getModsExports(mod.deps || [], factory, id)
            );
            if (typeof factoryReturn !== 'undefined') {
                mod.exports = factoryReturn;
            }
            mod.defined = 1;
        }

        return mod.exports;
    }
}());
define('echarts', ['echarts/echarts'], function (main) {return main;});
define('echarts/echarts', [
    'require',
    './config',
    'zrender/tool/util',
    'zrender/tool/event',
    'zrender/tool/env',
    'zrender',
    'zrender/config',
    './chart/island',
    './component/toolbox',
    './component',
    './component/title',
    './component/tooltip',
    './component/legend',
    './util/ecData',
    './chart',
    'zrender/tool/color',
    './component/timeline',
    'zrender/shape/Image',
    'zrender/loadingEffect/Bar',
    'zrender/loadingEffect/Bubble',
    'zrender/loadingEffect/DynamicLine',
    'zrender/loadingEffect/Ring',
    'zrender/loadingEffect/Spin',
    'zrender/loadingEffect/Whirling',
    './theme/macarons',
    './theme/infographic'
], function (require) {
    var ecConfig = require('./config');
    var zrUtil = require('zrender/tool/util');
    var zrEvent = require('zrender/tool/event');
    var self = {};
    var _canvasSupported = require('zrender/tool/env').canvasSupported;
    var _idBase = new Date() - 0;
    var _instances = {};
    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';
    self.version = '2.2.1';
    self.dependencies = { zrender: '2.0.8' };
    self.init = function (dom, theme) {
        var zrender = require('zrender');
        if (zrender.version.replace('.', '') - 0 < self.dependencies.zrender.replace('.', '') - 0) {
            console.error('ZRender ' + zrender.version + ' is too old for ECharts ' + self.version + '. Current version need ZRender ' + self.dependencies.zrender + '+');
        }
        dom = dom instanceof Array ? dom[0] : dom;
        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
        if (!key) {
            key = _idBase++;
            dom.setAttribute(DOM_ATTRIBUTE_KEY, key);
        }
        if (_instances[key]) {
            _instances[key].dispose();
        }
        _instances[key] = new Echarts(dom);
        _instances[key].id = key;
        _instances[key].canvasSupported = _canvasSupported;
        _instances[key].setTheme(theme);
        return _instances[key];
    };
    self.getInstanceById = function (key) {
        return _instances[key];
    };
    function MessageCenter() {
        zrEvent.Dispatcher.call(this);
    }
    zrUtil.merge(MessageCenter.prototype, zrEvent.Dispatcher.prototype, true);
    function Echarts(dom) {
        dom.innerHTML = '';
        this._themeConfig = {};
        this.dom = dom;
        this._connected = false;
        this._status = {
            dragIn: false,
            dragOut: false,
            needRefresh: false
        };
        this._curEventType = false;
        this._chartList = [];
        this._messageCenter = new MessageCenter();
        this._messageCenterOutSide = new MessageCenter();
        this.resize = this.resize();
        this._init();
    }
    var ZR_EVENT = require('zrender/config').EVENT;
    var ZR_EVENT_LISTENS = [
        'CLICK',
        'DBLCLICK',
        'MOUSEOVER',
        'MOUSEOUT',
        'DRAGSTART',
        'DRAGEND',
        'DRAGENTER',
        'DRAGOVER',
        'DRAGLEAVE',
        'DROP'
    ];
    function callChartListMethodReverse(ecInstance, methodName, arg0, arg1, arg2) {
        var chartList = ecInstance._chartList;
        var len = chartList.length;
        while (len--) {
            var chart = chartList[len];
            if (typeof chart[methodName] === 'function') {
                chart[methodName](arg0, arg1, arg2);
            }
        }
    }
    Echarts.prototype = {
        _init: function () {
            var self = this;
            var _zr = require('zrender').init(this.dom);
            this._zr = _zr;
            this._messageCenter.dispatch = function (type, event, eventPackage, that) {
                eventPackage = eventPackage || {};
                eventPackage.type = type;
                eventPackage.event = event;
                self._messageCenter.dispatchWithContext(type, eventPackage, that);
                if (type != 'HOVER' && type != 'MOUSEOUT') {
                    setTimeout(function () {
                        self._messageCenterOutSide.dispatchWithContext(type, eventPackage, that);
                    }, 50);
                } else {
                    self._messageCenterOutSide.dispatchWithContext(type, eventPackage, that);
                }
            };
            this._onevent = function (param) {
                return self.__onevent(param);
            };
            for (var e in ecConfig.EVENT) {
                if (e != 'CLICK' && e != 'DBLCLICK' && e != 'HOVER' && e != 'MOUSEOUT' && e != 'MAP_ROAM') {
                    this._messageCenter.bind(ecConfig.EVENT[e], this._onevent, this);
                }
            }
            var eventBehaviors = {};
            this._onzrevent = function (param) {
                return self[eventBehaviors[param.type]](param);
            };
            for (var i = 0, len = ZR_EVENT_LISTENS.length; i < len; i++) {
                var eventName = ZR_EVENT_LISTENS[i];
                var eventValue = ZR_EVENT[eventName];
                eventBehaviors[eventValue] = '_on' + eventName.toLowerCase();
                _zr.on(eventValue, this._onzrevent);
            }
            this.chart = {};
            this.component = {};
            var Island = require('./chart/island');
            this._island = new Island(this._themeConfig, this._messageCenter, _zr, {}, this);
            this.chart.island = this._island;
            var Toolbox = require('./component/toolbox');
            this._toolbox = new Toolbox(this._themeConfig, this._messageCenter, _zr, {}, this);
            this.component.toolbox = this._toolbox;
            var componentLibrary = require('./component');
            componentLibrary.define('title', require('./component/title'));
            componentLibrary.define('tooltip', require('./component/tooltip'));
            componentLibrary.define('legend', require('./component/legend'));
            if (_zr.getWidth() === 0 || _zr.getHeight() === 0) {
                console.error('Domâ€™s width & height should be ready before init.');
            }
        },
        __onevent: function (param) {
            param.__echartsId = param.__echartsId || this.id;
            var fromMyself = param.__echartsId === this.id;
            if (!this._curEventType) {
                this._curEventType = param.type;
            }
            switch (param.type) {
            case ecConfig.EVENT.LEGEND_SELECTED:
                this._onlegendSelected(param);
                break;
            case ecConfig.EVENT.DATA_ZOOM:
                if (!fromMyself) {
                    var dz = this.component.dataZoom;
                    if (dz) {
                        dz.silence(true);
                        dz.absoluteZoom(param.zoom);
                        dz.silence(false);
                    }
                }
                this._ondataZoom(param);
                break;
            case ecConfig.EVENT.DATA_RANGE:
                fromMyself && this._ondataRange(param);
                break;
            case ecConfig.EVENT.MAGIC_TYPE_CHANGED:
                if (!fromMyself) {
                    var tb = this.component.toolbox;
                    if (tb) {
                        tb.silence(true);
                        tb.setMagicType(param.magicType);
                        tb.silence(false);
                    }
                }
                this._onmagicTypeChanged(param);
                break;
            case ecConfig.EVENT.DATA_VIEW_CHANGED:
                fromMyself && this._ondataViewChanged(param);
                break;
            case ecConfig.EVENT.TOOLTIP_HOVER:
                fromMyself && this._tooltipHover(param);
                break;
            case ecConfig.EVENT.RESTORE:
                this._onrestore();
                break;
            case ecConfig.EVENT.REFRESH:
                fromMyself && this._onrefresh(param);
                break;
            case ecConfig.EVENT.TOOLTIP_IN_GRID:
            case ecConfig.EVENT.TOOLTIP_OUT_GRID:
                if (!fromMyself) {
                    var grid = this.component.grid;
                    if (grid) {
                        this._zr.trigger('mousemove', {
                            connectTrigger: true,
                            zrenderX: grid.getX() + param.x * grid.getWidth(),
                            zrenderY: grid.getY() + param.y * grid.getHeight()
                        });
                    }
                } else if (this._connected) {
                    var grid = this.component.grid;
                    if (grid) {
                        param.x = (param.event.zrenderX - grid.getX()) / grid.getWidth();
                        param.y = (param.event.zrenderY - grid.getY()) / grid.getHeight();
                    }
                }
                break;
            }
            if (this._connected && fromMyself && this._curEventType === param.type) {
                for (var c in this._connected) {
                    this._connected[c].connectedEventHandler(param);
                }
                this._curEventType = null;
            }
            if (!fromMyself || !this._connected && fromMyself) {
                this._curEventType = null;
            }
        },
        _onclick: function (param) {
            callChartListMethodReverse(this, 'onclick', param);
            if (param.target) {
                var ecData = this._eventPackage(param.target);
                if (ecData && ecData.seriesIndex != null) {
                    this._messageCenter.dispatch(ecConfig.EVENT.CLICK, param.event, ecData, this);
                }
            }
        },
        _ondblclick: function (param) {
            callChartListMethodReverse(this, 'ondblclick', param);
            if (param.target) {
                var ecData = this._eventPackage(param.target);
                if (ecData && ecData.seriesIndex != null) {
                    this._messageCenter.dispatch(ecConfig.EVENT.DBLCLICK, param.event, ecData, this);
                }
            }
        },
        _onmouseover: function (param) {
            if (param.target) {
                var ecData = this._eventPackage(param.target);
                if (ecData && ecData.seriesIndex != null) {
                    this._messageCenter.dispatch(ecConfig.EVENT.HOVER, param.event, ecData, this);
                }
            }
        },
        _onmouseout: function (param) {
            if (param.target) {
                var ecData = this._eventPackage(param.target);
                if (ecData && ecData.seriesIndex != null) {
                    this._messageCenter.dispatch(ecConfig.EVENT.MOUSEOUT, param.event, ecData, this);
                }
            }
        },
        _ondragstart: function (param) {
            this._status = {
                dragIn: false,
                dragOut: false,
                needRefresh: false
            };
            callChartListMethodReverse(this, 'ondragstart', param);
        },
        _ondragenter: function (param) {
            callChartListMethodReverse(this, 'ondragenter', param);
        },
        _ondragover: function (param) {
            callChartListMethodReverse(this, 'ondragover', param);
        },
        _ondragleave: function (param) {
            callChartListMethodReverse(this, 'ondragleave', param);
        },
        _ondrop: function (param) {
            callChartListMethodReverse(this, 'ondrop', param, this._status);
            this._island.ondrop(param, this._status);
        },
        _ondragend: function (param) {
            callChartListMethodReverse(this, 'ondragend', param, this._status);
            this._timeline && this._timeline.ondragend(param, this._status);
            this._island.ondragend(param, this._status);
            if (this._status.needRefresh) {
                this._syncBackupData(this._option);
                var messageCenter = this._messageCenter;
                messageCenter.dispatch(ecConfig.EVENT.DATA_CHANGED, param.event, this._eventPackage(param.target), this);
                messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this);
            }
        },
        _onlegendSelected: function (param) {
            this._status.needRefresh = false;
            callChartListMethodReverse(this, 'onlegendSelected', param, this._status);
            if (this._status.needRefresh) {
                this._messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this);
            }
        },
        _ondataZoom: function (param) {
            this._status.needRefresh = false;
            callChartListMethodReverse(this, 'ondataZoom', param, this._status);
            if (this._status.needRefresh) {
                this._messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this);
            }
        },
        _ondataRange: function (param) {
            this._clearEffect();
            this._status.needRefresh = false;
            callChartListMethodReverse(this, 'ondataRange', param, this._status);
            if (this._status.needRefresh) {
                this._zr.refreshNextFrame();
            }
        },
        _onmagicTypeChanged: function () {
            this._clearEffect();
            this._render(this._toolbox.getMagicOption());
        },
        _ondataViewChanged: function (param) {
            this._syncBackupData(param.option);
            this._messageCenter.dispatch(ecConfig.EVENT.DATA_CHANGED, null, param, this);
            this._messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this);
        },
        _tooltipHover: function (param) {
            var tipShape = [];
            callChartListMethodReverse(this, 'ontooltipHover', param, tipShape);
        },
        _onrestore: function () {
            this.restore();
        },
        _onrefresh: function (param) {
            this._refreshInside = true;
            this.refresh(param);
            this._refreshInside = false;
        },
        _syncBackupData: function (curOption) {
            this.component.dataZoom && this.component.dataZoom.syncBackupData(curOption);
        },
        _eventPackage: function (target) {
            if (target) {
                var ecData = require('./util/ecData');
                var seriesIndex = ecData.get(target, 'seriesIndex');
                var dataIndex = ecData.get(target, 'dataIndex');
                dataIndex = seriesIndex != -1 && this.component.dataZoom ? this.component.dataZoom.getRealDataIndex(seriesIndex, dataIndex) : dataIndex;
                return {
                    seriesIndex: seriesIndex,
                    seriesName: (ecData.get(target, 'series') || {}).name,
                    dataIndex: dataIndex,
                    data: ecData.get(target, 'data'),
                    name: ecData.get(target, 'name'),
                    value: ecData.get(target, 'value'),
                    special: ecData.get(target, 'special')
                };
            }
            return;
        },
        _noDataCheck: function (magicOption) {
            var series = magicOption.series;
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].type == ecConfig.CHART_TYPE_MAP || series[i].data && series[i].data.length > 0 || series[i].markPoint && series[i].markPoint.data && series[i].markPoint.data.length > 0 || series[i].markLine && series[i].markLine.data && series[i].markLine.data.length > 0 || series[i].nodes && series[i].nodes.length > 0 || series[i].links && series[i].links.length > 0 || series[i].matrix && series[i].matrix.length > 0 || series[i].eventList && series[i].eventList.length > 0) {
                    return false;
                }
            }
            var loadOption = this._option && this._option.noDataLoadingOption || this._themeConfig.noDataLoadingOption || ecConfig.noDataLoadingOption || {
                text: this._option && this._option.noDataText || this._themeConfig.noDataText || ecConfig.noDataText,
                effect: this._option && this._option.noDataEffect || this._themeConfig.noDataEffect || ecConfig.noDataEffect
            };
            this.clear();
            this.showLoading(loadOption);
            return true;
        },
        _render: function (magicOption) {
            this._mergeGlobalConifg(magicOption);
            if (this._noDataCheck(magicOption)) {
                return;
            }
            var bgColor = magicOption.backgroundColor;
            if (bgColor) {
                if (!_canvasSupported && bgColor.indexOf('rgba') != -1) {
                    var cList = bgColor.split(',');
                    this.dom.style.filter = 'alpha(opacity=' + cList[3].substring(0, cList[3].lastIndexOf(')')) * 100 + ')';
                    cList.length = 3;
                    cList[0] = cList[0].replace('a', '');
                    this.dom.style.backgroundColor = cList.join(',') + ')';
                } else {
                    this.dom.style.backgroundColor = bgColor;
                }
            }
            this._zr.clearAnimation();
            this._chartList = [];
            var chartLibrary = require('./chart');
            var componentLibrary = require('./component');
            if (magicOption.xAxis || magicOption.yAxis) {
                magicOption.grid = magicOption.grid || {};
                magicOption.dataZoom = magicOption.dataZoom || {};
            }
            var componentList = [
                'title',
                'legend',
                'tooltip',
                'dataRange',
                'roamController',
                'grid',
                'dataZoom',
                'xAxis',
                'yAxis',
                'polar'
            ];
            var ComponentClass;
            var componentType;
            var component;
            for (var i = 0, l = componentList.length; i < l; i++) {
                componentType = componentList[i];
                component = this.component[componentType];
                if (magicOption[componentType]) {
                    if (component) {
                        component.refresh && component.refresh(magicOption);
                    } else {
                        ComponentClass = componentLibrary.get(/^[xy]Axis$/.test(componentType) ? 'axis' : componentType);
                        component = new ComponentClass(this._themeConfig, this._messageCenter, this._zr, magicOption, this, componentType);
                        this.component[componentType] = component;
                    }
                    this._chartList.push(component);
                } else if (component) {
                    component.dispose();
                    this.component[componentType] = null;
                    delete this.component[componentType];
                }
            }
            var ChartClass;
            var chartType;
            var chart;
            var chartMap = {};
            for (var i = 0, l = magicOption.series.length; i < l; i++) {
                chartType = magicOption.series[i].type;
                if (!chartType) {
                    console.error('series[' + i + '] chart type has not been defined.');
                    continue;
                }
                if (!chartMap[chartType]) {
                    chartMap[chartType] = true;
                    ChartClass = chartLibrary.get(chartType);
                    if (ChartClass) {
                        if (this.chart[chartType]) {
                            chart = this.chart[chartType];
                            chart.refresh(magicOption);
                        } else {
                            chart = new ChartClass(this._themeConfig, this._messageCenter, this._zr, magicOption, this);
                        }
                        this._chartList.push(chart);
                        this.chart[chartType] = chart;
                    } else {
                        console.error(chartType + ' has not been required.');
                    }
                }
            }
            for (chartType in this.chart) {
                if (chartType != ecConfig.CHART_TYPE_ISLAND && !chartMap[chartType]) {
                    this.chart[chartType].dispose();
                    this.chart[chartType] = null;
                    delete this.chart[chartType];
                }
            }
            this.component.grid && this.component.grid.refixAxisShape(this.component);
            this._island.refresh(magicOption);
            this._toolbox.refresh(magicOption);
            magicOption.animation && !magicOption.renderAsImage ? this._zr.refresh() : this._zr.render();
            var imgId = 'IMG' + this.id;
            var img = document.getElementById(imgId);
            if (magicOption.renderAsImage && _canvasSupported) {
                if (img) {
                    img.src = this.getDataURL(magicOption.renderAsImage);
                } else {
                    img = this.getImage(magicOption.renderAsImage);
                    img.id = imgId;
                    img.style.position = 'absolute';
                    img.style.left = 0;
                    img.style.top = 0;
                    this.dom.firstChild.appendChild(img);
                }
                this.un();
                this._zr.un();
                this._disposeChartList();
                this._zr.clear();
            } else if (img) {
                img.parentNode.removeChild(img);
            }
            img = null;
            this._option = magicOption;
        },
        restore: function () {
            this._clearEffect();
            this._option = zrUtil.clone(this._optionRestore);
            this._disposeChartList();
            this._island.clear();
            this._toolbox.reset(this._option, true);
            this._render(this._option);
        },
        refresh: function (param) {
            this._clearEffect();
            param = param || {};
            var magicOption = param.option;
            if (!this._refreshInside && magicOption) {
                magicOption = this.getOption();
                zrUtil.merge(magicOption, param.option, true);
                zrUtil.merge(this._optionRestore, param.option, true);
                this._toolbox.reset(magicOption);
            }
            this._island.refresh(magicOption);
            this._toolbox.refresh(magicOption);
            this._zr.clearAnimation();
            for (var i = 0, l = this._chartList.length; i < l; i++) {
                this._chartList[i].refresh && this._chartList[i].refresh(magicOption);
            }
            this.component.grid && this.component.grid.refixAxisShape(this.component);
            this._zr.refresh();
        },
        _disposeChartList: function () {
            this._clearEffect();
            this._zr.clearAnimation();
            var len = this._chartList.length;
            while (len--) {
                var chart = this._chartList[len];
                if (chart) {
                    var chartType = chart.type;
                    this.chart[chartType] && delete this.chart[chartType];
                    this.component[chartType] && delete this.component[chartType];
                    chart.dispose && chart.dispose();
                }
            }
            this._chartList = [];
        },
        _mergeGlobalConifg: function (magicOption) {
            var mergeList = [
                'backgroundColor',
                'calculable',
                'calculableColor',
                'calculableHolderColor',
                'nameConnector',
                'valueConnector',
                'animation',
                'animationThreshold',
                'animationDuration',
                'animationDurationUpdate',
                'animationEasing',
                'addDataAnimation',
                'symbolList',
                'DRAG_ENABLE_TIME'
            ];
            var len = mergeList.length;
            while (len--) {
                var mergeItem = mergeList[len];
                if (magicOption[mergeItem] == null) {
                    magicOption[mergeItem] = this._themeConfig[mergeItem] != null ? this._themeConfig[mergeItem] : ecConfig[mergeItem];
                }
            }
            var themeColor = magicOption.color;
            if (!(themeColor && themeColor.length)) {
                themeColor = this._themeConfig.color || ecConfig.color;
            }
            this._zr.getColor = function (idx) {
                var zrColor = require('zrender/tool/color');
                return zrColor.getColor(idx, themeColor);
            };
            if (!_canvasSupported) {
                magicOption.animation = false;
                magicOption.addDataAnimation = false;
            }
        },
        setOption: function (option, notMerge) {
            if (!option.timeline) {
                return this._setOption(option, notMerge);
            } else {
                return this._setTimelineOption(option);
            }
        },
        _setOption: function (option, notMerge) {
            if (!notMerge && this._option) {
                this._option = zrUtil.merge(this.getOption(), zrUtil.clone(option), true);
            } else {
                this._option = zrUtil.clone(option);
            }
            this._optionRestore = zrUtil.clone(this._option);
            if (!this._option.series || this._option.series.length === 0) {
                this._zr.clear();
                return;
            }
            if (this.component.dataZoom && (this._option.dataZoom || this._option.toolbox && this._option.toolbox.feature && this._option.toolbox.feature.dataZoom && this._option.toolbox.feature.dataZoom.show)) {
                this.component.dataZoom.syncOption(this._option);
            }
            this._toolbox.reset(this._option);
            this._render(this._option);
            return this;
        },
        getOption: function () {
            var magicOption = zrUtil.clone(this._option);
            var self = this;
            function restoreOption(prop) {
                var restoreSource = self._optionRestore[prop];
                if (restoreSource) {
                    if (restoreSource instanceof Array) {
                        var len = restoreSource.length;
                        while (len--) {
                            magicOption[prop][len].data = zrUtil.clone(restoreSource[len].data);
                        }
                    } else {
                        magicOption[prop].data = zrUtil.clone(restoreSource.data);
                    }
                }
            }
            restoreOption('xAxis');
            restoreOption('yAxis');
            restoreOption('series');
            return magicOption;
        },
        setSeries: function (series, notMerge) {
            if (!notMerge) {
                this.setOption({ series: series });
            } else {
                this._option.series = series;
                this.setOption(this._option, notMerge);
            }
            return this;
        },
        getSeries: function () {
            return this.getOption().series;
        },
        _setTimelineOption: function (option) {
            this._timeline && this._timeline.dispose();
            var Timeline = require('./component/timeline');
            var timeline = new Timeline(this._themeConfig, this._messageCenter, this._zr, option, this);
            this._timeline = timeline;
            this.component.timeline = this._timeline;
            return this;
        },
        addData: function (seriesIdx, data, isHead, dataGrow, additionData) {
            var params = seriesIdx instanceof Array ? seriesIdx : [[
                    seriesIdx,
                    data,
                    isHead,
                    dataGrow,
                    additionData
                ]];
            var magicOption = this.getOption();
            var optionRestore = this._optionRestore;
            for (var i = 0, l = params.length; i < l; i++) {
                seriesIdx = params[i][0];
                data = params[i][1];
                isHead = params[i][2];
                dataGrow = params[i][3];
                additionData = params[i][4];
                var seriesItem = optionRestore.series[seriesIdx];
                var inMethod = isHead ? 'unshift' : 'push';
                var outMethod = isHead ? 'pop' : 'shift';
                if (seriesItem) {
                    var seriesItemData = seriesItem.data;
                    var mSeriesItemData = magicOption.series[seriesIdx].data;
                    seriesItemData[inMethod](data);
                    mSeriesItemData[inMethod](data);
                    if (!dataGrow) {
                        seriesItemData[outMethod]();
                        data = mSeriesItemData[outMethod]();
                    }
                    if (additionData != null) {
                        var legend;
                        var legendData;
                        if (seriesItem.type === ecConfig.CHART_TYPE_PIE && (legend = optionRestore.legend) && (legendData = legend.data)) {
                            var mLegendData = magicOption.legend.data;
                            legendData[inMethod](additionData);
                            mLegendData[inMethod](additionData);
                            if (!dataGrow) {
                                var legendDataIdx = zrUtil.indexOf(legendData, data.name);
                                legendDataIdx != -1 && legendData.splice(legendDataIdx, 1);
                                legendDataIdx = zrUtil.indexOf(mLegendData, data.name);
                                legendDataIdx != -1 && mLegendData.splice(legendDataIdx, 1);
                            }
                        } else if (optionRestore.xAxis != null && optionRestore.yAxis != null) {
                            var axisData;
                            var mAxisData;
                            var axisIdx = seriesItem.xAxisIndex || 0;
                            if (optionRestore.xAxis[axisIdx].type == null || optionRestore.xAxis[axisIdx].type === 'category') {
                                axisData = optionRestore.xAxis[axisIdx].data;
                                mAxisData = magicOption.xAxis[axisIdx].data;
                                axisData[inMethod](additionData);
                                mAxisData[inMethod](additionData);
                                if (!dataGrow) {
                                    axisData[outMethod]();
                                    mAxisData[outMethod]();
                                }
                            }
                            axisIdx = seriesItem.yAxisIndex || 0;
                            if (optionRestore.yAxis[axisIdx].type === 'category') {
                                axisData = optionRestore.yAxis[axisIdx].data;
                                mAxisData = magicOption.yAxis[axisIdx].data;
                                axisData[inMethod](additionData);
                                mAxisData[inMethod](additionData);
                                if (!dataGrow) {
                                    axisData[outMethod]();
                                    mAxisData[outMethod]();
                                }
                            }
                        }
                    }
                    this._option.series[seriesIdx].data = magicOption.series[seriesIdx].data;
                }
            }
            this._zr.clearAnimation();
            var chartList = this._chartList;
            var chartAnimationCount = 0;
            var chartAnimationDone = function () {
                chartAnimationCount--;
                if (chartAnimationCount === 0) {
                    animationDone();
                }
            };
            for (var i = 0, l = chartList.length; i < l; i++) {
                if (magicOption.addDataAnimation && chartList[i].addDataAnimation) {
                    chartAnimationCount++;
                    chartList[i].addDataAnimation(params, chartAnimationDone);
                }
            }
            this.component.dataZoom && this.component.dataZoom.syncOption(magicOption);
            this._option = magicOption;
            var self = this;
            function animationDone() {
                if (!self._zr) {
                    return;
                }
                self._zr.clearAnimation();
                for (var i = 0, l = chartList.length; i < l; i++) {
                    chartList[i].motionlessOnce = magicOption.addDataAnimation && chartList[i].addDataAnimation;
                }
                self._messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, { option: magicOption }, self);
            }
            if (!magicOption.addDataAnimation) {
                setTimeout(animationDone, 0);
            }
            return this;
        },
        addMarkPoint: function (seriesIdx, markData) {
            return this._addMark(seriesIdx, markData, 'markPoint');
        },
        addMarkLine: function (seriesIdx, markData) {
            return this._addMark(seriesIdx, markData, 'markLine');
        },
        _addMark: function (seriesIdx, markData, markType) {
            var series = this._option.series;
            var seriesItem;
            if (series && (seriesItem = series[seriesIdx])) {
                var seriesR = this._optionRestore.series;
                var seriesRItem = seriesR[seriesIdx];
                var markOpt = seriesItem[markType];
                var markOptR = seriesRItem[markType];
                markOpt = seriesItem[markType] = markOpt || { data: [] };
                markOptR = seriesRItem[markType] = markOptR || { data: [] };
                for (var key in markData) {
                    if (key === 'data') {
                        markOpt.data = markOpt.data.concat(markData.data);
                        markOptR.data = markOptR.data.concat(markData.data);
                    } else if (typeof markData[key] != 'object' || markOpt[key] == null) {
                        markOpt[key] = markOptR[key] = markData[key];
                    } else {
                        zrUtil.merge(markOpt[key], markData[key], true);
                        zrUtil.merge(markOptR[key], markData[key], true);
                    }
                }
                var chart = this.chart[seriesItem.type];
                chart && chart.addMark(seriesIdx, markData, markType);
            }
            return this;
        },
        delMarkPoint: function (seriesIdx, markName) {
            return this._delMark(seriesIdx, markName, 'markPoint');
        },
        delMarkLine: function (seriesIdx, markName) {
            return this._delMark(seriesIdx, markName, 'markLine');
        },
        _delMark: function (seriesIdx, markName, markType) {
            var series = this._option.series;
            var seriesItem;
            var mark;
            var dataArray;
            if (!(series && (seriesItem = series[seriesIdx]) && (mark = seriesItem[markType]) && (dataArray = mark.data))) {
                return this;
            }
            markName = markName.split(' > ');
            var targetIndex = -1;
            for (var i = 0, l = dataArray.length; i < l; i++) {
                var dataItem = dataArray[i];
                if (dataItem instanceof Array) {
                    if (dataItem[0].name === markName[0] && dataItem[1].name === markName[1]) {
                        targetIndex = i;
                        break;
                    }
                } else if (dataItem.name === markName[0]) {
                    targetIndex = i;
                    break;
                }
            }
            if (targetIndex > -1) {
                dataArray.splice(targetIndex, 1);
                this._optionRestore.series[seriesIdx][markType].data.splice(targetIndex, 1);
                var chart = this.chart[seriesItem.type];
                chart && chart.delMark(seriesIdx, markName.join(' > '), markType);
            }
            return this;
        },
        getDom: function () {
            return this.dom;
        },
        getZrender: function () {
            return this._zr;
        },
        getDataURL: function (imgType) {
            if (!_canvasSupported) {
                return '';
            }
            if (this._chartList.length === 0) {
                var imgId = 'IMG' + this.id;
                var img = document.getElementById(imgId);
                if (img) {
                    return img.src;
                }
            }
            var tooltip = this.component.tooltip;
            tooltip && tooltip.hideTip();
            switch (imgType) {
            case 'jpeg':
                break;
            default:
                imgType = 'png';
            }
            var bgColor = this._option.backgroundColor;
            if (bgColor && bgColor.replace(' ', '') === 'rgba(0,0,0,0)') {
                bgColor = '#fff';
            }
            return this._zr.toDataURL('image/' + imgType, bgColor);
        },
        getImage: function (imgType) {
            var title = this._optionRestore.title;
            var imgDom = document.createElement('img');
            imgDom.src = this.getDataURL(imgType);
            imgDom.title = title && title.text || 'ECharts';
            return imgDom;
        },
        getConnectedDataURL: function (imgType) {
            if (!this.isConnected()) {
                return this.getDataURL(imgType);
            }
            var tempDom = this.dom;
            var imgList = {
                'self': {
                    img: this.getDataURL(imgType),
                    left: tempDom.offsetLeft,
                    top: tempDom.offsetTop,
                    right: tempDom.offsetLeft + tempDom.offsetWidth,
                    bottom: tempDom.offsetTop + tempDom.offsetHeight
                }
            };
            var minLeft = imgList.self.left;
            var minTop = imgList.self.top;
            var maxRight = imgList.self.right;
            var maxBottom = imgList.self.bottom;
            for (var c in this._connected) {
                tempDom = this._connected[c].getDom();
                imgList[c] = {
                    img: this._connected[c].getDataURL(imgType),
                    left: tempDom.offsetLeft,
                    top: tempDom.offsetTop,
                    right: tempDom.offsetLeft + tempDom.offsetWidth,
                    bottom: tempDom.offsetTop + tempDom.offsetHeight
                };
                minLeft = Math.min(minLeft, imgList[c].left);
                minTop = Math.min(minTop, imgList[c].top);
                maxRight = Math.max(maxRight, imgList[c].right);
                maxBottom = Math.max(maxBottom, imgList[c].bottom);
            }
            var zrDom = document.createElement('div');
            zrDom.style.position = 'absolute';
            zrDom.style.left = '-4000px';
            zrDom.style.width = maxRight - minLeft + 'px';
            zrDom.style.height = maxBottom - minTop + 'px';
            document.body.appendChild(zrDom);
            var zrImg = require('zrender').init(zrDom);
            var ImageShape = require('zrender/shape/Image');
            for (var c in imgList) {
                zrImg.addShape(new ImageShape({
                    style: {
                        x: imgList[c].left - minLeft,
                        y: imgList[c].top - minTop,
                        image: imgList[c].img
                    }
                }));
            }
            zrImg.render();
            var bgColor = this._option.backgroundColor;
            if (bgColor && bgColor.replace(/ /g, '') === 'rgba(0,0,0,0)') {
                bgColor = '#fff';
            }
            var image = zrImg.toDataURL('image/png', bgColor);
            setTimeout(function () {
                zrImg.dispose();
                zrDom.parentNode.removeChild(zrDom);
                zrDom = null;
            }, 100);
            return image;
        },
        getConnectedImage: function (imgType) {
            var title = this._optionRestore.title;
            var imgDom = document.createElement('img');
            imgDom.src = this.getConnectedDataURL(imgType);
            imgDom.title = title && title.text || 'ECharts';
            return imgDom;
        },
        on: function (eventName, eventListener) {
            this._messageCenterOutSide.bind(eventName, eventListener, this);
            return this;
        },
        un: function (eventName, eventListener) {
            this._messageCenterOutSide.unbind(eventName, eventListener);
            return this;
        },
        connect: function (connectTarget) {
            if (!connectTarget) {
                return this;
            }
            if (!this._connected) {
                this._connected = {};
            }
            if (connectTarget instanceof Array) {
                for (var i = 0, l = connectTarget.length; i < l; i++) {
                    this._connected[connectTarget[i].id] = connectTarget[i];
                }
            } else {
                this._connected[connectTarget.id] = connectTarget;
            }
            return this;
        },
        disConnect: function (connectTarget) {
            if (!connectTarget || !this._connected) {
                return this;
            }
            if (connectTarget instanceof Array) {
                for (var i = 0, l = connectTarget.length; i < l; i++) {
                    delete this._connected[connectTarget[i].id];
                }
            } else {
                delete this._connected[connectTarget.id];
            }
            for (var k in this._connected) {
                return k, this;
            }
            this._connected = false;
            return this;
        },
        connectedEventHandler: function (param) {
            if (param.__echartsId != this.id) {
                this._onevent(param);
            }
        },
        isConnected: function () {
            return !!this._connected;
        },
        showLoading: function (loadingOption) {
            var effectList = {
                bar: require('zrender/loadingEffect/Bar'),
                bubble: require('zrender/loadingEffect/Bubble'),
                dynamicLine: require('zrender/loadingEffect/DynamicLine'),
                ring: require('zrender/loadingEffect/Ring'),
                spin: require('zrender/loadingEffect/Spin'),
                whirling: require('zrender/loadingEffect/Whirling')
            };
            this._toolbox.hideDataView();
            loadingOption = loadingOption || {};
            var textStyle = loadingOption.textStyle || {};
            loadingOption.textStyle = textStyle;
            var finalTextStyle = zrUtil.merge(zrUtil.merge(zrUtil.clone(textStyle), this._themeConfig.textStyle), ecConfig.textStyle);
            textStyle.textFont = finalTextStyle.fontStyle + ' ' + finalTextStyle.fontWeight + ' ' + finalTextStyle.fontSize + 'px ' + finalTextStyle.fontFamily;
            textStyle.text = loadingOption.text || this._option && this._option.loadingText || this._themeConfig.loadingText || ecConfig.loadingText;
            if (loadingOption.x != null) {
                textStyle.x = loadingOption.x;
            }
            if (loadingOption.y != null) {
                textStyle.y = loadingOption.y;
            }
            loadingOption.effectOption = loadingOption.effectOption || {};
            loadingOption.effectOption.textStyle = textStyle;
            var Effect = loadingOption.effect;
            if (typeof Effect === 'string' || Effect == null) {
                Effect = effectList[loadingOption.effect || this._option && this._option.loadingEffect || this._themeConfig.loadingEffect || ecConfig.loadingEffect] || effectList.spin;
            }
            this._zr.showLoading(new Effect(loadingOption.effectOption));
            return this;
        },
        hideLoading: function () {
            this._zr.hideLoading();
            return this;
        },
        setTheme: function (theme) {
            if (theme) {
                if (typeof theme === 'string') {
                    switch (theme) {
                    case 'macarons':
                        theme = require('./theme/macarons');
                        break;
                    case 'infographic':
                        theme = require('./theme/infographic');
                        break;
                    default:
                        theme = {};
                    }
                } else {
                    theme = theme || {};
                }
                this._themeConfig = theme;
            }
            if (!_canvasSupported) {
                var textStyle = this._themeConfig.textStyle;
                textStyle && textStyle.fontFamily && textStyle.fontFamily2 && (textStyle.fontFamily = textStyle.fontFamily2);
                textStyle = ecConfig.textStyle;
                textStyle.fontFamily = textStyle.fontFamily2;
            }
            this._timeline && this._timeline.setTheme(true);
            this._optionRestore && this.restore();
        },
        resize: function () {
            var self = this;
            return function () {
                self._clearEffect();
                self._zr.resize();
                if (self._option && self._option.renderAsImage && _canvasSupported) {
                    self._render(self._option);
                    return self;
                }
                self._zr.clearAnimation();
                self._island.resize();
                self._toolbox.resize();
                self._timeline && self._timeline.resize();
                for (var i = 0, l = self._chartList.length; i < l; i++) {
                    self._chartList[i].resize && self._chartList[i].resize();
                }
                self.component.grid && self.component.grid.refixAxisShape(self.component);
                self._zr.refresh();
                self._messageCenter.dispatch(ecConfig.EVENT.RESIZE, null, null, self);
                return self;
            };
        },
        _clearEffect: function () {
            this._zr.modLayer(ecConfig.EFFECT_ZLEVEL, { motionBlur: false });
            this._zr.painter.clearLayer(ecConfig.EFFECT_ZLEVEL);
        },
        clear: function () {
            this._disposeChartList();
            this._zr.clear();
            this._option = {};
            this._optionRestore = {};
            this.dom.style.backgroundColor = null;
            return this;
        },
        dispose: function () {
            var key = this.dom.getAttribute(DOM_ATTRIBUTE_KEY);
            key && delete _instances[key];
            this._island.dispose();
            this._toolbox.dispose();
            this._timeline && this._timeline.dispose();
            this._messageCenter.unbind();
            this.clear();
            this._zr.dispose();
            this._zr = null;
        }
    };
    return self;
});define('echarts/config', [], function () {
    var config = {
        CHART_TYPE_LINE: 'line',
        CHART_TYPE_BAR: 'bar',
        CHART_TYPE_SCATTER: 'scatter',
        CHART_TYPE_PIE: 'pie',
        CHART_TYPE_RADAR: 'radar',
        CHART_TYPE_MAP: 'map',
        CHART_TYPE_K: 'k',
        CHART_TYPE_ISLAND: 'island',
        CHART_TYPE_FORCE: 'force',
        CHART_TYPE_CHORD: 'chord',
        CHART_TYPE_GAUGE: 'gauge',
        CHART_TYPE_FUNNEL: 'funnel',
        CHART_TYPE_EVENTRIVER: 'eventRiver',
        COMPONENT_TYPE_TITLE: 'title',
        COMPONENT_TYPE_LEGEND: 'legend',
        COMPONENT_TYPE_DATARANGE: 'dataRange',
        COMPONENT_TYPE_DATAVIEW: 'dataView',
        COMPONENT_TYPE_DATAZOOM: 'dataZoom',
        COMPONENT_TYPE_TOOLBOX: 'toolbox',
        COMPONENT_TYPE_TOOLTIP: 'tooltip',
        COMPONENT_TYPE_GRID: 'grid',
        COMPONENT_TYPE_AXIS: 'axis',
        COMPONENT_TYPE_POLAR: 'polar',
        COMPONENT_TYPE_X_AXIS: 'xAxis',
        COMPONENT_TYPE_Y_AXIS: 'yAxis',
        COMPONENT_TYPE_AXIS_CATEGORY: 'categoryAxis',
        COMPONENT_TYPE_AXIS_VALUE: 'valueAxis',
        COMPONENT_TYPE_TIMELINE: 'timeline',
        COMPONENT_TYPE_ROAMCONTROLLER: 'roamController',
        backgroundColor: 'rgba(0,0,0,0)',
        color: [
            '#ff7f50',
            '#87cefa',
            '#da70d6',
            '#32cd32',
            '#6495ed',
            '#ff69b4',
            '#ba55d3',
            '#cd5c5c',
            '#ffa500',
            '#40e0d0',
            '#1e90ff',
            '#ff6347',
            '#7b68ee',
            '#00fa9a',
            '#ffd700',
            '#6699FF',
            '#ff6666',
            '#3cb371',
            '#b8860b',
            '#30e0e0'
        ],
        markPoint: {
            clickable: true,
            symbol: 'pin',
            symbolSize: 10,
            large: false,
            effect: {
                show: false,
                loop: true,
                period: 15,
                type: 'scale',
                scaleSize: 2,
                bounceDistance: 10
            },
            itemStyle: {
                normal: {
                    borderWidth: 2,
                    label: {
                        show: true,
                        position: 'inside'
                    }
                },
                emphasis: { label: { show: true } }
            }
        },
        markLine: {
            clickable: true,
            symbol: [
                'circle',
                'arrow'
            ],
            symbolSize: [
                2,
                4
            ],
            smoothness: 0.2,
            precision: 2,
            effect: {
                show: false,
                loop: true,
                period: 15,
                scaleSize: 2
            },
            bundling: {
                enable: false,
                maxTurningAngle: 45
            },
            itemStyle: {
                normal: {
                    borderWidth: 1.5,
                    label: {
                        show: true,
                        position: 'end'
                    },
                    lineStyle: { type: 'dashed' }
                },
                emphasis: {
                    label: { show: false },
                    lineStyle: {}
                }
            }
        },
        textStyle: {
            decoration: 'none',
            fontFamily: 'Arial, Verdana, sans-serif',
            fontFamily2: 'å¾®è½¯é›…é»‘',
            fontSize: 12,
            fontStyle: 'normal',
            fontWeight: 'normal'
        },
        EVENT: {
            REFRESH: 'refresh',
            RESTORE: 'restore',
            RESIZE: 'resize',
            CLICK: 'click',
            DBLCLICK: 'dblclick',
            HOVER: 'hover',
            MOUSEOUT: 'mouseout',
            DATA_CHANGED: 'dataChanged',
            DATA_ZOOM: 'dataZoom',
            DATA_RANGE: 'dataRange',
            DATA_RANGE_SELECTED: 'dataRangeSelected',
            DATA_RANGE_HOVERLINK: 'dataRangeHoverLink',
            LEGEND_SELECTED: 'legendSelected',
            LEGEND_HOVERLINK: 'legendHoverLink',
            MAP_SELECTED: 'mapSelected',
            PIE_SELECTED: 'pieSelected',
            MAGIC_TYPE_CHANGED: 'magicTypeChanged',
            DATA_VIEW_CHANGED: 'dataViewChanged',
            TIMELINE_CHANGED: 'timelineChanged',
            MAP_ROAM: 'mapRoam',
            FORCE_LAYOUT_END: 'forceLayoutEnd',
            TOOLTIP_HOVER: 'tooltipHover',
            TOOLTIP_IN_GRID: 'tooltipInGrid',
            TOOLTIP_OUT_GRID: 'tooltipOutGrid',
            ROAMCONTROLLER: 'roamController'
        },
        DRAG_ENABLE_TIME: 120,
        EFFECT_ZLEVEL: 10,
        symbolList: [
            'circle',
            'rectangle',
            'triangle',
            'diamond',
            'emptyCircle',
            'emptyRectangle',
            'emptyTriangle',
            'emptyDiamond'
        ],
        loadingEffect: 'spin',
        loadingText: 'æ•°æ®è¯»å–ä¸­...',
        noDataEffect: 'bubble',
        noDataText: 'æš‚æ— æ•°æ®',
        calculable: false,
        calculableColor: 'rgba(255,165,0,0.6)',
        calculableHolderColor: '#ccc',
        nameConnector: ' & ',
        valueConnector: ': ',
        animation: true,
        addDataAnimation: true,
        animationThreshold: 2000,
        animationDuration: 2000,
        animationDurationUpdate: 500,
        animationEasing: 'ExponentialOut'
    };
    return config;
});define('zrender/tool/util', [
    'require',
    '../dep/excanvas'
], function (require) {
    var BUILTIN_OBJECT = {
        '[object Function]': 1,
        '[object RegExp]': 1,
        '[object Date]': 1,
        '[object Error]': 1,
        '[object CanvasGradient]': 1
    };
    var objToString = Object.prototype.toString;
    function isDom(obj) {
        return obj && obj.nodeType === 1 && typeof obj.nodeName == 'string';
    }
    function clone(source) {
        if (typeof source == 'object' && source !== null) {
            var result = source;
            if (source instanceof Array) {
                result = [];
                for (var i = 0, len = source.length; i < len; i++) {
                    result[i] = clone(source[i]);
                }
            } else if (!BUILTIN_OBJECT[objToString.call(source)] && !isDom(source)) {
                result = {};
                for (var key in source) {
                    if (source.hasOwnProperty(key)) {
                        result[key] = clone(source[key]);
                    }
                }
            }
            return result;
        }
        return source;
    }
    function mergeItem(target, source, key, overwrite) {
        if (source.hasOwnProperty(key)) {
            var targetProp = target[key];
            if (typeof targetProp == 'object' && !BUILTIN_OBJECT[objToString.call(targetProp)] && !isDom(targetProp)) {
                merge(target[key], source[key], overwrite);
            } else if (overwrite || !(key in target)) {
                target[key] = source[key];
            }
        }
    }
    function merge(target, source, overwrite) {
        for (var i in source) {
            mergeItem(target, source, i, overwrite);
        }
        return target;
    }
    var _ctx;
    function getContext() {
        if (!_ctx) {
            require('../dep/excanvas');
            if (window['G_vmlCanvasManager']) {
                var _div = document.createElement('div');
                _div.style.position = 'absolute';
                _div.style.top = '-1000px';
                document.body.appendChild(_div);
                _ctx = G_vmlCanvasManager.initElement(_div).getContext('2d');
            } else {
                _ctx = document.createElement('canvas').getContext('2d');
            }
        }
        return _ctx;
    }
    var _canvas;
    var _pixelCtx;
    var _width;
    var _height;
    var _offsetX = 0;
    var _offsetY = 0;
    function getPixelContext() {
        if (!_pixelCtx) {
            _canvas = document.createElement('canvas');
            _width = _canvas.width;
            _height = _canvas.height;
            _pixelCtx = _canvas.getContext('2d');
        }
        return _pixelCtx;
    }
    function adjustCanvasSize(x, y) {
        var _v = 100;
        var _flag;
        if (x + _offsetX > _width) {
            _width = x + _offsetX + _v;
            _canvas.width = _width;
            _flag = true;
        }
        if (y + _offsetY > _height) {
            _height = y + _offsetY + _v;
            _canvas.height = _height;
            _flag = true;
        }
        if (x < -_offsetX) {
            _offsetX = Math.ceil(-x / _v) * _v;
            _width += _offsetX;
            _canvas.width = _width;
            _flag = true;
        }
        if (y < -_offsetY) {
            _offsetY = Math.ceil(-y / _v) * _v;
            _height += _offsetY;
            _canvas.height = _height;
            _flag = true;
        }
        if (_flag) {
            _pixelCtx.translate(_offsetX, _offsetY);
        }
    }
    function getPixelOffset() {
        return {
            x: _offsetX,
            y: _offsetY
        };
    }
    function indexOf(array, value) {
        if (array.indexOf) {
            return array.indexOf(value);
        }
        for (var i = 0, len = array.length; i < len; i++) {
            if (array[i] === value) {
                return i;
            }
        }
        return -1;
    }
    function inherits(clazz, baseClazz) {
        var clazzPrototype = clazz.prototype;
        function F() {
        }
        F.prototype = baseClazz.prototype;
        clazz.prototype = new F();
        for (var prop in clazzPrototype) {
            clazz.prototype[prop] = clazzPrototype[prop];
        }
        clazz.constructor = clazz;
    }
    return {
        inherits: inherits,
        clone: clone,
        merge: merge,
        getContext: getContext,
        getPixelContext: getPixelContext,
        getPixelOffset: getPixelOffset,
        adjustCanvasSize: adjustCanvasSize,
        indexOf: indexOf
    };
});define('zrender/tool/event', [
    'require',
    '../mixin/Eventful'
], function (require) {
    'use strict';
    var Eventful = require('../mixin/Eventful');
    function getX(e) {
        return typeof e.zrenderX != 'undefined' && e.zrenderX || typeof e.offsetX != 'undefined' && e.offsetX || typeof e.layerX != 'undefined' && e.layerX || typeof e.clientX != 'undefined' && e.clientX;
    }
    function getY(e) {
        return typeof e.zrenderY != 'undefined' && e.zrenderY || typeof e.offsetY != 'undefined' && e.offsetY || typeof e.layerY != 'undefined' && e.layerY || typeof e.clientY != 'undefined' && e.clientY;
    }
    function getDelta(e) {
        return typeof e.zrenderDelta != 'undefined' && e.zrenderDelta || typeof e.wheelDelta != 'undefined' && e.wheelDelta || typeof e.detail != 'undefined' && -e.detail;
    }
    var stop = typeof window.addEventListener === 'function' ? function (e) {
        e.preventDefault();
        e.stopPropagation();
        e.cancelBubble = true;
    } : function (e) {
        e.returnValue = false;
        e.cancelBubble = true;
    };
    return {
        getX: getX,
        getY: getY,
        getDelta: getDelta,
        stop: stop,
        Dispatcher: Eventful
    };
});define('zrender/tool/env', [], function () {
    function detect(ua) {
        var os = this.os = {};
        var browser = this.browser = {};
        var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
        var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
        var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
        var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
        var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
        var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
        var touchpad = webos && ua.match(/TouchPad/);
        var kindle = ua.match(/Kindle\/([\d.]+)/);
        var silk = ua.match(/Silk\/([\d._]+)/);
        var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
        var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
        var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
        var playbook = ua.match(/PlayBook/);
        var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
        var firefox = ua.match(/Firefox\/([\d.]+)/);
        var ie = ua.match(/MSIE ([\d.]+)/);
        var safari = webkit && ua.match(/Mobile\//) && !chrome;
        var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;
        var ie = ua.match(/MSIE\s([\d.]+)/);
        if (browser.webkit = !!webkit)
            browser.version = webkit[1];
        if (android)
            os.android = true, os.version = android[2];
        if (iphone && !ipod)
            os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
        if (ipad)
            os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
        if (ipod)
            os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
        if (webos)
            os.webos = true, os.version = webos[2];
        if (touchpad)
            os.touchpad = true;
        if (blackberry)
            os.blackberry = true, os.version = blackberry[2];
        if (bb10)
            os.bb10 = true, os.version = bb10[2];
        if (rimtabletos)
            os.rimtabletos = true, os.version = rimtabletos[2];
        if (playbook)
            browser.playbook = true;
        if (kindle)
            os.kindle = true, os.version = kindle[1];
        if (silk)
            browser.silk = true, browser.version = silk[1];
        if (!silk && os.android && ua.match(/Kindle Fire/))
            browser.silk = true;
        if (chrome)
            browser.chrome = true, browser.version = chrome[1];
        if (firefox)
            browser.firefox = true, browser.version = firefox[1];
        if (ie)
            browser.ie = true, browser.version = ie[1];
        if (safari && (ua.match(/Safari/) || !!os.ios))
            browser.safari = true;
        if (webview)
            browser.webview = true;
        if (ie)
            browser.ie = true, browser.version = ie[1];
        os.tablet = !!(ipad || playbook || android && !ua.match(/Mobile/) || firefox && ua.match(/Tablet/) || ie && !ua.match(/Phone/) && ua.match(/Touch/));
        os.phone = !!(!os.tablet && !os.ipod && (android || iphone || webos || blackberry || bb10 || chrome && ua.match(/Android/) || chrome && ua.match(/CriOS\/([\d.]+)/) || firefox && ua.match(/Mobile/) || ie && ua.match(/Touch/)));
        return {
            browser: browser,
            os: os,
            canvasSupported: document.createElement('canvas').getContext ? true : false
        };
    }
    return detect(navigator.userAgent);
});define('zrender', ['zrender/zrender'], function (main) {return main;});
define('zrender/zrender', [
    'require',
    './dep/excanvas',
    './tool/util',
    './tool/log',
    './tool/guid',
    './Handler',
    './Painter',
    './Storage',
    './animation/Animation',
    './tool/env'
], function (require) {
    require('./dep/excanvas');
    var util = require('./tool/util');
    var log = require('./tool/log');
    var guid = require('./tool/guid');
    var Handler = require('./Handler');
    var Painter = require('./Painter');
    var Storage = require('./Storage');
    var Animation = require('./animation/Animation');
    var _instances = {};
    var zrender = {};
    zrender.version = '2.0.8';
    zrender.init = function (dom) {
        var zr = new ZRender(guid(), dom);
        _instances[zr.id] = zr;
        return zr;
    };
    zrender.dispose = function (zr) {
        if (zr) {
            zr.dispose();
        } else {
            for (var key in _instances) {
                _instances[key].dispose();
            }
            _instances = {};
        }
        return zrender;
    };
    zrender.getInstance = function (id) {
        return _instances[id];
    };
    zrender.delInstance = function (id) {
        delete _instances[id];
        return zrender;
    };
    function getFrameCallback(zrInstance) {
        return function () {
            var animatingElements = zrInstance.animatingElements;
            for (var i = 0, l = animatingElements.length; i < l; i++) {
                zrInstance.storage.mod(animatingElements[i].id);
            }
            if (animatingElements.length || zrInstance._needsRefreshNextFrame) {
                zrInstance.refresh();
            }
        };
    }
    var ZRender = function (id, dom) {
        this.id = id;
        this.env = require('./tool/env');
        this.storage = new Storage();
        this.painter = new Painter(dom, this.storage);
        this.handler = new Handler(dom, this.storage, this.painter);
        this.animatingElements = [];
        this.animation = new Animation({ stage: { update: getFrameCallback(this) } });
        this.animation.start();
        var self = this;
        this.painter.refreshNextFrame = function () {
            self.refreshNextFrame();
        };
        this._needsRefreshNextFrame = false;
        var self = this;
        var storage = this.storage;
        var oldDelFromMap = storage.delFromMap;
        storage.delFromMap = function (elId) {
            var el = storage.get(elId);
            self.stopAnimation(el);
            oldDelFromMap.call(storage, elId);
        };
    };
    ZRender.prototype.getId = function () {
        return this.id;
    };
    ZRender.prototype.addShape = function (shape) {
        this.addElement(shape);
        return this;
    };
    ZRender.prototype.addGroup = function (group) {
        this.addElement(group);
        return this;
    };
    ZRender.prototype.delShape = function (shapeId) {
        this.delElement(shapeId);
        return this;
    };
    ZRender.prototype.delGroup = function (groupId) {
        this.delElement(groupId);
        return this;
    };
    ZRender.prototype.modShape = function (shapeId, shape) {
        this.modElement(shapeId, shape);
        return this;
    };
    ZRender.prototype.modGroup = function (groupId, group) {
        this.modElement(groupId, group);
        return this;
    };
    ZRender.prototype.addElement = function (el) {
        this.storage.addRoot(el);
        this._needsRefreshNextFrame = true;
        return this;
    };
    ZRender.prototype.delElement = function (el) {
        this.storage.delRoot(el);
        this._needsRefreshNextFrame = true;
        return this;
    };
    ZRender.prototype.modElement = function (el, params) {
        this.storage.mod(el, params);
        this._needsRefreshNextFrame = true;
        return this;
    };
    ZRender.prototype.modLayer = function (zLevel, config) {
        this.painter.modLayer(zLevel, config);
        this._needsRefreshNextFrame = true;
        return this;
    };
    ZRender.prototype.addHoverShape = function (shape) {
        this.storage.addHover(shape);
        return this;
    };
    ZRender.prototype.render = function (callback) {
        this.painter.render(callback);
        this._needsRefreshNextFrame = false;
        return this;
    };
    ZRender.prototype.refresh = function (callback) {
        this.painter.refresh(callback);
        this._needsRefreshNextFrame = false;
        return this;
    };
    ZRender.prototype.refreshNextFrame = function () {
        this._needsRefreshNextFrame = true;
        return this;
    };
    ZRender.prototype.refreshHover = function (callback) {
        this.painter.refreshHover(callback);
        return this;
    };
    ZRender.prototype.refreshShapes = function (shapeList, callback) {
        this.painter.refreshShapes(shapeList, callback);
        return this;
    };
    ZRender.prototype.resize = function () {
        this.painter.resize();
        return this;
    };
    ZRender.prototype.animate = function (el, path, loop) {
        if (typeof el === 'string') {
            el = this.storage.get(el);
        }
        if (el) {
            var target;
            if (path) {
                var pathSplitted = path.split('.');
                var prop = el;
                for (var i = 0, l = pathSplitted.length; i < l; i++) {
                    if (!prop) {
                        continue;
                    }
                    prop = prop[pathSplitted[i]];
                }
                if (prop) {
                    target = prop;
                }
            } else {
                target = el;
            }
            if (!target) {
                log('Property "' + path + '" is not existed in element ' + el.id);
                return;
            }
            var animatingElements = this.animatingElements;
            if (el.__animators == null) {
                el.__animators = [];
            }
            var animators = el.__animators;
            if (animators.length === 0) {
                animatingElements.push(el);
            }
            var animator = this.animation.animate(target, { loop: loop }).done(function () {
                var idx = util.indexOf(el.__animators, animator);
                if (idx >= 0) {
                    animators.splice(idx, 1);
                }
                if (animators.length === 0) {
                    var idx = util.indexOf(animatingElements, el);
                    animatingElements.splice(idx, 1);
                }
            });
            animators.push(animator);
            return animator;
        } else {
            log('Element not existed');
        }
    };
    ZRender.prototype.stopAnimation = function (el) {
        if (el.__animators) {
            var animators = el.__animators;
            var len = animators.length;
            for (var i = 0; i < len; i++) {
                animators[i].stop();
            }
            if (len > 0) {
                var animatingElements = this.animatingElements;
                var idx = util.indexOf(animatingElements, el);
                if (idx >= 0) {
                    animatingElements.splice(idx, 1);
                }
            }
            animators.length = 0;
        }
        return this;
    };
    ZRender.prototype.clearAnimation = function () {
        this.animation.clear();
        this.animatingElements.length = 0;
        return this;
    };
    ZRender.prototype.showLoading = function (loadingEffect) {
        this.painter.showLoading(loadingEffect);
        return this;
    };
    ZRender.prototype.hideLoading = function () {
        this.painter.hideLoading();
        return this;
    };
    ZRender.prototype.getWidth = function () {
        return this.painter.getWidth();
    };
    ZRender.prototype.getHeight = function () {
        return this.painter.getHeight();
    };
    ZRender.prototype.toDataURL = function (type, backgroundColor, args) {
        return this.painter.toDataURL(type, backgroundColor, args);
    };
    ZRender.prototype.shapeToImage = function (e, width, height) {
        var id = guid();
        return this.painter.shapeToImage(id, e, width, height);
    };
    ZRender.prototype.on = function (eventName, eventHandler, context) {
        this.handler.on(eventName, eventHandler, context);
        return this;
    };
    ZRender.prototype.un = function (eventName, eventHandler) {
        this.handler.un(eventName, eventHandler);
        return this;
    };
    ZRender.prototype.trigger = function (eventName, event) {
        this.handler.trigger(eventName, event);
        return this;
    };
    ZRender.prototype.clear = function () {
        this.storage.delRoot();
        this.painter.clear();
        return this;
    };
    ZRender.prototype.dispose = function () {
        this.animation.stop();
        this.clear();
        this.storage.dispose();
        this.painter.dispose();
        this.handler.dispose();
        this.animation = this.animatingElements = this.storage = this.painter = this.handler = null;
        zrender.delInstance(this.id);
    };
    return zrender;
});define('zrender/config', [], function () {
    var config = {
        EVENT: {
            RESIZE: 'resize',
            CLICK: 'click',
            DBLCLICK: 'dblclick',
            MOUSEWHEEL: 'mousewheel',
            MOUSEMOVE: 'mousemove',
            MOUSEOVER: 'mouseover',
            MOUSEOUT: 'mouseout',
            MOUSEDOWN: 'mousedown',
            MOUSEUP: 'mouseup',
            GLOBALOUT: 'globalout',
            DRAGSTART: 'dragstart',
            DRAGEND: 'dragend',
            DRAGENTER: 'dragenter',
            DRAGOVER: 'dragover',
            DRAGLEAVE: 'dragleave',
            DROP: 'drop',
            touchClickDelay: 300
        },
        catchBrushException: false,
        debugMode: 0,
        devicePixelRatio: Math.max(window.devicePixelRatio || 1, 1)
    };
    return config;
});define('echarts/chart/island', [
    'require',
    './base',
    'zrender/shape/Circle',
    '../config',
    '../util/ecData',
    'zrender/tool/util',
    'zrender/tool/event',
    'zrender/tool/color',
    '../util/accMath',
    '../chart'
], function (require) {
    var ChartBase = require('./base');
    var CircleShape = require('zrender/shape/Circle');
    var ecConfig = require('../config');
    ecConfig.island = {
        zlevel: 0,
        z: 5,
        r: 15,
        calculateStep: 0.1
    };
    var ecData = require('../util/ecData');
    var zrUtil = require('zrender/tool/util');
    var zrEvent = require('zrender/tool/event');
    function Island(ecTheme, messageCenter, zr, option, myChart) {
        ChartBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        this._nameConnector;
        this._valueConnector;
        this._zrHeight = this.zr.getHeight();
        this._zrWidth = this.zr.getWidth();
        var self = this;
        self.shapeHandler.onmousewheel = function (param) {
            var shape = param.target;
            var event = param.event;
            var delta = zrEvent.getDelta(event);
            delta = delta > 0 ? -1 : 1;
            shape.style.r -= delta;
            shape.style.r = shape.style.r < 5 ? 5 : shape.style.r;
            var value = ecData.get(shape, 'value');
            var dvalue = value * self.option.island.calculateStep;
            value = dvalue > 1 ? Math.round(value - dvalue * delta) : +(value - dvalue * delta).toFixed(2);
            var name = ecData.get(shape, 'name');
            shape.style.text = name + ':' + value;
            ecData.set(shape, 'value', value);
            ecData.set(shape, 'name', name);
            self.zr.modShape(shape.id);
            self.zr.refreshNextFrame();
            zrEvent.stop(event);
        };
    }
    Island.prototype = {
        type: ecConfig.CHART_TYPE_ISLAND,
        _combine: function (tarShape, srcShape) {
            var zrColor = require('zrender/tool/color');
            var accMath = require('../util/accMath');
            var value = accMath.accAdd(ecData.get(tarShape, 'value'), ecData.get(srcShape, 'value'));
            var name = ecData.get(tarShape, 'name') + this._nameConnector + ecData.get(srcShape, 'name');
            tarShape.style.text = name + this._valueConnector + value;
            ecData.set(tarShape, 'value', value);
            ecData.set(tarShape, 'name', name);
            tarShape.style.r = this.option.island.r;
            tarShape.style.color = zrColor.mix(tarShape.style.color, srcShape.style.color);
        },
        refresh: function (newOption) {
            if (newOption) {
                newOption.island = this.reformOption(newOption.island);
                this.option = newOption;
                this._nameConnector = this.option.nameConnector;
                this._valueConnector = this.option.valueConnector;
            }
        },
        getOption: function () {
            return this.option;
        },
        resize: function () {
            var newWidth = this.zr.getWidth();
            var newHieght = this.zr.getHeight();
            var xScale = newWidth / (this._zrWidth || newWidth);
            var yScale = newHieght / (this._zrHeight || newHieght);
            if (xScale === 1 && yScale === 1) {
                return;
            }
            this._zrWidth = newWidth;
            this._zrHeight = newHieght;
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                this.zr.modShape(this.shapeList[i].id, {
                    style: {
                        x: Math.round(this.shapeList[i].style.x * xScale),
                        y: Math.round(this.shapeList[i].style.y * yScale)
                    }
                });
            }
        },
        add: function (shape) {
            var name = ecData.get(shape, 'name');
            var value = ecData.get(shape, 'value');
            var seriesName = ecData.get(shape, 'series') != null ? ecData.get(shape, 'series').name : '';
            var font = this.getFont(this.option.island.textStyle);
            var islandShape = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                style: {
                    x: shape.style.x,
                    y: shape.style.y,
                    r: this.option.island.r,
                    color: shape.style.color || shape.style.strokeColor,
                    text: name + this._valueConnector + value,
                    textFont: font
                },
                draggable: true,
                hoverable: true,
                onmousewheel: this.shapeHandler.onmousewheel,
                _type: 'island'
            };
            if (islandShape.style.color === '#fff') {
                islandShape.style.color = shape.style.strokeColor;
            }
            this.setCalculable(islandShape);
            islandShape.dragEnableTime = 0;
            ecData.pack(islandShape, { name: seriesName }, -1, value, -1, name);
            islandShape = new CircleShape(islandShape);
            this.shapeList.push(islandShape);
            this.zr.addShape(islandShape);
        },
        del: function (shape) {
            this.zr.delShape(shape.id);
            var newShapeList = [];
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                if (this.shapeList[i].id != shape.id) {
                    newShapeList.push(this.shapeList[i]);
                }
            }
            this.shapeList = newShapeList;
        },
        ondrop: function (param, status) {
            if (!this.isDrop || !param.target) {
                return;
            }
            var target = param.target;
            var dragged = param.dragged;
            this._combine(target, dragged);
            this.zr.modShape(target.id);
            status.dragIn = true;
            this.isDrop = false;
            return;
        },
        ondragend: function (param, status) {
            var target = param.target;
            if (!this.isDragend) {
                if (!status.dragIn) {
                    target.style.x = zrEvent.getX(param.event);
                    target.style.y = zrEvent.getY(param.event);
                    this.add(target);
                    status.needRefresh = true;
                }
            } else {
                if (status.dragIn) {
                    this.del(target);
                    status.needRefresh = true;
                }
            }
            this.isDragend = false;
            return;
        }
    };
    zrUtil.inherits(Island, ChartBase);
    require('../chart').define('island', Island);
    return Island;
});define('echarts/component/toolbox', [
    'require',
    './base',
    'zrender/shape/Line',
    'zrender/shape/Image',
    'zrender/shape/Rectangle',
    '../util/shape/Icon',
    '../config',
    'zrender/tool/util',
    'zrender/config',
    'zrender/tool/event',
    './dataView',
    '../component'
], function (require) {
    var Base = require('./base');
    var LineShape = require('zrender/shape/Line');
    var ImageShape = require('zrender/shape/Image');
    var RectangleShape = require('zrender/shape/Rectangle');
    var IconShape = require('../util/shape/Icon');
    var ecConfig = require('../config');
    ecConfig.toolbox = {
        zlevel: 0,
        z: 6,
        show: false,
        orient: 'horizontal',
        x: 'right',
        y: 'top',
        color: [
            '#1e90ff',
            '#22bb22',
            '#4b0082',
            '#d2691e'
        ],
        disableColor: '#ddd',
        effectiveColor: 'red',
        backgroundColor: 'rgba(0,0,0,0)',
        borderColor: '#ccc',
        borderWidth: 0,
        padding: 5,
        itemGap: 10,
        itemSize: 16,
        showTitle: true,
        feature: {
            mark: {
                show: false,
                title: {
                    mark: 'è¾…åŠ©çº¿å¼€å…³',
                    markUndo: 'åˆ é™¤è¾…åŠ©çº¿',
                    markClear: 'æ¸…ç©ºè¾…åŠ©çº¿'
                },
                lineStyle: {
                    width: 1,
                    color: '#1e90ff',
                    type: 'dashed'
                }
            },
            dataZoom: {
                show: false,
                title: {
                    dataZoom: 'åŒºåŸŸç¼©æ”¾',
                    dataZoomReset: 'åŒºåŸŸç¼©æ”¾åŽé€€'
                }
            },
            dataView: {
                show: false,
                title: 'æ•°æ®è§†å›¾',
                readOnly: false,
                lang: [
                    'æ•°æ®è§†å›¾',
                    'å…³é—­',
                    'åˆ·æ–°'
                ]
            },
            magicType: {
                show: false,
                title: {
                    line: 'æŠ˜çº¿å›¾åˆ‡æ¢',
                    bar: 'æŸ±å½¢å›¾åˆ‡æ¢',
                    stack: 'å †ç§¯',
                    tiled: 'å¹³é“º',
                    force: 'åŠ›å¯¼å‘å¸ƒå±€å›¾åˆ‡æ¢',
                    chord: 'å’Œå¼¦å›¾åˆ‡æ¢',
                    pie: 'é¥¼å›¾åˆ‡æ¢',
                    funnel: 'æ¼æ–—å›¾åˆ‡æ¢'
                },
                type: []
            },
            restore: {
                show: false,
                title: 'è¿˜åŽŸ'
            },
            saveAsImage: {
                show: false,
                title: 'ä¿å­˜ä¸ºå›¾ç‰‡',
                type: 'png',
                lang: ['ç‚¹å‡»ä¿å­˜']
            }
        }
    };
    var zrUtil = require('zrender/tool/util');
    var zrConfig = require('zrender/config');
    var zrEvent = require('zrender/tool/event');
    var _MAGICTYPE_STACK = 'stack';
    var _MAGICTYPE_TILED = 'tiled';
    function Toolbox(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.dom = myChart.dom;
        this._magicType = {};
        this._magicMap = {};
        this._isSilence = false;
        this._iconList;
        this._iconShapeMap = {};
        this._featureTitle = {};
        this._featureIcon = {};
        this._featureColor = {};
        this._featureOption = {};
        this._enableColor = 'red';
        this._disableColor = '#ccc';
        this._markShapeList = [];
        var self = this;
        self._onMark = function (param) {
            self.__onMark(param);
        };
        self._onMarkUndo = function (param) {
            self.__onMarkUndo(param);
        };
        self._onMarkClear = function (param) {
            self.__onMarkClear(param);
        };
        self._onDataZoom = function (param) {
            self.__onDataZoom(param);
        };
        self._onDataZoomReset = function (param) {
            self.__onDataZoomReset(param);
        };
        self._onDataView = function (param) {
            self.__onDataView(param);
        };
        self._onRestore = function (param) {
            self.__onRestore(param);
        };
        self._onSaveAsImage = function (param) {
            self.__onSaveAsImage(param);
        };
        self._onMagicType = function (param) {
            self.__onMagicType(param);
        };
        self._onCustomHandler = function (param) {
            self.__onCustomHandler(param);
        };
        self._onmousemove = function (param) {
            return self.__onmousemove(param);
        };
        self._onmousedown = function (param) {
            return self.__onmousedown(param);
        };
        self._onmouseup = function (param) {
            return self.__onmouseup(param);
        };
        self._onclick = function (param) {
            return self.__onclick(param);
        };
    }
    Toolbox.prototype = {
        type: ecConfig.COMPONENT_TYPE_TOOLBOX,
        _buildShape: function () {
            this._iconList = [];
            var toolboxOption = this.option.toolbox;
            this._enableColor = toolboxOption.effectiveColor;
            this._disableColor = toolboxOption.disableColor;
            var feature = toolboxOption.feature;
            var iconName = [];
            for (var key in feature) {
                if (feature[key].show) {
                    switch (key) {
                    case 'mark':
                        iconName.push({
                            key: key,
                            name: 'mark'
                        });
                        iconName.push({
                            key: key,
                            name: 'markUndo'
                        });
                        iconName.push({
                            key: key,
                            name: 'markClear'
                        });
                        break;
                    case 'magicType':
                        for (var i = 0, l = feature[key].type.length; i < l; i++) {
                            feature[key].title[feature[key].type[i] + 'Chart'] = feature[key].title[feature[key].type[i]];
                            if (feature[key].option) {
                                feature[key].option[feature[key].type[i] + 'Chart'] = feature[key].option[feature[key].type[i]];
                            }
                            iconName.push({
                                key: key,
                                name: feature[key].type[i] + 'Chart'
                            });
                        }
                        break;
                    case 'dataZoom':
                        iconName.push({
                            key: key,
                            name: 'dataZoom'
                        });
                        iconName.push({
                            key: key,
                            name: 'dataZoomReset'
                        });
                        break;
                    case 'saveAsImage':
                        if (this.canvasSupported) {
                            iconName.push({
                                key: key,
                                name: 'saveAsImage'
                            });
                        }
                        break;
                    default:
                        iconName.push({
                            key: key,
                            name: key
                        });
                        break;
                    }
                }
            }
            if (iconName.length > 0) {
                var name;
                var key;
                for (var i = 0, l = iconName.length; i < l; i++) {
                    name = iconName[i].name;
                    key = iconName[i].key;
                    this._iconList.push(name);
                    this._featureTitle[name] = feature[key].title[name] || feature[key].title;
                    if (feature[key].icon) {
                        this._featureIcon[name] = feature[key].icon[name] || feature[key].icon;
                    }
                    if (feature[key].color) {
                        this._featureColor[name] = feature[key].color[name] || feature[key].color;
                    }
                    if (feature[key].option) {
                        this._featureOption[name] = feature[key].option[name] || feature[key].option;
                    }
                }
                this._itemGroupLocation = this._getItemGroupLocation();
                this._buildBackground();
                this._buildItem();
                for (var i = 0, l = this.shapeList.length; i < l; i++) {
                    this.zr.addShape(this.shapeList[i]);
                }
                if (this._iconShapeMap['mark']) {
                    this._iconDisable(this._iconShapeMap['markUndo']);
                    this._iconDisable(this._iconShapeMap['markClear']);
                }
                if (this._iconShapeMap['dataZoomReset'] && this._zoomQueue.length === 0) {
                    this._iconDisable(this._iconShapeMap['dataZoomReset']);
                }
            }
        },
        _buildItem: function () {
            var toolboxOption = this.option.toolbox;
            var iconLength = this._iconList.length;
            var lastX = this._itemGroupLocation.x;
            var lastY = this._itemGroupLocation.y;
            var itemSize = toolboxOption.itemSize;
            var itemGap = toolboxOption.itemGap;
            var itemShape;
            var color = toolboxOption.color instanceof Array ? toolboxOption.color : [toolboxOption.color];
            var textFont = this.getFont(toolboxOption.textStyle);
            var textPosition;
            var textAlign;
            var textBaseline;
            if (toolboxOption.orient === 'horizontal') {
                textPosition = this._itemGroupLocation.y / this.zr.getHeight() < 0.5 ? 'bottom' : 'top';
                textAlign = this._itemGroupLocation.x / this.zr.getWidth() < 0.5 ? 'left' : 'right';
                textBaseline = this._itemGroupLocation.y / this.zr.getHeight() < 0.5 ? 'top' : 'bottom';
            } else {
                textPosition = this._itemGroupLocation.x / this.zr.getWidth() < 0.5 ? 'right' : 'left';
            }
            this._iconShapeMap = {};
            var self = this;
            for (var i = 0; i < iconLength; i++) {
                itemShape = {
                    type: 'icon',
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    style: {
                        x: lastX,
                        y: lastY,
                        width: itemSize,
                        height: itemSize,
                        iconType: this._iconList[i],
                        lineWidth: 1,
                        strokeColor: this._featureColor[this._iconList[i]] || color[i % color.length],
                        brushType: 'stroke'
                    },
                    highlightStyle: {
                        lineWidth: 1,
                        text: toolboxOption.showTitle ? this._featureTitle[this._iconList[i]] : undefined,
                        textFont: textFont,
                        textPosition: textPosition,
                        strokeColor: this._featureColor[this._iconList[i]] || color[i % color.length]
                    },
                    hoverable: true,
                    clickable: true
                };
                if (this._featureIcon[this._iconList[i]]) {
                    itemShape.style.image = this._featureIcon[this._iconList[i]].replace(new RegExp('^image:\\/\\/'), '');
                    itemShape.style.opacity = 0.8;
                    itemShape.highlightStyle.opacity = 1;
                    itemShape.type = 'image';
                }
                if (toolboxOption.orient === 'horizontal') {
                    if (i === 0 && textAlign === 'left') {
                        itemShape.highlightStyle.textPosition = 'specific';
                        itemShape.highlightStyle.textAlign = textAlign;
                        itemShape.highlightStyle.textBaseline = textBaseline;
                        itemShape.highlightStyle.textX = lastX;
                        itemShape.highlightStyle.textY = textBaseline === 'top' ? lastY + itemSize + 10 : lastY - 10;
                    }
                    if (i === iconLength - 1 && textAlign === 'right') {
                        itemShape.highlightStyle.textPosition = 'specific';
                        itemShape.highlightStyle.textAlign = textAlign;
                        itemShape.highlightStyle.textBaseline = textBaseline;
                        itemShape.highlightStyle.textX = lastX + itemSize;
                        itemShape.highlightStyle.textY = textBaseline === 'top' ? lastY + itemSize + 10 : lastY - 10;
                    }
                }
                switch (this._iconList[i]) {
                case 'mark':
                    itemShape.onclick = self._onMark;
                    break;
                case 'markUndo':
                    itemShape.onclick = self._onMarkUndo;
                    break;
                case 'markClear':
                    itemShape.onclick = self._onMarkClear;
                    break;
                case 'dataZoom':
                    itemShape.onclick = self._onDataZoom;
                    break;
                case 'dataZoomReset':
                    itemShape.onclick = self._onDataZoomReset;
                    break;
                case 'dataView':
                    if (!this._dataView) {
                        var DataView = require('./dataView');
                        this._dataView = new DataView(this.ecTheme, this.messageCenter, this.zr, this.option, this.myChart);
                    }
                    itemShape.onclick = self._onDataView;
                    break;
                case 'restore':
                    itemShape.onclick = self._onRestore;
                    break;
                case 'saveAsImage':
                    itemShape.onclick = self._onSaveAsImage;
                    break;
                default:
                    if (this._iconList[i].match('Chart')) {
                        itemShape._name = this._iconList[i].replace('Chart', '');
                        itemShape.onclick = self._onMagicType;
                    } else {
                        itemShape.onclick = self._onCustomHandler;
                    }
                    break;
                }
                if (itemShape.type === 'icon') {
                    itemShape = new IconShape(itemShape);
                } else if (itemShape.type === 'image') {
                    itemShape = new ImageShape(itemShape);
                }
                this.shapeList.push(itemShape);
                this._iconShapeMap[this._iconList[i]] = itemShape;
                if (toolboxOption.orient === 'horizontal') {
                    lastX += itemSize + itemGap;
                } else {
                    lastY += itemSize + itemGap;
                }
            }
        },
        _buildBackground: function () {
            var toolboxOption = this.option.toolbox;
            var padding = this.reformCssArray(this.option.toolbox.padding);
            this.shapeList.push(new RectangleShape({
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                hoverable: false,
                style: {
                    x: this._itemGroupLocation.x - padding[3],
                    y: this._itemGroupLocation.y - padding[0],
                    width: this._itemGroupLocation.width + padding[3] + padding[1],
                    height: this._itemGroupLocation.height + padding[0] + padding[2],
                    brushType: toolboxOption.borderWidth === 0 ? 'fill' : 'both',
                    color: toolboxOption.backgroundColor,
                    strokeColor: toolboxOption.borderColor,
                    lineWidth: toolboxOption.borderWidth
                }
            }));
        },
        _getItemGroupLocation: function () {
            var toolboxOption = this.option.toolbox;
            var padding = this.reformCssArray(this.option.toolbox.padding);
            var iconLength = this._iconList.length;
            var itemGap = toolboxOption.itemGap;
            var itemSize = toolboxOption.itemSize;
            var totalWidth = 0;
            var totalHeight = 0;
            if (toolboxOption.orient === 'horizontal') {
                totalWidth = (itemSize + itemGap) * iconLength - itemGap;
                totalHeight = itemSize;
            } else {
                totalHeight = (itemSize + itemGap) * iconLength - itemGap;
                totalWidth = itemSize;
            }
            var x;
            var zrWidth = this.zr.getWidth();
            switch (toolboxOption.x) {
            case 'center':
                x = Math.floor((zrWidth - totalWidth) / 2);
                break;
            case 'left':
                x = padding[3] + toolboxOption.borderWidth;
                break;
            case 'right':
                x = zrWidth - totalWidth - padding[1] - toolboxOption.borderWidth;
                break;
            default:
                x = toolboxOption.x - 0;
                x = isNaN(x) ? 0 : x;
                break;
            }
            var y;
            var zrHeight = this.zr.getHeight();
            switch (toolboxOption.y) {
            case 'top':
                y = padding[0] + toolboxOption.borderWidth;
                break;
            case 'bottom':
                y = zrHeight - totalHeight - padding[2] - toolboxOption.borderWidth;
                break;
            case 'center':
                y = Math.floor((zrHeight - totalHeight) / 2);
                break;
            default:
                y = toolboxOption.y - 0;
                y = isNaN(y) ? 0 : y;
                break;
            }
            return {
                x: x,
                y: y,
                width: totalWidth,
                height: totalHeight
            };
        },
        __onmousemove: function (param) {
            if (this._marking) {
                this._markShape.style.xEnd = zrEvent.getX(param.event);
                this._markShape.style.yEnd = zrEvent.getY(param.event);
                this.zr.addHoverShape(this._markShape);
            }
            if (this._zooming) {
                this._zoomShape.style.width = zrEvent.getX(param.event) - this._zoomShape.style.x;
                this._zoomShape.style.height = zrEvent.getY(param.event) - this._zoomShape.style.y;
                this.zr.addHoverShape(this._zoomShape);
                this.dom.style.cursor = 'crosshair';
                zrEvent.stop(param.event);
            }
            if (this._zoomStart && (this.dom.style.cursor != 'pointer' && this.dom.style.cursor != 'move')) {
                this.dom.style.cursor = 'crosshair';
            }
        },
        __onmousedown: function (param) {
            if (param.target) {
                return;
            }
            this._zooming = true;
            var x = zrEvent.getX(param.event);
            var y = zrEvent.getY(param.event);
            var zoomOption = this.option.dataZoom || {};
            this._zoomShape = new RectangleShape({
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                style: {
                    x: x,
                    y: y,
                    width: 1,
                    height: 1,
                    brushType: 'both'
                },
                highlightStyle: {
                    lineWidth: 2,
                    color: zoomOption.fillerColor || ecConfig.dataZoom.fillerColor,
                    strokeColor: zoomOption.handleColor || ecConfig.dataZoom.handleColor,
                    brushType: 'both'
                }
            });
            this.zr.addHoverShape(this._zoomShape);
            return true;
        },
        __onmouseup: function () {
            if (!this._zoomShape || Math.abs(this._zoomShape.style.width) < 10 || Math.abs(this._zoomShape.style.height) < 10) {
                this._zooming = false;
                return true;
            }
            if (this._zooming && this.component.dataZoom) {
                this._zooming = false;
                var zoom = this.component.dataZoom.rectZoom(this._zoomShape.style);
                if (zoom) {
                    this._zoomQueue.push({
                        start: zoom.start,
                        end: zoom.end,
                        start2: zoom.start2,
                        end2: zoom.end2
                    });
                    this._iconEnable(this._iconShapeMap['dataZoomReset']);
                    this.zr.refreshNextFrame();
                }
            }
            return true;
        },
        __onclick: function (param) {
            if (param.target) {
                return;
            }
            if (this._marking) {
                this._marking = false;
                this._markShapeList.push(this._markShape);
                this._iconEnable(this._iconShapeMap['markUndo']);
                this._iconEnable(this._iconShapeMap['markClear']);
                this.zr.addShape(this._markShape);
                this.zr.refreshNextFrame();
            } else if (this._markStart) {
                this._marking = true;
                var x = zrEvent.getX(param.event);
                var y = zrEvent.getY(param.event);
                this._markShape = new LineShape({
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    style: {
                        xStart: x,
                        yStart: y,
                        xEnd: x,
                        yEnd: y,
                        lineWidth: this.query(this.option, 'toolbox.feature.mark.lineStyle.width'),
                        strokeColor: this.query(this.option, 'toolbox.feature.mark.lineStyle.color'),
                        lineType: this.query(this.option, 'toolbox.feature.mark.lineStyle.type')
                    }
                });
                this.zr.addHoverShape(this._markShape);
            }
        },
        __onMark: function (param) {
            var target = param.target;
            if (this._marking || this._markStart) {
                this._resetMark();
                this.zr.refreshNextFrame();
            } else {
                this._resetZoom();
                this.zr.modShape(target.id, { style: { strokeColor: this._enableColor } });
                this.zr.refreshNextFrame();
                this._markStart = true;
                var self = this;
                setTimeout(function () {
                    self.zr && self.zr.on(zrConfig.EVENT.CLICK, self._onclick) && self.zr.on(zrConfig.EVENT.MOUSEMOVE, self._onmousemove);
                }, 10);
            }
            return true;
        },
        __onMarkUndo: function () {
            if (this._marking) {
                this._marking = false;
            } else {
                var len = this._markShapeList.length;
                if (len >= 1) {
                    var target = this._markShapeList[len - 1];
                    this.zr.delShape(target.id);
                    this.zr.refreshNextFrame();
                    this._markShapeList.pop();
                    if (len === 1) {
                        this._iconDisable(this._iconShapeMap['markUndo']);
                        this._iconDisable(this._iconShapeMap['markClear']);
                    }
                }
            }
            return true;
        },
        __onMarkClear: function () {
            if (this._marking) {
                this._marking = false;
            }
            var len = this._markShapeList.length;
            if (len > 0) {
                while (len--) {
                    this.zr.delShape(this._markShapeList.pop().id);
                }
                this._iconDisable(this._iconShapeMap['markUndo']);
                this._iconDisable(this._iconShapeMap['markClear']);
                this.zr.refreshNextFrame();
            }
            return true;
        },
        __onDataZoom: function (param) {
            var target = param.target;
            if (this._zooming || this._zoomStart) {
                this._resetZoom();
                this.zr.refreshNextFrame();
                this.dom.style.cursor = 'default';
            } else {
                this._resetMark();
                this.zr.modShape(target.id, { style: { strokeColor: this._enableColor } });
                this.zr.refreshNextFrame();
                this._zoomStart = true;
                var self = this;
                setTimeout(function () {
                    self.zr && self.zr.on(zrConfig.EVENT.MOUSEDOWN, self._onmousedown) && self.zr.on(zrConfig.EVENT.MOUSEUP, self._onmouseup) && self.zr.on(zrConfig.EVENT.MOUSEMOVE, self._onmousemove);
                }, 10);
                this.dom.style.cursor = 'crosshair';
            }
            return true;
        },
        __onDataZoomReset: function () {
            if (this._zooming) {
                this._zooming = false;
            }
            this._zoomQueue.pop();
            if (this._zoomQueue.length > 0) {
                this.component.dataZoom.absoluteZoom(this._zoomQueue[this._zoomQueue.length - 1]);
            } else {
                this.component.dataZoom.rectZoom();
                this._iconDisable(this._iconShapeMap['dataZoomReset']);
                this.zr.refreshNextFrame();
            }
            return true;
        },
        _resetMark: function () {
            this._marking = false;
            if (this._markStart) {
                this._markStart = false;
                if (this._iconShapeMap['mark']) {
                    this.zr.modShape(this._iconShapeMap['mark'].id, { style: { strokeColor: this._iconShapeMap['mark'].highlightStyle.strokeColor } });
                }
                this.zr.un(zrConfig.EVENT.CLICK, this._onclick);
                this.zr.un(zrConfig.EVENT.MOUSEMOVE, this._onmousemove);
            }
        },
        _resetZoom: function () {
            this._zooming = false;
            if (this._zoomStart) {
                this._zoomStart = false;
                if (this._iconShapeMap['dataZoom']) {
                    this.zr.modShape(this._iconShapeMap['dataZoom'].id, { style: { strokeColor: this._iconShapeMap['dataZoom'].highlightStyle.strokeColor } });
                }
                this.zr.un(zrConfig.EVENT.MOUSEDOWN, this._onmousedown);
                this.zr.un(zrConfig.EVENT.MOUSEUP, this._onmouseup);
                this.zr.un(zrConfig.EVENT.MOUSEMOVE, this._onmousemove);
            }
        },
        _iconDisable: function (target) {
            if (target.type != 'image') {
                this.zr.modShape(target.id, {
                    hoverable: false,
                    clickable: false,
                    style: { strokeColor: this._disableColor }
                });
            } else {
                this.zr.modShape(target.id, {
                    hoverable: false,
                    clickable: false,
                    style: { opacity: 0.3 }
                });
            }
        },
        _iconEnable: function (target) {
            if (target.type != 'image') {
                this.zr.modShape(target.id, {
                    hoverable: true,
                    clickable: true,
                    style: { strokeColor: target.highlightStyle.strokeColor }
                });
            } else {
                this.zr.modShape(target.id, {
                    hoverable: true,
                    clickable: true,
                    style: { opacity: 0.8 }
                });
            }
        },
        __onDataView: function () {
            this._dataView.show(this.option);
            return true;
        },
        __onRestore: function () {
            this._resetMark();
            this._resetZoom();
            this.messageCenter.dispatch(ecConfig.EVENT.RESTORE, null, null, this.myChart);
            return true;
        },
        __onSaveAsImage: function () {
            var saveOption = this.option.toolbox.feature.saveAsImage;
            var imgType = saveOption.type || 'png';
            if (imgType != 'png' && imgType != 'jpeg') {
                imgType = 'png';
            }
            var image;
            if (!this.myChart.isConnected()) {
                image = this.zr.toDataURL('image/' + imgType, this.option.backgroundColor && this.option.backgroundColor.replace(' ', '') === 'rgba(0,0,0,0)' ? '#fff' : this.option.backgroundColor);
            } else {
                image = this.myChart.getConnectedDataURL(imgType);
            }
            var downloadDiv = document.createElement('div');
            downloadDiv.id = '__echarts_download_wrap__';
            downloadDiv.style.cssText = 'position:fixed;' + 'z-index:99999;' + 'display:block;' + 'top:0;left:0;' + 'background-color:rgba(33,33,33,0.5);' + 'text-align:center;' + 'width:100%;' + 'height:100%;' + 'line-height:' + document.documentElement.clientHeight + 'px;';
            var downloadLink = document.createElement('a');
            downloadLink.href = image;
            downloadLink.setAttribute('download', (saveOption.name ? saveOption.name : this.option.title && (this.option.title.text || this.option.title.subtext) ? this.option.title.text || this.option.title.subtext : 'ECharts') + '.' + imgType);
            downloadLink.innerHTML = '<img style="vertical-align:middle" src="' + image + '" title="' + (!!window.ActiveXObject || 'ActiveXObject' in window ? 'å³é”®->å›¾ç‰‡å¦å­˜ä¸º' : saveOption.lang ? saveOption.lang[0] : 'ç‚¹å‡»ä¿å­˜') + '"/>';
            downloadDiv.appendChild(downloadLink);
            document.body.appendChild(downloadDiv);
            downloadLink = null;
            downloadDiv = null;
            setTimeout(function () {
                var _d = document.getElementById('__echarts_download_wrap__');
                if (_d) {
                    _d.onclick = function () {
                        var d = document.getElementById('__echarts_download_wrap__');
                        d.onclick = null;
                        d.innerHTML = '';
                        document.body.removeChild(d);
                        d = null;
                    };
                    _d = null;
                }
            }, 500);
            return;
        },
        __onMagicType: function (param) {
            this._resetMark();
            var itemName = param.target._name;
            if (!this._magicType[itemName]) {
                this._magicType[itemName] = true;
                if (itemName === ecConfig.CHART_TYPE_LINE) {
                    this._magicType[ecConfig.CHART_TYPE_BAR] = false;
                } else if (itemName === ecConfig.CHART_TYPE_BAR) {
                    this._magicType[ecConfig.CHART_TYPE_LINE] = false;
                }
                if (itemName === ecConfig.CHART_TYPE_PIE) {
                    this._magicType[ecConfig.CHART_TYPE_FUNNEL] = false;
                } else if (itemName === ecConfig.CHART_TYPE_FUNNEL) {
                    this._magicType[ecConfig.CHART_TYPE_PIE] = false;
                }
                if (itemName === ecConfig.CHART_TYPE_FORCE) {
                    this._magicType[ecConfig.CHART_TYPE_CHORD] = false;
                } else if (itemName === ecConfig.CHART_TYPE_CHORD) {
                    this._magicType[ecConfig.CHART_TYPE_FORCE] = false;
                }
                if (itemName === _MAGICTYPE_STACK) {
                    this._magicType[_MAGICTYPE_TILED] = false;
                } else if (itemName === _MAGICTYPE_TILED) {
                    this._magicType[_MAGICTYPE_STACK] = false;
                }
                this.messageCenter.dispatch(ecConfig.EVENT.MAGIC_TYPE_CHANGED, param.event, { magicType: this._magicType }, this.myChart);
            }
            return true;
        },
        setMagicType: function (magicType) {
            this._resetMark();
            this._magicType = magicType;
            !this._isSilence && this.messageCenter.dispatch(ecConfig.EVENT.MAGIC_TYPE_CHANGED, null, { magicType: this._magicType }, this.myChart);
        },
        __onCustomHandler: function (param) {
            var target = param.target.style.iconType;
            var featureHandler = this.option.toolbox.feature[target].onclick;
            if (typeof featureHandler === 'function') {
                featureHandler.call(this, this.option);
            }
        },
        reset: function (newOption, isRestore) {
            isRestore && this.clear();
            if (this.query(newOption, 'toolbox.show') && this.query(newOption, 'toolbox.feature.magicType.show')) {
                var magicType = newOption.toolbox.feature.magicType.type;
                var len = magicType.length;
                this._magicMap = {};
                while (len--) {
                    this._magicMap[magicType[len]] = true;
                }
                len = newOption.series.length;
                var oriType;
                var axis;
                while (len--) {
                    oriType = newOption.series[len].type;
                    if (this._magicMap[oriType]) {
                        axis = newOption.xAxis instanceof Array ? newOption.xAxis[newOption.series[len].xAxisIndex || 0] : newOption.xAxis;
                        if (axis && (axis.type || 'category') === 'category') {
                            axis.__boundaryGap = axis.boundaryGap != null ? axis.boundaryGap : true;
                        }
                        axis = newOption.yAxis instanceof Array ? newOption.yAxis[newOption.series[len].yAxisIndex || 0] : newOption.yAxis;
                        if (axis && axis.type === 'category') {
                            axis.__boundaryGap = axis.boundaryGap != null ? axis.boundaryGap : true;
                        }
                        newOption.series[len].__type = oriType;
                        newOption.series[len].__itemStyle = zrUtil.clone(newOption.series[len].itemStyle || {});
                    }
                    if (this._magicMap[_MAGICTYPE_STACK] || this._magicMap[_MAGICTYPE_TILED]) {
                        newOption.series[len].__stack = newOption.series[len].stack;
                    }
                }
            }
            this._magicType = isRestore ? {} : this._magicType || {};
            for (var itemName in this._magicType) {
                if (this._magicType[itemName]) {
                    this.option = newOption;
                    this.getMagicOption();
                    break;
                }
            }
            var zoomOption = newOption.dataZoom;
            if (zoomOption && zoomOption.show) {
                var start = zoomOption.start != null && zoomOption.start >= 0 && zoomOption.start <= 100 ? zoomOption.start : 0;
                var end = zoomOption.end != null && zoomOption.end >= 0 && zoomOption.end <= 100 ? zoomOption.end : 100;
                if (start > end) {
                    start = start + end;
                    end = start - end;
                    start = start - end;
                }
                this._zoomQueue = [{
                        start: start,
                        end: end,
                        start2: 0,
                        end2: 100
                    }];
            } else {
                this._zoomQueue = [];
            }
        },
        getMagicOption: function () {
            var axis;
            var chartType;
            if (this._magicType[ecConfig.CHART_TYPE_LINE] || this._magicType[ecConfig.CHART_TYPE_BAR]) {
                var boundaryGap = this._magicType[ecConfig.CHART_TYPE_LINE] ? false : true;
                for (var i = 0, l = this.option.series.length; i < l; i++) {
                    chartType = this.option.series[i].type;
                    if (chartType == ecConfig.CHART_TYPE_LINE || chartType == ecConfig.CHART_TYPE_BAR) {
                        axis = this.option.xAxis instanceof Array ? this.option.xAxis[this.option.series[i].xAxisIndex || 0] : this.option.xAxis;
                        if (axis && (axis.type || 'category') === 'category') {
                            axis.boundaryGap = boundaryGap ? true : axis.__boundaryGap;
                        }
                        axis = this.option.yAxis instanceof Array ? this.option.yAxis[this.option.series[i].yAxisIndex || 0] : this.option.yAxis;
                        if (axis && axis.type === 'category') {
                            axis.boundaryGap = boundaryGap ? true : axis.__boundaryGap;
                        }
                    }
                }
                this._defaultMagic(ecConfig.CHART_TYPE_LINE, ecConfig.CHART_TYPE_BAR);
            }
            this._defaultMagic(ecConfig.CHART_TYPE_CHORD, ecConfig.CHART_TYPE_FORCE);
            this._defaultMagic(ecConfig.CHART_TYPE_PIE, ecConfig.CHART_TYPE_FUNNEL);
            if (this._magicType[_MAGICTYPE_STACK] || this._magicType[_MAGICTYPE_TILED]) {
                for (var i = 0, l = this.option.series.length; i < l; i++) {
                    if (this._magicType[_MAGICTYPE_STACK]) {
                        this.option.series[i].stack = '_ECHARTS_STACK_KENER_2014_';
                        chartType = _MAGICTYPE_STACK;
                    } else if (this._magicType[_MAGICTYPE_TILED]) {
                        this.option.series[i].stack = null;
                        chartType = _MAGICTYPE_TILED;
                    }
                    if (this._featureOption[chartType + 'Chart']) {
                        zrUtil.merge(this.option.series[i], this._featureOption[chartType + 'Chart'] || {}, true);
                    }
                }
            }
            return this.option;
        },
        _defaultMagic: function (cType1, cType2) {
            if (this._magicType[cType1] || this._magicType[cType2]) {
                for (var i = 0, l = this.option.series.length; i < l; i++) {
                    var chartType = this.option.series[i].type;
                    if (chartType == cType1 || chartType == cType2) {
                        this.option.series[i].type = this._magicType[cType1] ? cType1 : cType2;
                        this.option.series[i].itemStyle = zrUtil.clone(this.option.series[i].__itemStyle);
                        chartType = this.option.series[i].type;
                        if (this._featureOption[chartType + 'Chart']) {
                            zrUtil.merge(this.option.series[i], this._featureOption[chartType + 'Chart'] || {}, true);
                        }
                    }
                }
            }
        },
        silence: function (s) {
            this._isSilence = s;
        },
        resize: function () {
            this._resetMark();
            this.clear();
            if (this.option && this.option.toolbox && this.option.toolbox.show) {
                this._buildShape();
            }
            if (this._dataView) {
                this._dataView.resize();
            }
        },
        hideDataView: function () {
            if (this._dataView) {
                this._dataView.hide();
            }
        },
        clear: function (notMark) {
            if (this.zr) {
                this.zr.delShape(this.shapeList);
                this.shapeList = [];
                if (!notMark) {
                    this.zr.delShape(this._markShapeList);
                    this._markShapeList = [];
                }
            }
        },
        onbeforDispose: function () {
            if (this._dataView) {
                this._dataView.dispose();
                this._dataView = null;
            }
            this._markShapeList = null;
        },
        refresh: function (newOption) {
            if (newOption) {
                this._resetMark();
                this._resetZoom();
                newOption.toolbox = this.reformOption(newOption.toolbox);
                this.option = newOption;
                this.clear(true);
                if (newOption.toolbox.show) {
                    this._buildShape();
                }
                this.hideDataView();
            }
        }
    };
    zrUtil.inherits(Toolbox, Base);
    require('../component').define('toolbox', Toolbox);
    return Toolbox;
});define('echarts/component', [], function () {
    var self = {};
    var _componentLibrary = {};
    self.define = function (name, clazz) {
        _componentLibrary[name] = clazz;
        return self;
    };
    self.get = function (name) {
        return _componentLibrary[name];
    };
    return self;
});define('echarts/component/title', [
    'require',
    './base',
    'zrender/shape/Text',
    'zrender/shape/Rectangle',
    '../config',
    'zrender/tool/util',
    'zrender/tool/area',
    'zrender/tool/color',
    '../component'
], function (require) {
    var Base = require('./base');
    var TextShape = require('zrender/shape/Text');
    var RectangleShape = require('zrender/shape/Rectangle');
    var ecConfig = require('../config');
    ecConfig.title = {
        zlevel: 0,
        z: 6,
        show: true,
        text: '',
        subtext: '',
        x: 'left',
        y: 'top',
        backgroundColor: 'rgba(0,0,0,0)',
        borderColor: '#ccc',
        borderWidth: 0,
        padding: 5,
        itemGap: 5,
        textStyle: {
            fontSize: 18,
            fontWeight: 'bolder',
            color: '#333'
        },
        subtextStyle: { color: '#aaa' }
    };
    var zrUtil = require('zrender/tool/util');
    var zrArea = require('zrender/tool/area');
    var zrColor = require('zrender/tool/color');
    function Title(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.refresh(option);
    }
    Title.prototype = {
        type: ecConfig.COMPONENT_TYPE_TITLE,
        _buildShape: function () {
            if (!this.titleOption.show) {
                return;
            }
            this._itemGroupLocation = this._getItemGroupLocation();
            this._buildBackground();
            this._buildItem();
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                this.zr.addShape(this.shapeList[i]);
            }
        },
        _buildItem: function () {
            var text = this.titleOption.text;
            var link = this.titleOption.link;
            var target = this.titleOption.target;
            var subtext = this.titleOption.subtext;
            var sublink = this.titleOption.sublink;
            var subtarget = this.titleOption.subtarget;
            var font = this.getFont(this.titleOption.textStyle);
            var subfont = this.getFont(this.titleOption.subtextStyle);
            var x = this._itemGroupLocation.x;
            var y = this._itemGroupLocation.y;
            var width = this._itemGroupLocation.width;
            var height = this._itemGroupLocation.height;
            var textShape = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                style: {
                    y: y,
                    color: this.titleOption.textStyle.color,
                    text: text,
                    textFont: font,
                    textBaseline: 'top'
                },
                highlightStyle: {
                    color: zrColor.lift(this.titleOption.textStyle.color, 1),
                    brushType: 'fill'
                },
                hoverable: false
            };
            if (link) {
                textShape.hoverable = true;
                textShape.clickable = true;
                textShape.onclick = function () {
                    if (!target || target != 'self') {
                        window.open(link);
                    } else {
                        window.location = link;
                    }
                };
            }
            var subtextShape = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                style: {
                    y: y + height,
                    color: this.titleOption.subtextStyle.color,
                    text: subtext,
                    textFont: subfont,
                    textBaseline: 'bottom'
                },
                highlightStyle: {
                    color: zrColor.lift(this.titleOption.subtextStyle.color, 1),
                    brushType: 'fill'
                },
                hoverable: false
            };
            if (sublink) {
                subtextShape.hoverable = true;
                subtextShape.clickable = true;
                subtextShape.onclick = function () {
                    if (!subtarget || subtarget != 'self') {
                        window.open(sublink);
                    } else {
                        window.location = sublink;
                    }
                };
            }
            switch (this.titleOption.x) {
            case 'center':
                textShape.style.x = subtextShape.style.x = x + width / 2;
                textShape.style.textAlign = subtextShape.style.textAlign = 'center';
                break;
            case 'left':
                textShape.style.x = subtextShape.style.x = x;
                textShape.style.textAlign = subtextShape.style.textAlign = 'left';
                break;
            case 'right':
                textShape.style.x = subtextShape.style.x = x + width;
                textShape.style.textAlign = subtextShape.style.textAlign = 'right';
                break;
            default:
                x = this.titleOption.x - 0;
                x = isNaN(x) ? 0 : x;
                textShape.style.x = subtextShape.style.x = x;
                break;
            }
            if (this.titleOption.textAlign) {
                textShape.style.textAlign = subtextShape.style.textAlign = this.titleOption.textAlign;
            }
            this.shapeList.push(new TextShape(textShape));
            subtext !== '' && this.shapeList.push(new TextShape(subtextShape));
        },
        _buildBackground: function () {
            var padding = this.reformCssArray(this.titleOption.padding);
            this.shapeList.push(new RectangleShape({
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                hoverable: false,
                style: {
                    x: this._itemGroupLocation.x - padding[3],
                    y: this._itemGroupLocation.y - padding[0],
                    width: this._itemGroupLocation.width + padding[3] + padding[1],
                    height: this._itemGroupLocation.height + padding[0] + padding[2],
                    brushType: this.titleOption.borderWidth === 0 ? 'fill' : 'both',
                    color: this.titleOption.backgroundColor,
                    strokeColor: this.titleOption.borderColor,
                    lineWidth: this.titleOption.borderWidth
                }
            }));
        },
        _getItemGroupLocation: function () {
            var padding = this.reformCssArray(this.titleOption.padding);
            var text = this.titleOption.text;
            var subtext = this.titleOption.subtext;
            var font = this.getFont(this.titleOption.textStyle);
            var subfont = this.getFont(this.titleOption.subtextStyle);
            var totalWidth = Math.max(zrArea.getTextWidth(text, font), zrArea.getTextWidth(subtext, subfont));
            var totalHeight = zrArea.getTextHeight(text, font) + (subtext === '' ? 0 : this.titleOption.itemGap + zrArea.getTextHeight(subtext, subfont));
            var x;
            var zrWidth = this.zr.getWidth();
            switch (this.titleOption.x) {
            case 'center':
                x = Math.floor((zrWidth - totalWidth) / 2);
                break;
            case 'left':
                x = padding[3] + this.titleOption.borderWidth;
                break;
            case 'right':
                x = zrWidth - totalWidth - padding[1] - this.titleOption.borderWidth;
                break;
            default:
                x = this.titleOption.x - 0;
                x = isNaN(x) ? 0 : x;
                break;
            }
            var y;
            var zrHeight = this.zr.getHeight();
            switch (this.titleOption.y) {
            case 'top':
                y = padding[0] + this.titleOption.borderWidth;
                break;
            case 'bottom':
                y = zrHeight - totalHeight - padding[2] - this.titleOption.borderWidth;
                break;
            case 'center':
                y = Math.floor((zrHeight - totalHeight) / 2);
                break;
            default:
                y = this.titleOption.y - 0;
                y = isNaN(y) ? 0 : y;
                break;
            }
            return {
                x: x,
                y: y,
                width: totalWidth,
                height: totalHeight
            };
        },
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.option.title = this.reformOption(this.option.title);
                this.titleOption = this.option.title;
                this.titleOption.textStyle = this.getTextStyle(this.titleOption.textStyle);
                this.titleOption.subtextStyle = this.getTextStyle(this.titleOption.subtextStyle);
            }
            this.clear();
            this._buildShape();
        }
    };
    zrUtil.inherits(Title, Base);
    require('../component').define('title', Title);
    return Title;
});define('echarts/component/tooltip', [
    'require',
    './base',
    '../util/shape/Cross',
    'zrender/shape/Line',
    'zrender/shape/Rectangle',
    '../config',
    '../util/ecData',
    'zrender/config',
    'zrender/tool/event',
    'zrender/tool/area',
    'zrender/tool/color',
    'zrender/tool/util',
    'zrender/shape/Base',
    '../component'
], function (require) {
    var Base = require('./base');
    var CrossShape = require('../util/shape/Cross');
    var LineShape = require('zrender/shape/Line');
    var RectangleShape = require('zrender/shape/Rectangle');
    var rectangleInstance = new RectangleShape({});
    var ecConfig = require('../config');
    ecConfig.tooltip = {
        zlevel: 1,
        z: 8,
        show: true,
        showContent: true,
        trigger: 'item',
        islandFormatter: '{a} <br/>{b} : {c}',
        showDelay: 20,
        hideDelay: 100,
        transitionDuration: 0.4,
        enterable: false,
        backgroundColor: 'rgba(0,0,0,0.7)',
        borderColor: '#333',
        borderRadius: 4,
        borderWidth: 0,
        padding: 5,
        axisPointer: {
            type: 'line',
            lineStyle: {
                color: '#48b',
                width: 2,
                type: 'solid'
            },
            crossStyle: {
                color: '#1e90ff',
                width: 1,
                type: 'dashed'
            },
            shadowStyle: {
                color: 'rgba(150,150,150,0.3)',
                width: 'auto',
                type: 'default'
            }
        },
        textStyle: { color: '#fff' }
    };
    var ecData = require('../util/ecData');
    var zrConfig = require('zrender/config');
    var zrEvent = require('zrender/tool/event');
    var zrArea = require('zrender/tool/area');
    var zrColor = require('zrender/tool/color');
    var zrUtil = require('zrender/tool/util');
    var zrShapeBase = require('zrender/shape/Base');
    function Tooltip(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.dom = myChart.dom;
        var self = this;
        self._onmousemove = function (param) {
            return self.__onmousemove(param);
        };
        self._onglobalout = function (param) {
            return self.__onglobalout(param);
        };
        this.zr.on(zrConfig.EVENT.MOUSEMOVE, self._onmousemove);
        this.zr.on(zrConfig.EVENT.GLOBALOUT, self._onglobalout);
        self._hide = function (param) {
            return self.__hide(param);
        };
        self._tryShow = function (param) {
            return self.__tryShow(param);
        };
        self._refixed = function (param) {
            return self.__refixed(param);
        };
        self._setContent = function (ticket, res) {
            return self.__setContent(ticket, res);
        };
        this._tDom = this._tDom || document.createElement('div');
        this._tDom.onselectstart = function () {
            return false;
        };
        this._tDom.onmouseover = function () {
            self._mousein = true;
        };
        this._tDom.onmouseout = function () {
            self._mousein = false;
        };
        this._tDom.className = 'echarts-tooltip';
        this._tDom.style.position = 'absolute';
        this.hasAppend = false;
        this._axisLineShape && this.zr.delShape(this._axisLineShape.id);
        this._axisLineShape = new LineShape({
            zlevel: this.getZlevelBase(),
            z: this.getZBase(),
            invisible: true,
            hoverable: false
        });
        this.shapeList.push(this._axisLineShape);
        this.zr.addShape(this._axisLineShape);
        this._axisShadowShape && this.zr.delShape(this._axisShadowShape.id);
        this._axisShadowShape = new LineShape({
            zlevel: this.getZlevelBase(),
            z: 1,
            invisible: true,
            hoverable: false
        });
        this.shapeList.push(this._axisShadowShape);
        this.zr.addShape(this._axisShadowShape);
        this._axisCrossShape && this.zr.delShape(this._axisCrossShape.id);
        this._axisCrossShape = new CrossShape({
            zlevel: this.getZlevelBase(),
            z: this.getZBase(),
            invisible: true,
            hoverable: false
        });
        this.shapeList.push(this._axisCrossShape);
        this.zr.addShape(this._axisCrossShape);
        this.showing = false;
        this.refresh(option);
    }
    Tooltip.prototype = {
        type: ecConfig.COMPONENT_TYPE_TOOLTIP,
        _gCssText: 'position:absolute;display:block;border-style:solid;white-space:nowrap;',
        _style: function (opt) {
            if (!opt) {
                return '';
            }
            var cssText = [];
            if (opt.transitionDuration) {
                var transitionText = 'left ' + opt.transitionDuration + 's,' + 'top ' + opt.transitionDuration + 's';
                cssText.push('transition:' + transitionText);
                cssText.push('-moz-transition:' + transitionText);
                cssText.push('-webkit-transition:' + transitionText);
                cssText.push('-o-transition:' + transitionText);
            }
            if (opt.backgroundColor) {
                cssText.push('background-Color:' + zrColor.toHex(opt.backgroundColor));
                cssText.push('filter:alpha(opacity=70)');
                cssText.push('background-Color:' + opt.backgroundColor);
            }
            if (opt.borderWidth != null) {
                cssText.push('border-width:' + opt.borderWidth + 'px');
            }
            if (opt.borderColor != null) {
                cssText.push('border-color:' + opt.borderColor);
            }
            if (opt.borderRadius != null) {
                cssText.push('border-radius:' + opt.borderRadius + 'px');
                cssText.push('-moz-border-radius:' + opt.borderRadius + 'px');
                cssText.push('-webkit-border-radius:' + opt.borderRadius + 'px');
                cssText.push('-o-border-radius:' + opt.borderRadius + 'px');
            }
            var textStyle = opt.textStyle;
            if (textStyle) {
                textStyle.color && cssText.push('color:' + textStyle.color);
                textStyle.decoration && cssText.push('text-decoration:' + textStyle.decoration);
                textStyle.align && cssText.push('text-align:' + textStyle.align);
                textStyle.fontFamily && cssText.push('font-family:' + textStyle.fontFamily);
                textStyle.fontSize && cssText.push('font-size:' + textStyle.fontSize + 'px');
                textStyle.fontSize && cssText.push('line-height:' + Math.round(textStyle.fontSize * 3 / 2) + 'px');
                textStyle.fontStyle && cssText.push('font-style:' + textStyle.fontStyle);
                textStyle.fontWeight && cssText.push('font-weight:' + textStyle.fontWeight);
            }
            var padding = opt.padding;
            if (padding != null) {
                padding = this.reformCssArray(padding);
                cssText.push('padding:' + padding[0] + 'px ' + padding[1] + 'px ' + padding[2] + 'px ' + padding[3] + 'px');
            }
            cssText = cssText.join(';') + ';';
            return cssText;
        },
        __hide: function () {
            this._lastDataIndex = -1;
            this._lastSeriesIndex = -1;
            this._lastItemTriggerId = -1;
            if (this._tDom) {
                this._tDom.style.display = 'none';
            }
            var needRefresh = false;
            if (!this._axisLineShape.invisible) {
                this._axisLineShape.invisible = true;
                this.zr.modShape(this._axisLineShape.id);
                needRefresh = true;
            }
            if (!this._axisShadowShape.invisible) {
                this._axisShadowShape.invisible = true;
                this.zr.modShape(this._axisShadowShape.id);
                needRefresh = true;
            }
            if (!this._axisCrossShape.invisible) {
                this._axisCrossShape.invisible = true;
                this.zr.modShape(this._axisCrossShape.id);
                needRefresh = true;
            }
            if (this._lastTipShape && this._lastTipShape.tipShape.length > 0) {
                this.zr.delShape(this._lastTipShape.tipShape);
                this._lastTipShape = false;
                this.shapeList.length = 2;
            }
            needRefresh && this.zr.refreshNextFrame();
            this.showing = false;
        },
        _show: function (position, x, y, specialCssText) {
            var domHeight = this._tDom.offsetHeight;
            var domWidth = this._tDom.offsetWidth;
            if (position) {
                if (typeof position === 'function') {
                    position = position([
                        x,
                        y
                    ]);
                }
                if (position instanceof Array) {
                    x = position[0];
                    y = position[1];
                }
            }
            if (x + domWidth > this._zrWidth) {
                x -= domWidth + 40;
            }
            if (y + domHeight > this._zrHeight) {
                y -= domHeight - 20;
            }
            if (y < 20) {
                y = 0;
            }
            this._tDom.style.cssText = this._gCssText + this._defaultCssText + (specialCssText ? specialCssText : '') + 'left:' + x + 'px;top:' + y + 'px;';
            if (domHeight < 10 || domWidth < 10) {
                setTimeout(this._refixed, 20);
            }
            this.showing = true;
        },
        __refixed: function () {
            if (this._tDom) {
                var cssText = '';
                var domHeight = this._tDom.offsetHeight;
                var domWidth = this._tDom.offsetWidth;
                if (this._tDom.offsetLeft + domWidth > this._zrWidth) {
                    cssText += 'left:' + (this._zrWidth - domWidth - 20) + 'px;';
                }
                if (this._tDom.offsetTop + domHeight > this._zrHeight) {
                    cssText += 'top:' + (this._zrHeight - domHeight - 10) + 'px;';
                }
                if (cssText !== '') {
                    this._tDom.style.cssText += cssText;
                }
            }
        },
        __tryShow: function () {
            var needShow;
            var trigger;
            if (!this._curTarget) {
                this._findPolarTrigger() || this._findAxisTrigger();
            } else {
                if (this._curTarget._type === 'island' && this.option.tooltip.show) {
                    this._showItemTrigger();
                    return;
                }
                var serie = ecData.get(this._curTarget, 'series');
                var data = ecData.get(this._curTarget, 'data');
                needShow = this.deepQuery([
                    data,
                    serie,
                    this.option
                ], 'tooltip.show');
                if (serie == null || data == null || !needShow) {
                    clearTimeout(this._hidingTicket);
                    clearTimeout(this._showingTicket);
                    this._hidingTicket = setTimeout(this._hide, this._hideDelay);
                } else {
                    trigger = this.deepQuery([
                        data,
                        serie,
                        this.option
                    ], 'tooltip.trigger');
                    trigger === 'axis' ? this._showAxisTrigger(serie.xAxisIndex, serie.yAxisIndex, ecData.get(this._curTarget, 'dataIndex')) : this._showItemTrigger();
                }
            }
        },
        _findAxisTrigger: function () {
            if (!this.component.xAxis || !this.component.yAxis) {
                this._hidingTicket = setTimeout(this._hide, this._hideDelay);
                return;
            }
            var series = this.option.series;
            var xAxisIndex;
            var yAxisIndex;
            for (var i = 0, l = series.length; i < l; i++) {
                if (this.deepQuery([
                        series[i],
                        this.option
                    ], 'tooltip.trigger') === 'axis') {
                    xAxisIndex = series[i].xAxisIndex || 0;
                    yAxisIndex = series[i].yAxisIndex || 0;
                    if (this.component.xAxis.getAxis(xAxisIndex) && this.component.xAxis.getAxis(xAxisIndex).type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY) {
                        this._showAxisTrigger(xAxisIndex, yAxisIndex, this._getNearestDataIndex('x', this.component.xAxis.getAxis(xAxisIndex)));
                        return;
                    } else if (this.component.yAxis.getAxis(yAxisIndex) && this.component.yAxis.getAxis(yAxisIndex).type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY) {
                        this._showAxisTrigger(xAxisIndex, yAxisIndex, this._getNearestDataIndex('y', this.component.yAxis.getAxis(yAxisIndex)));
                        return;
                    } else {
                        this._showAxisTrigger(xAxisIndex, yAxisIndex, -1);
                        return;
                    }
                }
            }
            if (this.option.tooltip.axisPointer.type === 'cross') {
                this._showAxisTrigger(-1, -1, -1);
            }
        },
        _findPolarTrigger: function () {
            if (!this.component.polar) {
                return false;
            }
            var x = zrEvent.getX(this._event);
            var y = zrEvent.getY(this._event);
            var polarIndex = this.component.polar.getNearestIndex([
                x,
                y
            ]);
            var valueIndex;
            if (polarIndex) {
                valueIndex = polarIndex.valueIndex;
                polarIndex = polarIndex.polarIndex;
            } else {
                polarIndex = -1;
            }
            if (polarIndex != -1) {
                return this._showPolarTrigger(polarIndex, valueIndex);
            }
            return false;
        },
        _getNearestDataIndex: function (direction, categoryAxis) {
            var dataIndex = -1;
            var x = zrEvent.getX(this._event);
            var y = zrEvent.getY(this._event);
            if (direction === 'x') {
                var left;
                var right;
                var xEnd = this.component.grid.getXend();
                var curCoord = categoryAxis.getCoordByIndex(dataIndex);
                while (curCoord < xEnd) {
                    right = curCoord;
                    if (curCoord <= x) {
                        left = curCoord;
                    } else {
                        break;
                    }
                    curCoord = categoryAxis.getCoordByIndex(++dataIndex);
                }
                if (dataIndex <= 0) {
                    dataIndex = 0;
                } else if (x - left <= right - x) {
                    dataIndex -= 1;
                } else {
                    if (categoryAxis.getNameByIndex(dataIndex) == null) {
                        dataIndex -= 1;
                    }
                }
                return dataIndex;
            } else {
                var top;
                var bottom;
                var yStart = this.component.grid.getY();
                var curCoord = categoryAxis.getCoordByIndex(dataIndex);
                while (curCoord > yStart) {
                    top = curCoord;
                    if (curCoord >= y) {
                        bottom = curCoord;
                    } else {
                        break;
                    }
                    curCoord = categoryAxis.getCoordByIndex(++dataIndex);
                }
                if (dataIndex <= 0) {
                    dataIndex = 0;
                } else if (y - top >= bottom - y) {
                    dataIndex -= 1;
                } else {
                    if (categoryAxis.getNameByIndex(dataIndex) == null) {
                        dataIndex -= 1;
                    }
                }
                return dataIndex;
            }
            return -1;
        },
        _showAxisTrigger: function (xAxisIndex, yAxisIndex, dataIndex) {
            !this._event.connectTrigger && this.messageCenter.dispatch(ecConfig.EVENT.TOOLTIP_IN_GRID, this._event, null, this.myChart);
            if (this.component.xAxis == null || this.component.yAxis == null || xAxisIndex == null || yAxisIndex == null) {
                clearTimeout(this._hidingTicket);
                clearTimeout(this._showingTicket);
                this._hidingTicket = setTimeout(this._hide, this._hideDelay);
                return;
            }
            var series = this.option.series;
            var seriesArray = [];
            var seriesIndex = [];
            var categoryAxis;
            var formatter;
            var position;
            var showContent;
            var specialCssText = '';
            if (this.option.tooltip.trigger === 'axis') {
                if (!this.option.tooltip.show) {
                    return;
                }
                formatter = this.option.tooltip.formatter;
                position = this.option.tooltip.position;
            }
            var axisLayout = xAxisIndex != -1 && this.component.xAxis.getAxis(xAxisIndex).type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY ? 'xAxis' : yAxisIndex != -1 && this.component.yAxis.getAxis(yAxisIndex).type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY ? 'yAxis' : false;
            var x;
            var y;
            if (axisLayout) {
                var axisIndex = axisLayout == 'xAxis' ? xAxisIndex : yAxisIndex;
                categoryAxis = this.component[axisLayout].getAxis(axisIndex);
                for (var i = 0, l = series.length; i < l; i++) {
                    if (!this._isSelected(series[i].name)) {
                        continue;
                    }
                    if (series[i][axisLayout + 'Index'] === axisIndex && this.deepQuery([
                            series[i],
                            this.option
                        ], 'tooltip.trigger') === 'axis') {
                        showContent = this.query(series[i], 'tooltip.showContent') || showContent;
                        formatter = this.query(series[i], 'tooltip.formatter') || formatter;
                        position = this.query(series[i], 'tooltip.position') || position;
                        specialCssText += this._style(this.query(series[i], 'tooltip'));
                        if (series[i].stack != null && axisLayout == 'xAxis') {
                            seriesArray.unshift(series[i]);
                            seriesIndex.unshift(i);
                        } else {
                            seriesArray.push(series[i]);
                            seriesIndex.push(i);
                        }
                    }
                }
                this.messageCenter.dispatch(ecConfig.EVENT.TOOLTIP_HOVER, this._event, {
                    seriesIndex: seriesIndex,
                    dataIndex: dataIndex
                }, this.myChart);
                var rect;
                if (axisLayout == 'xAxis') {
                    x = this.subPixelOptimize(categoryAxis.getCoordByIndex(dataIndex), this._axisLineWidth);
                    y = zrEvent.getY(this._event);
                    rect = [
                        x,
                        this.component.grid.getY(),
                        x,
                        this.component.grid.getYend()
                    ];
                } else {
                    x = zrEvent.getX(this._event);
                    y = this.subPixelOptimize(categoryAxis.getCoordByIndex(dataIndex), this._axisLineWidth);
                    rect = [
                        this.component.grid.getX(),
                        y,
                        this.component.grid.getXend(),
                        y
                    ];
                }
                this._styleAxisPointer(seriesArray, rect[0], rect[1], rect[2], rect[3], categoryAxis.getGap(), x, y);
            } else {
                x = zrEvent.getX(this._event);
                y = zrEvent.getY(this._event);
                this._styleAxisPointer(series, this.component.grid.getX(), y, this.component.grid.getXend(), y, 0, x, y);
                if (dataIndex >= 0) {
                    this._showItemTrigger(true);
                } else {
                    clearTimeout(this._hidingTicket);
                    clearTimeout(this._showingTicket);
                    this._tDom.style.display = 'none';
                }
            }
            if (seriesArray.length > 0) {
                this._lastItemTriggerId = -1;
                if (this._lastDataIndex != dataIndex || this._lastSeriesIndex != seriesIndex[0]) {
                    this._lastDataIndex = dataIndex;
                    this._lastSeriesIndex = seriesIndex[0];
                    var data;
                    var value;
                    if (typeof formatter === 'function') {
                        var params = [];
                        for (var i = 0, l = seriesArray.length; i < l; i++) {
                            data = seriesArray[i].data[dataIndex];
                            value = this.getDataFromOption(data, '-');
                            params.push({
                                seriesIndex: seriesIndex[i],
                                seriesName: seriesArray[i].name || '',
                                series: seriesArray[i],
                                dataIndex: dataIndex,
                                data: data,
                                name: categoryAxis.getNameByIndex(dataIndex),
                                value: value,
                                0: seriesArray[i].name || '',
                                1: categoryAxis.getNameByIndex(dataIndex),
                                2: value,
                                3: data
                            });
                        }
                        this._curTicket = 'axis:' + dataIndex;
                        this._tDom.innerHTML = formatter.call(this.myChart, params, this._curTicket, this._setContent);
                    } else if (typeof formatter === 'string') {
                        this._curTicket = NaN;
                        formatter = formatter.replace('{a}', '{a0}').replace('{b}', '{b0}').replace('{c}', '{c0}');
                        for (var i = 0, l = seriesArray.length; i < l; i++) {
                            formatter = formatter.replace('{a' + i + '}', this._encodeHTML(seriesArray[i].name || ''));
                            formatter = formatter.replace('{b' + i + '}', this._encodeHTML(categoryAxis.getNameByIndex(dataIndex)));
                            data = seriesArray[i].data[dataIndex];
                            data = this.getDataFromOption(data, '-');
                            formatter = formatter.replace('{c' + i + '}', data instanceof Array ? data : this.numAddCommas(data));
                        }
                        this._tDom.innerHTML = formatter;
                    } else {
                        this._curTicket = NaN;
                        formatter = this._encodeHTML(categoryAxis.getNameByIndex(dataIndex));
                        for (var i = 0, l = seriesArray.length; i < l; i++) {
                            formatter += '<br/>' + this._encodeHTML(seriesArray[i].name || '') + ' : ';
                            data = seriesArray[i].data[dataIndex];
                            data = this.getDataFromOption(data, '-');
                            formatter += data instanceof Array ? data : this.numAddCommas(data);
                        }
                        this._tDom.innerHTML = formatter;
                    }
                }
                if (showContent === false || !this.option.tooltip.showContent) {
                    return;
                }
                if (!this.hasAppend) {
                    this._tDom.style.left = this._zrWidth / 2 + 'px';
                    this._tDom.style.top = this._zrHeight / 2 + 'px';
                    this.dom.firstChild.appendChild(this._tDom);
                    this.hasAppend = true;
                }
                this._show(position, x + 10, y + 10, specialCssText);
            }
        },
        _showPolarTrigger: function (polarIndex, dataIndex) {
            if (this.component.polar == null || polarIndex == null || dataIndex == null || dataIndex < 0) {
                return false;
            }
            var series = this.option.series;
            var seriesArray = [];
            var seriesIndex = [];
            var formatter;
            var position;
            var showContent;
            var specialCssText = '';
            if (this.option.tooltip.trigger === 'axis') {
                if (!this.option.tooltip.show) {
                    return false;
                }
                formatter = this.option.tooltip.formatter;
                position = this.option.tooltip.position;
            }
            var indicatorName = this.option.polar[polarIndex].indicator[dataIndex].text;
            for (var i = 0, l = series.length; i < l; i++) {
                if (!this._isSelected(series[i].name)) {
                    continue;
                }
                if (series[i].polarIndex === polarIndex && this.deepQuery([
                        series[i],
                        this.option
                    ], 'tooltip.trigger') === 'axis') {
                    showContent = this.query(series[i], 'tooltip.showContent') || showContent;
                    formatter = this.query(series[i], 'tooltip.formatter') || formatter;
                    position = this.query(series[i], 'tooltip.position') || position;
                    specialCssText += this._style(this.query(series[i], 'tooltip'));
                    seriesArray.push(series[i]);
                    seriesIndex.push(i);
                }
            }
            if (seriesArray.length > 0) {
                var polarData;
                var data;
                var value;
                var params = [];
                for (var i = 0, l = seriesArray.length; i < l; i++) {
                    polarData = seriesArray[i].data;
                    for (var j = 0, k = polarData.length; j < k; j++) {
                        data = polarData[j];
                        if (!this._isSelected(data.name)) {
                            continue;
                        }
                        data = data != null ? data : {
                            name: '',
                            value: { dataIndex: '-' }
                        };
                        value = this.getDataFromOption(data.value[dataIndex]);
                        params.push({
                            seriesIndex: seriesIndex[i],
                            seriesName: seriesArray[i].name || '',
                            series: seriesArray[i],
                            dataIndex: dataIndex,
                            data: data,
                            name: data.name,
                            indicator: indicatorName,
                            value: value,
                            0: seriesArray[i].name || '',
                            1: data.name,
                            2: value,
                            3: indicatorName
                        });
                    }
                }
                if (params.length <= 0) {
                    return;
                }
                this._lastItemTriggerId = -1;
                if (this._lastDataIndex != dataIndex || this._lastSeriesIndex != seriesIndex[0]) {
                    this._lastDataIndex = dataIndex;
                    this._lastSeriesIndex = seriesIndex[0];
                    if (typeof formatter === 'function') {
                        this._curTicket = 'axis:' + dataIndex;
                        this._tDom.innerHTML = formatter.call(this.myChart, params, this._curTicket, this._setContent);
                    } else if (typeof formatter === 'string') {
                        formatter = formatter.replace('{a}', '{a0}').replace('{b}', '{b0}').replace('{c}', '{c0}').replace('{d}', '{d0}');
                        for (var i = 0, l = params.length; i < l; i++) {
                            formatter = formatter.replace('{a' + i + '}', this._encodeHTML(params[i].seriesName));
                            formatter = formatter.replace('{b' + i + '}', this._encodeHTML(params[i].name));
                            formatter = formatter.replace('{c' + i + '}', this.numAddCommas(params[i].value));
                            formatter = formatter.replace('{d' + i + '}', this._encodeHTML(params[i].indicator));
                        }
                        this._tDom.innerHTML = formatter;
                    } else {
                        formatter = this._encodeHTML(params[0].name) + '<br/>' + this._encodeHTML(params[0].indicator) + ' : ' + this.numAddCommas(params[0].value);
                        for (var i = 1, l = params.length; i < l; i++) {
                            formatter += '<br/>' + this._encodeHTML(params[i].name) + '<br/>';
                            formatter += this._encodeHTML(params[i].indicator) + ' : ' + this.numAddCommas(params[i].value);
                        }
                        this._tDom.innerHTML = formatter;
                    }
                }
                if (showContent === false || !this.option.tooltip.showContent) {
                    return;
                }
                if (!this.hasAppend) {
                    this._tDom.style.left = this._zrWidth / 2 + 'px';
                    this._tDom.style.top = this._zrHeight / 2 + 'px';
                    this.dom.firstChild.appendChild(this._tDom);
                    this.hasAppend = true;
                }
                this._show(position, zrEvent.getX(this._event), zrEvent.getY(this._event), specialCssText);
                return true;
            }
        },
        _showItemTrigger: function (axisTrigger) {
            if (!this._curTarget) {
                return;
            }
            var serie = ecData.get(this._curTarget, 'series');
            var seriesIndex = ecData.get(this._curTarget, 'seriesIndex');
            var data = ecData.get(this._curTarget, 'data');
            var dataIndex = ecData.get(this._curTarget, 'dataIndex');
            var name = ecData.get(this._curTarget, 'name');
            var value = ecData.get(this._curTarget, 'value');
            var special = ecData.get(this._curTarget, 'special');
            var special2 = ecData.get(this._curTarget, 'special2');
            var queryTarget = [
                data,
                serie,
                this.option
            ];
            var formatter;
            var position;
            var showContent;
            var specialCssText = '';
            if (this._curTarget._type != 'island') {
                var trigger = axisTrigger ? 'axis' : 'item';
                if (this.option.tooltip.trigger === trigger) {
                    formatter = this.option.tooltip.formatter;
                    position = this.option.tooltip.position;
                }
                if (this.query(serie, 'tooltip.trigger') === trigger) {
                    showContent = this.query(serie, 'tooltip.showContent') || showContent;
                    formatter = this.query(serie, 'tooltip.formatter') || formatter;
                    position = this.query(serie, 'tooltip.position') || position;
                    specialCssText += this._style(this.query(serie, 'tooltip'));
                }
                showContent = this.query(data, 'tooltip.showContent') || showContent;
                formatter = this.query(data, 'tooltip.formatter') || formatter;
                position = this.query(data, 'tooltip.position') || position;
                specialCssText += this._style(this.query(data, 'tooltip'));
            } else {
                this._lastItemTriggerId = NaN;
                showContent = this.deepQuery(queryTarget, 'tooltip.showContent');
                formatter = this.deepQuery(queryTarget, 'tooltip.islandFormatter');
                position = this.deepQuery(queryTarget, 'tooltip.islandPosition');
            }
            this._lastDataIndex = -1;
            this._lastSeriesIndex = -1;
            if (this._lastItemTriggerId !== this._curTarget.id) {
                this._lastItemTriggerId = this._curTarget.id;
                if (typeof formatter === 'function') {
                    this._curTicket = (serie.name || '') + ':' + dataIndex;
                    this._tDom.innerHTML = formatter.call(this.myChart, {
                        seriesIndex: seriesIndex,
                        seriesName: serie.name || '',
                        series: serie,
                        dataIndex: dataIndex,
                        data: data,
                        name: name,
                        value: value,
                        percent: special,
                        indicator: special,
                        value2: special2,
                        indicator2: special2,
                        0: serie.name || '',
                        1: name,
                        2: value,
                        3: special,
                        4: special2,
                        5: data,
                        6: seriesIndex,
                        7: dataIndex
                    }, this._curTicket, this._setContent);
                } else if (typeof formatter === 'string') {
                    this._curTicket = NaN;
                    formatter = formatter.replace('{a}', '{a0}').replace('{b}', '{b0}').replace('{c}', '{c0}');
                    formatter = formatter.replace('{a0}', this._encodeHTML(serie.name || '')).replace('{b0}', this._encodeHTML(name)).replace('{c0}', value instanceof Array ? value : this.numAddCommas(value));
                    formatter = formatter.replace('{d}', '{d0}').replace('{d0}', special || '');
                    formatter = formatter.replace('{e}', '{e0}').replace('{e0}', ecData.get(this._curTarget, 'special2') || '');
                    this._tDom.innerHTML = formatter;
                } else {
                    this._curTicket = NaN;
                    if (serie.type === ecConfig.CHART_TYPE_RADAR && special) {
                        this._tDom.innerHTML = this._itemFormatter.radar.call(this, serie, name, value, special);
                    } else if (serie.type === ecConfig.CHART_TYPE_EVENTRIVER) {
                        this._tDom.innerHTML = this._itemFormatter.eventRiver.call(this, serie, name, value, data);
                    } else {
                        this._tDom.innerHTML = '' + (serie.name != null ? this._encodeHTML(serie.name) + '<br/>' : '') + (name === '' ? '' : this._encodeHTML(name) + ' : ') + (value instanceof Array ? value : this.numAddCommas(value));
                    }
                }
            }
            var x = zrEvent.getX(this._event);
            var y = zrEvent.getY(this._event);
            if (this.deepQuery(queryTarget, 'tooltip.axisPointer.show') && this.component.grid) {
                this._styleAxisPointer([serie], this.component.grid.getX(), y, this.component.grid.getXend(), y, 0, x, y);
            } else {
                this._hide();
            }
            if (showContent === false || !this.option.tooltip.showContent) {
                return;
            }
            if (!this.hasAppend) {
                this._tDom.style.left = this._zrWidth / 2 + 'px';
                this._tDom.style.top = this._zrHeight / 2 + 'px';
                this.dom.firstChild.appendChild(this._tDom);
                this.hasAppend = true;
            }
            this._show(position, x + 20, y - 20, specialCssText);
        },
        _itemFormatter: {
            radar: function (serie, name, value, indicator) {
                var html = '';
                html += this._encodeHTML(name === '' ? serie.name || '' : name);
                html += html === '' ? '' : '<br />';
                for (var i = 0; i < indicator.length; i++) {
                    html += this._encodeHTML(indicator[i].text) + ' : ' + this.numAddCommas(value[i]) + '<br />';
                }
                return html;
            },
            chord: function (serie, name, value, special, special2) {
                if (special2 == null) {
                    return this._encodeHTML(name) + ' (' + this.numAddCommas(value) + ')';
                } else {
                    var name1 = this._encodeHTML(name);
                    var name2 = this._encodeHTML(special);
                    return '' + (serie.name != null ? this._encodeHTML(serie.name) + '<br/>' : '') + name1 + ' -> ' + name2 + ' (' + this.numAddCommas(value) + ')' + '<br />' + name2 + ' -> ' + name1 + ' (' + this.numAddCommas(special2) + ')';
                }
            },
            eventRiver: function (serie, name, value, data) {
                var html = '';
                html += this._encodeHTML(serie.name === '' ? '' : serie.name + ' : ');
                html += this._encodeHTML(name);
                html += html === '' ? '' : '<br />';
                data = data.evolution;
                for (var i = 0, l = data.length; i < l; i++) {
                    html += '<div style="padding-top:5px;">';
                    if (!data[i].detail) {
                        continue;
                    }
                    if (data[i].detail.img) {
                        html += '<img src="' + data[i].detail.img + '" style="float:left;width:40px;height:40px;">';
                    }
                    html += '<div style="margin-left:45px;">' + data[i].time + '<br/>';
                    html += '<a href="' + data[i].detail.link + '" target="_blank">';
                    html += data[i].detail.text + '</a></div>';
                    html += '</div>';
                }
                return html;
            }
        },
        _styleAxisPointer: function (seriesArray, xStart, yStart, xEnd, yEnd, gap, x, y) {
            if (seriesArray.length > 0) {
                var queryTarget;
                var curType;
                var axisPointer = this.option.tooltip.axisPointer;
                var pointType = axisPointer.type;
                var style = {
                    line: {},
                    cross: {},
                    shadow: {}
                };
                for (var pType in style) {
                    style[pType].color = axisPointer[pType + 'Style'].color;
                    style[pType].width = axisPointer[pType + 'Style'].width;
                    style[pType].type = axisPointer[pType + 'Style'].type;
                }
                for (var i = 0, l = seriesArray.length; i < l; i++) {
                    queryTarget = seriesArray[i];
                    curType = this.query(queryTarget, 'tooltip.axisPointer.type');
                    pointType = curType || pointType;
                    if (curType) {
                        style[curType].color = this.query(queryTarget, 'tooltip.axisPointer.' + curType + 'Style.color') || style[curType].color;
                        style[curType].width = this.query(queryTarget, 'tooltip.axisPointer.' + curType + 'Style.width') || style[curType].width;
                        style[curType].type = this.query(queryTarget, 'tooltip.axisPointer.' + curType + 'Style.type') || style[curType].type;
                    }
                }
                if (pointType === 'line') {
                    var lineWidth = style.line.width;
                    var isVertical = xStart == xEnd;
                    this._axisLineShape.style = {
                        xStart: isVertical ? this.subPixelOptimize(xStart, lineWidth) : xStart,
                        yStart: isVertical ? yStart : this.subPixelOptimize(yStart, lineWidth),
                        xEnd: isVertical ? this.subPixelOptimize(xEnd, lineWidth) : xEnd,
                        yEnd: isVertical ? yEnd : this.subPixelOptimize(yEnd, lineWidth),
                        strokeColor: style.line.color,
                        lineWidth: lineWidth,
                        lineType: style.line.type
                    };
                    this._axisLineShape.invisible = false;
                    this.zr.modShape(this._axisLineShape.id);
                } else if (pointType === 'cross') {
                    var crossWidth = style.cross.width;
                    this._axisCrossShape.style = {
                        brushType: 'stroke',
                        rect: this.component.grid.getArea(),
                        x: this.subPixelOptimize(x, crossWidth),
                        y: this.subPixelOptimize(y, crossWidth),
                        text: ('( ' + this.component.xAxis.getAxis(0).getValueFromCoord(x) + ' , ' + this.component.yAxis.getAxis(0).getValueFromCoord(y) + ' )').replace('  , ', ' ').replace(' ,  ', ' '),
                        textPosition: 'specific',
                        strokeColor: style.cross.color,
                        lineWidth: crossWidth,
                        lineType: style.cross.type
                    };
                    if (this.component.grid.getXend() - x > 100) {
                        this._axisCrossShape.style.textAlign = 'left';
                        this._axisCrossShape.style.textX = x + 10;
                    } else {
                        this._axisCrossShape.style.textAlign = 'right';
                        this._axisCrossShape.style.textX = x - 10;
                    }
                    if (y - this.component.grid.getY() > 50) {
                        this._axisCrossShape.style.textBaseline = 'bottom';
                        this._axisCrossShape.style.textY = y - 10;
                    } else {
                        this._axisCrossShape.style.textBaseline = 'top';
                        this._axisCrossShape.style.textY = y + 10;
                    }
                    this._axisCrossShape.invisible = false;
                    this.zr.modShape(this._axisCrossShape.id);
                } else if (pointType === 'shadow') {
                    if (style.shadow.width == null || style.shadow.width === 'auto' || isNaN(style.shadow.width)) {
                        style.shadow.width = gap;
                    }
                    if (xStart === xEnd) {
                        if (Math.abs(this.component.grid.getX() - xStart) < 2) {
                            style.shadow.width /= 2;
                            xStart = xEnd = xEnd + style.shadow.width / 2;
                        } else if (Math.abs(this.component.grid.getXend() - xStart) < 2) {
                            style.shadow.width /= 2;
                            xStart = xEnd = xEnd - style.shadow.width / 2;
                        }
                    } else if (yStart === yEnd) {
                        if (Math.abs(this.component.grid.getY() - yStart) < 2) {
                            style.shadow.width /= 2;
                            yStart = yEnd = yEnd + style.shadow.width / 2;
                        } else if (Math.abs(this.component.grid.getYend() - yStart) < 2) {
                            style.shadow.width /= 2;
                            yStart = yEnd = yEnd - style.shadow.width / 2;
                        }
                    }
                    this._axisShadowShape.style = {
                        xStart: xStart,
                        yStart: yStart,
                        xEnd: xEnd,
                        yEnd: yEnd,
                        strokeColor: style.shadow.color,
                        lineWidth: style.shadow.width
                    };
                    this._axisShadowShape.invisible = false;
                    this.zr.modShape(this._axisShadowShape.id);
                }
                this.zr.refreshNextFrame();
            }
        },
        __onmousemove: function (param) {
            clearTimeout(this._hidingTicket);
            clearTimeout(this._showingTicket);
            if (this._mousein && this._enterable) {
                return;
            }
            var target = param.target;
            var mx = zrEvent.getX(param.event);
            var my = zrEvent.getY(param.event);
            if (!target) {
                this._curTarget = false;
                this._event = param.event;
                this._event.zrenderX = mx;
                this._event.zrenderY = my;
                if (this._needAxisTrigger && this.component.grid && zrArea.isInside(rectangleInstance, this.component.grid.getArea(), mx, my)) {
                    this._showingTicket = setTimeout(this._tryShow, this._showDelay);
                } else if (this._needAxisTrigger && this.component.polar && this.component.polar.isInside([
                        mx,
                        my
                    ]) != -1) {
                    this._showingTicket = setTimeout(this._tryShow, this._showDelay);
                } else {
                    !this._event.connectTrigger && this.messageCenter.dispatch(ecConfig.EVENT.TOOLTIP_OUT_GRID, this._event, null, this.myChart);
                    this._hidingTicket = setTimeout(this._hide, this._hideDelay);
                }
            } else {
                this._curTarget = target;
                this._event = param.event;
                this._event.zrenderX = mx;
                this._event.zrenderY = my;
                var polarIndex;
                if (this._needAxisTrigger && this.component.polar && (polarIndex = this.component.polar.isInside([
                        mx,
                        my
                    ])) != -1) {
                    var series = this.option.series;
                    for (var i = 0, l = series.length; i < l; i++) {
                        if (series[i].polarIndex === polarIndex && this.deepQuery([
                                series[i],
                                this.option
                            ], 'tooltip.trigger') === 'axis') {
                            this._curTarget = null;
                            break;
                        }
                    }
                }
                this._showingTicket = setTimeout(this._tryShow, this._showDelay);
            }
        },
        __onglobalout: function () {
            clearTimeout(this._hidingTicket);
            clearTimeout(this._showingTicket);
            this._hidingTicket = setTimeout(this._hide, this._hideDelay);
        },
        __setContent: function (ticket, content) {
            if (!this._tDom) {
                return;
            }
            if (ticket === this._curTicket) {
                this._tDom.innerHTML = content;
            }
            setTimeout(this._refixed, 20);
        },
        ontooltipHover: function (param, tipShape) {
            if (!this._lastTipShape || this._lastTipShape && this._lastTipShape.dataIndex != param.dataIndex) {
                if (this._lastTipShape && this._lastTipShape.tipShape.length > 0) {
                    this.zr.delShape(this._lastTipShape.tipShape);
                    this.shapeList.length = 2;
                }
                for (var i = 0, l = tipShape.length; i < l; i++) {
                    tipShape[i].zlevel = this.getZlevelBase();
                    tipShape[i].z = this.getZBase();
                    tipShape[i].style = zrShapeBase.prototype.getHighlightStyle(tipShape[i].style, tipShape[i].highlightStyle);
                    tipShape[i].draggable = false;
                    tipShape[i].hoverable = false;
                    tipShape[i].clickable = false;
                    tipShape[i].ondragend = null;
                    tipShape[i].ondragover = null;
                    tipShape[i].ondrop = null;
                    this.shapeList.push(tipShape[i]);
                    this.zr.addShape(tipShape[i]);
                }
                this._lastTipShape = {
                    dataIndex: param.dataIndex,
                    tipShape: tipShape
                };
            }
        },
        ondragend: function () {
            this._hide();
        },
        onlegendSelected: function (param) {
            this._selectedMap = param.selected;
        },
        _setSelectedMap: function () {
            if (this.component.legend) {
                this._selectedMap = zrUtil.clone(this.component.legend.getSelectedMap());
            } else {
                this._selectedMap = {};
            }
        },
        _isSelected: function (itemName) {
            if (this._selectedMap[itemName] != null) {
                return this._selectedMap[itemName];
            } else {
                return true;
            }
        },
        showTip: function (params) {
            if (!params) {
                return;
            }
            var seriesIndex;
            var series = this.option.series;
            if (params.seriesIndex != null) {
                seriesIndex = params.seriesIndex;
            } else {
                var seriesName = params.seriesName;
                for (var i = 0, l = series.length; i < l; i++) {
                    if (series[i].name === seriesName) {
                        seriesIndex = i;
                        break;
                    }
                }
            }
            var serie = series[seriesIndex];
            if (serie == null) {
                return;
            }
            var chart = this.myChart.chart[serie.type];
            var isAxisTrigger = this.deepQuery([
                serie,
                this.option
            ], 'tooltip.trigger') === 'axis';
            if (!chart) {
                return;
            }
            if (isAxisTrigger) {
                var dataIndex = params.dataIndex;
                switch (chart.type) {
                case ecConfig.CHART_TYPE_LINE:
                case ecConfig.CHART_TYPE_BAR:
                case ecConfig.CHART_TYPE_K:
                    if (this.component.xAxis == null || this.component.yAxis == null || serie.data.length <= dataIndex) {
                        return;
                    }
                    var xAxisIndex = serie.xAxisIndex || 0;
                    var yAxisIndex = serie.yAxisIndex || 0;
                    if (this.component.xAxis.getAxis(xAxisIndex).type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY) {
                        this._event = {
                            zrenderX: this.component.xAxis.getAxis(xAxisIndex).getCoordByIndex(dataIndex),
                            zrenderY: this.component.grid.getY() + (this.component.grid.getYend() - this.component.grid.getY()) / 4
                        };
                    } else {
                        this._event = {
                            zrenderX: this.component.grid.getX() + (this.component.grid.getXend() - this.component.grid.getX()) / 4,
                            zrenderY: this.component.yAxis.getAxis(yAxisIndex).getCoordByIndex(dataIndex)
                        };
                    }
                    this._showAxisTrigger(xAxisIndex, yAxisIndex, dataIndex);
                    break;
                case ecConfig.CHART_TYPE_RADAR:
                    if (this.component.polar == null || serie.data[0].value.length <= dataIndex) {
                        return;
                    }
                    var polarIndex = serie.polarIndex || 0;
                    var vector = this.component.polar.getVector(polarIndex, dataIndex, 'max');
                    this._event = {
                        zrenderX: vector[0],
                        zrenderY: vector[1]
                    };
                    this._showPolarTrigger(polarIndex, dataIndex);
                    break;
                }
            } else {
                var shapeList = chart.shapeList;
                var x;
                var y;
                switch (chart.type) {
                case ecConfig.CHART_TYPE_LINE:
                case ecConfig.CHART_TYPE_BAR:
                case ecConfig.CHART_TYPE_K:
                case ecConfig.CHART_TYPE_SCATTER:
                    var dataIndex = params.dataIndex;
                    for (var i = 0, l = shapeList.length; i < l; i++) {
                        if (shapeList[i]._mark == null && ecData.get(shapeList[i], 'seriesIndex') == seriesIndex && ecData.get(shapeList[i], 'dataIndex') == dataIndex) {
                            this._curTarget = shapeList[i];
                            x = shapeList[i].style.x;
                            y = chart.type != ecConfig.CHART_TYPE_K ? shapeList[i].style.y : shapeList[i].style.y[0];
                            break;
                        }
                    }
                    break;
                case ecConfig.CHART_TYPE_RADAR:
                    var dataIndex = params.dataIndex;
                    for (var i = 0, l = shapeList.length; i < l; i++) {
                        if (shapeList[i].type === 'polygon' && ecData.get(shapeList[i], 'seriesIndex') == seriesIndex && ecData.get(shapeList[i], 'dataIndex') == dataIndex) {
                            this._curTarget = shapeList[i];
                            var vector = this.component.polar.getCenter(serie.polarIndex || 0);
                            x = vector[0];
                            y = vector[1];
                            break;
                        }
                    }
                    break;
                case ecConfig.CHART_TYPE_PIE:
                    var name = params.name;
                    for (var i = 0, l = shapeList.length; i < l; i++) {
                        if (shapeList[i].type === 'sector' && ecData.get(shapeList[i], 'seriesIndex') == seriesIndex && ecData.get(shapeList[i], 'name') == name) {
                            this._curTarget = shapeList[i];
                            var style = this._curTarget.style;
                            var midAngle = (style.startAngle + style.endAngle) / 2 * Math.PI / 180;
                            x = this._curTarget.style.x + Math.cos(midAngle) * style.r / 1.5;
                            y = this._curTarget.style.y - Math.sin(midAngle) * style.r / 1.5;
                            break;
                        }
                    }
                    break;
                case ecConfig.CHART_TYPE_MAP:
                    var name = params.name;
                    var mapType = serie.mapType;
                    for (var i = 0, l = shapeList.length; i < l; i++) {
                        if (shapeList[i].type === 'text' && shapeList[i]._mapType === mapType && shapeList[i].style._name === name) {
                            this._curTarget = shapeList[i];
                            x = this._curTarget.style.x + this._curTarget.position[0];
                            y = this._curTarget.style.y + this._curTarget.position[1];
                            break;
                        }
                    }
                    break;
                case ecConfig.CHART_TYPE_CHORD:
                    var name = params.name;
                    for (var i = 0, l = shapeList.length; i < l; i++) {
                        if (shapeList[i].type === 'sector' && ecData.get(shapeList[i], 'name') == name) {
                            this._curTarget = shapeList[i];
                            var style = this._curTarget.style;
                            var midAngle = (style.startAngle + style.endAngle) / 2 * Math.PI / 180;
                            x = this._curTarget.style.x + Math.cos(midAngle) * (style.r - 2);
                            y = this._curTarget.style.y - Math.sin(midAngle) * (style.r - 2);
                            this.zr.trigger(zrConfig.EVENT.MOUSEMOVE, {
                                zrenderX: x,
                                zrenderY: y
                            });
                            return;
                        }
                    }
                    break;
                case ecConfig.CHART_TYPE_FORCE:
                    var name = params.name;
                    for (var i = 0, l = shapeList.length; i < l; i++) {
                        if (shapeList[i].type === 'circle' && ecData.get(shapeList[i], 'name') == name) {
                            this._curTarget = shapeList[i];
                            x = this._curTarget.position[0];
                            y = this._curTarget.position[1];
                            break;
                        }
                    }
                    break;
                }
                if (x != null && y != null) {
                    this._event = {
                        zrenderX: x,
                        zrenderY: y
                    };
                    this.zr.addHoverShape(this._curTarget);
                    this.zr.refreshHover();
                    this._showItemTrigger();
                }
            }
        },
        hideTip: function () {
            this._hide();
        },
        refresh: function (newOption) {
            this._zrHeight = this.zr.getHeight();
            this._zrWidth = this.zr.getWidth();
            if (this._lastTipShape && this._lastTipShape.tipShape.length > 0) {
                this.zr.delShape(this._lastTipShape.tipShape);
            }
            this._lastTipShape = false;
            this.shapeList.length = 2;
            this._lastDataIndex = -1;
            this._lastSeriesIndex = -1;
            this._lastItemTriggerId = -1;
            if (newOption) {
                this.option = newOption;
                this.option.tooltip = this.reformOption(this.option.tooltip);
                this.option.tooltip.textStyle = zrUtil.merge(this.option.tooltip.textStyle, this.ecTheme.textStyle);
                this._needAxisTrigger = false;
                if (this.option.tooltip.trigger === 'axis') {
                    this._needAxisTrigger = true;
                }
                var series = this.option.series;
                for (var i = 0, l = series.length; i < l; i++) {
                    if (this.query(series[i], 'tooltip.trigger') === 'axis') {
                        this._needAxisTrigger = true;
                        break;
                    }
                }
                this._showDelay = this.option.tooltip.showDelay;
                this._hideDelay = this.option.tooltip.hideDelay;
                this._defaultCssText = this._style(this.option.tooltip);
                this._setSelectedMap();
                this._axisLineWidth = this.option.tooltip.axisPointer.lineStyle.width;
                this._enterable = this.option.tooltip.enterable;
            }
            if (this.showing) {
                var self = this;
                setTimeout(function () {
                    self.zr.trigger(zrConfig.EVENT.MOUSEMOVE, self.zr.handler._event);
                }, 50);
            }
        },
        onbeforDispose: function () {
            if (this._lastTipShape && this._lastTipShape.tipShape.length > 0) {
                this.zr.delShape(this._lastTipShape.tipShape);
            }
            clearTimeout(this._hidingTicket);
            clearTimeout(this._showingTicket);
            this.zr.un(zrConfig.EVENT.MOUSEMOVE, this._onmousemove);
            this.zr.un(zrConfig.EVENT.GLOBALOUT, this._onglobalout);
            if (this.hasAppend && !!this.dom.firstChild) {
                this.dom.firstChild.removeChild(this._tDom);
            }
            this._tDom = null;
        },
        _encodeHTML: function (source) {
            return String(source).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
        }
    };
    zrUtil.inherits(Tooltip, Base);
    require('../component').define('tooltip', Tooltip);
    return Tooltip;
});define('echarts/component/legend', [
    'require',
    './base',
    'zrender/shape/Text',
    'zrender/shape/Rectangle',
    'zrender/shape/Sector',
    '../util/shape/Icon',
    '../util/shape/Candle',
    '../config',
    'zrender/tool/util',
    'zrender/tool/area',
    '../component'
], function (require) {
    var Base = require('./base');
    var TextShape = require('zrender/shape/Text');
    var RectangleShape = require('zrender/shape/Rectangle');
    var SectorShape = require('zrender/shape/Sector');
    var IconShape = require('../util/shape/Icon');
    var CandleShape = require('../util/shape/Candle');
    var ecConfig = require('../config');
    ecConfig.legend = {
        zlevel: 0,
        z: 4,
        show: true,
        orient: 'horizontal',
        x: 'center',
        y: 'top',
        backgroundColor: 'rgba(0,0,0,0)',
        borderColor: '#ccc',
        borderWidth: 0,
        padding: 5,
        itemGap: 10,
        itemWidth: 20,
        itemHeight: 14,
        textStyle: { color: '#333' },
        selectedMode: true
    };
    var zrUtil = require('zrender/tool/util');
    var zrArea = require('zrender/tool/area');
    function Legend(ecTheme, messageCenter, zr, option, myChart) {
        if (!this.query(option, 'legend.data')) {
            console.error('option.legend.data has not been defined.');
            return;
        }
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        var self = this;
        self._legendSelected = function (param) {
            self.__legendSelected(param);
        };
        self._dispatchHoverLink = function (param) {
            return self.__dispatchHoverLink(param);
        };
        this._colorIndex = 0;
        this._colorMap = {};
        this._selectedMap = {};
        this._hasDataMap = {};
        this.refresh(option);
    }
    Legend.prototype = {
        type: ecConfig.COMPONENT_TYPE_LEGEND,
        _buildShape: function () {
            if (!this.legendOption.show) {
                return;
            }
            this._itemGroupLocation = this._getItemGroupLocation();
            this._buildBackground();
            this._buildItem();
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                this.zr.addShape(this.shapeList[i]);
            }
        },
        _buildItem: function () {
            var data = this.legendOption.data;
            var dataLength = data.length;
            var itemName;
            var itemType;
            var itemShape;
            var textShape;
            var textStyle = this.legendOption.textStyle;
            var dataTextStyle;
            var dataFont;
            var formattedName;
            var zrWidth = this.zr.getWidth();
            var zrHeight = this.zr.getHeight();
            var lastX = this._itemGroupLocation.x;
            var lastY = this._itemGroupLocation.y;
            var itemWidth = this.legendOption.itemWidth;
            var itemHeight = this.legendOption.itemHeight;
            var itemGap = this.legendOption.itemGap;
            var color;
            if (this.legendOption.orient === 'vertical' && this.legendOption.x === 'right') {
                lastX = this._itemGroupLocation.x + this._itemGroupLocation.width - itemWidth;
            }
            for (var i = 0; i < dataLength; i++) {
                dataTextStyle = zrUtil.merge(data[i].textStyle || {}, textStyle);
                dataFont = this.getFont(dataTextStyle);
                itemName = this._getName(data[i]);
                formattedName = this._getFormatterName(itemName);
                if (itemName === '') {
                    if (this.legendOption.orient === 'horizontal') {
                        lastX = this._itemGroupLocation.x;
                        lastY += itemHeight + itemGap;
                    } else {
                        this.legendOption.x === 'right' ? lastX -= this._itemGroupLocation.maxWidth + itemGap : lastX += this._itemGroupLocation.maxWidth + itemGap;
                        lastY = this._itemGroupLocation.y;
                    }
                    continue;
                }
                itemType = data[i].icon || this._getSomethingByName(itemName).type;
                color = this.getColor(itemName);
                if (this.legendOption.orient === 'horizontal') {
                    if (zrWidth - lastX < 200 && itemWidth + 5 + zrArea.getTextWidth(formattedName, dataFont) + (i === dataLength - 1 || data[i + 1] === '' ? 0 : itemGap) >= zrWidth - lastX) {
                        lastX = this._itemGroupLocation.x;
                        lastY += itemHeight + itemGap;
                    }
                } else {
                    if (zrHeight - lastY < 200 && itemHeight + (i === dataLength - 1 || data[i + 1] === '' ? 0 : itemGap) >= zrHeight - lastY) {
                        this.legendOption.x === 'right' ? lastX -= this._itemGroupLocation.maxWidth + itemGap : lastX += this._itemGroupLocation.maxWidth + itemGap;
                        lastY = this._itemGroupLocation.y;
                    }
                }
                itemShape = this._getItemShapeByType(lastX, lastY, itemWidth, itemHeight, this._selectedMap[itemName] && this._hasDataMap[itemName] ? color : '#ccc', itemType, color);
                itemShape._name = itemName;
                itemShape = new IconShape(itemShape);
                textShape = {
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    style: {
                        x: lastX + itemWidth + 5,
                        y: lastY + itemHeight / 2,
                        color: this._selectedMap[itemName] ? dataTextStyle.color === 'auto' ? color : dataTextStyle.color : '#ccc',
                        text: formattedName,
                        textFont: dataFont,
                        textBaseline: 'middle'
                    },
                    highlightStyle: {
                        color: color,
                        brushType: 'fill'
                    },
                    hoverable: !!this.legendOption.selectedMode,
                    clickable: !!this.legendOption.selectedMode
                };
                if (this.legendOption.orient === 'vertical' && this.legendOption.x === 'right') {
                    textShape.style.x -= itemWidth + 10;
                    textShape.style.textAlign = 'right';
                }
                textShape._name = itemName;
                textShape = new TextShape(textShape);
                if (this.legendOption.selectedMode) {
                    itemShape.onclick = textShape.onclick = this._legendSelected;
                    itemShape.onmouseover = textShape.onmouseover = this._dispatchHoverLink;
                    itemShape.hoverConnect = textShape.id;
                    textShape.hoverConnect = itemShape.id;
                }
                this.shapeList.push(itemShape);
                this.shapeList.push(textShape);
                if (this.legendOption.orient === 'horizontal') {
                    lastX += itemWidth + 5 + zrArea.getTextWidth(formattedName, dataFont) + itemGap;
                } else {
                    lastY += itemHeight + itemGap;
                }
            }
            if (this.legendOption.orient === 'horizontal' && this.legendOption.x === 'center' && lastY != this._itemGroupLocation.y) {
                this._mLineOptimize();
            }
        },
        _getName: function (data) {
            return typeof data.name != 'undefined' ? data.name : data;
        },
        _getFormatterName: function (itemName) {
            var formatter = this.legendOption.formatter;
            var formattedName;
            if (typeof formatter === 'function') {
                formattedName = formatter.call(this.myChart, itemName);
            } else if (typeof formatter === 'string') {
                formattedName = formatter.replace('{name}', itemName);
            } else {
                formattedName = itemName;
            }
            return formattedName;
        },
        _getFormatterNameFromData: function (data) {
            var itemName = this._getName(data);
            return this._getFormatterName(itemName);
        },
        _mLineOptimize: function () {
            var lineOffsetArray = [];
            var lastX = this._itemGroupLocation.x;
            for (var i = 2, l = this.shapeList.length; i < l; i++) {
                if (this.shapeList[i].style.x === lastX) {
                    lineOffsetArray.push((this._itemGroupLocation.width - (this.shapeList[i - 1].style.x + zrArea.getTextWidth(this.shapeList[i - 1].style.text, this.shapeList[i - 1].style.textFont) - lastX)) / 2);
                } else if (i === l - 1) {
                    lineOffsetArray.push((this._itemGroupLocation.width - (this.shapeList[i].style.x + zrArea.getTextWidth(this.shapeList[i].style.text, this.shapeList[i].style.textFont) - lastX)) / 2);
                }
            }
            var curLineIndex = -1;
            for (var i = 1, l = this.shapeList.length; i < l; i++) {
                if (this.shapeList[i].style.x === lastX) {
                    curLineIndex++;
                }
                if (lineOffsetArray[curLineIndex] === 0) {
                    continue;
                } else {
                    this.shapeList[i].style.x += lineOffsetArray[curLineIndex];
                }
            }
        },
        _buildBackground: function () {
            var padding = this.reformCssArray(this.legendOption.padding);
            this.shapeList.push(new RectangleShape({
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                hoverable: false,
                style: {
                    x: this._itemGroupLocation.x - padding[3],
                    y: this._itemGroupLocation.y - padding[0],
                    width: this._itemGroupLocation.width + padding[3] + padding[1],
                    height: this._itemGroupLocation.height + padding[0] + padding[2],
                    brushType: this.legendOption.borderWidth === 0 ? 'fill' : 'both',
                    color: this.legendOption.backgroundColor,
                    strokeColor: this.legendOption.borderColor,
                    lineWidth: this.legendOption.borderWidth
                }
            }));
        },
        _getItemGroupLocation: function () {
            var data = this.legendOption.data;
            var dataLength = data.length;
            var itemGap = this.legendOption.itemGap;
            var itemWidth = this.legendOption.itemWidth + 5;
            var itemHeight = this.legendOption.itemHeight;
            var textStyle = this.legendOption.textStyle;
            var font = this.getFont(textStyle);
            var totalWidth = 0;
            var totalHeight = 0;
            var padding = this.reformCssArray(this.legendOption.padding);
            var zrWidth = this.zr.getWidth() - padding[1] - padding[3];
            var zrHeight = this.zr.getHeight() - padding[0] - padding[2];
            var temp = 0;
            var maxWidth = 0;
            if (this.legendOption.orient === 'horizontal') {
                totalHeight = itemHeight;
                for (var i = 0; i < dataLength; i++) {
                    if (this._getName(data[i]) === '') {
                        temp -= itemGap;
                        totalWidth = Math.max(totalWidth, temp);
                        totalHeight += itemHeight + itemGap;
                        temp = 0;
                        continue;
                    }
                    var tempTextWidth = zrArea.getTextWidth(this._getFormatterNameFromData(data[i]), data[i].textStyle ? this.getFont(zrUtil.merge(data[i].textStyle || {}, textStyle)) : font);
                    if (temp + itemWidth + tempTextWidth + itemGap > zrWidth) {
                        temp -= itemGap;
                        totalWidth = Math.max(totalWidth, temp);
                        totalHeight += itemHeight + itemGap;
                        temp = 0;
                    } else {
                        temp += itemWidth + tempTextWidth + itemGap;
                        totalWidth = Math.max(totalWidth, temp - itemGap);
                    }
                }
            } else {
                for (var i = 0; i < dataLength; i++) {
                    maxWidth = Math.max(maxWidth, zrArea.getTextWidth(this._getFormatterNameFromData(data[i]), data[i].textStyle ? this.getFont(zrUtil.merge(data[i].textStyle || {}, textStyle)) : font));
                }
                maxWidth += itemWidth;
                totalWidth = maxWidth;
                for (var i = 0; i < dataLength; i++) {
                    if (this._getName(data[i]) === '') {
                        totalWidth += maxWidth + itemGap;
                        temp -= itemGap;
                        totalHeight = Math.max(totalHeight, temp);
                        temp = 0;
                        continue;
                    }
                    if (temp + itemHeight + itemGap > zrHeight) {
                        totalWidth += maxWidth + itemGap;
                        temp -= itemGap;
                        totalHeight = Math.max(totalHeight, temp);
                        temp = 0;
                    } else {
                        temp += itemHeight + itemGap;
                        totalHeight = Math.max(totalHeight, temp - itemGap);
                    }
                }
            }
            zrWidth = this.zr.getWidth();
            zrHeight = this.zr.getHeight();
            var x;
            switch (this.legendOption.x) {
            case 'center':
                x = Math.floor((zrWidth - totalWidth) / 2);
                break;
            case 'left':
                x = padding[3] + this.legendOption.borderWidth;
                break;
            case 'right':
                x = zrWidth - totalWidth - padding[1] - padding[3] - this.legendOption.borderWidth * 2;
                break;
            default:
                x = this.parsePercent(this.legendOption.x, zrWidth);
                break;
            }
            var y;
            switch (this.legendOption.y) {
            case 'top':
                y = padding[0] + this.legendOption.borderWidth;
                break;
            case 'bottom':
                y = zrHeight - totalHeight - padding[0] - padding[2] - this.legendOption.borderWidth * 2;
                break;
            case 'center':
                y = Math.floor((zrHeight - totalHeight) / 2);
                break;
            default:
                y = this.parsePercent(this.legendOption.y, zrHeight);
                break;
            }
            return {
                x: x,
                y: y,
                width: totalWidth,
                height: totalHeight,
                maxWidth: maxWidth
            };
        },
        _getSomethingByName: function (name) {
            var series = this.option.series;
            var data;
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].name === name) {
                    return {
                        type: series[i].type,
                        series: series[i],
                        seriesIndex: i,
                        data: null,
                        dataIndex: -1
                    };
                }
                if (series[i].type === ecConfig.CHART_TYPE_PIE || series[i].type === ecConfig.CHART_TYPE_RADAR || series[i].type === ecConfig.CHART_TYPE_CHORD || series[i].type === ecConfig.CHART_TYPE_FORCE || series[i].type === ecConfig.CHART_TYPE_FUNNEL) {
                    data = series[i].categories || series[i].data || series[i].nodes;
                    for (var j = 0, k = data.length; j < k; j++) {
                        if (data[j].name === name) {
                            return {
                                type: series[i].type,
                                series: series[i],
                                seriesIndex: i,
                                data: data[j],
                                dataIndex: j
                            };
                        }
                    }
                }
            }
            return {
                type: 'bar',
                series: null,
                seriesIndex: -1,
                data: null,
                dataIndex: -1
            };
        },
        _getItemShapeByType: function (x, y, width, height, color, itemType, defaultColor) {
            var highlightColor = color === '#ccc' ? defaultColor : color;
            var itemShape = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                style: {
                    iconType: 'legendicon' + itemType,
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    color: color,
                    strokeColor: color,
                    lineWidth: 2
                },
                highlightStyle: {
                    color: highlightColor,
                    strokeColor: highlightColor,
                    lineWidth: 1
                },
                hoverable: this.legendOption.selectedMode,
                clickable: this.legendOption.selectedMode
            };
            var imageLocation;
            if (itemType.match('image')) {
                var imageLocation = itemType.replace(new RegExp('^image:\\/\\/'), '');
                itemType = 'image';
            }
            switch (itemType) {
            case 'line':
                itemShape.style.brushType = 'stroke';
                itemShape.highlightStyle.lineWidth = 3;
                break;
            case 'radar':
            case 'scatter':
                itemShape.highlightStyle.lineWidth = 3;
                break;
            case 'k':
                itemShape.style.brushType = 'both';
                itemShape.highlightStyle.lineWidth = 3;
                itemShape.highlightStyle.color = itemShape.style.color = this.deepQuery([
                    this.ecTheme,
                    ecConfig
                ], 'k.itemStyle.normal.color') || '#fff';
                itemShape.style.strokeColor = color != '#ccc' ? this.deepQuery([
                    this.ecTheme,
                    ecConfig
                ], 'k.itemStyle.normal.lineStyle.color') || '#ff3200' : color;
                break;
            case 'image':
                itemShape.style.iconType = 'image';
                itemShape.style.image = imageLocation;
                if (color === '#ccc') {
                    itemShape.style.opacity = 0.5;
                }
                break;
            }
            return itemShape;
        },
        __legendSelected: function (param) {
            var itemName = param.target._name;
            if (this.legendOption.selectedMode === 'single') {
                for (var k in this._selectedMap) {
                    this._selectedMap[k] = false;
                }
            }
            this._selectedMap[itemName] = !this._selectedMap[itemName];
            this.messageCenter.dispatch(ecConfig.EVENT.LEGEND_SELECTED, param.event, {
                selected: this._selectedMap,
                target: itemName
            }, this.myChart);
        },
        __dispatchHoverLink: function (param) {
            this.messageCenter.dispatch(ecConfig.EVENT.LEGEND_HOVERLINK, param.event, { target: param.target._name }, this.myChart);
            return;
        },
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption || this.option;
                this.option.legend = this.reformOption(this.option.legend);
                this.legendOption = this.option.legend;
                var data = this.legendOption.data || [];
                var itemName;
                var something;
                var color;
                var queryTarget;
                if (this.legendOption.selected) {
                    for (var k in this.legendOption.selected) {
                        this._selectedMap[k] = typeof this._selectedMap[k] != 'undefined' ? this._selectedMap[k] : this.legendOption.selected[k];
                    }
                }
                for (var i = 0, dataLength = data.length; i < dataLength; i++) {
                    itemName = this._getName(data[i]);
                    if (itemName === '') {
                        continue;
                    }
                    something = this._getSomethingByName(itemName);
                    if (!something.series) {
                        this._hasDataMap[itemName] = false;
                    } else {
                        this._hasDataMap[itemName] = true;
                        if (something.data && (something.type === ecConfig.CHART_TYPE_PIE || something.type === ecConfig.CHART_TYPE_FORCE || something.type === ecConfig.CHART_TYPE_FUNNEL)) {
                            queryTarget = [
                                something.data,
                                something.series
                            ];
                        } else {
                            queryTarget = [something.series];
                        }
                        color = this.getItemStyleColor(this.deepQuery(queryTarget, 'itemStyle.normal.color'), something.seriesIndex, something.dataIndex, something.data);
                        if (color && something.type != ecConfig.CHART_TYPE_K) {
                            this.setColor(itemName, color);
                        }
                        this._selectedMap[itemName] = this._selectedMap[itemName] != null ? this._selectedMap[itemName] : true;
                    }
                }
            }
            this.clear();
            this._buildShape();
        },
        getRelatedAmount: function (name) {
            var amount = 0;
            var series = this.option.series;
            var data;
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].name === name) {
                    amount++;
                }
                if (series[i].type === ecConfig.CHART_TYPE_PIE || series[i].type === ecConfig.CHART_TYPE_RADAR || series[i].type === ecConfig.CHART_TYPE_CHORD || series[i].type === ecConfig.CHART_TYPE_FORCE || series[i].type === ecConfig.CHART_TYPE_FUNNEL) {
                    data = series[i].type != ecConfig.CHART_TYPE_FORCE ? series[i].data : series[i].categories;
                    for (var j = 0, k = data.length; j < k; j++) {
                        if (data[j].name === name && data[j].value != '-') {
                            amount++;
                        }
                    }
                }
            }
            return amount;
        },
        setColor: function (legendName, color) {
            this._colorMap[legendName] = color;
        },
        getColor: function (legendName) {
            if (!this._colorMap[legendName]) {
                this._colorMap[legendName] = this.zr.getColor(this._colorIndex++);
            }
            return this._colorMap[legendName];
        },
        hasColor: function (legendName) {
            return this._colorMap[legendName] ? this._colorMap[legendName] : false;
        },
        add: function (name, color) {
            var data = this.legendOption.data;
            for (var i = 0, dataLength = data.length; i < dataLength; i++) {
                if (this._getName(data[i]) === name) {
                    return;
                }
            }
            this.legendOption.data.push(name);
            this.setColor(name, color);
            this._selectedMap[name] = true;
            this._hasDataMap[name] = true;
        },
        del: function (name) {
            var data = this.legendOption.data;
            for (var i = 0, dataLength = data.length; i < dataLength; i++) {
                if (this._getName(data[i]) === name) {
                    return this.legendOption.data.splice(i, 1);
                }
            }
        },
        getItemShape: function (name) {
            if (name == null) {
                return;
            }
            var shape;
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                shape = this.shapeList[i];
                if (shape._name === name && shape.type != 'text') {
                    return shape;
                }
            }
        },
        setItemShape: function (name, itemShape) {
            var shape;
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                shape = this.shapeList[i];
                if (shape._name === name && shape.type != 'text') {
                    if (!this._selectedMap[name]) {
                        itemShape.style.color = '#ccc';
                        itemShape.style.strokeColor = '#ccc';
                    }
                    this.zr.modShape(shape.id, itemShape);
                }
            }
        },
        isSelected: function (itemName) {
            if (typeof this._selectedMap[itemName] != 'undefined') {
                return this._selectedMap[itemName];
            } else {
                return true;
            }
        },
        getSelectedMap: function () {
            return this._selectedMap;
        },
        setSelected: function (itemName, selectStatus) {
            if (this.legendOption.selectedMode === 'single') {
                for (var k in this._selectedMap) {
                    this._selectedMap[k] = false;
                }
            }
            this._selectedMap[itemName] = selectStatus;
            this.messageCenter.dispatch(ecConfig.EVENT.LEGEND_SELECTED, null, {
                selected: this._selectedMap,
                target: itemName
            }, this.myChart);
        },
        onlegendSelected: function (param, status) {
            var legendSelected = param.selected;
            for (var itemName in legendSelected) {
                if (this._selectedMap[itemName] != legendSelected[itemName]) {
                    status.needRefresh = true;
                }
                this._selectedMap[itemName] = legendSelected[itemName];
            }
            return;
        }
    };
    var legendIcon = {
        line: function (ctx, style) {
            var dy = style.height / 2;
            ctx.moveTo(style.x, style.y + dy);
            ctx.lineTo(style.x + style.width, style.y + dy);
        },
        pie: function (ctx, style) {
            var x = style.x;
            var y = style.y;
            var width = style.width;
            var height = style.height;
            SectorShape.prototype.buildPath(ctx, {
                x: x + width / 2,
                y: y + height + 2,
                r: height,
                r0: 6,
                startAngle: 45,
                endAngle: 135
            });
        },
        eventRiver: function (ctx, style) {
            var x = style.x;
            var y = style.y;
            var width = style.width;
            var height = style.height;
            ctx.moveTo(x, y + height);
            ctx.bezierCurveTo(x + width, y + height, x, y + 4, x + width, y + 4);
            ctx.lineTo(x + width, y);
            ctx.bezierCurveTo(x, y, x + width, y + height - 4, x, y + height - 4);
            ctx.lineTo(x, y + height);
        },
        k: function (ctx, style) {
            var x = style.x;
            var y = style.y;
            var width = style.width;
            var height = style.height;
            CandleShape.prototype.buildPath(ctx, {
                x: x + width / 2,
                y: [
                    y + 1,
                    y + 1,
                    y + height - 6,
                    y + height
                ],
                width: width - 6
            });
        },
        bar: function (ctx, style) {
            var x = style.x;
            var y = style.y + 1;
            var width = style.width;
            var height = style.height - 2;
            var r = 3;
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + width - r, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + r);
            ctx.lineTo(x + width, y + height - r);
            ctx.quadraticCurveTo(x + width, y + height, x + width - r, y + height);
            ctx.lineTo(x + r, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
        },
        force: function (ctx, style) {
            IconShape.prototype.iconLibrary.circle(ctx, style);
        },
        radar: function (ctx, style) {
            var n = 6;
            var x = style.x + style.width / 2;
            var y = style.y + style.height / 2;
            var r = style.height / 2;
            var dStep = 2 * Math.PI / n;
            var deg = -Math.PI / 2;
            var xStart = x + r * Math.cos(deg);
            var yStart = y + r * Math.sin(deg);
            ctx.moveTo(xStart, yStart);
            deg += dStep;
            for (var i = 0, end = n - 1; i < end; i++) {
                ctx.lineTo(x + r * Math.cos(deg), y + r * Math.sin(deg));
                deg += dStep;
            }
            ctx.lineTo(xStart, yStart);
        }
    };
    legendIcon.chord = legendIcon.pie;
    legendIcon.map = legendIcon.bar;
    for (var k in legendIcon) {
        IconShape.prototype.iconLibrary['legendicon' + k] = legendIcon[k];
    }
    zrUtil.inherits(Legend, Base);
    require('../component').define('legend', Legend);
    return Legend;
});define('echarts/util/ecData', [], function () {
    function pack(shape, series, seriesIndex, data, dataIndex, name, special, special2) {
        var value;
        if (typeof data != 'undefined') {
            value = data.value == null ? data : data.value;
        }
        shape._echartsData = {
            '_series': series,
            '_seriesIndex': seriesIndex,
            '_data': data,
            '_dataIndex': dataIndex,
            '_name': name,
            '_value': value,
            '_special': special,
            '_special2': special2
        };
        return shape._echartsData;
    }
    function get(shape, key) {
        var data = shape._echartsData;
        if (!key) {
            return data;
        }
        switch (key) {
        case 'series':
        case 'seriesIndex':
        case 'data':
        case 'dataIndex':
        case 'name':
        case 'value':
        case 'special':
        case 'special2':
            return data && data['_' + key];
        }
        return null;
    }
    function set(shape, key, value) {
        shape._echartsData = shape._echartsData || {};
        switch (key) {
        case 'series':
        case 'seriesIndex':
        case 'data':
        case 'dataIndex':
        case 'name':
        case 'value':
        case 'special':
        case 'special2':
            shape._echartsData['_' + key] = value;
            break;
        }
    }
    function clone(source, target) {
        target._echartsData = {
            '_series': source._echartsData._series,
            '_seriesIndex': source._echartsData._seriesIndex,
            '_data': source._echartsData._data,
            '_dataIndex': source._echartsData._dataIndex,
            '_name': source._echartsData._name,
            '_value': source._echartsData._value,
            '_special': source._echartsData._special,
            '_special2': source._echartsData._special2
        };
    }
    return {
        pack: pack,
        set: set,
        get: get,
        clone: clone
    };
});define('echarts/chart', [], function () {
    var self = {};
    var _chartLibrary = {};
    self.define = function (name, clazz) {
        _chartLibrary[name] = clazz;
        return self;
    };
    self.get = function (name) {
        return _chartLibrary[name];
    };
    return self;
});define('zrender/tool/color', [
    'require',
    '../tool/util'
], function (require) {
    var util = require('../tool/util');
    var _ctx;
    var palette = [
        '#ff9277',
        ' #dddd00',
        ' #ffc877',
        ' #bbe3ff',
        ' #d5ffbb',
        '#bbbbff',
        ' #ddb000',
        ' #b0dd00',
        ' #e2bbff',
        ' #ffbbe3',
        '#ff7777',
        ' #ff9900',
        ' #83dd00',
        ' #77e3ff',
        ' #778fff',
        '#c877ff',
        ' #ff77ab',
        ' #ff6600',
        ' #aa8800',
        ' #77c7ff',
        '#ad77ff',
        ' #ff77ff',
        ' #dd0083',
        ' #777700',
        ' #00aa00',
        '#0088aa',
        ' #8400dd',
        ' #aa0088',
        ' #dd0000',
        ' #772e00'
    ];
    var _palette = palette;
    var highlightColor = 'rgba(255,255,0,0.5)';
    var _highlightColor = highlightColor;
    var colorRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i;
    var _nameColors = {
        aliceblue: '#f0f8ff',
        antiquewhite: '#faebd7',
        aqua: '#0ff',
        aquamarine: '#7fffd4',
        azure: '#f0ffff',
        beige: '#f5f5dc',
        bisque: '#ffe4c4',
        black: '#000',
        blanchedalmond: '#ffebcd',
        blue: '#00f',
        blueviolet: '#8a2be2',
        brown: '#a52a2a',
        burlywood: '#deb887',
        cadetblue: '#5f9ea0',
        chartreuse: '#7fff00',
        chocolate: '#d2691e',
        coral: '#ff7f50',
        cornflowerblue: '#6495ed',
        cornsilk: '#fff8dc',
        crimson: '#dc143c',
        cyan: '#0ff',
        darkblue: '#00008b',
        darkcyan: '#008b8b',
        darkgoldenrod: '#b8860b',
        darkgray: '#a9a9a9',
        darkgrey: '#a9a9a9',
        darkgreen: '#006400',
        darkkhaki: '#bdb76b',
        darkmagenta: '#8b008b',
        darkolivegreen: '#556b2f',
        darkorange: '#ff8c00',
        darkorchid: '#9932cc',
        darkred: '#8b0000',
        darksalmon: '#e9967a',
        darkseagreen: '#8fbc8f',
        darkslateblue: '#483d8b',
        darkslategray: '#2f4f4f',
        darkslategrey: '#2f4f4f',
        darkturquoise: '#00ced1',
        darkviolet: '#9400d3',
        deeppink: '#ff1493',
        deepskyblue: '#00bfff',
        dimgray: '#696969',
        dimgrey: '#696969',
        dodgerblue: '#1e90ff',
        firebrick: '#b22222',
        floralwhite: '#fffaf0',
        forestgreen: '#228b22',
        fuchsia: '#f0f',
        gainsboro: '#dcdcdc',
        ghostwhite: '#f8f8ff',
        gold: '#ffd700',
        goldenrod: '#daa520',
        gray: '#808080',
        grey: '#808080',
        green: '#008000',
        greenyellow: '#adff2f',
        honeydew: '#f0fff0',
        hotpink: '#ff69b4',
        indianred: '#cd5c5c',
        indigo: '#4b0082',
        ivory: '#fffff0',
        khaki: '#f0e68c',
        lavender: '#e6e6fa',
        lavenderblush: '#fff0f5',
        lawngreen: '#7cfc00',
        lemonchiffon: '#fffacd',
        lightblue: '#add8e6',
        lightcoral: '#f08080',
        lightcyan: '#e0ffff',
        lightgoldenrodyellow: '#fafad2',
        lightgray: '#d3d3d3',
        lightgrey: '#d3d3d3',
        lightgreen: '#90ee90',
        lightpink: '#ffb6c1',
        lightsalmon: '#ffa07a',
        lightseagreen: '#20b2aa',
        lightskyblue: '#87cefa',
        lightslategray: '#789',
        lightslategrey: '#789',
        lightsteelblue: '#b0c4de',
        lightyellow: '#ffffe0',
        lime: '#0f0',
        limegreen: '#32cd32',
        linen: '#faf0e6',
        magenta: '#f0f',
        maroon: '#800000',
        mediumaquamarine: '#66cdaa',
        mediumblue: '#0000cd',
        mediumorchid: '#ba55d3',
        mediumpurple: '#9370d8',
        mediumseagreen: '#3cb371',
        mediumslateblue: '#7b68ee',
        mediumspringgreen: '#00fa9a',
        mediumturquoise: '#48d1cc',
        mediumvioletred: '#c71585',
        midnightblue: '#191970',
        mintcream: '#f5fffa',
        mistyrose: '#ffe4e1',
        moccasin: '#ffe4b5',
        navajowhite: '#ffdead',
        navy: '#000080',
        oldlace: '#fdf5e6',
        olive: '#808000',
        olivedrab: '#6b8e23',
        orange: '#ffa500',
        orangered: '#ff4500',
        orchid: '#da70d6',
        palegoldenrod: '#eee8aa',
        palegreen: '#98fb98',
        paleturquoise: '#afeeee',
        palevioletred: '#d87093',
        papayawhip: '#ffefd5',
        peachpuff: '#ffdab9',
        peru: '#cd853f',
        pink: '#ffc0cb',
        plum: '#dda0dd',
        powderblue: '#b0e0e6',
        purple: '#800080',
        red: '#f00',
        rosybrown: '#bc8f8f',
        royalblue: '#4169e1',
        saddlebrown: '#8b4513',
        salmon: '#fa8072',
        sandybrown: '#f4a460',
        seagreen: '#2e8b57',
        seashell: '#fff5ee',
        sienna: '#a0522d',
        silver: '#c0c0c0',
        skyblue: '#87ceeb',
        slateblue: '#6a5acd',
        slategray: '#708090',
        slategrey: '#708090',
        snow: '#fffafa',
        springgreen: '#00ff7f',
        steelblue: '#4682b4',
        tan: '#d2b48c',
        teal: '#008080',
        thistle: '#d8bfd8',
        tomato: '#ff6347',
        turquoise: '#40e0d0',
        violet: '#ee82ee',
        wheat: '#f5deb3',
        white: '#fff',
        whitesmoke: '#f5f5f5',
        yellow: '#ff0',
        yellowgreen: '#9acd32'
    };
    function customPalette(userPalete) {
        palette = userPalete;
    }
    function resetPalette() {
        palette = _palette;
    }
    function getColor(idx, userPalete) {
        idx = idx | 0;
        userPalete = userPalete || palette;
        return userPalete[idx % userPalete.length];
    }
    function customHighlight(userHighlightColor) {
        highlightColor = userHighlightColor;
    }
    function resetHighlight() {
        _highlightColor = highlightColor;
    }
    function getHighlightColor() {
        return highlightColor;
    }
    function getRadialGradient(x0, y0, r0, x1, y1, r1, colorList) {
        if (!_ctx) {
            _ctx = util.getContext();
        }
        var gradient = _ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);
        for (var i = 0, l = colorList.length; i < l; i++) {
            gradient.addColorStop(colorList[i][0], colorList[i][1]);
        }
        gradient.__nonRecursion = true;
        return gradient;
    }
    function getLinearGradient(x0, y0, x1, y1, colorList) {
        if (!_ctx) {
            _ctx = util.getContext();
        }
        var gradient = _ctx.createLinearGradient(x0, y0, x1, y1);
        for (var i = 0, l = colorList.length; i < l; i++) {
            gradient.addColorStop(colorList[i][0], colorList[i][1]);
        }
        gradient.__nonRecursion = true;
        return gradient;
    }
    function getStepColors(start, end, step) {
        start = toRGBA(start);
        end = toRGBA(end);
        start = getData(start);
        end = getData(end);
        var colors = [];
        var stepR = (end[0] - start[0]) / step;
        var stepG = (end[1] - start[1]) / step;
        var stepB = (end[2] - start[2]) / step;
        var stepA = (end[3] - start[3]) / step;
        for (var i = 0, r = start[0], g = start[1], b = start[2], a = start[3]; i < step; i++) {
            colors[i] = toColor([
                adjust(Math.floor(r), [
                    0,
                    255
                ]),
                adjust(Math.floor(g), [
                    0,
                    255
                ]),
                adjust(Math.floor(b), [
                    0,
                    255
                ]),
                a.toFixed(4) - 0
            ], 'rgba');
            r += stepR;
            g += stepG;
            b += stepB;
            a += stepA;
        }
        r = end[0];
        g = end[1];
        b = end[2];
        a = end[3];
        colors[i] = toColor([
            r,
            g,
            b,
            a
        ], 'rgba');
        return colors;
    }
    function getGradientColors(colors, step) {
        var ret = [];
        var len = colors.length;
        if (step === undefined) {
            step = 20;
        }
        if (len === 1) {
            ret = getStepColors(colors[0], colors[0], step);
        } else if (len > 1) {
            for (var i = 0, n = len - 1; i < n; i++) {
                var steps = getStepColors(colors[i], colors[i + 1], step);
                if (i < n - 1) {
                    steps.pop();
                }
                ret = ret.concat(steps);
            }
        }
        return ret;
    }
    function toColor(data, format) {
        format = format || 'rgb';
        if (data && (data.length === 3 || data.length === 4)) {
            data = map(data, function (c) {
                return c > 1 ? Math.ceil(c) : c;
            });
            if (format.indexOf('hex') > -1) {
                return '#' + ((1 << 24) + (data[0] << 16) + (data[1] << 8) + +data[2]).toString(16).slice(1);
            } else if (format.indexOf('hs') > -1) {
                var sx = map(data.slice(1, 3), function (c) {
                    return c + '%';
                });
                data[1] = sx[0];
                data[2] = sx[1];
            }
            if (format.indexOf('a') > -1) {
                if (data.length === 3) {
                    data.push(1);
                }
                data[3] = adjust(data[3], [
                    0,
                    1
                ]);
                return format + '(' + data.slice(0, 4).join(',') + ')';
            }
            return format + '(' + data.slice(0, 3).join(',') + ')';
        }
    }
    function toArray(color) {
        color = trim(color);
        if (color.indexOf('rgba') < 0) {
            color = toRGBA(color);
        }
        var data = [];
        var i = 0;
        color.replace(/[\d.]+/g, function (n) {
            if (i < 3) {
                n = n | 0;
            } else {
                n = +n;
            }
            data[i++] = n;
        });
        return data;
    }
    function convert(color, format) {
        if (!isCalculableColor(color)) {
            return color;
        }
        var data = getData(color);
        var alpha = data[3];
        if (typeof alpha === 'undefined') {
            alpha = 1;
        }
        if (color.indexOf('hsb') > -1) {
            data = _HSV_2_RGB(data);
        } else if (color.indexOf('hsl') > -1) {
            data = _HSL_2_RGB(data);
        }
        if (format.indexOf('hsb') > -1 || format.indexOf('hsv') > -1) {
            data = _RGB_2_HSB(data);
        } else if (format.indexOf('hsl') > -1) {
            data = _RGB_2_HSL(data);
        }
        data[3] = alpha;
        return toColor(data, format);
    }
    function toRGBA(color) {
        return convert(color, 'rgba');
    }
    function toRGB(color) {
        return convert(color, 'rgb');
    }
    function toHex(color) {
        return convert(color, 'hex');
    }
    function toHSVA(color) {
        return convert(color, 'hsva');
    }
    function toHSV(color) {
        return convert(color, 'hsv');
    }
    function toHSBA(color) {
        return convert(color, 'hsba');
    }
    function toHSB(color) {
        return convert(color, 'hsb');
    }
    function toHSLA(color) {
        return convert(color, 'hsla');
    }
    function toHSL(color) {
        return convert(color, 'hsl');
    }
    function toName(color) {
        for (var key in _nameColors) {
            if (toHex(_nameColors[key]) === toHex(color)) {
                return key;
            }
        }
        return null;
    }
    function trim(color) {
        return String(color).replace(/\s+/g, '');
    }
    function normalize(color) {
        if (_nameColors[color]) {
            color = _nameColors[color];
        }
        color = trim(color);
        color = color.replace(/hsv/i, 'hsb');
        if (/^#[\da-f]{3}$/i.test(color)) {
            color = parseInt(color.slice(1), 16);
            var r = (color & 3840) << 8;
            var g = (color & 240) << 4;
            var b = color & 15;
            color = '#' + ((1 << 24) + (r << 4) + r + (g << 4) + g + (b << 4) + b).toString(16).slice(1);
        }
        return color;
    }
    function lift(color, level) {
        if (!isCalculableColor(color)) {
            return color;
        }
        var direct = level > 0 ? 1 : -1;
        if (typeof level === 'undefined') {
            level = 0;
        }
        level = Math.abs(level) > 1 ? 1 : Math.abs(level);
        color = toRGB(color);
        var data = getData(color);
        for (var i = 0; i < 3; i++) {
            if (direct === 1) {
                data[i] = data[i] * (1 - level) | 0;
            } else {
                data[i] = (255 - data[i]) * level + data[i] | 0;
            }
        }
        return 'rgb(' + data.join(',') + ')';
    }
    function reverse(color) {
        if (!isCalculableColor(color)) {
            return color;
        }
        var data = getData(toRGBA(color));
        data = map(data, function (c) {
            return 255 - c;
        });
        return toColor(data, 'rgb');
    }
    function mix(color1, color2, weight) {
        if (!isCalculableColor(color1) || !isCalculableColor(color2)) {
            return color1;
        }
        if (typeof weight === 'undefined') {
            weight = 0.5;
        }
        weight = 1 - adjust(weight, [
            0,
            1
        ]);
        var w = weight * 2 - 1;
        var data1 = getData(toRGBA(color1));
        var data2 = getData(toRGBA(color2));
        var d = data1[3] - data2[3];
        var weight1 = ((w * d === -1 ? w : (w + d) / (1 + w * d)) + 1) / 2;
        var weight2 = 1 - weight1;
        var data = [];
        for (var i = 0; i < 3; i++) {
            data[i] = data1[i] * weight1 + data2[i] * weight2;
        }
        var alpha = data1[3] * weight + data2[3] * (1 - weight);
        alpha = Math.max(0, Math.min(1, alpha));
        if (data1[3] === 1 && data2[3] === 1) {
            return toColor(data, 'rgb');
        }
        data[3] = alpha;
        return toColor(data, 'rgba');
    }
    function random() {
        return '#' + (Math.random().toString(16) + '0000').slice(2, 8);
    }
    function getData(color) {
        color = normalize(color);
        var r = color.match(colorRegExp);
        if (r === null) {
            throw new Error('The color format error');
        }
        var d;
        var a;
        var data = [];
        var rgb;
        if (r[2]) {
            d = r[2].replace('#', '').split('');
            rgb = [
                d[0] + d[1],
                d[2] + d[3],
                d[4] + d[5]
            ];
            data = map(rgb, function (c) {
                return adjust(parseInt(c, 16), [
                    0,
                    255
                ]);
            });
        } else if (r[4]) {
            var rgba = r[4].split(',');
            a = rgba[3];
            rgb = rgba.slice(0, 3);
            data = map(rgb, function (c) {
                c = Math.floor(c.indexOf('%') > 0 ? parseInt(c, 0) * 2.55 : c);
                return adjust(c, [
                    0,
                    255
                ]);
            });
            if (typeof a !== 'undefined') {
                data.push(adjust(parseFloat(a), [
                    0,
                    1
                ]));
            }
        } else if (r[5] || r[6]) {
            var hsxa = (r[5] || r[6]).split(',');
            var h = parseInt(hsxa[0], 0) / 360;
            var s = hsxa[1];
            var x = hsxa[2];
            a = hsxa[3];
            data = map([
                s,
                x
            ], function (c) {
                return adjust(parseFloat(c) / 100, [
                    0,
                    1
                ]);
            });
            data.unshift(h);
            if (typeof a !== 'undefined') {
                data.push(adjust(parseFloat(a), [
                    0,
                    1
                ]));
            }
        }
        return data;
    }
    function alpha(color, a) {
        if (!isCalculableColor(color)) {
            return color;
        }
        if (a === null) {
            a = 1;
        }
        var data = getData(toRGBA(color));
        data[3] = adjust(Number(a).toFixed(4), [
            0,
            1
        ]);
        return toColor(data, 'rgba');
    }
    function map(array, fun) {
        if (typeof fun !== 'function') {
            throw new TypeError();
        }
        var len = array ? array.length : 0;
        for (var i = 0; i < len; i++) {
            array[i] = fun(array[i]);
        }
        return array;
    }
    function adjust(value, region) {
        if (value <= region[0]) {
            value = region[0];
        } else if (value >= region[1]) {
            value = region[1];
        }
        return value;
    }
    function isCalculableColor(color) {
        return color instanceof Array || typeof color === 'string';
    }
    function _HSV_2_RGB(data) {
        var H = data[0];
        var S = data[1];
        var V = data[2];
        var R;
        var G;
        var B;
        if (S === 0) {
            R = V * 255;
            G = V * 255;
            B = V * 255;
        } else {
            var h = H * 6;
            if (h === 6) {
                h = 0;
            }
            var i = h | 0;
            var v1 = V * (1 - S);
            var v2 = V * (1 - S * (h - i));
            var v3 = V * (1 - S * (1 - (h - i)));
            var r = 0;
            var g = 0;
            var b = 0;
            if (i === 0) {
                r = V;
                g = v3;
                b = v1;
            } else if (i === 1) {
                r = v2;
                g = V;
                b = v1;
            } else if (i === 2) {
                r = v1;
                g = V;
                b = v3;
            } else if (i === 3) {
                r = v1;
                g = v2;
                b = V;
            } else if (i === 4) {
                r = v3;
                g = v1;
                b = V;
            } else {
                r = V;
                g = v1;
                b = v2;
            }
            R = r * 255;
            G = g * 255;
            B = b * 255;
        }
        return [
            R,
            G,
            B
        ];
    }
    function _HSL_2_RGB(data) {
        var H = data[0];
        var S = data[1];
        var L = data[2];
        var R;
        var G;
        var B;
        if (S === 0) {
            R = L * 255;
            G = L * 255;
            B = L * 255;
        } else {
            var v2;
            if (L < 0.5) {
                v2 = L * (1 + S);
            } else {
                v2 = L + S - S * L;
            }
            var v1 = 2 * L - v2;
            R = 255 * _HUE_2_RGB(v1, v2, H + 1 / 3);
            G = 255 * _HUE_2_RGB(v1, v2, H);
            B = 255 * _HUE_2_RGB(v1, v2, H - 1 / 3);
        }
        return [
            R,
            G,
            B
        ];
    }
    function _HUE_2_RGB(v1, v2, vH) {
        if (vH < 0) {
            vH += 1;
        }
        if (vH > 1) {
            vH -= 1;
        }
        if (6 * vH < 1) {
            return v1 + (v2 - v1) * 6 * vH;
        }
        if (2 * vH < 1) {
            return v2;
        }
        if (3 * vH < 2) {
            return v1 + (v2 - v1) * (2 / 3 - vH) * 6;
        }
        return v1;
    }
    function _RGB_2_HSB(data) {
        var R = data[0] / 255;
        var G = data[1] / 255;
        var B = data[2] / 255;
        var vMin = Math.min(R, G, B);
        var vMax = Math.max(R, G, B);
        var delta = vMax - vMin;
        var V = vMax;
        var H;
        var S;
        if (delta === 0) {
            H = 0;
            S = 0;
        } else {
            S = delta / vMax;
            var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
            var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
            var deltaB = ((vMax - B) / 6 + delta / 2) / delta;
            if (R === vMax) {
                H = deltaB - deltaG;
            } else if (G === vMax) {
                H = 1 / 3 + deltaR - deltaB;
            } else if (B === vMax) {
                H = 2 / 3 + deltaG - deltaR;
            }
            if (H < 0) {
                H += 1;
            }
            if (H > 1) {
                H -= 1;
            }
        }
        H = H * 360;
        S = S * 100;
        V = V * 100;
        return [
            H,
            S,
            V
        ];
    }
    function _RGB_2_HSL(data) {
        var R = data[0] / 255;
        var G = data[1] / 255;
        var B = data[2] / 255;
        var vMin = Math.min(R, G, B);
        var vMax = Math.max(R, G, B);
        var delta = vMax - vMin;
        var L = (vMax + vMin) / 2;
        var H;
        var S;
        if (delta === 0) {
            H = 0;
            S = 0;
        } else {
            if (L < 0.5) {
                S = delta / (vMax + vMin);
            } else {
                S = delta / (2 - vMax - vMin);
            }
            var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
            var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
            var deltaB = ((vMax - B) / 6 + delta / 2) / delta;
            if (R === vMax) {
                H = deltaB - deltaG;
            } else if (G === vMax) {
                H = 1 / 3 + deltaR - deltaB;
            } else if (B === vMax) {
                H = 2 / 3 + deltaG - deltaR;
            }
            if (H < 0) {
                H += 1;
            }
            if (H > 1) {
                H -= 1;
            }
        }
        H = H * 360;
        S = S * 100;
        L = L * 100;
        return [
            H,
            S,
            L
        ];
    }
    return {
        customPalette: customPalette,
        resetPalette: resetPalette,
        getColor: getColor,
        getHighlightColor: getHighlightColor,
        customHighlight: customHighlight,
        resetHighlight: resetHighlight,
        getRadialGradient: getRadialGradient,
        getLinearGradient: getLinearGradient,
        getGradientColors: getGradientColors,
        getStepColors: getStepColors,
        reverse: reverse,
        mix: mix,
        lift: lift,
        trim: trim,
        random: random,
        toRGB: toRGB,
        toRGBA: toRGBA,
        toHex: toHex,
        toHSL: toHSL,
        toHSLA: toHSLA,
        toHSB: toHSB,
        toHSBA: toHSBA,
        toHSV: toHSV,
        toHSVA: toHSVA,
        toName: toName,
        toColor: toColor,
        toArray: toArray,
        alpha: alpha,
        getData: getData
    };
});define('echarts/component/timeline', [
    'require',
    './base',
    'zrender/shape/Rectangle',
    '../util/shape/Icon',
    '../util/shape/Chain',
    '../config',
    'zrender/tool/util',
    'zrender/tool/area',
    'zrender/tool/event',
    '../component'
], function (require) {
    var Base = require('./base');
    var RectangleShape = require('zrender/shape/Rectangle');
    var IconShape = require('../util/shape/Icon');
    var ChainShape = require('../util/shape/Chain');
    var ecConfig = require('../config');
    ecConfig.timeline = {
        zlevel: 0,
        z: 4,
        show: true,
        type: 'time',
        notMerge: false,
        realtime: true,
        x: 80,
        x2: 80,
        y2: 0,
        height: 50,
        backgroundColor: 'rgba(0,0,0,0)',
        borderColor: '#ccc',
        borderWidth: 0,
        padding: 5,
        controlPosition: 'left',
        autoPlay: false,
        loop: true,
        playInterval: 2000,
        lineStyle: {
            width: 1,
            color: '#666',
            type: 'dashed'
        },
        label: {
            show: true,
            interval: 'auto',
            rotate: 0,
            textStyle: { color: '#333' }
        },
        checkpointStyle: {
            symbol: 'auto',
            symbolSize: 'auto',
            color: 'auto',
            borderColor: 'auto',
            borderWidth: 'auto',
            label: {
                show: false,
                textStyle: { color: 'auto' }
            }
        },
        controlStyle: {
            itemSize: 15,
            itemGap: 5,
            normal: { color: '#333' },
            emphasis: { color: '#1e90ff' }
        },
        symbol: 'emptyDiamond',
        symbolSize: 4,
        currentIndex: 0
    };
    var zrUtil = require('zrender/tool/util');
    var zrArea = require('zrender/tool/area');
    var zrEvent = require('zrender/tool/event');
    function Timeline(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        var self = this;
        self._onclick = function (param) {
            return self.__onclick(param);
        };
        self._ondrift = function (dx, dy) {
            return self.__ondrift(this, dx, dy);
        };
        self._ondragend = function () {
            return self.__ondragend();
        };
        self._setCurrentOption = function () {
            var timelineOption = self.timelineOption;
            self.currentIndex %= timelineOption.data.length;
            var curOption = self.options[self.currentIndex] || {};
            self.myChart.setOption(curOption, timelineOption.notMerge);
            self.messageCenter.dispatch(ecConfig.EVENT.TIMELINE_CHANGED, null, {
                currentIndex: self.currentIndex,
                data: timelineOption.data[self.currentIndex].name != null ? timelineOption.data[self.currentIndex].name : timelineOption.data[self.currentIndex]
            }, self.myChart);
        };
        self._onFrame = function () {
            self._setCurrentOption();
            self._syncHandleShape();
            if (self.timelineOption.autoPlay) {
                self.playTicket = setTimeout(function () {
                    self.currentIndex += 1;
                    if (!self.timelineOption.loop && self.currentIndex >= self.timelineOption.data.length) {
                        self.currentIndex = self.timelineOption.data.length - 1;
                        self.stop();
                        return;
                    }
                    self._onFrame();
                }, self.timelineOption.playInterval);
            }
        };
        this.setTheme(false);
        this.options = this.option.options;
        this.currentIndex = this.timelineOption.currentIndex % this.timelineOption.data.length;
        if (!this.timelineOption.notMerge && this.currentIndex !== 0) {
            this.options[this.currentIndex] = zrUtil.merge(this.options[this.currentIndex], this.options[0]);
        }
        if (this.timelineOption.show) {
            this._buildShape();
            this._syncHandleShape();
        }
        this._setCurrentOption();
        if (this.timelineOption.autoPlay) {
            var self = this;
            this.playTicket = setTimeout(function () {
                self.play();
            }, this.ecTheme.animationDuration != null ? this.ecTheme.animationDuration : ecConfig.animationDuration);
        }
    }
    Timeline.prototype = {
        type: ecConfig.COMPONENT_TYPE_TIMELINE,
        _buildShape: function () {
            this._location = this._getLocation();
            this._buildBackground();
            this._buildControl();
            this._chainPoint = this._getChainPoint();
            if (this.timelineOption.label.show) {
                var interval = this._getInterval();
                for (var i = 0, len = this._chainPoint.length; i < len; i += interval) {
                    this._chainPoint[i].showLabel = true;
                }
            }
            this._buildChain();
            this._buildHandle();
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                this.zr.addShape(this.shapeList[i]);
            }
        },
        _getLocation: function () {
            var timelineOption = this.timelineOption;
            var padding = this.reformCssArray(this.timelineOption.padding);
            var zrWidth = this.zr.getWidth();
            var x = this.parsePercent(timelineOption.x, zrWidth);
            var x2 = this.parsePercent(timelineOption.x2, zrWidth);
            var width;
            if (timelineOption.width == null) {
                width = zrWidth - x - x2;
                x2 = zrWidth - x2;
            } else {
                width = this.parsePercent(timelineOption.width, zrWidth);
                x2 = x + width;
            }
            var zrHeight = this.zr.getHeight();
            var height = this.parsePercent(timelineOption.height, zrHeight);
            var y;
            var y2;
            if (timelineOption.y != null) {
                y = this.parsePercent(timelineOption.y, zrHeight);
                y2 = y + height;
            } else {
                y2 = zrHeight - this.parsePercent(timelineOption.y2, zrHeight);
                y = y2 - height;
            }
            return {
                x: x + padding[3],
                y: y + padding[0],
                x2: x2 - padding[1],
                y2: y2 - padding[2],
                width: width - padding[1] - padding[3],
                height: height - padding[0] - padding[2]
            };
        },
        _getReformedLabel: function (idx) {
            var timelineOption = this.timelineOption;
            var data = timelineOption.data[idx].name != null ? timelineOption.data[idx].name : timelineOption.data[idx];
            var formatter = timelineOption.data[idx].formatter || timelineOption.label.formatter;
            if (formatter) {
                if (typeof formatter === 'function') {
                    data = formatter.call(this.myChart, data);
                } else if (typeof formatter === 'string') {
                    data = formatter.replace('{value}', data);
                }
            }
            return data;
        },
        _getInterval: function () {
            var chainPoint = this._chainPoint;
            var timelineOption = this.timelineOption;
            var interval = timelineOption.label.interval;
            if (interval === 'auto') {
                var fontSize = timelineOption.label.textStyle.fontSize;
                var data = timelineOption.data;
                var dataLength = timelineOption.data.length;
                if (dataLength > 3) {
                    var isEnough = false;
                    var labelSpace;
                    var labelSize;
                    interval = 0;
                    while (!isEnough && interval < dataLength) {
                        interval++;
                        isEnough = true;
                        for (var i = interval; i < dataLength; i += interval) {
                            labelSpace = chainPoint[i].x - chainPoint[i - interval].x;
                            if (timelineOption.label.rotate !== 0) {
                                labelSize = fontSize;
                            } else if (data[i].textStyle) {
                                labelSize = zrArea.getTextWidth(chainPoint[i].name, chainPoint[i].textFont);
                            } else {
                                var label = chainPoint[i].name + '';
                                var wLen = (label.match(/\w/g) || '').length;
                                var oLen = label.length - wLen;
                                labelSize = wLen * fontSize * 2 / 3 + oLen * fontSize;
                            }
                            if (labelSpace < labelSize) {
                                isEnough = false;
                                break;
                            }
                        }
                    }
                } else {
                    interval = 1;
                }
            } else {
                interval = interval - 0 + 1;
            }
            return interval;
        },
        _getChainPoint: function () {
            var timelineOption = this.timelineOption;
            var symbol = timelineOption.symbol.toLowerCase();
            var symbolSize = timelineOption.symbolSize;
            var rotate = timelineOption.label.rotate;
            var textStyle = timelineOption.label.textStyle;
            var textFont = this.getFont(textStyle);
            var dataTextStyle;
            var data = timelineOption.data;
            var x = this._location.x;
            var y = this._location.y + this._location.height / 4 * 3;
            var width = this._location.x2 - this._location.x;
            var len = data.length;
            function _getName(i) {
                return data[i].name != null ? data[i].name : data[i] + '';
            }
            var xList = [];
            if (len > 1) {
                var boundaryGap = width / len;
                boundaryGap = boundaryGap > 50 ? 50 : boundaryGap < 20 ? 5 : boundaryGap;
                width -= boundaryGap * 2;
                if (timelineOption.type === 'number') {
                    for (var i = 0; i < len; i++) {
                        xList.push(x + boundaryGap + width / (len - 1) * i);
                    }
                } else {
                    xList[0] = new Date(_getName(0).replace(/-/g, '/'));
                    xList[len - 1] = new Date(_getName(len - 1).replace(/-/g, '/')) - xList[0];
                    for (var i = 1; i < len; i++) {
                        xList[i] = x + boundaryGap + width * (new Date(_getName(i).replace(/-/g, '/')) - xList[0]) / xList[len - 1];
                    }
                    xList[0] = x + boundaryGap;
                }
            } else {
                xList.push(x + width / 2);
            }
            var list = [];
            var curSymbol;
            var n;
            var isEmpty;
            var textAlign;
            var rotation;
            for (var i = 0; i < len; i++) {
                x = xList[i];
                curSymbol = data[i].symbol && data[i].symbol.toLowerCase() || symbol;
                if (curSymbol.match('empty')) {
                    curSymbol = curSymbol.replace('empty', '');
                    isEmpty = true;
                } else {
                    isEmpty = false;
                }
                if (curSymbol.match('star')) {
                    n = curSymbol.replace('star', '') - 0 || 5;
                    curSymbol = 'star';
                }
                dataTextStyle = data[i].textStyle ? zrUtil.merge(data[i].textStyle || {}, textStyle) : textStyle;
                textAlign = dataTextStyle.align || 'center';
                if (rotate) {
                    textAlign = rotate > 0 ? 'right' : 'left';
                    rotation = [
                        rotate * Math.PI / 180,
                        x,
                        y - 5
                    ];
                } else {
                    rotation = false;
                }
                list.push({
                    x: x,
                    n: n,
                    isEmpty: isEmpty,
                    symbol: curSymbol,
                    symbolSize: data[i].symbolSize || symbolSize,
                    color: data[i].color,
                    borderColor: data[i].borderColor,
                    borderWidth: data[i].borderWidth,
                    name: this._getReformedLabel(i),
                    textColor: dataTextStyle.color,
                    textAlign: textAlign,
                    textBaseline: dataTextStyle.baseline || 'middle',
                    textX: x,
                    textY: y - (rotate ? 5 : 0),
                    textFont: data[i].textStyle ? this.getFont(dataTextStyle) : textFont,
                    rotation: rotation,
                    showLabel: false
                });
            }
            return list;
        },
        _buildBackground: function () {
            var timelineOption = this.timelineOption;
            var padding = this.reformCssArray(this.timelineOption.padding);
            var width = this._location.width;
            var height = this._location.height;
            if (timelineOption.borderWidth !== 0 || timelineOption.backgroundColor.replace(/\s/g, '') != 'rgba(0,0,0,0)') {
                this.shapeList.push(new RectangleShape({
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    hoverable: false,
                    style: {
                        x: this._location.x - padding[3],
                        y: this._location.y - padding[0],
                        width: width + padding[1] + padding[3],
                        height: height + padding[0] + padding[2],
                        brushType: timelineOption.borderWidth === 0 ? 'fill' : 'both',
                        color: timelineOption.backgroundColor,
                        strokeColor: timelineOption.borderColor,
                        lineWidth: timelineOption.borderWidth
                    }
                }));
            }
        },
        _buildControl: function () {
            var self = this;
            var timelineOption = this.timelineOption;
            var lineStyle = timelineOption.lineStyle;
            var controlStyle = timelineOption.controlStyle;
            if (timelineOption.controlPosition === 'none') {
                return;
            }
            var iconSize = controlStyle.itemSize;
            var iconGap = controlStyle.itemGap;
            var x;
            if (timelineOption.controlPosition === 'left') {
                x = this._location.x;
                this._location.x += (iconSize + iconGap) * 3;
            } else {
                x = this._location.x2 - ((iconSize + iconGap) * 3 - iconGap);
                this._location.x2 -= (iconSize + iconGap) * 3;
            }
            var y = this._location.y;
            var iconStyle = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase() + 1,
                style: {
                    iconType: 'timelineControl',
                    symbol: 'last',
                    x: x,
                    y: y,
                    width: iconSize,
                    height: iconSize,
                    brushType: 'stroke',
                    color: controlStyle.normal.color,
                    strokeColor: controlStyle.normal.color,
                    lineWidth: lineStyle.width
                },
                highlightStyle: {
                    color: controlStyle.emphasis.color,
                    strokeColor: controlStyle.emphasis.color,
                    lineWidth: lineStyle.width + 1
                },
                clickable: true
            };
            this._ctrLastShape = new IconShape(iconStyle);
            this._ctrLastShape.onclick = function () {
                self.last();
            };
            this.shapeList.push(this._ctrLastShape);
            x += iconSize + iconGap;
            this._ctrPlayShape = new IconShape(zrUtil.clone(iconStyle));
            this._ctrPlayShape.style.brushType = 'fill';
            this._ctrPlayShape.style.symbol = 'play';
            this._ctrPlayShape.style.status = this.timelineOption.autoPlay ? 'playing' : 'stop';
            this._ctrPlayShape.style.x = x;
            this._ctrPlayShape.onclick = function () {
                if (self._ctrPlayShape.style.status === 'stop') {
                    self.play();
                } else {
                    self.stop();
                }
            };
            this.shapeList.push(this._ctrPlayShape);
            x += iconSize + iconGap;
            this._ctrNextShape = new IconShape(zrUtil.clone(iconStyle));
            this._ctrNextShape.style.symbol = 'next';
            this._ctrNextShape.style.x = x;
            this._ctrNextShape.onclick = function () {
                self.next();
            };
            this.shapeList.push(this._ctrNextShape);
        },
        _buildChain: function () {
            var timelineOption = this.timelineOption;
            var lineStyle = timelineOption.lineStyle;
            this._timelineShae = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                style: {
                    x: this._location.x,
                    y: this.subPixelOptimize(this._location.y, lineStyle.width),
                    width: this._location.x2 - this._location.x,
                    height: this._location.height,
                    chainPoint: this._chainPoint,
                    brushType: 'both',
                    strokeColor: lineStyle.color,
                    lineWidth: lineStyle.width,
                    lineType: lineStyle.type
                },
                hoverable: false,
                clickable: true,
                onclick: this._onclick
            };
            this._timelineShae = new ChainShape(this._timelineShae);
            this.shapeList.push(this._timelineShae);
        },
        _buildHandle: function () {
            var curPoint = this._chainPoint[this.currentIndex];
            var symbolSize = curPoint.symbolSize + 1;
            symbolSize = symbolSize < 5 ? 5 : symbolSize;
            this._handleShape = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase() + 1,
                hoverable: false,
                draggable: true,
                style: {
                    iconType: 'diamond',
                    n: curPoint.n,
                    x: curPoint.x - symbolSize,
                    y: this._location.y + this._location.height / 4 - symbolSize,
                    width: symbolSize * 2,
                    height: symbolSize * 2,
                    brushType: 'both',
                    textPosition: 'specific',
                    textX: curPoint.x,
                    textY: this._location.y - this._location.height / 4,
                    textAlign: 'center',
                    textBaseline: 'middle'
                },
                highlightStyle: {},
                ondrift: this._ondrift,
                ondragend: this._ondragend
            };
            this._handleShape = new IconShape(this._handleShape);
            this.shapeList.push(this._handleShape);
        },
        _syncHandleShape: function () {
            if (!this.timelineOption.show) {
                return;
            }
            var timelineOption = this.timelineOption;
            var cpStyle = timelineOption.checkpointStyle;
            var curPoint = this._chainPoint[this.currentIndex];
            this._handleShape.style.text = cpStyle.label.show ? curPoint.name : '';
            this._handleShape.style.textFont = curPoint.textFont;
            this._handleShape.style.n = curPoint.n;
            if (cpStyle.symbol === 'auto') {
                this._handleShape.style.iconType = curPoint.symbol != 'none' ? curPoint.symbol : 'diamond';
            } else {
                this._handleShape.style.iconType = cpStyle.symbol;
                if (cpStyle.symbol.match('star')) {
                    this._handleShape.style.n = cpStyle.symbol.replace('star', '') - 0 || 5;
                    this._handleShape.style.iconType = 'star';
                }
            }
            var symbolSize;
            if (cpStyle.symbolSize === 'auto') {
                symbolSize = curPoint.symbolSize + 2;
                symbolSize = symbolSize < 5 ? 5 : symbolSize;
            } else {
                symbolSize = cpStyle.symbolSize - 0;
            }
            this._handleShape.style.color = cpStyle.color === 'auto' ? curPoint.color ? curPoint.color : timelineOption.controlStyle.emphasis.color : cpStyle.color;
            this._handleShape.style.textColor = cpStyle.label.textStyle.color === 'auto' ? this._handleShape.style.color : cpStyle.label.textStyle.color;
            this._handleShape.highlightStyle.strokeColor = this._handleShape.style.strokeColor = cpStyle.borderColor === 'auto' ? curPoint.borderColor ? curPoint.borderColor : '#fff' : cpStyle.borderColor;
            this._handleShape.style.lineWidth = cpStyle.borderWidth === 'auto' ? curPoint.borderWidth ? curPoint.borderWidth : 0 : cpStyle.borderWidth - 0;
            this._handleShape.highlightStyle.lineWidth = this._handleShape.style.lineWidth + 1;
            this.zr.animate(this._handleShape.id, 'style').when(500, {
                x: curPoint.x - symbolSize,
                textX: curPoint.x,
                y: this._location.y + this._location.height / 4 - symbolSize,
                width: symbolSize * 2,
                height: symbolSize * 2
            }).start('ExponentialOut');
        },
        _findChainIndex: function (x) {
            var chainPoint = this._chainPoint;
            var len = chainPoint.length;
            if (x <= chainPoint[0].x) {
                return 0;
            } else if (x >= chainPoint[len - 1].x) {
                return len - 1;
            }
            for (var i = 0; i < len - 1; i++) {
                if (x >= chainPoint[i].x && x <= chainPoint[i + 1].x) {
                    return Math.abs(x - chainPoint[i].x) < Math.abs(x - chainPoint[i + 1].x) ? i : i + 1;
                }
            }
        },
        __onclick: function (param) {
            var x = zrEvent.getX(param.event);
            var newIndex = this._findChainIndex(x);
            if (newIndex === this.currentIndex) {
                return true;
            }
            this.currentIndex = newIndex;
            this.timelineOption.autoPlay && this.stop();
            clearTimeout(this.playTicket);
            this._onFrame();
        },
        __ondrift: function (shape, dx) {
            this.timelineOption.autoPlay && this.stop();
            var chainPoint = this._chainPoint;
            var len = chainPoint.length;
            var newIndex;
            if (shape.style.x + dx <= chainPoint[0].x - chainPoint[0].symbolSize) {
                shape.style.x = chainPoint[0].x - chainPoint[0].symbolSize;
                newIndex = 0;
            } else if (shape.style.x + dx >= chainPoint[len - 1].x - chainPoint[len - 1].symbolSize) {
                shape.style.x = chainPoint[len - 1].x - chainPoint[len - 1].symbolSize;
                newIndex = len - 1;
            } else {
                shape.style.x += dx;
                newIndex = this._findChainIndex(shape.style.x);
            }
            var curPoint = chainPoint[newIndex];
            var symbolSize = curPoint.symbolSize + 2;
            shape.style.iconType = curPoint.symbol;
            shape.style.n = curPoint.n;
            shape.style.textX = shape.style.x + symbolSize / 2;
            shape.style.y = this._location.y + this._location.height / 4 - symbolSize;
            shape.style.width = symbolSize * 2;
            shape.style.height = symbolSize * 2;
            shape.style.text = curPoint.name;
            if (newIndex === this.currentIndex) {
                return true;
            }
            this.currentIndex = newIndex;
            if (this.timelineOption.realtime) {
                clearTimeout(this.playTicket);
                var self = this;
                this.playTicket = setTimeout(function () {
                    self._setCurrentOption();
                }, 200);
            }
            return true;
        },
        __ondragend: function () {
            this.isDragend = true;
        },
        ondragend: function (param, status) {
            if (!this.isDragend || !param.target) {
                return;
            }
            !this.timelineOption.realtime && this._setCurrentOption();
            status.dragOut = true;
            status.dragIn = true;
            status.needRefresh = false;
            this.isDragend = false;
            this._syncHandleShape();
            return;
        },
        last: function () {
            this.timelineOption.autoPlay && this.stop();
            this.currentIndex -= 1;
            if (this.currentIndex < 0) {
                this.currentIndex = this.timelineOption.data.length - 1;
            }
            this._onFrame();
            return this.currentIndex;
        },
        next: function () {
            this.timelineOption.autoPlay && this.stop();
            this.currentIndex += 1;
            if (this.currentIndex >= this.timelineOption.data.length) {
                this.currentIndex = 0;
            }
            this._onFrame();
            return this.currentIndex;
        },
        play: function (targetIndex, autoPlay) {
            if (this._ctrPlayShape && this._ctrPlayShape.style.status != 'playing') {
                this._ctrPlayShape.style.status = 'playing';
                this.zr.modShape(this._ctrPlayShape.id);
                this.zr.refreshNextFrame();
            }
            this.timelineOption.autoPlay = autoPlay != null ? autoPlay : true;
            if (!this.timelineOption.autoPlay) {
                clearTimeout(this.playTicket);
            }
            this.currentIndex = targetIndex != null ? targetIndex : this.currentIndex + 1;
            if (this.currentIndex >= this.timelineOption.data.length) {
                this.currentIndex = 0;
            }
            this._onFrame();
            return this.currentIndex;
        },
        stop: function () {
            if (this._ctrPlayShape && this._ctrPlayShape.style.status != 'stop') {
                this._ctrPlayShape.style.status = 'stop';
                this.zr.modShape(this._ctrPlayShape.id);
                this.zr.refreshNextFrame();
            }
            this.timelineOption.autoPlay = false;
            clearTimeout(this.playTicket);
            return this.currentIndex;
        },
        resize: function () {
            if (this.timelineOption.show) {
                this.clear();
                this._buildShape();
                this._syncHandleShape();
            }
        },
        setTheme: function (needRefresh) {
            this.timelineOption = this.reformOption(zrUtil.clone(this.option.timeline));
            this.timelineOption.label.textStyle = this.getTextStyle(this.timelineOption.label.textStyle);
            this.timelineOption.checkpointStyle.label.textStyle = this.getTextStyle(this.timelineOption.checkpointStyle.label.textStyle);
            if (!this.myChart.canvasSupported) {
                this.timelineOption.realtime = false;
            }
            if (this.timelineOption.show && needRefresh) {
                this.clear();
                this._buildShape();
                this._syncHandleShape();
            }
        },
        onbeforDispose: function () {
            clearTimeout(this.playTicket);
        }
    };
    function timelineControl(ctx, style) {
        var lineWidth = 2;
        var x = style.x + lineWidth;
        var y = style.y + lineWidth + 2;
        var width = style.width - lineWidth;
        var height = style.height - lineWidth;
        var symbol = style.symbol;
        if (symbol === 'last') {
            ctx.moveTo(x + width - 2, y + height / 3);
            ctx.lineTo(x + width - 2, y);
            ctx.lineTo(x + 2, y + height / 2);
            ctx.lineTo(x + width - 2, y + height);
            ctx.lineTo(x + width - 2, y + height / 3 * 2);
            ctx.moveTo(x, y);
            ctx.lineTo(x, y);
        } else if (symbol === 'next') {
            ctx.moveTo(x + 2, y + height / 3);
            ctx.lineTo(x + 2, y);
            ctx.lineTo(x + width - 2, y + height / 2);
            ctx.lineTo(x + 2, y + height);
            ctx.lineTo(x + 2, y + height / 3 * 2);
            ctx.moveTo(x, y);
            ctx.lineTo(x, y);
        } else if (symbol === 'play') {
            if (style.status === 'stop') {
                ctx.moveTo(x + 2, y);
                ctx.lineTo(x + width - 2, y + height / 2);
                ctx.lineTo(x + 2, y + height);
                ctx.lineTo(x + 2, y);
            } else {
                var delta = style.brushType === 'both' ? 2 : 3;
                ctx.rect(x + 2, y, delta, height);
                ctx.rect(x + width - delta - 2, y, delta, height);
            }
        } else if (symbol.match('image')) {
            var imageLocation = '';
            imageLocation = symbol.replace(new RegExp('^image:\\/\\/'), '');
            symbol = IconShape.prototype.iconLibrary.image;
            symbol(ctx, {
                x: x,
                y: y,
                width: width,
                height: height,
                image: imageLocation
            });
        }
    }
    IconShape.prototype.iconLibrary['timelineControl'] = timelineControl;
    zrUtil.inherits(Timeline, Base);
    require('../component').define('timeline', Timeline);
    return Timeline;
});define('zrender/shape/Image', [
    'require',
    './Base',
    '../tool/util'
], function (require) {
    var Base = require('./Base');
    var ZImage = function (options) {
        Base.call(this, options);
    };
    ZImage.prototype = {
        type: 'image',
        brush: function (ctx, isHighlight, refreshNextFrame) {
            var style = this.style || {};
            if (isHighlight) {
                style = this.getHighlightStyle(style, this.highlightStyle || {});
            }
            var image = style.image;
            var self = this;
            if (!this._imageCache) {
                this._imageCache = {};
            }
            if (typeof image === 'string') {
                var src = image;
                if (this._imageCache[src]) {
                    image = this._imageCache[src];
                } else {
                    image = new Image();
                    image.onload = function () {
                        image.onload = null;
                        self.modSelf();
                        refreshNextFrame();
                    };
                    image.src = src;
                    this._imageCache[src] = image;
                }
            }
            if (image) {
                if (image.nodeName.toUpperCase() == 'IMG') {
                    if (window.ActiveXObject) {
                        if (image.readyState != 'complete') {
                            return;
                        }
                    } else {
                        if (!image.complete) {
                            return;
                        }
                    }
                }
                var width = style.width || image.width;
                var height = style.height || image.height;
                var x = style.x;
                var y = style.y;
                if (!image.width || !image.height) {
                    return;
                }
                ctx.save();
                this.doClip(ctx);
                this.setContext(ctx, style);
                this.setTransform(ctx);
                if (style.sWidth && style.sHeight) {
                    var sx = style.sx || 0;
                    var sy = style.sy || 0;
                    ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
                } else if (style.sx && style.sy) {
                    var sx = style.sx;
                    var sy = style.sy;
                    var sWidth = width - sx;
                    var sHeight = height - sy;
                    ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
                } else {
                    ctx.drawImage(image, x, y, width, height);
                }
                if (!style.width) {
                    style.width = width;
                }
                if (!style.height) {
                    style.height = height;
                }
                if (!this.style.width) {
                    this.style.width = width;
                }
                if (!this.style.height) {
                    this.style.height = height;
                }
                this.drawText(ctx, style, this.style);
                ctx.restore();
            }
        },
        getRect: function (style) {
            return {
                x: style.x,
                y: style.y,
                width: style.width,
                height: style.height
            };
        },
        clearCache: function () {
            this._imageCache = {};
        }
    };
    require('../tool/util').inherits(ZImage, Base);
    return ZImage;
});define('zrender/loadingEffect/Bar', [
    'require',
    './Base',
    '../tool/util',
    '../tool/color',
    '../shape/Rectangle'
], function (require) {
    var Base = require('./Base');
    var util = require('../tool/util');
    var zrColor = require('../tool/color');
    var RectangleShape = require('../shape/Rectangle');
    function Bar(options) {
        Base.call(this, options);
    }
    util.inherits(Bar, Base);
    Bar.prototype._start = function (addShapeHandle, refreshHandle) {
        var options = util.merge(this.options, {
            textStyle: { color: '#888' },
            backgroundColor: 'rgba(250, 250, 250, 0.8)',
            effectOption: {
                x: 0,
                y: this.canvasHeight / 2 - 30,
                width: this.canvasWidth,
                height: 5,
                brushType: 'fill',
                timeInterval: 100
            }
        });
        var textShape = this.createTextShape(options.textStyle);
        var background = this.createBackgroundShape(options.backgroundColor);
        var effectOption = options.effectOption;
        var barShape = new RectangleShape({ highlightStyle: util.clone(effectOption) });
        barShape.highlightStyle.color = effectOption.color || zrColor.getLinearGradient(effectOption.x, effectOption.y, effectOption.x + effectOption.width, effectOption.y + effectOption.height, [
            [
                0,
                '#ff6400'
            ],
            [
                0.5,
                '#ffe100'
            ],
            [
                1,
                '#b1ff00'
            ]
        ]);
        if (options.progress != null) {
            addShapeHandle(background);
            barShape.highlightStyle.width = this.adjust(options.progress, [
                0,
                1
            ]) * options.effectOption.width;
            addShapeHandle(barShape);
            addShapeHandle(textShape);
            refreshHandle();
            return;
        } else {
            barShape.highlightStyle.width = 0;
            return setInterval(function () {
                addShapeHandle(background);
                if (barShape.highlightStyle.width < effectOption.width) {
                    barShape.highlightStyle.width += 8;
                } else {
                    barShape.highlightStyle.width = 0;
                }
                addShapeHandle(barShape);
                addShapeHandle(textShape);
                refreshHandle();
            }, effectOption.timeInterval);
        }
    };
    return Bar;
});define('zrender/loadingEffect/Bubble', [
    'require',
    './Base',
    '../tool/util',
    '../tool/color',
    '../shape/Circle'
], function (require) {
    var Base = require('./Base');
    var util = require('../tool/util');
    var zrColor = require('../tool/color');
    var CircleShape = require('../shape/Circle');
    function Bubble(options) {
        Base.call(this, options);
    }
    util.inherits(Bubble, Base);
    Bubble.prototype._start = function (addShapeHandle, refreshHandle) {
        var options = util.merge(this.options, {
            textStyle: { color: '#888' },
            backgroundColor: 'rgba(250, 250, 250, 0.8)',
            effect: {
                n: 50,
                lineWidth: 2,
                brushType: 'stroke',
                color: 'random',
                timeInterval: 100
            }
        });
        var textShape = this.createTextShape(options.textStyle);
        var background = this.createBackgroundShape(options.backgroundColor);
        var effectOption = options.effect;
        var n = effectOption.n;
        var brushType = effectOption.brushType;
        var lineWidth = effectOption.lineWidth;
        var shapeList = [];
        var canvasWidth = this.canvasWidth;
        var canvasHeight = this.canvasHeight;
        for (var i = 0; i < n; i++) {
            var color = effectOption.color == 'random' ? zrColor.alpha(zrColor.random(), 0.3) : effectOption.color;
            shapeList[i] = new CircleShape({
                highlightStyle: {
                    x: Math.ceil(Math.random() * canvasWidth),
                    y: Math.ceil(Math.random() * canvasHeight),
                    r: Math.ceil(Math.random() * 40),
                    brushType: brushType,
                    color: color,
                    strokeColor: color,
                    lineWidth: lineWidth
                },
                animationY: Math.ceil(Math.random() * 20)
            });
        }
        return setInterval(function () {
            addShapeHandle(background);
            for (var i = 0; i < n; i++) {
                var style = shapeList[i].highlightStyle;
                if (style.y - shapeList[i].animationY + style.r <= 0) {
                    shapeList[i].highlightStyle.y = canvasHeight + style.r;
                    shapeList[i].highlightStyle.x = Math.ceil(Math.random() * canvasWidth);
                }
                shapeList[i].highlightStyle.y -= shapeList[i].animationY;
                addShapeHandle(shapeList[i]);
            }
            addShapeHandle(textShape);
            refreshHandle();
        }, effectOption.timeInterval);
    };
    return Bubble;
});define('zrender/loadingEffect/DynamicLine', [
    'require',
    './Base',
    '../tool/util',
    '../tool/color',
    '../shape/Line'
], function (require) {
    var Base = require('./Base');
    var util = require('../tool/util');
    var zrColor = require('../tool/color');
    var LineShape = require('../shape/Line');
    function DynamicLine(options) {
        Base.call(this, options);
    }
    util.inherits(DynamicLine, Base);
    DynamicLine.prototype._start = function (addShapeHandle, refreshHandle) {
        var options = util.merge(this.options, {
            textStyle: { color: '#fff' },
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            effectOption: {
                n: 30,
                lineWidth: 1,
                color: 'random',
                timeInterval: 100
            }
        });
        var textShape = this.createTextShape(options.textStyle);
        var background = this.createBackgroundShape(options.backgroundColor);
        var effectOption = options.effectOption;
        var n = effectOption.n;
        var lineWidth = effectOption.lineWidth;
        var shapeList = [];
        var canvasWidth = this.canvasWidth;
        var canvasHeight = this.canvasHeight;
        for (var i = 0; i < n; i++) {
            var xStart = -Math.ceil(Math.random() * 1000);
            var len = Math.ceil(Math.random() * 400);
            var pos = Math.ceil(Math.random() * canvasHeight);
            var color = effectOption.color == 'random' ? zrColor.random() : effectOption.color;
            shapeList[i] = new LineShape({
                highlightStyle: {
                    xStart: xStart,
                    yStart: pos,
                    xEnd: xStart + len,
                    yEnd: pos,
                    strokeColor: color,
                    lineWidth: lineWidth
                },
                animationX: Math.ceil(Math.random() * 100),
                len: len
            });
        }
        return setInterval(function () {
            addShapeHandle(background);
            for (var i = 0; i < n; i++) {
                var style = shapeList[i].highlightStyle;
                if (style.xStart >= canvasWidth) {
                    shapeList[i].len = Math.ceil(Math.random() * 400);
                    style.xStart = -400;
                    style.xEnd = -400 + shapeList[i].len;
                    style.yStart = Math.ceil(Math.random() * canvasHeight);
                    style.yEnd = style.yStart;
                }
                style.xStart += shapeList[i].animationX;
                style.xEnd += shapeList[i].animationX;
                addShapeHandle(shapeList[i]);
            }
            addShapeHandle(textShape);
            refreshHandle();
        }, effectOption.timeInterval);
    };
    return DynamicLine;
});define('zrender/loadingEffect/Ring', [
    'require',
    './Base',
    '../tool/util',
    '../tool/color',
    '../shape/Ring',
    '../shape/Sector'
], function (require) {
    var Base = require('./Base');
    var util = require('../tool/util');
    var zrColor = require('../tool/color');
    var RingShape = require('../shape/Ring');
    var SectorShape = require('../shape/Sector');
    function Ring(options) {
        Base.call(this, options);
    }
    util.inherits(Ring, Base);
    Ring.prototype._start = function (addShapeHandle, refreshHandle) {
        var options = util.merge(this.options, {
            textStyle: { color: '#07a' },
            backgroundColor: 'rgba(250, 250, 250, 0.8)',
            effect: {
                x: this.canvasWidth / 2,
                y: this.canvasHeight / 2,
                r0: 60,
                r: 100,
                color: '#bbdcff',
                brushType: 'fill',
                textPosition: 'inside',
                textFont: 'normal 30px verdana',
                textColor: 'rgba(30, 144, 255, 0.6)',
                timeInterval: 100
            }
        });
        var effectOption = options.effect;
        var textStyle = options.textStyle;
        if (textStyle.x == null) {
            textStyle.x = effectOption.x;
        }
        if (textStyle.y == null) {
            textStyle.y = effectOption.y + (effectOption.r0 + effectOption.r) / 2 - 5;
        }
        var textShape = this.createTextShape(options.textStyle);
        var background = this.createBackgroundShape(options.backgroundColor);
        var x = effectOption.x;
        var y = effectOption.y;
        var r0 = effectOption.r0 + 6;
        var r = effectOption.r - 6;
        var color = effectOption.color;
        var darkColor = zrColor.lift(color, 0.1);
        var shapeRing = new RingShape({ highlightStyle: util.clone(effectOption) });
        var shapeList = [];
        var clolrList = zrColor.getGradientColors([
            '#ff6400',
            '#ffe100',
            '#97ff00'
        ], 25);
        var preAngle = 15;
        var endAngle = 240;
        for (var i = 0; i < 16; i++) {
            shapeList.push(new SectorShape({
                highlightStyle: {
                    x: x,
                    y: y,
                    r0: r0,
                    r: r,
                    startAngle: endAngle - preAngle,
                    endAngle: endAngle,
                    brushType: 'fill',
                    color: darkColor
                },
                _color: zrColor.getLinearGradient(x + r0 * Math.cos(endAngle, true), y - r0 * Math.sin(endAngle, true), x + r0 * Math.cos(endAngle - preAngle, true), y - r0 * Math.sin(endAngle - preAngle, true), [
                    [
                        0,
                        clolrList[i * 2]
                    ],
                    [
                        1,
                        clolrList[i * 2 + 1]
                    ]
                ])
            }));
            endAngle -= preAngle;
        }
        endAngle = 360;
        for (var i = 0; i < 4; i++) {
            shapeList.push(new SectorShape({
                highlightStyle: {
                    x: x,
                    y: y,
                    r0: r0,
                    r: r,
                    startAngle: endAngle - preAngle,
                    endAngle: endAngle,
                    brushType: 'fill',
                    color: darkColor
                },
                _color: zrColor.getLinearGradient(x + r0 * Math.cos(endAngle, true), y - r0 * Math.sin(endAngle, true), x + r0 * Math.cos(endAngle - preAngle, true), y - r0 * Math.sin(endAngle - preAngle, true), [
                    [
                        0,
                        clolrList[i * 2 + 32]
                    ],
                    [
                        1,
                        clolrList[i * 2 + 33]
                    ]
                ])
            }));
            endAngle -= preAngle;
        }
        var n = 0;
        if (options.progress != null) {
            addShapeHandle(background);
            n = this.adjust(options.progress, [
                0,
                1
            ]).toFixed(2) * 100 / 5;
            shapeRing.highlightStyle.text = n * 5 + '%';
            addShapeHandle(shapeRing);
            for (var i = 0; i < 20; i++) {
                shapeList[i].highlightStyle.color = i < n ? shapeList[i]._color : darkColor;
                addShapeHandle(shapeList[i]);
            }
            addShapeHandle(textShape);
            refreshHandle();
            return;
        }
        return setInterval(function () {
            addShapeHandle(background);
            n += n >= 20 ? -20 : 1;
            addShapeHandle(shapeRing);
            for (var i = 0; i < 20; i++) {
                shapeList[i].highlightStyle.color = i < n ? shapeList[i]._color : darkColor;
                addShapeHandle(shapeList[i]);
            }
            addShapeHandle(textShape);
            refreshHandle();
        }, effectOption.timeInterval);
    };
    return Ring;
});define('zrender/loadingEffect/Spin', [
    'require',
    './Base',
    '../tool/util',
    '../tool/color',
    '../tool/area',
    '../shape/Sector'
], function (require) {
    var Base = require('./Base');
    var util = require('../tool/util');
    var zrColor = require('../tool/color');
    var zrArea = require('../tool/area');
    var SectorShape = require('../shape/Sector');
    function Spin(options) {
        Base.call(this, options);
    }
    util.inherits(Spin, Base);
    Spin.prototype._start = function (addShapeHandle, refreshHandle) {
        var options = util.merge(this.options, {
            textStyle: {
                color: '#fff',
                textAlign: 'start'
            },
            backgroundColor: 'rgba(0, 0, 0, 0.8)'
        });
        var textShape = this.createTextShape(options.textStyle);
        var textGap = 10;
        var textWidth = zrArea.getTextWidth(textShape.highlightStyle.text, textShape.highlightStyle.textFont);
        var textHeight = zrArea.getTextHeight(textShape.highlightStyle.text, textShape.highlightStyle.textFont);
        var effectOption = util.merge(this.options.effect || {}, {
            r0: 9,
            r: 15,
            n: 18,
            color: '#fff',
            timeInterval: 100
        });
        var location = this.getLocation(this.options.textStyle, textWidth + textGap + effectOption.r * 2, Math.max(effectOption.r * 2, textHeight));
        effectOption.x = location.x + effectOption.r;
        effectOption.y = textShape.highlightStyle.y = location.y + location.height / 2;
        textShape.highlightStyle.x = effectOption.x + effectOption.r + textGap;
        var background = this.createBackgroundShape(options.backgroundColor);
        var n = effectOption.n;
        var x = effectOption.x;
        var y = effectOption.y;
        var r0 = effectOption.r0;
        var r = effectOption.r;
        var color = effectOption.color;
        var shapeList = [];
        var preAngle = Math.round(180 / n);
        for (var i = 0; i < n; i++) {
            shapeList[i] = new SectorShape({
                highlightStyle: {
                    x: x,
                    y: y,
                    r0: r0,
                    r: r,
                    startAngle: preAngle * i * 2,
                    endAngle: preAngle * i * 2 + preAngle,
                    color: zrColor.alpha(color, (i + 1) / n),
                    brushType: 'fill'
                }
            });
        }
        var pos = [
            0,
            x,
            y
        ];
        return setInterval(function () {
            addShapeHandle(background);
            pos[0] -= 0.3;
            for (var i = 0; i < n; i++) {
                shapeList[i].rotation = pos;
                addShapeHandle(shapeList[i]);
            }
            addShapeHandle(textShape);
            refreshHandle();
        }, effectOption.timeInterval);
    };
    return Spin;
});define('zrender/loadingEffect/Whirling', [
    'require',
    './Base',
    '../tool/util',
    '../tool/area',
    '../shape/Ring',
    '../shape/Droplet',
    '../shape/Circle'
], function (require) {
    var Base = require('./Base');
    var util = require('../tool/util');
    var zrArea = require('../tool/area');
    var RingShape = require('../shape/Ring');
    var DropletShape = require('../shape/Droplet');
    var CircleShape = require('../shape/Circle');
    function Whirling(options) {
        Base.call(this, options);
    }
    util.inherits(Whirling, Base);
    Whirling.prototype._start = function (addShapeHandle, refreshHandle) {
        var options = util.merge(this.options, {
            textStyle: {
                color: '#888',
                textAlign: 'start'
            },
            backgroundColor: 'rgba(250, 250, 250, 0.8)'
        });
        var textShape = this.createTextShape(options.textStyle);
        var textGap = 10;
        var textWidth = zrArea.getTextWidth(textShape.highlightStyle.text, textShape.highlightStyle.textFont);
        var textHeight = zrArea.getTextHeight(textShape.highlightStyle.text, textShape.highlightStyle.textFont);
        var effectOption = util.merge(this.options.effect || {}, {
            r: 18,
            colorIn: '#fff',
            colorOut: '#555',
            colorWhirl: '#6cf',
            timeInterval: 50
        });
        var location = this.getLocation(this.options.textStyle, textWidth + textGap + effectOption.r * 2, Math.max(effectOption.r * 2, textHeight));
        effectOption.x = location.x + effectOption.r;
        effectOption.y = textShape.highlightStyle.y = location.y + location.height / 2;
        textShape.highlightStyle.x = effectOption.x + effectOption.r + textGap;
        var background = this.createBackgroundShape(options.backgroundColor);
        var droplet = new DropletShape({
            highlightStyle: {
                a: Math.round(effectOption.r / 2),
                b: Math.round(effectOption.r - effectOption.r / 6),
                brushType: 'fill',
                color: effectOption.colorWhirl
            }
        });
        var circleIn = new CircleShape({
            highlightStyle: {
                r: Math.round(effectOption.r / 6),
                brushType: 'fill',
                color: effectOption.colorIn
            }
        });
        var circleOut = new RingShape({
            highlightStyle: {
                r0: Math.round(effectOption.r - effectOption.r / 3),
                r: effectOption.r,
                brushType: 'fill',
                color: effectOption.colorOut
            }
        });
        var pos = [
            0,
            effectOption.x,
            effectOption.y
        ];
        droplet.highlightStyle.x = circleIn.highlightStyle.x = circleOut.highlightStyle.x = pos[1];
        droplet.highlightStyle.y = circleIn.highlightStyle.y = circleOut.highlightStyle.y = pos[2];
        return setInterval(function () {
            addShapeHandle(background);
            addShapeHandle(circleOut);
            pos[0] -= 0.3;
            droplet.rotation = pos;
            addShapeHandle(droplet);
            addShapeHandle(circleIn);
            addShapeHandle(textShape);
            refreshHandle();
        }, effectOption.timeInterval);
    };
    return Whirling;
});define('echarts/theme/macarons', [], function () {
    var theme = {
        color: [
            '#2ec7c9',
            '#b6a2de',
            '#5ab1ef',
            '#ffb980',
            '#d87a80',
            '#8d98b3',
            '#e5cf0d',
            '#97b552',
            '#95706d',
            '#dc69aa',
            '#07a2a4',
            '#9a7fd1',
            '#588dd5',
            '#f5994e',
            '#c05050',
            '#59678c',
            '#c9ab00',
            '#7eb00a',
            '#6f5553',
            '#c14089'
        ],
        title: {
            textStyle: {
                fontWeight: 'normal',
                color: '#008acd'
            }
        },
        dataRange: {
            itemWidth: 15,
            color: [
                '#5ab1ef',
                '#e0ffff'
            ]
        },
        toolbox: {
            color: [
                '#1e90ff',
                '#1e90ff',
                '#1e90ff',
                '#1e90ff'
            ],
            effectiveColor: '#ff4500'
        },
        tooltip: {
            backgroundColor: 'rgba(50,50,50,0.5)',
            axisPointer: {
                type: 'line',
                lineStyle: { color: '#008acd' },
                crossStyle: { color: '#008acd' },
                shadowStyle: { color: 'rgba(200,200,200,0.2)' }
            }
        },
        dataZoom: {
            dataBackgroundColor: '#efefff',
            fillerColor: 'rgba(182,162,222,0.2)',
            handleColor: '#008acd'
        },
        grid: { borderColor: '#eee' },
        categoryAxis: {
            axisLine: { lineStyle: { color: '#008acd' } },
            splitLine: { lineStyle: { color: ['#eee'] } }
        },
        valueAxis: {
            axisLine: { lineStyle: { color: '#008acd' } },
            splitArea: {
                show: true,
                areaStyle: {
                    color: [
                        'rgba(250,250,250,0.1)',
                        'rgba(200,200,200,0.1)'
                    ]
                }
            },
            splitLine: { lineStyle: { color: ['#eee'] } }
        },
        polar: {
            axisLine: { lineStyle: { color: '#ddd' } },
            splitArea: {
                show: true,
                areaStyle: {
                    color: [
                        'rgba(250,250,250,0.2)',
                        'rgba(200,200,200,0.2)'
                    ]
                }
            },
            splitLine: { lineStyle: { color: '#ddd' } }
        },
        timeline: {
            lineStyle: { color: '#008acd' },
            controlStyle: {
                normal: { color: '#008acd' },
                emphasis: { color: '#008acd' }
            },
            symbol: 'emptyCircle',
            symbolSize: 3
        },
        bar: {
            itemStyle: {
                normal: { barBorderRadius: 5 },
                emphasis: { barBorderRadius: 5 }
            }
        },
        line: {
            smooth: true,
            symbol: 'emptyCircle',
            symbolSize: 3
        },
        k: {
            itemStyle: {
                normal: {
                    color: '#d87a80',
                    color0: '#2ec7c9',
                    lineStyle: {
                        color: '#d87a80',
                        color0: '#2ec7c9'
                    }
                }
            }
        },
        scatter: {
            symbol: 'circle',
            symbolSize: 4
        },
        radar: {
            symbol: 'emptyCircle',
            symbolSize: 3
        },
        map: {
            itemStyle: {
                normal: {
                    areaStyle: { color: '#ddd' },
                    label: { textStyle: { color: '#d87a80' } }
                },
                emphasis: { areaStyle: { color: '#fe994e' } }
            }
        },
        force: { itemStyle: { normal: { linkStyle: { color: '#1e90ff' } } } },
        chord: {
            itemStyle: {
                normal: {
                    borderWidth: 1,
                    borderColor: 'rgba(128, 128, 128, 0.5)',
                    chordStyle: { lineStyle: { color: 'rgba(128, 128, 128, 0.5)' } }
                },
                emphasis: {
                    borderWidth: 1,
                    borderColor: 'rgba(128, 128, 128, 0.5)',
                    chordStyle: { lineStyle: { color: 'rgba(128, 128, 128, 0.5)' } }
                }
            }
        },
        gauge: {
            axisLine: {
                lineStyle: {
                    color: [
                        [
                            0.2,
                            '#2ec7c9'
                        ],
                        [
                            0.8,
                            '#5ab1ef'
                        ],
                        [
                            1,
                            '#d87a80'
                        ]
                    ],
                    width: 10
                }
            },
            axisTick: {
                splitNumber: 10,
                length: 15,
                lineStyle: { color: 'auto' }
            },
            splitLine: {
                length: 22,
                lineStyle: { color: 'auto' }
            },
            pointer: { width: 5 }
        },
        textStyle: { fontFamily: 'å¾®è½¯é›…é»‘, Arial, Verdana, sans-serif' }
    };
    return theme;
});define('echarts/theme/infographic', [], function () {
    var theme = {
        color: [
            '#C1232B',
            '#B5C334',
            '#FCCE10',
            '#E87C25',
            '#27727B',
            '#FE8463',
            '#9BCA63',
            '#FAD860',
            '#F3A43B',
            '#60C0DD',
            '#D7504B',
            '#C6E579',
            '#F4E001',
            '#F0805A',
            '#26C0C0'
        ],
        title: {
            textStyle: {
                fontWeight: 'normal',
                color: '#27727B'
            }
        },
        dataRange: {
            x: 'right',
            y: 'center',
            itemWidth: 5,
            itemHeight: 25,
            color: [
                '#C1232B',
                '#FCCE10'
            ]
        },
        toolbox: {
            color: [
                '#C1232B',
                '#B5C334',
                '#FCCE10',
                '#E87C25',
                '#27727B',
                '#FE8463',
                '#9BCA63',
                '#FAD860',
                '#F3A43B',
                '#60C0DD'
            ],
            effectiveColor: '#ff4500'
        },
        tooltip: {
            backgroundColor: 'rgba(50,50,50,0.5)',
            axisPointer: {
                type: 'line',
                lineStyle: {
                    color: '#27727B',
                    type: 'dashed'
                },
                crossStyle: { color: '#27727B' },
                shadowStyle: { color: 'rgba(200,200,200,0.3)' }
            }
        },
        dataZoom: {
            dataBackgroundColor: 'rgba(181,195,52,0.3)',
            fillerColor: 'rgba(181,195,52,0.2)',
            handleColor: '#27727B'
        },
        grid: { borderWidth: 0 },
        categoryAxis: {
            axisLine: { lineStyle: { color: '#27727B' } },
            splitLine: { show: false }
        },
        valueAxis: {
            axisLine: { show: false },
            splitArea: { show: false },
            splitLine: {
                lineStyle: {
                    color: ['#ccc'],
                    type: 'dashed'
                }
            }
        },
        polar: {
            axisLine: { lineStyle: { color: '#ddd' } },
            splitArea: {
                show: true,
                areaStyle: {
                    color: [
                        'rgba(250,250,250,0.2)',
                        'rgba(200,200,200,0.2)'
                    ]
                }
            },
            splitLine: { lineStyle: { color: '#ddd' } }
        },
        timeline: {
            lineStyle: { color: '#27727B' },
            controlStyle: {
                normal: { color: '#27727B' },
                emphasis: { color: '#27727B' }
            },
            symbol: 'emptyCircle',
            symbolSize: 3
        },
        line: {
            itemStyle: {
                normal: {
                    borderWidth: 2,
                    borderColor: '#fff',
                    lineStyle: { width: 3 }
                },
                emphasis: { borderWidth: 0 }
            },
            symbol: 'circle',
            symbolSize: 3.5
        },
        k: {
            itemStyle: {
                normal: {
                    color: '#C1232B',
                    color0: '#B5C334',
                    lineStyle: {
                        width: 1,
                        color: '#C1232B',
                        color0: '#B5C334'
                    }
                }
            }
        },
        scatter: {
            itemStyle: {
                normal: {
                    borderWidth: 1,
                    borderColor: 'rgba(200,200,200,0.5)'
                },
                emphasis: { borderWidth: 0 }
            },
            symbol: 'star4',
            symbolSize: 4
        },
        radar: {
            symbol: 'emptyCircle',
            symbolSize: 3
        },
        map: {
            itemStyle: {
                normal: {
                    areaStyle: { color: '#ddd' },
                    label: { textStyle: { color: '#C1232B' } }
                },
                emphasis: {
                    areaStyle: { color: '#fe994e' },
                    label: { textStyle: { color: 'rgb(100,0,0)' } }
                }
            }
        },
        force: { itemStyle: { normal: { linkStyle: { color: '#27727B' } } } },
        chord: {
            itemStyle: {
                normal: {
                    borderWidth: 1,
                    borderColor: 'rgba(128, 128, 128, 0.5)',
                    chordStyle: { lineStyle: { color: 'rgba(128, 128, 128, 0.5)' } }
                },
                emphasis: {
                    borderWidth: 1,
                    borderColor: 'rgba(128, 128, 128, 0.5)',
                    chordStyle: { lineStyle: { color: 'rgba(128, 128, 128, 0.5)' } }
                }
            }
        },
        gauge: {
            center: [
                '50%',
                '80%'
            ],
            radius: '100%',
            startAngle: 180,
            endAngle: 0,
            axisLine: {
                show: true,
                lineStyle: {
                    color: [
                        [
                            0.2,
                            '#B5C334'
                        ],
                        [
                            0.8,
                            '#27727B'
                        ],
                        [
                            1,
                            '#C1232B'
                        ]
                    ],
                    width: '40%'
                }
            },
            axisTick: {
                splitNumber: 2,
                length: 5,
                lineStyle: { color: '#fff' }
            },
            axisLabel: {
                textStyle: {
                    color: '#fff',
                    fontWeight: 'bolder'
                }
            },
            splitLine: {
                length: '5%',
                lineStyle: { color: '#fff' }
            },
            pointer: {
                width: '40%',
                length: '80%',
                color: '#fff'
            },
            title: {
                offsetCenter: [
                    0,
                    -20
                ],
                textStyle: {
                    color: 'auto',
                    fontSize: 20
                }
            },
            detail: {
                offsetCenter: [
                    0,
                    0
                ],
                textStyle: {
                    color: 'auto',
                    fontSize: 40
                }
            }
        },
        textStyle: { fontFamily: 'å¾®è½¯é›…é»‘, Arial, Verdana, sans-serif' }
    };
    return theme;
});define('zrender/dep/excanvas', ['require'], function (require) {
    if (!document.createElement('canvas').getContext) {
        (function () {
            var m = Math;
            var mr = m.round;
            var ms = m.sin;
            var mc = m.cos;
            var abs = m.abs;
            var sqrt = m.sqrt;
            var Z = 10;
            var Z2 = Z / 2;
            var IE_VERSION = +navigator.userAgent.match(/MSIE ([\d.]+)?/)[1];
            function getContext() {
                return this.context_ || (this.context_ = new CanvasRenderingContext2D_(this));
            }
            var slice = Array.prototype.slice;
            function bind(f, obj, var_args) {
                var a = slice.call(arguments, 2);
                return function () {
                    return f.apply(obj, a.concat(slice.call(arguments)));
                };
            }
            function encodeHtmlAttribute(s) {
                return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
            }
            function addNamespace(doc, prefix, urn) {
                if (!doc.namespaces[prefix]) {
                    doc.namespaces.add(prefix, urn, '#default#VML');
                }
            }
            function addNamespacesAndStylesheet(doc) {
                addNamespace(doc, 'g_vml_', 'urn:schemas-microsoft-com:vml');
                addNamespace(doc, 'g_o_', 'urn:schemas-microsoft-com:office:office');
                if (!doc.styleSheets['ex_canvas_']) {
                    var ss = doc.createStyleSheet();
                    ss.owningElement.id = 'ex_canvas_';
                    ss.cssText = 'canvas{display:inline-block;overflow:hidden;' + 'text-align:left;width:300px;height:150px}';
                }
            }
            addNamespacesAndStylesheet(document);
            var G_vmlCanvasManager_ = {
                init: function (opt_doc) {
                    var doc = opt_doc || document;
                    doc.createElement('canvas');
                    doc.attachEvent('onreadystatechange', bind(this.init_, this, doc));
                },
                init_: function (doc) {
                    var els = doc.getElementsByTagName('canvas');
                    for (var i = 0; i < els.length; i++) {
                        this.initElement(els[i]);
                    }
                },
                initElement: function (el) {
                    if (!el.getContext) {
                        el.getContext = getContext;
                        addNamespacesAndStylesheet(el.ownerDocument);
                        el.innerHTML = '';
                        el.attachEvent('onpropertychange', onPropertyChange);
                        el.attachEvent('onresize', onResize);
                        var attrs = el.attributes;
                        if (attrs.width && attrs.width.specified) {
                            el.style.width = attrs.width.nodeValue + 'px';
                        } else {
                            el.width = el.clientWidth;
                        }
                        if (attrs.height && attrs.height.specified) {
                            el.style.height = attrs.height.nodeValue + 'px';
                        } else {
                            el.height = el.clientHeight;
                        }
                    }
                    return el;
                }
            };
            function onPropertyChange(e) {
                var el = e.srcElement;
                switch (e.propertyName) {
                case 'width':
                    el.getContext().clearRect();
                    el.style.width = el.attributes.width.nodeValue + 'px';
                    el.firstChild.style.width = el.clientWidth + 'px';
                    break;
                case 'height':
                    el.getContext().clearRect();
                    el.style.height = el.attributes.height.nodeValue + 'px';
                    el.firstChild.style.height = el.clientHeight + 'px';
                    break;
                }
            }
            function onResize(e) {
                var el = e.srcElement;
                if (el.firstChild) {
                    el.firstChild.style.width = el.clientWidth + 'px';
                    el.firstChild.style.height = el.clientHeight + 'px';
                }
            }
            G_vmlCanvasManager_.init();
            var decToHex = [];
            for (var i = 0; i < 16; i++) {
                for (var j = 0; j < 16; j++) {
                    decToHex[i * 16 + j] = i.toString(16) + j.toString(16);
                }
            }
            function createMatrixIdentity() {
                return [
                    [
                        1,
                        0,
                        0
                    ],
                    [
                        0,
                        1,
                        0
                    ],
                    [
                        0,
                        0,
                        1
                    ]
                ];
            }
            function matrixMultiply(m1, m2) {
                var result = createMatrixIdentity();
                for (var x = 0; x < 3; x++) {
                    for (var y = 0; y < 3; y++) {
                        var sum = 0;
                        for (var z = 0; z < 3; z++) {
                            sum += m1[x][z] * m2[z][y];
                        }
                        result[x][y] = sum;
                    }
                }
                return result;
            }
            function copyState(o1, o2) {
                o2.fillStyle = o1.fillStyle;
                o2.lineCap = o1.lineCap;
                o2.lineJoin = o1.lineJoin;
                o2.lineWidth = o1.lineWidth;
                o2.miterLimit = o1.miterLimit;
                o2.shadowBlur = o1.shadowBlur;
                o2.shadowColor = o1.shadowColor;
                o2.shadowOffsetX = o1.shadowOffsetX;
                o2.shadowOffsetY = o1.shadowOffsetY;
                o2.strokeStyle = o1.strokeStyle;
                o2.globalAlpha = o1.globalAlpha;
                o2.font = o1.font;
                o2.textAlign = o1.textAlign;
                o2.textBaseline = o1.textBaseline;
                o2.scaleX_ = o1.scaleX_;
                o2.scaleY_ = o1.scaleY_;
                o2.lineScale_ = o1.lineScale_;
            }
            var colorData = {
                aliceblue: '#F0F8FF',
                antiquewhite: '#FAEBD7',
                aquamarine: '#7FFFD4',
                azure: '#F0FFFF',
                beige: '#F5F5DC',
                bisque: '#FFE4C4',
                black: '#000000',
                blanchedalmond: '#FFEBCD',
                blueviolet: '#8A2BE2',
                brown: '#A52A2A',
                burlywood: '#DEB887',
                cadetblue: '#5F9EA0',
                chartreuse: '#7FFF00',
                chocolate: '#D2691E',
                coral: '#FF7F50',
                cornflowerblue: '#6495ED',
                cornsilk: '#FFF8DC',
                crimson: '#DC143C',
                cyan: '#00FFFF',
                darkblue: '#00008B',
                darkcyan: '#008B8B',
                darkgoldenrod: '#B8860B',
                darkgray: '#A9A9A9',
                darkgreen: '#006400',
                darkgrey: '#A9A9A9',
                darkkhaki: '#BDB76B',
                darkmagenta: '#8B008B',
                darkolivegreen: '#556B2F',
                darkorange: '#FF8C00',
                darkorchid: '#9932CC',
                darkred: '#8B0000',
                darksalmon: '#E9967A',
                darkseagreen: '#8FBC8F',
                darkslateblue: '#483D8B',
                darkslategray: '#2F4F4F',
                darkslategrey: '#2F4F4F',
                darkturquoise: '#00CED1',
                darkviolet: '#9400D3',
                deeppink: '#FF1493',
                deepskyblue: '#00BFFF',
                dimgray: '#696969',
                dimgrey: '#696969',
                dodgerblue: '#1E90FF',
                firebrick: '#B22222',
                floralwhite: '#FFFAF0',
                forestgreen: '#228B22',
                gainsboro: '#DCDCDC',
                ghostwhite: '#F8F8FF',
                gold: '#FFD700',
                goldenrod: '#DAA520',
                grey: '#808080',
                greenyellow: '#ADFF2F',
                honeydew: '#F0FFF0',
                hotpink: '#FF69B4',
                indianred: '#CD5C5C',
                indigo: '#4B0082',
                ivory: '#FFFFF0',
                khaki: '#F0E68C',
                lavender: '#E6E6FA',
                lavenderblush: '#FFF0F5',
                lawngreen: '#7CFC00',
                lemonchiffon: '#FFFACD',
                lightblue: '#ADD8E6',
                lightcoral: '#F08080',
                lightcyan: '#E0FFFF',
                lightgoldenrodyellow: '#FAFAD2',
                lightgreen: '#90EE90',
                lightgrey: '#D3D3D3',
                lightpink: '#FFB6C1',
                lightsalmon: '#FFA07A',
                lightseagreen: '#20B2AA',
                lightskyblue: '#87CEFA',
                lightslategray: '#778899',
                lightslategrey: '#778899',
                lightsteelblue: '#B0C4DE',
                lightyellow: '#FFFFE0',
                limegreen: '#32CD32',
                linen: '#FAF0E6',
                magenta: '#FF00FF',
                mediumaquamarine: '#66CDAA',
                mediumblue: '#0000CD',
                mediumorchid: '#BA55D3',
                mediumpurple: '#9370DB',
                mediumseagreen: '#3CB371',
                mediumslateblue: '#7B68EE',
                mediumspringgreen: '#00FA9A',
                mediumturquoise: '#48D1CC',
                mediumvioletred: '#C71585',
                midnightblue: '#191970',
                mintcream: '#F5FFFA',
                mistyrose: '#FFE4E1',
                moccasin: '#FFE4B5',
                navajowhite: '#FFDEAD',
                oldlace: '#FDF5E6',
                olivedrab: '#6B8E23',
                orange: '#FFA500',
                orangered: '#FF4500',
                orchid: '#DA70D6',
                palegoldenrod: '#EEE8AA',
                palegreen: '#98FB98',
                paleturquoise: '#AFEEEE',
                palevioletred: '#DB7093',
                papayawhip: '#FFEFD5',
                peachpuff: '#FFDAB9',
                peru: '#CD853F',
                pink: '#FFC0CB',
                plum: '#DDA0DD',
                powderblue: '#B0E0E6',
                rosybrown: '#BC8F8F',
                royalblue: '#4169E1',
                saddlebrown: '#8B4513',
                salmon: '#FA8072',
                sandybrown: '#F4A460',
                seagreen: '#2E8B57',
                seashell: '#FFF5EE',
                sienna: '#A0522D',
                skyblue: '#87CEEB',
                slateblue: '#6A5ACD',
                slategray: '#708090',
                slategrey: '#708090',
                snow: '#FFFAFA',
                springgreen: '#00FF7F',
                steelblue: '#4682B4',
                tan: '#D2B48C',
                thistle: '#D8BFD8',
                tomato: '#FF6347',
                turquoise: '#40E0D0',
                violet: '#EE82EE',
                wheat: '#F5DEB3',
                whitesmoke: '#F5F5F5',
                yellowgreen: '#9ACD32'
            };
            function getRgbHslContent(styleString) {
                var start = styleString.indexOf('(', 3);
                var end = styleString.indexOf(')', start + 1);
                var parts = styleString.substring(start + 1, end).split(',');
                if (parts.length != 4 || styleString.charAt(3) != 'a') {
                    parts[3] = 1;
                }
                return parts;
            }
            function percent(s) {
                return parseFloat(s) / 100;
            }
            function clamp(v, min, max) {
                return Math.min(max, Math.max(min, v));
            }
            function hslToRgb(parts) {
                var r, g, b, h, s, l;
                h = parseFloat(parts[0]) / 360 % 360;
                if (h < 0)
                    h++;
                s = clamp(percent(parts[1]), 0, 1);
                l = clamp(percent(parts[2]), 0, 1);
                if (s == 0) {
                    r = g = b = l;
                } else {
                    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    var p = 2 * l - q;
                    r = hueToRgb(p, q, h + 1 / 3);
                    g = hueToRgb(p, q, h);
                    b = hueToRgb(p, q, h - 1 / 3);
                }
                return '#' + decToHex[Math.floor(r * 255)] + decToHex[Math.floor(g * 255)] + decToHex[Math.floor(b * 255)];
            }
            function hueToRgb(m1, m2, h) {
                if (h < 0)
                    h++;
                if (h > 1)
                    h--;
                if (6 * h < 1)
                    return m1 + (m2 - m1) * 6 * h;
                else if (2 * h < 1)
                    return m2;
                else if (3 * h < 2)
                    return m1 + (m2 - m1) * (2 / 3 - h) * 6;
                else
                    return m1;
            }
            var processStyleCache = {};
            function processStyle(styleString) {
                if (styleString in processStyleCache) {
                    return processStyleCache[styleString];
                }
                var str, alpha = 1;
                styleString = String(styleString);
                if (styleString.charAt(0) == '#') {
                    str = styleString;
                } else if (/^rgb/.test(styleString)) {
                    var parts = getRgbHslContent(styleString);
                    var str = '#', n;
                    for (var i = 0; i < 3; i++) {
                        if (parts[i].indexOf('%') != -1) {
                            n = Math.floor(percent(parts[i]) * 255);
                        } else {
                            n = +parts[i];
                        }
                        str += decToHex[clamp(n, 0, 255)];
                    }
                    alpha = +parts[3];
                } else if (/^hsl/.test(styleString)) {
                    var parts = getRgbHslContent(styleString);
                    str = hslToRgb(parts);
                    alpha = parts[3];
                } else {
                    str = colorData[styleString] || styleString;
                }
                return processStyleCache[styleString] = {
                    color: str,
                    alpha: alpha
                };
            }
            var DEFAULT_STYLE = {
                style: 'normal',
                variant: 'normal',
                weight: 'normal',
                size: 12,
                family: 'å¾®è½¯é›…é»‘'
            };
            var fontStyleCache = {};
            function processFontStyle(styleString) {
                if (fontStyleCache[styleString]) {
                    return fontStyleCache[styleString];
                }
                var el = document.createElement('div');
                var style = el.style;
                var fontFamily;
                try {
                    style.font = styleString;
                    fontFamily = style.fontFamily.split(',')[0];
                } catch (ex) {
                }
                return fontStyleCache[styleString] = {
                    style: style.fontStyle || DEFAULT_STYLE.style,
                    variant: style.fontVariant || DEFAULT_STYLE.variant,
                    weight: style.fontWeight || DEFAULT_STYLE.weight,
                    size: style.fontSize || DEFAULT_STYLE.size,
                    family: fontFamily || DEFAULT_STYLE.family
                };
            }
            function getComputedStyle(style, element) {
                var computedStyle = {};
                for (var p in style) {
                    computedStyle[p] = style[p];
                }
                var canvasFontSize = parseFloat(element.currentStyle.fontSize), fontSize = parseFloat(style.size);
                if (typeof style.size == 'number') {
                    computedStyle.size = style.size;
                } else if (style.size.indexOf('px') != -1) {
                    computedStyle.size = fontSize;
                } else if (style.size.indexOf('em') != -1) {
                    computedStyle.size = canvasFontSize * fontSize;
                } else if (style.size.indexOf('%') != -1) {
                    computedStyle.size = canvasFontSize / 100 * fontSize;
                } else if (style.size.indexOf('pt') != -1) {
                    computedStyle.size = fontSize / 0.75;
                } else {
                    computedStyle.size = canvasFontSize;
                }
                return computedStyle;
            }
            function buildStyle(style) {
                return style.style + ' ' + style.variant + ' ' + style.weight + ' ' + style.size + 'px \'' + style.family + '\'';
            }
            var lineCapMap = {
                'butt': 'flat',
                'round': 'round'
            };
            function processLineCap(lineCap) {
                return lineCapMap[lineCap] || 'square';
            }
            function CanvasRenderingContext2D_(canvasElement) {
                this.m_ = createMatrixIdentity();
                this.mStack_ = [];
                this.aStack_ = [];
                this.currentPath_ = [];
                this.strokeStyle = '#000';
                this.fillStyle = '#000';
                this.lineWidth = 1;
                this.lineJoin = 'miter';
                this.lineCap = 'butt';
                this.miterLimit = Z * 1;
                this.globalAlpha = 1;
                this.font = '12px å¾®è½¯é›…é»‘';
                this.textAlign = 'left';
                this.textBaseline = 'alphabetic';
                this.canvas = canvasElement;
                var cssText = 'width:' + canvasElement.clientWidth + 'px;height:' + canvasElement.clientHeight + 'px;overflow:hidden;position:absolute';
                var el = canvasElement.ownerDocument.createElement('div');
                el.style.cssText = cssText;
                canvasElement.appendChild(el);
                var overlayEl = el.cloneNode(false);
                overlayEl.style.backgroundColor = '#fff';
                overlayEl.style.filter = 'alpha(opacity=0)';
                canvasElement.appendChild(overlayEl);
                this.element_ = el;
                this.scaleX_ = 1;
                this.scaleY_ = 1;
                this.lineScale_ = 1;
            }
            var contextPrototype = CanvasRenderingContext2D_.prototype;
            contextPrototype.clearRect = function () {
                if (this.textMeasureEl_) {
                    this.textMeasureEl_.removeNode(true);
                    this.textMeasureEl_ = null;
                }
                this.element_.innerHTML = '';
            };
            contextPrototype.beginPath = function () {
                this.currentPath_ = [];
            };
            contextPrototype.moveTo = function (aX, aY) {
                var p = getCoords(this, aX, aY);
                this.currentPath_.push({
                    type: 'moveTo',
                    x: p.x,
                    y: p.y
                });
                this.currentX_ = p.x;
                this.currentY_ = p.y;
            };
            contextPrototype.lineTo = function (aX, aY) {
                var p = getCoords(this, aX, aY);
                this.currentPath_.push({
                    type: 'lineTo',
                    x: p.x,
                    y: p.y
                });
                this.currentX_ = p.x;
                this.currentY_ = p.y;
            };
            contextPrototype.bezierCurveTo = function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
                var p = getCoords(this, aX, aY);
                var cp1 = getCoords(this, aCP1x, aCP1y);
                var cp2 = getCoords(this, aCP2x, aCP2y);
                bezierCurveTo(this, cp1, cp2, p);
            };
            function bezierCurveTo(self, cp1, cp2, p) {
                self.currentPath_.push({
                    type: 'bezierCurveTo',
                    cp1x: cp1.x,
                    cp1y: cp1.y,
                    cp2x: cp2.x,
                    cp2y: cp2.y,
                    x: p.x,
                    y: p.y
                });
                self.currentX_ = p.x;
                self.currentY_ = p.y;
            }
            contextPrototype.quadraticCurveTo = function (aCPx, aCPy, aX, aY) {
                var cp = getCoords(this, aCPx, aCPy);
                var p = getCoords(this, aX, aY);
                var cp1 = {
                    x: this.currentX_ + 2 / 3 * (cp.x - this.currentX_),
                    y: this.currentY_ + 2 / 3 * (cp.y - this.currentY_)
                };
                var cp2 = {
                    x: cp1.x + (p.x - this.currentX_) / 3,
                    y: cp1.y + (p.y - this.currentY_) / 3
                };
                bezierCurveTo(this, cp1, cp2, p);
            };
            contextPrototype.arc = function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
                aRadius *= Z;
                var arcType = aClockwise ? 'at' : 'wa';
                var xStart = aX + mc(aStartAngle) * aRadius - Z2;
                var yStart = aY + ms(aStartAngle) * aRadius - Z2;
                var xEnd = aX + mc(aEndAngle) * aRadius - Z2;
                var yEnd = aY + ms(aEndAngle) * aRadius - Z2;
                if (xStart == xEnd && !aClockwise) {
                    xStart += 0.125;
                }
                var p = getCoords(this, aX, aY);
                var pStart = getCoords(this, xStart, yStart);
                var pEnd = getCoords(this, xEnd, yEnd);
                this.currentPath_.push({
                    type: arcType,
                    x: p.x,
                    y: p.y,
                    radius: aRadius,
                    xStart: pStart.x,
                    yStart: pStart.y,
                    xEnd: pEnd.x,
                    yEnd: pEnd.y
                });
            };
            contextPrototype.rect = function (aX, aY, aWidth, aHeight) {
                this.moveTo(aX, aY);
                this.lineTo(aX + aWidth, aY);
                this.lineTo(aX + aWidth, aY + aHeight);
                this.lineTo(aX, aY + aHeight);
                this.closePath();
            };
            contextPrototype.strokeRect = function (aX, aY, aWidth, aHeight) {
                var oldPath = this.currentPath_;
                this.beginPath();
                this.moveTo(aX, aY);
                this.lineTo(aX + aWidth, aY);
                this.lineTo(aX + aWidth, aY + aHeight);
                this.lineTo(aX, aY + aHeight);
                this.closePath();
                this.stroke();
                this.currentPath_ = oldPath;
            };
            contextPrototype.fillRect = function (aX, aY, aWidth, aHeight) {
                var oldPath = this.currentPath_;
                this.beginPath();
                this.moveTo(aX, aY);
                this.lineTo(aX + aWidth, aY);
                this.lineTo(aX + aWidth, aY + aHeight);
                this.lineTo(aX, aY + aHeight);
                this.closePath();
                this.fill();
                this.currentPath_ = oldPath;
            };
            contextPrototype.createLinearGradient = function (aX0, aY0, aX1, aY1) {
                var gradient = new CanvasGradient_('gradient');
                gradient.x0_ = aX0;
                gradient.y0_ = aY0;
                gradient.x1_ = aX1;
                gradient.y1_ = aY1;
                return gradient;
            };
            contextPrototype.createRadialGradient = function (aX0, aY0, aR0, aX1, aY1, aR1) {
                var gradient = new CanvasGradient_('gradientradial');
                gradient.x0_ = aX0;
                gradient.y0_ = aY0;
                gradient.r0_ = aR0;
                gradient.x1_ = aX1;
                gradient.y1_ = aY1;
                gradient.r1_ = aR1;
                return gradient;
            };
            contextPrototype.drawImage = function (image, var_args) {
                var dx, dy, dw, dh, sx, sy, sw, sh;
                var oldRuntimeWidth = image.runtimeStyle.width;
                var oldRuntimeHeight = image.runtimeStyle.height;
                image.runtimeStyle.width = 'auto';
                image.runtimeStyle.height = 'auto';
                var w = image.width;
                var h = image.height;
                image.runtimeStyle.width = oldRuntimeWidth;
                image.runtimeStyle.height = oldRuntimeHeight;
                if (arguments.length == 3) {
                    dx = arguments[1];
                    dy = arguments[2];
                    sx = sy = 0;
                    sw = dw = w;
                    sh = dh = h;
                } else if (arguments.length == 5) {
                    dx = arguments[1];
                    dy = arguments[2];
                    dw = arguments[3];
                    dh = arguments[4];
                    sx = sy = 0;
                    sw = w;
                    sh = h;
                } else if (arguments.length == 9) {
                    sx = arguments[1];
                    sy = arguments[2];
                    sw = arguments[3];
                    sh = arguments[4];
                    dx = arguments[5];
                    dy = arguments[6];
                    dw = arguments[7];
                    dh = arguments[8];
                } else {
                    throw Error('Invalid number of arguments');
                }
                var d = getCoords(this, dx, dy);
                var w2 = sw / 2;
                var h2 = sh / 2;
                var vmlStr = [];
                var W = 10;
                var H = 10;
                var scaleX = scaleY = 1;
                vmlStr.push(' <g_vml_:group', ' coordsize="', Z * W, ',', Z * H, '"', ' coordorigin="0,0"', ' style="width:', W, 'px;height:', H, 'px;position:absolute;');
                if (this.m_[0][0] != 1 || this.m_[0][1] || this.m_[1][1] != 1 || this.m_[1][0]) {
                    var filter = [];
                    var scaleX = this.scaleX_;
                    var scaleY = this.scaleY_;
                    filter.push('M11=', this.m_[0][0] / scaleX, ',', 'M12=', this.m_[1][0] / scaleY, ',', 'M21=', this.m_[0][1] / scaleX, ',', 'M22=', this.m_[1][1] / scaleY, ',', 'Dx=', mr(d.x / Z), ',', 'Dy=', mr(d.y / Z), '');
                    var max = d;
                    var c2 = getCoords(this, dx + dw, dy);
                    var c3 = getCoords(this, dx, dy + dh);
                    var c4 = getCoords(this, dx + dw, dy + dh);
                    max.x = m.max(max.x, c2.x, c3.x, c4.x);
                    max.y = m.max(max.y, c2.y, c3.y, c4.y);
                    vmlStr.push('padding:0 ', mr(max.x / Z), 'px ', mr(max.y / Z), 'px 0;filter:progid:DXImageTransform.Microsoft.Matrix(', filter.join(''), ', SizingMethod=\'clip\');');
                } else {
                    vmlStr.push('top:', mr(d.y / Z), 'px;left:', mr(d.x / Z), 'px;');
                }
                vmlStr.push(' ">');
                if (sx || sy) {
                    vmlStr.push('<div style="overflow: hidden; width:', Math.ceil((dw + sx * dw / sw) * scaleX), 'px;', ' height:', Math.ceil((dh + sy * dh / sh) * scaleY), 'px;', ' filter:progid:DxImageTransform.Microsoft.Matrix(Dx=', -sx * dw / sw * scaleX, ',Dy=', -sy * dh / sh * scaleY, ');">');
                }
                vmlStr.push('<div style="width:', Math.round(scaleX * w * dw / sw), 'px;', ' height:', Math.round(scaleY * h * dh / sh), 'px;', ' filter:');
                if (this.globalAlpha < 1) {
                    vmlStr.push(' progid:DXImageTransform.Microsoft.Alpha(opacity=' + this.globalAlpha * 100 + ')');
                }
                vmlStr.push(' progid:DXImageTransform.Microsoft.AlphaImageLoader(src=', image.src, ',sizingMethod=scale)">');
                if (sx || sy)
                    vmlStr.push('</div>');
                vmlStr.push('</div></div>');
                this.element_.insertAdjacentHTML('BeforeEnd', vmlStr.join(''));
            };
            contextPrototype.stroke = function (aFill) {
                var lineStr = [];
                var lineOpen = false;
                var W = 10;
                var H = 10;
                lineStr.push('<g_vml_:shape', ' filled="', !!aFill, '"', ' style="position:absolute;width:', W, 'px;height:', H, 'px;"', ' coordorigin="0,0"', ' coordsize="', Z * W, ',', Z * H, '"', ' stroked="', !aFill, '"', ' path="');
                var newSeq = false;
                var min = {
                    x: null,
                    y: null
                };
                var max = {
                    x: null,
                    y: null
                };
                for (var i = 0; i < this.currentPath_.length; i++) {
                    var p = this.currentPath_[i];
                    var c;
                    switch (p.type) {
                    case 'moveTo':
                        c = p;
                        lineStr.push(' m ', mr(p.x), ',', mr(p.y));
                        break;
                    case 'lineTo':
                        lineStr.push(' l ', mr(p.x), ',', mr(p.y));
                        break;
                    case 'close':
                        lineStr.push(' x ');
                        p = null;
                        break;
                    case 'bezierCurveTo':
                        lineStr.push(' c ', mr(p.cp1x), ',', mr(p.cp1y), ',', mr(p.cp2x), ',', mr(p.cp2y), ',', mr(p.x), ',', mr(p.y));
                        break;
                    case 'at':
                    case 'wa':
                        lineStr.push(' ', p.type, ' ', mr(p.x - this.scaleX_ * p.radius), ',', mr(p.y - this.scaleY_ * p.radius), ' ', mr(p.x + this.scaleX_ * p.radius), ',', mr(p.y + this.scaleY_ * p.radius), ' ', mr(p.xStart), ',', mr(p.yStart), ' ', mr(p.xEnd), ',', mr(p.yEnd));
                        break;
                    }
                    if (p) {
                        if (min.x == null || p.x < min.x) {
                            min.x = p.x;
                        }
                        if (max.x == null || p.x > max.x) {
                            max.x = p.x;
                        }
                        if (min.y == null || p.y < min.y) {
                            min.y = p.y;
                        }
                        if (max.y == null || p.y > max.y) {
                            max.y = p.y;
                        }
                    }
                }
                lineStr.push(' ">');
                if (!aFill) {
                    appendStroke(this, lineStr);
                } else {
                    appendFill(this, lineStr, min, max);
                }
                lineStr.push('</g_vml_:shape>');
                this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
            };
            function appendStroke(ctx, lineStr) {
                var a = processStyle(ctx.strokeStyle);
                var color = a.color;
                var opacity = a.alpha * ctx.globalAlpha;
                var lineWidth = ctx.lineScale_ * ctx.lineWidth;
                if (lineWidth < 1) {
                    opacity *= lineWidth;
                }
                lineStr.push('<g_vml_:stroke', ' opacity="', opacity, '"', ' joinstyle="', ctx.lineJoin, '"', ' miterlimit="', ctx.miterLimit, '"', ' endcap="', processLineCap(ctx.lineCap), '"', ' weight="', lineWidth, 'px"', ' color="', color, '" />');
            }
            function appendFill(ctx, lineStr, min, max) {
                var fillStyle = ctx.fillStyle;
                var arcScaleX = ctx.scaleX_;
                var arcScaleY = ctx.scaleY_;
                var width = max.x - min.x;
                var height = max.y - min.y;
                if (fillStyle instanceof CanvasGradient_) {
                    var angle = 0;
                    var focus = {
                        x: 0,
                        y: 0
                    };
                    var shift = 0;
                    var expansion = 1;
                    if (fillStyle.type_ == 'gradient') {
                        var x0 = fillStyle.x0_ / arcScaleX;
                        var y0 = fillStyle.y0_ / arcScaleY;
                        var x1 = fillStyle.x1_ / arcScaleX;
                        var y1 = fillStyle.y1_ / arcScaleY;
                        var p0 = getCoords(ctx, x0, y0);
                        var p1 = getCoords(ctx, x1, y1);
                        var dx = p1.x - p0.x;
                        var dy = p1.y - p0.y;
                        angle = Math.atan2(dx, dy) * 180 / Math.PI;
                        if (angle < 0) {
                            angle += 360;
                        }
                        if (angle < 0.000001) {
                            angle = 0;
                        }
                    } else {
                        var p0 = getCoords(ctx, fillStyle.x0_, fillStyle.y0_);
                        focus = {
                            x: (p0.x - min.x) / width,
                            y: (p0.y - min.y) / height
                        };
                        width /= arcScaleX * Z;
                        height /= arcScaleY * Z;
                        var dimension = m.max(width, height);
                        shift = 2 * fillStyle.r0_ / dimension;
                        expansion = 2 * fillStyle.r1_ / dimension - shift;
                    }
                    var stops = fillStyle.colors_;
                    stops.sort(function (cs1, cs2) {
                        return cs1.offset - cs2.offset;
                    });
                    var length = stops.length;
                    var color1 = stops[0].color;
                    var color2 = stops[length - 1].color;
                    var opacity1 = stops[0].alpha * ctx.globalAlpha;
                    var opacity2 = stops[length - 1].alpha * ctx.globalAlpha;
                    var colors = [];
                    for (var i = 0; i < length; i++) {
                        var stop = stops[i];
                        colors.push(stop.offset * expansion + shift + ' ' + stop.color);
                    }
                    lineStr.push('<g_vml_:fill type="', fillStyle.type_, '"', ' method="none" focus="100%"', ' color="', color1, '"', ' color2="', color2, '"', ' colors="', colors.join(','), '"', ' opacity="', opacity2, '"', ' g_o_:opacity2="', opacity1, '"', ' angle="', angle, '"', ' focusposition="', focus.x, ',', focus.y, '" />');
                } else if (fillStyle instanceof CanvasPattern_) {
                    if (width && height) {
                        var deltaLeft = -min.x;
                        var deltaTop = -min.y;
                        lineStr.push('<g_vml_:fill', ' position="', deltaLeft / width * arcScaleX * arcScaleX, ',', deltaTop / height * arcScaleY * arcScaleY, '"', ' type="tile"', ' src="', fillStyle.src_, '" />');
                    }
                } else {
                    var a = processStyle(ctx.fillStyle);
                    var color = a.color;
                    var opacity = a.alpha * ctx.globalAlpha;
                    lineStr.push('<g_vml_:fill color="', color, '" opacity="', opacity, '" />');
                }
            }
            contextPrototype.fill = function () {
                this.stroke(true);
            };
            contextPrototype.closePath = function () {
                this.currentPath_.push({ type: 'close' });
            };
            function getCoords(ctx, aX, aY) {
                var m = ctx.m_;
                return {
                    x: Z * (aX * m[0][0] + aY * m[1][0] + m[2][0]) - Z2,
                    y: Z * (aX * m[0][1] + aY * m[1][1] + m[2][1]) - Z2
                };
            }
            ;
            contextPrototype.save = function () {
                var o = {};
                copyState(this, o);
                this.aStack_.push(o);
                this.mStack_.push(this.m_);
                this.m_ = matrixMultiply(createMatrixIdentity(), this.m_);
            };
            contextPrototype.restore = function () {
                if (this.aStack_.length) {
                    copyState(this.aStack_.pop(), this);
                    this.m_ = this.mStack_.pop();
                }
            };
            function matrixIsFinite(m) {
                return isFinite(m[0][0]) && isFinite(m[0][1]) && isFinite(m[1][0]) && isFinite(m[1][1]) && isFinite(m[2][0]) && isFinite(m[2][1]);
            }
            function setM(ctx, m, updateLineScale) {
                if (!matrixIsFinite(m)) {
                    return;
                }
                ctx.m_ = m;
                ctx.scaleX_ = Math.sqrt(m[0][0] * m[0][0] + m[0][1] * m[0][1]);
                ctx.scaleY_ = Math.sqrt(m[1][0] * m[1][0] + m[1][1] * m[1][1]);
                if (updateLineScale) {
                    var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];
                    ctx.lineScale_ = sqrt(abs(det));
                }
            }
            contextPrototype.translate = function (aX, aY) {
                var m1 = [
                    [
                        1,
                        0,
                        0
                    ],
                    [
                        0,
                        1,
                        0
                    ],
                    [
                        aX,
                        aY,
                        1
                    ]
                ];
                setM(this, matrixMultiply(m1, this.m_), false);
            };
            contextPrototype.rotate = function (aRot) {
                var c = mc(aRot);
                var s = ms(aRot);
                var m1 = [
                    [
                        c,
                        s,
                        0
                    ],
                    [
                        -s,
                        c,
                        0
                    ],
                    [
                        0,
                        0,
                        1
                    ]
                ];
                setM(this, matrixMultiply(m1, this.m_), false);
            };
            contextPrototype.scale = function (aX, aY) {
                var m1 = [
                    [
                        aX,
                        0,
                        0
                    ],
                    [
                        0,
                        aY,
                        0
                    ],
                    [
                        0,
                        0,
                        1
                    ]
                ];
                setM(this, matrixMultiply(m1, this.m_), true);
            };
            contextPrototype.transform = function (m11, m12, m21, m22, dx, dy) {
                var m1 = [
                    [
                        m11,
                        m12,
                        0
                    ],
                    [
                        m21,
                        m22,
                        0
                    ],
                    [
                        dx,
                        dy,
                        1
                    ]
                ];
                setM(this, matrixMultiply(m1, this.m_), true);
            };
            contextPrototype.setTransform = function (m11, m12, m21, m22, dx, dy) {
                var m = [
                    [
                        m11,
                        m12,
                        0
                    ],
                    [
                        m21,
                        m22,
                        0
                    ],
                    [
                        dx,
                        dy,
                        1
                    ]
                ];
                setM(this, m, true);
            };
            contextPrototype.drawText_ = function (text, x, y, maxWidth, stroke) {
                var m = this.m_, delta = 1000, left = 0, right = delta, offset = {
                        x: 0,
                        y: 0
                    }, lineStr = [];
                var fontStyle = getComputedStyle(processFontStyle(this.font), this.element_);
                var fontStyleString = buildStyle(fontStyle);
                var elementStyle = this.element_.currentStyle;
                var textAlign = this.textAlign.toLowerCase();
                switch (textAlign) {
                case 'left':
                case 'center':
                case 'right':
                    break;
                case 'end':
                    textAlign = elementStyle.direction == 'ltr' ? 'right' : 'left';
                    break;
                case 'start':
                    textAlign = elementStyle.direction == 'rtl' ? 'right' : 'left';
                    break;
                default:
                    textAlign = 'left';
                }
                switch (this.textBaseline) {
                case 'hanging':
                case 'top':
                    offset.y = fontStyle.size / 1.75;
                    break;
                case 'middle':
                    break;
                default:
                case null:
                case 'alphabetic':
                case 'ideographic':
                case 'bottom':
                    offset.y = -fontStyle.size / 2.25;
                    break;
                }
                switch (textAlign) {
                case 'right':
                    left = delta;
                    right = 0.05;
                    break;
                case 'center':
                    left = right = delta / 2;
                    break;
                }
                var d = getCoords(this, x + offset.x, y + offset.y);
                lineStr.push('<g_vml_:line from="', -left, ' 0" to="', right, ' 0.05" ', ' coordsize="100 100" coordorigin="0 0"', ' filled="', !stroke, '" stroked="', !!stroke, '" style="position:absolute;width:1px;height:1px;">');
                if (stroke) {
                    appendStroke(this, lineStr);
                } else {
                    appendFill(this, lineStr, {
                        x: -left,
                        y: 0
                    }, {
                        x: right,
                        y: fontStyle.size
                    });
                }
                var skewM = m[0][0].toFixed(3) + ',' + m[1][0].toFixed(3) + ',' + m[0][1].toFixed(3) + ',' + m[1][1].toFixed(3) + ',0,0';
                var skewOffset = mr(d.x / Z) + ',' + mr(d.y / Z);
                lineStr.push('<g_vml_:skew on="t" matrix="', skewM, '" ', ' offset="', skewOffset, '" origin="', left, ' 0" />', '<g_vml_:path textpathok="true" />', '<g_vml_:textpath on="true" string="', encodeHtmlAttribute(text), '" style="v-text-align:', textAlign, ';font:', encodeHtmlAttribute(fontStyleString), '" /></g_vml_:line>');
                this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
            };
            contextPrototype.fillText = function (text, x, y, maxWidth) {
                this.drawText_(text, x, y, maxWidth, false);
            };
            contextPrototype.strokeText = function (text, x, y, maxWidth) {
                this.drawText_(text, x, y, maxWidth, true);
            };
            contextPrototype.measureText = function (text) {
                if (!this.textMeasureEl_) {
                    var s = '<span style="position:absolute;' + 'top:-20000px;left:0;padding:0;margin:0;border:none;' + 'white-space:pre;"></span>';
                    this.element_.insertAdjacentHTML('beforeEnd', s);
                    this.textMeasureEl_ = this.element_.lastChild;
                }
                var doc = this.element_.ownerDocument;
                this.textMeasureEl_.innerHTML = '';
                try {
                    this.textMeasureEl_.style.font = this.font;
                } catch (ex) {
                }
                this.textMeasureEl_.appendChild(doc.createTextNode(text));
                return { width: this.textMeasureEl_.offsetWidth };
            };
            contextPrototype.clip = function () {
            };
            contextPrototype.arcTo = function () {
            };
            contextPrototype.createPattern = function (image, repetition) {
                return new CanvasPattern_(image, repetition);
            };
            function CanvasGradient_(aType) {
                this.type_ = aType;
                this.x0_ = 0;
                this.y0_ = 0;
                this.r0_ = 0;
                this.x1_ = 0;
                this.y1_ = 0;
                this.r1_ = 0;
                this.colors_ = [];
            }
            CanvasGradient_.prototype.addColorStop = function (aOffset, aColor) {
                aColor = processStyle(aColor);
                this.colors_.push({
                    offset: aOffset,
                    color: aColor.color,
                    alpha: aColor.alpha
                });
            };
            function CanvasPattern_(image, repetition) {
                assertImageIsValid(image);
                switch (repetition) {
                case 'repeat':
                case null:
                case '':
                    this.repetition_ = 'repeat';
                    break;
                case 'repeat-x':
                case 'repeat-y':
                case 'no-repeat':
                    this.repetition_ = repetition;
                    break;
                default:
                    throwException('SYNTAX_ERR');
                }
                this.src_ = image.src;
                this.width_ = image.width;
                this.height_ = image.height;
            }
            function throwException(s) {
                throw new DOMException_(s);
            }
            function assertImageIsValid(img) {
                if (!img || img.nodeType != 1 || img.tagName != 'IMG') {
                    throwException('TYPE_MISMATCH_ERR');
                }
                if (img.readyState != 'complete') {
                    throwException('INVALID_STATE_ERR');
                }
            }
            function DOMException_(s) {
                this.code = this[s];
                this.message = s + ': DOM Exception ' + this.code;
            }
            var p = DOMException_.prototype = new Error();
            p.INDEX_SIZE_ERR = 1;
            p.DOMSTRING_SIZE_ERR = 2;
            p.HIERARCHY_REQUEST_ERR = 3;
            p.WRONG_DOCUMENT_ERR = 4;
            p.INVALID_CHARACTER_ERR = 5;
            p.NO_DATA_ALLOWED_ERR = 6;
            p.NO_MODIFICATION_ALLOWED_ERR = 7;
            p.NOT_FOUND_ERR = 8;
            p.NOT_SUPPORTED_ERR = 9;
            p.INUSE_ATTRIBUTE_ERR = 10;
            p.INVALID_STATE_ERR = 11;
            p.SYNTAX_ERR = 12;
            p.INVALID_MODIFICATION_ERR = 13;
            p.NAMESPACE_ERR = 14;
            p.INVALID_ACCESS_ERR = 15;
            p.VALIDATION_ERR = 16;
            p.TYPE_MISMATCH_ERR = 17;
            G_vmlCanvasManager = G_vmlCanvasManager_;
            CanvasRenderingContext2D = CanvasRenderingContext2D_;
            CanvasGradient = CanvasGradient_;
            CanvasPattern = CanvasPattern_;
            DOMException = DOMException_;
        }());
    } else {
        G_vmlCanvasManager = false;
    }
    return G_vmlCanvasManager;
});define('zrender/mixin/Eventful', ['require'], function (require) {
    var Eventful = function () {
        this._handlers = {};
    };
    Eventful.prototype.one = function (event, handler, context) {
        var _h = this._handlers;
        if (!handler || !event) {
            return this;
        }
        if (!_h[event]) {
            _h[event] = [];
        }
        _h[event].push({
            h: handler,
            one: true,
            ctx: context || this
        });
        return this;
    };
    Eventful.prototype.bind = function (event, handler, context) {
        var _h = this._handlers;
        if (!handler || !event) {
            return this;
        }
        if (!_h[event]) {
            _h[event] = [];
        }
        _h[event].push({
            h: handler,
            one: false,
            ctx: context || this
        });
        return this;
    };
    Eventful.prototype.unbind = function (event, handler) {
        var _h = this._handlers;
        if (!event) {
            this._handlers = {};
            return this;
        }
        if (handler) {
            if (_h[event]) {
                var newList = [];
                for (var i = 0, l = _h[event].length; i < l; i++) {
                    if (_h[event][i]['h'] != handler) {
                        newList.push(_h[event][i]);
                    }
                }
                _h[event] = newList;
            }
            if (_h[event] && _h[event].length === 0) {
                delete _h[event];
            }
        } else {
            delete _h[event];
        }
        return this;
    };
    Eventful.prototype.dispatch = function (type) {
        if (this._handlers[type]) {
            var args = arguments;
            var argLen = args.length;
            if (argLen > 3) {
                args = Array.prototype.slice.call(args, 1);
            }
            var _h = this._handlers[type];
            var len = _h.length;
            for (var i = 0; i < len;) {
                switch (argLen) {
                case 1:
                    _h[i]['h'].call(_h[i]['ctx']);
                    break;
                case 2:
                    _h[i]['h'].call(_h[i]['ctx'], args[1]);
                    break;
                case 3:
                    _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);
                    break;
                default:
                    _h[i]['h'].apply(_h[i]['ctx'], args);
                    break;
                }
                if (_h[i]['one']) {
                    _h.splice(i, 1);
                    len--;
                } else {
                    i++;
                }
            }
        }
        return this;
    };
    Eventful.prototype.dispatchWithContext = function (type) {
        if (this._handlers[type]) {
            var args = arguments;
            var argLen = args.length;
            if (argLen > 4) {
                args = Array.prototype.slice.call(args, 1, args.length - 1);
            }
            var ctx = args[args.length - 1];
            var _h = this._handlers[type];
            var len = _h.length;
            for (var i = 0; i < len;) {
                switch (argLen) {
                case 1:
                    _h[i]['h'].call(ctx);
                    break;
                case 2:
                    _h[i]['h'].call(ctx, args[1]);
                    break;
                case 3:
                    _h[i]['h'].call(ctx, args[1], args[2]);
                    break;
                default:
                    _h[i]['h'].apply(ctx, args);
                    break;
                }
                if (_h[i]['one']) {
                    _h.splice(i, 1);
                    len--;
                } else {
                    i++;
                }
            }
        }
        return this;
    };
    return Eventful;
});define('zrender/tool/log', [
    'require',
    '../config'
], function (require) {
    var config = require('../config');
    return function () {
        if (config.debugMode === 0) {
            return;
        } else if (config.debugMode == 1) {
            for (var k in arguments) {
                throw new Error(arguments[k]);
            }
        } else if (config.debugMode > 1) {
            for (var k in arguments) {
                console.log(arguments[k]);
            }
        }
    };
});define('zrender/tool/guid', [], function () {
    var idStart = 2311;
    return function () {
        return 'zrender__' + idStart++;
    };
});define('zrender/Handler', [
    'require',
    './config',
    './tool/env',
    './tool/event',
    './tool/util',
    './tool/vector',
    './tool/matrix',
    './mixin/Eventful'
], function (require) {
    'use strict';
    var config = require('./config');
    var env = require('./tool/env');
    var eventTool = require('./tool/event');
    var util = require('./tool/util');
    var vec2 = require('./tool/vector');
    var mat2d = require('./tool/matrix');
    var EVENT = config.EVENT;
    var Eventful = require('./mixin/Eventful');
    var domHandlerNames = [
        'resize',
        'click',
        'dblclick',
        'mousewheel',
        'mousemove',
        'mouseout',
        'mouseup',
        'mousedown',
        'touchstart',
        'touchend',
        'touchmove'
    ];
    var domHandlers = {
        resize: function (event) {
            event = event || window.event;
            this._lastHover = null;
            this._isMouseDown = 0;
            this.dispatch(EVENT.RESIZE, event);
        },
        click: function (event) {
            event = this._zrenderEventFixed(event);
            var _lastHover = this._lastHover;
            if (_lastHover && _lastHover.clickable || !_lastHover) {
                if (this._clickThreshold < 5) {
                    this._dispatchAgency(_lastHover, EVENT.CLICK, event);
                }
            }
            this._mousemoveHandler(event);
        },
        dblclick: function (event) {
            event = event || window.event;
            event = this._zrenderEventFixed(event);
            var _lastHover = this._lastHover;
            if (_lastHover && _lastHover.clickable || !_lastHover) {
                if (this._clickThreshold < 5) {
                    this._dispatchAgency(_lastHover, EVENT.DBLCLICK, event);
                }
            }
            this._mousemoveHandler(event);
        },
        mousewheel: function (event) {
            event = this._zrenderEventFixed(event);
            var delta = event.wheelDelta || -event.detail;
            var scale = delta > 0 ? 1.1 : 1 / 1.1;
            var needsRefresh = false;
            var mouseX = this._mouseX;
            var mouseY = this._mouseY;
            this.painter.eachBuildinLayer(function (layer) {
                var pos = layer.position;
                if (layer.zoomable) {
                    layer.__zoom = layer.__zoom || 1;
                    var newZoom = layer.__zoom;
                    newZoom *= scale;
                    newZoom = Math.max(Math.min(layer.maxZoom, newZoom), layer.minZoom);
                    scale = newZoom / layer.__zoom;
                    layer.__zoom = newZoom;
                    pos[0] -= (mouseX - pos[0]) * (scale - 1);
                    pos[1] -= (mouseY - pos[1]) * (scale - 1);
                    layer.scale[0] *= scale;
                    layer.scale[1] *= scale;
                    layer.dirty = true;
                    needsRefresh = true;
                    eventTool.stop(event);
                }
            });
            if (needsRefresh) {
                this.painter.refresh();
            }
            this._dispatchAgency(this._lastHover, EVENT.MOUSEWHEEL, event);
            this._mousemoveHandler(event);
        },
        mousemove: function (event) {
            if (this.painter.isLoading()) {
                return;
            }
            event = this._zrenderEventFixed(event);
            this._lastX = this._mouseX;
            this._lastY = this._mouseY;
            this._mouseX = eventTool.getX(event);
            this._mouseY = eventTool.getY(event);
            var dx = this._mouseX - this._lastX;
            var dy = this._mouseY - this._lastY;
            this._processDragStart(event);
            this._hasfound = 0;
            this._event = event;
            this._iterateAndFindHover();
            if (!this._hasfound) {
                if (!this._draggingTarget || this._lastHover && this._lastHover != this._draggingTarget) {
                    this._processOutShape(event);
                    this._processDragLeave(event);
                }
                this._lastHover = null;
                this.storage.delHover();
                this.painter.clearHover();
            }
            var cursor = 'default';
            if (this._draggingTarget) {
                this.storage.drift(this._draggingTarget.id, dx, dy);
                this._draggingTarget.modSelf();
                this.storage.addHover(this._draggingTarget);
                this._clickThreshold++;
            } else if (this._isMouseDown) {
                var needsRefresh = false;
                this.painter.eachBuildinLayer(function (layer) {
                    if (layer.panable) {
                        cursor = 'move';
                        layer.position[0] += dx;
                        layer.position[1] += dy;
                        needsRefresh = true;
                        layer.dirty = true;
                    }
                });
                if (needsRefresh) {
                    this.painter.refresh();
                }
            }
            if (this._draggingTarget || this._hasfound && this._lastHover.draggable) {
                cursor = 'move';
            } else if (this._hasfound && this._lastHover.clickable) {
                cursor = 'pointer';
            }
            this.root.style.cursor = cursor;
            this._dispatchAgency(this._lastHover, EVENT.MOUSEMOVE, event);
            if (this._draggingTarget || this._hasfound || this.storage.hasHoverShape()) {
                this.painter.refreshHover();
            }
        },
        mouseout: function (event) {
            event = this._zrenderEventFixed(event);
            var element = event.toElement || event.relatedTarget;
            if (element != this.root) {
                while (element && element.nodeType != 9) {
                    if (element == this.root) {
                        this._mousemoveHandler(event);
                        return;
                    }
                    element = element.parentNode;
                }
            }
            event.zrenderX = this._lastX;
            event.zrenderY = this._lastY;
            this.root.style.cursor = 'default';
            this._isMouseDown = 0;
            this._processOutShape(event);
            this._processDrop(event);
            this._processDragEnd(event);
            if (!this.painter.isLoading()) {
                this.painter.refreshHover();
            }
            this.dispatch(EVENT.GLOBALOUT, event);
        },
        mousedown: function (event) {
            this._clickThreshold = 0;
            if (this._lastDownButton == 2) {
                this._lastDownButton = event.button;
                this._mouseDownTarget = null;
                return;
            }
            this._lastMouseDownMoment = new Date();
            event = this._zrenderEventFixed(event);
            this._isMouseDown = 1;
            this._mouseDownTarget = this._lastHover;
            this._dispatchAgency(this._lastHover, EVENT.MOUSEDOWN, event);
            this._lastDownButton = event.button;
        },
        mouseup: function (event) {
            event = this._zrenderEventFixed(event);
            this.root.style.cursor = 'default';
            this._isMouseDown = 0;
            this._mouseDownTarget = null;
            this._dispatchAgency(this._lastHover, EVENT.MOUSEUP, event);
            this._processDrop(event);
            this._processDragEnd(event);
        },
        touchstart: function (event) {
            event = this._zrenderEventFixed(event, true);
            this._lastTouchMoment = new Date();
            this._mobileFindFixed(event);
            this._mousedownHandler(event);
        },
        touchmove: function (event) {
            event = this._zrenderEventFixed(event, true);
            this._mousemoveHandler(event);
            if (this._isDragging) {
                eventTool.stop(event);
            }
        },
        touchend: function (event) {
            event = this._zrenderEventFixed(event, true);
            this._mouseupHandler(event);
            var now = new Date();
            if (now - this._lastTouchMoment < EVENT.touchClickDelay) {
                this._mobileFindFixed(event);
                this._clickHandler(event);
                if (now - this._lastClickMoment < EVENT.touchClickDelay / 2) {
                    this._dblclickHandler(event);
                    if (this._lastHover && this._lastHover.clickable) {
                        eventTool.stop(event);
                    }
                }
                this._lastClickMoment = now;
            }
            this.painter.clearHover();
        }
    };
    function bind1Arg(handler, context) {
        return function (e) {
            return handler.call(context, e);
        };
    }
    function bind3Arg(handler, context) {
        return function (arg1, arg2, arg3) {
            return handler.call(context, arg1, arg2, arg3);
        };
    }
    function initDomHandler(instance) {
        var len = domHandlerNames.length;
        while (len--) {
            var name = domHandlerNames[len];
            instance['_' + name + 'Handler'] = bind1Arg(domHandlers[name], instance);
        }
    }
    var Handler = function (root, storage, painter) {
        Eventful.call(this);
        this.root = root;
        this.storage = storage;
        this.painter = painter;
        this._lastX = this._lastY = this._mouseX = this._mouseY = 0;
        this._findHover = bind3Arg(findHover, this);
        this._domHover = painter.getDomHover();
        initDomHandler(this);
        if (window.addEventListener) {
            window.addEventListener('resize', this._resizeHandler);
            if (env.os.tablet || env.os.phone) {
                root.addEventListener('touchstart', this._touchstartHandler);
                root.addEventListener('touchmove', this._touchmoveHandler);
                root.addEventListener('touchend', this._touchendHandler);
            } else {
                root.addEventListener('click', this._clickHandler);
                root.addEventListener('dblclick', this._dblclickHandler);
                root.addEventListener('mousewheel', this._mousewheelHandler);
                root.addEventListener('mousemove', this._mousemoveHandler);
                root.addEventListener('mousedown', this._mousedownHandler);
                root.addEventListener('mouseup', this._mouseupHandler);
            }
            root.addEventListener('DOMMouseScroll', this._mousewheelHandler);
            root.addEventListener('mouseout', this._mouseoutHandler);
        } else {
            window.attachEvent('onresize', this._resizeHandler);
            root.attachEvent('onclick', this._clickHandler);
            root.ondblclick = this._dblclickHandler;
            root.attachEvent('onmousewheel', this._mousewheelHandler);
            root.attachEvent('onmousemove', this._mousemoveHandler);
            root.attachEvent('onmouseout', this._mouseoutHandler);
            root.attachEvent('onmousedown', this._mousedownHandler);
            root.attachEvent('onmouseup', this._mouseupHandler);
        }
    };
    Handler.prototype.on = function (eventName, handler, context) {
        this.bind(eventName, handler, context);
        return this;
    };
    Handler.prototype.un = function (eventName, handler) {
        this.unbind(eventName, handler);
        return this;
    };
    Handler.prototype.trigger = function (eventName, eventArgs) {
        switch (eventName) {
        case EVENT.RESIZE:
        case EVENT.CLICK:
        case EVENT.DBLCLICK:
        case EVENT.MOUSEWHEEL:
        case EVENT.MOUSEMOVE:
        case EVENT.MOUSEDOWN:
        case EVENT.MOUSEUP:
        case EVENT.MOUSEOUT:
            this['_' + eventName + 'Handler'](eventArgs);
            break;
        }
    };
    Handler.prototype.dispose = function () {
        var root = this.root;
        if (window.removeEventListener) {
            window.removeEventListener('resize', this._resizeHandler);
            if (env.os.tablet || env.os.phone) {
                root.removeEventListener('touchstart', this._touchstartHandler);
                root.removeEventListener('touchmove', this._touchmoveHandler);
                root.removeEventListener('touchend', this._touchendHandler);
            } else {
                root.removeEventListener('click', this._clickHandler);
                root.removeEventListener('dblclick', this._dblclickHandler);
                root.removeEventListener('mousewheel', this._mousewheelHandler);
                root.removeEventListener('mousemove', this._mousemoveHandler);
                root.removeEventListener('mousedown', this._mousedownHandler);
                root.removeEventListener('mouseup', this._mouseupHandler);
            }
            root.removeEventListener('DOMMouseScroll', this._mousewheelHandler);
            root.removeEventListener('mouseout', this._mouseoutHandler);
        } else {
            window.detachEvent('onresize', this._resizeHandler);
            root.detachEvent('onclick', this._clickHandler);
            root.detachEvent('dblclick', this._dblclickHandler);
            root.detachEvent('onmousewheel', this._mousewheelHandler);
            root.detachEvent('onmousemove', this._mousemoveHandler);
            root.detachEvent('onmouseout', this._mouseoutHandler);
            root.detachEvent('onmousedown', this._mousedownHandler);
            root.detachEvent('onmouseup', this._mouseupHandler);
        }
        this.root = this._domHover = this.storage = this.painter = null;
        this.un();
    };
    Handler.prototype._processDragStart = function (event) {
        var _lastHover = this._lastHover;
        if (this._isMouseDown && _lastHover && _lastHover.draggable && !this._draggingTarget && this._mouseDownTarget == _lastHover) {
            if (_lastHover.dragEnableTime && new Date() - this._lastMouseDownMoment < _lastHover.dragEnableTime) {
                return;
            }
            var _draggingTarget = _lastHover;
            this._draggingTarget = _draggingTarget;
            this._isDragging = 1;
            _draggingTarget.invisible = true;
            this.storage.mod(_draggingTarget.id);
            this._dispatchAgency(_draggingTarget, EVENT.DRAGSTART, event);
            this.painter.refresh();
        }
    };
    Handler.prototype._processDragEnter = function (event) {
        if (this._draggingTarget) {
            this._dispatchAgency(this._lastHover, EVENT.DRAGENTER, event, this._draggingTarget);
        }
    };
    Handler.prototype._processDragOver = function (event) {
        if (this._draggingTarget) {
            this._dispatchAgency(this._lastHover, EVENT.DRAGOVER, event, this._draggingTarget);
        }
    };
    Handler.prototype._processDragLeave = function (event) {
        if (this._draggingTarget) {
            this._dispatchAgency(this._lastHover, EVENT.DRAGLEAVE, event, this._draggingTarget);
        }
    };
    Handler.prototype._processDrop = function (event) {
        if (this._draggingTarget) {
            this._draggingTarget.invisible = false;
            this.storage.mod(this._draggingTarget.id);
            this.painter.refresh();
            this._dispatchAgency(this._lastHover, EVENT.DROP, event, this._draggingTarget);
        }
    };
    Handler.prototype._processDragEnd = function (event) {
        if (this._draggingTarget) {
            this._dispatchAgency(this._draggingTarget, EVENT.DRAGEND, event);
            this._lastHover = null;
        }
        this._isDragging = 0;
        this._draggingTarget = null;
    };
    Handler.prototype._processOverShape = function (event) {
        this._dispatchAgency(this._lastHover, EVENT.MOUSEOVER, event);
    };
    Handler.prototype._processOutShape = function (event) {
        this._dispatchAgency(this._lastHover, EVENT.MOUSEOUT, event);
    };
    Handler.prototype._dispatchAgency = function (targetShape, eventName, event, draggedShape) {
        var eventHandler = 'on' + eventName;
        var eventPacket = {
            type: eventName,
            event: event,
            target: targetShape,
            cancelBubble: false
        };
        var el = targetShape;
        if (draggedShape) {
            eventPacket.dragged = draggedShape;
        }
        while (el) {
            el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler](eventPacket));
            el.dispatch(eventName, eventPacket);
            el = el.parent;
            if (eventPacket.cancelBubble) {
                break;
            }
        }
        if (targetShape) {
            if (!eventPacket.cancelBubble) {
                this.dispatch(eventName, eventPacket);
            }
        } else if (!draggedShape) {
            var eveObj = {
                type: eventName,
                event: event
            };
            this.dispatch(eventName, eveObj);
            this.painter.eachOtherLayer(function (layer) {
                if (typeof layer[eventHandler] == 'function') {
                    layer[eventHandler](eveObj);
                }
                if (layer.dispatch) {
                    layer.dispatch(eventName, eveObj);
                }
            });
        }
    };
    Handler.prototype._iterateAndFindHover = function () {
        var invTransform = mat2d.create();
        return function () {
            var list = this.storage.getShapeList();
            var currentZLevel;
            var currentLayer;
            var tmp = [
                0,
                0
            ];
            for (var i = list.length - 1; i >= 0; i--) {
                var shape = list[i];
                if (currentZLevel !== shape.zlevel) {
                    currentLayer = this.painter.getLayer(shape.zlevel, currentLayer);
                    tmp[0] = this._mouseX;
                    tmp[1] = this._mouseY;
                    if (currentLayer.needTransform) {
                        mat2d.invert(invTransform, currentLayer.transform);
                        vec2.applyTransform(tmp, tmp, invTransform);
                    }
                }
                if (this._findHover(shape, tmp[0], tmp[1])) {
                    break;
                }
            }
        };
    }();
    var MOBILE_TOUCH_OFFSETS = [
        { x: 10 },
        { x: -20 },
        {
            x: 10,
            y: 10
        },
        { y: -20 }
    ];
    Handler.prototype._mobileFindFixed = function (event) {
        this._lastHover = null;
        this._mouseX = event.zrenderX;
        this._mouseY = event.zrenderY;
        this._event = event;
        this._iterateAndFindHover();
        for (var i = 0; !this._lastHover && i < MOBILE_TOUCH_OFFSETS.length; i++) {
            var offset = MOBILE_TOUCH_OFFSETS[i];
            offset.x && (this._mouseX += offset.x);
            offset.y && (this._mouseY += offset.y);
            this._iterateAndFindHover();
        }
        if (this._lastHover) {
            event.zrenderX = this._mouseX;
            event.zrenderY = this._mouseY;
        }
    };
    function findHover(shape, x, y) {
        if (this._draggingTarget && this._draggingTarget.id == shape.id || shape.isSilent()) {
            return false;
        }
        var event = this._event;
        if (shape.isCover(x, y)) {
            if (shape.hoverable) {
                this.storage.addHover(shape);
            }
            var p = shape.parent;
            while (p) {
                if (p.clipShape && !p.clipShape.isCover(this._mouseX, this._mouseY)) {
                    return false;
                }
                p = p.parent;
            }
            if (this._lastHover != shape) {
                this._processOutShape(event);
                this._processDragLeave(event);
                this._lastHover = shape;
                this._processDragEnter(event);
            }
            this._processOverShape(event);
            this._processDragOver(event);
            this._hasfound = 1;
            return true;
        }
        return false;
    }
    Handler.prototype._zrenderEventFixed = function (event, isTouch) {
        if (event.zrenderFixed) {
            return event;
        }
        if (!isTouch) {
            event = event || window.event;
            var target = event.toElement || event.relatedTarget || event.srcElement || event.target;
            if (target && target != this._domHover) {
                event.zrenderX = (typeof event.offsetX != 'undefined' ? event.offsetX : event.layerX) + target.offsetLeft;
                event.zrenderY = (typeof event.offsetY != 'undefined' ? event.offsetY : event.layerY) + target.offsetTop;
            }
        } else {
            var touch = event.type != 'touchend' ? event.targetTouches[0] : event.changedTouches[0];
            if (touch) {
                var rBounding = this.painter._domRoot.getBoundingClientRect();
                event.zrenderX = touch.clientX - rBounding.left;
                event.zrenderY = touch.clientY - rBounding.top;
            }
        }
        event.zrenderFixed = 1;
        return event;
    };
    util.merge(Handler.prototype, Eventful.prototype, true);
    return Handler;
});define('zrender/Painter', [
    'require',
    './config',
    './tool/util',
    './tool/log',
    './loadingEffect/Base',
    './Layer',
    './shape/Image'
], function (require) {
    'use strict';
    var config = require('./config');
    var util = require('./tool/util');
    var log = require('./tool/log');
    var BaseLoadingEffect = require('./loadingEffect/Base');
    var Layer = require('./Layer');
    function returnFalse() {
        return false;
    }
    function doNothing() {
    }
    function isLayerValid(layer) {
        if (!layer) {
            return false;
        }
        if (layer.isBuildin) {
            return true;
        }
        if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {
            return false;
        }
        return true;
    }
    var Painter = function (root, storage) {
        this.root = root;
        root.style['-webkit-tap-highlight-color'] = 'transparent';
        root.style['-webkit-user-select'] = 'none';
        root.style['user-select'] = 'none';
        root.style['-webkit-touch-callout'] = 'none';
        this.storage = storage;
        root.innerHTML = '';
        this._width = this._getWidth();
        this._height = this._getHeight();
        var domRoot = document.createElement('div');
        this._domRoot = domRoot;
        domRoot.style.position = 'relative';
        domRoot.style.overflow = 'hidden';
        domRoot.style.width = this._width + 'px';
        domRoot.style.height = this._height + 'px';
        root.appendChild(domRoot);
        this._layers = {};
        this._zlevelList = [];
        this._layerConfig = {};
        this._loadingEffect = new BaseLoadingEffect({});
        this.shapeToImage = this._createShapeToImageProcessor();
        this._bgDom = document.createElement('div');
        this._bgDom.style.cssText = [
            'position:absolute;left:0px;top:0px;width:',
            this._width,
            'px;height:',
            this._height + 'px;',
            '-webkit-user-select:none;user-select;none;',
            '-webkit-touch-callout:none;'
        ].join('');
        this._bgDom.setAttribute('data-zr-dom-id', 'bg');
        domRoot.appendChild(this._bgDom);
        this._bgDom.onselectstart = returnFalse;
        var hoverLayer = new Layer('_zrender_hover_', this);
        this._layers['hover'] = hoverLayer;
        domRoot.appendChild(hoverLayer.dom);
        hoverLayer.initContext();
        hoverLayer.dom.onselectstart = returnFalse;
        hoverLayer.dom.style['-webkit-user-select'] = 'none';
        hoverLayer.dom.style['user-select'] = 'none';
        hoverLayer.dom.style['-webkit-touch-callout'] = 'none';
        this.refreshNextFrame = null;
    };
    Painter.prototype.render = function (callback) {
        if (this.isLoading()) {
            this.hideLoading();
        }
        this.refresh(callback, true);
        return this;
    };
    Painter.prototype.refresh = function (callback, paintAll) {
        var list = this.storage.getShapeList(true);
        this._paintList(list, paintAll);
        for (var i = 0; i < this._zlevelList.length; i++) {
            var z = this._zlevelList[i];
            var layer = this._layers[z];
            if (!layer.isBuildin && layer.refresh) {
                layer.refresh();
            }
        }
        if (typeof callback == 'function') {
            callback();
        }
        return this;
    };
    Painter.prototype._preProcessLayer = function (layer) {
        layer.unusedCount++;
        layer.updateTransform();
    };
    Painter.prototype._postProcessLayer = function (layer) {
        layer.dirty = false;
        if (layer.unusedCount == 1) {
            layer.clear();
        }
    };
    Painter.prototype._paintList = function (list, paintAll) {
        if (typeof paintAll == 'undefined') {
            paintAll = false;
        }
        this._updateLayerStatus(list);
        var currentLayer;
        var currentZLevel;
        var ctx;
        this.eachBuildinLayer(this._preProcessLayer);
        for (var i = 0, l = list.length; i < l; i++) {
            var shape = list[i];
            if (currentZLevel !== shape.zlevel) {
                if (currentLayer) {
                    if (currentLayer.needTransform) {
                        ctx.restore();
                    }
                    ctx.flush && ctx.flush();
                }
                currentZLevel = shape.zlevel;
                currentLayer = this.getLayer(currentZLevel);
                if (!currentLayer.isBuildin) {
                    log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);
                }
                ctx = currentLayer.ctx;
                currentLayer.unusedCount = 0;
                if (currentLayer.dirty || paintAll) {
                    currentLayer.clear();
                }
                if (currentLayer.needTransform) {
                    ctx.save();
                    currentLayer.setTransform(ctx);
                }
            }
            if ((currentLayer.dirty || paintAll) && !shape.invisible) {
                if (!shape.onbrush || shape.onbrush && !shape.onbrush(ctx, false)) {
                    if (config.catchBrushException) {
                        try {
                            shape.brush(ctx, false, this.refreshNextFrame);
                        } catch (error) {
                            log(error, 'brush error of ' + shape.type, shape);
                        }
                    } else {
                        shape.brush(ctx, false, this.refreshNextFrame);
                    }
                }
            }
            shape.__dirty = false;
        }
        if (currentLayer) {
            if (currentLayer.needTransform) {
                ctx.restore();
            }
            ctx.flush && ctx.flush();
        }
        this.eachBuildinLayer(this._postProcessLayer);
    };
    Painter.prototype.getLayer = function (zlevel) {
        var layer = this._layers[zlevel];
        if (!layer) {
            layer = new Layer(zlevel, this);
            layer.isBuildin = true;
            if (this._layerConfig[zlevel]) {
                util.merge(layer, this._layerConfig[zlevel], true);
            }
            layer.updateTransform();
            this.insertLayer(zlevel, layer);
            layer.initContext();
        }
        return layer;
    };
    Painter.prototype.insertLayer = function (zlevel, layer) {
        if (this._layers[zlevel]) {
            log('ZLevel ' + zlevel + ' has been used already');
            return;
        }
        if (!isLayerValid(layer)) {
            log('Layer of zlevel ' + zlevel + ' is not valid');
            return;
        }
        var len = this._zlevelList.length;
        var prevLayer = null;
        var i = -1;
        if (len > 0 && zlevel > this._zlevelList[0]) {
            for (i = 0; i < len - 1; i++) {
                if (this._zlevelList[i] < zlevel && this._zlevelList[i + 1] > zlevel) {
                    break;
                }
            }
            prevLayer = this._layers[this._zlevelList[i]];
        }
        this._zlevelList.splice(i + 1, 0, zlevel);
        var prevDom = prevLayer ? prevLayer.dom : this._bgDom;
        if (prevDom.nextSibling) {
            prevDom.parentNode.insertBefore(layer.dom, prevDom.nextSibling);
        } else {
            prevDom.parentNode.appendChild(layer.dom);
        }
        this._layers[zlevel] = layer;
    };
    Painter.prototype.eachLayer = function (cb, context) {
        for (var i = 0; i < this._zlevelList.length; i++) {
            var z = this._zlevelList[i];
            cb.call(context, this._layers[z], z);
        }
    };
    Painter.prototype.eachBuildinLayer = function (cb, context) {
        for (var i = 0; i < this._zlevelList.length; i++) {
            var z = this._zlevelList[i];
            var layer = this._layers[z];
            if (layer.isBuildin) {
                cb.call(context, layer, z);
            }
        }
    };
    Painter.prototype.eachOtherLayer = function (cb, context) {
        for (var i = 0; i < this._zlevelList.length; i++) {
            var z = this._zlevelList[i];
            var layer = this._layers[z];
            if (!layer.isBuildin) {
                cb.call(context, layer, z);
            }
        }
    };
    Painter.prototype.getLayers = function () {
        return this._layers;
    };
    Painter.prototype._updateLayerStatus = function (list) {
        var layers = this._layers;
        var elCounts = {};
        this.eachBuildinLayer(function (layer, z) {
            elCounts[z] = layer.elCount;
            layer.elCount = 0;
        });
        for (var i = 0, l = list.length; i < l; i++) {
            var shape = list[i];
            var zlevel = shape.zlevel;
            var layer = layers[zlevel];
            if (layer) {
                layer.elCount++;
                if (layer.dirty) {
                    continue;
                }
                layer.dirty = shape.__dirty;
            }
        }
        this.eachBuildinLayer(function (layer, z) {
            if (elCounts[z] !== layer.elCount) {
                layer.dirty = true;
            }
        });
    };
    Painter.prototype.refreshShapes = function (shapeList, callback) {
        for (var i = 0, l = shapeList.length; i < l; i++) {
            var shape = shapeList[i];
            shape.modSelf();
        }
        this.refresh(callback);
        return this;
    };
    Painter.prototype.setLoadingEffect = function (loadingEffect) {
        this._loadingEffect = loadingEffect;
        return this;
    };
    Painter.prototype.clear = function () {
        this.eachBuildinLayer(this._clearLayer);
        return this;
    };
    Painter.prototype._clearLayer = function (layer) {
        layer.clear();
    };
    Painter.prototype.modLayer = function (zlevel, config) {
        if (config) {
            if (!this._layerConfig[zlevel]) {
                this._layerConfig[zlevel] = config;
            } else {
                util.merge(this._layerConfig[zlevel], config, true);
            }
            var layer = this._layers[zlevel];
            if (layer) {
                util.merge(layer, this._layerConfig[zlevel], true);
            }
        }
    };
    Painter.prototype.delLayer = function (zlevel) {
        var layer = this._layers[zlevel];
        if (!layer) {
            return;
        }
        this.modLayer(zlevel, {
            position: layer.position,
            rotation: layer.rotation,
            scale: layer.scale
        });
        layer.dom.parentNode.removeChild(layer.dom);
        delete this._layers[zlevel];
        this._zlevelList.splice(util.indexOf(this._zlevelList, zlevel), 1);
    };
    Painter.prototype.refreshHover = function () {
        this.clearHover();
        var list = this.storage.getHoverShapes(true);
        for (var i = 0, l = list.length; i < l; i++) {
            this._brushHover(list[i]);
        }
        var ctx = this._layers.hover.ctx;
        ctx.flush && ctx.flush();
        this.storage.delHover();
        return this;
    };
    Painter.prototype.clearHover = function () {
        var hover = this._layers.hover;
        hover && hover.clear();
        return this;
    };
    Painter.prototype.showLoading = function (loadingEffect) {
        this._loadingEffect && this._loadingEffect.stop();
        loadingEffect && this.setLoadingEffect(loadingEffect);
        this._loadingEffect.start(this);
        this.loading = true;
        return this;
    };
    Painter.prototype.hideLoading = function () {
        this._loadingEffect.stop();
        this.clearHover();
        this.loading = false;
        return this;
    };
    Painter.prototype.isLoading = function () {
        return this.loading;
    };
    Painter.prototype.resize = function () {
        var domRoot = this._domRoot;
        domRoot.style.display = 'none';
        var width = this._getWidth();
        var height = this._getHeight();
        domRoot.style.display = '';
        if (this._width != width || height != this._height) {
            this._width = width;
            this._height = height;
            domRoot.style.width = width + 'px';
            domRoot.style.height = height + 'px';
            for (var id in this._layers) {
                this._layers[id].resize(width, height);
            }
            this.refresh(null, true);
        }
        return this;
    };
    Painter.prototype.clearLayer = function (zLevel) {
        var layer = this._layers[zLevel];
        if (layer) {
            layer.clear();
        }
    };
    Painter.prototype.dispose = function () {
        if (this.isLoading()) {
            this.hideLoading();
        }
        this.root.innerHTML = '';
        this.root = this.storage = this._domRoot = this._layers = null;
    };
    Painter.prototype.getDomHover = function () {
        return this._layers.hover.dom;
    };
    Painter.prototype.toDataURL = function (type, backgroundColor, args) {
        if (window['G_vmlCanvasManager']) {
            return null;
        }
        var imageLayer = new Layer('image', this);
        this._bgDom.appendChild(imageLayer.dom);
        imageLayer.initContext();
        var ctx = imageLayer.ctx;
        imageLayer.clearColor = backgroundColor || '#fff';
        imageLayer.clear();
        var self = this;
        this.storage.iterShape(function (shape) {
            if (!shape.invisible) {
                if (!shape.onbrush || shape.onbrush && !shape.onbrush(ctx, false)) {
                    if (config.catchBrushException) {
                        try {
                            shape.brush(ctx, false, self.refreshNextFrame);
                        } catch (error) {
                            log(error, 'brush error of ' + shape.type, shape);
                        }
                    } else {
                        shape.brush(ctx, false, self.refreshNextFrame);
                    }
                }
            }
        }, {
            normal: 'up',
            update: true
        });
        var image = imageLayer.dom.toDataURL(type, args);
        ctx = null;
        this._bgDom.removeChild(imageLayer.dom);
        return image;
    };
    Painter.prototype.getWidth = function () {
        return this._width;
    };
    Painter.prototype.getHeight = function () {
        return this._height;
    };
    Painter.prototype._getWidth = function () {
        var root = this.root;
        var stl = root.currentStyle || document.defaultView.getComputedStyle(root);
        return ((root.clientWidth || parseInt(stl.width, 10)) - parseInt(stl.paddingLeft, 10) - parseInt(stl.paddingRight, 10)).toFixed(0) - 0;
    };
    Painter.prototype._getHeight = function () {
        var root = this.root;
        var stl = root.currentStyle || document.defaultView.getComputedStyle(root);
        return ((root.clientHeight || parseInt(stl.height, 10)) - parseInt(stl.paddingTop, 10) - parseInt(stl.paddingBottom, 10)).toFixed(0) - 0;
    };
    Painter.prototype._brushHover = function (shape) {
        var ctx = this._layers.hover.ctx;
        if (!shape.onbrush || shape.onbrush && !shape.onbrush(ctx, true)) {
            var layer = this.getLayer(shape.zlevel);
            if (layer.needTransform) {
                ctx.save();
                layer.setTransform(ctx);
            }
            if (config.catchBrushException) {
                try {
                    shape.brush(ctx, true, this.refreshNextFrame);
                } catch (error) {
                    log(error, 'hoverBrush error of ' + shape.type, shape);
                }
            } else {
                shape.brush(ctx, true, this.refreshNextFrame);
            }
            if (layer.needTransform) {
                ctx.restore();
            }
        }
    };
    Painter.prototype._shapeToImage = function (id, shape, width, height, devicePixelRatio) {
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        canvas.setAttribute('width', width * devicePixelRatio);
        canvas.setAttribute('height', height * devicePixelRatio);
        ctx.clearRect(0, 0, width * devicePixelRatio, height * devicePixelRatio);
        var shapeTransform = {
            position: shape.position,
            rotation: shape.rotation,
            scale: shape.scale
        };
        shape.position = [
            0,
            0,
            0
        ];
        shape.rotation = 0;
        shape.scale = [
            1,
            1
        ];
        if (shape) {
            shape.brush(ctx, false);
        }
        var ImageShape = require('./shape/Image');
        var imgShape = new ImageShape({
            id: id,
            style: {
                x: 0,
                y: 0,
                image: canvas
            }
        });
        if (shapeTransform.position != null) {
            imgShape.position = shape.position = shapeTransform.position;
        }
        if (shapeTransform.rotation != null) {
            imgShape.rotation = shape.rotation = shapeTransform.rotation;
        }
        if (shapeTransform.scale != null) {
            imgShape.scale = shape.scale = shapeTransform.scale;
        }
        return imgShape;
    };
    Painter.prototype._createShapeToImageProcessor = function () {
        if (window['G_vmlCanvasManager']) {
            return doNothing;
        }
        var me = this;
        return function (id, e, width, height) {
            return me._shapeToImage(id, e, width, height, config.devicePixelRatio);
        };
    };
    return Painter;
});define('zrender/Storage', [
    'require',
    './tool/util',
    './Group'
], function (require) {
    'use strict';
    var util = require('./tool/util');
    var Group = require('./Group');
    var defaultIterateOption = {
        hover: false,
        normal: 'down',
        update: false
    };
    function shapeCompareFunc(a, b) {
        if (a.zlevel == b.zlevel) {
            if (a.z == b.z) {
                return a.__renderidx - b.__renderidx;
            }
            return a.z - b.z;
        }
        return a.zlevel - b.zlevel;
    }
    var Storage = function () {
        this._elements = {};
        this._hoverElements = [];
        this._roots = [];
        this._shapeList = [];
        this._shapeListOffset = 0;
    };
    Storage.prototype.iterShape = function (fun, option) {
        if (!option) {
            option = defaultIterateOption;
        }
        if (option.hover) {
            for (var i = 0, l = this._hoverElements.length; i < l; i++) {
                var el = this._hoverElements[i];
                el.updateTransform();
                if (fun(el)) {
                    return this;
                }
            }
        }
        if (option.update) {
            this.updateShapeList();
        }
        switch (option.normal) {
        case 'down':
            var l = this._shapeList.length;
            while (l--) {
                if (fun(this._shapeList[l])) {
                    return this;
                }
            }
            break;
        default:
            for (var i = 0, l = this._shapeList.length; i < l; i++) {
                if (fun(this._shapeList[i])) {
                    return this;
                }
            }
            break;
        }
        return this;
    };
    Storage.prototype.getHoverShapes = function (update) {
        var hoverElements = [];
        for (var i = 0, l = this._hoverElements.length; i < l; i++) {
            hoverElements.push(this._hoverElements[i]);
            var target = this._hoverElements[i].hoverConnect;
            if (target) {
                var shape;
                target = target instanceof Array ? target : [target];
                for (var j = 0, k = target.length; j < k; j++) {
                    shape = target[j].id ? target[j] : this.get(target[j]);
                    if (shape) {
                        hoverElements.push(shape);
                    }
                }
            }
        }
        hoverElements.sort(shapeCompareFunc);
        if (update) {
            for (var i = 0, l = hoverElements.length; i < l; i++) {
                hoverElements[i].updateTransform();
            }
        }
        return hoverElements;
    };
    Storage.prototype.getShapeList = function (update) {
        if (update) {
            this.updateShapeList();
        }
        return this._shapeList;
    };
    Storage.prototype.updateShapeList = function () {
        this._shapeListOffset = 0;
        for (var i = 0, len = this._roots.length; i < len; i++) {
            var root = this._roots[i];
            this._updateAndAddShape(root);
        }
        this._shapeList.length = this._shapeListOffset;
        for (var i = 0, len = this._shapeList.length; i < len; i++) {
            this._shapeList[i].__renderidx = i;
        }
        this._shapeList.sort(shapeCompareFunc);
    };
    Storage.prototype._updateAndAddShape = function (el, clipShapes) {
        if (el.ignore) {
            return;
        }
        el.updateTransform();
        if (el.type == 'group') {
            if (el.clipShape) {
                el.clipShape.parent = el;
                el.clipShape.updateTransform();
                if (clipShapes) {
                    clipShapes = clipShapes.slice();
                    clipShapes.push(el.clipShape);
                } else {
                    clipShapes = [el.clipShape];
                }
            }
            for (var i = 0; i < el._children.length; i++) {
                var child = el._children[i];
                child.__dirty = el.__dirty || child.__dirty;
                this._updateAndAddShape(child, clipShapes);
            }
            el.__dirty = false;
        } else {
            el.__clipShapes = clipShapes;
            this._shapeList[this._shapeListOffset++] = el;
        }
    };
    Storage.prototype.mod = function (el, params) {
        if (typeof el === 'string') {
            el = this._elements[el];
        }
        if (el) {
            el.modSelf();
            if (params) {
                if (params.parent || params._storage || params.__clipShapes) {
                    var target = {};
                    for (var name in params) {
                        if (name === 'parent' || name === '_storage' || name === '__clipShapes') {
                            continue;
                        }
                        if (params.hasOwnProperty(name)) {
                            target[name] = params[name];
                        }
                    }
                    util.merge(el, target, true);
                } else {
                    util.merge(el, params, true);
                }
            }
        }
        return this;
    };
    Storage.prototype.drift = function (shapeId, dx, dy) {
        var shape = this._elements[shapeId];
        if (shape) {
            shape.needTransform = true;
            if (shape.draggable === 'horizontal') {
                dy = 0;
            } else if (shape.draggable === 'vertical') {
                dx = 0;
            }
            if (!shape.ondrift || shape.ondrift && !shape.ondrift(dx, dy)) {
                shape.drift(dx, dy);
            }
        }
        return this;
    };
    Storage.prototype.addHover = function (shape) {
        shape.updateNeedTransform();
        this._hoverElements.push(shape);
        return this;
    };
    Storage.prototype.delHover = function () {
        this._hoverElements = [];
        return this;
    };
    Storage.prototype.hasHoverShape = function () {
        return this._hoverElements.length > 0;
    };
    Storage.prototype.addRoot = function (el) {
        if (this._elements[el.id]) {
            return;
        }
        if (el instanceof Group) {
            el.addChildrenToStorage(this);
        }
        this.addToMap(el);
        this._roots.push(el);
    };
    Storage.prototype.delRoot = function (elId) {
        if (typeof elId == 'undefined') {
            for (var i = 0; i < this._roots.length; i++) {
                var root = this._roots[i];
                if (root instanceof Group) {
                    root.delChildrenFromStorage(this);
                }
            }
            this._elements = {};
            this._hoverElements = [];
            this._roots = [];
            this._shapeList = [];
            this._shapeListOffset = 0;
            return;
        }
        if (elId instanceof Array) {
            for (var i = 0, l = elId.length; i < l; i++) {
                this.delRoot(elId[i]);
            }
            return;
        }
        var el;
        if (typeof elId == 'string') {
            el = this._elements[elId];
        } else {
            el = elId;
        }
        var idx = util.indexOf(this._roots, el);
        if (idx >= 0) {
            this.delFromMap(el.id);
            this._roots.splice(idx, 1);
            if (el instanceof Group) {
                el.delChildrenFromStorage(this);
            }
        }
    };
    Storage.prototype.addToMap = function (el) {
        if (el instanceof Group) {
            el._storage = this;
        }
        el.modSelf();
        this._elements[el.id] = el;
        return this;
    };
    Storage.prototype.get = function (elId) {
        return this._elements[elId];
    };
    Storage.prototype.delFromMap = function (elId) {
        var el = this._elements[elId];
        if (el) {
            delete this._elements[elId];
            if (el instanceof Group) {
                el._storage = null;
            }
        }
        return this;
    };
    Storage.prototype.dispose = function () {
        this._elements = this._renderList = this._roots = this._hoverElements = null;
    };
    return Storage;
});define('zrender/animation/Animation', [
    'require',
    './Clip',
    '../tool/color',
    '../tool/util',
    '../tool/event'
], function (require) {
    'use strict';
    var Clip = require('./Clip');
    var color = require('../tool/color');
    var util = require('../tool/util');
    var Dispatcher = require('../tool/event').Dispatcher;
    var requestAnimationFrame = window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (func) {
        setTimeout(func, 16);
    };
    var arraySlice = Array.prototype.slice;
    var Animation = function (options) {
        options = options || {};
        this.stage = options.stage || {};
        this.onframe = options.onframe || function () {
        };
        this._clips = [];
        this._running = false;
        this._time = 0;
        Dispatcher.call(this);
    };
    Animation.prototype = {
        add: function (clip) {
            this._clips.push(clip);
        },
        remove: function (clip) {
            var idx = util.indexOf(this._clips, clip);
            if (idx >= 0) {
                this._clips.splice(idx, 1);
            }
        },
        _update: function () {
            var time = new Date().getTime();
            var delta = time - this._time;
            var clips = this._clips;
            var len = clips.length;
            var deferredEvents = [];
            var deferredClips = [];
            for (var i = 0; i < len; i++) {
                var clip = clips[i];
                var e = clip.step(time);
                if (e) {
                    deferredEvents.push(e);
                    deferredClips.push(clip);
                }
            }
            for (var i = 0; i < len;) {
                if (clips[i]._needsRemove) {
                    clips[i] = clips[len - 1];
                    clips.pop();
                    len--;
                } else {
                    i++;
                }
            }
            len = deferredEvents.length;
            for (var i = 0; i < len; i++) {
                deferredClips[i].fire(deferredEvents[i]);
            }
            this._time = time;
            this.onframe(delta);
            this.dispatch('frame', delta);
            if (this.stage.update) {
                this.stage.update();
            }
        },
        start: function () {
            var self = this;
            this._running = true;
            function step() {
                if (self._running) {
                    requestAnimationFrame(step);
                    self._update();
                }
            }
            this._time = new Date().getTime();
            requestAnimationFrame(step);
        },
        stop: function () {
            this._running = false;
        },
        clear: function () {
            this._clips = [];
        },
        animate: function (target, options) {
            options = options || {};
            var deferred = new Animator(target, options.loop, options.getter, options.setter);
            deferred.animation = this;
            return deferred;
        },
        constructor: Animation
    };
    util.merge(Animation.prototype, Dispatcher.prototype, true);
    function _defaultGetter(target, key) {
        return target[key];
    }
    function _defaultSetter(target, key, value) {
        target[key] = value;
    }
    function _interpolateNumber(p0, p1, percent) {
        return (p1 - p0) * percent + p0;
    }
    function _interpolateArray(p0, p1, percent, out, arrDim) {
        var len = p0.length;
        if (arrDim == 1) {
            for (var i = 0; i < len; i++) {
                out[i] = _interpolateNumber(p0[i], p1[i], percent);
            }
        } else {
            var len2 = p0[0].length;
            for (var i = 0; i < len; i++) {
                for (var j = 0; j < len2; j++) {
                    out[i][j] = _interpolateNumber(p0[i][j], p1[i][j], percent);
                }
            }
        }
    }
    function _isArrayLike(data) {
        switch (typeof data) {
        case 'undefined':
        case 'string':
            return false;
        }
        return typeof data.length !== 'undefined';
    }
    function _catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {
        var len = p0.length;
        if (arrDim == 1) {
            for (var i = 0; i < len; i++) {
                out[i] = _catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);
            }
        } else {
            var len2 = p0[0].length;
            for (var i = 0; i < len; i++) {
                for (var j = 0; j < len2; j++) {
                    out[i][j] = _catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);
                }
            }
        }
    }
    function _catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
    function _cloneValue(value) {
        if (_isArrayLike(value)) {
            var len = value.length;
            if (_isArrayLike(value[0])) {
                var ret = [];
                for (var i = 0; i < len; i++) {
                    ret.push(arraySlice.call(value[i]));
                }
                return ret;
            } else {
                return arraySlice.call(value);
            }
        } else {
            return value;
        }
    }
    function rgba2String(rgba) {
        rgba[0] = Math.floor(rgba[0]);
        rgba[1] = Math.floor(rgba[1]);
        rgba[2] = Math.floor(rgba[2]);
        return 'rgba(' + rgba.join(',') + ')';
    }
    var Animator = function (target, loop, getter, setter) {
        this._tracks = {};
        this._target = target;
        this._loop = loop || false;
        this._getter = getter || _defaultGetter;
        this._setter = setter || _defaultSetter;
        this._clipCount = 0;
        this._delay = 0;
        this._doneList = [];
        this._onframeList = [];
        this._clipList = [];
    };
    Animator.prototype = {
        when: function (time, props) {
            for (var propName in props) {
                if (!this._tracks[propName]) {
                    this._tracks[propName] = [];
                    if (time !== 0) {
                        this._tracks[propName].push({
                            time: 0,
                            value: _cloneValue(this._getter(this._target, propName))
                        });
                    }
                }
                this._tracks[propName].push({
                    time: parseInt(time, 10),
                    value: props[propName]
                });
            }
            return this;
        },
        during: function (callback) {
            this._onframeList.push(callback);
            return this;
        },
        start: function (easing) {
            var self = this;
            var setter = this._setter;
            var getter = this._getter;
            var useSpline = easing === 'spline';
            var ondestroy = function () {
                self._clipCount--;
                if (self._clipCount === 0) {
                    self._tracks = {};
                    var len = self._doneList.length;
                    for (var i = 0; i < len; i++) {
                        self._doneList[i].call(self);
                    }
                }
            };
            var createTrackClip = function (keyframes, propName) {
                var trackLen = keyframes.length;
                if (!trackLen) {
                    return;
                }
                var firstVal = keyframes[0].value;
                var isValueArray = _isArrayLike(firstVal);
                var isValueColor = false;
                var arrDim = isValueArray && _isArrayLike(firstVal[0]) ? 2 : 1;
                keyframes.sort(function (a, b) {
                    return a.time - b.time;
                });
                var trackMaxTime;
                if (trackLen) {
                    trackMaxTime = keyframes[trackLen - 1].time;
                } else {
                    return;
                }
                var kfPercents = [];
                var kfValues = [];
                for (var i = 0; i < trackLen; i++) {
                    kfPercents.push(keyframes[i].time / trackMaxTime);
                    var value = keyframes[i].value;
                    if (typeof value == 'string') {
                        value = color.toArray(value);
                        if (value.length === 0) {
                            value[0] = value[1] = value[2] = 0;
                            value[3] = 1;
                        }
                        isValueColor = true;
                    }
                    kfValues.push(value);
                }
                var cacheKey = 0;
                var cachePercent = 0;
                var start;
                var i;
                var w;
                var p0;
                var p1;
                var p2;
                var p3;
                if (isValueColor) {
                    var rgba = [
                        0,
                        0,
                        0,
                        0
                    ];
                }
                var onframe = function (target, percent) {
                    if (percent < cachePercent) {
                        start = Math.min(cacheKey + 1, trackLen - 1);
                        for (i = start; i >= 0; i--) {
                            if (kfPercents[i] <= percent) {
                                break;
                            }
                        }
                        i = Math.min(i, trackLen - 2);
                    } else {
                        for (i = cacheKey; i < trackLen; i++) {
                            if (kfPercents[i] > percent) {
                                break;
                            }
                        }
                        i = Math.min(i - 1, trackLen - 2);
                    }
                    cacheKey = i;
                    cachePercent = percent;
                    var range = kfPercents[i + 1] - kfPercents[i];
                    if (range === 0) {
                        return;
                    } else {
                        w = (percent - kfPercents[i]) / range;
                    }
                    if (useSpline) {
                        p1 = kfValues[i];
                        p0 = kfValues[i === 0 ? i : i - 1];
                        p2 = kfValues[i > trackLen - 2 ? trackLen - 1 : i + 1];
                        p3 = kfValues[i > trackLen - 3 ? trackLen - 1 : i + 2];
                        if (isValueArray) {
                            _catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);
                        } else {
                            var value;
                            if (isValueColor) {
                                value = _catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);
                                value = rgba2String(rgba);
                            } else {
                                value = _catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
                            }
                            setter(target, propName, value);
                        }
                    } else {
                        if (isValueArray) {
                            _interpolateArray(kfValues[i], kfValues[i + 1], w, getter(target, propName), arrDim);
                        } else {
                            var value;
                            if (isValueColor) {
                                _interpolateArray(kfValues[i], kfValues[i + 1], w, rgba, 1);
                                value = rgba2String(rgba);
                            } else {
                                value = _interpolateNumber(kfValues[i], kfValues[i + 1], w);
                            }
                            setter(target, propName, value);
                        }
                    }
                    for (i = 0; i < self._onframeList.length; i++) {
                        self._onframeList[i](target, percent);
                    }
                };
                var clip = new Clip({
                    target: self._target,
                    life: trackMaxTime,
                    loop: self._loop,
                    delay: self._delay,
                    onframe: onframe,
                    ondestroy: ondestroy
                });
                if (easing && easing !== 'spline') {
                    clip.easing = easing;
                }
                self._clipList.push(clip);
                self._clipCount++;
                self.animation.add(clip);
            };
            for (var propName in this._tracks) {
                createTrackClip(this._tracks[propName], propName);
            }
            return this;
        },
        stop: function () {
            for (var i = 0; i < this._clipList.length; i++) {
                var clip = this._clipList[i];
                this.animation.remove(clip);
            }
            this._clipList = [];
        },
        delay: function (time) {
            this._delay = time;
            return this;
        },
        done: function (cb) {
            if (cb) {
                this._doneList.push(cb);
            }
            return this;
        }
    };
    return Animation;
});define('zrender/tool/vector', [], function () {
    var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
    var vector = {
        create: function (x, y) {
            var out = new ArrayCtor(2);
            out[0] = x || 0;
            out[1] = y || 0;
            return out;
        },
        copy: function (out, v) {
            out[0] = v[0];
            out[1] = v[1];
            return out;
        },
        clone: function (v) {
            var out = new ArrayCtor(2);
            out[0] = v[0];
            out[1] = v[1];
            return out;
        },
        set: function (out, a, b) {
            out[0] = a;
            out[1] = b;
            return out;
        },
        add: function (out, v1, v2) {
            out[0] = v1[0] + v2[0];
            out[1] = v1[1] + v2[1];
            return out;
        },
        scaleAndAdd: function (out, v1, v2, a) {
            out[0] = v1[0] + v2[0] * a;
            out[1] = v1[1] + v2[1] * a;
            return out;
        },
        sub: function (out, v1, v2) {
            out[0] = v1[0] - v2[0];
            out[1] = v1[1] - v2[1];
            return out;
        },
        len: function (v) {
            return Math.sqrt(this.lenSquare(v));
        },
        lenSquare: function (v) {
            return v[0] * v[0] + v[1] * v[1];
        },
        mul: function (out, v1, v2) {
            out[0] = v1[0] * v2[0];
            out[1] = v1[1] * v2[1];
            return out;
        },
        div: function (out, v1, v2) {
            out[0] = v1[0] / v2[0];
            out[1] = v1[1] / v2[1];
            return out;
        },
        dot: function (v1, v2) {
            return v1[0] * v2[0] + v1[1] * v2[1];
        },
        scale: function (out, v, s) {
            out[0] = v[0] * s;
            out[1] = v[1] * s;
            return out;
        },
        normalize: function (out, v) {
            var d = vector.len(v);
            if (d === 0) {
                out[0] = 0;
                out[1] = 0;
            } else {
                out[0] = v[0] / d;
                out[1] = v[1] / d;
            }
            return out;
        },
        distance: function (v1, v2) {
            return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
        },
        distanceSquare: function (v1, v2) {
            return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
        },
        negate: function (out, v) {
            out[0] = -v[0];
            out[1] = -v[1];
            return out;
        },
        lerp: function (out, v1, v2, t) {
            out[0] = v1[0] + t * (v2[0] - v1[0]);
            out[1] = v1[1] + t * (v2[1] - v1[1]);
            return out;
        },
        applyTransform: function (out, v, m) {
            var x = v[0];
            var y = v[1];
            out[0] = m[0] * x + m[2] * y + m[4];
            out[1] = m[1] * x + m[3] * y + m[5];
            return out;
        },
        min: function (out, v1, v2) {
            out[0] = Math.min(v1[0], v2[0]);
            out[1] = Math.min(v1[1], v2[1]);
            return out;
        },
        max: function (out, v1, v2) {
            out[0] = Math.max(v1[0], v2[0]);
            out[1] = Math.max(v1[1], v2[1]);
            return out;
        }
    };
    vector.length = vector.len;
    vector.lengthSquare = vector.lenSquare;
    vector.dist = vector.distance;
    vector.distSquare = vector.distanceSquare;
    return vector;
});define('zrender/tool/matrix', [], function () {
    var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
    var matrix = {
        create: function () {
            var out = new ArrayCtor(6);
            matrix.identity(out);
            return out;
        },
        identity: function (out) {
            out[0] = 1;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            out[4] = 0;
            out[5] = 0;
            return out;
        },
        copy: function (out, m) {
            out[0] = m[0];
            out[1] = m[1];
            out[2] = m[2];
            out[3] = m[3];
            out[4] = m[4];
            out[5] = m[5];
            return out;
        },
        mul: function (out, m1, m2) {
            out[0] = m1[0] * m2[0] + m1[2] * m2[1];
            out[1] = m1[1] * m2[0] + m1[3] * m2[1];
            out[2] = m1[0] * m2[2] + m1[2] * m2[3];
            out[3] = m1[1] * m2[2] + m1[3] * m2[3];
            out[4] = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
            out[5] = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
            return out;
        },
        translate: function (out, a, v) {
            out[0] = a[0];
            out[1] = a[1];
            out[2] = a[2];
            out[3] = a[3];
            out[4] = a[4] + v[0];
            out[5] = a[5] + v[1];
            return out;
        },
        rotate: function (out, a, rad) {
            var aa = a[0];
            var ac = a[2];
            var atx = a[4];
            var ab = a[1];
            var ad = a[3];
            var aty = a[5];
            var st = Math.sin(rad);
            var ct = Math.cos(rad);
            out[0] = aa * ct + ab * st;
            out[1] = -aa * st + ab * ct;
            out[2] = ac * ct + ad * st;
            out[3] = -ac * st + ct * ad;
            out[4] = ct * atx + st * aty;
            out[5] = ct * aty - st * atx;
            return out;
        },
        scale: function (out, a, v) {
            var vx = v[0];
            var vy = v[1];
            out[0] = a[0] * vx;
            out[1] = a[1] * vy;
            out[2] = a[2] * vx;
            out[3] = a[3] * vy;
            out[4] = a[4] * vx;
            out[5] = a[5] * vy;
            return out;
        },
        invert: function (out, a) {
            var aa = a[0];
            var ac = a[2];
            var atx = a[4];
            var ab = a[1];
            var ad = a[3];
            var aty = a[5];
            var det = aa * ad - ab * ac;
            if (!det) {
                return null;
            }
            det = 1 / det;
            out[0] = ad * det;
            out[1] = -ab * det;
            out[2] = -ac * det;
            out[3] = aa * det;
            out[4] = (ac * aty - ad * atx) * det;
            out[5] = (ab * atx - aa * aty) * det;
            return out;
        },
        mulVector: function (out, a, v) {
            var aa = a[0];
            var ac = a[2];
            var atx = a[4];
            var ab = a[1];
            var ad = a[3];
            var aty = a[5];
            out[0] = v[0] * aa + v[1] * ac + atx;
            out[1] = v[0] * ab + v[1] * ad + aty;
            return out;
        }
    };
    return matrix;
});define('zrender/loadingEffect/Base', [
    'require',
    '../tool/util',
    '../shape/Text',
    '../shape/Rectangle'
], function (require) {
    var util = require('../tool/util');
    var TextShape = require('../shape/Text');
    var RectangleShape = require('../shape/Rectangle');
    var DEFAULT_TEXT = 'Loading...';
    var DEFAULT_TEXT_FONT = 'normal 16px Arial';
    function Base(options) {
        this.setOptions(options);
    }
    Base.prototype.createTextShape = function (textStyle) {
        return new TextShape({
            highlightStyle: util.merge({
                x: this.canvasWidth / 2,
                y: this.canvasHeight / 2,
                text: DEFAULT_TEXT,
                textAlign: 'center',
                textBaseline: 'middle',
                textFont: DEFAULT_TEXT_FONT,
                color: '#333',
                brushType: 'fill'
            }, textStyle, true)
        });
    };
    Base.prototype.createBackgroundShape = function (color) {
        return new RectangleShape({
            highlightStyle: {
                x: 0,
                y: 0,
                width: this.canvasWidth,
                height: this.canvasHeight,
                brushType: 'fill',
                color: color
            }
        });
    };
    Base.prototype.start = function (painter) {
        this.canvasWidth = painter._width;
        this.canvasHeight = painter._height;
        function addShapeHandle(param) {
            painter.storage.addHover(param);
        }
        function refreshHandle() {
            painter.refreshHover();
        }
        this.loadingTimer = this._start(addShapeHandle, refreshHandle);
    };
    Base.prototype._start = function () {
        return setInterval(function () {
        }, 10000);
    };
    Base.prototype.stop = function () {
        clearInterval(this.loadingTimer);
    };
    Base.prototype.setOptions = function (options) {
        this.options = options || {};
    };
    Base.prototype.adjust = function (value, region) {
        if (value <= region[0]) {
            value = region[0];
        } else if (value >= region[1]) {
            value = region[1];
        }
        return value;
    };
    Base.prototype.getLocation = function (loc, totalWidth, totalHeight) {
        var x = loc.x != null ? loc.x : 'center';
        switch (x) {
        case 'center':
            x = Math.floor((this.canvasWidth - totalWidth) / 2);
            break;
        case 'left':
            x = 0;
            break;
        case 'right':
            x = this.canvasWidth - totalWidth;
            break;
        }
        var y = loc.y != null ? loc.y : 'center';
        switch (y) {
        case 'center':
            y = Math.floor((this.canvasHeight - totalHeight) / 2);
            break;
        case 'top':
            y = 0;
            break;
        case 'bottom':
            y = this.canvasHeight - totalHeight;
            break;
        }
        return {
            x: x,
            y: y,
            width: totalWidth,
            height: totalHeight
        };
    };
    return Base;
});define('zrender/Layer', [
    'require',
    './mixin/Transformable',
    './tool/util',
    './config'
], function (require) {
    var Transformable = require('./mixin/Transformable');
    var util = require('./tool/util');
    var vmlCanvasManager = window['G_vmlCanvasManager'];
    var config = require('./config');
    function returnFalse() {
        return false;
    }
    function createDom(id, type, painter) {
        var newDom = document.createElement(type);
        var width = painter.getWidth();
        var height = painter.getHeight();
        newDom.style.position = 'absolute';
        newDom.style.left = 0;
        newDom.style.top = 0;
        newDom.style.width = width + 'px';
        newDom.style.height = height + 'px';
        newDom.width = width * config.devicePixelRatio;
        newDom.height = height * config.devicePixelRatio;
        newDom.setAttribute('data-zr-dom-id', id);
        return newDom;
    }
    var Layer = function (id, painter) {
        this.id = id;
        this.dom = createDom(id, 'canvas', painter);
        this.dom.onselectstart = returnFalse;
        this.dom.style['-webkit-user-select'] = 'none';
        this.dom.style['user-select'] = 'none';
        this.dom.style['-webkit-touch-callout'] = 'none';
        this.dom.style['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
        vmlCanvasManager && vmlCanvasManager.initElement(this.dom);
        this.domBack = null;
        this.ctxBack = null;
        this.painter = painter;
        this.unusedCount = 0;
        this.config = null;
        this.dirty = true;
        this.elCount = 0;
        this.clearColor = 0;
        this.motionBlur = false;
        this.lastFrameAlpha = 0.7;
        this.zoomable = false;
        this.panable = false;
        this.maxZoom = Infinity;
        this.minZoom = 0;
        Transformable.call(this);
    };
    Layer.prototype.initContext = function () {
        this.ctx = this.dom.getContext('2d');
        var dpr = config.devicePixelRatio;
        if (dpr != 1) {
            this.ctx.scale(dpr, dpr);
        }
    };
    Layer.prototype.createBackBuffer = function () {
        if (vmlCanvasManager) {
            return;
        }
        this.domBack = createDom('back-' + this.id, 'canvas', this.painter);
        this.ctxBack = this.domBack.getContext('2d');
        var dpr = config.devicePixelRatio;
        if (dpr != 1) {
            this.ctxBack.scale(dpr, dpr);
        }
    };
    Layer.prototype.resize = function (width, height) {
        var dpr = config.devicePixelRatio;
        this.dom.style.width = width + 'px';
        this.dom.style.height = height + 'px';
        this.dom.setAttribute('width', width * dpr);
        this.dom.setAttribute('height', height * dpr);
        if (dpr != 1) {
            this.ctx.scale(dpr, dpr);
        }
        if (this.domBack) {
            this.domBack.setAttribute('width', width * dpr);
            this.domBack.setAttribute('height', height * dpr);
            if (dpr != 1) {
                this.ctxBack.scale(dpr, dpr);
            }
        }
    };
    Layer.prototype.clear = function () {
        var dom = this.dom;
        var ctx = this.ctx;
        var width = dom.width;
        var height = dom.height;
        var haveClearColor = this.clearColor && !vmlCanvasManager;
        var haveMotionBLur = this.motionBlur && !vmlCanvasManager;
        var lastFrameAlpha = this.lastFrameAlpha;
        var dpr = config.devicePixelRatio;
        if (haveMotionBLur) {
            if (!this.domBack) {
                this.createBackBuffer();
            }
            this.ctxBack.globalCompositeOperation = 'copy';
            this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);
        }
        ctx.clearRect(0, 0, width / dpr, height / dpr);
        if (haveClearColor) {
            ctx.save();
            ctx.fillStyle = this.clearColor;
            ctx.fillRect(0, 0, width / dpr, height / dpr);
            ctx.restore();
        }
        if (haveMotionBLur) {
            var domBack = this.domBack;
            ctx.save();
            ctx.globalAlpha = lastFrameAlpha;
            ctx.drawImage(domBack, 0, 0, width / dpr, height / dpr);
            ctx.restore();
        }
    };
    util.merge(Layer.prototype, Transformable.prototype);
    return Layer;
});define('zrender/shape/Text', [
    'require',
    '../tool/area',
    './Base',
    '../tool/util'
], function (require) {
    var area = require('../tool/area');
    var Base = require('./Base');
    var Text = function (options) {
        Base.call(this, options);
    };
    Text.prototype = {
        type: 'text',
        brush: function (ctx, isHighlight) {
            var style = this.style;
            if (isHighlight) {
                style = this.getHighlightStyle(style, this.highlightStyle || {});
            }
            if (typeof style.text == 'undefined' || style.text === false) {
                return;
            }
            ctx.save();
            this.doClip(ctx);
            this.setContext(ctx, style);
            this.setTransform(ctx);
            if (style.textFont) {
                ctx.font = style.textFont;
            }
            ctx.textAlign = style.textAlign || 'start';
            ctx.textBaseline = style.textBaseline || 'middle';
            var text = (style.text + '').split('\n');
            var lineHeight = area.getTextHeight('å›½', style.textFont);
            var rect = this.getRect(style);
            var x = style.x;
            var y;
            if (style.textBaseline == 'top') {
                y = rect.y;
            } else if (style.textBaseline == 'bottom') {
                y = rect.y + lineHeight;
            } else {
                y = rect.y + lineHeight / 2;
            }
            for (var i = 0, l = text.length; i < l; i++) {
                if (style.maxWidth) {
                    switch (style.brushType) {
                    case 'fill':
                        ctx.fillText(text[i], x, y, style.maxWidth);
                        break;
                    case 'stroke':
                        ctx.strokeText(text[i], x, y, style.maxWidth);
                        break;
                    case 'both':
                        ctx.fillText(text[i], x, y, style.maxWidth);
                        ctx.strokeText(text[i], x, y, style.maxWidth);
                        break;
                    default:
                        ctx.fillText(text[i], x, y, style.maxWidth);
                    }
                } else {
                    switch (style.brushType) {
                    case 'fill':
                        ctx.fillText(text[i], x, y);
                        break;
                    case 'stroke':
                        ctx.strokeText(text[i], x, y);
                        break;
                    case 'both':
                        ctx.fillText(text[i], x, y);
                        ctx.strokeText(text[i], x, y);
                        break;
                    default:
                        ctx.fillText(text[i], x, y);
                    }
                }
                y += lineHeight;
            }
            ctx.restore();
            return;
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            var width = area.getTextWidth(style.text, style.textFont);
            var height = area.getTextHeight(style.text, style.textFont);
            var textX = style.x;
            if (style.textAlign == 'end' || style.textAlign == 'right') {
                textX -= width;
            } else if (style.textAlign == 'center') {
                textX -= width / 2;
            }
            var textY;
            if (style.textBaseline == 'top') {
                textY = style.y;
            } else if (style.textBaseline == 'bottom') {
                textY = style.y - height;
            } else {
                textY = style.y - height / 2;
            }
            style.__rect = {
                x: textX,
                y: textY,
                width: width,
                height: height
            };
            return style.__rect;
        }
    };
    require('../tool/util').inherits(Text, Base);
    return Text;
});define('zrender/shape/Rectangle', [
    'require',
    './Base',
    '../tool/util'
], function (require) {
    var Base = require('./Base');
    var Rectangle = function (options) {
        Base.call(this, options);
    };
    Rectangle.prototype = {
        type: 'rectangle',
        _buildRadiusPath: function (ctx, style) {
            var x = style.x;
            var y = style.y;
            var width = style.width;
            var height = style.height;
            var r = style.radius;
            var r1;
            var r2;
            var r3;
            var r4;
            if (typeof r === 'number') {
                r1 = r2 = r3 = r4 = r;
            } else if (r instanceof Array) {
                if (r.length === 1) {
                    r1 = r2 = r3 = r4 = r[0];
                } else if (r.length === 2) {
                    r1 = r3 = r[0];
                    r2 = r4 = r[1];
                } else if (r.length === 3) {
                    r1 = r[0];
                    r2 = r4 = r[1];
                    r3 = r[2];
                } else {
                    r1 = r[0];
                    r2 = r[1];
                    r3 = r[2];
                    r4 = r[3];
                }
            } else {
                r1 = r2 = r3 = r4 = 0;
            }
            var total;
            if (r1 + r2 > width) {
                total = r1 + r2;
                r1 *= width / total;
                r2 *= width / total;
            }
            if (r3 + r4 > width) {
                total = r3 + r4;
                r3 *= width / total;
                r4 *= width / total;
            }
            if (r2 + r3 > height) {
                total = r2 + r3;
                r2 *= height / total;
                r3 *= height / total;
            }
            if (r1 + r4 > height) {
                total = r1 + r4;
                r1 *= height / total;
                r4 *= height / total;
            }
            ctx.moveTo(x + r1, y);
            ctx.lineTo(x + width - r2, y);
            r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);
            ctx.lineTo(x + width, y + height - r3);
            r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);
            ctx.lineTo(x + r4, y + height);
            r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);
            ctx.lineTo(x, y + r1);
            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
        },
        buildPath: function (ctx, style) {
            if (!style.radius) {
                ctx.moveTo(style.x, style.y);
                ctx.lineTo(style.x + style.width, style.y);
                ctx.lineTo(style.x + style.width, style.y + style.height);
                ctx.lineTo(style.x, style.y + style.height);
                ctx.lineTo(style.x, style.y);
            } else {
                this._buildRadiusPath(ctx, style);
            }
            ctx.closePath();
            return;
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            var lineWidth;
            if (style.brushType == 'stroke' || style.brushType == 'fill') {
                lineWidth = style.lineWidth || 1;
            } else {
                lineWidth = 0;
            }
            style.__rect = {
                x: Math.round(style.x - lineWidth / 2),
                y: Math.round(style.y - lineWidth / 2),
                width: style.width + lineWidth,
                height: style.height + lineWidth
            };
            return style.__rect;
        }
    };
    require('../tool/util').inherits(Rectangle, Base);
    return Rectangle;
});define('zrender/tool/area', [
    'require',
    './util',
    './curve'
], function (require) {
    'use strict';
    var util = require('./util');
    var curve = require('./curve');
    var _ctx;
    var _textWidthCache = {};
    var _textHeightCache = {};
    var _textWidthCacheCounter = 0;
    var _textHeightCacheCounter = 0;
    var TEXT_CACHE_MAX = 5000;
    var PI2 = Math.PI * 2;
    function normalizeRadian(angle) {
        angle %= PI2;
        if (angle < 0) {
            angle += PI2;
        }
        return angle;
    }
    function isInside(shape, area, x, y) {
        if (!area || !shape) {
            return false;
        }
        var zoneType = shape.type;
        _ctx = _ctx || util.getContext();
        var _mathReturn = _mathMethod(shape, area, x, y);
        if (typeof _mathReturn != 'undefined') {
            return _mathReturn;
        }
        if (shape.buildPath && _ctx.isPointInPath) {
            return _buildPathMethod(shape, _ctx, area, x, y);
        }
        switch (zoneType) {
        case 'ellipse':
            return true;
        case 'trochoid':
            var _r = area.location == 'out' ? area.r1 + area.r2 + area.d : area.r1 - area.r2 + area.d;
            return isInsideCircle(area, x, y, _r);
        case 'rose':
            return isInsideCircle(area, x, y, area.maxr);
        default:
            return false;
        }
    }
    function _mathMethod(shape, area, x, y) {
        var zoneType = shape.type;
        switch (zoneType) {
        case 'bezier-curve':
            if (typeof area.cpX2 === 'undefined') {
                return isInsideQuadraticStroke(area.xStart, area.yStart, area.cpX1, area.cpY1, area.xEnd, area.yEnd, area.lineWidth, x, y);
            }
            return isInsideCubicStroke(area.xStart, area.yStart, area.cpX1, area.cpY1, area.cpX2, area.cpY2, area.xEnd, area.yEnd, area.lineWidth, x, y);
        case 'line':
            return isInsideLine(area.xStart, area.yStart, area.xEnd, area.yEnd, area.lineWidth, x, y);
        case 'polyline':
            return isInsidePolyline(area.pointList, area.lineWidth, x, y);
        case 'ring':
            return isInsideRing(area.x, area.y, area.r0, area.r, x, y);
        case 'circle':
            return isInsideCircle(area.x, area.y, area.r, x, y);
        case 'sector':
            var startAngle = area.startAngle * Math.PI / 180;
            var endAngle = area.endAngle * Math.PI / 180;
            if (!area.clockWise) {
                startAngle = -startAngle;
                endAngle = -endAngle;
            }
            return isInsideSector(area.x, area.y, area.r0, area.r, startAngle, endAngle, !area.clockWise, x, y);
        case 'path':
            return area.pathArray && isInsidePath(area.pathArray, Math.max(area.lineWidth, 5), area.brushType, x, y);
        case 'polygon':
        case 'star':
        case 'isogon':
            return isInsidePolygon(area.pointList, x, y);
        case 'text':
            var rect = area.__rect || shape.getRect(area);
            return isInsideRect(rect.x, rect.y, rect.width, rect.height, x, y);
        case 'rectangle':
        case 'image':
            return isInsideRect(area.x, area.y, area.width, area.height, x, y);
        }
    }
    function _buildPathMethod(shape, context, area, x, y) {
        context.beginPath();
        shape.buildPath(context, area);
        context.closePath();
        return context.isPointInPath(x, y);
    }
    function isOutside(shape, area, x, y) {
        return !isInside(shape, area, x, y);
    }
    function isInsideLine(x0, y0, x1, y1, lineWidth, x, y) {
        if (lineWidth === 0) {
            return false;
        }
        var _l = Math.max(lineWidth, 5);
        var _a = 0;
        var _b = x0;
        if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
            return false;
        }
        if (x0 !== x1) {
            _a = (y0 - y1) / (x0 - x1);
            _b = (x0 * y1 - x1 * y0) / (x0 - x1);
        } else {
            return Math.abs(x - x0) <= _l / 2;
        }
        var tmp = _a * x - y + _b;
        var _s = tmp * tmp / (_a * _a + 1);
        return _s <= _l / 2 * _l / 2;
    }
    function isInsideCubicStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
        if (lineWidth === 0) {
            return false;
        }
        var _l = Math.max(lineWidth, 5);
        if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
            return false;
        }
        var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
        return d <= _l / 2;
    }
    function isInsideQuadraticStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
        if (lineWidth === 0) {
            return false;
        }
        var _l = Math.max(lineWidth, 5);
        if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
            return false;
        }
        var d = curve.quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
        return d <= _l / 2;
    }
    function isInsideArcStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
        if (lineWidth === 0) {
            return false;
        }
        var _l = Math.max(lineWidth, 5);
        x -= cx;
        y -= cy;
        var d = Math.sqrt(x * x + y * y);
        if (d - _l > r || d + _l < r) {
            return false;
        }
        if (Math.abs(startAngle - endAngle) >= PI2) {
            return true;
        }
        if (anticlockwise) {
            var tmp = startAngle;
            startAngle = normalizeRadian(endAngle);
            endAngle = normalizeRadian(tmp);
        } else {
            startAngle = normalizeRadian(startAngle);
            endAngle = normalizeRadian(endAngle);
        }
        if (startAngle > endAngle) {
            endAngle += PI2;
        }
        var angle = Math.atan2(y, x);
        if (angle < 0) {
            angle += PI2;
        }
        return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;
    }
    function isInsidePolyline(points, lineWidth, x, y) {
        var lineWidth = Math.max(lineWidth, 10);
        for (var i = 0, l = points.length - 1; i < l; i++) {
            var x0 = points[i][0];
            var y0 = points[i][1];
            var x1 = points[i + 1][0];
            var y1 = points[i + 1][1];
            if (isInsideLine(x0, y0, x1, y1, lineWidth, x, y)) {
                return true;
            }
        }
        return false;
    }
    function isInsideRing(cx, cy, r0, r, x, y) {
        var d = (x - cx) * (x - cx) + (y - cy) * (y - cy);
        return d < r * r && d > r0 * r0;
    }
    function isInsideRect(x0, y0, width, height, x, y) {
        return x >= x0 && x <= x0 + width && y >= y0 && y <= y0 + height;
    }
    function isInsideCircle(x0, y0, r, x, y) {
        return (x - x0) * (x - x0) + (y - y0) * (y - y0) < r * r;
    }
    function isInsideSector(cx, cy, r0, r, startAngle, endAngle, anticlockwise, x, y) {
        return isInsideArcStroke(cx, cy, (r0 + r) / 2, startAngle, endAngle, anticlockwise, r - r0, x, y);
    }
    function isInsidePolygon(points, x, y) {
        var N = points.length;
        var w = 0;
        for (var i = 0, j = N - 1; i < N; i++) {
            var x0 = points[j][0];
            var y0 = points[j][1];
            var x1 = points[i][0];
            var y1 = points[i][1];
            w += windingLine(x0, y0, x1, y1, x, y);
            j = i;
        }
        return w !== 0;
    }
    function windingLine(x0, y0, x1, y1, x, y) {
        if (y > y0 && y > y1 || y < y0 && y < y1) {
            return 0;
        }
        if (y1 == y0) {
            return 0;
        }
        var dir = y1 < y0 ? 1 : -1;
        var t = (y - y0) / (y1 - y0);
        var x_ = t * (x1 - x0) + x0;
        return x_ > x ? dir : 0;
    }
    var roots = [
        -1,
        -1,
        -1
    ];
    var extrema = [
        -1,
        -1
    ];
    function swapExtrema() {
        var tmp = extrema[0];
        extrema[0] = extrema[1];
        extrema[1] = tmp;
    }
    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
        if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
            return 0;
        }
        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
        if (nRoots === 0) {
            return 0;
        } else {
            var w = 0;
            var nExtrema = -1;
            var y0_, y1_;
            for (var i = 0; i < nRoots; i++) {
                var t = roots[i];
                var x_ = curve.cubicAt(x0, x1, x2, x3, t);
                if (x_ < x) {
                    continue;
                }
                if (nExtrema < 0) {
                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
                    if (extrema[1] < extrema[0] && nExtrema > 1) {
                        swapExtrema();
                    }
                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
                    if (nExtrema > 1) {
                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
                    }
                }
                if (nExtrema == 2) {
                    if (t < extrema[0]) {
                        w += y0_ < y0 ? 1 : -1;
                    } else if (t < extrema[1]) {
                        w += y1_ < y0_ ? 1 : -1;
                    } else {
                        w += y3 < y1_ ? 1 : -1;
                    }
                } else {
                    if (t < extrema[0]) {
                        w += y0_ < y0 ? 1 : -1;
                    } else {
                        w += y3 < y0_ ? 1 : -1;
                    }
                }
            }
            return w;
        }
    }
    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
        if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
            return 0;
        }
        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
        if (nRoots === 0) {
            return 0;
        } else {
            var t = curve.quadraticExtremum(y0, y1, y2);
            if (t >= 0 && t <= 1) {
                var w = 0;
                var y_ = curve.quadraticAt(y0, y1, y2, t);
                for (var i = 0; i < nRoots; i++) {
                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
                    if (x_ < x) {
                        continue;
                    }
                    if (roots[i] < t) {
                        w += y_ < y0 ? 1 : -1;
                    } else {
                        w += y2 < y_ ? 1 : -1;
                    }
                }
                return w;
            } else {
                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
                if (x_ < x) {
                    return 0;
                }
                return y2 < y0 ? 1 : -1;
            }
        }
    }
    function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
        y -= cy;
        if (y > r || y < -r) {
            return 0;
        }
        var tmp = Math.sqrt(r * r - y * y);
        roots[0] = -tmp;
        roots[1] = tmp;
        if (Math.abs(startAngle - endAngle) >= PI2) {
            startAngle = 0;
            endAngle = PI2;
            var dir = anticlockwise ? 1 : -1;
            if (x >= roots[0] + cx && x <= roots[1] + cx) {
                return dir;
            } else {
                return 0;
            }
        }
        if (anticlockwise) {
            var tmp = startAngle;
            startAngle = normalizeRadian(endAngle);
            endAngle = normalizeRadian(tmp);
        } else {
            startAngle = normalizeRadian(startAngle);
            endAngle = normalizeRadian(endAngle);
        }
        if (startAngle > endAngle) {
            endAngle += PI2;
        }
        var w = 0;
        for (var i = 0; i < 2; i++) {
            var x_ = roots[i];
            if (x_ + cx > x) {
                var angle = Math.atan2(y, x_);
                var dir = anticlockwise ? 1 : -1;
                if (angle < 0) {
                    angle = PI2 + angle;
                }
                if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {
                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
                        dir = -dir;
                    }
                    w += dir;
                }
            }
        }
        return w;
    }
    function isInsidePath(pathArray, lineWidth, brushType, x, y) {
        var w = 0;
        var xi = 0;
        var yi = 0;
        var x0 = 0;
        var y0 = 0;
        var beginSubpath = true;
        var firstCmd = true;
        brushType = brushType || 'fill';
        var hasStroke = brushType === 'stroke' || brushType === 'both';
        var hasFill = brushType === 'fill' || brushType === 'both';
        for (var i = 0; i < pathArray.length; i++) {
            var seg = pathArray[i];
            var p = seg.points;
            if (beginSubpath || seg.command === 'M') {
                if (i > 0) {
                    if (hasFill) {
                        w += windingLine(xi, yi, x0, y0, x, y);
                    }
                    if (w !== 0) {
                        return true;
                    }
                }
                x0 = p[p.length - 2];
                y0 = p[p.length - 1];
                beginSubpath = false;
                if (firstCmd && seg.command !== 'A') {
                    firstCmd = false;
                    xi = x0;
                    yi = y0;
                }
            }
            switch (seg.command) {
            case 'M':
                xi = p[0];
                yi = p[1];
                break;
            case 'L':
                if (hasStroke) {
                    if (isInsideLine(xi, yi, p[0], p[1], lineWidth, x, y)) {
                        return true;
                    }
                }
                if (hasFill) {
                    w += windingLine(xi, yi, p[0], p[1], x, y);
                }
                xi = p[0];
                yi = p[1];
                break;
            case 'C':
                if (hasStroke) {
                    if (isInsideCubicStroke(xi, yi, p[0], p[1], p[2], p[3], p[4], p[5], lineWidth, x, y)) {
                        return true;
                    }
                }
                if (hasFill) {
                    w += windingCubic(xi, yi, p[0], p[1], p[2], p[3], p[4], p[5], x, y);
                }
                xi = p[4];
                yi = p[5];
                break;
            case 'Q':
                if (hasStroke) {
                    if (isInsideQuadraticStroke(xi, yi, p[0], p[1], p[2], p[3], lineWidth, x, y)) {
                        return true;
                    }
                }
                if (hasFill) {
                    w += windingQuadratic(xi, yi, p[0], p[1], p[2], p[3], x, y);
                }
                xi = p[2];
                yi = p[3];
                break;
            case 'A':
                var cx = p[0];
                var cy = p[1];
                var rx = p[2];
                var ry = p[3];
                var theta = p[4];
                var dTheta = p[5];
                var x1 = Math.cos(theta) * rx + cx;
                var y1 = Math.sin(theta) * ry + cy;
                if (!firstCmd) {
                    w += windingLine(xi, yi, x1, y1);
                } else {
                    firstCmd = false;
                    x0 = x1;
                    y0 = y1;
                }
                var _x = (x - cx) * ry / rx + cx;
                if (hasStroke) {
                    if (isInsideArcStroke(cx, cy, ry, theta, theta + dTheta, 1 - p[7], lineWidth, _x, y)) {
                        return true;
                    }
                }
                if (hasFill) {
                    w += windingArc(cx, cy, ry, theta, theta + dTheta, 1 - p[7], _x, y);
                }
                xi = Math.cos(theta + dTheta) * rx + cx;
                yi = Math.sin(theta + dTheta) * ry + cy;
                break;
            case 'z':
                if (hasStroke) {
                    if (isInsideLine(xi, yi, x0, y0, lineWidth, x, y)) {
                        return true;
                    }
                }
                beginSubpath = true;
                break;
            }
        }
        if (hasFill) {
            w += windingLine(xi, yi, x0, y0, x, y);
        }
        return w !== 0;
    }
    function getTextWidth(text, textFont) {
        var key = text + ':' + textFont;
        if (_textWidthCache[key]) {
            return _textWidthCache[key];
        }
        _ctx = _ctx || util.getContext();
        _ctx.save();
        if (textFont) {
            _ctx.font = textFont;
        }
        text = (text + '').split('\n');
        var width = 0;
        for (var i = 0, l = text.length; i < l; i++) {
            width = Math.max(_ctx.measureText(text[i]).width, width);
        }
        _ctx.restore();
        _textWidthCache[key] = width;
        if (++_textWidthCacheCounter > TEXT_CACHE_MAX) {
            _textWidthCacheCounter = 0;
            _textWidthCache = {};
        }
        return width;
    }
    function getTextHeight(text, textFont) {
        var key = text + ':' + textFont;
        if (_textHeightCache[key]) {
            return _textHeightCache[key];
        }
        _ctx = _ctx || util.getContext();
        _ctx.save();
        if (textFont) {
            _ctx.font = textFont;
        }
        text = (text + '').split('\n');
        var height = (_ctx.measureText('å›½').width + 2) * text.length;
        _ctx.restore();
        _textHeightCache[key] = height;
        if (++_textHeightCacheCounter > TEXT_CACHE_MAX) {
            _textHeightCacheCounter = 0;
            _textHeightCache = {};
        }
        return height;
    }
    return {
        isInside: isInside,
        isOutside: isOutside,
        getTextWidth: getTextWidth,
        getTextHeight: getTextHeight,
        isInsidePath: isInsidePath,
        isInsidePolygon: isInsidePolygon,
        isInsideSector: isInsideSector,
        isInsideCircle: isInsideCircle,
        isInsideLine: isInsideLine,
        isInsideRect: isInsideRect,
        isInsidePolyline: isInsidePolyline,
        isInsideCubicStroke: isInsideCubicStroke,
        isInsideQuadraticStroke: isInsideQuadraticStroke
    };
});define('zrender/shape/Base', [
    'require',
    '../tool/matrix',
    '../tool/guid',
    '../tool/util',
    '../tool/log',
    '../mixin/Transformable',
    '../mixin/Eventful',
    '../tool/area',
    '../tool/color'
], function (require) {
    var vmlCanvasManager = window['G_vmlCanvasManager'];
    var matrix = require('../tool/matrix');
    var guid = require('../tool/guid');
    var util = require('../tool/util');
    var log = require('../tool/log');
    var Transformable = require('../mixin/Transformable');
    var Eventful = require('../mixin/Eventful');
    function _fillText(ctx, text, x, y, textFont, textAlign, textBaseline) {
        if (textFont) {
            ctx.font = textFont;
        }
        ctx.textAlign = textAlign;
        ctx.textBaseline = textBaseline;
        var rect = _getTextRect(text, x, y, textFont, textAlign, textBaseline);
        text = (text + '').split('\n');
        var lineHeight = require('../tool/area').getTextHeight('å›½', textFont);
        switch (textBaseline) {
        case 'top':
            y = rect.y;
            break;
        case 'bottom':
            y = rect.y + lineHeight;
            break;
        default:
            y = rect.y + lineHeight / 2;
        }
        for (var i = 0, l = text.length; i < l; i++) {
            ctx.fillText(text[i], x, y);
            y += lineHeight;
        }
    }
    function _getTextRect(text, x, y, textFont, textAlign, textBaseline) {
        var area = require('../tool/area');
        var width = area.getTextWidth(text, textFont);
        var lineHeight = area.getTextHeight('å›½', textFont);
        text = (text + '').split('\n');
        switch (textAlign) {
        case 'end':
        case 'right':
            x -= width;
            break;
        case 'center':
            x -= width / 2;
            break;
        }
        switch (textBaseline) {
        case 'top':
            break;
        case 'bottom':
            y -= lineHeight * text.length;
            break;
        default:
            y -= lineHeight * text.length / 2;
        }
        return {
            x: x,
            y: y,
            width: width,
            height: lineHeight * text.length
        };
    }
    var Base = function (options) {
        options = options || {};
        this.id = options.id || guid();
        for (var key in options) {
            this[key] = options[key];
        }
        this.style = this.style || {};
        this.highlightStyle = this.highlightStyle || null;
        this.parent = null;
        this.__dirty = true;
        this.__clipShapes = [];
        Transformable.call(this);
        Eventful.call(this);
    };
    Base.prototype.invisible = false;
    Base.prototype.ignore = false;
    Base.prototype.zlevel = 0;
    Base.prototype.draggable = false;
    Base.prototype.clickable = false;
    Base.prototype.hoverable = true;
    Base.prototype.z = 0;
    Base.prototype.brush = function (ctx, isHighlight) {
        var style = this.beforeBrush(ctx, isHighlight);
        ctx.beginPath();
        this.buildPath(ctx, style);
        switch (style.brushType) {
        case 'both':
            ctx.fill();
        case 'stroke':
            style.lineWidth > 0 && ctx.stroke();
            break;
        default:
            ctx.fill();
        }
        this.drawText(ctx, style, this.style);
        this.afterBrush(ctx);
    };
    Base.prototype.beforeBrush = function (ctx, isHighlight) {
        var style = this.style;
        if (this.brushTypeOnly) {
            style.brushType = this.brushTypeOnly;
        }
        if (isHighlight) {
            style = this.getHighlightStyle(style, this.highlightStyle || {}, this.brushTypeOnly);
        }
        if (this.brushTypeOnly == 'stroke') {
            style.strokeColor = style.strokeColor || style.color;
        }
        ctx.save();
        this.doClip(ctx);
        this.setContext(ctx, style);
        this.setTransform(ctx);
        return style;
    };
    Base.prototype.afterBrush = function (ctx) {
        ctx.restore();
    };
    var STYLE_CTX_MAP = [
        [
            'color',
            'fillStyle'
        ],
        [
            'strokeColor',
            'strokeStyle'
        ],
        [
            'opacity',
            'globalAlpha'
        ],
        [
            'lineCap',
            'lineCap'
        ],
        [
            'lineJoin',
            'lineJoin'
        ],
        [
            'miterLimit',
            'miterLimit'
        ],
        [
            'lineWidth',
            'lineWidth'
        ],
        [
            'shadowBlur',
            'shadowBlur'
        ],
        [
            'shadowColor',
            'shadowColor'
        ],
        [
            'shadowOffsetX',
            'shadowOffsetX'
        ],
        [
            'shadowOffsetY',
            'shadowOffsetY'
        ]
    ];
    Base.prototype.setContext = function (ctx, style) {
        for (var i = 0, len = STYLE_CTX_MAP.length; i < len; i++) {
            var styleProp = STYLE_CTX_MAP[i][0];
            var styleValue = style[styleProp];
            var ctxProp = STYLE_CTX_MAP[i][1];
            if (typeof styleValue != 'undefined') {
                ctx[ctxProp] = styleValue;
            }
        }
    };
    var clipShapeInvTransform = matrix.create();
    Base.prototype.doClip = function (ctx) {
        if (this.__clipShapes && !vmlCanvasManager) {
            for (var i = 0; i < this.__clipShapes.length; i++) {
                var clipShape = this.__clipShapes[i];
                if (clipShape.needTransform) {
                    var m = clipShape.transform;
                    matrix.invert(clipShapeInvTransform, m);
                    ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
                }
                ctx.beginPath();
                clipShape.buildPath(ctx, clipShape.style);
                ctx.clip();
                if (clipShape.needTransform) {
                    var m = clipShapeInvTransform;
                    ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
                }
            }
        }
    };
    Base.prototype.getHighlightStyle = function (style, highlightStyle, brushTypeOnly) {
        var newStyle = {};
        for (var k in style) {
            newStyle[k] = style[k];
        }
        var color = require('../tool/color');
        var highlightColor = color.getHighlightColor();
        if (style.brushType != 'stroke') {
            newStyle.strokeColor = highlightColor;
            newStyle.lineWidth = (style.lineWidth || 1) + this.getHighlightZoom();
            newStyle.brushType = 'both';
        } else {
            if (brushTypeOnly != 'stroke') {
                newStyle.strokeColor = highlightColor;
                newStyle.lineWidth = (style.lineWidth || 1) + this.getHighlightZoom();
            } else {
                newStyle.strokeColor = highlightStyle.strokeColor || color.mix(style.strokeColor, color.toRGB(highlightColor));
            }
        }
        for (var k in highlightStyle) {
            if (typeof highlightStyle[k] != 'undefined') {
                newStyle[k] = highlightStyle[k];
            }
        }
        return newStyle;
    };
    Base.prototype.getHighlightZoom = function () {
        return this.type != 'text' ? 6 : 2;
    };
    Base.prototype.drift = function (dx, dy) {
        this.position[0] += dx;
        this.position[1] += dy;
    };
    Base.prototype.buildPath = function (ctx, style) {
        log('buildPath not implemented in ' + this.type);
    };
    Base.prototype.getRect = function (style) {
        log('getRect not implemented in ' + this.type);
    };
    Base.prototype.isCover = function (x, y) {
        var originPos = this.transformCoordToLocal(x, y);
        x = originPos[0];
        y = originPos[1];
        if (this.isCoverRect(x, y)) {
            return require('../tool/area').isInside(this, this.style, x, y);
        }
        return false;
    };
    Base.prototype.isCoverRect = function (x, y) {
        var rect = this.style.__rect;
        if (!rect) {
            rect = this.style.__rect = this.getRect(this.style);
        }
        return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
    };
    Base.prototype.drawText = function (ctx, style, normalStyle) {
        if (typeof style.text == 'undefined' || style.text === false) {
            return;
        }
        var textColor = style.textColor || style.color || style.strokeColor;
        ctx.fillStyle = textColor;
        var dd = 10;
        var al;
        var bl;
        var tx;
        var ty;
        var textPosition = style.textPosition || this.textPosition || 'top';
        switch (textPosition) {
        case 'inside':
        case 'top':
        case 'bottom':
        case 'left':
        case 'right':
            if (this.getRect) {
                var rect = (normalStyle || style).__rect || this.getRect(normalStyle || style);
                switch (textPosition) {
                case 'inside':
                    tx = rect.x + rect.width / 2;
                    ty = rect.y + rect.height / 2;
                    al = 'center';
                    bl = 'middle';
                    if (style.brushType != 'stroke' && textColor == style.color) {
                        ctx.fillStyle = '#fff';
                    }
                    break;
                case 'left':
                    tx = rect.x - dd;
                    ty = rect.y + rect.height / 2;
                    al = 'end';
                    bl = 'middle';
                    break;
                case 'right':
                    tx = rect.x + rect.width + dd;
                    ty = rect.y + rect.height / 2;
                    al = 'start';
                    bl = 'middle';
                    break;
                case 'top':
                    tx = rect.x + rect.width / 2;
                    ty = rect.y - dd;
                    al = 'center';
                    bl = 'bottom';
                    break;
                case 'bottom':
                    tx = rect.x + rect.width / 2;
                    ty = rect.y + rect.height + dd;
                    al = 'center';
                    bl = 'top';
                    break;
                }
            }
            break;
        case 'start':
        case 'end':
            var pointList = style.pointList || [
                [
                    style.xStart || 0,
                    style.yStart || 0
                ],
                [
                    style.xEnd || 0,
                    style.yEnd || 0
                ]
            ];
            var length = pointList.length;
            if (length < 2) {
                return;
            }
            var xStart;
            var xEnd;
            var yStart;
            var yEnd;
            switch (textPosition) {
            case 'start':
                xStart = pointList[1][0];
                xEnd = pointList[0][0];
                yStart = pointList[1][1];
                yEnd = pointList[0][1];
                break;
            case 'end':
                xStart = pointList[length - 2][0];
                xEnd = pointList[length - 1][0];
                yStart = pointList[length - 2][1];
                yEnd = pointList[length - 1][1];
                break;
            }
            tx = xEnd;
            ty = yEnd;
            var angle = Math.atan((yStart - yEnd) / (xEnd - xStart)) / Math.PI * 180;
            if (xEnd - xStart < 0) {
                angle += 180;
            } else if (yStart - yEnd < 0) {
                angle += 360;
            }
            dd = 5;
            if (angle >= 30 && angle <= 150) {
                al = 'center';
                bl = 'bottom';
                ty -= dd;
            } else if (angle > 150 && angle < 210) {
                al = 'right';
                bl = 'middle';
                tx -= dd;
            } else if (angle >= 210 && angle <= 330) {
                al = 'center';
                bl = 'top';
                ty += dd;
            } else {
                al = 'left';
                bl = 'middle';
                tx += dd;
            }
            break;
        case 'specific':
            tx = style.textX || 0;
            ty = style.textY || 0;
            al = 'start';
            bl = 'middle';
            break;
        }
        if (tx != null && ty != null) {
            _fillText(ctx, style.text, tx, ty, style.textFont, style.textAlign || al, style.textBaseline || bl);
        }
    };
    Base.prototype.modSelf = function () {
        this.__dirty = true;
        if (this.style) {
            this.style.__rect = null;
        }
        if (this.highlightStyle) {
            this.highlightStyle.__rect = null;
        }
    };
    Base.prototype.isSilent = function () {
        return !(this.hoverable || this.draggable || this.clickable || this.onmousemove || this.onmouseover || this.onmouseout || this.onmousedown || this.onmouseup || this.onclick || this.ondragenter || this.ondragover || this.ondragleave || this.ondrop);
    };
    util.merge(Base.prototype, Transformable.prototype, true);
    util.merge(Base.prototype, Eventful.prototype, true);
    return Base;
});define('zrender/tool/curve', [
    'require',
    './vector'
], function (require) {
    var vector = require('./vector');
    'use strict';
    var EPSILON = 0.0001;
    var THREE_SQRT = Math.sqrt(3);
    var ONE_THIRD = 1 / 3;
    var _v0 = vector.create();
    var _v1 = vector.create();
    var _v2 = vector.create();
    function isAroundZero(val) {
        return val > -EPSILON && val < EPSILON;
    }
    function isNotAroundZero(val) {
        return val > EPSILON || val < -EPSILON;
    }
    function cubicAt(p0, p1, p2, p3, t) {
        var onet = 1 - t;
        return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
    }
    function cubicDerivativeAt(p0, p1, p2, p3, t) {
        var onet = 1 - t;
        return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
    }
    function cubicRootAt(p0, p1, p2, p3, val, roots) {
        var a = p3 + 3 * (p1 - p2) - p0;
        var b = 3 * (p2 - p1 * 2 + p0);
        var c = 3 * (p1 - p0);
        var d = p0 - val;
        var A = b * b - 3 * a * c;
        var B = b * c - 9 * a * d;
        var C = c * c - 3 * b * d;
        var n = 0;
        if (isAroundZero(A) && isAroundZero(B)) {
            if (isAroundZero(b)) {
                roots[0] = 0;
            } else {
                var t1 = -c / b;
                if (t1 >= 0 && t1 <= 1) {
                    roots[n++] = t1;
                }
            }
        } else {
            var disc = B * B - 4 * A * C;
            if (isAroundZero(disc)) {
                var K = B / A;
                var t1 = -b / a + K;
                var t2 = -K / 2;
                if (t1 >= 0 && t1 <= 1) {
                    roots[n++] = t1;
                }
                if (t2 >= 0 && t2 <= 1) {
                    roots[n++] = t2;
                }
            } else if (disc > 0) {
                var discSqrt = Math.sqrt(disc);
                var Y1 = A * b + 1.5 * a * (-B + discSqrt);
                var Y2 = A * b + 1.5 * a * (-B - discSqrt);
                if (Y1 < 0) {
                    Y1 = -Math.pow(-Y1, ONE_THIRD);
                } else {
                    Y1 = Math.pow(Y1, ONE_THIRD);
                }
                if (Y2 < 0) {
                    Y2 = -Math.pow(-Y2, ONE_THIRD);
                } else {
                    Y2 = Math.pow(Y2, ONE_THIRD);
                }
                var t1 = (-b - (Y1 + Y2)) / (3 * a);
                if (t1 >= 0 && t1 <= 1) {
                    roots[n++] = t1;
                }
            } else {
                var T = (2 * A * b - 3 * a * B) / (2 * Math.sqrt(A * A * A));
                var theta = Math.acos(T) / 3;
                var ASqrt = Math.sqrt(A);
                var tmp = Math.cos(theta);
                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
                if (t1 >= 0 && t1 <= 1) {
                    roots[n++] = t1;
                }
                if (t2 >= 0 && t2 <= 1) {
                    roots[n++] = t2;
                }
                if (t3 >= 0 && t3 <= 1) {
                    roots[n++] = t3;
                }
            }
        }
        return n;
    }
    function cubicExtrema(p0, p1, p2, p3, extrema) {
        var b = 6 * p2 - 12 * p1 + 6 * p0;
        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
        var c = 3 * p1 - 3 * p0;
        var n = 0;
        if (isAroundZero(a)) {
            if (isNotAroundZero(b)) {
                var t1 = -c / b;
                if (t1 >= 0 && t1 <= 1) {
                    extrema[n++] = t1;
                }
            }
        } else {
            var disc = b * b - 4 * a * c;
            if (isAroundZero(disc)) {
                extrema[0] = -b / (2 * a);
            } else if (disc > 0) {
                var discSqrt = Math.sqrt(disc);
                var t1 = (-b + discSqrt) / (2 * a);
                var t2 = (-b - discSqrt) / (2 * a);
                if (t1 >= 0 && t1 <= 1) {
                    extrema[n++] = t1;
                }
                if (t2 >= 0 && t2 <= 1) {
                    extrema[n++] = t2;
                }
            }
        }
        return n;
    }
    function cubicSubdivide(p0, p1, p2, p3, t, out) {
        var p01 = (p1 - p0) * t + p0;
        var p12 = (p2 - p1) * t + p1;
        var p23 = (p3 - p2) * t + p2;
        var p012 = (p12 - p01) * t + p01;
        var p123 = (p23 - p12) * t + p12;
        var p0123 = (p123 - p012) * t + p012;
        out[0] = p0;
        out[1] = p01;
        out[2] = p012;
        out[3] = p0123;
        out[4] = p0123;
        out[5] = p123;
        out[6] = p23;
        out[7] = p3;
    }
    function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
        var t;
        var interval = 0.005;
        var d = Infinity;
        _v0[0] = x;
        _v0[1] = y;
        for (var _t = 0; _t < 1; _t += 0.05) {
            _v1[0] = cubicAt(x0, x1, x2, x3, _t);
            _v1[1] = cubicAt(y0, y1, y2, y3, _t);
            var d1 = vector.distSquare(_v0, _v1);
            if (d1 < d) {
                t = _t;
                d = d1;
            }
        }
        d = Infinity;
        for (var i = 0; i < 32; i++) {
            if (interval < EPSILON) {
                break;
            }
            var prev = t - interval;
            var next = t + interval;
            _v1[0] = cubicAt(x0, x1, x2, x3, prev);
            _v1[1] = cubicAt(y0, y1, y2, y3, prev);
            var d1 = vector.distSquare(_v1, _v0);
            if (prev >= 0 && d1 < d) {
                t = prev;
                d = d1;
            } else {
                _v2[0] = cubicAt(x0, x1, x2, x3, next);
                _v2[1] = cubicAt(y0, y1, y2, y3, next);
                var d2 = vector.distSquare(_v2, _v0);
                if (next <= 1 && d2 < d) {
                    t = next;
                    d = d2;
                } else {
                    interval *= 0.5;
                }
            }
        }
        if (out) {
            out[0] = cubicAt(x0, x1, x2, x3, t);
            out[1] = cubicAt(y0, y1, y2, y3, t);
        }
        return Math.sqrt(d);
    }
    function quadraticAt(p0, p1, p2, t) {
        var onet = 1 - t;
        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
    }
    function quadraticDerivativeAt(p0, p1, p2, t) {
        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
    }
    function quadraticRootAt(p0, p1, p2, val, roots) {
        var a = p0 - 2 * p1 + p2;
        var b = 2 * (p1 - p0);
        var c = p0 - val;
        var n = 0;
        if (isAroundZero(a)) {
            if (isNotAroundZero(b)) {
                var t1 = -c / b;
                if (t1 >= 0 && t1 <= 1) {
                    roots[n++] = t1;
                }
            }
        } else {
            var disc = b * b - 4 * a * c;
            if (isAroundZero(disc)) {
                var t1 = -b / (2 * a);
                if (t1 >= 0 && t1 <= 1) {
                    roots[n++] = t1;
                }
            } else if (disc > 0) {
                var discSqrt = Math.sqrt(disc);
                var t1 = (-b + discSqrt) / (2 * a);
                var t2 = (-b - discSqrt) / (2 * a);
                if (t1 >= 0 && t1 <= 1) {
                    roots[n++] = t1;
                }
                if (t2 >= 0 && t2 <= 1) {
                    roots[n++] = t2;
                }
            }
        }
        return n;
    }
    function quadraticExtremum(p0, p1, p2) {
        var divider = p0 + p2 - 2 * p1;
        if (divider === 0) {
            return 0.5;
        } else {
            return (p0 - p1) / divider;
        }
    }
    function quadraticSubdivide(p0, p1, p2, t, out) {
        var p01 = (p1 - p0) * t + p0;
        var p12 = (p2 - p1) * t + p1;
        var p012 = (p12 - p01) * t + p01;
        out[0] = p0;
        out[1] = p01;
        out[2] = p012;
        out[3] = p012;
        out[4] = p12;
        out[5] = p2;
    }
    function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
        var t;
        var interval = 0.005;
        var d = Infinity;
        _v0[0] = x;
        _v0[1] = y;
        for (var _t = 0; _t < 1; _t += 0.05) {
            _v1[0] = quadraticAt(x0, x1, x2, _t);
            _v1[1] = quadraticAt(y0, y1, y2, _t);
            var d1 = vector.distSquare(_v0, _v1);
            if (d1 < d) {
                t = _t;
                d = d1;
            }
        }
        d = Infinity;
        for (var i = 0; i < 32; i++) {
            if (interval < EPSILON) {
                break;
            }
            var prev = t - interval;
            var next = t + interval;
            _v1[0] = quadraticAt(x0, x1, x2, prev);
            _v1[1] = quadraticAt(y0, y1, y2, prev);
            var d1 = vector.distSquare(_v1, _v0);
            if (prev >= 0 && d1 < d) {
                t = prev;
                d = d1;
            } else {
                _v2[0] = quadraticAt(x0, x1, x2, next);
                _v2[1] = quadraticAt(y0, y1, y2, next);
                var d2 = vector.distSquare(_v2, _v0);
                if (next <= 1 && d2 < d) {
                    t = next;
                    d = d2;
                } else {
                    interval *= 0.5;
                }
            }
        }
        if (out) {
            out[0] = quadraticAt(x0, x1, x2, t);
            out[1] = quadraticAt(y0, y1, y2, t);
        }
        return Math.sqrt(d);
    }
    return {
        cubicAt: cubicAt,
        cubicDerivativeAt: cubicDerivativeAt,
        cubicRootAt: cubicRootAt,
        cubicExtrema: cubicExtrema,
        cubicSubdivide: cubicSubdivide,
        cubicProjectPoint: cubicProjectPoint,
        quadraticAt: quadraticAt,
        quadraticDerivativeAt: quadraticDerivativeAt,
        quadraticRootAt: quadraticRootAt,
        quadraticExtremum: quadraticExtremum,
        quadraticSubdivide: quadraticSubdivide,
        quadraticProjectPoint: quadraticProjectPoint
    };
});define('zrender/mixin/Transformable', [
    'require',
    '../tool/matrix',
    '../tool/vector'
], function (require) {
    'use strict';
    var matrix = require('../tool/matrix');
    var vector = require('../tool/vector');
    var origin = [
        0,
        0
    ];
    var mTranslate = matrix.translate;
    var EPSILON = 0.00005;
    function isAroundZero(val) {
        return val > -EPSILON && val < EPSILON;
    }
    function isNotAroundZero(val) {
        return val > EPSILON || val < -EPSILON;
    }
    var Transformable = function () {
        if (!this.position) {
            this.position = [
                0,
                0
            ];
        }
        if (typeof this.rotation == 'undefined') {
            this.rotation = [
                0,
                0,
                0
            ];
        }
        if (!this.scale) {
            this.scale = [
                1,
                1,
                0,
                0
            ];
        }
        this.needLocalTransform = false;
        this.needTransform = false;
    };
    Transformable.prototype = {
        constructor: Transformable,
        updateNeedTransform: function () {
            this.needLocalTransform = isNotAroundZero(this.rotation[0]) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);
        },
        updateTransform: function () {
            this.updateNeedTransform();
            var parentHasTransform = this.parent && this.parent.needTransform;
            this.needTransform = this.needLocalTransform || parentHasTransform;
            if (!this.needTransform) {
                return;
            }
            var m = this.transform || matrix.create();
            matrix.identity(m);
            if (this.needLocalTransform) {
                var scale = this.scale;
                if (isNotAroundZero(scale[0]) || isNotAroundZero(scale[1])) {
                    origin[0] = -scale[2] || 0;
                    origin[1] = -scale[3] || 0;
                    var haveOrigin = isNotAroundZero(origin[0]) || isNotAroundZero(origin[1]);
                    if (haveOrigin) {
                        mTranslate(m, m, origin);
                    }
                    matrix.scale(m, m, scale);
                    if (haveOrigin) {
                        origin[0] = -origin[0];
                        origin[1] = -origin[1];
                        mTranslate(m, m, origin);
                    }
                }
                if (this.rotation instanceof Array) {
                    if (this.rotation[0] !== 0) {
                        origin[0] = -this.rotation[1] || 0;
                        origin[1] = -this.rotation[2] || 0;
                        var haveOrigin = isNotAroundZero(origin[0]) || isNotAroundZero(origin[1]);
                        if (haveOrigin) {
                            mTranslate(m, m, origin);
                        }
                        matrix.rotate(m, m, this.rotation[0]);
                        if (haveOrigin) {
                            origin[0] = -origin[0];
                            origin[1] = -origin[1];
                            mTranslate(m, m, origin);
                        }
                    }
                } else {
                    if (this.rotation !== 0) {
                        matrix.rotate(m, m, this.rotation);
                    }
                }
                if (isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1])) {
                    mTranslate(m, m, this.position);
                }
            }
            if (parentHasTransform) {
                if (this.needLocalTransform) {
                    matrix.mul(m, this.parent.transform, m);
                } else {
                    matrix.copy(m, this.parent.transform);
                }
            }
            this.transform = m;
            this.invTransform = this.invTransform || matrix.create();
            matrix.invert(this.invTransform, m);
        },
        setTransform: function (ctx) {
            if (this.needTransform) {
                var m = this.transform;
                ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
            }
        },
        lookAt: function () {
            var v = vector.create();
            return function (target) {
                if (!this.transform) {
                    this.transform = matrix.create();
                }
                var m = this.transform;
                vector.sub(v, target, this.position);
                if (isAroundZero(v[0]) && isAroundZero(v[1])) {
                    return;
                }
                vector.normalize(v, v);
                var scale = this.scale;
                m[2] = v[0] * scale[1];
                m[3] = v[1] * scale[1];
                m[0] = v[1] * scale[0];
                m[1] = -v[0] * scale[0];
                m[4] = this.position[0];
                m[5] = this.position[1];
                this.decomposeTransform();
            };
        }(),
        decomposeTransform: function () {
            if (!this.transform) {
                return;
            }
            var m = this.transform;
            var sx = m[0] * m[0] + m[1] * m[1];
            var position = this.position;
            var scale = this.scale;
            var rotation = this.rotation;
            if (isNotAroundZero(sx - 1)) {
                sx = Math.sqrt(sx);
            }
            var sy = m[2] * m[2] + m[3] * m[3];
            if (isNotAroundZero(sy - 1)) {
                sy = Math.sqrt(sy);
            }
            position[0] = m[4];
            position[1] = m[5];
            scale[0] = sx;
            scale[1] = sy;
            scale[2] = scale[3] = 0;
            rotation[0] = Math.atan2(-m[1] / sy, m[0] / sx);
            rotation[1] = rotation[2] = 0;
        },
        transformCoordToLocal: function (x, y) {
            var v2 = [
                x,
                y
            ];
            if (this.needTransform && this.invTransform) {
                matrix.mulVector(v2, this.invTransform, v2);
            }
            return v2;
        }
    };
    return Transformable;
});define('zrender/Group', [
    'require',
    './tool/guid',
    './tool/util',
    './mixin/Transformable',
    './mixin/Eventful'
], function (require) {
    var guid = require('./tool/guid');
    var util = require('./tool/util');
    var Transformable = require('./mixin/Transformable');
    var Eventful = require('./mixin/Eventful');
    var Group = function (options) {
        options = options || {};
        this.id = options.id || guid();
        for (var key in options) {
            this[key] = options[key];
        }
        this.type = 'group';
        this.clipShape = null;
        this._children = [];
        this._storage = null;
        this.__dirty = true;
        Transformable.call(this);
        Eventful.call(this);
    };
    Group.prototype.ignore = false;
    Group.prototype.children = function () {
        return this._children.slice();
    };
    Group.prototype.childAt = function (idx) {
        return this._children[idx];
    };
    Group.prototype.addChild = function (child) {
        if (child == this) {
            return;
        }
        if (child.parent == this) {
            return;
        }
        if (child.parent) {
            child.parent.removeChild(child);
        }
        this._children.push(child);
        child.parent = this;
        if (this._storage && this._storage !== child._storage) {
            this._storage.addToMap(child);
            if (child instanceof Group) {
                child.addChildrenToStorage(this._storage);
            }
        }
    };
    Group.prototype.removeChild = function (child) {
        var idx = util.indexOf(this._children, child);
        if (idx >= 0) {
            this._children.splice(idx, 1);
        }
        child.parent = null;
        if (this._storage) {
            this._storage.delFromMap(child.id);
            if (child instanceof Group) {
                child.delChildrenFromStorage(this._storage);
            }
        }
    };
    Group.prototype.clearChildren = function () {
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            if (this._storage) {
                this._storage.delFromMap(child.id);
                if (child instanceof Group) {
                    child.delChildrenFromStorage(this._storage);
                }
            }
        }
        this._children.length = 0;
    };
    Group.prototype.eachChild = function (cb, context) {
        var haveContext = !!context;
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            if (haveContext) {
                cb.call(context, child);
            } else {
                cb(child);
            }
        }
    };
    Group.prototype.traverse = function (cb, context) {
        var haveContext = !!context;
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            if (haveContext) {
                cb.call(context, child);
            } else {
                cb(child);
            }
            if (child.type === 'group') {
                child.traverse(cb, context);
            }
        }
    };
    Group.prototype.addChildrenToStorage = function (storage) {
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            storage.addToMap(child);
            if (child instanceof Group) {
                child.addChildrenToStorage(storage);
            }
        }
    };
    Group.prototype.delChildrenFromStorage = function (storage) {
        for (var i = 0; i < this._children.length; i++) {
            var child = this._children[i];
            storage.delFromMap(child.id);
            if (child instanceof Group) {
                child.delChildrenFromStorage(storage);
            }
        }
    };
    Group.prototype.modSelf = function () {
        this.__dirty = true;
    };
    util.merge(Group.prototype, Transformable.prototype, true);
    util.merge(Group.prototype, Eventful.prototype, true);
    return Group;
});define('zrender/animation/Clip', [
    'require',
    './easing'
], function (require) {
    var Easing = require('./easing');
    function Clip(options) {
        this._targetPool = options.target || {};
        if (!(this._targetPool instanceof Array)) {
            this._targetPool = [this._targetPool];
        }
        this._life = options.life || 1000;
        this._delay = options.delay || 0;
        this._startTime = new Date().getTime() + this._delay;
        this._endTime = this._startTime + this._life * 1000;
        this.loop = typeof options.loop == 'undefined' ? false : options.loop;
        this.gap = options.gap || 0;
        this.easing = options.easing || 'Linear';
        this.onframe = options.onframe;
        this.ondestroy = options.ondestroy;
        this.onrestart = options.onrestart;
    }
    Clip.prototype = {
        step: function (time) {
            var percent = (time - this._startTime) / this._life;
            if (percent < 0) {
                return;
            }
            percent = Math.min(percent, 1);
            var easingFunc = typeof this.easing == 'string' ? Easing[this.easing] : this.easing;
            var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;
            this.fire('frame', schedule);
            if (percent == 1) {
                if (this.loop) {
                    this.restart();
                    return 'restart';
                }
                this._needsRemove = true;
                return 'destroy';
            }
            return null;
        },
        restart: function () {
            var time = new Date().getTime();
            var remainder = (time - this._startTime) % this._life;
            this._startTime = new Date().getTime() - remainder + this.gap;
            this._needsRemove = false;
        },
        fire: function (eventType, arg) {
            for (var i = 0, len = this._targetPool.length; i < len; i++) {
                if (this['on' + eventType]) {
                    this['on' + eventType](this._targetPool[i], arg);
                }
            }
        },
        constructor: Clip
    };
    return Clip;
});define('zrender/animation/easing', [], function () {
    var easing = {
        Linear: function (k) {
            return k;
        },
        QuadraticIn: function (k) {
            return k * k;
        },
        QuadraticOut: function (k) {
            return k * (2 - k);
        },
        QuadraticInOut: function (k) {
            if ((k *= 2) < 1) {
                return 0.5 * k * k;
            }
            return -0.5 * (--k * (k - 2) - 1);
        },
        CubicIn: function (k) {
            return k * k * k;
        },
        CubicOut: function (k) {
            return --k * k * k + 1;
        },
        CubicInOut: function (k) {
            if ((k *= 2) < 1) {
                return 0.5 * k * k * k;
            }
            return 0.5 * ((k -= 2) * k * k + 2);
        },
        QuarticIn: function (k) {
            return k * k * k * k;
        },
        QuarticOut: function (k) {
            return 1 - --k * k * k * k;
        },
        QuarticInOut: function (k) {
            if ((k *= 2) < 1) {
                return 0.5 * k * k * k * k;
            }
            return -0.5 * ((k -= 2) * k * k * k - 2);
        },
        QuinticIn: function (k) {
            return k * k * k * k * k;
        },
        QuinticOut: function (k) {
            return --k * k * k * k * k + 1;
        },
        QuinticInOut: function (k) {
            if ((k *= 2) < 1) {
                return 0.5 * k * k * k * k * k;
            }
            return 0.5 * ((k -= 2) * k * k * k * k + 2);
        },
        SinusoidalIn: function (k) {
            return 1 - Math.cos(k * Math.PI / 2);
        },
        SinusoidalOut: function (k) {
            return Math.sin(k * Math.PI / 2);
        },
        SinusoidalInOut: function (k) {
            return 0.5 * (1 - Math.cos(Math.PI * k));
        },
        ExponentialIn: function (k) {
            return k === 0 ? 0 : Math.pow(1024, k - 1);
        },
        ExponentialOut: function (k) {
            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
        },
        ExponentialInOut: function (k) {
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            if ((k *= 2) < 1) {
                return 0.5 * Math.pow(1024, k - 1);
            }
            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
        },
        CircularIn: function (k) {
            return 1 - Math.sqrt(1 - k * k);
        },
        CircularOut: function (k) {
            return Math.sqrt(1 - --k * k);
        },
        CircularInOut: function (k) {
            if ((k *= 2) < 1) {
                return -0.5 * (Math.sqrt(1 - k * k) - 1);
            }
            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
        },
        ElasticIn: function (k) {
            var s;
            var a = 0.1;
            var p = 0.4;
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            if (!a || a < 1) {
                a = 1;
                s = p / 4;
            } else {
                s = p * Math.asin(1 / a) / (2 * Math.PI);
            }
            return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
        },
        ElasticOut: function (k) {
            var s;
            var a = 0.1;
            var p = 0.4;
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            if (!a || a < 1) {
                a = 1;
                s = p / 4;
            } else {
                s = p * Math.asin(1 / a) / (2 * Math.PI);
            }
            return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
        },
        ElasticInOut: function (k) {
            var s;
            var a = 0.1;
            var p = 0.4;
            if (k === 0) {
                return 0;
            }
            if (k === 1) {
                return 1;
            }
            if (!a || a < 1) {
                a = 1;
                s = p / 4;
            } else {
                s = p * Math.asin(1 / a) / (2 * Math.PI);
            }
            if ((k *= 2) < 1) {
                return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
            }
            return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
        },
        BackIn: function (k) {
            var s = 1.70158;
            return k * k * ((s + 1) * k - s);
        },
        BackOut: function (k) {
            var s = 1.70158;
            return --k * k * ((s + 1) * k + s) + 1;
        },
        BackInOut: function (k) {
            var s = 1.70158 * 1.525;
            if ((k *= 2) < 1) {
                return 0.5 * (k * k * ((s + 1) * k - s));
            }
            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
        },
        BounceIn: function (k) {
            return 1 - easing.BounceOut(1 - k);
        },
        BounceOut: function (k) {
            if (k < 1 / 2.75) {
                return 7.5625 * k * k;
            } else if (k < 2 / 2.75) {
                return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
            } else if (k < 2.5 / 2.75) {
                return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
            } else {
                return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
            }
        },
        BounceInOut: function (k) {
            if (k < 0.5) {
                return easing.BounceIn(k * 2) * 0.5;
            }
            return easing.BounceOut(k * 2 - 1) * 0.5 + 0.5;
        }
    };
    return easing;
});define('echarts/chart/base', [
    'require',
    'zrender/shape/Image',
    '../util/shape/Icon',
    '../util/shape/MarkLine',
    '../util/shape/Symbol',
    'zrender/shape/Polyline',
    'zrender/shape/ShapeBundle',
    '../config',
    '../util/ecData',
    '../util/ecAnimation',
    '../util/ecEffect',
    '../util/accMath',
    '../component/base',
    '../layout/EdgeBundling',
    'zrender/tool/util',
    'zrender/tool/area'
], function (require) {
    var ImageShape = require('zrender/shape/Image');
    var IconShape = require('../util/shape/Icon');
    var MarkLineShape = require('../util/shape/MarkLine');
    var SymbolShape = require('../util/shape/Symbol');
    var PolylineShape = require('zrender/shape/Polyline');
    var ShapeBundle = require('zrender/shape/ShapeBundle');
    var ecConfig = require('../config');
    var ecData = require('../util/ecData');
    var ecAnimation = require('../util/ecAnimation');
    var ecEffect = require('../util/ecEffect');
    var accMath = require('../util/accMath');
    var ComponentBase = require('../component/base');
    var EdgeBundling = require('../layout/EdgeBundling');
    var zrUtil = require('zrender/tool/util');
    var zrArea = require('zrender/tool/area');
    function isCoordAvailable(coord) {
        return coord.x != null && coord.y != null;
    }
    function Base(ecTheme, messageCenter, zr, option, myChart) {
        ComponentBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        var self = this;
        this.selectedMap = {};
        this.lastShapeList = [];
        this.shapeHandler = {
            onclick: function () {
                self.isClick = true;
            },
            ondragover: function (param) {
                var calculableShape = param.target;
                calculableShape.highlightStyle = calculableShape.highlightStyle || {};
                var highlightStyle = calculableShape.highlightStyle;
                var brushType = highlightStyle.brushTyep;
                var strokeColor = highlightStyle.strokeColor;
                var lineWidth = highlightStyle.lineWidth;
                highlightStyle.brushType = 'stroke';
                highlightStyle.strokeColor = self.ecTheme.calculableColor || ecConfig.calculableColor;
                highlightStyle.lineWidth = calculableShape.type === 'icon' ? 30 : 10;
                self.zr.addHoverShape(calculableShape);
                setTimeout(function () {
                    if (highlightStyle) {
                        highlightStyle.brushType = brushType;
                        highlightStyle.strokeColor = strokeColor;
                        highlightStyle.lineWidth = lineWidth;
                    }
                }, 20);
            },
            ondrop: function (param) {
                if (ecData.get(param.dragged, 'data') != null) {
                    self.isDrop = true;
                }
            },
            ondragend: function () {
                self.isDragend = true;
            }
        };
    }
    Base.prototype = {
        setCalculable: function (shape) {
            shape.dragEnableTime = this.ecTheme.DRAG_ENABLE_TIME || ecConfig.DRAG_ENABLE_TIME;
            shape.ondragover = this.shapeHandler.ondragover;
            shape.ondragend = this.shapeHandler.ondragend;
            shape.ondrop = this.shapeHandler.ondrop;
            return shape;
        },
        ondrop: function (param, status) {
            if (!this.isDrop || !param.target || status.dragIn) {
                return;
            }
            var target = param.target;
            var dragged = param.dragged;
            var seriesIndex = ecData.get(target, 'seriesIndex');
            var dataIndex = ecData.get(target, 'dataIndex');
            var series = this.series;
            var data;
            var legend = this.component.legend;
            if (dataIndex === -1) {
                if (ecData.get(dragged, 'seriesIndex') == seriesIndex) {
                    status.dragOut = status.dragIn = status.needRefresh = true;
                    this.isDrop = false;
                    return;
                }
                data = {
                    value: ecData.get(dragged, 'value'),
                    name: ecData.get(dragged, 'name')
                };
                if (this.type === ecConfig.CHART_TYPE_PIE && data.value < 0) {
                    data.value = 0;
                }
                var hasFind = false;
                var sData = series[seriesIndex].data;
                for (var i = 0, l = sData.length; i < l; i++) {
                    if (sData[i].name === data.name && sData[i].value === '-') {
                        series[seriesIndex].data[i].value = data.value;
                        hasFind = true;
                    }
                }
                !hasFind && series[seriesIndex].data.push(data);
                legend && legend.add(data.name, dragged.style.color || dragged.style.strokeColor);
            } else {
                data = series[seriesIndex].data[dataIndex] || '-';
                if (data.value != null) {
                    if (data.value != '-') {
                        series[seriesIndex].data[dataIndex].value = accMath.accAdd(series[seriesIndex].data[dataIndex].value, ecData.get(dragged, 'value'));
                    } else {
                        series[seriesIndex].data[dataIndex].value = ecData.get(dragged, 'value');
                    }
                    if (this.type === ecConfig.CHART_TYPE_FUNNEL || this.type === ecConfig.CHART_TYPE_PIE) {
                        legend && legend.getRelatedAmount(data.name) === 1 && this.component.legend.del(data.name);
                        data.name += this.option.nameConnector + ecData.get(dragged, 'name');
                        legend && legend.add(data.name, dragged.style.color || dragged.style.strokeColor);
                    }
                } else {
                    if (data != '-') {
                        series[seriesIndex].data[dataIndex] = accMath.accAdd(series[seriesIndex].data[dataIndex], ecData.get(dragged, 'value'));
                    } else {
                        series[seriesIndex].data[dataIndex] = ecData.get(dragged, 'value');
                    }
                }
            }
            status.dragIn = status.dragIn || true;
            this.isDrop = false;
            var self = this;
            setTimeout(function () {
                self.zr.trigger('mousemove', param.event);
            }, 300);
            return;
        },
        ondragend: function (param, status) {
            if (!this.isDragend || !param.target || status.dragOut) {
                return;
            }
            var target = param.target;
            var seriesIndex = ecData.get(target, 'seriesIndex');
            var dataIndex = ecData.get(target, 'dataIndex');
            var series = this.series;
            if (series[seriesIndex].data[dataIndex].value != null) {
                series[seriesIndex].data[dataIndex].value = '-';
                var name = series[seriesIndex].data[dataIndex].name;
                var legend = this.component.legend;
                if (legend && legend.getRelatedAmount(name) === 0) {
                    legend.del(name);
                }
            } else {
                series[seriesIndex].data[dataIndex] = '-';
            }
            status.dragOut = true;
            status.needRefresh = true;
            this.isDragend = false;
            return;
        },
        onlegendSelected: function (param, status) {
            var legendSelected = param.selected;
            for (var itemName in this.selectedMap) {
                if (this.selectedMap[itemName] != legendSelected[itemName]) {
                    status.needRefresh = true;
                }
                this.selectedMap[itemName] = legendSelected[itemName];
            }
            return;
        },
        _buildPosition: function () {
            this._symbol = this.option.symbolList;
            this._sIndex2ShapeMap = {};
            this._sIndex2ColorMap = {};
            this.selectedMap = {};
            this.xMarkMap = {};
            var series = this.series;
            var _position2sIndexMap = {
                top: [],
                bottom: [],
                left: [],
                right: [],
                other: []
            };
            var xAxisIndex;
            var yAxisIndex;
            var xAxis;
            var yAxis;
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].type === this.type) {
                    series[i] = this.reformOption(series[i]);
                    this.legendHoverLink = series[i].legendHoverLink || this.legendHoverLink;
                    xAxisIndex = series[i].xAxisIndex;
                    yAxisIndex = series[i].yAxisIndex;
                    xAxis = this.component.xAxis.getAxis(xAxisIndex);
                    yAxis = this.component.yAxis.getAxis(yAxisIndex);
                    if (xAxis.type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY) {
                        _position2sIndexMap[xAxis.getPosition()].push(i);
                    } else if (yAxis.type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY) {
                        _position2sIndexMap[yAxis.getPosition()].push(i);
                    } else {
                        _position2sIndexMap.other.push(i);
                    }
                }
            }
            for (var position in _position2sIndexMap) {
                if (_position2sIndexMap[position].length > 0) {
                    this._buildSinglePosition(position, _position2sIndexMap[position]);
                }
            }
            this.addShapeList();
        },
        _buildSinglePosition: function (position, seriesArray) {
            var mapData = this._mapData(seriesArray);
            var locationMap = mapData.locationMap;
            var maxDataLength = mapData.maxDataLength;
            if (maxDataLength === 0 || locationMap.length === 0) {
                return;
            }
            switch (position) {
            case 'bottom':
            case 'top':
                this._buildHorizontal(seriesArray, maxDataLength, locationMap, this.xMarkMap);
                break;
            case 'left':
            case 'right':
                this._buildVertical(seriesArray, maxDataLength, locationMap, this.xMarkMap);
                break;
            case 'other':
                this._buildOther(seriesArray, maxDataLength, locationMap, this.xMarkMap);
                break;
            }
            for (var i = 0, l = seriesArray.length; i < l; i++) {
                this.buildMark(seriesArray[i]);
            }
        },
        _mapData: function (seriesArray) {
            var series = this.series;
            var serie;
            var dataIndex = 0;
            var stackMap = {};
            var magicStackKey = '__kener__stack__';
            var stackKey;
            var serieName;
            var legend = this.component.legend;
            var locationMap = [];
            var maxDataLength = 0;
            var iconShape;
            for (var i = 0, l = seriesArray.length; i < l; i++) {
                serie = series[seriesArray[i]];
                serieName = serie.name;
                this._sIndex2ShapeMap[seriesArray[i]] = this._sIndex2ShapeMap[seriesArray[i]] || this.query(serie, 'symbol') || this._symbol[i % this._symbol.length];
                if (legend) {
                    this.selectedMap[serieName] = legend.isSelected(serieName);
                    this._sIndex2ColorMap[seriesArray[i]] = legend.getColor(serieName);
                    iconShape = legend.getItemShape(serieName);
                    if (iconShape) {
                        var style = iconShape.style;
                        if (this.type == ecConfig.CHART_TYPE_LINE) {
                            style.iconType = 'legendLineIcon';
                            style.symbol = this._sIndex2ShapeMap[seriesArray[i]];
                        } else if (serie.itemStyle.normal.barBorderWidth > 0) {
                            var highlightStyle = iconShape.highlightStyle;
                            style.brushType = 'both';
                            style.x += 1;
                            style.y += 1;
                            style.width -= 2;
                            style.height -= 2;
                            style.strokeColor = highlightStyle.strokeColor = serie.itemStyle.normal.barBorderColor;
                            highlightStyle.lineWidth = 3;
                        }
                        legend.setItemShape(serieName, iconShape);
                    }
                } else {
                    this.selectedMap[serieName] = true;
                    this._sIndex2ColorMap[seriesArray[i]] = this.zr.getColor(seriesArray[i]);
                }
                if (this.selectedMap[serieName]) {
                    stackKey = serie.stack || magicStackKey + seriesArray[i];
                    if (stackMap[stackKey] == null) {
                        stackMap[stackKey] = dataIndex;
                        locationMap[dataIndex] = [seriesArray[i]];
                        dataIndex++;
                    } else {
                        locationMap[stackMap[stackKey]].push(seriesArray[i]);
                    }
                }
                maxDataLength = Math.max(maxDataLength, serie.data.length);
            }
            return {
                locationMap: locationMap,
                maxDataLength: maxDataLength
            };
        },
        _calculMarkMapXY: function (xMarkMap, locationMap, xy) {
            var series = this.series;
            for (var j = 0, k = locationMap.length; j < k; j++) {
                for (var m = 0, n = locationMap[j].length; m < n; m++) {
                    var seriesIndex = locationMap[j][m];
                    var valueIndex = xy == 'xy' ? 0 : '';
                    var grid = this.component.grid;
                    var tarMark = xMarkMap[seriesIndex];
                    if (xy.indexOf('x') != '-1') {
                        if (tarMark['counter' + valueIndex] > 0) {
                            tarMark['average' + valueIndex] = tarMark['sum' + valueIndex] / tarMark['counter' + valueIndex];
                        }
                        var x = this.component.xAxis.getAxis(series[seriesIndex].xAxisIndex || 0).getCoord(tarMark['average' + valueIndex]);
                        tarMark['averageLine' + valueIndex] = [
                            [
                                x,
                                grid.getYend()
                            ],
                            [
                                x,
                                grid.getY()
                            ]
                        ];
                        tarMark['minLine' + valueIndex] = [
                            [
                                tarMark['minX' + valueIndex],
                                grid.getYend()
                            ],
                            [
                                tarMark['minX' + valueIndex],
                                grid.getY()
                            ]
                        ];
                        tarMark['maxLine' + valueIndex] = [
                            [
                                tarMark['maxX' + valueIndex],
                                grid.getYend()
                            ],
                            [
                                tarMark['maxX' + valueIndex],
                                grid.getY()
                            ]
                        ];
                        tarMark.isHorizontal = false;
                    }
                    valueIndex = xy == 'xy' ? 1 : '';
                    if (xy.indexOf('y') != '-1') {
                        if (tarMark['counter' + valueIndex] > 0) {
                            tarMark['average' + valueIndex] = tarMark['sum' + valueIndex] / tarMark['counter' + valueIndex];
                        }
                        var y = this.component.yAxis.getAxis(series[seriesIndex].yAxisIndex || 0).getCoord(tarMark['average' + valueIndex]);
                        tarMark['averageLine' + valueIndex] = [
                            [
                                grid.getX(),
                                y
                            ],
                            [
                                grid.getXend(),
                                y
                            ]
                        ];
                        tarMark['minLine' + valueIndex] = [
                            [
                                grid.getX(),
                                tarMark['minY' + valueIndex]
                            ],
                            [
                                grid.getXend(),
                                tarMark['minY' + valueIndex]
                            ]
                        ];
                        tarMark['maxLine' + valueIndex] = [
                            [
                                grid.getX(),
                                tarMark['maxY' + valueIndex]
                            ],
                            [
                                grid.getXend(),
                                tarMark['maxY' + valueIndex]
                            ]
                        ];
                        tarMark.isHorizontal = true;
                    }
                }
            }
        },
        addLabel: function (tarShape, serie, data, name, orient) {
            var queryTarget = [
                data,
                serie
            ];
            var nLabel = this.deepMerge(queryTarget, 'itemStyle.normal.label');
            var eLabel = this.deepMerge(queryTarget, 'itemStyle.emphasis.label');
            var nTextStyle = nLabel.textStyle || {};
            var eTextStyle = eLabel.textStyle || {};
            if (nLabel.show) {
                var style = tarShape.style;
                style.text = this._getLabelText(serie, data, name, 'normal');
                style.textPosition = nLabel.position == null ? orient === 'horizontal' ? 'right' : 'top' : nLabel.position;
                style.textColor = nTextStyle.color;
                style.textFont = this.getFont(nTextStyle);
                style.textAlign = nTextStyle.align;
                style.textBaseline = nTextStyle.baseline;
            }
            if (eLabel.show) {
                var highlightStyle = tarShape.highlightStyle;
                highlightStyle.text = this._getLabelText(serie, data, name, 'emphasis');
                highlightStyle.textPosition = nLabel.show ? tarShape.style.textPosition : eLabel.position == null ? orient === 'horizontal' ? 'right' : 'top' : eLabel.position;
                highlightStyle.textColor = eTextStyle.color;
                highlightStyle.textFont = this.getFont(eTextStyle);
                highlightStyle.textAlign = eTextStyle.align;
                highlightStyle.textBaseline = eTextStyle.baseline;
            }
            return tarShape;
        },
        _getLabelText: function (serie, data, name, status) {
            var formatter = this.deepQuery([
                data,
                serie
            ], 'itemStyle.' + status + '.label.formatter');
            if (!formatter && status === 'emphasis') {
                formatter = this.deepQuery([
                    data,
                    serie
                ], 'itemStyle.normal.label.formatter');
            }
            var value = this.getDataFromOption(data, '-');
            if (formatter) {
                if (typeof formatter === 'function') {
                    return formatter.call(this.myChart, {
                        seriesName: serie.name,
                        series: serie,
                        name: name,
                        value: value,
                        data: data,
                        status: status
                    });
                } else if (typeof formatter === 'string') {
                    formatter = formatter.replace('{a}', '{a0}').replace('{b}', '{b0}').replace('{c}', '{c0}').replace('{a0}', serie.name).replace('{b0}', name).replace('{c0}', this.numAddCommas(value));
                    return formatter;
                }
            } else {
                if (value instanceof Array) {
                    return value[2] != null ? this.numAddCommas(value[2]) : value[0] + ' , ' + value[1];
                } else {
                    return this.numAddCommas(value);
                }
            }
        },
        buildMark: function (seriesIndex) {
            var serie = this.series[seriesIndex];
            if (this.selectedMap[serie.name]) {
                serie.markLine && this._buildMarkLine(seriesIndex);
                serie.markPoint && this._buildMarkPoint(seriesIndex);
            }
        },
        _buildMarkPoint: function (seriesIndex) {
            var attachStyle = (this.markAttachStyle || {})[seriesIndex];
            var serie = this.series[seriesIndex];
            var mpData;
            var pos;
            var markPoint = zrUtil.clone(serie.markPoint);
            for (var i = 0, l = markPoint.data.length; i < l; i++) {
                mpData = markPoint.data[i];
                pos = this.getMarkCoord(seriesIndex, mpData);
                mpData.x = mpData.x != null ? mpData.x : pos[0];
                mpData.y = mpData.y != null ? mpData.y : pos[1];
                if (mpData.type && (mpData.type === 'max' || mpData.type === 'min')) {
                    mpData.value = pos[3];
                    mpData.name = mpData.name || mpData.type;
                    mpData.symbolSize = mpData.symbolSize || zrArea.getTextWidth(pos[3], this.getFont()) / 2 + 5;
                }
            }
            var shapeList = this._markPoint(seriesIndex, markPoint);
            for (var i = 0, l = shapeList.length; i < l; i++) {
                var tarShape = shapeList[i];
                tarShape.zlevel = this.getZlevelBase();
                tarShape.z = this.getZBase() + 1;
                for (var key in attachStyle) {
                    tarShape[key] = zrUtil.clone(attachStyle[key]);
                }
                this.shapeList.push(tarShape);
            }
            if (this.type === ecConfig.CHART_TYPE_FORCE || this.type === ecConfig.CHART_TYPE_CHORD) {
                for (var i = 0, l = shapeList.length; i < l; i++) {
                    this.zr.addShape(shapeList[i]);
                }
            }
        },
        _buildMarkLine: function (seriesIndex) {
            var attachStyle = (this.markAttachStyle || {})[seriesIndex];
            var serie = this.series[seriesIndex];
            var pos;
            var markLine = zrUtil.clone(serie.markLine);
            for (var i = 0, l = markLine.data.length; i < l; i++) {
                var mlData = markLine.data[i];
                if (mlData.type && (mlData.type === 'max' || mlData.type === 'min' || mlData.type === 'average')) {
                    pos = this.getMarkCoord(seriesIndex, mlData);
                    markLine.data[i] = [
                        zrUtil.clone(mlData),
                        {}
                    ];
                    markLine.data[i][0].name = mlData.name || mlData.type;
                    markLine.data[i][0].value = mlData.type !== 'average' ? pos[3] : +pos[3].toFixed(markLine.precision != null ? markLine.precision : this.deepQuery([
                        this.ecTheme,
                        ecConfig
                    ], 'markLine.precision'));
                    pos = pos[2];
                    mlData = [
                        {},
                        {}
                    ];
                } else {
                    pos = [
                        this.getMarkCoord(seriesIndex, mlData[0]),
                        this.getMarkCoord(seriesIndex, mlData[1])
                    ];
                }
                if (pos == null || pos[0] == null || pos[1] == null) {
                    continue;
                }
                markLine.data[i][0].x = mlData[0].x != null ? mlData[0].x : pos[0][0];
                markLine.data[i][0].y = mlData[0].y != null ? mlData[0].y : pos[0][1];
                markLine.data[i][1].x = mlData[1].x != null ? mlData[1].x : pos[1][0];
                markLine.data[i][1].y = mlData[1].y != null ? mlData[1].y : pos[1][1];
            }
            var shapeList = this._markLine(seriesIndex, markLine);
            var isLarge = markLine.large;
            if (isLarge) {
                var shapeBundle = new ShapeBundle({ style: { shapeList: shapeList } });
                var firstShape = shapeList[0];
                if (firstShape) {
                    zrUtil.merge(shapeBundle.style, firstShape.style);
                    zrUtil.merge(shapeBundle.highlightStyle = {}, firstShape.highlightStyle);
                    shapeBundle.style.brushType = 'stroke';
                    shapeBundle.zlevel = this.getZlevelBase();
                    shapeBundle.z = this.getZBase() + 1;
                    shapeBundle.hoverable = false;
                    for (var key in attachStyle) {
                        shapeBundle[key] = zrUtil.clone(attachStyle[key]);
                    }
                }
                this.shapeList.push(shapeBundle);
                this.zr.addShape(shapeBundle);
                shapeBundle._mark = 'largeLine';
                var effect = markLine.effect;
                if (effect.show) {
                    shapeBundle.effect = effect;
                }
            } else {
                for (var i = 0, l = shapeList.length; i < l; i++) {
                    var tarShape = shapeList[i];
                    tarShape.zlevel = this.getZlevelBase();
                    tarShape.z = this.getZBase() + 1;
                    for (var key in attachStyle) {
                        tarShape[key] = zrUtil.clone(attachStyle[key]);
                    }
                    this.shapeList.push(tarShape);
                }
                if (this.type === ecConfig.CHART_TYPE_FORCE || this.type === ecConfig.CHART_TYPE_CHORD) {
                    for (var i = 0, l = shapeList.length; i < l; i++) {
                        this.zr.addShape(shapeList[i]);
                    }
                }
            }
        },
        _markPoint: function (seriesIndex, mpOption) {
            var serie = this.series[seriesIndex];
            var component = this.component;
            zrUtil.merge(zrUtil.merge(mpOption, zrUtil.clone(this.ecTheme.markPoint || {})), zrUtil.clone(ecConfig.markPoint));
            mpOption.name = serie.name;
            var pList = [];
            var data = mpOption.data;
            var itemShape;
            var dataRange = component.dataRange;
            var legend = component.legend;
            var color;
            var value;
            var queryTarget;
            var nColor;
            var eColor;
            var effect;
            var zrWidth = this.zr.getWidth();
            var zrHeight = this.zr.getHeight();
            if (!mpOption.large) {
                for (var i = 0, l = data.length; i < l; i++) {
                    if (data[i].x == null || data[i].y == null) {
                        continue;
                    }
                    value = data[i].value != null ? data[i].value : '';
                    if (legend) {
                        color = legend.getColor(serie.name);
                    }
                    if (dataRange) {
                        color = isNaN(value) ? color : dataRange.getColor(value);
                        queryTarget = [
                            data[i],
                            mpOption
                        ];
                        nColor = this.deepQuery(queryTarget, 'itemStyle.normal.color') || color;
                        eColor = this.deepQuery(queryTarget, 'itemStyle.emphasis.color') || nColor;
                        if (nColor == null && eColor == null) {
                            continue;
                        }
                    }
                    color = color == null ? this.zr.getColor(seriesIndex) : color;
                    data[i].tooltip = data[i].tooltip || mpOption.tooltip || { trigger: 'item' };
                    data[i].name = data[i].name != null ? data[i].name : '';
                    data[i].value = value;
                    itemShape = this.getSymbolShape(mpOption, seriesIndex, data[i], i, data[i].name, this.parsePercent(data[i].x, zrWidth), this.parsePercent(data[i].y, zrHeight), 'pin', color, 'rgba(0,0,0,0)', 'horizontal');
                    itemShape._mark = 'point';
                    effect = this.deepMerge([
                        data[i],
                        mpOption
                    ], 'effect');
                    if (effect.show) {
                        itemShape.effect = effect;
                    }
                    if (serie.type === ecConfig.CHART_TYPE_MAP) {
                        itemShape._geo = this.getMarkGeo(data[i]);
                    }
                    ecData.pack(itemShape, serie, seriesIndex, data[i], i, data[i].name, value);
                    pList.push(itemShape);
                }
            } else {
                itemShape = this.getLargeMarkPointShape(seriesIndex, mpOption);
                itemShape._mark = 'largePoint';
                itemShape && pList.push(itemShape);
            }
            return pList;
        },
        _markLine: function () {
            function normalizeOptionValue(mlOption, key) {
                mlOption[key] = mlOption[key] instanceof Array ? mlOption[key].length > 1 ? mlOption[key] : [
                    mlOption[key][0],
                    mlOption[key][0]
                ] : [
                    mlOption[key],
                    mlOption[key]
                ];
            }
            return function (seriesIndex, mlOption) {
                var serie = this.series[seriesIndex];
                var component = this.component;
                var dataRange = component.dataRange;
                var legend = component.legend;
                zrUtil.merge(zrUtil.merge(mlOption, zrUtil.clone(this.ecTheme.markLine || {})), zrUtil.clone(ecConfig.markLine));
                var defaultColor = legend ? legend.getColor(serie.name) : this.zr.getColor(seriesIndex);
                normalizeOptionValue(mlOption, 'symbol');
                normalizeOptionValue(mlOption, 'symbolSize');
                normalizeOptionValue(mlOption, 'symbolRotate');
                var data = mlOption.data;
                var edges = [];
                var zrWidth = this.zr.getWidth();
                var zrHeight = this.zr.getHeight();
                for (var i = 0; i < data.length; i++) {
                    var mlData = data[i];
                    if (isCoordAvailable(mlData[0]) && isCoordAvailable(mlData[1])) {
                        var mergeData = this.deepMerge(mlData);
                        var queryTarget = [
                            mergeData,
                            mlOption
                        ];
                        var color = defaultColor;
                        var value = mergeData.value != null ? mergeData.value : '';
                        if (dataRange) {
                            color = isNaN(value) ? color : dataRange.getColor(value);
                            var nColor = this.deepQuery(queryTarget, 'itemStyle.normal.color') || color;
                            var eColor = this.deepQuery(queryTarget, 'itemStyle.emphasis.color') || nColor;
                            if (nColor == null && eColor == null) {
                                continue;
                            }
                        }
                        mlData[0].tooltip = mergeData.tooltip || mlOption.tooltip || { trigger: 'item' };
                        mlData[0].name = mlData[0].name || '';
                        mlData[1].name = mlData[1].name || '';
                        mlData[0].value = value;
                        edges.push({
                            points: [
                                [
                                    this.parsePercent(mlData[0].x, zrWidth),
                                    this.parsePercent(mlData[0].y, zrHeight)
                                ],
                                [
                                    this.parsePercent(mlData[1].x, zrWidth),
                                    this.parsePercent(mlData[1].y, zrHeight)
                                ]
                            ],
                            rawData: mlData,
                            color: color
                        });
                    }
                }
                var enableBundling = this.query(mlOption, 'bundling.enable');
                if (enableBundling) {
                    var edgeBundling = new EdgeBundling();
                    edgeBundling.maxTurningAngle = this.query(mlOption, 'bundling.maxTurningAngle') / 180 * Math.PI;
                    edges = edgeBundling.run(edges);
                }
                mlOption.name = serie.name;
                var shapeList = [];
                for (var i = 0, l = edges.length; i < l; i++) {
                    var edge = edges[i];
                    var rawEdge = edge.rawEdge || edge;
                    var mlData = rawEdge.rawData;
                    var value = mlData.value != null ? mlData.value : '';
                    var itemShape = this.getMarkLineShape(mlOption, seriesIndex, mlData, i, edge.points, enableBundling, rawEdge.color);
                    itemShape._mark = 'line';
                    var effect = this.deepMerge([
                        mlData[0],
                        mlData[1],
                        mlOption
                    ], 'effect');
                    if (effect.show) {
                        itemShape.effect = effect;
                        itemShape.effect.large = mlOption.large;
                    }
                    if (serie.type === ecConfig.CHART_TYPE_MAP) {
                        itemShape._geo = [
                            this.getMarkGeo(mlData[0]),
                            this.getMarkGeo(mlData[1])
                        ];
                    }
                    ecData.pack(itemShape, serie, seriesIndex, mlData[0], i, mlData[0].name + (mlData[1].name !== '' ? ' > ' + mlData[1].name : ''), value);
                    shapeList.push(itemShape);
                }
                return shapeList;
            };
        }(),
        getMarkCoord: function () {
            return [
                0,
                0
            ];
        },
        getSymbolShape: function (serie, seriesIndex, data, dataIndex, name, x, y, symbol, color, emptyColor, orient) {
            var queryTarget = [
                data,
                serie
            ];
            var value = this.getDataFromOption(data, '-');
            symbol = this.deepQuery(queryTarget, 'symbol') || symbol;
            var symbolSize = this.deepQuery(queryTarget, 'symbolSize');
            symbolSize = typeof symbolSize === 'function' ? symbolSize(value) : symbolSize;
            var symbolRotate = this.deepQuery(queryTarget, 'symbolRotate');
            var normal = this.deepMerge(queryTarget, 'itemStyle.normal');
            var emphasis = this.deepMerge(queryTarget, 'itemStyle.emphasis');
            var nBorderWidth = normal.borderWidth != null ? normal.borderWidth : normal.lineStyle && normal.lineStyle.width;
            if (nBorderWidth == null) {
                nBorderWidth = symbol.match('empty') ? 2 : 0;
            }
            var eBorderWidth = emphasis.borderWidth != null ? emphasis.borderWidth : emphasis.lineStyle && emphasis.lineStyle.width;
            if (eBorderWidth == null) {
                eBorderWidth = nBorderWidth + 2;
            }
            var nColor = this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data);
            var eColor = this.getItemStyleColor(emphasis.color, seriesIndex, dataIndex, data);
            var itemShape = new IconShape({
                style: {
                    iconType: symbol.replace('empty', '').toLowerCase(),
                    x: x - symbolSize,
                    y: y - symbolSize,
                    width: symbolSize * 2,
                    height: symbolSize * 2,
                    brushType: 'both',
                    color: symbol.match('empty') ? emptyColor : nColor || color,
                    strokeColor: normal.borderColor || nColor || color,
                    lineWidth: nBorderWidth
                },
                highlightStyle: {
                    color: symbol.match('empty') ? emptyColor : eColor || nColor || color,
                    strokeColor: emphasis.borderColor || normal.borderColor || eColor || nColor || color,
                    lineWidth: eBorderWidth
                },
                clickable: this.deepQuery(queryTarget, 'clickable')
            });
            if (symbol.match('image')) {
                itemShape.style.image = symbol.replace(new RegExp('^image:\\/\\/'), '');
                itemShape = new ImageShape({
                    style: itemShape.style,
                    highlightStyle: itemShape.highlightStyle,
                    clickable: this.deepQuery(queryTarget, 'clickable')
                });
            }
            if (symbolRotate != null) {
                itemShape.rotation = [
                    symbolRotate * Math.PI / 180,
                    x,
                    y
                ];
            }
            if (symbol.match('star')) {
                itemShape.style.iconType = 'star';
                itemShape.style.n = symbol.replace('empty', '').replace('star', '') - 0 || 5;
            }
            if (symbol === 'none') {
                itemShape.invisible = true;
                itemShape.hoverable = false;
            }
            itemShape = this.addLabel(itemShape, serie, data, name, orient);
            if (symbol.match('empty')) {
                if (itemShape.style.textColor == null) {
                    itemShape.style.textColor = itemShape.style.strokeColor;
                }
                if (itemShape.highlightStyle.textColor == null) {
                    itemShape.highlightStyle.textColor = itemShape.highlightStyle.strokeColor;
                }
            }
            ecData.pack(itemShape, serie, seriesIndex, data, dataIndex, name);
            itemShape._x = x;
            itemShape._y = y;
            itemShape._dataIndex = dataIndex;
            itemShape._seriesIndex = seriesIndex;
            return itemShape;
        },
        getMarkLineShape: function (mlOption, seriesIndex, data, dataIndex, points, bundling, color) {
            var value0 = data[0].value != null ? data[0].value : '-';
            var value1 = data[1].value != null ? data[1].value : '-';
            var symbol = [
                data[0].symbol || mlOption.symbol[0],
                data[1].symbol || mlOption.symbol[1]
            ];
            var symbolSize = [
                data[0].symbolSize || mlOption.symbolSize[0],
                data[1].symbolSize || mlOption.symbolSize[1]
            ];
            symbolSize[0] = typeof symbolSize[0] === 'function' ? symbolSize[0](value0) : symbolSize[0];
            symbolSize[1] = typeof symbolSize[1] === 'function' ? symbolSize[1](value1) : symbolSize[1];
            var symbolRotate = [
                this.query(data[0], 'symbolRotate') || mlOption.symbolRotate[0],
                this.query(data[1], 'symbolRotate') || mlOption.symbolRotate[1]
            ];
            var queryTarget = [
                data[0],
                data[1],
                mlOption
            ];
            var normal = this.deepMerge(queryTarget, 'itemStyle.normal');
            normal.color = this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data);
            var emphasis = this.deepMerge(queryTarget, 'itemStyle.emphasis');
            emphasis.color = this.getItemStyleColor(emphasis.color, seriesIndex, dataIndex, data);
            var nlineStyle = normal.lineStyle;
            var elineStyle = emphasis.lineStyle;
            var nBorderWidth = nlineStyle.width;
            if (nBorderWidth == null) {
                nBorderWidth = normal.borderWidth;
            }
            var eBorderWidth = elineStyle.width;
            if (eBorderWidth == null) {
                eBorderWidth = emphasis.borderWidth != null ? emphasis.borderWidth : nBorderWidth + 2;
            }
            var smoothness = this.deepQuery(queryTarget, 'smoothness');
            if (!this.deepQuery(queryTarget, 'smooth')) {
                smoothness = 0;
            }
            var ShapeCtor = bundling ? PolylineShape : MarkLineShape;
            var itemShape = new ShapeCtor({
                style: {
                    symbol: symbol,
                    symbolSize: symbolSize,
                    symbolRotate: symbolRotate,
                    brushType: 'both',
                    lineType: nlineStyle.type,
                    shadowColor: nlineStyle.shadowColor || nlineStyle.color || normal.borderColor || normal.color || color,
                    shadowBlur: nlineStyle.shadowBlur,
                    shadowOffsetX: nlineStyle.shadowOffsetX,
                    shadowOffsetY: nlineStyle.shadowOffsetY,
                    color: normal.color || color,
                    strokeColor: nlineStyle.color || normal.borderColor || normal.color || color,
                    lineWidth: nBorderWidth,
                    symbolBorderColor: normal.borderColor || normal.color || color,
                    symbolBorder: normal.borderWidth
                },
                highlightStyle: {
                    shadowColor: elineStyle.shadowColor,
                    shadowBlur: elineStyle.shadowBlur,
                    shadowOffsetX: elineStyle.shadowOffsetX,
                    shadowOffsetY: elineStyle.shadowOffsetY,
                    color: emphasis.color || normal.color || color,
                    strokeColor: elineStyle.color || nlineStyle.color || emphasis.borderColor || normal.borderColor || emphasis.color || normal.color || color,
                    lineWidth: eBorderWidth,
                    symbolBorderColor: emphasis.borderColor || normal.borderColor || emphasis.color || normal.color || color,
                    symbolBorder: emphasis.borderWidth == null ? normal.borderWidth + 2 : emphasis.borderWidth
                },
                clickable: this.deepQuery(queryTarget, 'clickable')
            });
            var shapeStyle = itemShape.style;
            if (bundling) {
                shapeStyle.pointList = points;
                shapeStyle.smooth = smoothness;
            } else {
                shapeStyle.xStart = points[0][0];
                shapeStyle.yStart = points[0][1];
                shapeStyle.xEnd = points[1][0];
                shapeStyle.yEnd = points[1][1];
                shapeStyle.curveness = smoothness;
                itemShape.updatePoints(itemShape.style);
            }
            itemShape = this.addLabel(itemShape, mlOption, data[0], data[0].name + ' : ' + data[1].name);
            return itemShape;
        },
        getLargeMarkPointShape: function (seriesIndex, mpOption) {
            var serie = this.series[seriesIndex];
            var component = this.component;
            var data = mpOption.data;
            var itemShape;
            var dataRange = component.dataRange;
            var legend = component.legend;
            var color;
            var value;
            var queryTarget = [
                data[0],
                mpOption
            ];
            var nColor;
            var eColor;
            var effect;
            if (legend) {
                color = legend.getColor(serie.name);
            }
            if (dataRange) {
                value = data[0].value != null ? data[0].value : '';
                color = isNaN(value) ? color : dataRange.getColor(value);
                nColor = this.deepQuery(queryTarget, 'itemStyle.normal.color') || color;
                eColor = this.deepQuery(queryTarget, 'itemStyle.emphasis.color') || nColor;
                if (nColor == null && eColor == null) {
                    return;
                }
            }
            color = this.deepMerge(queryTarget, 'itemStyle.normal').color || color;
            var symbol = this.deepQuery(queryTarget, 'symbol') || 'circle';
            symbol = symbol.replace('empty', '').replace(/\d/g, '');
            effect = this.deepMerge([
                data[0],
                mpOption
            ], 'effect');
            var devicePixelRatio = window.devicePixelRatio || 1;
            itemShape = new SymbolShape({
                style: {
                    pointList: data,
                    color: color,
                    strokeColor: color,
                    shadowColor: effect.shadowColor || color,
                    shadowBlur: (effect.shadowBlur != null ? effect.shadowBlur : 8) * devicePixelRatio,
                    size: this.deepQuery(queryTarget, 'symbolSize'),
                    iconType: symbol,
                    brushType: 'fill',
                    lineWidth: 1
                },
                draggable: false,
                hoverable: false
            });
            if (effect.show) {
                itemShape.effect = effect;
            }
            return itemShape;
        },
        backupShapeList: function () {
            if (this.shapeList && this.shapeList.length > 0) {
                this.lastShapeList = this.shapeList;
                this.shapeList = [];
            } else {
                this.lastShapeList = [];
            }
        },
        addShapeList: function () {
            var maxLenth = this.option.animationThreshold / (this.canvasSupported ? 2 : 4);
            var lastShapeList = this.lastShapeList;
            var shapeList = this.shapeList;
            var isUpdate = lastShapeList.length > 0;
            var duration = isUpdate ? this.query(this.option, 'animationDurationUpdate') : this.query(this.option, 'animationDuration');
            var easing = this.query(this.option, 'animationEasing');
            var delay;
            var key;
            var oldMap = {};
            var newMap = {};
            if (this.option.animation && !this.option.renderAsImage && shapeList.length < maxLenth && !this.motionlessOnce) {
                for (var i = 0, l = lastShapeList.length; i < l; i++) {
                    key = this._getAnimationKey(lastShapeList[i]);
                    if (key.match('undefined')) {
                        this.zr.delShape(lastShapeList[i].id);
                    } else {
                        key += lastShapeList[i].type;
                        if (oldMap[key]) {
                            this.zr.delShape(lastShapeList[i].id);
                        } else {
                            oldMap[key] = lastShapeList[i];
                        }
                    }
                }
                for (var i = 0, l = shapeList.length; i < l; i++) {
                    key = this._getAnimationKey(shapeList[i]);
                    if (key.match('undefined')) {
                        this.zr.addShape(shapeList[i]);
                    } else {
                        key += shapeList[i].type;
                        newMap[key] = shapeList[i];
                    }
                }
                for (key in oldMap) {
                    if (!newMap[key]) {
                        this.zr.delShape(oldMap[key].id);
                    }
                }
                for (key in newMap) {
                    if (oldMap[key]) {
                        this.zr.delShape(oldMap[key].id);
                        this._animateMod(oldMap[key], newMap[key], duration, easing, 0, isUpdate);
                    } else {
                        delay = (this.type == ecConfig.CHART_TYPE_LINE || this.type == ecConfig.CHART_TYPE_RADAR) && key.indexOf('icon') !== 0 ? duration / 2 : 0;
                        this._animateMod(false, newMap[key], duration, easing, delay, isUpdate);
                    }
                }
                this.zr.refresh();
                this.animationEffect();
            } else {
                this.motionlessOnce = false;
                this.zr.delShape(lastShapeList);
                for (var i = 0, l = shapeList.length; i < l; i++) {
                    this.zr.addShape(shapeList[i]);
                }
            }
        },
        _getAnimationKey: function (shape) {
            if (this.type != ecConfig.CHART_TYPE_MAP) {
                return ecData.get(shape, 'seriesIndex') + '_' + ecData.get(shape, 'dataIndex') + (shape._mark ? shape._mark : '') + (this.type === ecConfig.CHART_TYPE_RADAR ? ecData.get(shape, 'special') : '');
            } else {
                return ecData.get(shape, 'seriesIndex') + '_' + ecData.get(shape, 'dataIndex') + (shape._mark ? shape._mark : 'undefined');
            }
        },
        _animateMod: function (oldShape, newShape, duration, easing, delay, isUpdate) {
            switch (newShape.type) {
            case 'polyline':
            case 'half-smooth-polygon':
                ecAnimation.pointList(this.zr, oldShape, newShape, duration, easing);
                break;
            case 'rectangle':
                ecAnimation.rectangle(this.zr, oldShape, newShape, duration, easing);
                break;
            case 'image':
            case 'icon':
                ecAnimation.icon(this.zr, oldShape, newShape, duration, easing, delay);
                break;
            case 'candle':
                if (!isUpdate) {
                    ecAnimation.candle(this.zr, oldShape, newShape, duration, easing);
                } else {
                    this.zr.addShape(newShape);
                }
                break;
            case 'ring':
            case 'sector':
            case 'circle':
                if (!isUpdate) {
                    ecAnimation.ring(this.zr, oldShape, newShape, duration + (ecData.get(newShape, 'dataIndex') || 0) % 20 * 100, easing);
                } else if (newShape.type === 'sector') {
                    ecAnimation.sector(this.zr, oldShape, newShape, duration, easing);
                } else {
                    this.zr.addShape(newShape);
                }
                break;
            case 'text':
                ecAnimation.text(this.zr, oldShape, newShape, duration, easing);
                break;
            case 'polygon':
                if (!isUpdate) {
                    ecAnimation.polygon(this.zr, oldShape, newShape, duration, easing);
                } else {
                    ecAnimation.pointList(this.zr, oldShape, newShape, duration, easing);
                }
                break;
            case 'ribbon':
                ecAnimation.ribbon(this.zr, oldShape, newShape, duration, easing);
                break;
            case 'gauge-pointer':
                ecAnimation.gaugePointer(this.zr, oldShape, newShape, duration, easing);
                break;
            case 'mark-line':
                ecAnimation.markline(this.zr, oldShape, newShape, duration, easing);
                break;
            case 'bezier-curve':
            case 'line':
                ecAnimation.line(this.zr, oldShape, newShape, duration, easing);
                break;
            default:
                this.zr.addShape(newShape);
                break;
            }
        },
        animationMark: function (duration, easing, shapeList) {
            var shapeList = shapeList || this.shapeList;
            for (var i = 0, l = shapeList.length; i < l; i++) {
                if (!shapeList[i]._mark) {
                    continue;
                }
                this._animateMod(false, shapeList[i], duration, easing, 0, true);
            }
            this.animationEffect(shapeList);
        },
        animationEffect: function (shapeList) {
            !shapeList && this.clearEffectShape();
            shapeList = shapeList || this.shapeList;
            if (shapeList == null) {
                return;
            }
            var zlevel = ecConfig.EFFECT_ZLEVEL;
            if (this.canvasSupported) {
                this.zr.modLayer(zlevel, {
                    motionBlur: true,
                    lastFrameAlpha: 0.95
                });
            }
            var shape;
            for (var i = 0, l = shapeList.length; i < l; i++) {
                shape = shapeList[i];
                if (!(shape._mark && shape.effect && shape.effect.show && ecEffect[shape._mark])) {
                    continue;
                }
                ecEffect[shape._mark](this.zr, this.effectList, shape, zlevel);
                this.effectList[this.effectList.length - 1]._mark = shape._mark;
            }
        },
        clearEffectShape: function (clearMotionBlur) {
            var effectList = this.effectList;
            if (this.zr && effectList && effectList.length > 0) {
                clearMotionBlur && this.zr.modLayer(ecConfig.EFFECT_ZLEVEL, { motionBlur: false });
                this.zr.delShape(effectList);
                for (var i = 0; i < effectList.length; i++) {
                    if (effectList[i].effectAnimator) {
                        effectList[i].effectAnimator.stop();
                    }
                }
            }
            this.effectList = [];
        },
        addMark: function (seriesIndex, markData, markType) {
            var serie = this.series[seriesIndex];
            if (this.selectedMap[serie.name]) {
                var duration = this.query(this.option, 'animationDurationUpdate');
                var easing = this.query(this.option, 'animationEasing');
                var oriMarkData = serie[markType].data;
                var lastLength = this.shapeList.length;
                serie[markType].data = markData.data;
                this['_build' + markType.replace('m', 'M')](seriesIndex);
                if (this.option.animation && !this.option.renderAsImage) {
                    this.animationMark(duration, easing, this.shapeList.slice(lastLength));
                } else {
                    for (var i = lastLength, l = this.shapeList.length; i < l; i++) {
                        this.zr.addShape(this.shapeList[i]);
                    }
                    this.zr.refreshNextFrame();
                }
                serie[markType].data = oriMarkData;
            }
        },
        delMark: function (seriesIndex, markName, markType) {
            markType = markType.replace('mark', '').replace('large', '').toLowerCase();
            var serie = this.series[seriesIndex];
            if (this.selectedMap[serie.name]) {
                var needRefresh = false;
                var shapeList = [
                    this.shapeList,
                    this.effectList
                ];
                var len = 2;
                while (len--) {
                    for (var i = 0, l = shapeList[len].length; i < l; i++) {
                        if (shapeList[len][i]._mark == markType && ecData.get(shapeList[len][i], 'seriesIndex') == seriesIndex && ecData.get(shapeList[len][i], 'name') == markName) {
                            this.zr.delShape(shapeList[len][i].id);
                            shapeList[len].splice(i, 1);
                            needRefresh = true;
                            break;
                        }
                    }
                }
                needRefresh && this.zr.refreshNextFrame();
            }
        }
    };
    zrUtil.inherits(Base, ComponentBase);
    return Base;
});define('zrender/shape/Circle', [
    'require',
    './Base',
    '../tool/util'
], function (require) {
    'use strict';
    var Base = require('./Base');
    var Circle = function (options) {
        Base.call(this, options);
    };
    Circle.prototype = {
        type: 'circle',
        buildPath: function (ctx, style) {
            ctx.moveTo(style.x + style.r, style.y);
            ctx.arc(style.x, style.y, style.r, 0, Math.PI * 2, true);
            return;
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            var lineWidth;
            if (style.brushType == 'stroke' || style.brushType == 'fill') {
                lineWidth = style.lineWidth || 1;
            } else {
                lineWidth = 0;
            }
            style.__rect = {
                x: Math.round(style.x - style.r - lineWidth / 2),
                y: Math.round(style.y - style.r - lineWidth / 2),
                width: style.r * 2 + lineWidth,
                height: style.r * 2 + lineWidth
            };
            return style.__rect;
        }
    };
    require('../tool/util').inherits(Circle, Base);
    return Circle;
});define('echarts/util/accMath', [], function () {
    function accDiv(arg1, arg2) {
        var s1 = arg1.toString();
        var s2 = arg2.toString();
        var m = 0;
        try {
            m = s2.split('.')[1].length;
        } catch (e) {
        }
        try {
            m -= s1.split('.')[1].length;
        } catch (e) {
        }
        return (s1.replace('.', '') - 0) / (s2.replace('.', '') - 0) * Math.pow(10, m);
    }
    function accMul(arg1, arg2) {
        var s1 = arg1.toString();
        var s2 = arg2.toString();
        var m = 0;
        try {
            m += s1.split('.')[1].length;
        } catch (e) {
        }
        try {
            m += s2.split('.')[1].length;
        } catch (e) {
        }
        return (s1.replace('.', '') - 0) * (s2.replace('.', '') - 0) / Math.pow(10, m);
    }
    function accAdd(arg1, arg2) {
        var r1 = 0;
        var r2 = 0;
        try {
            r1 = arg1.toString().split('.')[1].length;
        } catch (e) {
        }
        try {
            r2 = arg2.toString().split('.')[1].length;
        } catch (e) {
        }
        var m = Math.pow(10, Math.max(r1, r2));
        return (Math.round(arg1 * m) + Math.round(arg2 * m)) / m;
    }
    function accSub(arg1, arg2) {
        return accAdd(arg1, -arg2);
    }
    return {
        accDiv: accDiv,
        accMul: accMul,
        accAdd: accAdd,
        accSub: accSub
    };
});define('echarts/util/shape/Icon', [
    'require',
    'zrender/tool/util',
    'zrender/shape/Star',
    'zrender/shape/Heart',
    'zrender/shape/Droplet',
    'zrender/shape/Image',
    'zrender/shape/Base'
], function (require) {
    var zrUtil = require('zrender/tool/util');
    function _iconMark(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        var dy = style.height / 16;
        ctx.moveTo(x, y + style.height);
        ctx.lineTo(x + 5 * dx, y + 14 * dy);
        ctx.lineTo(x + style.width, y + 3 * dy);
        ctx.lineTo(x + 13 * dx, y);
        ctx.lineTo(x + 2 * dx, y + 11 * dy);
        ctx.lineTo(x, y + style.height);
        ctx.moveTo(x + 6 * dx, y + 10 * dy);
        ctx.lineTo(x + 14 * dx, y + 2 * dy);
        ctx.moveTo(x + 10 * dx, y + 13 * dy);
        ctx.lineTo(x + style.width, y + 13 * dy);
        ctx.moveTo(x + 13 * dx, y + 10 * dy);
        ctx.lineTo(x + 13 * dx, y + style.height);
    }
    function _iconMarkUndo(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        var dy = style.height / 16;
        ctx.moveTo(x, y + style.height);
        ctx.lineTo(x + 5 * dx, y + 14 * dy);
        ctx.lineTo(x + style.width, y + 3 * dy);
        ctx.lineTo(x + 13 * dx, y);
        ctx.lineTo(x + 2 * dx, y + 11 * dy);
        ctx.lineTo(x, y + style.height);
        ctx.moveTo(x + 6 * dx, y + 10 * dy);
        ctx.lineTo(x + 14 * dx, y + 2 * dy);
        ctx.moveTo(x + 10 * dx, y + 13 * dy);
        ctx.lineTo(x + style.width, y + 13 * dy);
    }
    function _iconMarkClear(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        var dy = style.height / 16;
        ctx.moveTo(x + 4 * dx, y + 15 * dy);
        ctx.lineTo(x + 9 * dx, y + 13 * dy);
        ctx.lineTo(x + 14 * dx, y + 8 * dy);
        ctx.lineTo(x + 11 * dx, y + 5 * dy);
        ctx.lineTo(x + 6 * dx, y + 10 * dy);
        ctx.lineTo(x + 4 * dx, y + 15 * dy);
        ctx.moveTo(x + 5 * dx, y);
        ctx.lineTo(x + 11 * dx, y);
        ctx.moveTo(x + 5 * dx, y + dy);
        ctx.lineTo(x + 11 * dx, y + dy);
        ctx.moveTo(x, y + 2 * dy);
        ctx.lineTo(x + style.width, y + 2 * dy);
        ctx.moveTo(x, y + 5 * dy);
        ctx.lineTo(x + 3 * dx, y + style.height);
        ctx.lineTo(x + 13 * dx, y + style.height);
        ctx.lineTo(x + style.width, y + 5 * dy);
    }
    function _iconDataZoom(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        var dy = style.height / 16;
        ctx.moveTo(x, y + 3 * dy);
        ctx.lineTo(x + 6 * dx, y + 3 * dy);
        ctx.moveTo(x + 3 * dx, y);
        ctx.lineTo(x + 3 * dx, y + 6 * dy);
        ctx.moveTo(x + 3 * dx, y + 8 * dy);
        ctx.lineTo(x + 3 * dx, y + style.height);
        ctx.lineTo(x + style.width, y + style.height);
        ctx.lineTo(x + style.width, y + 3 * dy);
        ctx.lineTo(x + 8 * dx, y + 3 * dy);
    }
    function _iconDataZoomReset(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        var dy = style.height / 16;
        ctx.moveTo(x + 6 * dx, y);
        ctx.lineTo(x + 2 * dx, y + 3 * dy);
        ctx.lineTo(x + 6 * dx, y + 6 * dy);
        ctx.moveTo(x + 2 * dx, y + 3 * dy);
        ctx.lineTo(x + 14 * dx, y + 3 * dy);
        ctx.lineTo(x + 14 * dx, y + 11 * dy);
        ctx.moveTo(x + 2 * dx, y + 5 * dy);
        ctx.lineTo(x + 2 * dx, y + 13 * dy);
        ctx.lineTo(x + 14 * dx, y + 13 * dy);
        ctx.moveTo(x + 10 * dx, y + 10 * dy);
        ctx.lineTo(x + 14 * dx, y + 13 * dy);
        ctx.lineTo(x + 10 * dx, y + style.height);
    }
    function _iconRestore(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        var dy = style.height / 16;
        var r = style.width / 2;
        ctx.lineWidth = 1.5;
        ctx.arc(x + r, y + r, r - dx, 0, Math.PI * 2 / 3);
        ctx.moveTo(x + 3 * dx, y + style.height);
        ctx.lineTo(x + 0 * dx, y + 12 * dy);
        ctx.lineTo(x + 5 * dx, y + 11 * dy);
        ctx.moveTo(x, y + 8 * dy);
        ctx.arc(x + r, y + r, r - dx, Math.PI, Math.PI * 5 / 3);
        ctx.moveTo(x + 13 * dx, y);
        ctx.lineTo(x + style.width, y + 4 * dy);
        ctx.lineTo(x + 11 * dx, y + 5 * dy);
    }
    function _iconLineChart(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        var dy = style.height / 16;
        ctx.moveTo(x, y);
        ctx.lineTo(x, y + style.height);
        ctx.lineTo(x + style.width, y + style.height);
        ctx.moveTo(x + 2 * dx, y + 14 * dy);
        ctx.lineTo(x + 7 * dx, y + 6 * dy);
        ctx.lineTo(x + 11 * dx, y + 11 * dy);
        ctx.lineTo(x + 15 * dx, y + 2 * dy);
    }
    function _iconBarChart(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        var dy = style.height / 16;
        ctx.moveTo(x, y);
        ctx.lineTo(x, y + style.height);
        ctx.lineTo(x + style.width, y + style.height);
        ctx.moveTo(x + 3 * dx, y + 14 * dy);
        ctx.lineTo(x + 3 * dx, y + 6 * dy);
        ctx.lineTo(x + 4 * dx, y + 6 * dy);
        ctx.lineTo(x + 4 * dx, y + 14 * dy);
        ctx.moveTo(x + 7 * dx, y + 14 * dy);
        ctx.lineTo(x + 7 * dx, y + 2 * dy);
        ctx.lineTo(x + 8 * dx, y + 2 * dy);
        ctx.lineTo(x + 8 * dx, y + 14 * dy);
        ctx.moveTo(x + 11 * dx, y + 14 * dy);
        ctx.lineTo(x + 11 * dx, y + 9 * dy);
        ctx.lineTo(x + 12 * dx, y + 9 * dy);
        ctx.lineTo(x + 12 * dx, y + 14 * dy);
    }
    function _iconPieChart(ctx, style) {
        var x = style.x;
        var y = style.y;
        var width = style.width - 2;
        var height = style.height - 2;
        var r = Math.min(width, height) / 2;
        y += 2;
        ctx.moveTo(x + r + 3, y + r - 3);
        ctx.arc(x + r + 3, y + r - 3, r - 1, 0, -Math.PI / 2, true);
        ctx.lineTo(x + r + 3, y + r - 3);
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + r, y + r);
        ctx.arc(x + r, y + r, r, -Math.PI / 2, Math.PI * 2, true);
        ctx.lineTo(x + r, y + r);
        ctx.lineWidth = 1.5;
    }
    function _iconFunnelChart(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        var dy = style.height / 16;
        y -= dy;
        ctx.moveTo(x + 1 * dx, y + 2 * dy);
        ctx.lineTo(x + 15 * dx, y + 2 * dy);
        ctx.lineTo(x + 14 * dx, y + 3 * dy);
        ctx.lineTo(x + 2 * dx, y + 3 * dy);
        ctx.moveTo(x + 3 * dx, y + 6 * dy);
        ctx.lineTo(x + 13 * dx, y + 6 * dy);
        ctx.lineTo(x + 12 * dx, y + 7 * dy);
        ctx.lineTo(x + 4 * dx, y + 7 * dy);
        ctx.moveTo(x + 5 * dx, y + 10 * dy);
        ctx.lineTo(x + 11 * dx, y + 10 * dy);
        ctx.lineTo(x + 10 * dx, y + 11 * dy);
        ctx.lineTo(x + 6 * dx, y + 11 * dy);
        ctx.moveTo(x + 7 * dx, y + 14 * dy);
        ctx.lineTo(x + 9 * dx, y + 14 * dy);
        ctx.lineTo(x + 8 * dx, y + 15 * dy);
        ctx.lineTo(x + 7 * dx, y + 15 * dy);
    }
    function _iconForceChart(ctx, style) {
        var x = style.x;
        var y = style.y;
        var width = style.width;
        var height = style.height;
        var dx = width / 16;
        var dy = height / 16;
        var r = Math.min(dx, dy) * 2;
        ctx.moveTo(x + dx + r, y + dy + r);
        ctx.arc(x + dx, y + dy, r, Math.PI / 4, Math.PI * 3);
        ctx.lineTo(x + 7 * dx - r, y + 6 * dy - r);
        ctx.arc(x + 7 * dx, y + 6 * dy, r, Math.PI / 4 * 5, Math.PI * 4);
        ctx.arc(x + 7 * dx, y + 6 * dy, r / 2, Math.PI / 4 * 5, Math.PI * 4);
        ctx.moveTo(x + 7 * dx - r / 2, y + 6 * dy + r);
        ctx.lineTo(x + dx + r, y + 14 * dy - r);
        ctx.arc(x + dx, y + 14 * dy, r, -Math.PI / 4, Math.PI * 2);
        ctx.moveTo(x + 7 * dx + r / 2, y + 6 * dy);
        ctx.lineTo(x + 14 * dx - r, y + 10 * dy - r / 2);
        ctx.moveTo(x + 16 * dx, y + 10 * dy);
        ctx.arc(x + 14 * dx, y + 10 * dy, r, 0, Math.PI * 3);
        ctx.lineWidth = 1.5;
    }
    function _iconChordChart(ctx, style) {
        var x = style.x;
        var y = style.y;
        var width = style.width;
        var height = style.height;
        var r = Math.min(width, height) / 2;
        ctx.moveTo(x + width, y + height / 2);
        ctx.arc(x + r, y + r, r, 0, Math.PI * 2);
        ctx.arc(x + r, y, r, Math.PI / 4, Math.PI / 5 * 4);
        ctx.arc(x, y + r, r, -Math.PI / 3, Math.PI / 3);
        ctx.arc(x + width, y + height, r, Math.PI, Math.PI / 2 * 3);
        ctx.lineWidth = 1.5;
    }
    function _iconStackChart(ctx, style) {
        var x = style.x;
        var y = style.y;
        var width = style.width;
        var height = style.height;
        var dy = Math.round(height / 3);
        var delta = Math.round((dy - 2) / 2);
        var len = 3;
        while (len--) {
            ctx.rect(x, y + dy * len + delta, width, 2);
        }
    }
    function _iconTiledChart(ctx, style) {
        var x = style.x;
        var y = style.y;
        var width = style.width;
        var height = style.height;
        var dx = Math.round(width / 3);
        var delta = Math.round((dx - 2) / 2);
        var len = 3;
        while (len--) {
            ctx.rect(x + dx * len + delta, y, 2, height);
        }
    }
    function _iconDataView(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        ctx.moveTo(x + dx, y);
        ctx.lineTo(x + dx, y + style.height);
        ctx.lineTo(x + 15 * dx, y + style.height);
        ctx.lineTo(x + 15 * dx, y);
        ctx.lineTo(x + dx, y);
        ctx.moveTo(x + 3 * dx, y + 3 * dx);
        ctx.lineTo(x + 13 * dx, y + 3 * dx);
        ctx.moveTo(x + 3 * dx, y + 6 * dx);
        ctx.lineTo(x + 13 * dx, y + 6 * dx);
        ctx.moveTo(x + 3 * dx, y + 9 * dx);
        ctx.lineTo(x + 13 * dx, y + 9 * dx);
        ctx.moveTo(x + 3 * dx, y + 12 * dx);
        ctx.lineTo(x + 9 * dx, y + 12 * dx);
    }
    function _iconSave(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        var dy = style.height / 16;
        ctx.moveTo(x, y);
        ctx.lineTo(x, y + style.height);
        ctx.lineTo(x + style.width, y + style.height);
        ctx.lineTo(x + style.width, y);
        ctx.lineTo(x, y);
        ctx.moveTo(x + 4 * dx, y);
        ctx.lineTo(x + 4 * dx, y + 8 * dy);
        ctx.lineTo(x + 12 * dx, y + 8 * dy);
        ctx.lineTo(x + 12 * dx, y);
        ctx.moveTo(x + 6 * dx, y + 11 * dy);
        ctx.lineTo(x + 6 * dx, y + 13 * dy);
        ctx.lineTo(x + 10 * dx, y + 13 * dy);
        ctx.lineTo(x + 10 * dx, y + 11 * dy);
        ctx.lineTo(x + 6 * dx, y + 11 * dy);
    }
    function _iconCross(ctx, style) {
        var x = style.x;
        var y = style.y;
        var width = style.width;
        var height = style.height;
        ctx.moveTo(x, y + height / 2);
        ctx.lineTo(x + width, y + height / 2);
        ctx.moveTo(x + width / 2, y);
        ctx.lineTo(x + width / 2, y + height);
    }
    function _iconCircle(ctx, style) {
        var width = style.width / 2;
        var height = style.height / 2;
        var r = Math.min(width, height);
        ctx.moveTo(style.x + width + r, style.y + height);
        ctx.arc(style.x + width, style.y + height, r, 0, Math.PI * 2);
        ctx.closePath();
    }
    function _iconRectangle(ctx, style) {
        ctx.rect(style.x, style.y, style.width, style.height);
        ctx.closePath();
    }
    function _iconTriangle(ctx, style) {
        var width = style.width / 2;
        var height = style.height / 2;
        var x = style.x + width;
        var y = style.y + height;
        var symbolSize = Math.min(width, height);
        ctx.moveTo(x, y - symbolSize);
        ctx.lineTo(x + symbolSize, y + symbolSize);
        ctx.lineTo(x - symbolSize, y + symbolSize);
        ctx.lineTo(x, y - symbolSize);
        ctx.closePath();
    }
    function _iconDiamond(ctx, style) {
        var width = style.width / 2;
        var height = style.height / 2;
        var x = style.x + width;
        var y = style.y + height;
        var symbolSize = Math.min(width, height);
        ctx.moveTo(x, y - symbolSize);
        ctx.lineTo(x + symbolSize, y);
        ctx.lineTo(x, y + symbolSize);
        ctx.lineTo(x - symbolSize, y);
        ctx.lineTo(x, y - symbolSize);
        ctx.closePath();
    }
    function _iconArrow(ctx, style) {
        var x = style.x;
        var y = style.y;
        var dx = style.width / 16;
        ctx.moveTo(x + 8 * dx, y);
        ctx.lineTo(x + dx, y + style.height);
        ctx.lineTo(x + 8 * dx, y + style.height / 4 * 3);
        ctx.lineTo(x + 15 * dx, y + style.height);
        ctx.lineTo(x + 8 * dx, y);
        ctx.closePath();
    }
    function _iconStar(ctx, style) {
        var StarShape = require('zrender/shape/Star');
        var width = style.width / 2;
        var height = style.height / 2;
        StarShape.prototype.buildPath(ctx, {
            x: style.x + width,
            y: style.y + height,
            r: Math.min(width, height),
            n: style.n || 5
        });
    }
    function _iconHeart(ctx, style) {
        var HeartShape = require('zrender/shape/Heart');
        HeartShape.prototype.buildPath(ctx, {
            x: style.x + style.width / 2,
            y: style.y + style.height * 0.2,
            a: style.width / 2,
            b: style.height * 0.8
        });
    }
    function _iconDroplet(ctx, style) {
        var DropletShape = require('zrender/shape/Droplet');
        DropletShape.prototype.buildPath(ctx, {
            x: style.x + style.width * 0.5,
            y: style.y + style.height * 0.5,
            a: style.width * 0.5,
            b: style.height * 0.8
        });
    }
    function _iconPin(ctx, style) {
        var x = style.x;
        var y = style.y - style.height / 2 * 1.5;
        var width = style.width / 2;
        var height = style.height / 2;
        var r = Math.min(width, height);
        ctx.arc(x + width, y + height, r, Math.PI / 5 * 4, Math.PI / 5);
        ctx.lineTo(x + width, y + height + r * 1.5);
        ctx.closePath();
    }
    function _iconImage(ctx, style, refreshNextFrame) {
        var ImageShape = require('zrender/shape/Image');
        this._imageShape = this._imageShape || new ImageShape({ style: {} });
        for (var name in style) {
            this._imageShape.style[name] = style[name];
        }
        this._imageShape.brush(ctx, false, refreshNextFrame);
    }
    var Base = require('zrender/shape/Base');
    function Icon(options) {
        Base.call(this, options);
    }
    Icon.prototype = {
        type: 'icon',
        iconLibrary: {
            mark: _iconMark,
            markUndo: _iconMarkUndo,
            markClear: _iconMarkClear,
            dataZoom: _iconDataZoom,
            dataZoomReset: _iconDataZoomReset,
            restore: _iconRestore,
            lineChart: _iconLineChart,
            barChart: _iconBarChart,
            pieChart: _iconPieChart,
            funnelChart: _iconFunnelChart,
            forceChart: _iconForceChart,
            chordChart: _iconChordChart,
            stackChart: _iconStackChart,
            tiledChart: _iconTiledChart,
            dataView: _iconDataView,
            saveAsImage: _iconSave,
            cross: _iconCross,
            circle: _iconCircle,
            rectangle: _iconRectangle,
            triangle: _iconTriangle,
            diamond: _iconDiamond,
            arrow: _iconArrow,
            star: _iconStar,
            heart: _iconHeart,
            droplet: _iconDroplet,
            pin: _iconPin,
            image: _iconImage
        },
        brush: function (ctx, isHighlight, refreshNextFrame) {
            var style = isHighlight ? this.highlightStyle : this.style;
            style = style || {};
            var iconType = style.iconType || this.style.iconType;
            if (iconType === 'image') {
                var ImageShape = require('zrender/shape/Image');
                ImageShape.prototype.brush.call(this, ctx, isHighlight, refreshNextFrame);
            } else {
                var style = this.beforeBrush(ctx, isHighlight);
                ctx.beginPath();
                this.buildPath(ctx, style, refreshNextFrame);
                switch (style.brushType) {
                case 'both':
                    ctx.fill();
                case 'stroke':
                    style.lineWidth > 0 && ctx.stroke();
                    break;
                default:
                    ctx.fill();
                }
                this.drawText(ctx, style, this.style);
                this.afterBrush(ctx);
            }
        },
        buildPath: function (ctx, style, refreshNextFrame) {
            if (this.iconLibrary[style.iconType]) {
                this.iconLibrary[style.iconType].call(this, ctx, style, refreshNextFrame);
            } else {
                ctx.moveTo(style.x, style.y);
                ctx.lineTo(style.x + style.width, style.y);
                ctx.lineTo(style.x + style.width, style.y + style.height);
                ctx.lineTo(style.x, style.y + style.height);
                ctx.lineTo(style.x, style.y);
                ctx.closePath();
            }
            return;
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            style.__rect = {
                x: Math.round(style.x),
                y: Math.round(style.y - (style.iconType == 'pin' ? style.height / 2 * 1.5 : 0)),
                width: style.width,
                height: style.height * (style.iconType === 'pin' ? 1.25 : 1)
            };
            return style.__rect;
        },
        isCover: function (x, y) {
            var originPos = this.transformCoordToLocal(x, y);
            x = originPos[0];
            y = originPos[1];
            var rect = this.style.__rect;
            if (!rect) {
                rect = this.style.__rect = this.getRect(this.style);
            }
            var delta = rect.height < 8 || rect.width < 8 ? 4 : 0;
            return x >= rect.x - delta && x <= rect.x + rect.width + delta && y >= rect.y - delta && y <= rect.y + rect.height + delta;
        }
    };
    zrUtil.inherits(Icon, Base);
    return Icon;
});define('echarts/util/shape/MarkLine', [
    'require',
    'zrender/shape/Base',
    './Icon',
    'zrender/shape/Line',
    'zrender/shape/BezierCurve',
    'zrender/tool/area',
    'zrender/shape/util/dashedLineTo',
    'zrender/tool/util',
    'zrender/tool/curve'
], function (require) {
    var Base = require('zrender/shape/Base');
    var IconShape = require('./Icon');
    var LineShape = require('zrender/shape/Line');
    var lineInstance = new LineShape({});
    var CurveShape = require('zrender/shape/BezierCurve');
    var curveInstance = new CurveShape({});
    var area = require('zrender/tool/area');
    var dashedLineTo = require('zrender/shape/util/dashedLineTo');
    var zrUtil = require('zrender/tool/util');
    var curveTool = require('zrender/tool/curve');
    function MarkLine(options) {
        Base.call(this, options);
        if (this.style.curveness > 0) {
            this.updatePoints(this.style);
        }
        if (this.highlightStyle.curveness > 0) {
            this.updatePoints(this.highlightStyle);
        }
    }
    MarkLine.prototype = {
        type: 'mark-line',
        brush: function (ctx, isHighlight) {
            var style = this.style;
            if (isHighlight) {
                style = this.getHighlightStyle(style, this.highlightStyle || {});
            }
            ctx.save();
            this.setContext(ctx, style);
            this.setTransform(ctx);
            ctx.save();
            ctx.beginPath();
            this.buildPath(ctx, style);
            ctx.stroke();
            ctx.restore();
            this.brushSymbol(ctx, style, 0);
            this.brushSymbol(ctx, style, 1);
            this.drawText(ctx, style, this.style);
            ctx.restore();
        },
        buildPath: function (ctx, style) {
            var lineType = style.lineType || 'solid';
            ctx.moveTo(style.xStart, style.yStart);
            if (style.curveness > 0) {
                var lineDash = null;
                switch (lineType) {
                case 'dashed':
                    lineDash = [
                        5,
                        5
                    ];
                    break;
                case 'dotted':
                    lineDash = [
                        1,
                        1
                    ];
                    break;
                }
                if (lineDash && ctx.setLineDash) {
                    ctx.setLineDash(lineDash);
                }
                ctx.quadraticCurveTo(style.cpX1, style.cpY1, style.xEnd, style.yEnd);
            } else {
                if (lineType == 'solid') {
                    ctx.lineTo(style.xEnd, style.yEnd);
                } else {
                    var dashLength = (style.lineWidth || 1) * (style.lineType == 'dashed' ? 5 : 1);
                    dashedLineTo(ctx, style.xStart, style.yStart, style.xEnd, style.yEnd, dashLength);
                }
            }
        },
        updatePoints: function (style) {
            var curveness = style.curveness || 0;
            var inv = 1;
            var x0 = style.xStart;
            var y0 = style.yStart;
            var x2 = style.xEnd;
            var y2 = style.yEnd;
            var x1 = (x0 + x2) / 2 - inv * (y0 - y2) * curveness;
            var y1 = (y0 + y2) / 2 - inv * (x2 - x0) * curveness;
            style.cpX1 = x1;
            style.cpY1 = y1;
        },
        brushSymbol: function (ctx, style, idx) {
            if (style.symbol[idx] == 'none') {
                return;
            }
            ctx.save();
            ctx.beginPath();
            ctx.lineWidth = style.symbolBorder;
            ctx.strokeStyle = style.symbolBorderColor;
            var symbol = style.symbol[idx].replace('empty', '').toLowerCase();
            if (style.symbol[idx].match('empty')) {
                ctx.fillStyle = '#fff';
            }
            var x0 = style.xStart;
            var y0 = style.yStart;
            var x2 = style.xEnd;
            var y2 = style.yEnd;
            var x = idx === 0 ? x0 : x2;
            var y = idx === 0 ? y0 : y2;
            var curveness = style.curveness || 0;
            var rotate = style.symbolRotate[idx] != null ? style.symbolRotate[idx] - 0 : 0;
            rotate = rotate / 180 * Math.PI;
            if (symbol == 'arrow' && rotate === 0) {
                if (curveness === 0) {
                    var sign = idx === 0 ? -1 : 1;
                    rotate = Math.PI / 2 + Math.atan2(sign * (y2 - y0), sign * (x2 - x0));
                } else {
                    var x1 = style.cpX1;
                    var y1 = style.cpY1;
                    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;
                    var dx = quadraticDerivativeAt(x0, x1, x2, idx);
                    var dy = quadraticDerivativeAt(y0, y1, y2, idx);
                    rotate = Math.PI / 2 + Math.atan2(dy, dx);
                }
            }
            ctx.translate(x, y);
            if (rotate !== 0) {
                ctx.rotate(rotate);
            }
            var symbolSize = style.symbolSize[idx];
            IconShape.prototype.buildPath(ctx, {
                x: -symbolSize,
                y: -symbolSize,
                width: symbolSize * 2,
                height: symbolSize * 2,
                iconType: symbol
            });
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        },
        getRect: function (style) {
            style.curveness > 0 ? curveInstance.getRect(style) : lineInstance.getRect(style);
            return style.__rect;
        },
        isCover: function (x, y) {
            var originPos = this.transformCoordToLocal(x, y);
            x = originPos[0];
            y = originPos[1];
            if (this.isCoverRect(x, y)) {
                return this.style.curveness > 0 ? area.isInside(curveInstance, this.style, x, y) : area.isInside(lineInstance, this.style, x, y);
            }
            return false;
        }
    };
    zrUtil.inherits(MarkLine, Base);
    return MarkLine;
});define('echarts/util/shape/Symbol', [
    'require',
    'zrender/shape/Base',
    'zrender/shape/Polygon',
    'zrender/tool/util',
    './normalIsCover'
], function (require) {
    var Base = require('zrender/shape/Base');
    var PolygonShape = require('zrender/shape/Polygon');
    var polygonInstance = new PolygonShape({});
    var zrUtil = require('zrender/tool/util');
    function Symbol(options) {
        Base.call(this, options);
    }
    Symbol.prototype = {
        type: 'symbol',
        buildPath: function (ctx, style) {
            var pointList = style.pointList;
            var len = pointList.length;
            if (len === 0) {
                return;
            }
            var subSize = 10000;
            var subSetLength = Math.ceil(len / subSize);
            var sub;
            var subLen;
            var isArray = pointList[0] instanceof Array;
            var size = style.size ? style.size : 2;
            var curSize = size;
            var halfSize = size / 2;
            var PI2 = Math.PI * 2;
            var percent;
            var x;
            var y;
            for (var j = 0; j < subSetLength; j++) {
                ctx.beginPath();
                sub = j * subSize;
                subLen = sub + subSize;
                subLen = subLen > len ? len : subLen;
                for (var i = sub; i < subLen; i++) {
                    if (style.random) {
                        percent = style['randomMap' + i % 20] / 100;
                        curSize = size * percent * percent;
                        halfSize = curSize / 2;
                    }
                    if (isArray) {
                        x = pointList[i][0];
                        y = pointList[i][1];
                    } else {
                        x = pointList[i].x;
                        y = pointList[i].y;
                    }
                    if (curSize < 3) {
                        ctx.rect(x - halfSize, y - halfSize, curSize, curSize);
                    } else {
                        switch (style.iconType) {
                        case 'circle':
                            ctx.moveTo(x, y);
                            ctx.arc(x, y, halfSize, 0, PI2, true);
                            break;
                        case 'diamond':
                            ctx.moveTo(x, y - halfSize);
                            ctx.lineTo(x + halfSize / 3, y - halfSize / 3);
                            ctx.lineTo(x + halfSize, y);
                            ctx.lineTo(x + halfSize / 3, y + halfSize / 3);
                            ctx.lineTo(x, y + halfSize);
                            ctx.lineTo(x - halfSize / 3, y + halfSize / 3);
                            ctx.lineTo(x - halfSize, y);
                            ctx.lineTo(x - halfSize / 3, y - halfSize / 3);
                            ctx.lineTo(x, y - halfSize);
                            break;
                        default:
                            ctx.rect(x - halfSize, y - halfSize, curSize, curSize);
                        }
                    }
                }
                ctx.closePath();
                if (j < subSetLength - 1) {
                    switch (style.brushType) {
                    case 'both':
                        ctx.fill();
                        style.lineWidth > 0 && ctx.stroke();
                        break;
                    case 'stroke':
                        style.lineWidth > 0 && ctx.stroke();
                        break;
                    default:
                        ctx.fill();
                    }
                }
            }
        },
        getRect: function (style) {
            return style.__rect || polygonInstance.getRect(style);
        },
        isCover: require('./normalIsCover')
    };
    zrUtil.inherits(Symbol, Base);
    return Symbol;
});define('zrender/shape/Polyline', [
    'require',
    './Base',
    './util/smoothSpline',
    './util/smoothBezier',
    './util/dashedLineTo',
    './Polygon',
    '../tool/util'
], function (require) {
    var Base = require('./Base');
    var smoothSpline = require('./util/smoothSpline');
    var smoothBezier = require('./util/smoothBezier');
    var dashedLineTo = require('./util/dashedLineTo');
    var Polyline = function (options) {
        this.brushTypeOnly = 'stroke';
        this.textPosition = 'end';
        Base.call(this, options);
    };
    Polyline.prototype = {
        type: 'polyline',
        buildPath: function (ctx, style) {
            var pointList = style.pointList;
            if (pointList.length < 2) {
                return;
            }
            var len = Math.min(style.pointList.length, Math.round(style.pointListLength || style.pointList.length));
            if (style.smooth && style.smooth !== 'spline') {
                if (!style.controlPointList) {
                    this.updateControlPoints(style);
                }
                var controlPointList = style.controlPointList;
                ctx.moveTo(pointList[0][0], pointList[0][1]);
                var cp1;
                var cp2;
                var p;
                for (var i = 0; i < len - 1; i++) {
                    cp1 = controlPointList[i * 2];
                    cp2 = controlPointList[i * 2 + 1];
                    p = pointList[i + 1];
                    ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
                }
            } else {
                if (style.smooth === 'spline') {
                    pointList = smoothSpline(pointList);
                    len = pointList.length;
                }
                if (!style.lineType || style.lineType == 'solid') {
                    ctx.moveTo(pointList[0][0], pointList[0][1]);
                    for (var i = 1; i < len; i++) {
                        ctx.lineTo(pointList[i][0], pointList[i][1]);
                    }
                } else if (style.lineType == 'dashed' || style.lineType == 'dotted') {
                    var dashLength = (style.lineWidth || 1) * (style.lineType == 'dashed' ? 5 : 1);
                    ctx.moveTo(pointList[0][0], pointList[0][1]);
                    for (var i = 1; i < len; i++) {
                        dashedLineTo(ctx, pointList[i - 1][0], pointList[i - 1][1], pointList[i][0], pointList[i][1], dashLength);
                    }
                }
            }
            return;
        },
        updateControlPoints: function (style) {
            style.controlPointList = smoothBezier(style.pointList, style.smooth, false, style.smoothConstraint);
        },
        getRect: function (style) {
            return require('./Polygon').prototype.getRect(style);
        }
    };
    require('../tool/util').inherits(Polyline, Base);
    return Polyline;
});define('zrender/shape/ShapeBundle', [
    'require',
    './Base',
    '../tool/util'
], function (require) {
    var Base = require('./Base');
    var ShapeBundle = function (options) {
        Base.call(this, options);
    };
    ShapeBundle.prototype = {
        constructor: ShapeBundle,
        type: 'shape-bundle',
        brush: function (ctx, isHighlight) {
            var style = this.beforeBrush(ctx, isHighlight);
            ctx.beginPath();
            for (var i = 0; i < style.shapeList.length; i++) {
                var subShape = style.shapeList[i];
                var subShapeStyle = subShape.style;
                if (isHighlight) {
                    subShapeStyle = subShape.getHighlightStyle(subShapeStyle, subShape.highlightStyle || {}, subShape.brushTypeOnly);
                }
                subShape.buildPath(ctx, subShapeStyle);
            }
            switch (style.brushType) {
            case 'both':
                ctx.fill();
            case 'stroke':
                style.lineWidth > 0 && ctx.stroke();
                break;
            default:
                ctx.fill();
            }
            this.drawText(ctx, style, this.style);
            this.afterBrush(ctx);
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            var minX = Infinity;
            var maxX = -Infinity;
            var minY = Infinity;
            var maxY = -Infinity;
            for (var i = 0; i < style.shapeList.length; i++) {
                var subShape = style.shapeList[i];
                var subRect = subShape.getRect(subShape.style);
                var minX = Math.min(subRect.x, minX);
                var minY = Math.min(subRect.y, minY);
                var maxX = Math.max(subRect.x + subRect.width, maxX);
                var maxY = Math.max(subRect.y + subRect.height, maxY);
            }
            style.__rect = {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
            return style.__rect;
        },
        isCover: function (x, y) {
            var originPos = this.transformCoordToLocal(x, y);
            x = originPos[0];
            y = originPos[1];
            if (this.isCoverRect(x, y)) {
                for (var i = 0; i < this.style.shapeList.length; i++) {
                    var subShape = this.style.shapeList[i];
                    if (subShape.isCover(x, y)) {
                        return true;
                    }
                }
            }
            return false;
        }
    };
    require('../tool/util').inherits(ShapeBundle, Base);
    return ShapeBundle;
});define('echarts/util/ecAnimation', [
    'require',
    'zrender/tool/util',
    'zrender/tool/curve',
    'zrender/shape/Polygon'
], function (require) {
    var zrUtil = require('zrender/tool/util');
    var curveTool = require('zrender/tool/curve');
    function pointList(zr, oldShape, newShape, duration, easing) {
        var newPointList = newShape.style.pointList;
        var newPointListLen = newPointList.length;
        var oldPointList;
        if (!oldShape) {
            oldPointList = [];
            if (newShape._orient != 'vertical') {
                var y = newPointList[0][1];
                for (var i = 0; i < newPointListLen; i++) {
                    oldPointList[i] = [
                        newPointList[i][0],
                        y
                    ];
                }
            } else {
                var x = newPointList[0][0];
                for (var i = 0; i < newPointListLen; i++) {
                    oldPointList[i] = [
                        x,
                        newPointList[i][1]
                    ];
                }
            }
            if (newShape.type == 'half-smooth-polygon') {
                oldPointList[newPointListLen - 1] = zrUtil.clone(newPointList[newPointListLen - 1]);
                oldPointList[newPointListLen - 2] = zrUtil.clone(newPointList[newPointListLen - 2]);
            }
            oldShape = { style: { pointList: oldPointList } };
        }
        oldPointList = oldShape.style.pointList;
        var oldPointListLen = oldPointList.length;
        if (oldPointListLen == newPointListLen) {
            newShape.style.pointList = oldPointList;
        } else if (oldPointListLen < newPointListLen) {
            newShape.style.pointList = oldPointList.concat(newPointList.slice(oldPointListLen));
        } else {
            newShape.style.pointList = oldPointList.slice(0, newPointListLen);
        }
        zr.addShape(newShape);
        newShape.__animating = true;
        zr.animate(newShape.id, 'style').when(duration, { pointList: newPointList }).during(function () {
            if (newShape.updateControlPoints) {
                newShape.updateControlPoints(newShape.style);
            }
        }).done(function () {
            newShape.__animating = false;
        }).start(easing);
    }
    function cloneStyle(target, source) {
        var len = arguments.length;
        for (var i = 2; i < len; i++) {
            var prop = arguments[i];
            target.style[prop] = source.style[prop];
        }
    }
    function rectangle(zr, oldShape, newShape, duration, easing) {
        var newShapeStyle = newShape.style;
        if (!oldShape) {
            oldShape = {
                position: newShape.position,
                style: {
                    x: newShapeStyle.x,
                    y: newShape._orient == 'vertical' ? newShapeStyle.y + newShapeStyle.height : newShapeStyle.y,
                    width: newShape._orient == 'vertical' ? newShapeStyle.width : 0,
                    height: newShape._orient != 'vertical' ? newShapeStyle.height : 0
                }
            };
        }
        var newX = newShapeStyle.x;
        var newY = newShapeStyle.y;
        var newWidth = newShapeStyle.width;
        var newHeight = newShapeStyle.height;
        var newPosition = [
            newShape.position[0],
            newShape.position[1]
        ];
        cloneStyle(newShape, oldShape, 'x', 'y', 'width', 'height');
        newShape.position = oldShape.position;
        zr.addShape(newShape);
        if (newPosition[0] != oldShape.position[0] || newPosition[1] != oldShape.position[1]) {
            zr.animate(newShape.id, '').when(duration, { position: newPosition }).start(easing);
        }
        newShape.__animating = true;
        zr.animate(newShape.id, 'style').when(duration, {
            x: newX,
            y: newY,
            width: newWidth,
            height: newHeight
        }).done(function () {
            newShape.__animating = false;
        }).start(easing);
    }
    function candle(zr, oldShape, newShape, duration, easing) {
        if (!oldShape) {
            var y = newShape.style.y;
            oldShape = {
                style: {
                    y: [
                        y[0],
                        y[0],
                        y[0],
                        y[0]
                    ]
                }
            };
        }
        var newY = newShape.style.y;
        newShape.style.y = oldShape.style.y;
        zr.addShape(newShape);
        newShape.__animating = true;
        zr.animate(newShape.id, 'style').when(duration, { y: newY }).done(function () {
            newShape.__animating = false;
        }).start(easing);
    }
    function ring(zr, oldShape, newShape, duration, easing) {
        var x = newShape.style.x;
        var y = newShape.style.y;
        var r0 = newShape.style.r0;
        var r = newShape.style.r;
        newShape.__animating = true;
        if (newShape._animationAdd != 'r') {
            newShape.style.r0 = 0;
            newShape.style.r = 0;
            newShape.rotation = [
                Math.PI * 2,
                x,
                y
            ];
            zr.addShape(newShape);
            zr.animate(newShape.id, 'style').when(duration, {
                r0: r0,
                r: r
            }).done(function () {
                newShape.__animating = false;
            }).start(easing);
            zr.animate(newShape.id, '').when(Math.round(duration / 3 * 2), {
                rotation: [
                    0,
                    x,
                    y
                ]
            }).start(easing);
        } else {
            newShape.style.r0 = newShape.style.r;
            zr.addShape(newShape);
            zr.animate(newShape.id, 'style').when(duration, { r0: r0 }).done(function () {
                newShape.__animating = false;
            }).start(easing);
        }
    }
    function sector(zr, oldShape, newShape, duration, easing) {
        if (!oldShape) {
            if (newShape._animationAdd != 'r') {
                oldShape = {
                    style: {
                        startAngle: newShape.style.startAngle,
                        endAngle: newShape.style.startAngle
                    }
                };
            } else {
                oldShape = { style: { r0: newShape.style.r } };
            }
        }
        var startAngle = newShape.style.startAngle;
        var endAngle = newShape.style.endAngle;
        cloneStyle(newShape, oldShape, 'startAngle', 'endAngle');
        zr.addShape(newShape);
        newShape.__animating = true;
        zr.animate(newShape.id, 'style').when(duration, {
            startAngle: startAngle,
            endAngle: endAngle
        }).done(function () {
            newShape.__animating = false;
        }).start(easing);
    }
    function text(zr, oldShape, newShape, duration, easing) {
        if (!oldShape) {
            oldShape = {
                style: {
                    x: newShape.style.textAlign == 'left' ? newShape.style.x + 100 : newShape.style.x - 100,
                    y: newShape.style.y
                }
            };
        }
        var x = newShape.style.x;
        var y = newShape.style.y;
        cloneStyle(newShape, oldShape, 'x', 'y');
        zr.addShape(newShape);
        newShape.__animating = true;
        zr.animate(newShape.id, 'style').when(duration, {
            x: x,
            y: y
        }).done(function () {
            newShape.__animating = false;
        }).start(easing);
    }
    function polygon(zr, oldShape, newShape, duration, easing) {
        var rect = require('zrender/shape/Polygon').prototype.getRect(newShape.style);
        var x = rect.x + rect.width / 2;
        var y = rect.y + rect.height / 2;
        newShape.scale = [
            0.1,
            0.1,
            x,
            y
        ];
        zr.addShape(newShape);
        newShape.__animating = true;
        zr.animate(newShape.id, '').when(duration, {
            scale: [
                1,
                1,
                x,
                y
            ]
        }).done(function () {
            newShape.__animating = false;
        }).start(easing);
    }
    function ribbon(zr, oldShape, newShape, duration, easing) {
        if (!oldShape) {
            oldShape = {
                style: {
                    source0: 0,
                    source1: newShape.style.source1 > 0 ? 360 : -360,
                    target0: 0,
                    target1: newShape.style.target1 > 0 ? 360 : -360
                }
            };
        }
        var source0 = newShape.style.source0;
        var source1 = newShape.style.source1;
        var target0 = newShape.style.target0;
        var target1 = newShape.style.target1;
        if (oldShape.style) {
            cloneStyle(newShape, oldShape, 'source0', 'source1', 'target0', 'target1');
        }
        zr.addShape(newShape);
        newShape.__animating = true;
        zr.animate(newShape.id, 'style').when(duration, {
            source0: source0,
            source1: source1,
            target0: target0,
            target1: target1
        }).done(function () {
            newShape.__animating = false;
        }).start(easing);
    }
    function gaugePointer(zr, oldShape, newShape, duration, easing) {
        if (!oldShape) {
            oldShape = { style: { angle: newShape.style.startAngle } };
        }
        var angle = newShape.style.angle;
        newShape.style.angle = oldShape.style.angle;
        zr.addShape(newShape);
        newShape.__animating = true;
        zr.animate(newShape.id, 'style').when(duration, { angle: angle }).done(function () {
            newShape.__animating = false;
        }).start(easing);
    }
    function icon(zr, oldShape, newShape, duration, easing, delay) {
        newShape.style._x = newShape.style.x;
        newShape.style._y = newShape.style.y;
        newShape.style._width = newShape.style.width;
        newShape.style._height = newShape.style.height;
        if (!oldShape) {
            var x = newShape._x || 0;
            var y = newShape._y || 0;
            newShape.scale = [
                0.01,
                0.01,
                x,
                y
            ];
            zr.addShape(newShape);
            newShape.__animating = true;
            zr.animate(newShape.id, '').delay(delay).when(duration, {
                scale: [
                    1,
                    1,
                    x,
                    y
                ]
            }).done(function () {
                newShape.__animating = false;
            }).start(easing || 'QuinticOut');
        } else {
            rectangle(zr, oldShape, newShape, duration, easing);
        }
    }
    function line(zr, oldShape, newShape, duration, easing) {
        if (!oldShape) {
            oldShape = {
                style: {
                    xStart: newShape.style.xStart,
                    yStart: newShape.style.yStart,
                    xEnd: newShape.style.xStart,
                    yEnd: newShape.style.yStart
                }
            };
        }
        var xStart = newShape.style.xStart;
        var xEnd = newShape.style.xEnd;
        var yStart = newShape.style.yStart;
        var yEnd = newShape.style.yEnd;
        cloneStyle(newShape, oldShape, 'xStart', 'xEnd', 'yStart', 'yEnd');
        zr.addShape(newShape);
        newShape.__animating = true;
        zr.animate(newShape.id, 'style').when(duration, {
            xStart: xStart,
            xEnd: xEnd,
            yStart: yStart,
            yEnd: yEnd
        }).done(function () {
            newShape.__animating = false;
        }).start(easing);
    }
    function markline(zr, oldShape, newShape, duration, easing) {
        easing = easing || 'QuinticOut';
        newShape.__animating = true;
        zr.addShape(newShape);
        var newShapeStyle = newShape.style;
        var animationDone = function () {
            newShape.__animating = false;
        };
        var x0 = newShapeStyle.xStart;
        var y0 = newShapeStyle.yStart;
        var x2 = newShapeStyle.xEnd;
        var y2 = newShapeStyle.yEnd;
        if (newShapeStyle.curveness > 0) {
            newShape.updatePoints(newShapeStyle);
            var obj = { p: 0 };
            var x1 = newShapeStyle.cpX1;
            var y1 = newShapeStyle.cpY1;
            var newXArr = [];
            var newYArr = [];
            var subdivide = curveTool.quadraticSubdivide;
            zr.animation.animate(obj).when(duration, { p: 1 }).during(function () {
                subdivide(x0, x1, x2, obj.p, newXArr);
                subdivide(y0, y1, y2, obj.p, newYArr);
                newShapeStyle.cpX1 = newXArr[1];
                newShapeStyle.cpY1 = newYArr[1];
                newShapeStyle.xEnd = newXArr[2];
                newShapeStyle.yEnd = newYArr[2];
                zr.modShape(newShape);
            }).done(animationDone).start(easing);
        } else {
            zr.animate(newShape.id, 'style').when(0, {
                xEnd: x0,
                yEnd: y0
            }).when(duration, {
                xEnd: x2,
                yEnd: y2
            }).done(animationDone).start(easing);
        }
    }
    return {
        pointList: pointList,
        rectangle: rectangle,
        candle: candle,
        ring: ring,
        sector: sector,
        text: text,
        polygon: polygon,
        ribbon: ribbon,
        gaugePointer: gaugePointer,
        icon: icon,
        line: line,
        markline: markline
    };
});define('echarts/util/ecEffect', [
    'require',
    '../util/ecData',
    'zrender/shape/Circle',
    'zrender/shape/Image',
    'zrender/tool/curve',
    '../util/shape/Icon',
    '../util/shape/Symbol',
    'zrender/shape/ShapeBundle',
    'zrender/shape/Polyline',
    'zrender/tool/vector',
    'zrender/tool/env'
], function (require) {
    var ecData = require('../util/ecData');
    var CircleShape = require('zrender/shape/Circle');
    var ImageShape = require('zrender/shape/Image');
    var curveTool = require('zrender/tool/curve');
    var IconShape = require('../util/shape/Icon');
    var SymbolShape = require('../util/shape/Symbol');
    var ShapeBundle = require('zrender/shape/ShapeBundle');
    var Polyline = require('zrender/shape/Polyline');
    var vec2 = require('zrender/tool/vector');
    var canvasSupported = require('zrender/tool/env').canvasSupported;
    function point(zr, effectList, shape, zlevel) {
        var effect = shape.effect;
        var color = effect.color || shape.style.strokeColor || shape.style.color;
        var shadowColor = effect.shadowColor || color;
        var size = effect.scaleSize;
        var distance = effect.bounceDistance;
        var shadowBlur = typeof effect.shadowBlur != 'undefined' ? effect.shadowBlur : size;
        var effectShape;
        if (shape.type !== 'image') {
            effectShape = new IconShape({
                zlevel: zlevel,
                style: {
                    brushType: 'stroke',
                    iconType: shape.style.iconType != 'droplet' ? shape.style.iconType : 'circle',
                    x: shadowBlur + 1,
                    y: shadowBlur + 1,
                    n: shape.style.n,
                    width: shape.style._width * size,
                    height: shape.style._height * size,
                    lineWidth: 1,
                    strokeColor: color,
                    shadowColor: shadowColor,
                    shadowBlur: shadowBlur
                },
                draggable: false,
                hoverable: false
            });
            if (shape.style.iconType == 'pin') {
                effectShape.style.y += effectShape.style.height / 2 * 1.5;
            }
            if (canvasSupported) {
                effectShape.style.image = zr.shapeToImage(effectShape, effectShape.style.width + shadowBlur * 2 + 2, effectShape.style.height + shadowBlur * 2 + 2).style.image;
                effectShape = new ImageShape({
                    zlevel: effectShape.zlevel,
                    style: effectShape.style,
                    draggable: false,
                    hoverable: false
                });
            }
        } else {
            effectShape = new ImageShape({
                zlevel: zlevel,
                style: shape.style,
                draggable: false,
                hoverable: false
            });
        }
        ecData.clone(shape, effectShape);
        effectShape.position = shape.position;
        effectList.push(effectShape);
        zr.addShape(effectShape);
        var devicePixelRatio = shape.type !== 'image' ? window.devicePixelRatio || 1 : 1;
        var offset = (effectShape.style.width / devicePixelRatio - shape.style._width) / 2;
        effectShape.style.x = shape.style._x - offset;
        effectShape.style.y = shape.style._y - offset;
        if (shape.style.iconType == 'pin') {
            effectShape.style.y -= shape.style.height / 2 * 1.5;
        }
        var duration = (effect.period + Math.random() * 10) * 100;
        zr.modShape(shape.id, { invisible: true });
        var centerX = effectShape.style.x + effectShape.style.width / 2 / devicePixelRatio;
        var centerY = effectShape.style.y + effectShape.style.height / 2 / devicePixelRatio;
        if (effect.type === 'scale') {
            zr.modShape(effectShape.id, {
                scale: [
                    0.1,
                    0.1,
                    centerX,
                    centerY
                ]
            });
            zr.animate(effectShape.id, '', effect.loop).when(duration, {
                scale: [
                    1,
                    1,
                    centerX,
                    centerY
                ]
            }).done(function () {
                shape.effect.show = false;
                zr.delShape(effectShape.id);
            }).start();
        } else {
            zr.animate(effectShape.id, 'style', effect.loop).when(duration, { y: effectShape.style.y - distance }).when(duration * 2, { y: effectShape.style.y }).done(function () {
                shape.effect.show = false;
                zr.delShape(effectShape.id);
            }).start();
        }
    }
    function largePoint(zr, effectList, shape, zlevel) {
        var effect = shape.effect;
        var color = effect.color || shape.style.strokeColor || shape.style.color;
        var size = effect.scaleSize;
        var shadowColor = effect.shadowColor || color;
        var shadowBlur = typeof effect.shadowBlur != 'undefined' ? effect.shadowBlur : size * 2;
        var devicePixelRatio = window.devicePixelRatio || 1;
        var effectShape = new SymbolShape({
            zlevel: zlevel,
            position: shape.position,
            scale: shape.scale,
            style: {
                pointList: shape.style.pointList,
                iconType: shape.style.iconType,
                color: color,
                strokeColor: color,
                shadowColor: shadowColor,
                shadowBlur: shadowBlur * devicePixelRatio,
                random: true,
                brushType: 'fill',
                lineWidth: 1,
                size: shape.style.size
            },
            draggable: false,
            hoverable: false
        });
        effectList.push(effectShape);
        zr.addShape(effectShape);
        zr.modShape(shape.id, { invisible: true });
        var duration = Math.round(effect.period * 100);
        var clip1 = {};
        var clip2 = {};
        for (var i = 0; i < 20; i++) {
            effectShape.style['randomMap' + i] = 0;
            clip1 = {};
            clip1['randomMap' + i] = 100;
            clip2 = {};
            clip2['randomMap' + i] = 0;
            effectShape.style['randomMap' + i] = Math.random() * 100;
            zr.animate(effectShape.id, 'style', true).when(duration, clip1).when(duration * 2, clip2).when(duration * 3, clip1).when(duration * 4, clip1).delay(Math.random() * duration * i).start();
        }
    }
    function line(zr, effectList, shape, zlevel, isLarge) {
        var effect = shape.effect;
        var shapeStyle = shape.style;
        var color = effect.color || shapeStyle.strokeColor || shapeStyle.color;
        var shadowColor = effect.shadowColor || shapeStyle.strokeColor || color;
        var size = shapeStyle.lineWidth * effect.scaleSize;
        var shadowBlur = typeof effect.shadowBlur != 'undefined' ? effect.shadowBlur : size;
        var effectShape = new CircleShape({
            zlevel: zlevel,
            style: {
                x: shadowBlur,
                y: shadowBlur,
                r: size,
                color: color,
                shadowColor: shadowColor,
                shadowBlur: shadowBlur
            },
            hoverable: false
        });
        var offset = 0;
        if (canvasSupported && !isLarge) {
            var zlevel = effectShape.zlevel;
            effectShape = zr.shapeToImage(effectShape, (size + shadowBlur) * 2, (size + shadowBlur) * 2);
            effectShape.zlevel = zlevel;
            effectShape.hoverable = false;
            offset = shadowBlur;
        }
        if (!isLarge) {
            ecData.clone(shape, effectShape);
            effectShape.position = shape.position;
            effectList.push(effectShape);
            zr.addShape(effectShape);
        }
        var effectDone = function () {
            if (!isLarge) {
                shape.effect.show = false;
                zr.delShape(effectShape.id);
            }
            effectShape.effectAnimator = null;
        };
        if (shape instanceof Polyline) {
            var distanceList = [0];
            var totalDist = 0;
            var pointList = shapeStyle.pointList;
            var controlPointList = shapeStyle.controlPointList;
            for (var i = 1; i < pointList.length; i++) {
                if (controlPointList) {
                    var cp1 = controlPointList[(i - 1) * 2];
                    var cp2 = controlPointList[(i - 1) * 2 + 1];
                    totalDist += vec2.dist(pointList[i - 1], cp1) + vec2.dist(cp1, cp2) + vec2.dist(cp2, pointList[i]);
                } else {
                    totalDist += vec2.dist(pointList[i - 1], pointList[i]);
                }
                distanceList.push(totalDist);
            }
            var obj = { p: 0 };
            var animator = zr.animation.animate(obj, { loop: effect.loop });
            for (var i = 0; i < distanceList.length; i++) {
                animator.when(distanceList[i] * effect.period, { p: i });
            }
            animator.during(function () {
                var i = Math.floor(obj.p);
                var x, y;
                if (i == pointList.length - 1) {
                    x = pointList[i][0];
                    y = pointList[i][1];
                } else {
                    var t = obj.p - i;
                    var p0 = pointList[i];
                    var p1 = pointList[i + 1];
                    if (controlPointList) {
                        var cp1 = controlPointList[i * 2];
                        var cp2 = controlPointList[i * 2 + 1];
                        x = curveTool.cubicAt(p0[0], cp1[0], cp2[0], p1[0], t);
                        y = curveTool.cubicAt(p0[1], cp1[1], cp2[1], p1[1], t);
                    } else {
                        x = (p1[0] - p0[0]) * t + p0[0];
                        y = (p1[1] - p0[1]) * t + p0[1];
                    }
                }
                effectShape.style.x = x;
                effectShape.style.y = y;
                if (!isLarge) {
                    zr.modShape(effectShape);
                }
            }).done(effectDone).start();
            animator.duration = totalDist * effect.period;
            effectShape.effectAnimator = animator;
        } else {
            var x0 = shapeStyle.xStart - offset;
            var y0 = shapeStyle.yStart - offset;
            var x2 = shapeStyle.xEnd - offset;
            var y2 = shapeStyle.yEnd - offset;
            effectShape.style.x = x0;
            effectShape.style.y = y0;
            var distance = (x2 - x0) * (x2 - x0) + (y2 - y0) * (y2 - y0);
            var duration = Math.round(Math.sqrt(Math.round(distance * effect.period * effect.period)));
            if (shape.style.curveness > 0) {
                var x1 = shapeStyle.cpX1 - offset;
                var y1 = shapeStyle.cpY1 - offset;
                effectShape.effectAnimator = zr.animation.animate(effectShape, { loop: effect.loop }).when(duration, { p: 1 }).during(function (target, t) {
                    effectShape.style.x = curveTool.quadraticAt(x0, x1, x2, t);
                    effectShape.style.y = curveTool.quadraticAt(y0, y1, y2, t);
                    if (!isLarge) {
                        zr.modShape(effectShape);
                    }
                }).done(effectDone).start();
            } else {
                effectShape.effectAnimator = zr.animation.animate(effectShape.style, { loop: effect.loop }).when(duration, {
                    x: x2,
                    y: y2
                }).during(function () {
                    if (!isLarge) {
                        zr.modShape(effectShape);
                    }
                }).done(effectDone).start();
            }
            effectShape.effectAnimator.duration = duration;
        }
        return effectShape;
    }
    function largeLine(zr, effectList, shape, zlevel) {
        var effectShape = new ShapeBundle({
            style: { shapeList: [] },
            zlevel: zlevel,
            hoverable: false
        });
        var shapeList = shape.style.shapeList;
        var effect = shape.effect;
        effectShape.position = shape.position;
        var maxDuration = 0;
        var subEffectAnimators = [];
        for (var i = 0; i < shapeList.length; i++) {
            shapeList[i].effect = effect;
            var subEffectShape = line(zr, null, shapeList[i], zlevel, true);
            var subEffectAnimator = subEffectShape.effectAnimator;
            effectShape.style.shapeList.push(subEffectShape);
            if (subEffectAnimator.duration > maxDuration) {
                maxDuration = subEffectAnimator.duration;
            }
            if (i === 0) {
                effectShape.style.color = subEffectShape.style.color;
                effectShape.style.shadowBlur = subEffectShape.style.shadowBlur;
                effectShape.style.shadowColor = subEffectShape.style.shadowColor;
            }
            subEffectAnimators.push(subEffectAnimator);
        }
        effectList.push(effectShape);
        zr.addShape(effectShape);
        var clearAllAnimators = function () {
            for (var i = 0; i < subEffectAnimators.length; i++) {
                subEffectAnimators[i].stop();
            }
        };
        if (maxDuration) {
            effectShape.__dummy = 0;
            var animator = zr.animate(effectShape.id, '', effect.loop).when(maxDuration, { __dummy: 1 }).during(function () {
                zr.modShape(effectShape);
            }).done(function () {
                shape.effect.show = false;
                zr.delShape(effectShape.id);
            }).start();
            var oldStop = animator.stop;
            animator.stop = function () {
                clearAllAnimators();
                oldStop.call(this);
            };
        }
    }
    return {
        point: point,
        largePoint: largePoint,
        line: line,
        largeLine: largeLine
    };
});define('echarts/component/base', [
    'require',
    '../config',
    '../util/ecData',
    '../util/ecQuery',
    '../util/number',
    'zrender/tool/util',
    'zrender/tool/env'
], function (require) {
    var ecConfig = require('../config');
    var ecData = require('../util/ecData');
    var ecQuery = require('../util/ecQuery');
    var number = require('../util/number');
    var zrUtil = require('zrender/tool/util');
    function Base(ecTheme, messageCenter, zr, option, myChart) {
        this.ecTheme = ecTheme;
        this.messageCenter = messageCenter;
        this.zr = zr;
        this.option = option;
        this.series = option.series;
        this.myChart = myChart;
        this.component = myChart.component;
        this.shapeList = [];
        this.effectList = [];
        var self = this;
        self._onlegendhoverlink = function (param) {
            if (self.legendHoverLink) {
                var targetName = param.target;
                var name;
                for (var i = self.shapeList.length - 1; i >= 0; i--) {
                    name = self.type == ecConfig.CHART_TYPE_PIE || self.type == ecConfig.CHART_TYPE_FUNNEL ? ecData.get(self.shapeList[i], 'name') : (ecData.get(self.shapeList[i], 'series') || {}).name;
                    if (name == targetName && !self.shapeList[i].invisible && !self.shapeList[i].__animating) {
                        self.zr.addHoverShape(self.shapeList[i]);
                    }
                }
            }
        };
        messageCenter && messageCenter.bind(ecConfig.EVENT.LEGEND_HOVERLINK, this._onlegendhoverlink);
    }
    Base.prototype = {
        canvasSupported: require('zrender/tool/env').canvasSupported,
        _getZ: function (zWhat) {
            if (this[zWhat] != null) {
                return this[zWhat];
            }
            var opt = this.ecTheme[this.type];
            if (opt && opt[zWhat] != null) {
                return opt[zWhat];
            }
            opt = ecConfig[this.type];
            if (opt && opt[zWhat] != null) {
                return opt[zWhat];
            }
            return 0;
        },
        getZlevelBase: function () {
            return this._getZ('zlevel');
        },
        getZBase: function () {
            return this._getZ('z');
        },
        reformOption: function (opt) {
            opt = zrUtil.merge(zrUtil.merge(opt || {}, zrUtil.clone(this.ecTheme[this.type] || {})), zrUtil.clone(ecConfig[this.type] || {}));
            this.z = opt.z;
            this.zlevel = opt.zlevel;
            return opt;
        },
        reformCssArray: function (p) {
            if (p instanceof Array) {
                switch (p.length + '') {
                case '4':
                    return p;
                case '3':
                    return [
                        p[0],
                        p[1],
                        p[2],
                        p[1]
                    ];
                case '2':
                    return [
                        p[0],
                        p[1],
                        p[0],
                        p[1]
                    ];
                case '1':
                    return [
                        p[0],
                        p[0],
                        p[0],
                        p[0]
                    ];
                case '0':
                    return [
                        0,
                        0,
                        0,
                        0
                    ];
                }
            } else {
                return [
                    p,
                    p,
                    p,
                    p
                ];
            }
        },
        getShapeById: function (id) {
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                if (this.shapeList[i].id === id) {
                    return this.shapeList[i];
                }
            }
            return null;
        },
        getFont: function (textStyle) {
            var finalTextStyle = this.getTextStyle(zrUtil.clone(textStyle));
            return finalTextStyle.fontStyle + ' ' + finalTextStyle.fontWeight + ' ' + finalTextStyle.fontSize + 'px ' + finalTextStyle.fontFamily;
        },
        getTextStyle: function (targetStyle) {
            return zrUtil.merge(zrUtil.merge(targetStyle || {}, this.ecTheme.textStyle), ecConfig.textStyle);
        },
        getItemStyleColor: function (itemColor, seriesIndex, dataIndex, data) {
            return typeof itemColor === 'function' ? itemColor.call(this.myChart, {
                seriesIndex: seriesIndex,
                series: this.series[seriesIndex],
                dataIndex: dataIndex,
                data: data
            }) : itemColor;
        },
        getDataFromOption: function (data, defaultData) {
            return data != null ? data.value != null ? data.value : data : defaultData;
        },
        subPixelOptimize: function (position, lineWidth) {
            if (lineWidth % 2 === 1) {
                position = Math.floor(position) + 0.5;
            } else {
                position = Math.round(position);
            }
            return position;
        },
        resize: function () {
            this.refresh && this.refresh();
            this.clearEffectShape && this.clearEffectShape(true);
            var self = this;
            setTimeout(function () {
                self.animationEffect && self.animationEffect();
            }, 200);
        },
        clear: function () {
            this.clearEffectShape && this.clearEffectShape();
            this.zr && this.zr.delShape(this.shapeList);
            this.shapeList = [];
        },
        dispose: function () {
            this.onbeforDispose && this.onbeforDispose();
            this.clear();
            this.shapeList = null;
            this.effectList = null;
            this.messageCenter && this.messageCenter.unbind(ecConfig.EVENT.LEGEND_HOVERLINK, this._onlegendhoverlink);
            this.onafterDispose && this.onafterDispose();
        },
        query: ecQuery.query,
        deepQuery: ecQuery.deepQuery,
        deepMerge: ecQuery.deepMerge,
        parsePercent: number.parsePercent,
        parseCenter: number.parseCenter,
        parseRadius: number.parseRadius,
        numAddCommas: number.addCommas
    };
    return Base;
});define('echarts/layout/EdgeBundling', [
    'require',
    '../data/KDTree',
    'zrender/tool/vector'
], function (require) {
    var KDTree = require('../data/KDTree');
    var vec2 = require('zrender/tool/vector');
    var v2Create = vec2.create;
    var v2DistSquare = vec2.distSquare;
    var v2Dist = vec2.dist;
    var v2Copy = vec2.copy;
    var v2Clone = vec2.clone;
    function squaredDistance(a, b) {
        a = a.array;
        b = b.array;
        var x = b[0] - a[0];
        var y = b[1] - a[1];
        var z = b[2] - a[2];
        var w = b[3] - a[3];
        return x * x + y * y + z * z + w * w;
    }
    function CoarsenedEdge(group) {
        this.points = [
            group.mp0,
            group.mp1
        ];
        this.group = group;
    }
    function Edge(edge) {
        var points = edge.points;
        if (points[0][1] < points[1][1] || edge instanceof CoarsenedEdge) {
            this.array = [
                points[0][0],
                points[0][1],
                points[1][0],
                points[1][1]
            ];
            this._startPoint = points[0];
            this._endPoint = points[1];
        } else {
            this.array = [
                points[1][0],
                points[1][1],
                points[0][0],
                points[0][1]
            ];
            this._startPoint = points[1];
            this._endPoint = points[0];
        }
        this.ink = v2Dist(points[0], points[1]);
        this.edge = edge;
        this.group = null;
    }
    Edge.prototype.getStartPoint = function () {
        return this._startPoint;
    };
    Edge.prototype.getEndPoint = function () {
        return this._endPoint;
    };
    function BundledEdgeGroup() {
        this.edgeList = [];
        this.mp0 = v2Create();
        this.mp1 = v2Create();
        this.ink = 0;
    }
    BundledEdgeGroup.prototype.addEdge = function (edge) {
        edge.group = this;
        this.edgeList.push(edge);
    };
    BundledEdgeGroup.prototype.removeEdge = function (edge) {
        edge.group = null;
        this.edgeList.splice(this.edgeList.indexOf(edge), 1);
    };
    function EdgeBundling() {
        this.maxNearestEdge = 6;
        this.maxTurningAngle = Math.PI / 4;
        this.maxIteration = 20;
    }
    EdgeBundling.prototype = {
        constructor: EdgeBundling,
        run: function (rawEdges) {
            var res = this._iterate(rawEdges);
            var nIterate = 0;
            while (nIterate++ < this.maxIteration) {
                var coarsenedEdges = [];
                for (var i = 0; i < res.groups.length; i++) {
                    coarsenedEdges.push(new CoarsenedEdge(res.groups[i]));
                }
                var newRes = this._iterate(coarsenedEdges);
                if (newRes.savedInk <= 0) {
                    break;
                } else {
                    res = newRes;
                }
            }
            var newEdges = [];
            function pointApproxEqual(p0, p1) {
                return v2DistSquare(p0, p1) < 1e-10;
            }
            function cleanEdgePoints(edgePoints, rawEdgePoints) {
                var res = [];
                var off = 0;
                for (var i = 0; i < edgePoints.length; i++) {
                    if (!(off > 0 && pointApproxEqual(edgePoints[i], res[off - 1]))) {
                        res[off++] = v2Clone(edgePoints[i]);
                    }
                }
                if (rawEdgePoints[0] && !pointApproxEqual(res[0], rawEdgePoints[0])) {
                    res = res.reverse();
                }
                return res;
            }
            var buildNewEdges = function (groups, fromEdgePoints) {
                var newEdgePoints;
                for (var i = 0; i < groups.length; i++) {
                    var group = groups[i];
                    if (group.edgeList[0] && group.edgeList[0].edge instanceof CoarsenedEdge) {
                        var newGroups = [];
                        for (var j = 0; j < group.edgeList.length; j++) {
                            newGroups.push(group.edgeList[j].edge.group);
                        }
                        if (!fromEdgePoints) {
                            newEdgePoints = [];
                        } else {
                            newEdgePoints = fromEdgePoints.slice();
                        }
                        newEdgePoints.unshift(group.mp0);
                        newEdgePoints.push(group.mp1);
                        buildNewEdges(newGroups, newEdgePoints);
                    } else {
                        for (var j = 0; j < group.edgeList.length; j++) {
                            var edge = group.edgeList[j];
                            if (!fromEdgePoints) {
                                newEdgePoints = [];
                            } else {
                                newEdgePoints = fromEdgePoints.slice();
                            }
                            newEdgePoints.unshift(group.mp0);
                            newEdgePoints.push(group.mp1);
                            newEdgePoints.unshift(edge.getStartPoint());
                            newEdgePoints.push(edge.getEndPoint());
                            newEdges.push({
                                points: cleanEdgePoints(newEdgePoints, edge.edge.points),
                                rawEdge: edge.edge
                            });
                        }
                    }
                }
            };
            buildNewEdges(res.groups);
            return newEdges;
        },
        _iterate: function (rawEdges) {
            var edges = [];
            var groups = [];
            var totalSavedInk = 0;
            for (var i = 0; i < rawEdges.length; i++) {
                var edge = new Edge(rawEdges[i]);
                edges.push(edge);
            }
            var tree = new KDTree(edges, 4);
            var nearests = [];
            var _mp0 = v2Create();
            var _mp1 = v2Create();
            var _newGroupInk = 0;
            var mp0 = v2Create();
            var mp1 = v2Create();
            var newGroupInk = 0;
            for (var i = 0; i < edges.length; i++) {
                var edge = edges[i];
                if (edge.group) {
                    continue;
                }
                tree.nearestN(edge, this.maxNearestEdge, squaredDistance, nearests);
                var maxSavedInk = 0;
                var mostSavingInkEdge = null;
                var lastCheckedGroup = null;
                for (var j = 0; j < nearests.length; j++) {
                    var nearest = nearests[j];
                    var savedInk = 0;
                    if (nearest.group) {
                        if (nearest.group !== lastCheckedGroup) {
                            lastCheckedGroup = nearest.group;
                            _newGroupInk = this._calculateGroupEdgeInk(nearest.group, edge, _mp0, _mp1);
                            savedInk = nearest.group.ink + edge.ink - _newGroupInk;
                        }
                    } else {
                        _newGroupInk = this._calculateEdgeEdgeInk(edge, nearest, _mp0, _mp1);
                        savedInk = nearest.ink + edge.ink - _newGroupInk;
                    }
                    if (savedInk > maxSavedInk) {
                        maxSavedInk = savedInk;
                        mostSavingInkEdge = nearest;
                        v2Copy(mp1, _mp1);
                        v2Copy(mp0, _mp0);
                        newGroupInk = _newGroupInk;
                    }
                }
                if (mostSavingInkEdge) {
                    totalSavedInk += maxSavedInk;
                    var group;
                    if (!mostSavingInkEdge.group) {
                        group = new BundledEdgeGroup();
                        groups.push(group);
                        group.addEdge(mostSavingInkEdge);
                    }
                    group = mostSavingInkEdge.group;
                    v2Copy(group.mp0, mp0);
                    v2Copy(group.mp1, mp1);
                    group.ink = newGroupInk;
                    mostSavingInkEdge.group.addEdge(edge);
                } else {
                    var group = new BundledEdgeGroup();
                    groups.push(group);
                    v2Copy(group.mp0, edge.getStartPoint());
                    v2Copy(group.mp1, edge.getEndPoint());
                    group.ink = edge.ink;
                    group.addEdge(edge);
                }
            }
            return {
                groups: groups,
                edges: edges,
                savedInk: totalSavedInk
            };
        },
        _calculateEdgeEdgeInk: function () {
            var startPointSet = [];
            var endPointSet = [];
            return function (e0, e1, mp0, mp1) {
                startPointSet[0] = e0.getStartPoint();
                startPointSet[1] = e1.getStartPoint();
                endPointSet[0] = e0.getEndPoint();
                endPointSet[1] = e1.getEndPoint();
                this._calculateMeetPoints(startPointSet, endPointSet, mp0, mp1);
                var ink = v2Dist(startPointSet[0], mp0) + v2Dist(mp0, mp1) + v2Dist(mp1, endPointSet[0]) + v2Dist(startPointSet[1], mp0) + v2Dist(mp1, endPointSet[1]);
                return ink;
            };
        }(),
        _calculateGroupEdgeInk: function (group, edgeTryAdd, mp0, mp1) {
            var startPointSet = [];
            var endPointSet = [];
            for (var i = 0; i < group.edgeList.length; i++) {
                var edge = group.edgeList[i];
                startPointSet.push(edge.getStartPoint());
                endPointSet.push(edge.getEndPoint());
            }
            startPointSet.push(edgeTryAdd.getStartPoint());
            endPointSet.push(edgeTryAdd.getEndPoint());
            this._calculateMeetPoints(startPointSet, endPointSet, mp0, mp1);
            var ink = v2Dist(mp0, mp1);
            for (var i = 0; i < startPointSet.length; i++) {
                ink += v2Dist(startPointSet[i], mp0) + v2Dist(endPointSet[i], mp1);
            }
            return ink;
        },
        _calculateMeetPoints: function () {
            var cp0 = v2Create();
            var cp1 = v2Create();
            return function (startPointSet, endPointSet, mp0, mp1) {
                vec2.set(cp0, 0, 0);
                vec2.set(cp1, 0, 0);
                var len = startPointSet.length;
                for (var i = 0; i < len; i++) {
                    vec2.add(cp0, cp0, startPointSet[i]);
                }
                vec2.scale(cp0, cp0, 1 / len);
                len = endPointSet.length;
                for (var i = 0; i < len; i++) {
                    vec2.add(cp1, cp1, endPointSet[i]);
                }
                vec2.scale(cp1, cp1, 1 / len);
                this._limitTurningAngle(startPointSet, cp0, cp1, mp0);
                this._limitTurningAngle(endPointSet, cp1, cp0, mp1);
            };
        }(),
        _limitTurningAngle: function () {
            var v10 = v2Create();
            var vTmp = v2Create();
            var project = v2Create();
            var tmpOut = v2Create();
            return function (pointSet, p0, p1, out) {
                var maxTurningAngleCos = Math.cos(this.maxTurningAngle);
                var maxTurningAngleTan = Math.tan(this.maxTurningAngle);
                vec2.sub(v10, p0, p1);
                vec2.normalize(v10, v10);
                vec2.copy(out, p0);
                var maxMovement = 0;
                for (var i = 0; i < pointSet.length; i++) {
                    var p = pointSet[i];
                    vec2.sub(vTmp, p, p0);
                    var len = vec2.len(vTmp);
                    vec2.scale(vTmp, vTmp, 1 / len);
                    var turningAngleCos = vec2.dot(vTmp, v10);
                    if (turningAngleCos < maxTurningAngleCos) {
                        vec2.scaleAndAdd(project, p0, v10, len * turningAngleCos);
                        var distance = v2Dist(project, p);
                        var d = distance / maxTurningAngleTan;
                        vec2.scaleAndAdd(tmpOut, project, v10, -d);
                        var movement = v2DistSquare(tmpOut, p0);
                        if (movement > maxMovement) {
                            maxMovement = movement;
                            vec2.copy(out, tmpOut);
                        }
                    }
                }
            };
        }()
    };
    return EdgeBundling;
});define('zrender/shape/Star', [
    'require',
    '../tool/math',
    './Base',
    '../tool/util'
], function (require) {
    var math = require('../tool/math');
    var sin = math.sin;
    var cos = math.cos;
    var PI = Math.PI;
    var Base = require('./Base');
    var Star = function (options) {
        Base.call(this, options);
    };
    Star.prototype = {
        type: 'star',
        buildPath: function (ctx, style) {
            var n = style.n;
            if (!n || n < 2) {
                return;
            }
            var x = style.x;
            var y = style.y;
            var r = style.r;
            var r0 = style.r0;
            if (r0 == null) {
                r0 = n > 4 ? r * cos(2 * PI / n) / cos(PI / n) : r / 3;
            }
            var dStep = PI / n;
            var deg = -PI / 2;
            var xStart = x + r * cos(deg);
            var yStart = y + r * sin(deg);
            deg += dStep;
            var pointList = style.pointList = [];
            pointList.push([
                xStart,
                yStart
            ]);
            for (var i = 0, end = n * 2 - 1, ri; i < end; i++) {
                ri = i % 2 === 0 ? r0 : r;
                pointList.push([
                    x + ri * cos(deg),
                    y + ri * sin(deg)
                ]);
                deg += dStep;
            }
            pointList.push([
                xStart,
                yStart
            ]);
            ctx.moveTo(pointList[0][0], pointList[0][1]);
            for (var i = 0; i < pointList.length; i++) {
                ctx.lineTo(pointList[i][0], pointList[i][1]);
            }
            ctx.closePath();
            return;
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            var lineWidth;
            if (style.brushType == 'stroke' || style.brushType == 'fill') {
                lineWidth = style.lineWidth || 1;
            } else {
                lineWidth = 0;
            }
            style.__rect = {
                x: Math.round(style.x - style.r - lineWidth / 2),
                y: Math.round(style.y - style.r - lineWidth / 2),
                width: style.r * 2 + lineWidth,
                height: style.r * 2 + lineWidth
            };
            return style.__rect;
        }
    };
    require('../tool/util').inherits(Star, Base);
    return Star;
});define('zrender/shape/Heart', [
    'require',
    './Base',
    './util/PathProxy',
    '../tool/area',
    '../tool/util'
], function (require) {
    'use strict';
    var Base = require('./Base');
    var PathProxy = require('./util/PathProxy');
    var area = require('../tool/area');
    var Heart = function (options) {
        Base.call(this, options);
        this._pathProxy = new PathProxy();
    };
    Heart.prototype = {
        type: 'heart',
        buildPath: function (ctx, style) {
            var path = this._pathProxy || new PathProxy();
            path.begin(ctx);
            path.moveTo(style.x, style.y);
            path.bezierCurveTo(style.x + style.a / 2, style.y - style.b * 2 / 3, style.x + style.a * 2, style.y + style.b / 3, style.x, style.y + style.b);
            path.bezierCurveTo(style.x - style.a * 2, style.y + style.b / 3, style.x - style.a / 2, style.y - style.b * 2 / 3, style.x, style.y);
            path.closePath();
            return;
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            if (!this._pathProxy.isEmpty()) {
                this.buildPath(null, style);
            }
            return this._pathProxy.fastBoundingRect();
        },
        isCover: function (x, y) {
            var originPos = this.transformCoordToLocal(x, y);
            x = originPos[0];
            y = originPos[1];
            if (this.isCoverRect(x, y)) {
                return area.isInsidePath(this._pathProxy.pathCommands, this.style.lineWidth, this.style.brushType, x, y);
            }
        }
    };
    require('../tool/util').inherits(Heart, Base);
    return Heart;
});define('zrender/shape/Droplet', [
    'require',
    './Base',
    './util/PathProxy',
    '../tool/area',
    '../tool/util'
], function (require) {
    'use strict';
    var Base = require('./Base');
    var PathProxy = require('./util/PathProxy');
    var area = require('../tool/area');
    var Droplet = function (options) {
        Base.call(this, options);
        this._pathProxy = new PathProxy();
    };
    Droplet.prototype = {
        type: 'droplet',
        buildPath: function (ctx, style) {
            var path = this._pathProxy || new PathProxy();
            path.begin(ctx);
            path.moveTo(style.x, style.y + style.a);
            path.bezierCurveTo(style.x + style.a, style.y + style.a, style.x + style.a * 3 / 2, style.y - style.a / 3, style.x, style.y - style.b);
            path.bezierCurveTo(style.x - style.a * 3 / 2, style.y - style.a / 3, style.x - style.a, style.y + style.a, style.x, style.y + style.a);
            path.closePath();
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            if (!this._pathProxy.isEmpty()) {
                this.buildPath(null, style);
            }
            return this._pathProxy.fastBoundingRect();
        },
        isCover: function (x, y) {
            var originPos = this.transformCoordToLocal(x, y);
            x = originPos[0];
            y = originPos[1];
            if (this.isCoverRect(x, y)) {
                return area.isInsidePath(this._pathProxy.pathCommands, this.style.lineWidth, this.style.brushType, x, y);
            }
        }
    };
    require('../tool/util').inherits(Droplet, Base);
    return Droplet;
});define('zrender/tool/math', [], function () {
    var _radians = Math.PI / 180;
    function sin(angle, isDegrees) {
        return Math.sin(isDegrees ? angle * _radians : angle);
    }
    function cos(angle, isDegrees) {
        return Math.cos(isDegrees ? angle * _radians : angle);
    }
    function degreeToRadian(angle) {
        return angle * _radians;
    }
    function radianToDegree(angle) {
        return angle / _radians;
    }
    return {
        sin: sin,
        cos: cos,
        degreeToRadian: degreeToRadian,
        radianToDegree: radianToDegree
    };
});define('zrender/shape/util/PathProxy', [
    'require',
    '../../tool/vector'
], function (require) {
    var vector = require('../../tool/vector');
    var PathSegment = function (command, points) {
        this.command = command;
        this.points = points || null;
    };
    var PathProxy = function () {
        this.pathCommands = [];
        this._ctx = null;
        this._min = [];
        this._max = [];
    };
    PathProxy.prototype.fastBoundingRect = function () {
        var min = this._min;
        var max = this._max;
        min[0] = min[1] = Infinity;
        max[0] = max[1] = -Infinity;
        for (var i = 0; i < this.pathCommands.length; i++) {
            var seg = this.pathCommands[i];
            var p = seg.points;
            switch (seg.command) {
            case 'M':
                vector.min(min, min, p);
                vector.max(max, max, p);
                break;
            case 'L':
                vector.min(min, min, p);
                vector.max(max, max, p);
                break;
            case 'C':
                for (var j = 0; j < 6; j += 2) {
                    min[0] = Math.min(min[0], min[0], p[j]);
                    min[1] = Math.min(min[1], min[1], p[j + 1]);
                    max[0] = Math.max(max[0], max[0], p[j]);
                    max[1] = Math.max(max[1], max[1], p[j + 1]);
                }
                break;
            case 'Q':
                for (var j = 0; j < 4; j += 2) {
                    min[0] = Math.min(min[0], min[0], p[j]);
                    min[1] = Math.min(min[1], min[1], p[j + 1]);
                    max[0] = Math.max(max[0], max[0], p[j]);
                    max[1] = Math.max(max[1], max[1], p[j + 1]);
                }
                break;
            case 'A':
                var cx = p[0];
                var cy = p[1];
                var rx = p[2];
                var ry = p[3];
                min[0] = Math.min(min[0], min[0], cx - rx);
                min[1] = Math.min(min[1], min[1], cy - ry);
                max[0] = Math.max(max[0], max[0], cx + rx);
                max[1] = Math.max(max[1], max[1], cy + ry);
                break;
            }
        }
        return {
            x: min[0],
            y: min[1],
            width: max[0] - min[0],
            height: max[1] - min[1]
        };
    };
    PathProxy.prototype.begin = function (ctx) {
        this._ctx = ctx || null;
        this.pathCommands.length = 0;
        return this;
    };
    PathProxy.prototype.moveTo = function (x, y) {
        this.pathCommands.push(new PathSegment('M', [
            x,
            y
        ]));
        if (this._ctx) {
            this._ctx.moveTo(x, y);
        }
        return this;
    };
    PathProxy.prototype.lineTo = function (x, y) {
        this.pathCommands.push(new PathSegment('L', [
            x,
            y
        ]));
        if (this._ctx) {
            this._ctx.lineTo(x, y);
        }
        return this;
    };
    PathProxy.prototype.bezierCurveTo = function (x1, y1, x2, y2, x3, y3) {
        this.pathCommands.push(new PathSegment('C', [
            x1,
            y1,
            x2,
            y2,
            x3,
            y3
        ]));
        if (this._ctx) {
            this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
        }
        return this;
    };
    PathProxy.prototype.quadraticCurveTo = function (x1, y1, x2, y2) {
        this.pathCommands.push(new PathSegment('Q', [
            x1,
            y1,
            x2,
            y2
        ]));
        if (this._ctx) {
            this._ctx.quadraticCurveTo(x1, y1, x2, y2);
        }
        return this;
    };
    PathProxy.prototype.arc = function (cx, cy, r, startAngle, endAngle, anticlockwise) {
        this.pathCommands.push(new PathSegment('A', [
            cx,
            cy,
            r,
            r,
            startAngle,
            endAngle - startAngle,
            0,
            anticlockwise ? 0 : 1
        ]));
        if (this._ctx) {
            this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
        }
        return this;
    };
    PathProxy.prototype.arcTo = function (x1, y1, x2, y2, radius) {
        if (this._ctx) {
            this._ctx.arcTo(x1, y1, x2, y2, radius);
        }
        return this;
    };
    PathProxy.prototype.rect = function (x, y, w, h) {
        if (this._ctx) {
            this._ctx.rect(x, y, w, h);
        }
        return this;
    };
    PathProxy.prototype.closePath = function () {
        this.pathCommands.push(new PathSegment('z'));
        if (this._ctx) {
            this._ctx.closePath();
        }
        return this;
    };
    PathProxy.prototype.isEmpty = function () {
        return this.pathCommands.length === 0;
    };
    PathProxy.PathSegment = PathSegment;
    return PathProxy;
});define('zrender/shape/Line', [
    'require',
    './Base',
    './util/dashedLineTo',
    '../tool/util'
], function (require) {
    var Base = require('./Base');
    var dashedLineTo = require('./util/dashedLineTo');
    var Line = function (options) {
        this.brushTypeOnly = 'stroke';
        this.textPosition = 'end';
        Base.call(this, options);
    };
    Line.prototype = {
        type: 'line',
        buildPath: function (ctx, style) {
            if (!style.lineType || style.lineType == 'solid') {
                ctx.moveTo(style.xStart, style.yStart);
                ctx.lineTo(style.xEnd, style.yEnd);
            } else if (style.lineType == 'dashed' || style.lineType == 'dotted') {
                var dashLength = (style.lineWidth || 1) * (style.lineType == 'dashed' ? 5 : 1);
                dashedLineTo(ctx, style.xStart, style.yStart, style.xEnd, style.yEnd, dashLength);
            }
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            var lineWidth = style.lineWidth || 1;
            style.__rect = {
                x: Math.min(style.xStart, style.xEnd) - lineWidth,
                y: Math.min(style.yStart, style.yEnd) - lineWidth,
                width: Math.abs(style.xStart - style.xEnd) + lineWidth,
                height: Math.abs(style.yStart - style.yEnd) + lineWidth
            };
            return style.__rect;
        }
    };
    require('../tool/util').inherits(Line, Base);
    return Line;
});define('zrender/shape/BezierCurve', [
    'require',
    './Base',
    '../tool/util'
], function (require) {
    'use strict';
    var Base = require('./Base');
    var BezierCurve = function (options) {
        this.brushTypeOnly = 'stroke';
        this.textPosition = 'end';
        Base.call(this, options);
    };
    BezierCurve.prototype = {
        type: 'bezier-curve',
        buildPath: function (ctx, style) {
            ctx.moveTo(style.xStart, style.yStart);
            if (typeof style.cpX2 != 'undefined' && typeof style.cpY2 != 'undefined') {
                ctx.bezierCurveTo(style.cpX1, style.cpY1, style.cpX2, style.cpY2, style.xEnd, style.yEnd);
            } else {
                ctx.quadraticCurveTo(style.cpX1, style.cpY1, style.xEnd, style.yEnd);
            }
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            var _minX = Math.min(style.xStart, style.xEnd, style.cpX1);
            var _minY = Math.min(style.yStart, style.yEnd, style.cpY1);
            var _maxX = Math.max(style.xStart, style.xEnd, style.cpX1);
            var _maxY = Math.max(style.yStart, style.yEnd, style.cpY1);
            var _x2 = style.cpX2;
            var _y2 = style.cpY2;
            if (typeof _x2 != 'undefined' && typeof _y2 != 'undefined') {
                _minX = Math.min(_minX, _x2);
                _minY = Math.min(_minY, _y2);
                _maxX = Math.max(_maxX, _x2);
                _maxY = Math.max(_maxY, _y2);
            }
            var lineWidth = style.lineWidth || 1;
            style.__rect = {
                x: _minX - lineWidth,
                y: _minY - lineWidth,
                width: _maxX - _minX + lineWidth,
                height: _maxY - _minY + lineWidth
            };
            return style.__rect;
        }
    };
    require('../tool/util').inherits(BezierCurve, Base);
    return BezierCurve;
});define('zrender/shape/util/dashedLineTo', [], function () {
    var dashPattern = [
        5,
        5
    ];
    return function (ctx, x1, y1, x2, y2, dashLength) {
        if (ctx.setLineDash) {
            dashPattern[0] = dashPattern[1] = dashLength;
            ctx.setLineDash(dashPattern);
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            return;
        }
        dashLength = typeof dashLength != 'number' ? 5 : dashLength;
        var dx = x2 - x1;
        var dy = y2 - y1;
        var numDashes = Math.floor(Math.sqrt(dx * dx + dy * dy) / dashLength);
        dx = dx / numDashes;
        dy = dy / numDashes;
        var flag = true;
        for (var i = 0; i < numDashes; ++i) {
            if (flag) {
                ctx.moveTo(x1, y1);
            } else {
                ctx.lineTo(x1, y1);
            }
            flag = !flag;
            x1 += dx;
            y1 += dy;
        }
        ctx.lineTo(x2, y2);
    };
});define('zrender/shape/Polygon', [
    'require',
    './Base',
    './util/smoothSpline',
    './util/smoothBezier',
    './util/dashedLineTo',
    '../tool/util'
], function (require) {
    var Base = require('./Base');
    var smoothSpline = require('./util/smoothSpline');
    var smoothBezier = require('./util/smoothBezier');
    var dashedLineTo = require('./util/dashedLineTo');
    var Polygon = function (options) {
        Base.call(this, options);
    };
    Polygon.prototype = {
        type: 'polygon',
        buildPath: function (ctx, style) {
            var pointList = style.pointList;
            if (pointList.length < 2) {
                return;
            }
            if (style.smooth && style.smooth !== 'spline') {
                var controlPoints = smoothBezier(pointList, style.smooth, true, style.smoothConstraint);
                ctx.moveTo(pointList[0][0], pointList[0][1]);
                var cp1;
                var cp2;
                var p;
                var len = pointList.length;
                for (var i = 0; i < len; i++) {
                    cp1 = controlPoints[i * 2];
                    cp2 = controlPoints[i * 2 + 1];
                    p = pointList[(i + 1) % len];
                    ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
                }
            } else {
                if (style.smooth === 'spline') {
                    pointList = smoothSpline(pointList, true);
                }
                if (!style.lineType || style.lineType == 'solid') {
                    ctx.moveTo(pointList[0][0], pointList[0][1]);
                    for (var i = 1, l = pointList.length; i < l; i++) {
                        ctx.lineTo(pointList[i][0], pointList[i][1]);
                    }
                    ctx.lineTo(pointList[0][0], pointList[0][1]);
                } else if (style.lineType == 'dashed' || style.lineType == 'dotted') {
                    var dashLength = style._dashLength || (style.lineWidth || 1) * (style.lineType == 'dashed' ? 5 : 1);
                    style._dashLength = dashLength;
                    ctx.moveTo(pointList[0][0], pointList[0][1]);
                    for (var i = 1, l = pointList.length; i < l; i++) {
                        dashedLineTo(ctx, pointList[i - 1][0], pointList[i - 1][1], pointList[i][0], pointList[i][1], dashLength);
                    }
                    dashedLineTo(ctx, pointList[pointList.length - 1][0], pointList[pointList.length - 1][1], pointList[0][0], pointList[0][1], dashLength);
                }
            }
            ctx.closePath();
            return;
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            var minX = Number.MAX_VALUE;
            var maxX = Number.MIN_VALUE;
            var minY = Number.MAX_VALUE;
            var maxY = Number.MIN_VALUE;
            var pointList = style.pointList;
            for (var i = 0, l = pointList.length; i < l; i++) {
                if (pointList[i][0] < minX) {
                    minX = pointList[i][0];
                }
                if (pointList[i][0] > maxX) {
                    maxX = pointList[i][0];
                }
                if (pointList[i][1] < minY) {
                    minY = pointList[i][1];
                }
                if (pointList[i][1] > maxY) {
                    maxY = pointList[i][1];
                }
            }
            var lineWidth;
            if (style.brushType == 'stroke' || style.brushType == 'fill') {
                lineWidth = style.lineWidth || 1;
            } else {
                lineWidth = 0;
            }
            style.__rect = {
                x: Math.round(minX - lineWidth / 2),
                y: Math.round(minY - lineWidth / 2),
                width: maxX - minX + lineWidth,
                height: maxY - minY + lineWidth
            };
            return style.__rect;
        }
    };
    require('../tool/util').inherits(Polygon, Base);
    return Polygon;
});define('echarts/util/shape/normalIsCover', [], function () {
    return function (x, y) {
        var originPos = this.transformCoordToLocal(x, y);
        x = originPos[0];
        y = originPos[1];
        return this.isCoverRect(x, y);
    };
});define('zrender/shape/util/smoothSpline', [
    'require',
    '../../tool/vector'
], function (require) {
    var vector = require('../../tool/vector');
    function interpolate(p0, p1, p2, p3, t, t2, t3) {
        var v0 = (p2 - p0) * 0.5;
        var v1 = (p3 - p1) * 0.5;
        return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
    }
    return function (points, isLoop, constraint) {
        var len = points.length;
        var ret = [];
        var distance = 0;
        for (var i = 1; i < len; i++) {
            distance += vector.distance(points[i - 1], points[i]);
        }
        var segs = distance / 5;
        segs = segs < len ? len : segs;
        for (var i = 0; i < segs; i++) {
            var pos = i / (segs - 1) * (isLoop ? len : len - 1);
            var idx = Math.floor(pos);
            var w = pos - idx;
            var p0;
            var p1 = points[idx % len];
            var p2;
            var p3;
            if (!isLoop) {
                p0 = points[idx === 0 ? idx : idx - 1];
                p2 = points[idx > len - 2 ? len - 1 : idx + 1];
                p3 = points[idx > len - 3 ? len - 1 : idx + 2];
            } else {
                p0 = points[(idx - 1 + len) % len];
                p2 = points[(idx + 1) % len];
                p3 = points[(idx + 2) % len];
            }
            var w2 = w * w;
            var w3 = w * w2;
            ret.push([
                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),
                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)
            ]);
        }
        return ret;
    };
});define('zrender/shape/util/smoothBezier', [
    'require',
    '../../tool/vector'
], function (require) {
    var vector = require('../../tool/vector');
    return function (points, smooth, isLoop, constraint) {
        var cps = [];
        var v = [];
        var v1 = [];
        var v2 = [];
        var prevPoint;
        var nextPoint;
        var hasConstraint = !!constraint;
        var min, max;
        if (hasConstraint) {
            min = [
                Infinity,
                Infinity
            ];
            max = [
                -Infinity,
                -Infinity
            ];
            for (var i = 0, len = points.length; i < len; i++) {
                vector.min(min, min, points[i]);
                vector.max(max, max, points[i]);
            }
            vector.min(min, min, constraint[0]);
            vector.max(max, max, constraint[1]);
        }
        for (var i = 0, len = points.length; i < len; i++) {
            var point = points[i];
            var prevPoint;
            var nextPoint;
            if (isLoop) {
                prevPoint = points[i ? i - 1 : len - 1];
                nextPoint = points[(i + 1) % len];
            } else {
                if (i === 0 || i === len - 1) {
                    cps.push(vector.clone(points[i]));
                    continue;
                } else {
                    prevPoint = points[i - 1];
                    nextPoint = points[i + 1];
                }
            }
            vector.sub(v, nextPoint, prevPoint);
            vector.scale(v, v, smooth);
            var d0 = vector.distance(point, prevPoint);
            var d1 = vector.distance(point, nextPoint);
            var sum = d0 + d1;
            if (sum !== 0) {
                d0 /= sum;
                d1 /= sum;
            }
            vector.scale(v1, v, -d0);
            vector.scale(v2, v, d1);
            var cp0 = vector.add([], point, v1);
            var cp1 = vector.add([], point, v2);
            if (hasConstraint) {
                vector.max(cp0, cp0, min);
                vector.min(cp0, cp0, max);
                vector.max(cp1, cp1, min);
                vector.min(cp1, cp1, max);
            }
            cps.push(cp0);
            cps.push(cp1);
        }
        if (isLoop) {
            cps.push(vector.clone(cps.shift()));
        }
        return cps;
    };
});define('echarts/util/ecQuery', [
    'require',
    'zrender/tool/util'
], function (require) {
    var zrUtil = require('zrender/tool/util');
    function query(optionTarget, optionLocation) {
        if (typeof optionTarget == 'undefined') {
            return;
        }
        if (!optionLocation) {
            return optionTarget;
        }
        optionLocation = optionLocation.split('.');
        var length = optionLocation.length;
        var curIdx = 0;
        while (curIdx < length) {
            optionTarget = optionTarget[optionLocation[curIdx]];
            if (typeof optionTarget == 'undefined') {
                return;
            }
            curIdx++;
        }
        return optionTarget;
    }
    function deepQuery(ctrList, optionLocation) {
        var finalOption;
        for (var i = 0, l = ctrList.length; i < l; i++) {
            finalOption = query(ctrList[i], optionLocation);
            if (typeof finalOption != 'undefined') {
                return finalOption;
            }
        }
    }
    function deepMerge(ctrList, optionLocation) {
        var finalOption;
        var len = ctrList.length;
        while (len--) {
            var tempOption = query(ctrList[len], optionLocation);
            if (typeof tempOption != 'undefined') {
                if (typeof finalOption == 'undefined') {
                    finalOption = zrUtil.clone(tempOption);
                } else {
                    zrUtil.merge(finalOption, tempOption, true);
                }
            }
        }
        return finalOption;
    }
    return {
        query: query,
        deepQuery: deepQuery,
        deepMerge: deepMerge
    };
});define('echarts/util/number', [], function () {
    function _trim(str) {
        return str.replace(/^\s+/, '').replace(/\s+$/, '');
    }
    function parsePercent(value, maxValue) {
        if (typeof value === 'string') {
            if (_trim(value).match(/%$/)) {
                return parseFloat(value) / 100 * maxValue;
            }
            return parseFloat(value);
        }
        return value;
    }
    function parseCenter(zr, center) {
        return [
            parsePercent(center[0], zr.getWidth()),
            parsePercent(center[1], zr.getHeight())
        ];
    }
    function parseRadius(zr, radius) {
        if (!(radius instanceof Array)) {
            radius = [
                0,
                radius
            ];
        }
        var zrSize = Math.min(zr.getWidth(), zr.getHeight()) / 2;
        return [
            parsePercent(radius[0], zrSize),
            parsePercent(radius[1], zrSize)
        ];
    }
    function addCommas(x) {
        if (isNaN(x)) {
            return '-';
        }
        x = (x + '').split('.');
        return x[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, '$1,') + (x.length > 1 ? '.' + x[1] : '');
    }
    return {
        parsePercent: parsePercent,
        parseCenter: parseCenter,
        parseRadius: parseRadius,
        addCommas: addCommas
    };
});define('echarts/data/KDTree', [
    'require',
    './quickSelect'
], function (require) {
    var quickSelect = require('./quickSelect');
    function Node(axis, data) {
        this.left = null;
        this.right = null;
        this.axis = axis;
        this.data = data;
    }
    var KDTree = function (points, dimension) {
        if (!points.length) {
            return;
        }
        if (!dimension) {
            dimension = points[0].array.length;
        }
        this.dimension = dimension;
        this.root = this._buildTree(points, 0, points.length - 1, 0);
        this._stack = [];
        this._nearstNList = [];
    };
    KDTree.prototype._buildTree = function (points, left, right, axis) {
        if (right < left) {
            return null;
        }
        var medianIndex = Math.floor((left + right) / 2);
        medianIndex = quickSelect(points, left, right, medianIndex, function (a, b) {
            return a.array[axis] - b.array[axis];
        });
        var median = points[medianIndex];
        var node = new Node(axis, median);
        axis = (axis + 1) % this.dimension;
        if (right > left) {
            node.left = this._buildTree(points, left, medianIndex - 1, axis);
            node.right = this._buildTree(points, medianIndex + 1, right, axis);
        }
        return node;
    };
    KDTree.prototype.nearest = function (target, squaredDistance) {
        var curr = this.root;
        var stack = this._stack;
        var idx = 0;
        var minDist = Infinity;
        var nearestNode = null;
        if (curr.data !== target) {
            minDist = squaredDistance(curr.data, target);
            nearestNode = curr;
        }
        if (target.array[curr.axis] < curr.data.array[curr.axis]) {
            curr.right && (stack[idx++] = curr.right);
            curr.left && (stack[idx++] = curr.left);
        } else {
            curr.left && (stack[idx++] = curr.left);
            curr.right && (stack[idx++] = curr.right);
        }
        while (idx--) {
            curr = stack[idx];
            var currDist = target.array[curr.axis] - curr.data.array[curr.axis];
            var isLeft = currDist < 0;
            var needsCheckOtherSide = false;
            currDist = currDist * currDist;
            if (currDist < minDist) {
                currDist = squaredDistance(curr.data, target);
                if (currDist < minDist && curr.data !== target) {
                    minDist = currDist;
                    nearestNode = curr;
                }
                needsCheckOtherSide = true;
            }
            if (isLeft) {
                if (needsCheckOtherSide) {
                    curr.right && (stack[idx++] = curr.right);
                }
                curr.left && (stack[idx++] = curr.left);
            } else {
                if (needsCheckOtherSide) {
                    curr.left && (stack[idx++] = curr.left);
                }
                curr.right && (stack[idx++] = curr.right);
            }
        }
        return nearestNode.data;
    };
    KDTree.prototype._addNearest = function (found, dist, node) {
        var nearestNList = this._nearstNList;
        for (var i = found - 1; i > 0; i--) {
            if (dist >= nearestNList[i - 1].dist) {
                break;
            } else {
                nearestNList[i].dist = nearestNList[i - 1].dist;
                nearestNList[i].node = nearestNList[i - 1].node;
            }
        }
        nearestNList[i].dist = dist;
        nearestNList[i].node = node;
    };
    KDTree.prototype.nearestN = function (target, N, squaredDistance, output) {
        if (N <= 0) {
            output.length = 0;
            return output;
        }
        var curr = this.root;
        var stack = this._stack;
        var idx = 0;
        var nearestNList = this._nearstNList;
        for (var i = 0; i < N; i++) {
            if (!nearestNList[i]) {
                nearestNList[i] = {};
            }
            nearestNList[i].dist = 0;
            nearestNList[i].node = null;
        }
        var currDist = squaredDistance(curr.data, target);
        var found = 0;
        if (curr.data !== target) {
            found++;
            this._addNearest(found, currDist, curr);
        }
        if (target.array[curr.axis] < curr.data.array[curr.axis]) {
            curr.right && (stack[idx++] = curr.right);
            curr.left && (stack[idx++] = curr.left);
        } else {
            curr.left && (stack[idx++] = curr.left);
            curr.right && (stack[idx++] = curr.right);
        }
        while (idx--) {
            curr = stack[idx];
            var currDist = target.array[curr.axis] - curr.data.array[curr.axis];
            var isLeft = currDist < 0;
            var needsCheckOtherSide = false;
            currDist = currDist * currDist;
            if (found < N || currDist < nearestNList[found - 1].dist) {
                currDist = squaredDistance(curr.data, target);
                if ((found < N || currDist < nearestNList[found - 1].dist) && curr.data !== target) {
                    if (found < N) {
                        found++;
                    }
                    this._addNearest(found, currDist, curr);
                }
                needsCheckOtherSide = true;
            }
            if (isLeft) {
                if (needsCheckOtherSide) {
                    curr.right && (stack[idx++] = curr.right);
                }
                curr.left && (stack[idx++] = curr.left);
            } else {
                if (needsCheckOtherSide) {
                    curr.left && (stack[idx++] = curr.left);
                }
                curr.right && (stack[idx++] = curr.right);
            }
        }
        for (var i = 0; i < found; i++) {
            output[i] = nearestNList[i].node.data;
        }
        output.length = found;
        return output;
    };
    return KDTree;
});define('echarts/data/quickSelect', ['require'], function (require) {
    function defaultCompareFunc(a, b) {
        return a - b;
    }
    function swapElement(list, idx0, idx1) {
        var tmp = list[idx0];
        list[idx0] = list[idx1];
        list[idx1] = tmp;
    }
    function select(list, left, right, nth, compareFunc) {
        var pivotIdx = left;
        while (right > left) {
            var pivotIdx = Math.round((right + left) / 2);
            var pivotValue = list[pivotIdx];
            swapElement(list, pivotIdx, right);
            pivotIdx = left;
            for (var i = left; i <= right - 1; i++) {
                if (compareFunc(pivotValue, list[i]) >= 0) {
                    swapElement(list, i, pivotIdx);
                    pivotIdx++;
                }
            }
            swapElement(list, right, pivotIdx);
            if (pivotIdx === nth) {
                return pivotIdx;
            } else if (pivotIdx < nth) {
                left = pivotIdx + 1;
            } else {
                right = pivotIdx - 1;
            }
        }
        return left;
    }
    function quickSelect(list, left, right, nth, compareFunc) {
        if (arguments.length <= 3) {
            nth = left;
            if (arguments.length == 2) {
                compareFunc = defaultCompareFunc;
            } else {
                compareFunc = right;
            }
            left = 0;
            right = list.length - 1;
        }
        return select(list, left, right, nth, compareFunc);
    }
    return quickSelect;
});define('echarts/component/dataView', [
    'require',
    './base',
    '../config',
    'zrender/tool/util',
    '../component'
], function (require) {
    var Base = require('./base');
    var ecConfig = require('../config');
    var zrUtil = require('zrender/tool/util');
    function DataView(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.dom = myChart.dom;
        this._tDom = document.createElement('div');
        this._textArea = document.createElement('textArea');
        this._buttonRefresh = document.createElement('button');
        this._buttonClose = document.createElement('button');
        this._hasShow = false;
        this._zrHeight = zr.getHeight();
        this._zrWidth = zr.getWidth();
        this._tDom.className = 'echarts-dataview';
        this.hide();
        this.dom.firstChild.appendChild(this._tDom);
        if (window.addEventListener) {
            this._tDom.addEventListener('click', this._stop);
            this._tDom.addEventListener('mousewheel', this._stop);
            this._tDom.addEventListener('mousemove', this._stop);
            this._tDom.addEventListener('mousedown', this._stop);
            this._tDom.addEventListener('mouseup', this._stop);
            this._tDom.addEventListener('touchstart', this._stop);
            this._tDom.addEventListener('touchmove', this._stop);
            this._tDom.addEventListener('touchend', this._stop);
        } else {
            this._tDom.attachEvent('onclick', this._stop);
            this._tDom.attachEvent('onmousewheel', this._stop);
            this._tDom.attachEvent('onmousemove', this._stop);
            this._tDom.attachEvent('onmousedown', this._stop);
            this._tDom.attachEvent('onmouseup', this._stop);
        }
    }
    DataView.prototype = {
        type: ecConfig.COMPONENT_TYPE_DATAVIEW,
        _lang: [
            'Data View',
            'close',
            'refresh'
        ],
        _gCssText: 'position:absolute;' + 'display:block;' + 'overflow:hidden;' + 'transition:height 0.8s,background-color 1s;' + '-moz-transition:height 0.8s,background-color 1s;' + '-webkit-transition:height 0.8s,background-color 1s;' + '-o-transition:height 0.8s,background-color 1s;' + 'z-index:1;' + 'left:0;' + 'top:0;',
        hide: function () {
            this._sizeCssText = 'width:' + this._zrWidth + 'px;' + 'height:' + 0 + 'px;' + 'background-color:#f0ffff;';
            this._tDom.style.cssText = this._gCssText + this._sizeCssText;
        },
        show: function (newOption) {
            this._hasShow = true;
            var lang = this.query(this.option, 'toolbox.feature.dataView.lang') || this._lang;
            this.option = newOption;
            this._tDom.innerHTML = '<p style="padding:8px 0;margin:0 0 10px 0;' + 'border-bottom:1px solid #eee">' + (lang[0] || this._lang[0]) + '</p>';
            var customContent = this.query(this.option, 'toolbox.feature.dataView.optionToContent');
            if (typeof customContent != 'function') {
                this._textArea.value = this._optionToContent();
            } else {
                this._textArea = document.createElement('div');
                this._textArea.innerHTML = customContent(this.option);
            }
            this._textArea.style.cssText = 'display:block;margin:0 0 8px 0;padding:4px 6px;overflow:auto;' + 'width:100%;' + 'height:' + (this._zrHeight - 100) + 'px;';
            this._tDom.appendChild(this._textArea);
            this._buttonClose.style.cssText = 'float:right;padding:1px 6px;';
            this._buttonClose.innerHTML = lang[1] || this._lang[1];
            var self = this;
            this._buttonClose.onclick = function () {
                self.hide();
            };
            this._tDom.appendChild(this._buttonClose);
            if (this.query(this.option, 'toolbox.feature.dataView.readOnly') === false) {
                this._buttonRefresh.style.cssText = 'float:right;margin-right:10px;padding:1px 6px;';
                this._buttonRefresh.innerHTML = lang[2] || this._lang[2];
                this._buttonRefresh.onclick = function () {
                    self._save();
                };
                this._textArea.readOnly = false;
                this._textArea.style.cursor = 'default';
            } else {
                this._buttonRefresh.style.cssText = 'display:none';
                this._textArea.readOnly = true;
                this._textArea.style.cursor = 'text';
            }
            this._tDom.appendChild(this._buttonRefresh);
            this._sizeCssText = 'width:' + this._zrWidth + 'px;' + 'height:' + this._zrHeight + 'px;' + 'background-color:#fff;';
            this._tDom.style.cssText = this._gCssText + this._sizeCssText;
        },
        _optionToContent: function () {
            var i;
            var j;
            var k;
            var len;
            var data;
            var valueList;
            var axisList = [];
            var content = '';
            if (this.option.xAxis) {
                if (this.option.xAxis instanceof Array) {
                    axisList = this.option.xAxis;
                } else {
                    axisList = [this.option.xAxis];
                }
                for (i = 0, len = axisList.length; i < len; i++) {
                    if ((axisList[i].type || 'category') == 'category') {
                        valueList = [];
                        for (j = 0, k = axisList[i].data.length; j < k; j++) {
                            valueList.push(this.getDataFromOption(axisList[i].data[j]));
                        }
                        content += valueList.join(', ') + '\n\n';
                    }
                }
            }
            if (this.option.yAxis) {
                if (this.option.yAxis instanceof Array) {
                    axisList = this.option.yAxis;
                } else {
                    axisList = [this.option.yAxis];
                }
                for (i = 0, len = axisList.length; i < len; i++) {
                    if (axisList[i].type == 'category') {
                        valueList = [];
                        for (j = 0, k = axisList[i].data.length; j < k; j++) {
                            valueList.push(this.getDataFromOption(axisList[i].data[j]));
                        }
                        content += valueList.join(', ') + '\n\n';
                    }
                }
            }
            var series = this.option.series;
            var itemName;
            for (i = 0, len = series.length; i < len; i++) {
                valueList = [];
                for (j = 0, k = series[i].data.length; j < k; j++) {
                    data = series[i].data[j];
                    if (series[i].type == ecConfig.CHART_TYPE_PIE || series[i].type == ecConfig.CHART_TYPE_MAP) {
                        itemName = (data.name || '-') + ':';
                    } else {
                        itemName = '';
                    }
                    if (series[i].type == ecConfig.CHART_TYPE_SCATTER) {
                        data = this.getDataFromOption(data).join(', ');
                    }
                    valueList.push(itemName + this.getDataFromOption(data));
                }
                content += (series[i].name || '-') + ' : \n';
                content += valueList.join(series[i].type == ecConfig.CHART_TYPE_SCATTER ? '\n' : ', ');
                content += '\n\n';
            }
            return content;
        },
        _save: function () {
            var customContent = this.query(this.option, 'toolbox.feature.dataView.contentToOption');
            if (typeof customContent != 'function') {
                var text = this._textArea.value.split('\n');
                var content = [];
                for (var i = 0, l = text.length; i < l; i++) {
                    text[i] = this._trim(text[i]);
                    if (text[i] !== '') {
                        content.push(text[i]);
                    }
                }
                this._contentToOption(content);
            } else {
                customContent(this._textArea, this.option);
            }
            this.hide();
            var self = this;
            setTimeout(function () {
                self.messageCenter && self.messageCenter.dispatch(ecConfig.EVENT.DATA_VIEW_CHANGED, null, { option: self.option }, self.myChart);
            }, self.canvasSupported ? 800 : 100);
        },
        _contentToOption: function (content) {
            var i;
            var j;
            var k;
            var len;
            var data;
            var axisList = [];
            var contentIdx = 0;
            var contentValueList;
            var value;
            if (this.option.xAxis) {
                if (this.option.xAxis instanceof Array) {
                    axisList = this.option.xAxis;
                } else {
                    axisList = [this.option.xAxis];
                }
                for (i = 0, len = axisList.length; i < len; i++) {
                    if ((axisList[i].type || 'category') == 'category') {
                        contentValueList = content[contentIdx].split(',');
                        for (j = 0, k = axisList[i].data.length; j < k; j++) {
                            value = this._trim(contentValueList[j] || '');
                            data = axisList[i].data[j];
                            if (typeof axisList[i].data[j].value != 'undefined') {
                                axisList[i].data[j].value = value;
                            } else {
                                axisList[i].data[j] = value;
                            }
                        }
                        contentIdx++;
                    }
                }
            }
            if (this.option.yAxis) {
                if (this.option.yAxis instanceof Array) {
                    axisList = this.option.yAxis;
                } else {
                    axisList = [this.option.yAxis];
                }
                for (i = 0, len = axisList.length; i < len; i++) {
                    if (axisList[i].type == 'category') {
                        contentValueList = content[contentIdx].split(',');
                        for (j = 0, k = axisList[i].data.length; j < k; j++) {
                            value = this._trim(contentValueList[j] || '');
                            data = axisList[i].data[j];
                            if (typeof axisList[i].data[j].value != 'undefined') {
                                axisList[i].data[j].value = value;
                            } else {
                                axisList[i].data[j] = value;
                            }
                        }
                        contentIdx++;
                    }
                }
            }
            var series = this.option.series;
            for (i = 0, len = series.length; i < len; i++) {
                contentIdx++;
                if (series[i].type == ecConfig.CHART_TYPE_SCATTER) {
                    for (var j = 0, k = series[i].data.length; j < k; j++) {
                        contentValueList = content[contentIdx];
                        value = contentValueList.replace(' ', '').split(',');
                        if (typeof series[i].data[j].value != 'undefined') {
                            series[i].data[j].value = value;
                        } else {
                            series[i].data[j] = value;
                        }
                        contentIdx++;
                    }
                } else {
                    contentValueList = content[contentIdx].split(',');
                    for (var j = 0, k = series[i].data.length; j < k; j++) {
                        value = (contentValueList[j] || '').replace(/.*:/, '');
                        value = this._trim(value);
                        value = value != '-' && value !== '' ? value - 0 : '-';
                        if (typeof series[i].data[j].value != 'undefined') {
                            series[i].data[j].value = value;
                        } else {
                            series[i].data[j] = value;
                        }
                    }
                    contentIdx++;
                }
            }
        },
        _trim: function (str) {
            var trimer = new RegExp('(^[\\s\\t\\xa0\\u3000]+)|([\\u3000\\xa0\\s\\t]+$)', 'g');
            return str.replace(trimer, '');
        },
        _stop: function (e) {
            e = e || window.event;
            if (e.stopPropagation) {
                e.stopPropagation();
            } else {
                e.cancelBubble = true;
            }
        },
        resize: function () {
            this._zrHeight = this.zr.getHeight();
            this._zrWidth = this.zr.getWidth();
            if (this._tDom.offsetHeight > 10) {
                this._sizeCssText = 'width:' + this._zrWidth + 'px;' + 'height:' + this._zrHeight + 'px;' + 'background-color:#fff;';
                this._tDom.style.cssText = this._gCssText + this._sizeCssText;
                this._textArea.style.cssText = 'display:block;margin:0 0 8px 0;' + 'padding:4px 6px;overflow:auto;' + 'width:100%;' + 'height:' + (this._zrHeight - 100) + 'px;';
            }
        },
        dispose: function () {
            if (window.removeEventListener) {
                this._tDom.removeEventListener('click', this._stop);
                this._tDom.removeEventListener('mousewheel', this._stop);
                this._tDom.removeEventListener('mousemove', this._stop);
                this._tDom.removeEventListener('mousedown', this._stop);
                this._tDom.removeEventListener('mouseup', this._stop);
                this._tDom.removeEventListener('touchstart', this._stop);
                this._tDom.removeEventListener('touchmove', this._stop);
                this._tDom.removeEventListener('touchend', this._stop);
            } else {
                this._tDom.detachEvent('onclick', this._stop);
                this._tDom.detachEvent('onmousewheel', this._stop);
                this._tDom.detachEvent('onmousemove', this._stop);
                this._tDom.detachEvent('onmousedown', this._stop);
                this._tDom.detachEvent('onmouseup', this._stop);
            }
            this._buttonRefresh.onclick = null;
            this._buttonClose.onclick = null;
            if (this._hasShow) {
                this._tDom.removeChild(this._textArea);
                this._tDom.removeChild(this._buttonRefresh);
                this._tDom.removeChild(this._buttonClose);
            }
            this._textArea = null;
            this._buttonRefresh = null;
            this._buttonClose = null;
            this.dom.firstChild.removeChild(this._tDom);
            this._tDom = null;
        }
    };
    zrUtil.inherits(DataView, Base);
    require('../component').define('dataView', DataView);
    return DataView;
});define('echarts/util/shape/Cross', [
    'require',
    'zrender/shape/Base',
    'zrender/shape/Line',
    'zrender/tool/util',
    './normalIsCover'
], function (require) {
    var Base = require('zrender/shape/Base');
    var LineShape = require('zrender/shape/Line');
    var zrUtil = require('zrender/tool/util');
    function Cross(options) {
        Base.call(this, options);
    }
    Cross.prototype = {
        type: 'cross',
        buildPath: function (ctx, style) {
            var rect = style.rect;
            style.xStart = rect.x;
            style.xEnd = rect.x + rect.width;
            style.yStart = style.yEnd = style.y;
            LineShape.prototype.buildPath(ctx, style);
            style.xStart = style.xEnd = style.x;
            style.yStart = rect.y;
            style.yEnd = rect.y + rect.height;
            LineShape.prototype.buildPath(ctx, style);
        },
        getRect: function (style) {
            return style.rect;
        },
        isCover: require('./normalIsCover')
    };
    zrUtil.inherits(Cross, Base);
    return Cross;
});define('zrender/shape/Sector', [
    'require',
    '../tool/math',
    '../tool/computeBoundingBox',
    '../tool/vector',
    './Base',
    '../tool/util'
], function (require) {
    var math = require('../tool/math');
    var computeBoundingBox = require('../tool/computeBoundingBox');
    var vec2 = require('../tool/vector');
    var Base = require('./Base');
    var min0 = vec2.create();
    var min1 = vec2.create();
    var max0 = vec2.create();
    var max1 = vec2.create();
    var Sector = function (options) {
        Base.call(this, options);
    };
    Sector.prototype = {
        type: 'sector',
        buildPath: function (ctx, style) {
            var x = style.x;
            var y = style.y;
            var r0 = style.r0 || 0;
            var r = style.r;
            var startAngle = style.startAngle;
            var endAngle = style.endAngle;
            var clockWise = style.clockWise || false;
            startAngle = math.degreeToRadian(startAngle);
            endAngle = math.degreeToRadian(endAngle);
            if (!clockWise) {
                startAngle = -startAngle;
                endAngle = -endAngle;
            }
            var unitX = math.cos(startAngle);
            var unitY = math.sin(startAngle);
            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
            ctx.lineTo(unitX * r + x, unitY * r + y);
            ctx.arc(x, y, r, startAngle, endAngle, !clockWise);
            ctx.lineTo(math.cos(endAngle) * r0 + x, math.sin(endAngle) * r0 + y);
            if (r0 !== 0) {
                ctx.arc(x, y, r0, endAngle, startAngle, clockWise);
            }
            ctx.closePath();
            return;
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            var x = style.x;
            var y = style.y;
            var r0 = style.r0 || 0;
            var r = style.r;
            var startAngle = math.degreeToRadian(style.startAngle);
            var endAngle = math.degreeToRadian(style.endAngle);
            var clockWise = style.clockWise;
            if (!clockWise) {
                startAngle = -startAngle;
                endAngle = -endAngle;
            }
            if (r0 > 1) {
                computeBoundingBox.arc(x, y, r0, startAngle, endAngle, !clockWise, min0, max0);
            } else {
                min0[0] = max0[0] = x;
                min0[1] = max0[1] = y;
            }
            computeBoundingBox.arc(x, y, r, startAngle, endAngle, !clockWise, min1, max1);
            vec2.min(min0, min0, min1);
            vec2.max(max0, max0, max1);
            style.__rect = {
                x: min0[0],
                y: min0[1],
                width: max0[0] - min0[0],
                height: max0[1] - min0[1]
            };
            return style.__rect;
        }
    };
    require('../tool/util').inherits(Sector, Base);
    return Sector;
});define('echarts/util/shape/Candle', [
    'require',
    'zrender/shape/Base',
    'zrender/tool/util',
    './normalIsCover'
], function (require) {
    var Base = require('zrender/shape/Base');
    var zrUtil = require('zrender/tool/util');
    function Candle(options) {
        Base.call(this, options);
    }
    Candle.prototype = {
        type: 'candle',
        _numberOrder: function (a, b) {
            return b - a;
        },
        buildPath: function (ctx, style) {
            var yList = zrUtil.clone(style.y).sort(this._numberOrder);
            ctx.moveTo(style.x, yList[3]);
            ctx.lineTo(style.x, yList[2]);
            ctx.moveTo(style.x - style.width / 2, yList[2]);
            ctx.rect(style.x - style.width / 2, yList[2], style.width, yList[1] - yList[2]);
            ctx.moveTo(style.x, yList[1]);
            ctx.lineTo(style.x, yList[0]);
        },
        getRect: function (style) {
            if (!style.__rect) {
                var lineWidth = 0;
                if (style.brushType == 'stroke' || style.brushType == 'fill') {
                    lineWidth = style.lineWidth || 1;
                }
                var yList = zrUtil.clone(style.y).sort(this._numberOrder);
                style.__rect = {
                    x: Math.round(style.x - style.width / 2 - lineWidth / 2),
                    y: Math.round(yList[3] - lineWidth / 2),
                    width: style.width + lineWidth,
                    height: yList[0] - yList[3] + lineWidth
                };
            }
            return style.__rect;
        },
        isCover: require('./normalIsCover')
    };
    zrUtil.inherits(Candle, Base);
    return Candle;
});define('zrender/tool/computeBoundingBox', [
    'require',
    './vector',
    './curve'
], function (require) {
    var vec2 = require('./vector');
    var curve = require('./curve');
    function computeBoundingBox(points, min, max) {
        if (points.length === 0) {
            return;
        }
        var left = points[0][0];
        var right = points[0][0];
        var top = points[0][1];
        var bottom = points[0][1];
        for (var i = 1; i < points.length; i++) {
            var p = points[i];
            if (p[0] < left) {
                left = p[0];
            }
            if (p[0] > right) {
                right = p[0];
            }
            if (p[1] < top) {
                top = p[1];
            }
            if (p[1] > bottom) {
                bottom = p[1];
            }
        }
        min[0] = left;
        min[1] = top;
        max[0] = right;
        max[1] = bottom;
    }
    function computeCubeBezierBoundingBox(p0, p1, p2, p3, min, max) {
        var xDim = [];
        curve.cubicExtrema(p0[0], p1[0], p2[0], p3[0], xDim);
        for (var i = 0; i < xDim.length; i++) {
            xDim[i] = curve.cubicAt(p0[0], p1[0], p2[0], p3[0], xDim[i]);
        }
        var yDim = [];
        curve.cubicExtrema(p0[1], p1[1], p2[1], p3[1], yDim);
        for (var i = 0; i < yDim.length; i++) {
            yDim[i] = curve.cubicAt(p0[1], p1[1], p2[1], p3[1], yDim[i]);
        }
        xDim.push(p0[0], p3[0]);
        yDim.push(p0[1], p3[1]);
        var left = Math.min.apply(null, xDim);
        var right = Math.max.apply(null, xDim);
        var top = Math.min.apply(null, yDim);
        var bottom = Math.max.apply(null, yDim);
        min[0] = left;
        min[1] = top;
        max[0] = right;
        max[1] = bottom;
    }
    function computeQuadraticBezierBoundingBox(p0, p1, p2, min, max) {
        var t1 = curve.quadraticExtremum(p0[0], p1[0], p2[0]);
        var t2 = curve.quadraticExtremum(p0[1], p1[1], p2[1]);
        t1 = Math.max(Math.min(t1, 1), 0);
        t2 = Math.max(Math.min(t2, 1), 0);
        var ct1 = 1 - t1;
        var ct2 = 1 - t2;
        var x1 = ct1 * ct1 * p0[0] + 2 * ct1 * t1 * p1[0] + t1 * t1 * p2[0];
        var y1 = ct1 * ct1 * p0[1] + 2 * ct1 * t1 * p1[1] + t1 * t1 * p2[1];
        var x2 = ct2 * ct2 * p0[0] + 2 * ct2 * t2 * p1[0] + t2 * t2 * p2[0];
        var y2 = ct2 * ct2 * p0[1] + 2 * ct2 * t2 * p1[1] + t2 * t2 * p2[1];
        min[0] = Math.min(p0[0], p2[0], x1, x2);
        min[1] = Math.min(p0[1], p2[1], y1, y2);
        max[0] = Math.max(p0[0], p2[0], x1, x2);
        max[1] = Math.max(p0[1], p2[1], y1, y2);
    }
    var start = vec2.create();
    var end = vec2.create();
    var extremity = vec2.create();
    var computeArcBoundingBox = function (x, y, r, startAngle, endAngle, anticlockwise, min, max) {
        if (Math.abs(startAngle - endAngle) >= Math.PI * 2) {
            min[0] = x - r;
            min[1] = y - r;
            max[0] = x + r;
            max[1] = y + r;
            return;
        }
        start[0] = Math.cos(startAngle) * r + x;
        start[1] = Math.sin(startAngle) * r + y;
        end[0] = Math.cos(endAngle) * r + x;
        end[1] = Math.sin(endAngle) * r + y;
        vec2.min(min, start, end);
        vec2.max(max, start, end);
        startAngle = startAngle % (Math.PI * 2);
        if (startAngle < 0) {
            startAngle = startAngle + Math.PI * 2;
        }
        endAngle = endAngle % (Math.PI * 2);
        if (endAngle < 0) {
            endAngle = endAngle + Math.PI * 2;
        }
        if (startAngle > endAngle && !anticlockwise) {
            endAngle += Math.PI * 2;
        } else if (startAngle < endAngle && anticlockwise) {
            startAngle += Math.PI * 2;
        }
        if (anticlockwise) {
            var tmp = endAngle;
            endAngle = startAngle;
            startAngle = tmp;
        }
        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
            if (angle > startAngle) {
                extremity[0] = Math.cos(angle) * r + x;
                extremity[1] = Math.sin(angle) * r + y;
                vec2.min(min, extremity, min);
                vec2.max(max, extremity, max);
            }
        }
    };
    computeBoundingBox.cubeBezier = computeCubeBezierBoundingBox;
    computeBoundingBox.quadraticBezier = computeQuadraticBezierBoundingBox;
    computeBoundingBox.arc = computeArcBoundingBox;
    return computeBoundingBox;
});define('echarts/util/shape/Chain', [
    'require',
    'zrender/shape/Base',
    './Icon',
    'zrender/shape/util/dashedLineTo',
    'zrender/tool/util',
    'zrender/tool/matrix'
], function (require) {
    var Base = require('zrender/shape/Base');
    var IconShape = require('./Icon');
    var dashedLineTo = require('zrender/shape/util/dashedLineTo');
    var zrUtil = require('zrender/tool/util');
    var matrix = require('zrender/tool/matrix');
    function Chain(options) {
        Base.call(this, options);
    }
    Chain.prototype = {
        type: 'chain',
        brush: function (ctx, isHighlight) {
            var style = this.style;
            if (isHighlight) {
                style = this.getHighlightStyle(style, this.highlightStyle || {});
            }
            ctx.save();
            this.setContext(ctx, style);
            this.setTransform(ctx);
            ctx.save();
            ctx.beginPath();
            this.buildLinePath(ctx, style);
            ctx.stroke();
            ctx.restore();
            this.brushSymbol(ctx, style);
            ctx.restore();
            return;
        },
        buildLinePath: function (ctx, style) {
            var x = style.x;
            var y = style.y + 5;
            var width = style.width;
            var height = style.height / 2 - 10;
            ctx.moveTo(x, y);
            ctx.lineTo(x, y + height);
            ctx.moveTo(x + width, y);
            ctx.lineTo(x + width, y + height);
            ctx.moveTo(x, y + height / 2);
            if (!style.lineType || style.lineType == 'solid') {
                ctx.lineTo(x + width, y + height / 2);
            } else if (style.lineType == 'dashed' || style.lineType == 'dotted') {
                var dashLength = (style.lineWidth || 1) * (style.lineType == 'dashed' ? 5 : 1);
                dashedLineTo(ctx, x, y + height / 2, x + width, y + height / 2, dashLength);
            }
        },
        brushSymbol: function (ctx, style) {
            var y = style.y + style.height / 4;
            ctx.save();
            var chainPoint = style.chainPoint;
            var curPoint;
            for (var idx = 0, l = chainPoint.length; idx < l; idx++) {
                curPoint = chainPoint[idx];
                if (curPoint.symbol != 'none') {
                    ctx.beginPath();
                    var symbolSize = curPoint.symbolSize;
                    IconShape.prototype.buildPath(ctx, {
                        iconType: curPoint.symbol,
                        x: curPoint.x - symbolSize,
                        y: y - symbolSize,
                        width: symbolSize * 2,
                        height: symbolSize * 2,
                        n: curPoint.n
                    });
                    ctx.fillStyle = curPoint.isEmpty ? '#fff' : style.strokeColor;
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
                if (curPoint.showLabel) {
                    ctx.font = curPoint.textFont;
                    ctx.fillStyle = curPoint.textColor;
                    ctx.textAlign = curPoint.textAlign;
                    ctx.textBaseline = curPoint.textBaseline;
                    if (curPoint.rotation) {
                        ctx.save();
                        this._updateTextTransform(ctx, curPoint.rotation);
                        ctx.fillText(curPoint.name, curPoint.textX, curPoint.textY);
                        ctx.restore();
                    } else {
                        ctx.fillText(curPoint.name, curPoint.textX, curPoint.textY);
                    }
                }
            }
            ctx.restore();
        },
        _updateTextTransform: function (ctx, rotation) {
            var _transform = matrix.create();
            matrix.identity(_transform);
            if (rotation[0] !== 0) {
                var originX = rotation[1] || 0;
                var originY = rotation[2] || 0;
                if (originX || originY) {
                    matrix.translate(_transform, _transform, [
                        -originX,
                        -originY
                    ]);
                }
                matrix.rotate(_transform, _transform, rotation[0]);
                if (originX || originY) {
                    matrix.translate(_transform, _transform, [
                        originX,
                        originY
                    ]);
                }
            }
            ctx.transform.apply(ctx, _transform);
        },
        isCover: function (x, y) {
            var rect = this.style;
            if (x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height) {
                return true;
            } else {
                return false;
            }
        }
    };
    zrUtil.inherits(Chain, Base);
    return Chain;
});define('zrender/shape/Ring', [
    'require',
    './Base',
    '../tool/util'
], function (require) {
    var Base = require('./Base');
    var Ring = function (options) {
        Base.call(this, options);
    };
    Ring.prototype = {
        type: 'ring',
        buildPath: function (ctx, style) {
            ctx.arc(style.x, style.y, style.r, 0, Math.PI * 2, false);
            ctx.moveTo(style.x + style.r0, style.y);
            ctx.arc(style.x, style.y, style.r0, 0, Math.PI * 2, true);
            return;
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            var lineWidth;
            if (style.brushType == 'stroke' || style.brushType == 'fill') {
                lineWidth = style.lineWidth || 1;
            } else {
                lineWidth = 0;
            }
            style.__rect = {
                x: Math.round(style.x - style.r - lineWidth / 2),
                y: Math.round(style.y - style.r - lineWidth / 2),
                width: style.r * 2 + lineWidth,
                height: style.r * 2 + lineWidth
            };
            return style.__rect;
        }
    };
    require('../tool/util').inherits(Ring, Base);
    return Ring;
});define('echarts/component/axis', [
    'require',
    './base',
    'zrender/shape/Line',
    '../config',
    '../util/ecData',
    'zrender/tool/util',
    'zrender/tool/color',
    './categoryAxis',
    './valueAxis',
    '../component'
], function (require) {
    var Base = require('./base');
    var LineShape = require('zrender/shape/Line');
    var ecConfig = require('../config');
    var ecData = require('../util/ecData');
    var zrUtil = require('zrender/tool/util');
    var zrColor = require('zrender/tool/color');
    function Axis(ecTheme, messageCenter, zr, option, myChart, axisType) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.axisType = axisType;
        this._axisList = [];
        this.refresh(option);
    }
    Axis.prototype = {
        type: ecConfig.COMPONENT_TYPE_AXIS,
        axisBase: {
            _buildAxisLine: function () {
                var lineWidth = this.option.axisLine.lineStyle.width;
                var halfLineWidth = lineWidth / 2;
                var axShape = {
                    _axisShape: 'axisLine',
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase() + 3,
                    hoverable: false
                };
                var grid = this.grid;
                switch (this.option.position) {
                case 'left':
                    axShape.style = {
                        xStart: grid.getX() - halfLineWidth,
                        yStart: grid.getYend(),
                        xEnd: grid.getX() - halfLineWidth,
                        yEnd: grid.getY(),
                        lineCap: 'round'
                    };
                    break;
                case 'right':
                    axShape.style = {
                        xStart: grid.getXend() + halfLineWidth,
                        yStart: grid.getYend(),
                        xEnd: grid.getXend() + halfLineWidth,
                        yEnd: grid.getY(),
                        lineCap: 'round'
                    };
                    break;
                case 'bottom':
                    axShape.style = {
                        xStart: grid.getX(),
                        yStart: grid.getYend() + halfLineWidth,
                        xEnd: grid.getXend(),
                        yEnd: grid.getYend() + halfLineWidth,
                        lineCap: 'round'
                    };
                    break;
                case 'top':
                    axShape.style = {
                        xStart: grid.getX(),
                        yStart: grid.getY() - halfLineWidth,
                        xEnd: grid.getXend(),
                        yEnd: grid.getY() - halfLineWidth,
                        lineCap: 'round'
                    };
                    break;
                }
                var style = axShape.style;
                if (this.option.name !== '') {
                    style.text = this.option.name;
                    style.textPosition = this.option.nameLocation;
                    style.textFont = this.getFont(this.option.nameTextStyle);
                    if (this.option.nameTextStyle.align) {
                        style.textAlign = this.option.nameTextStyle.align;
                    }
                    if (this.option.nameTextStyle.baseline) {
                        style.textBaseline = this.option.nameTextStyle.baseline;
                    }
                    if (this.option.nameTextStyle.color) {
                        style.textColor = this.option.nameTextStyle.color;
                    }
                }
                style.strokeColor = this.option.axisLine.lineStyle.color;
                style.lineWidth = lineWidth;
                if (this.isHorizontal()) {
                    style.yStart = style.yEnd = this.subPixelOptimize(style.yEnd, lineWidth);
                } else {
                    style.xStart = style.xEnd = this.subPixelOptimize(style.xEnd, lineWidth);
                }
                style.lineType = this.option.axisLine.lineStyle.type;
                axShape = new LineShape(axShape);
                this.shapeList.push(axShape);
            },
            _axisLabelClickable: function (clickable, axShape) {
                if (clickable) {
                    ecData.pack(axShape, undefined, -1, undefined, -1, axShape.style.text);
                    axShape.hoverable = true;
                    axShape.clickable = true;
                    axShape.highlightStyle = {
                        color: zrColor.lift(axShape.style.color, 1),
                        brushType: 'fill'
                    };
                    return axShape;
                } else {
                    return axShape;
                }
            },
            refixAxisShape: function (zeroX, zeroY) {
                if (!this.option.axisLine.onZero) {
                    return;
                }
                var tickLength;
                if (this.isHorizontal() && zeroY != null) {
                    for (var i = 0, l = this.shapeList.length; i < l; i++) {
                        if (this.shapeList[i]._axisShape === 'axisLine') {
                            this.shapeList[i].style.yStart = this.shapeList[i].style.yEnd = this.subPixelOptimize(zeroY, this.shapeList[i].stylelineWidth);
                            this.zr.modShape(this.shapeList[i].id);
                        } else if (this.shapeList[i]._axisShape === 'axisTick') {
                            tickLength = this.shapeList[i].style.yEnd - this.shapeList[i].style.yStart;
                            this.shapeList[i].style.yStart = zeroY - tickLength;
                            this.shapeList[i].style.yEnd = zeroY;
                            this.zr.modShape(this.shapeList[i].id);
                        }
                    }
                }
                if (!this.isHorizontal() && zeroX != null) {
                    for (var i = 0, l = this.shapeList.length; i < l; i++) {
                        if (this.shapeList[i]._axisShape === 'axisLine') {
                            this.shapeList[i].style.xStart = this.shapeList[i].style.xEnd = this.subPixelOptimize(zeroX, this.shapeList[i].stylelineWidth);
                            this.zr.modShape(this.shapeList[i].id);
                        } else if (this.shapeList[i]._axisShape === 'axisTick') {
                            tickLength = this.shapeList[i].style.xEnd - this.shapeList[i].style.xStart;
                            this.shapeList[i].style.xStart = zeroX;
                            this.shapeList[i].style.xEnd = zeroX + tickLength;
                            this.zr.modShape(this.shapeList[i].id);
                        }
                    }
                }
            },
            getPosition: function () {
                return this.option.position;
            },
            isHorizontal: function () {
                return this.option.position === 'bottom' || this.option.position === 'top';
            }
        },
        reformOption: function (opt) {
            if (!opt || opt instanceof Array && opt.length === 0) {
                opt = [{ type: ecConfig.COMPONENT_TYPE_AXIS_VALUE }];
            } else if (!(opt instanceof Array)) {
                opt = [opt];
            }
            if (opt.length > 2) {
                opt = [
                    opt[0],
                    opt[1]
                ];
            }
            if (this.axisType === 'xAxis') {
                if (!opt[0].position || opt[0].position != 'bottom' && opt[0].position != 'top') {
                    opt[0].position = 'bottom';
                }
                if (opt.length > 1) {
                    opt[1].position = opt[0].position === 'bottom' ? 'top' : 'bottom';
                }
                for (var i = 0, l = opt.length; i < l; i++) {
                    opt[i].type = opt[i].type || 'category';
                    opt[i].xAxisIndex = i;
                    opt[i].yAxisIndex = -1;
                }
            } else {
                if (!opt[0].position || opt[0].position != 'left' && opt[0].position != 'right') {
                    opt[0].position = 'left';
                }
                if (opt.length > 1) {
                    opt[1].position = opt[0].position === 'left' ? 'right' : 'left';
                }
                for (var i = 0, l = opt.length; i < l; i++) {
                    opt[i].type = opt[i].type || 'value';
                    opt[i].xAxisIndex = -1;
                    opt[i].yAxisIndex = i;
                }
            }
            return opt;
        },
        refresh: function (newOption) {
            var axisOption;
            if (newOption) {
                this.option = newOption;
                if (this.axisType === 'xAxis') {
                    this.option.xAxis = this.reformOption(newOption.xAxis);
                    axisOption = this.option.xAxis;
                } else {
                    this.option.yAxis = this.reformOption(newOption.yAxis);
                    axisOption = this.option.yAxis;
                }
                this.series = newOption.series;
            }
            var CategoryAxis = require('./categoryAxis');
            var ValueAxis = require('./valueAxis');
            var len = Math.max(axisOption && axisOption.length || 0, this._axisList.length);
            for (var i = 0; i < len; i++) {
                if (this._axisList[i] && newOption && (!axisOption[i] || this._axisList[i].type != axisOption[i].type)) {
                    this._axisList[i].dispose && this._axisList[i].dispose();
                    this._axisList[i] = false;
                }
                if (this._axisList[i]) {
                    this._axisList[i].refresh && this._axisList[i].refresh(axisOption ? axisOption[i] : false, this.series);
                } else if (axisOption && axisOption[i]) {
                    this._axisList[i] = axisOption[i].type === 'category' ? new CategoryAxis(this.ecTheme, this.messageCenter, this.zr, axisOption[i], this.myChart, this.axisBase) : new ValueAxis(this.ecTheme, this.messageCenter, this.zr, axisOption[i], this.myChart, this.axisBase, this.series);
                }
            }
        },
        getAxis: function (idx) {
            return this._axisList[idx];
        },
        clear: function () {
            for (var i = 0, l = this._axisList.length; i < l; i++) {
                this._axisList[i].dispose && this._axisList[i].dispose();
            }
            this._axisList = [];
        }
    };
    zrUtil.inherits(Axis, Base);
    require('../component').define('axis', Axis);
    return Axis;
});define('echarts/component/grid', [
    'require',
    './base',
    'zrender/shape/Rectangle',
    '../config',
    'zrender/tool/util',
    '../component'
], function (require) {
    var Base = require('./base');
    var RectangleShape = require('zrender/shape/Rectangle');
    var ecConfig = require('../config');
    ecConfig.grid = {
        zlevel: 0,
        z: 0,
        x: 80,
        y: 60,
        x2: 80,
        y2: 60,
        backgroundColor: 'rgba(0,0,0,0)',
        borderWidth: 1,
        borderColor: '#ccc'
    };
    var zrUtil = require('zrender/tool/util');
    function Grid(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.refresh(option);
    }
    Grid.prototype = {
        type: ecConfig.COMPONENT_TYPE_GRID,
        getX: function () {
            return this._x;
        },
        getY: function () {
            return this._y;
        },
        getWidth: function () {
            return this._width;
        },
        getHeight: function () {
            return this._height;
        },
        getXend: function () {
            return this._x + this._width;
        },
        getYend: function () {
            return this._y + this._height;
        },
        getArea: function () {
            return {
                x: this._x,
                y: this._y,
                width: this._width,
                height: this._height
            };
        },
        getBbox: function () {
            return [
                [
                    this._x,
                    this._y
                ],
                [
                    this.getXend(),
                    this.getYend()
                ]
            ];
        },
        refixAxisShape: function (component) {
            var zeroX;
            var zeroY;
            var axisList = component.xAxis._axisList.concat(component.yAxis ? component.yAxis._axisList : []);
            var len = axisList.length;
            var axis;
            while (len--) {
                axis = axisList[len];
                if (axis.type == ecConfig.COMPONENT_TYPE_AXIS_VALUE && axis._min < 0 && axis._max >= 0) {
                    axis.isHorizontal() ? zeroX = axis.getCoord(0) : zeroY = axis.getCoord(0);
                }
            }
            if (typeof zeroX != 'undefined' || typeof zeroY != 'undefined') {
                len = axisList.length;
                while (len--) {
                    axisList[len].refixAxisShape(zeroX, zeroY);
                }
            }
        },
        refresh: function (newOption) {
            if (newOption || this._zrWidth != this.zr.getWidth() || this._zrHeight != this.zr.getHeight()) {
                this.clear();
                this.option = newOption || this.option;
                this.option.grid = this.reformOption(this.option.grid);
                var gridOption = this.option.grid;
                this._zrWidth = this.zr.getWidth();
                this._zrHeight = this.zr.getHeight();
                this._x = this.parsePercent(gridOption.x, this._zrWidth);
                this._y = this.parsePercent(gridOption.y, this._zrHeight);
                var x2 = this.parsePercent(gridOption.x2, this._zrWidth);
                var y2 = this.parsePercent(gridOption.y2, this._zrHeight);
                if (typeof gridOption.width == 'undefined') {
                    this._width = this._zrWidth - this._x - x2;
                } else {
                    this._width = this.parsePercent(gridOption.width, this._zrWidth);
                }
                this._width = this._width <= 0 ? 10 : this._width;
                if (typeof gridOption.height == 'undefined') {
                    this._height = this._zrHeight - this._y - y2;
                } else {
                    this._height = this.parsePercent(gridOption.height, this._zrHeight);
                }
                this._height = this._height <= 0 ? 10 : this._height;
                this._x = this.subPixelOptimize(this._x, gridOption.borderWidth);
                this._y = this.subPixelOptimize(this._y, gridOption.borderWidth);
                this.shapeList.push(new RectangleShape({
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    hoverable: false,
                    style: {
                        x: this._x,
                        y: this._y,
                        width: this._width,
                        height: this._height,
                        brushType: gridOption.borderWidth > 0 ? 'both' : 'fill',
                        color: gridOption.backgroundColor,
                        strokeColor: gridOption.borderColor,
                        lineWidth: gridOption.borderWidth
                    }
                }));
                this.zr.addShape(this.shapeList[0]);
            }
        }
    };
    zrUtil.inherits(Grid, Base);
    require('../component').define('grid', Grid);
    return Grid;
});define('echarts/component/dataZoom', [
    'require',
    './base',
    'zrender/shape/Rectangle',
    'zrender/shape/Polygon',
    '../util/shape/Icon',
    '../config',
    '../util/date',
    'zrender/tool/util',
    '../component'
], function (require) {
    var Base = require('./base');
    var RectangleShape = require('zrender/shape/Rectangle');
    var PolygonShape = require('zrender/shape/Polygon');
    var IconShape = require('../util/shape/Icon');
    var ecConfig = require('../config');
    ecConfig.dataZoom = {
        zlevel: 0,
        z: 4,
        show: false,
        orient: 'horizontal',
        backgroundColor: 'rgba(0,0,0,0)',
        dataBackgroundColor: '#eee',
        fillerColor: 'rgba(144,197,237,0.2)',
        handleColor: 'rgba(70,130,180,0.8)',
        handleSize: 8,
        showDetail: true,
        realtime: true
    };
    var ecDate = require('../util/date');
    var zrUtil = require('zrender/tool/util');
    function DataZoom(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        var self = this;
        self._ondrift = function (dx, dy) {
            return self.__ondrift(this, dx, dy);
        };
        self._ondragend = function () {
            return self.__ondragend();
        };
        this._fillerSize = 30;
        this._isSilence = false;
        this._zoom = {};
        this.option.dataZoom = this.reformOption(this.option.dataZoom);
        this.zoomOption = this.option.dataZoom;
        this._handleSize = this.zoomOption.handleSize;
        if (!this.myChart.canvasSupported) {
            this.zoomOption.realtime = false;
        }
        this._location = this._getLocation();
        this._zoom = this._getZoom();
        this._backupData();
        if (this.option.dataZoom.show) {
            this._buildShape();
        }
        this._syncData();
    }
    DataZoom.prototype = {
        type: ecConfig.COMPONENT_TYPE_DATAZOOM,
        _buildShape: function () {
            this._buildBackground();
            this._buildFiller();
            this._buildHandle();
            this._buildFrame();
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                this.zr.addShape(this.shapeList[i]);
            }
            this._syncFrameShape();
        },
        _getLocation: function () {
            var x;
            var y;
            var width;
            var height;
            var grid = this.component.grid;
            if (this.zoomOption.orient == 'horizontal') {
                width = this.zoomOption.width || grid.getWidth();
                height = this.zoomOption.height || this._fillerSize;
                x = this.zoomOption.x != null ? this.zoomOption.x : grid.getX();
                y = this.zoomOption.y != null ? this.zoomOption.y : this.zr.getHeight() - height - 2;
            } else {
                width = this.zoomOption.width || this._fillerSize;
                height = this.zoomOption.height || grid.getHeight();
                x = this.zoomOption.x != null ? this.zoomOption.x : 2;
                y = this.zoomOption.y != null ? this.zoomOption.y : grid.getY();
            }
            return {
                x: x,
                y: y,
                width: width,
                height: height
            };
        },
        _getZoom: function () {
            var series = this.option.series;
            var xAxis = this.option.xAxis;
            if (xAxis && !(xAxis instanceof Array)) {
                xAxis = [xAxis];
                this.option.xAxis = xAxis;
            }
            var yAxis = this.option.yAxis;
            if (yAxis && !(yAxis instanceof Array)) {
                yAxis = [yAxis];
                this.option.yAxis = yAxis;
            }
            var zoomSeriesIndex = [];
            var xAxisIndex;
            var yAxisIndex;
            var zOptIdx = this.zoomOption.xAxisIndex;
            if (xAxis && zOptIdx == null) {
                xAxisIndex = [];
                for (var i = 0, l = xAxis.length; i < l; i++) {
                    if (xAxis[i].type == 'category' || xAxis[i].type == null) {
                        xAxisIndex.push(i);
                    }
                }
            } else {
                if (zOptIdx instanceof Array) {
                    xAxisIndex = zOptIdx;
                } else if (zOptIdx != null) {
                    xAxisIndex = [zOptIdx];
                } else {
                    xAxisIndex = [];
                }
            }
            zOptIdx = this.zoomOption.yAxisIndex;
            if (yAxis && zOptIdx == null) {
                yAxisIndex = [];
                for (var i = 0, l = yAxis.length; i < l; i++) {
                    if (yAxis[i].type == 'category') {
                        yAxisIndex.push(i);
                    }
                }
            } else {
                if (zOptIdx instanceof Array) {
                    yAxisIndex = zOptIdx;
                } else if (zOptIdx != null) {
                    yAxisIndex = [zOptIdx];
                } else {
                    yAxisIndex = [];
                }
            }
            var serie;
            for (var i = 0, l = series.length; i < l; i++) {
                serie = series[i];
                if (serie.type != ecConfig.CHART_TYPE_LINE && serie.type != ecConfig.CHART_TYPE_BAR && serie.type != ecConfig.CHART_TYPE_SCATTER && serie.type != ecConfig.CHART_TYPE_K) {
                    continue;
                }
                for (var j = 0, k = xAxisIndex.length; j < k; j++) {
                    if (xAxisIndex[j] == (serie.xAxisIndex || 0)) {
                        zoomSeriesIndex.push(i);
                        break;
                    }
                }
                for (var j = 0, k = yAxisIndex.length; j < k; j++) {
                    if (yAxisIndex[j] == (serie.yAxisIndex || 0)) {
                        zoomSeriesIndex.push(i);
                        break;
                    }
                }
                if (this.zoomOption.xAxisIndex == null && this.zoomOption.yAxisIndex == null && serie.data && this.getDataFromOption(serie.data[0]) instanceof Array && (serie.type == ecConfig.CHART_TYPE_SCATTER || serie.type == ecConfig.CHART_TYPE_LINE || serie.type == ecConfig.CHART_TYPE_BAR)) {
                    zoomSeriesIndex.push(i);
                }
            }
            var start = this._zoom.start != null ? this._zoom.start : this.zoomOption.start != null ? this.zoomOption.start : 0;
            var end = this._zoom.end != null ? this._zoom.end : this.zoomOption.end != null ? this.zoomOption.end : 100;
            if (start > end) {
                start = start + end;
                end = start - end;
                start = start - end;
            }
            var size = Math.round((end - start) / 100 * (this.zoomOption.orient == 'horizontal' ? this._location.width : this._location.height));
            return {
                start: start,
                end: end,
                start2: 0,
                end2: 100,
                size: size,
                xAxisIndex: xAxisIndex,
                yAxisIndex: yAxisIndex,
                seriesIndex: zoomSeriesIndex,
                scatterMap: this._zoom.scatterMap || {}
            };
        },
        _backupData: function () {
            this._originalData = {
                xAxis: {},
                yAxis: {},
                series: {}
            };
            var xAxis = this.option.xAxis;
            var xAxisIndex = this._zoom.xAxisIndex;
            for (var i = 0, l = xAxisIndex.length; i < l; i++) {
                this._originalData.xAxis[xAxisIndex[i]] = xAxis[xAxisIndex[i]].data;
            }
            var yAxis = this.option.yAxis;
            var yAxisIndex = this._zoom.yAxisIndex;
            for (var i = 0, l = yAxisIndex.length; i < l; i++) {
                this._originalData.yAxis[yAxisIndex[i]] = yAxis[yAxisIndex[i]].data;
            }
            var series = this.option.series;
            var seriesIndex = this._zoom.seriesIndex;
            var serie;
            for (var i = 0, l = seriesIndex.length; i < l; i++) {
                serie = series[seriesIndex[i]];
                this._originalData.series[seriesIndex[i]] = serie.data;
                if (serie.data && this.getDataFromOption(serie.data[0]) instanceof Array && (serie.type == ecConfig.CHART_TYPE_SCATTER || serie.type == ecConfig.CHART_TYPE_LINE || serie.type == ecConfig.CHART_TYPE_BAR)) {
                    this._backupScale();
                    this._calculScatterMap(seriesIndex[i]);
                }
            }
        },
        _calculScatterMap: function (seriesIndex) {
            this._zoom.scatterMap = this._zoom.scatterMap || {};
            this._zoom.scatterMap[seriesIndex] = this._zoom.scatterMap[seriesIndex] || {};
            var componentLibrary = require('../component');
            var Axis = componentLibrary.get('axis');
            var axisOption = zrUtil.clone(this.option.xAxis);
            if (axisOption[0].type == 'category') {
                axisOption[0].type = 'value';
            }
            if (axisOption[1] && axisOption[1].type == 'category') {
                axisOption[1].type = 'value';
            }
            var vAxis = new Axis(this.ecTheme, null, false, {
                xAxis: axisOption,
                series: this.option.series
            }, this, 'xAxis');
            var axisIndex = this.option.series[seriesIndex].xAxisIndex || 0;
            this._zoom.scatterMap[seriesIndex].x = vAxis.getAxis(axisIndex).getExtremum();
            vAxis.dispose();
            axisOption = zrUtil.clone(this.option.yAxis);
            if (axisOption[0].type == 'category') {
                axisOption[0].type = 'value';
            }
            if (axisOption[1] && axisOption[1].type == 'category') {
                axisOption[1].type = 'value';
            }
            vAxis = new Axis(this.ecTheme, null, false, {
                yAxis: axisOption,
                series: this.option.series
            }, this, 'yAxis');
            axisIndex = this.option.series[seriesIndex].yAxisIndex || 0;
            this._zoom.scatterMap[seriesIndex].y = vAxis.getAxis(axisIndex).getExtremum();
            vAxis.dispose();
        },
        _buildBackground: function () {
            var width = this._location.width;
            var height = this._location.height;
            this.shapeList.push(new RectangleShape({
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                hoverable: false,
                style: {
                    x: this._location.x,
                    y: this._location.y,
                    width: width,
                    height: height,
                    color: this.zoomOption.backgroundColor
                }
            }));
            var maxLength = 0;
            var xAxis = this._originalData.xAxis;
            var xAxisIndex = this._zoom.xAxisIndex;
            for (var i = 0, l = xAxisIndex.length; i < l; i++) {
                maxLength = Math.max(maxLength, xAxis[xAxisIndex[i]].length);
            }
            var yAxis = this._originalData.yAxis;
            var yAxisIndex = this._zoom.yAxisIndex;
            for (var i = 0, l = yAxisIndex.length; i < l; i++) {
                maxLength = Math.max(maxLength, yAxis[yAxisIndex[i]].length);
            }
            var seriesIndex = this._zoom.seriesIndex[0];
            var data = this._originalData.series[seriesIndex];
            var maxValue = Number.MIN_VALUE;
            var minValue = Number.MAX_VALUE;
            var value;
            for (var i = 0, l = data.length; i < l; i++) {
                value = this.getDataFromOption(data[i], 0);
                if (this.option.series[seriesIndex].type == ecConfig.CHART_TYPE_K) {
                    value = value[1];
                }
                if (isNaN(value)) {
                    value = 0;
                }
                maxValue = Math.max(maxValue, value);
                minValue = Math.min(minValue, value);
            }
            var valueRange = maxValue - minValue;
            var pointList = [];
            var x = width / (maxLength - (maxLength > 1 ? 1 : 0));
            var y = height / (maxLength - (maxLength > 1 ? 1 : 0));
            var step = 1;
            if (this.zoomOption.orient == 'horizontal' && x < 1) {
                step = Math.floor(maxLength * 3 / width);
            } else if (this.zoomOption.orient == 'vertical' && y < 1) {
                step = Math.floor(maxLength * 3 / height);
            }
            for (var i = 0, l = maxLength; i < l; i += step) {
                value = this.getDataFromOption(data[i], 0);
                if (this.option.series[seriesIndex].type == ecConfig.CHART_TYPE_K) {
                    value = value[1];
                }
                if (isNaN(value)) {
                    value = 0;
                }
                if (this.zoomOption.orient == 'horizontal') {
                    pointList.push([
                        this._location.x + x * i,
                        this._location.y + height - 1 - Math.round((value - minValue) / valueRange * (height - 10))
                    ]);
                } else {
                    pointList.push([
                        this._location.x + 1 + Math.round((value - minValue) / valueRange * (width - 10)),
                        this._location.y + y * (l - i - 1)
                    ]);
                }
            }
            if (this.zoomOption.orient == 'horizontal') {
                pointList.push([
                    this._location.x + width,
                    this._location.y + height
                ]);
                pointList.push([
                    this._location.x,
                    this._location.y + height
                ]);
            } else {
                pointList.push([
                    this._location.x,
                    this._location.y
                ]);
                pointList.push([
                    this._location.x,
                    this._location.y + height
                ]);
            }
            this.shapeList.push(new PolygonShape({
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                style: {
                    pointList: pointList,
                    color: this.zoomOption.dataBackgroundColor
                },
                hoverable: false
            }));
        },
        _buildFiller: function () {
            this._fillerShae = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                draggable: true,
                ondrift: this._ondrift,
                ondragend: this._ondragend,
                _type: 'filler'
            };
            if (this.zoomOption.orient == 'horizontal') {
                this._fillerShae.style = {
                    x: this._location.x + Math.round(this._zoom.start / 100 * this._location.width) + this._handleSize,
                    y: this._location.y,
                    width: this._zoom.size - this._handleSize * 2,
                    height: this._location.height,
                    color: this.zoomOption.fillerColor,
                    text: ':::',
                    textPosition: 'inside'
                };
            } else {
                this._fillerShae.style = {
                    x: this._location.x,
                    y: this._location.y + Math.round(this._zoom.start / 100 * this._location.height) + this._handleSize,
                    width: this._location.width,
                    height: this._zoom.size - this._handleSize * 2,
                    color: this.zoomOption.fillerColor,
                    text: '::',
                    textPosition: 'inside'
                };
            }
            this._fillerShae.highlightStyle = {
                brushType: 'fill',
                color: 'rgba(0,0,0,0)'
            };
            this._fillerShae = new RectangleShape(this._fillerShae);
            this.shapeList.push(this._fillerShae);
        },
        _buildHandle: function () {
            var detail = this.zoomOption.showDetail ? this._getDetail() : {
                start: '',
                end: ''
            };
            this._startShape = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                draggable: true,
                style: {
                    iconType: 'rectangle',
                    x: this._location.x,
                    y: this._location.y,
                    width: this._handleSize,
                    height: this._handleSize,
                    color: this.zoomOption.handleColor,
                    text: '=',
                    textPosition: 'inside'
                },
                highlightStyle: {
                    text: detail.start,
                    brushType: 'fill',
                    textPosition: 'left'
                },
                ondrift: this._ondrift,
                ondragend: this._ondragend
            };
            if (this.zoomOption.orient == 'horizontal') {
                this._startShape.style.height = this._location.height;
                this._endShape = zrUtil.clone(this._startShape);
                this._startShape.style.x = this._fillerShae.style.x - this._handleSize, this._endShape.style.x = this._fillerShae.style.x + this._fillerShae.style.width;
                this._endShape.highlightStyle.text = detail.end;
                this._endShape.highlightStyle.textPosition = 'right';
            } else {
                this._startShape.style.width = this._location.width;
                this._endShape = zrUtil.clone(this._startShape);
                this._startShape.style.y = this._fillerShae.style.y + this._fillerShae.style.height;
                this._startShape.highlightStyle.textPosition = 'bottom';
                this._endShape.style.y = this._fillerShae.style.y - this._handleSize;
                this._endShape.highlightStyle.text = detail.end;
                this._endShape.highlightStyle.textPosition = 'top';
            }
            this._startShape = new IconShape(this._startShape);
            this._endShape = new IconShape(this._endShape);
            this.shapeList.push(this._startShape);
            this.shapeList.push(this._endShape);
        },
        _buildFrame: function () {
            var x = this.subPixelOptimize(this._location.x, 1);
            var y = this.subPixelOptimize(this._location.y, 1);
            this._startFrameShape = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                hoverable: false,
                style: {
                    x: x,
                    y: y,
                    width: this._location.width - (x > this._location.x ? 1 : 0),
                    height: this._location.height - (y > this._location.y ? 1 : 0),
                    lineWidth: 1,
                    brushType: 'stroke',
                    strokeColor: this.zoomOption.handleColor
                }
            };
            this._endFrameShape = zrUtil.clone(this._startFrameShape);
            this._startFrameShape = new RectangleShape(this._startFrameShape);
            this._endFrameShape = new RectangleShape(this._endFrameShape);
            this.shapeList.push(this._startFrameShape);
            this.shapeList.push(this._endFrameShape);
            return;
        },
        _syncHandleShape: function () {
            if (this.zoomOption.orient == 'horizontal') {
                this._startShape.style.x = this._fillerShae.style.x - this._handleSize;
                this._endShape.style.x = this._fillerShae.style.x + this._fillerShae.style.width;
                this._zoom.start = (this._startShape.style.x - this._location.x) / this._location.width * 100;
                this._zoom.end = (this._endShape.style.x + this._handleSize - this._location.x) / this._location.width * 100;
            } else {
                this._startShape.style.y = this._fillerShae.style.y + this._fillerShae.style.height;
                this._endShape.style.y = this._fillerShae.style.y - this._handleSize;
                this._zoom.start = (this._location.y + this._location.height - this._startShape.style.y) / this._location.height * 100;
                this._zoom.end = (this._location.y + this._location.height - this._endShape.style.y - this._handleSize) / this._location.height * 100;
            }
            this.zr.modShape(this._startShape.id);
            this.zr.modShape(this._endShape.id);
            this._syncFrameShape();
            this.zr.refreshNextFrame();
        },
        _syncFillerShape: function () {
            var a;
            var b;
            if (this.zoomOption.orient == 'horizontal') {
                a = this._startShape.style.x;
                b = this._endShape.style.x;
                this._fillerShae.style.x = Math.min(a, b) + this._handleSize;
                this._fillerShae.style.width = Math.abs(a - b) - this._handleSize;
                this._zoom.start = (Math.min(a, b) - this._location.x) / this._location.width * 100;
                this._zoom.end = (Math.max(a, b) + this._handleSize - this._location.x) / this._location.width * 100;
            } else {
                a = this._startShape.style.y;
                b = this._endShape.style.y;
                this._fillerShae.style.y = Math.min(a, b) + this._handleSize;
                this._fillerShae.style.height = Math.abs(a - b) - this._handleSize;
                this._zoom.start = (this._location.y + this._location.height - Math.max(a, b)) / this._location.height * 100;
                this._zoom.end = (this._location.y + this._location.height - Math.min(a, b) - this._handleSize) / this._location.height * 100;
            }
            this.zr.modShape(this._fillerShae.id);
            this._syncFrameShape();
            this.zr.refreshNextFrame();
        },
        _syncFrameShape: function () {
            if (this.zoomOption.orient == 'horizontal') {
                this._startFrameShape.style.width = this._fillerShae.style.x - this._location.x;
                this._endFrameShape.style.x = this._fillerShae.style.x + this._fillerShae.style.width;
                this._endFrameShape.style.width = this._location.x + this._location.width - this._endFrameShape.style.x;
            } else {
                this._startFrameShape.style.y = this._fillerShae.style.y + this._fillerShae.style.height;
                this._startFrameShape.style.height = this._location.y + this._location.height - this._startFrameShape.style.y;
                this._endFrameShape.style.height = this._fillerShae.style.y - this._location.y;
            }
            this.zr.modShape(this._startFrameShape.id);
            this.zr.modShape(this._endFrameShape.id);
        },
        _syncShape: function () {
            if (!this.zoomOption.show) {
                return;
            }
            if (this.zoomOption.orient == 'horizontal') {
                this._startShape.style.x = this._location.x + this._zoom.start / 100 * this._location.width;
                this._endShape.style.x = this._location.x + this._zoom.end / 100 * this._location.width - this._handleSize;
                this._fillerShae.style.x = this._startShape.style.x + this._handleSize;
                this._fillerShae.style.width = this._endShape.style.x - this._startShape.style.x - this._handleSize;
            } else {
                this._startShape.style.y = this._location.y + this._location.height - this._zoom.start / 100 * this._location.height;
                this._endShape.style.y = this._location.y + this._location.height - this._zoom.end / 100 * this._location.height - this._handleSize;
                this._fillerShae.style.y = this._endShape.style.y + this._handleSize;
                this._fillerShae.style.height = this._startShape.style.y - this._endShape.style.y - this._handleSize;
            }
            this.zr.modShape(this._startShape.id);
            this.zr.modShape(this._endShape.id);
            this.zr.modShape(this._fillerShae.id);
            this._syncFrameShape();
            this.zr.refresh();
        },
        _syncData: function (dispatchNow) {
            var target;
            var start;
            var end;
            var length;
            var data;
            for (var key in this._originalData) {
                target = this._originalData[key];
                for (var idx in target) {
                    data = target[idx];
                    if (data == null) {
                        continue;
                    }
                    length = data.length;
                    start = Math.floor(this._zoom.start / 100 * length);
                    end = Math.ceil(this._zoom.end / 100 * length);
                    if (!(this.getDataFromOption(data[0]) instanceof Array) || this.option[key][idx].type == ecConfig.CHART_TYPE_K) {
                        this.option[key][idx].data = data.slice(start, end);
                    } else {
                        this._setScale();
                        this.option[key][idx].data = this._synScatterData(idx, data);
                    }
                }
            }
            if (!this._isSilence && (this.zoomOption.realtime || dispatchNow)) {
                this.messageCenter.dispatch(ecConfig.EVENT.DATA_ZOOM, null, { zoom: this._zoom }, this.myChart);
            }
        },
        _synScatterData: function (seriesIndex, data) {
            if (this._zoom.start === 0 && this._zoom.end == 100 && this._zoom.start2 === 0 && this._zoom.end2 == 100) {
                return data;
            }
            var newData = [];
            var scale = this._zoom.scatterMap[seriesIndex];
            var total;
            var xStart;
            var xEnd;
            var yStart;
            var yEnd;
            if (this.zoomOption.orient == 'horizontal') {
                total = scale.x.max - scale.x.min;
                xStart = this._zoom.start / 100 * total + scale.x.min;
                xEnd = this._zoom.end / 100 * total + scale.x.min;
                total = scale.y.max - scale.y.min;
                yStart = this._zoom.start2 / 100 * total + scale.y.min;
                yEnd = this._zoom.end2 / 100 * total + scale.y.min;
            } else {
                total = scale.x.max - scale.x.min;
                xStart = this._zoom.start2 / 100 * total + scale.x.min;
                xEnd = this._zoom.end2 / 100 * total + scale.x.min;
                total = scale.y.max - scale.y.min;
                yStart = this._zoom.start / 100 * total + scale.y.min;
                yEnd = this._zoom.end / 100 * total + scale.y.min;
            }
            var value;
            for (var i = 0, l = data.length; i < l; i++) {
                value = data[i].value || data[i];
                if (value[0] >= xStart && value[0] <= xEnd && value[1] >= yStart && value[1] <= yEnd) {
                    newData.push(data[i]);
                }
            }
            return newData;
        },
        _setScale: function () {
            var needScale = this._zoom.start !== 0 || this._zoom.end !== 100 || this._zoom.start2 !== 0 || this._zoom.end2 !== 100;
            var axis = {
                xAxis: this.option.xAxis,
                yAxis: this.option.yAxis
            };
            for (var key in axis) {
                for (var i = 0, l = axis[key].length; i < l; i++) {
                    axis[key][i].scale = needScale || axis[key][i]._scale;
                }
            }
        },
        _backupScale: function () {
            var axis = {
                xAxis: this.option.xAxis,
                yAxis: this.option.yAxis
            };
            for (var key in axis) {
                for (var i = 0, l = axis[key].length; i < l; i++) {
                    axis[key][i]._scale = axis[key][i].scale;
                }
            }
        },
        _getDetail: function () {
            var key = [
                'xAxis',
                'yAxis'
            ];
            for (var i = 0, l = key.length; i < l; i++) {
                var target = this._originalData[key[i]];
                for (var idx in target) {
                    var data = target[idx];
                    if (data == null) {
                        continue;
                    }
                    var length = data.length;
                    var start = Math.floor(this._zoom.start / 100 * length);
                    var end = Math.ceil(this._zoom.end / 100 * length);
                    end -= end > 0 ? 1 : 0;
                    return {
                        start: this.getDataFromOption(data[start]),
                        end: this.getDataFromOption(data[end])
                    };
                }
            }
            key = this.zoomOption.orient == 'horizontal' ? 'xAxis' : 'yAxis';
            var seriesIndex = this._zoom.seriesIndex[0];
            var axisIndex = this.option.series[seriesIndex][key + 'Index'] || 0;
            var axisType = this.option[key][axisIndex].type;
            var min = this._zoom.scatterMap[seriesIndex][key.charAt(0)].min;
            var max = this._zoom.scatterMap[seriesIndex][key.charAt(0)].max;
            var gap = max - min;
            if (axisType == 'value') {
                return {
                    start: min + gap * this._zoom.start / 100,
                    end: min + gap * this._zoom.end / 100
                };
            } else if (axisType == 'time') {
                max = min + gap * this._zoom.end / 100;
                min = min + gap * this._zoom.start / 100;
                var formatter = ecDate.getAutoFormatter(min, max).formatter;
                return {
                    start: ecDate.format(formatter, min),
                    end: ecDate.format(formatter, max)
                };
            }
            return {
                start: '',
                end: ''
            };
        },
        __ondrift: function (shape, dx, dy) {
            if (this.zoomOption.zoomLock) {
                shape = this._fillerShae;
            }
            var detailSize = shape._type == 'filler' ? this._handleSize : 0;
            if (this.zoomOption.orient == 'horizontal') {
                if (shape.style.x + dx - detailSize <= this._location.x) {
                    shape.style.x = this._location.x + detailSize;
                } else if (shape.style.x + dx + shape.style.width + detailSize >= this._location.x + this._location.width) {
                    shape.style.x = this._location.x + this._location.width - shape.style.width - detailSize;
                } else {
                    shape.style.x += dx;
                }
            } else {
                if (shape.style.y + dy - detailSize <= this._location.y) {
                    shape.style.y = this._location.y + detailSize;
                } else if (shape.style.y + dy + shape.style.height + detailSize >= this._location.y + this._location.height) {
                    shape.style.y = this._location.y + this._location.height - shape.style.height - detailSize;
                } else {
                    shape.style.y += dy;
                }
            }
            if (shape._type == 'filler') {
                this._syncHandleShape();
            } else {
                this._syncFillerShape();
            }
            if (this.zoomOption.realtime) {
                this._syncData();
            }
            if (this.zoomOption.showDetail) {
                var detail = this._getDetail();
                this._startShape.style.text = this._startShape.highlightStyle.text = detail.start;
                this._endShape.style.text = this._endShape.highlightStyle.text = detail.end;
                this._startShape.style.textPosition = this._startShape.highlightStyle.textPosition;
                this._endShape.style.textPosition = this._endShape.highlightStyle.textPosition;
            }
            return true;
        },
        __ondragend: function () {
            if (this.zoomOption.showDetail) {
                this._startShape.style.text = this._endShape.style.text = '=';
                this._startShape.style.textPosition = this._endShape.style.textPosition = 'inside';
                this.zr.modShape(this._startShape.id);
                this.zr.modShape(this._endShape.id);
                this.zr.refreshNextFrame();
            }
            this.isDragend = true;
        },
        ondragend: function (param, status) {
            if (!this.isDragend || !param.target) {
                return;
            }
            !this.zoomOption.realtime && this._syncData();
            status.dragOut = true;
            status.dragIn = true;
            if (!this._isSilence && !this.zoomOption.realtime) {
                this.messageCenter.dispatch(ecConfig.EVENT.DATA_ZOOM, null, { zoom: this._zoom }, this.myChart);
            }
            status.needRefresh = false;
            this.isDragend = false;
            return;
        },
        ondataZoom: function (param, status) {
            status.needRefresh = true;
            return;
        },
        absoluteZoom: function (param) {
            this._zoom.start = param.start;
            this._zoom.end = param.end;
            this._zoom.start2 = param.start2;
            this._zoom.end2 = param.end2;
            this._syncShape();
            this._syncData(true);
            return;
        },
        rectZoom: function (param) {
            if (!param) {
                this._zoom.start = this._zoom.start2 = 0;
                this._zoom.end = this._zoom.end2 = 100;
                this._syncShape();
                this._syncData(true);
                return this._zoom;
            }
            var gridArea = this.component.grid.getArea();
            var rect = {
                x: param.x,
                y: param.y,
                width: param.width,
                height: param.height
            };
            if (rect.width < 0) {
                rect.x += rect.width;
                rect.width = -rect.width;
            }
            if (rect.height < 0) {
                rect.y += rect.height;
                rect.height = -rect.height;
            }
            if (rect.x > gridArea.x + gridArea.width || rect.y > gridArea.y + gridArea.height) {
                return false;
            }
            if (rect.x < gridArea.x) {
                rect.x = gridArea.x;
            }
            if (rect.x + rect.width > gridArea.x + gridArea.width) {
                rect.width = gridArea.x + gridArea.width - rect.x;
            }
            if (rect.y + rect.height > gridArea.y + gridArea.height) {
                rect.height = gridArea.y + gridArea.height - rect.y;
            }
            var total;
            var sdx = (rect.x - gridArea.x) / gridArea.width;
            var edx = 1 - (rect.x + rect.width - gridArea.x) / gridArea.width;
            var sdy = 1 - (rect.y + rect.height - gridArea.y) / gridArea.height;
            var edy = (rect.y - gridArea.y) / gridArea.height;
            if (this.zoomOption.orient == 'horizontal') {
                total = this._zoom.end - this._zoom.start;
                this._zoom.start += total * sdx;
                this._zoom.end -= total * edx;
                total = this._zoom.end2 - this._zoom.start2;
                this._zoom.start2 += total * sdy;
                this._zoom.end2 -= total * edy;
            } else {
                total = this._zoom.end - this._zoom.start;
                this._zoom.start += total * sdy;
                this._zoom.end -= total * edy;
                total = this._zoom.end2 - this._zoom.start2;
                this._zoom.start2 += total * sdx;
                this._zoom.end2 -= total * edx;
            }
            this._syncShape();
            this._syncData(true);
            return this._zoom;
        },
        syncBackupData: function (curOption) {
            var start;
            var target = this._originalData['series'];
            var curSeries = curOption.series;
            var curData;
            for (var i = 0, l = curSeries.length; i < l; i++) {
                curData = curSeries[i].data || curSeries[i].eventList;
                if (target[i]) {
                    start = Math.floor(this._zoom.start / 100 * target[i].length);
                } else {
                    start = 0;
                }
                for (var j = 0, k = curData.length; j < k; j++) {
                    if (target[i]) {
                        target[i][j + start] = curData[j];
                    }
                }
            }
        },
        syncOption: function (magicOption) {
            this.silence(true);
            this.option = magicOption;
            this.option.dataZoom = this.reformOption(this.option.dataZoom);
            this.zoomOption = this.option.dataZoom;
            if (!this.myChart.canvasSupported) {
                this.zoomOption.realtime = false;
            }
            this.clear();
            this._location = this._getLocation();
            this._zoom = this._getZoom();
            this._backupData();
            if (this.option.dataZoom && this.option.dataZoom.show) {
                this._buildShape();
            }
            this._syncData();
            this.silence(false);
        },
        silence: function (s) {
            this._isSilence = s;
        },
        getRealDataIndex: function (sIdx, dIdx) {
            if (!this._originalData || this._zoom.start === 0 && this._zoom.end == 100) {
                return dIdx;
            }
            var sreies = this._originalData.series;
            if (sreies[sIdx]) {
                return Math.floor(this._zoom.start / 100 * sreies[sIdx].length) + dIdx;
            }
            return -1;
        },
        resize: function () {
            this.clear();
            this._location = this._getLocation();
            this._zoom = this._getZoom();
            if (this.option.dataZoom.show) {
                this._buildShape();
            }
        }
    };
    zrUtil.inherits(DataZoom, Base);
    require('../component').define('dataZoom', DataZoom);
    return DataZoom;
});define('echarts/component/categoryAxis', [
    'require',
    './base',
    'zrender/shape/Text',
    'zrender/shape/Line',
    'zrender/shape/Rectangle',
    '../config',
    'zrender/tool/util',
    'zrender/tool/area',
    '../component'
], function (require) {
    var Base = require('./base');
    var TextShape = require('zrender/shape/Text');
    var LineShape = require('zrender/shape/Line');
    var RectangleShape = require('zrender/shape/Rectangle');
    var ecConfig = require('../config');
    ecConfig.categoryAxis = {
        zlevel: 0,
        z: 0,
        show: true,
        position: 'bottom',
        name: '',
        nameLocation: 'end',
        nameTextStyle: {},
        boundaryGap: true,
        axisLine: {
            show: true,
            onZero: true,
            lineStyle: {
                color: '#48b',
                width: 2,
                type: 'solid'
            }
        },
        axisTick: {
            show: true,
            interval: 'auto',
            inside: false,
            length: 5,
            lineStyle: {
                color: '#333',
                width: 1
            }
        },
        axisLabel: {
            show: true,
            interval: 'auto',
            rotate: 0,
            margin: 8,
            textStyle: { color: '#333' }
        },
        splitLine: {
            show: true,
            lineStyle: {
                color: ['#ccc'],
                width: 1,
                type: 'solid'
            }
        },
        splitArea: {
            show: false,
            areaStyle: {
                color: [
                    'rgba(250,250,250,0.3)',
                    'rgba(200,200,200,0.3)'
                ]
            }
        }
    };
    var zrUtil = require('zrender/tool/util');
    var zrArea = require('zrender/tool/area');
    function CategoryAxis(ecTheme, messageCenter, zr, option, myChart, axisBase) {
        if (option.data.length < 1) {
            console.error('option.data.length < 1.');
            return;
        }
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.grid = this.component.grid;
        for (var method in axisBase) {
            this[method] = axisBase[method];
        }
        this.refresh(option);
    }
    CategoryAxis.prototype = {
        type: ecConfig.COMPONENT_TYPE_AXIS_CATEGORY,
        _getReformedLabel: function (idx) {
            var data = this.getDataFromOption(this.option.data[idx]);
            var formatter = this.option.data[idx].formatter || this.option.axisLabel.formatter;
            if (formatter) {
                if (typeof formatter == 'function') {
                    data = formatter.call(this.myChart, data);
                } else if (typeof formatter == 'string') {
                    data = formatter.replace('{value}', data);
                }
            }
            return data;
        },
        _getInterval: function () {
            var interval = this.option.axisLabel.interval;
            if (interval == 'auto') {
                var fontSize = this.option.axisLabel.textStyle.fontSize;
                var data = this.option.data;
                var dataLength = this.option.data.length;
                if (this.isHorizontal()) {
                    if (dataLength > 3) {
                        var gap = this.getGap();
                        var isEnough = false;
                        var labelSpace;
                        var labelSize;
                        var step = Math.floor(0.5 / gap);
                        step = step < 1 ? 1 : step;
                        interval = Math.floor(15 / gap);
                        while (!isEnough && interval < dataLength) {
                            interval += step;
                            isEnough = true;
                            labelSpace = Math.floor(gap * interval);
                            for (var i = Math.floor((dataLength - 1) / interval) * interval; i >= 0; i -= interval) {
                                if (this.option.axisLabel.rotate !== 0) {
                                    labelSize = fontSize;
                                } else if (data[i].textStyle) {
                                    labelSize = zrArea.getTextWidth(this._getReformedLabel(i), this.getFont(zrUtil.merge(data[i].textStyle, this.option.axisLabel.textStyle)));
                                } else {
                                    var label = this._getReformedLabel(i) + '';
                                    var wLen = (label.match(/\w/g) || '').length;
                                    var oLen = label.length - wLen;
                                    labelSize = wLen * fontSize * 2 / 3 + oLen * fontSize;
                                }
                                if (labelSpace < labelSize) {
                                    isEnough = false;
                                    break;
                                }
                            }
                        }
                    } else {
                        interval = 1;
                    }
                } else {
                    if (dataLength > 3) {
                        var gap = this.getGap();
                        interval = Math.floor(11 / gap);
                        while (gap * interval - 6 < fontSize && interval < dataLength) {
                            interval++;
                        }
                    } else {
                        interval = 1;
                    }
                }
            } else {
                interval = typeof interval == 'function' ? 1 : interval - 0 + 1;
            }
            return interval;
        },
        _buildShape: function () {
            this._interval = this._getInterval();
            if (!this.option.show) {
                return;
            }
            this.option.splitArea.show && this._buildSplitArea();
            this.option.splitLine.show && this._buildSplitLine();
            this.option.axisLine.show && this._buildAxisLine();
            this.option.axisTick.show && this._buildAxisTick();
            this.option.axisLabel.show && this._buildAxisLabel();
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                this.zr.addShape(this.shapeList[i]);
            }
        },
        _buildAxisTick: function () {
            var axShape;
            var data = this.option.data;
            var dataLength = this.option.data.length;
            var tickOption = this.option.axisTick;
            var length = tickOption.length;
            var color = tickOption.lineStyle.color;
            var lineWidth = tickOption.lineStyle.width;
            var intervalFunction = typeof tickOption.interval == 'function' ? tickOption.interval : tickOption.interval == 'auto' ? typeof this.option.axisLabel.interval == 'function' ? this.option.axisLabel.interval : false : false;
            var interval = intervalFunction ? 1 : tickOption.interval == 'auto' ? this._interval : tickOption.interval - 0 + 1;
            var onGap = tickOption.onGap;
            var optGap = onGap ? this.getGap() / 2 : typeof onGap == 'undefined' ? this.option.boundaryGap ? this.getGap() / 2 : 0 : 0;
            var startIndex = optGap > 0 ? -interval : 0;
            if (this.isHorizontal()) {
                var yPosition = this.option.position == 'bottom' ? tickOption.inside ? this.grid.getYend() - length - 1 : this.grid.getYend() + 1 : tickOption.inside ? this.grid.getY() + 1 : this.grid.getY() - length - 1;
                var x;
                for (var i = startIndex; i < dataLength; i += interval) {
                    if (intervalFunction && !intervalFunction(i, data[i])) {
                        continue;
                    }
                    x = this.subPixelOptimize(this.getCoordByIndex(i) + (i >= 0 ? optGap : 0), lineWidth);
                    axShape = {
                        _axisShape: 'axisTick',
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase(),
                        hoverable: false,
                        style: {
                            xStart: x,
                            yStart: yPosition,
                            xEnd: x,
                            yEnd: yPosition + length,
                            strokeColor: color,
                            lineWidth: lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }
            } else {
                var xPosition = this.option.position == 'left' ? tickOption.inside ? this.grid.getX() + 1 : this.grid.getX() - length - 1 : tickOption.inside ? this.grid.getXend() - length - 1 : this.grid.getXend() + 1;
                var y;
                for (var i = startIndex; i < dataLength; i += interval) {
                    if (intervalFunction && !intervalFunction(i, data[i])) {
                        continue;
                    }
                    y = this.subPixelOptimize(this.getCoordByIndex(i) - (i >= 0 ? optGap : 0), lineWidth);
                    axShape = {
                        _axisShape: 'axisTick',
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase(),
                        hoverable: false,
                        style: {
                            xStart: xPosition,
                            yStart: y,
                            xEnd: xPosition + length,
                            yEnd: y,
                            strokeColor: color,
                            lineWidth: lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }
            }
        },
        _buildAxisLabel: function () {
            var axShape;
            var data = this.option.data;
            var dataLength = this.option.data.length;
            var labelOption = this.option.axisLabel;
            var rotate = labelOption.rotate;
            var margin = labelOption.margin;
            var clickable = labelOption.clickable;
            var textStyle = labelOption.textStyle;
            var intervalFunction = typeof labelOption.interval == 'function' ? labelOption.interval : false;
            var dataTextStyle;
            if (this.isHorizontal()) {
                var yPosition;
                var baseLine;
                if (this.option.position == 'bottom') {
                    yPosition = this.grid.getYend() + margin;
                    baseLine = 'top';
                } else {
                    yPosition = this.grid.getY() - margin;
                    baseLine = 'bottom';
                }
                for (var i = 0; i < dataLength; i += this._interval) {
                    if (intervalFunction && !intervalFunction(i, data[i]) || this._getReformedLabel(i) === '') {
                        continue;
                    }
                    dataTextStyle = zrUtil.merge(data[i].textStyle || {}, textStyle);
                    axShape = {
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase() + 3,
                        hoverable: false,
                        style: {
                            x: this.getCoordByIndex(i),
                            y: yPosition,
                            color: dataTextStyle.color,
                            text: this._getReformedLabel(i),
                            textFont: this.getFont(dataTextStyle),
                            textAlign: dataTextStyle.align || 'center',
                            textBaseline: dataTextStyle.baseline || baseLine
                        }
                    };
                    if (rotate) {
                        axShape.style.textAlign = rotate > 0 ? this.option.position == 'bottom' ? 'right' : 'left' : this.option.position == 'bottom' ? 'left' : 'right';
                        axShape.rotation = [
                            rotate * Math.PI / 180,
                            axShape.style.x,
                            axShape.style.y
                        ];
                    }
                    this.shapeList.push(new TextShape(this._axisLabelClickable(clickable, axShape)));
                }
            } else {
                var xPosition;
                var align;
                if (this.option.position == 'left') {
                    xPosition = this.grid.getX() - margin;
                    align = 'right';
                } else {
                    xPosition = this.grid.getXend() + margin;
                    align = 'left';
                }
                for (var i = 0; i < dataLength; i += this._interval) {
                    if (intervalFunction && !intervalFunction(i, data[i]) || this._getReformedLabel(i) === '') {
                        continue;
                    }
                    dataTextStyle = zrUtil.merge(data[i].textStyle || {}, textStyle);
                    axShape = {
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase() + 3,
                        hoverable: false,
                        style: {
                            x: xPosition,
                            y: this.getCoordByIndex(i),
                            color: dataTextStyle.color,
                            text: this._getReformedLabel(i),
                            textFont: this.getFont(dataTextStyle),
                            textAlign: dataTextStyle.align || align,
                            textBaseline: dataTextStyle.baseline || i === 0 && this.option.name !== '' ? 'bottom' : i == dataLength - 1 && this.option.name !== '' ? 'top' : 'middle'
                        }
                    };
                    if (rotate) {
                        axShape.rotation = [
                            rotate * Math.PI / 180,
                            axShape.style.x,
                            axShape.style.y
                        ];
                    }
                    this.shapeList.push(new TextShape(this._axisLabelClickable(clickable, axShape)));
                }
            }
        },
        _buildSplitLine: function () {
            var axShape;
            var data = this.option.data;
            var dataLength = this.option.data.length;
            var sLineOption = this.option.splitLine;
            var lineType = sLineOption.lineStyle.type;
            var lineWidth = sLineOption.lineStyle.width;
            var color = sLineOption.lineStyle.color;
            color = color instanceof Array ? color : [color];
            var colorLength = color.length;
            var intervalFunction = typeof this.option.axisLabel.interval == 'function' ? this.option.axisLabel.interval : false;
            var onGap = sLineOption.onGap;
            var optGap = onGap ? this.getGap() / 2 : typeof onGap == 'undefined' ? this.option.boundaryGap ? this.getGap() / 2 : 0 : 0;
            dataLength -= onGap || typeof onGap == 'undefined' && this.option.boundaryGap ? 1 : 0;
            if (this.isHorizontal()) {
                var sy = this.grid.getY();
                var ey = this.grid.getYend();
                var x;
                for (var i = 0; i < dataLength; i += this._interval) {
                    if (intervalFunction && !intervalFunction(i, data[i])) {
                        continue;
                    }
                    x = this.subPixelOptimize(this.getCoordByIndex(i) + optGap, lineWidth);
                    axShape = {
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase(),
                        hoverable: false,
                        style: {
                            xStart: x,
                            yStart: sy,
                            xEnd: x,
                            yEnd: ey,
                            strokeColor: color[i / this._interval % colorLength],
                            lineType: lineType,
                            lineWidth: lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }
            } else {
                var sx = this.grid.getX();
                var ex = this.grid.getXend();
                var y;
                for (var i = 0; i < dataLength; i += this._interval) {
                    if (intervalFunction && !intervalFunction(i, data[i])) {
                        continue;
                    }
                    y = this.subPixelOptimize(this.getCoordByIndex(i) - optGap, lineWidth);
                    axShape = {
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase(),
                        hoverable: false,
                        style: {
                            xStart: sx,
                            yStart: y,
                            xEnd: ex,
                            yEnd: y,
                            strokeColor: color[i / this._interval % colorLength],
                            lineType: lineType,
                            lineWidth: lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }
            }
        },
        _buildSplitArea: function () {
            var axShape;
            var data = this.option.data;
            var sAreaOption = this.option.splitArea;
            var color = sAreaOption.areaStyle.color;
            if (!(color instanceof Array)) {
                axShape = {
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    hoverable: false,
                    style: {
                        x: this.grid.getX(),
                        y: this.grid.getY(),
                        width: this.grid.getWidth(),
                        height: this.grid.getHeight(),
                        color: color
                    }
                };
                this.shapeList.push(new RectangleShape(axShape));
            } else {
                var colorLength = color.length;
                var dataLength = this.option.data.length;
                var intervalFunction = typeof this.option.axisLabel.interval == 'function' ? this.option.axisLabel.interval : false;
                var onGap = sAreaOption.onGap;
                var optGap = onGap ? this.getGap() / 2 : typeof onGap == 'undefined' ? this.option.boundaryGap ? this.getGap() / 2 : 0 : 0;
                if (this.isHorizontal()) {
                    var y = this.grid.getY();
                    var height = this.grid.getHeight();
                    var lastX = this.grid.getX();
                    var curX;
                    for (var i = 0; i <= dataLength; i += this._interval) {
                        if (intervalFunction && !intervalFunction(i, data[i]) && i < dataLength) {
                            continue;
                        }
                        curX = i < dataLength ? this.getCoordByIndex(i) + optGap : this.grid.getXend();
                        axShape = {
                            zlevel: this.getZlevelBase(),
                            z: this.getZBase(),
                            hoverable: false,
                            style: {
                                x: lastX,
                                y: y,
                                width: curX - lastX,
                                height: height,
                                color: color[i / this._interval % colorLength]
                            }
                        };
                        this.shapeList.push(new RectangleShape(axShape));
                        lastX = curX;
                    }
                } else {
                    var x = this.grid.getX();
                    var width = this.grid.getWidth();
                    var lastYend = this.grid.getYend();
                    var curY;
                    for (var i = 0; i <= dataLength; i += this._interval) {
                        if (intervalFunction && !intervalFunction(i, data[i]) && i < dataLength) {
                            continue;
                        }
                        curY = i < dataLength ? this.getCoordByIndex(i) - optGap : this.grid.getY();
                        axShape = {
                            zlevel: this.getZlevelBase(),
                            z: this.getZBase(),
                            hoverable: false,
                            style: {
                                x: x,
                                y: curY,
                                width: width,
                                height: lastYend - curY,
                                color: color[i / this._interval % colorLength]
                            }
                        };
                        this.shapeList.push(new RectangleShape(axShape));
                        lastYend = curY;
                    }
                }
            }
        },
        refresh: function (newOption) {
            if (newOption) {
                this.option = this.reformOption(newOption);
                this.option.axisLabel.textStyle = this.getTextStyle(this.option.axisLabel.textStyle);
            }
            this.clear();
            this._buildShape();
        },
        getGap: function () {
            var dataLength = this.option.data.length;
            var total = this.isHorizontal() ? this.grid.getWidth() : this.grid.getHeight();
            if (this.option.boundaryGap) {
                return total / dataLength;
            } else {
                return total / (dataLength > 1 ? dataLength - 1 : 1);
            }
        },
        getCoord: function (value) {
            var data = this.option.data;
            var dataLength = data.length;
            var gap = this.getGap();
            var position = this.option.boundaryGap ? gap / 2 : 0;
            for (var i = 0; i < dataLength; i++) {
                if (this.getDataFromOption(data[i]) == value) {
                    if (this.isHorizontal()) {
                        position = this.grid.getX() + position;
                    } else {
                        position = this.grid.getYend() - position;
                    }
                    return position;
                }
                position += gap;
            }
        },
        getCoordByIndex: function (dataIndex) {
            if (dataIndex < 0) {
                if (this.isHorizontal()) {
                    return this.grid.getX();
                } else {
                    return this.grid.getYend();
                }
            } else if (dataIndex > this.option.data.length - 1) {
                if (this.isHorizontal()) {
                    return this.grid.getXend();
                } else {
                    return this.grid.getY();
                }
            } else {
                var gap = this.getGap();
                var position = this.option.boundaryGap ? gap / 2 : 0;
                position += dataIndex * gap;
                if (this.isHorizontal()) {
                    position = this.grid.getX() + position;
                } else {
                    position = this.grid.getYend() - position;
                }
                return position;
            }
        },
        getNameByIndex: function (dataIndex) {
            return this.getDataFromOption(this.option.data[dataIndex]);
        },
        getIndexByName: function (name) {
            var data = this.option.data;
            var dataLength = data.length;
            for (var i = 0; i < dataLength; i++) {
                if (this.getDataFromOption(data[i]) == name) {
                    return i;
                }
            }
            return -1;
        },
        getValueFromCoord: function () {
            return '';
        },
        isMainAxis: function (dataIndex) {
            return dataIndex % this._interval === 0;
        }
    };
    zrUtil.inherits(CategoryAxis, Base);
    require('../component').define('categoryAxis', CategoryAxis);
    return CategoryAxis;
});define('echarts/component/valueAxis', [
    'require',
    './base',
    'zrender/shape/Text',
    'zrender/shape/Line',
    'zrender/shape/Rectangle',
    '../config',
    '../util/date',
    'zrender/tool/util',
    '../util/smartSteps',
    '../util/accMath',
    '../component'
], function (require) {
    var Base = require('./base');
    var TextShape = require('zrender/shape/Text');
    var LineShape = require('zrender/shape/Line');
    var RectangleShape = require('zrender/shape/Rectangle');
    var ecConfig = require('../config');
    ecConfig.valueAxis = {
        zlevel: 0,
        z: 0,
        show: true,
        position: 'left',
        name: '',
        nameLocation: 'end',
        nameTextStyle: {},
        boundaryGap: [
            0,
            0
        ],
        axisLine: {
            show: true,
            onZero: true,
            lineStyle: {
                color: '#48b',
                width: 2,
                type: 'solid'
            }
        },
        axisTick: {
            show: false,
            inside: false,
            length: 5,
            lineStyle: {
                color: '#333',
                width: 1
            }
        },
        axisLabel: {
            show: true,
            rotate: 0,
            margin: 8,
            textStyle: { color: '#333' }
        },
        splitLine: {
            show: true,
            lineStyle: {
                color: ['#ccc'],
                width: 1,
                type: 'solid'
            }
        },
        splitArea: {
            show: false,
            areaStyle: {
                color: [
                    'rgba(250,250,250,0.3)',
                    'rgba(200,200,200,0.3)'
                ]
            }
        }
    };
    var ecDate = require('../util/date');
    var zrUtil = require('zrender/tool/util');
    function ValueAxis(ecTheme, messageCenter, zr, option, myChart, axisBase, series) {
        if (!series || series.length === 0) {
            console.err('option.series.length == 0.');
            return;
        }
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.series = series;
        this.grid = this.component.grid;
        for (var method in axisBase) {
            this[method] = axisBase[method];
        }
        this.refresh(option, series);
    }
    ValueAxis.prototype = {
        type: ecConfig.COMPONENT_TYPE_AXIS_VALUE,
        _buildShape: function () {
            this._hasData = false;
            this._calculateValue();
            if (!this._hasData || !this.option.show) {
                return;
            }
            this.option.splitArea.show && this._buildSplitArea();
            this.option.splitLine.show && this._buildSplitLine();
            this.option.axisLine.show && this._buildAxisLine();
            this.option.axisTick.show && this._buildAxisTick();
            this.option.axisLabel.show && this._buildAxisLabel();
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                this.zr.addShape(this.shapeList[i]);
            }
        },
        _buildAxisTick: function () {
            var axShape;
            var data = this._valueList;
            var dataLength = this._valueList.length;
            var tickOption = this.option.axisTick;
            var length = tickOption.length;
            var color = tickOption.lineStyle.color;
            var lineWidth = tickOption.lineStyle.width;
            if (this.isHorizontal()) {
                var yPosition = this.option.position === 'bottom' ? tickOption.inside ? this.grid.getYend() - length - 1 : this.grid.getYend() + 1 : tickOption.inside ? this.grid.getY() + 1 : this.grid.getY() - length - 1;
                var x;
                for (var i = 0; i < dataLength; i++) {
                    x = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);
                    axShape = {
                        _axisShape: 'axisTick',
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase(),
                        hoverable: false,
                        style: {
                            xStart: x,
                            yStart: yPosition,
                            xEnd: x,
                            yEnd: yPosition + length,
                            strokeColor: color,
                            lineWidth: lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }
            } else {
                var xPosition = this.option.position === 'left' ? tickOption.inside ? this.grid.getX() + 1 : this.grid.getX() - length - 1 : tickOption.inside ? this.grid.getXend() - length - 1 : this.grid.getXend() + 1;
                var y;
                for (var i = 0; i < dataLength; i++) {
                    y = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);
                    axShape = {
                        _axisShape: 'axisTick',
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase(),
                        hoverable: false,
                        style: {
                            xStart: xPosition,
                            yStart: y,
                            xEnd: xPosition + length,
                            yEnd: y,
                            strokeColor: color,
                            lineWidth: lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }
            }
        },
        _buildAxisLabel: function () {
            var axShape;
            var data = this._valueList;
            var dataLength = this._valueList.length;
            var rotate = this.option.axisLabel.rotate;
            var margin = this.option.axisLabel.margin;
            var clickable = this.option.axisLabel.clickable;
            var textStyle = this.option.axisLabel.textStyle;
            if (this.isHorizontal()) {
                var yPosition;
                var baseLine;
                if (this.option.position === 'bottom') {
                    yPosition = this.grid.getYend() + margin;
                    baseLine = 'top';
                } else {
                    yPosition = this.grid.getY() - margin;
                    baseLine = 'bottom';
                }
                for (var i = 0; i < dataLength; i++) {
                    axShape = {
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase() + 3,
                        hoverable: false,
                        style: {
                            x: this.getCoord(data[i]),
                            y: yPosition,
                            color: typeof textStyle.color === 'function' ? textStyle.color(data[i]) : textStyle.color,
                            text: this._valueLabel[i],
                            textFont: this.getFont(textStyle),
                            textAlign: textStyle.align || 'center',
                            textBaseline: textStyle.baseline || baseLine
                        }
                    };
                    if (rotate) {
                        axShape.style.textAlign = rotate > 0 ? this.option.position === 'bottom' ? 'right' : 'left' : this.option.position === 'bottom' ? 'left' : 'right';
                        axShape.rotation = [
                            rotate * Math.PI / 180,
                            axShape.style.x,
                            axShape.style.y
                        ];
                    }
                    this.shapeList.push(new TextShape(this._axisLabelClickable(clickable, axShape)));
                }
            } else {
                var xPosition;
                var align;
                if (this.option.position === 'left') {
                    xPosition = this.grid.getX() - margin;
                    align = 'right';
                } else {
                    xPosition = this.grid.getXend() + margin;
                    align = 'left';
                }
                for (var i = 0; i < dataLength; i++) {
                    axShape = {
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase() + 3,
                        hoverable: false,
                        style: {
                            x: xPosition,
                            y: this.getCoord(data[i]),
                            color: typeof textStyle.color === 'function' ? textStyle.color(data[i]) : textStyle.color,
                            text: this._valueLabel[i],
                            textFont: this.getFont(textStyle),
                            textAlign: textStyle.align || align,
                            textBaseline: textStyle.baseline || (i === 0 && this.option.name !== '' ? 'bottom' : i === dataLength - 1 && this.option.name !== '' ? 'top' : 'middle')
                        }
                    };
                    if (rotate) {
                        axShape.rotation = [
                            rotate * Math.PI / 180,
                            axShape.style.x,
                            axShape.style.y
                        ];
                    }
                    this.shapeList.push(new TextShape(this._axisLabelClickable(clickable, axShape)));
                }
            }
        },
        _buildSplitLine: function () {
            var axShape;
            var data = this._valueList;
            var dataLength = this._valueList.length;
            var sLineOption = this.option.splitLine;
            var lineType = sLineOption.lineStyle.type;
            var lineWidth = sLineOption.lineStyle.width;
            var color = sLineOption.lineStyle.color;
            color = color instanceof Array ? color : [color];
            var colorLength = color.length;
            if (this.isHorizontal()) {
                var sy = this.grid.getY();
                var ey = this.grid.getYend();
                var x;
                for (var i = 0; i < dataLength; i++) {
                    x = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);
                    axShape = {
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase(),
                        hoverable: false,
                        style: {
                            xStart: x,
                            yStart: sy,
                            xEnd: x,
                            yEnd: ey,
                            strokeColor: color[i % colorLength],
                            lineType: lineType,
                            lineWidth: lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }
            } else {
                var sx = this.grid.getX();
                var ex = this.grid.getXend();
                var y;
                for (var i = 0; i < dataLength; i++) {
                    y = this.subPixelOptimize(this.getCoord(data[i]), lineWidth);
                    axShape = {
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase(),
                        hoverable: false,
                        style: {
                            xStart: sx,
                            yStart: y,
                            xEnd: ex,
                            yEnd: y,
                            strokeColor: color[i % colorLength],
                            lineType: lineType,
                            lineWidth: lineWidth
                        }
                    };
                    this.shapeList.push(new LineShape(axShape));
                }
            }
        },
        _buildSplitArea: function () {
            var axShape;
            var color = this.option.splitArea.areaStyle.color;
            if (!(color instanceof Array)) {
                axShape = {
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    hoverable: false,
                    style: {
                        x: this.grid.getX(),
                        y: this.grid.getY(),
                        width: this.grid.getWidth(),
                        height: this.grid.getHeight(),
                        color: color
                    }
                };
                this.shapeList.push(new RectangleShape(axShape));
            } else {
                var colorLength = color.length;
                var data = this._valueList;
                var dataLength = this._valueList.length;
                if (this.isHorizontal()) {
                    var y = this.grid.getY();
                    var height = this.grid.getHeight();
                    var lastX = this.grid.getX();
                    var curX;
                    for (var i = 0; i <= dataLength; i++) {
                        curX = i < dataLength ? this.getCoord(data[i]) : this.grid.getXend();
                        axShape = {
                            zlevel: this.getZlevelBase(),
                            z: this.getZBase(),
                            hoverable: false,
                            style: {
                                x: lastX,
                                y: y,
                                width: curX - lastX,
                                height: height,
                                color: color[i % colorLength]
                            }
                        };
                        this.shapeList.push(new RectangleShape(axShape));
                        lastX = curX;
                    }
                } else {
                    var x = this.grid.getX();
                    var width = this.grid.getWidth();
                    var lastYend = this.grid.getYend();
                    var curY;
                    for (var i = 0; i <= dataLength; i++) {
                        curY = i < dataLength ? this.getCoord(data[i]) : this.grid.getY();
                        axShape = {
                            zlevel: this.getZlevelBase(),
                            z: this.getZBase(),
                            hoverable: false,
                            style: {
                                x: x,
                                y: curY,
                                width: width,
                                height: lastYend - curY,
                                color: color[i % colorLength]
                            }
                        };
                        this.shapeList.push(new RectangleShape(axShape));
                        lastYend = curY;
                    }
                }
            }
        },
        _calculateValue: function () {
            if (isNaN(this.option.min - 0) || isNaN(this.option.max - 0)) {
                var data = {};
                var xIdx;
                var yIdx;
                var legend = this.component.legend;
                for (var i = 0, l = this.series.length; i < l; i++) {
                    if (this.series[i].type != ecConfig.CHART_TYPE_LINE && this.series[i].type != ecConfig.CHART_TYPE_BAR && this.series[i].type != ecConfig.CHART_TYPE_SCATTER && this.series[i].type != ecConfig.CHART_TYPE_K && this.series[i].type != ecConfig.CHART_TYPE_EVENTRIVER) {
                        continue;
                    }
                    if (legend && !legend.isSelected(this.series[i].name)) {
                        continue;
                    }
                    xIdx = this.series[i].xAxisIndex || 0;
                    yIdx = this.series[i].yAxisIndex || 0;
                    if (this.option.xAxisIndex != xIdx && this.option.yAxisIndex != yIdx) {
                        continue;
                    }
                    this._calculSum(data, i);
                }
                var oriData;
                for (var i in data) {
                    oriData = data[i];
                    for (var j = 0, k = oriData.length; j < k; j++) {
                        if (!isNaN(oriData[j])) {
                            this._hasData = true;
                            this._min = oriData[j];
                            this._max = oriData[j];
                            break;
                        }
                    }
                    if (this._hasData) {
                        break;
                    }
                }
                for (var i in data) {
                    oriData = data[i];
                    for (var j = 0, k = oriData.length; j < k; j++) {
                        if (!isNaN(oriData[j])) {
                            this._min = Math.min(this._min, oriData[j]);
                            this._max = Math.max(this._max, oriData[j]);
                        }
                    }
                }
                var gap = Math.abs(this._max - this._min);
                this._min = isNaN(this.option.min - 0) ? this._min - Math.abs(gap * this.option.boundaryGap[0]) : this.option.min - 0;
                this._max = isNaN(this.option.max - 0) ? this._max + Math.abs(gap * this.option.boundaryGap[1]) : this.option.max - 0;
                if (this._min === this._max) {
                    if (this._max === 0) {
                        this._max = 1;
                    } else if (this._max > 0) {
                        this._min = this._max / this.option.splitNumber != null ? this.option.splitNumber : 5;
                    } else {
                        this._max = this._max / this.option.splitNumber != null ? this.option.splitNumber : 5;
                    }
                }
                this.option.type != 'time' ? this._reformValue(this.option.scale) : this._reformTimeValue();
            } else {
                this._hasData = true;
                this._min = this.option.min - 0;
                this._max = this.option.max - 0;
                this.option.type != 'time' ? this._customerValue() : this._reformTimeValue();
            }
        },
        _calculSum: function (data, i) {
            var key = this.series[i].name || 'kener';
            var value;
            var oriData;
            if (!this.series[i].stack) {
                data[key] = data[key] || [];
                if (this.series[i].type != ecConfig.CHART_TYPE_EVENTRIVER) {
                    oriData = this.series[i].data;
                    for (var j = 0, k = oriData.length; j < k; j++) {
                        value = this.getDataFromOption(oriData[j]);
                        if (this.series[i].type === ecConfig.CHART_TYPE_K) {
                            data[key].push(value[0]);
                            data[key].push(value[1]);
                            data[key].push(value[2]);
                            data[key].push(value[3]);
                        } else if (value instanceof Array) {
                            if (this.option.xAxisIndex != -1) {
                                data[key].push(this.option.type != 'time' ? value[0] : ecDate.getNewDate(value[0]));
                            }
                            if (this.option.yAxisIndex != -1) {
                                data[key].push(this.option.type != 'time' ? value[1] : ecDate.getNewDate(value[1]));
                            }
                        } else {
                            data[key].push(value);
                        }
                    }
                } else {
                    oriData = this.series[i].data;
                    for (var j = 0, k = oriData.length; j < k; j++) {
                        var evolution = oriData[j].evolution;
                        for (var m = 0, n = evolution.length; m < n; m++) {
                            data[key].push(ecDate.getNewDate(evolution[m].time));
                        }
                    }
                }
            } else {
                var keyP = '__Magic_Key_Positive__' + this.series[i].stack;
                var keyN = '__Magic_Key_Negative__' + this.series[i].stack;
                data[keyP] = data[keyP] || [];
                data[keyN] = data[keyN] || [];
                data[key] = data[key] || [];
                oriData = this.series[i].data;
                for (var j = 0, k = oriData.length; j < k; j++) {
                    value = this.getDataFromOption(oriData[j]);
                    if (value === '-') {
                        continue;
                    }
                    value = value - 0;
                    if (value >= 0) {
                        if (data[keyP][j] != null) {
                            data[keyP][j] += value;
                        } else {
                            data[keyP][j] = value;
                        }
                    } else {
                        if (data[keyN][j] != null) {
                            data[keyN][j] += value;
                        } else {
                            data[keyN][j] = value;
                        }
                    }
                    if (this.option.scale) {
                        data[key].push(value);
                    }
                }
            }
        },
        _reformValue: function (scale) {
            var smartSteps = require('../util/smartSteps');
            var splitNumber = this.option.splitNumber;
            if (!scale && this._min >= 0 && this._max >= 0) {
                this._min = 0;
            }
            if (!scale && this._min <= 0 && this._max <= 0) {
                this._max = 0;
            }
            var stepOpt = smartSteps(this._min, this._max, splitNumber);
            splitNumber = splitNumber != null ? splitNumber : stepOpt.secs;
            this._min = stepOpt.min;
            this._max = stepOpt.max;
            this._valueList = stepOpt.pnts;
            this._reformLabelData();
        },
        _reformTimeValue: function () {
            var splitNumber = this.option.splitNumber != null ? this.option.splitNumber : 5;
            var curValue = ecDate.getAutoFormatter(this._min, this._max, splitNumber);
            var formatter = curValue.formatter;
            var gapValue = curValue.gapValue;
            this._valueList = [ecDate.getNewDate(this._min)];
            var startGap;
            switch (formatter) {
            case 'week':
                startGap = ecDate.nextMonday(this._min);
                break;
            case 'month':
                startGap = ecDate.nextNthOnMonth(this._min, 1);
                break;
            case 'quarter':
                startGap = ecDate.nextNthOnQuarterYear(this._min, 1);
                break;
            case 'half-year':
                startGap = ecDate.nextNthOnHalfYear(this._min, 1);
                break;
            case 'year':
                startGap = ecDate.nextNthOnYear(this._min, 1);
                break;
            default:
                if (gapValue <= 3600000 * 2) {
                    startGap = (Math.floor(this._min / gapValue) + 1) * gapValue;
                } else {
                    startGap = ecDate.getNewDate(this._min - -gapValue);
                    startGap.setHours(Math.round(startGap.getHours() / 6) * 6);
                    startGap.setMinutes(0);
                    startGap.setSeconds(0);
                }
                break;
            }
            if (startGap - this._min < gapValue / 2) {
                startGap -= -gapValue;
            }
            curValue = ecDate.getNewDate(startGap);
            splitNumber *= 1.5;
            while (splitNumber-- >= 0) {
                if (formatter == 'month' || formatter == 'quarter' || formatter == 'half-year' || formatter == 'year') {
                    curValue.setDate(1);
                }
                if (this._max - curValue < gapValue / 2) {
                    break;
                }
                this._valueList.push(curValue);
                curValue = ecDate.getNewDate(curValue - -gapValue);
            }
            this._valueList.push(ecDate.getNewDate(this._max));
            this._reformLabelData(formatter);
        },
        _customerValue: function () {
            var accMath = require('../util/accMath');
            var splitNumber = this.option.splitNumber != null ? this.option.splitNumber : 5;
            var splitGap = (this._max - this._min) / splitNumber;
            this._valueList = [];
            for (var i = 0; i <= splitNumber; i++) {
                this._valueList.push(accMath.accAdd(this._min, accMath.accMul(splitGap, i)));
            }
            this._reformLabelData();
        },
        _reformLabelData: function (timeFormatter) {
            this._valueLabel = [];
            var formatter = this.option.axisLabel.formatter;
            if (formatter) {
                for (var i = 0, l = this._valueList.length; i < l; i++) {
                    if (typeof formatter === 'function') {
                        this._valueLabel.push(timeFormatter ? formatter.call(this.myChart, this._valueList[i], timeFormatter) : formatter.call(this.myChart, this._valueList[i]));
                    } else if (typeof formatter === 'string') {
                        this._valueLabel.push(timeFormatter ? ecDate.format(formatter, this._valueList[i]) : formatter.replace('{value}', this._valueList[i]));
                    }
                }
            } else if (timeFormatter) {
                for (var i = 0, l = this._valueList.length; i < l; i++) {
                    this._valueLabel.push(ecDate.format(timeFormatter, this._valueList[i]));
                }
            } else {
                for (var i = 0, l = this._valueList.length; i < l; i++) {
                    this._valueLabel.push(this.numAddCommas(this._valueList[i]));
                }
            }
        },
        getExtremum: function () {
            this._calculateValue();
            return {
                min: this._min,
                max: this._max
            };
        },
        refresh: function (newOption, newSeries) {
            if (newOption) {
                this.option = this.reformOption(newOption);
                this.option.axisLabel.textStyle = zrUtil.merge(this.option.axisLabel.textStyle || {}, this.ecTheme.textStyle);
                this.series = newSeries;
            }
            if (this.zr) {
                this.clear();
                this._buildShape();
            }
        },
        getCoord: function (value) {
            value = value < this._min ? this._min : value;
            value = value > this._max ? this._max : value;
            var result;
            if (!this.isHorizontal()) {
                result = this.grid.getYend() - (value - this._min) / (this._max - this._min) * this.grid.getHeight();
            } else {
                result = this.grid.getX() + (value - this._min) / (this._max - this._min) * this.grid.getWidth();
            }
            return result;
        },
        getCoordSize: function (value) {
            if (!this.isHorizontal()) {
                return Math.abs(value / (this._max - this._min) * this.grid.getHeight());
            } else {
                return Math.abs(value / (this._max - this._min) * this.grid.getWidth());
            }
        },
        getValueFromCoord: function (coord) {
            var result;
            if (!this.isHorizontal()) {
                coord = coord < this.grid.getY() ? this.grid.getY() : coord;
                coord = coord > this.grid.getYend() ? this.grid.getYend() : coord;
                result = this._max - (coord - this.grid.getY()) / this.grid.getHeight() * (this._max - this._min);
            } else {
                coord = coord < this.grid.getX() ? this.grid.getX() : coord;
                coord = coord > this.grid.getXend() ? this.grid.getXend() : coord;
                result = this._min + (coord - this.grid.getX()) / this.grid.getWidth() * (this._max - this._min);
            }
            return result.toFixed(2) - 0;
        },
        isMaindAxis: function (value) {
            for (var i = 0, l = this._valueList.length; i < l; i++) {
                if (this._valueList[i] === value) {
                    return true;
                }
            }
            return false;
        }
    };
    zrUtil.inherits(ValueAxis, Base);
    require('../component').define('valueAxis', ValueAxis);
    return ValueAxis;
});define('echarts/util/date', [], function () {
    var _timeGap = [
        {
            formatter: 'hh : mm : ss',
            value: 1000
        },
        {
            formatter: 'hh : mm : ss',
            value: 1000 * 5
        },
        {
            formatter: 'hh : mm : ss',
            value: 1000 * 10
        },
        {
            formatter: 'hh : mm : ss',
            value: 1000 * 15
        },
        {
            formatter: 'hh : mm : ss',
            value: 1000 * 30
        },
        {
            formatter: 'hh : mm\nMM - dd',
            value: 60000
        },
        {
            formatter: 'hh : mm\nMM - dd',
            value: 60000 * 5
        },
        {
            formatter: 'hh : mm\nMM - dd',
            value: 60000 * 10
        },
        {
            formatter: 'hh : mm\nMM - dd',
            value: 60000 * 15
        },
        {
            formatter: 'hh : mm\nMM - dd',
            value: 60000 * 30
        },
        {
            formatter: 'hh : mm\nMM - dd',
            value: 3600000
        },
        {
            formatter: 'hh : mm\nMM - dd',
            value: 3600000 * 2
        },
        {
            formatter: 'hh : mm\nMM - dd',
            value: 3600000 * 6
        },
        {
            formatter: 'hh : mm\nMM - dd',
            value: 3600000 * 12
        },
        {
            formatter: 'MM - dd\nyyyy',
            value: 3600000 * 24
        },
        {
            formatter: 'week',
            value: 3600000 * 24 * 7
        },
        {
            formatter: 'month',
            value: 3600000 * 24 * 31
        },
        {
            formatter: 'quarter',
            value: 3600000 * 24 * 380 / 4
        },
        {
            formatter: 'half-year',
            value: 3600000 * 24 * 380 / 2
        },
        {
            formatter: 'year',
            value: 3600000 * 24 * 380
        }
    ];
    function getAutoFormatter(min, max, splitNumber) {
        splitNumber = splitNumber > 1 ? splitNumber : 2;
        var curValue;
        var totalGap;
        var formatter;
        var gapValue;
        for (var i = 0, l = _timeGap.length; i < l; i++) {
            curValue = _timeGap[i].value;
            totalGap = Math.ceil(max / curValue) * curValue - Math.floor(min / curValue) * curValue;
            if (Math.round(totalGap / curValue) <= splitNumber * 1.2) {
                formatter = _timeGap[i].formatter;
                gapValue = _timeGap[i].value;
                break;
            }
        }
        if (formatter == null) {
            formatter = 'year';
            curValue = 3600000 * 24 * 367;
            totalGap = Math.ceil(max / curValue) * curValue - Math.floor(min / curValue) * curValue;
            gapValue = Math.round(totalGap / (splitNumber - 1) / curValue) * curValue;
        }
        return {
            formatter: formatter,
            gapValue: gapValue
        };
    }
    function s2d(v) {
        return v < 10 ? '0' + v : v;
    }
    function format(formatter, value) {
        if (formatter == 'week' || formatter == 'month' || formatter == 'quarter' || formatter == 'half-year' || formatter == 'year') {
            formatter = 'MM - dd\nyyyy';
        }
        var date = getNewDate(value);
        var y = date.getFullYear();
        var M = date.getMonth() + 1;
        var d = date.getDate();
        var h = date.getHours();
        var m = date.getMinutes();
        var s = date.getSeconds();
        formatter = formatter.replace('MM', s2d(M));
        formatter = formatter.toLowerCase();
        formatter = formatter.replace('yyyy', y);
        formatter = formatter.replace('yy', y % 100);
        formatter = formatter.replace('dd', s2d(d));
        formatter = formatter.replace('d', d);
        formatter = formatter.replace('hh', s2d(h));
        formatter = formatter.replace('h', h);
        formatter = formatter.replace('mm', s2d(m));
        formatter = formatter.replace('m', m);
        formatter = formatter.replace('ss', s2d(s));
        formatter = formatter.replace('s', s);
        return formatter;
    }
    function nextMonday(value) {
        value = getNewDate(value);
        value.setDate(value.getDate() + 8 - value.getDay());
        return value;
    }
    function nextNthPerNmonth(value, nth, nmon) {
        value = getNewDate(value);
        value.setMonth(Math.ceil((value.getMonth() + 1) / nmon) * nmon);
        value.setDate(nth);
        return value;
    }
    function nextNthOnMonth(value, nth) {
        return nextNthPerNmonth(value, nth, 1);
    }
    function nextNthOnQuarterYear(value, nth) {
        return nextNthPerNmonth(value, nth, 3);
    }
    function nextNthOnHalfYear(value, nth) {
        return nextNthPerNmonth(value, nth, 6);
    }
    function nextNthOnYear(value, nth) {
        return nextNthPerNmonth(value, nth, 12);
    }
    function getNewDate(value) {
        return value instanceof Date ? value : new Date(typeof value == 'string' ? value.replace(/-/g, '/') : value);
    }
    return {
        getAutoFormatter: getAutoFormatter,
        getNewDate: getNewDate,
        format: format,
        nextMonday: nextMonday,
        nextNthPerNmonth: nextNthPerNmonth,
        nextNthOnMonth: nextNthOnMonth,
        nextNthOnQuarterYear: nextNthOnQuarterYear,
        nextNthOnHalfYear: nextNthOnHalfYear,
        nextNthOnYear: nextNthOnYear
    };
});define('echarts/util/smartSteps', [], function () {
    var mySteps = [
        10,
        20,
        25,
        50
    ];
    var mySections = [
        4,
        5,
        6
    ];
    var custOpts;
    var custSteps;
    var custSecs;
    var minLocked;
    var maxLocked;
    var MT = Math;
    var MATH_ROUND = MT.round;
    var MATH_FLOOR = MT.floor;
    var MATH_CEIL = MT.ceil;
    var MATH_ABS = MT.abs;
    function MATH_LOG(n) {
        return MT.log(MATH_ABS(n)) / MT.LN10;
    }
    function MATH_POW(n) {
        return MT.pow(10, n);
    }
    function MATH_ISINT(n) {
        return n === MATH_FLOOR(n);
    }
    function smartSteps(min, max, section, opts) {
        custOpts = opts || {};
        custSteps = custOpts.steps || mySteps;
        custSecs = custOpts.secs || mySections;
        section = MATH_ROUND(+section || 0) % 99;
        min = +min || 0;
        max = +max || 0;
        minLocked = maxLocked = 0;
        if ('min' in custOpts) {
            min = +custOpts.min || 0;
            minLocked = 1;
        }
        if ('max' in custOpts) {
            max = +custOpts.max || 0;
            maxLocked = 1;
        }
        if (min > max) {
            max = [
                min,
                min = max
            ][0];
        }
        var span = max - min;
        if (minLocked && maxLocked) {
            return bothLocked(min, max, section);
        }
        if (span < (section || 5)) {
            if (MATH_ISINT(min) && MATH_ISINT(max)) {
                return forInteger(min, max, section);
            } else if (span === 0) {
                return forSpan0(min, max, section);
            }
        }
        return coreCalc(min, max, section);
    }
    function makeResult(newMin, newMax, section, expon) {
        expon = expon || 0;
        var expStep = expNum((newMax - newMin) / section, -1);
        var expMin = expNum(newMin, -1, 1);
        var expMax = expNum(newMax, -1);
        var minExp = MT.min(expStep.e, expMin.e, expMax.e);
        if (expMin.c === 0) {
            minExp = MT.min(expStep.e, expMax.e);
        } else if (expMax.c === 0) {
            minExp = MT.min(expStep.e, expMin.e);
        }
        expFixTo(expStep, {
            c: 0,
            e: minExp
        });
        expFixTo(expMin, expStep, 1);
        expFixTo(expMax, expStep);
        expon += minExp;
        newMin = expMin.c;
        newMax = expMax.c;
        var step = (newMax - newMin) / section;
        var zoom = MATH_POW(expon);
        var fixTo = 0;
        var points = [];
        for (var i = section + 1; i--;) {
            points[i] = (newMin + step * i) * zoom;
        }
        if (expon < 0) {
            fixTo = decimals(zoom);
            step = +(step * zoom).toFixed(fixTo);
            newMin = +(newMin * zoom).toFixed(fixTo);
            newMax = +(newMax * zoom).toFixed(fixTo);
            for (var i = points.length; i--;) {
                points[i] = points[i].toFixed(fixTo);
                +points[i] === 0 && (points[i] = '0');
            }
        } else {
            newMin *= zoom;
            newMax *= zoom;
            step *= zoom;
        }
        custSecs = 0;
        custSteps = 0;
        custOpts = 0;
        return {
            min: newMin,
            max: newMax,
            secs: section,
            step: step,
            fix: fixTo,
            exp: expon,
            pnts: points
        };
    }
    function expNum(num, digit, byFloor) {
        digit = MATH_ROUND(digit % 10) || 2;
        if (digit < 0) {
            if (MATH_ISINT(num)) {
                digit = ('' + MATH_ABS(num)).replace(/0+$/, '').length || 1;
            } else {
                num = num.toFixed(15).replace(/0+$/, '');
                digit = num.replace('.', '').replace(/^[-0]+/, '').length;
                num = +num;
            }
        }
        var expon = MATH_FLOOR(MATH_LOG(num)) - digit + 1;
        var cNum = +(num * MATH_POW(-expon)).toFixed(15) || 0;
        cNum = byFloor ? MATH_FLOOR(cNum) : MATH_CEIL(cNum);
        !cNum && (expon = 0);
        if (('' + MATH_ABS(cNum)).length > digit) {
            expon += 1;
            cNum /= 10;
        }
        return {
            c: cNum,
            e: expon
        };
    }
    function expFixTo(expnum1, expnum2, byFloor) {
        var deltaExp = expnum2.e - expnum1.e;
        if (deltaExp) {
            expnum1.e += deltaExp;
            expnum1.c *= MATH_POW(-deltaExp);
            expnum1.c = byFloor ? MATH_FLOOR(expnum1.c) : MATH_CEIL(expnum1.c);
        }
    }
    function expFixMin(expnum1, expnum2, byFloor) {
        if (expnum1.e < expnum2.e) {
            expFixTo(expnum2, expnum1, byFloor);
        } else {
            expFixTo(expnum1, expnum2, byFloor);
        }
    }
    function getCeil(num, rounds) {
        rounds = rounds || mySteps;
        num = expNum(num);
        var cNum = num.c;
        var i = 0;
        while (cNum > rounds[i]) {
            i++;
        }
        if (!rounds[i]) {
            cNum /= 10;
            num.e += 1;
            i = 0;
            while (cNum > rounds[i]) {
                i++;
            }
        }
        num.c = rounds[i];
        return num;
    }
    function coreCalc(min, max, section) {
        var step;
        var secs = section || +custSecs.slice(-1);
        var expStep = getCeil((max - min) / secs, custSteps);
        var expSpan = expNum(max - min);
        var expMin = expNum(min, -1, 1);
        var expMax = expNum(max, -1);
        expFixTo(expSpan, expStep);
        expFixTo(expMin, expStep, 1);
        expFixTo(expMax, expStep);
        if (!section) {
            secs = look4sections(expMin, expMax);
        } else {
            step = look4step(expMin, expMax, secs);
        }
        if (MATH_ISINT(min) && MATH_ISINT(max) && min * max >= 0) {
            if (max - min < secs) {
                return forInteger(min, max, secs);
            }
            secs = tryForInt(min, max, section, expMin, expMax, secs);
        }
        var arrMM = cross0(min, max, expMin.c, expMax.c);
        expMin.c = arrMM[0];
        expMax.c = arrMM[1];
        if (minLocked || maxLocked) {
            singleLocked(min, max, expMin, expMax);
        }
        return makeResult(expMin.c, expMax.c, secs, expMax.e);
    }
    function look4sections(expMin, expMax) {
        var section;
        var tmpStep, tmpMin, tmpMax;
        var reference = [];
        for (var i = custSecs.length; i--;) {
            section = custSecs[i];
            tmpStep = getCeil((expMax.c - expMin.c) / section, custSteps);
            tmpStep = tmpStep.c * MATH_POW(tmpStep.e);
            tmpMin = MATH_FLOOR(expMin.c / tmpStep) * tmpStep;
            tmpMax = MATH_CEIL(expMax.c / tmpStep) * tmpStep;
            reference[i] = {
                min: tmpMin,
                max: tmpMax,
                step: tmpStep,
                span: tmpMax - tmpMin
            };
        }
        reference.sort(function (a, b) {
            var delta = a.span - b.span;
            if (delta === 0) {
                delta = a.step - b.step;
            }
            return delta;
        });
        reference = reference[0];
        section = reference.span / reference.step;
        expMin.c = reference.min;
        expMax.c = reference.max;
        return section < 3 ? section * 2 : section;
    }
    function look4step(expMin, expMax, secs) {
        var span;
        var tmpMax;
        var tmpMin = expMax.c;
        var tmpStep = (expMax.c - expMin.c) / secs - 1;
        while (tmpMin > expMin.c) {
            tmpStep = getCeil(tmpStep + 1, custSteps);
            tmpStep = tmpStep.c * MATH_POW(tmpStep.e);
            span = tmpStep * secs;
            tmpMax = MATH_CEIL(expMax.c / tmpStep) * tmpStep;
            tmpMin = tmpMax - span;
        }
        var deltaMin = expMin.c - tmpMin;
        var deltaMax = tmpMax - expMax.c;
        var deltaDelta = deltaMin - deltaMax;
        if (deltaDelta > tmpStep * 1.1) {
            deltaDelta = MATH_ROUND(deltaDelta / tmpStep / 2) * tmpStep;
            tmpMin += deltaDelta;
            tmpMax += deltaDelta;
        }
        expMin.c = tmpMin;
        expMax.c = tmpMax;
        return tmpStep;
    }
    function tryForInt(min, max, section, expMin, expMax, secs) {
        var span = expMax.c - expMin.c;
        var step = span / secs * MATH_POW(expMax.e);
        if (!MATH_ISINT(step)) {
            step = MATH_FLOOR(step);
            span = step * secs;
            if (span < max - min) {
                step += 1;
                span = step * secs;
                if (!section && step * (secs - 1) >= max - min) {
                    secs -= 1;
                    span = step * secs;
                }
            }
            if (span >= max - min) {
                var delta = span - (max - min);
                expMin.c = MATH_ROUND(min - delta / 2);
                expMax.c = MATH_ROUND(max + delta / 2);
                expMin.e = 0;
                expMax.e = 0;
            }
        }
        return secs;
    }
    function forInteger(min, max, section) {
        section = section || 5;
        if (minLocked) {
            max = min + section;
        } else if (maxLocked) {
            min = max - section;
        } else {
            var delta = section - (max - min);
            var newMin = MATH_ROUND(min - delta / 2);
            var newMax = MATH_ROUND(max + delta / 2);
            var arrMM = cross0(min, max, newMin, newMax);
            min = arrMM[0];
            max = arrMM[1];
        }
        return makeResult(min, max, section);
    }
    function forSpan0(min, max, section) {
        section = section || 5;
        var delta = MT.min(MATH_ABS(max / section), section) / 2.1;
        if (minLocked) {
            max = min + delta;
        } else if (maxLocked) {
            min = max - delta;
        } else {
            min = min - delta;
            max = max + delta;
        }
        return coreCalc(min, max, section);
    }
    function cross0(min, max, newMin, newMax) {
        if (min >= 0 && newMin < 0) {
            newMax -= newMin;
            newMin = 0;
        } else if (max <= 0 && newMax > 0) {
            newMin -= newMax;
            newMax = 0;
        }
        return [
            newMin,
            newMax
        ];
    }
    function decimals(num) {
        num = (+num).toFixed(15).split('.');
        return num.pop().replace(/0+$/, '').length;
    }
    function singleLocked(min, max, emin, emax) {
        if (minLocked) {
            var expMin = expNum(min, 4, 1);
            if (emin.e - expMin.e > 6) {
                expMin = {
                    c: 0,
                    e: emin.e
                };
            }
            expFixMin(emin, expMin);
            expFixMin(emax, expMin);
            emax.c += expMin.c - emin.c;
            emin.c = expMin.c;
        } else if (maxLocked) {
            var expMax = expNum(max, 4);
            if (emax.e - expMax.e > 6) {
                expMax = {
                    c: 0,
                    e: emax.e
                };
            }
            expFixMin(emin, expMax);
            expFixMin(emax, expMax);
            emin.c += expMax.c - emax.c;
            emax.c = expMax.c;
        }
    }
    function bothLocked(min, max, section) {
        var trySecs = section ? [section] : custSecs;
        var span = max - min;
        if (span === 0) {
            max = expNum(max, 3);
            section = trySecs[0];
            max.c = MATH_ROUND(max.c + section / 2);
            return makeResult(max.c - section, max.c, section, max.e);
        }
        if (MATH_ABS(max / span) < 0.000001) {
            max = 0;
        }
        if (MATH_ABS(min / span) < 0.000001) {
            min = 0;
        }
        var step, deltaSpan, score;
        var scoreS = [
            [
                5,
                10
            ],
            [
                10,
                2
            ],
            [
                50,
                10
            ],
            [
                100,
                2
            ]
        ];
        var reference = [];
        var debugLog = [];
        var expSpan = expNum(max - min, 3);
        var expMin = expNum(min, -1, 1);
        var expMax = expNum(max, -1);
        expFixTo(expMin, expSpan, 1);
        expFixTo(expMax, expSpan);
        span = expMax.c - expMin.c;
        expSpan.c = span;
        for (var i = trySecs.length; i--;) {
            section = trySecs[i];
            step = MATH_CEIL(span / section);
            deltaSpan = step * section - span;
            score = (deltaSpan + 3) * 3;
            score += (section - trySecs[0] + 2) * 2;
            if (section % 5 === 0) {
                score -= 10;
            }
            for (var j = scoreS.length; j--;) {
                if (step % scoreS[j][0] === 0) {
                    score /= scoreS[j][1];
                }
            }
            debugLog[i] = [
                section,
                step,
                deltaSpan,
                score
            ].join();
            reference[i] = {
                secs: section,
                step: step,
                delta: deltaSpan,
                score: score
            };
        }
        reference.sort(function (a, b) {
            return a.score - b.score;
        });
        reference = reference[0];
        expMin.c = MATH_ROUND(expMin.c - reference.delta / 2);
        expMax.c = MATH_ROUND(expMax.c + reference.delta / 2);
        return makeResult(expMin.c, expMax.c, reference.secs, expSpan.e);
    }
    return smartSteps;
});define('echarts/chart/line', [
    'require',
    './base',
    'zrender/shape/Polyline',
    '../util/shape/Icon',
    '../util/shape/HalfSmoothPolygon',
    '../component/axis',
    '../component/grid',
    '../component/dataZoom',
    '../config',
    '../util/ecData',
    'zrender/tool/util',
    'zrender/tool/color',
    '../chart'
], function (require) {
    var ChartBase = require('./base');
    var PolylineShape = require('zrender/shape/Polyline');
    var IconShape = require('../util/shape/Icon');
    var HalfSmoothPolygonShape = require('../util/shape/HalfSmoothPolygon');
    require('../component/axis');
    require('../component/grid');
    require('../component/dataZoom');
    var ecConfig = require('../config');
    ecConfig.line = {
        zlevel: 0,
        z: 2,
        clickable: true,
        legendHoverLink: true,
        xAxisIndex: 0,
        yAxisIndex: 0,
        dataFilter: 'nearest',
        itemStyle: {
            normal: {
                label: { show: false },
                lineStyle: {
                    width: 2,
                    type: 'solid',
                    shadowColor: 'rgba(0,0,0,0)',
                    shadowBlur: 0,
                    shadowOffsetX: 0,
                    shadowOffsetY: 0
                }
            },
            emphasis: { label: { show: false } }
        },
        symbolSize: 2,
        showAllSymbol: false
    };
    var ecData = require('../util/ecData');
    var zrUtil = require('zrender/tool/util');
    var zrColor = require('zrender/tool/color');
    function Line(ecTheme, messageCenter, zr, option, myChart) {
        ChartBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.refresh(option);
    }
    Line.prototype = {
        type: ecConfig.CHART_TYPE_LINE,
        _buildShape: function () {
            this.finalPLMap = {};
            this._buildPosition();
        },
        _buildHorizontal: function (seriesArray, maxDataLength, locationMap, xMarkMap) {
            var series = this.series;
            var seriesIndex = locationMap[0][0];
            var serie = series[seriesIndex];
            var categoryAxis = this.component.xAxis.getAxis(serie.xAxisIndex || 0);
            var valueAxis;
            var x;
            var y;
            var lastYP;
            var baseYP;
            var lastYN;
            var baseYN;
            var curPLMap = {};
            var data;
            var value;
            for (var i = 0, l = maxDataLength; i < l; i++) {
                if (categoryAxis.getNameByIndex(i) == null) {
                    break;
                }
                x = categoryAxis.getCoordByIndex(i);
                for (var j = 0, k = locationMap.length; j < k; j++) {
                    valueAxis = this.component.yAxis.getAxis(series[locationMap[j][0]].yAxisIndex || 0);
                    baseYP = lastYP = baseYN = lastYN = valueAxis.getCoord(0);
                    for (var m = 0, n = locationMap[j].length; m < n; m++) {
                        seriesIndex = locationMap[j][m];
                        serie = series[seriesIndex];
                        data = serie.data[i];
                        value = this.getDataFromOption(data, '-');
                        curPLMap[seriesIndex] = curPLMap[seriesIndex] || [];
                        xMarkMap[seriesIndex] = xMarkMap[seriesIndex] || {
                            min: Number.POSITIVE_INFINITY,
                            max: Number.NEGATIVE_INFINITY,
                            sum: 0,
                            counter: 0,
                            average: 0
                        };
                        if (value === '-') {
                            if (curPLMap[seriesIndex].length > 0) {
                                this.finalPLMap[seriesIndex] = this.finalPLMap[seriesIndex] || [];
                                this.finalPLMap[seriesIndex].push(curPLMap[seriesIndex]);
                                curPLMap[seriesIndex] = [];
                            }
                            continue;
                        }
                        if (value >= 0) {
                            lastYP -= m > 0 ? valueAxis.getCoordSize(value) : baseYP - valueAxis.getCoord(value);
                            y = lastYP;
                        } else if (value < 0) {
                            lastYN += m > 0 ? valueAxis.getCoordSize(value) : valueAxis.getCoord(value) - baseYN;
                            y = lastYN;
                        }
                        curPLMap[seriesIndex].push([
                            x,
                            y,
                            i,
                            categoryAxis.getNameByIndex(i),
                            x,
                            baseYP
                        ]);
                        if (xMarkMap[seriesIndex].min > value) {
                            xMarkMap[seriesIndex].min = value;
                            xMarkMap[seriesIndex].minY = y;
                            xMarkMap[seriesIndex].minX = x;
                        }
                        if (xMarkMap[seriesIndex].max < value) {
                            xMarkMap[seriesIndex].max = value;
                            xMarkMap[seriesIndex].maxY = y;
                            xMarkMap[seriesIndex].maxX = x;
                        }
                        xMarkMap[seriesIndex].sum += value;
                        xMarkMap[seriesIndex].counter++;
                    }
                }
                lastYP = this.component.grid.getY();
                var symbolSize;
                for (var j = 0, k = locationMap.length; j < k; j++) {
                    for (var m = 0, n = locationMap[j].length; m < n; m++) {
                        seriesIndex = locationMap[j][m];
                        serie = series[seriesIndex];
                        data = serie.data[i];
                        value = this.getDataFromOption(data, '-');
                        if (value != '-') {
                            continue;
                        }
                        if (this.deepQuery([
                                data,
                                serie,
                                this.option
                            ], 'calculable')) {
                            symbolSize = this.deepQuery([
                                data,
                                serie
                            ], 'symbolSize');
                            lastYP += symbolSize * 2 + 5;
                            y = lastYP;
                            this.shapeList.push(this._getCalculableItem(seriesIndex, i, categoryAxis.getNameByIndex(i), x, y, 'horizontal'));
                        }
                    }
                }
            }
            for (var sId in curPLMap) {
                if (curPLMap[sId].length > 0) {
                    this.finalPLMap[sId] = this.finalPLMap[sId] || [];
                    this.finalPLMap[sId].push(curPLMap[sId]);
                    curPLMap[sId] = [];
                }
            }
            this._calculMarkMapXY(xMarkMap, locationMap, 'y');
            this._buildBorkenLine(seriesArray, this.finalPLMap, categoryAxis, 'horizontal');
        },
        _buildVertical: function (seriesArray, maxDataLength, locationMap, xMarkMap) {
            var series = this.series;
            var seriesIndex = locationMap[0][0];
            var serie = series[seriesIndex];
            var categoryAxis = this.component.yAxis.getAxis(serie.yAxisIndex || 0);
            var valueAxis;
            var x;
            var y;
            var lastXP;
            var baseXP;
            var lastXN;
            var baseXN;
            var curPLMap = {};
            var data;
            var value;
            for (var i = 0, l = maxDataLength; i < l; i++) {
                if (categoryAxis.getNameByIndex(i) == null) {
                    break;
                }
                y = categoryAxis.getCoordByIndex(i);
                for (var j = 0, k = locationMap.length; j < k; j++) {
                    valueAxis = this.component.xAxis.getAxis(series[locationMap[j][0]].xAxisIndex || 0);
                    baseXP = lastXP = baseXN = lastXN = valueAxis.getCoord(0);
                    for (var m = 0, n = locationMap[j].length; m < n; m++) {
                        seriesIndex = locationMap[j][m];
                        serie = series[seriesIndex];
                        data = serie.data[i];
                        value = this.getDataFromOption(data, '-');
                        curPLMap[seriesIndex] = curPLMap[seriesIndex] || [];
                        xMarkMap[seriesIndex] = xMarkMap[seriesIndex] || {
                            min: Number.POSITIVE_INFINITY,
                            max: Number.NEGATIVE_INFINITY,
                            sum: 0,
                            counter: 0,
                            average: 0
                        };
                        if (value === '-') {
                            if (curPLMap[seriesIndex].length > 0) {
                                this.finalPLMap[seriesIndex] = this.finalPLMap[seriesIndex] || [];
                                this.finalPLMap[seriesIndex].push(curPLMap[seriesIndex]);
                                curPLMap[seriesIndex] = [];
                            }
                            continue;
                        }
                        if (value >= 0) {
                            lastXP += m > 0 ? valueAxis.getCoordSize(value) : valueAxis.getCoord(value) - baseXP;
                            x = lastXP;
                        } else if (value < 0) {
                            lastXN -= m > 0 ? valueAxis.getCoordSize(value) : baseXN - valueAxis.getCoord(value);
                            x = lastXN;
                        }
                        curPLMap[seriesIndex].push([
                            x,
                            y,
                            i,
                            categoryAxis.getNameByIndex(i),
                            baseXP,
                            y
                        ]);
                        if (xMarkMap[seriesIndex].min > value) {
                            xMarkMap[seriesIndex].min = value;
                            xMarkMap[seriesIndex].minX = x;
                            xMarkMap[seriesIndex].minY = y;
                        }
                        if (xMarkMap[seriesIndex].max < value) {
                            xMarkMap[seriesIndex].max = value;
                            xMarkMap[seriesIndex].maxX = x;
                            xMarkMap[seriesIndex].maxY = y;
                        }
                        xMarkMap[seriesIndex].sum += value;
                        xMarkMap[seriesIndex].counter++;
                    }
                }
                lastXP = this.component.grid.getXend();
                var symbolSize;
                for (var j = 0, k = locationMap.length; j < k; j++) {
                    for (var m = 0, n = locationMap[j].length; m < n; m++) {
                        seriesIndex = locationMap[j][m];
                        serie = series[seriesIndex];
                        data = serie.data[i];
                        value = this.getDataFromOption(data, '-');
                        if (value != '-') {
                            continue;
                        }
                        if (this.deepQuery([
                                data,
                                serie,
                                this.option
                            ], 'calculable')) {
                            symbolSize = this.deepQuery([
                                data,
                                serie
                            ], 'symbolSize');
                            lastXP -= symbolSize * 2 + 5;
                            x = lastXP;
                            this.shapeList.push(this._getCalculableItem(seriesIndex, i, categoryAxis.getNameByIndex(i), x, y, 'vertical'));
                        }
                    }
                }
            }
            for (var sId in curPLMap) {
                if (curPLMap[sId].length > 0) {
                    this.finalPLMap[sId] = this.finalPLMap[sId] || [];
                    this.finalPLMap[sId].push(curPLMap[sId]);
                    curPLMap[sId] = [];
                }
            }
            this._calculMarkMapXY(xMarkMap, locationMap, 'x');
            this._buildBorkenLine(seriesArray, this.finalPLMap, categoryAxis, 'vertical');
        },
        _buildOther: function (seriesArray, maxDataLength, locationMap, xMarkMap) {
            var series = this.series;
            var curPLMap = {};
            var xAxis;
            for (var j = 0, k = locationMap.length; j < k; j++) {
                for (var m = 0, n = locationMap[j].length; m < n; m++) {
                    var seriesIndex = locationMap[j][m];
                    var serie = series[seriesIndex];
                    xAxis = this.component.xAxis.getAxis(serie.xAxisIndex || 0);
                    var yAxis = this.component.yAxis.getAxis(serie.yAxisIndex || 0);
                    var baseY = yAxis.getCoord(0);
                    curPLMap[seriesIndex] = curPLMap[seriesIndex] || [];
                    xMarkMap[seriesIndex] = xMarkMap[seriesIndex] || {
                        min0: Number.POSITIVE_INFINITY,
                        min1: Number.POSITIVE_INFINITY,
                        max0: Number.NEGATIVE_INFINITY,
                        max1: Number.NEGATIVE_INFINITY,
                        sum0: 0,
                        sum1: 0,
                        counter0: 0,
                        counter1: 0,
                        average0: 0,
                        average1: 0
                    };
                    for (var i = 0, l = serie.data.length; i < l; i++) {
                        var data = serie.data[i];
                        var value = this.getDataFromOption(data, '-');
                        if (!(value instanceof Array)) {
                            continue;
                        }
                        var x = xAxis.getCoord(value[0]);
                        var y = yAxis.getCoord(value[1]);
                        curPLMap[seriesIndex].push([
                            x,
                            y,
                            i,
                            value[0],
                            x,
                            baseY
                        ]);
                        if (xMarkMap[seriesIndex].min0 > value[0]) {
                            xMarkMap[seriesIndex].min0 = value[0];
                            xMarkMap[seriesIndex].minY0 = y;
                            xMarkMap[seriesIndex].minX0 = x;
                        }
                        if (xMarkMap[seriesIndex].max0 < value[0]) {
                            xMarkMap[seriesIndex].max0 = value[0];
                            xMarkMap[seriesIndex].maxY0 = y;
                            xMarkMap[seriesIndex].maxX0 = x;
                        }
                        xMarkMap[seriesIndex].sum0 += value[0];
                        xMarkMap[seriesIndex].counter0++;
                        if (xMarkMap[seriesIndex].min1 > value[1]) {
                            xMarkMap[seriesIndex].min1 = value[1];
                            xMarkMap[seriesIndex].minY1 = y;
                            xMarkMap[seriesIndex].minX1 = x;
                        }
                        if (xMarkMap[seriesIndex].max1 < value[1]) {
                            xMarkMap[seriesIndex].max1 = value[1];
                            xMarkMap[seriesIndex].maxY1 = y;
                            xMarkMap[seriesIndex].maxX1 = x;
                        }
                        xMarkMap[seriesIndex].sum1 += value[1];
                        xMarkMap[seriesIndex].counter1++;
                    }
                }
            }
            for (var sId in curPLMap) {
                if (curPLMap[sId].length > 0) {
                    this.finalPLMap[sId] = this.finalPLMap[sId] || [];
                    this.finalPLMap[sId].push(curPLMap[sId]);
                    curPLMap[sId] = [];
                }
            }
            this._calculMarkMapXY(xMarkMap, locationMap, 'xy');
            this._buildBorkenLine(seriesArray, this.finalPLMap, xAxis, 'other');
        },
        _buildBorkenLine: function (seriesArray, pointList, categoryAxis, curOrient) {
            var orient = curOrient == 'other' ? 'horizontal' : curOrient;
            var series = this.series;
            var data;
            for (var sIdx = seriesArray.length - 1; sIdx >= 0; sIdx--) {
                var seriesIndex = seriesArray[sIdx];
                var serie = series[seriesIndex];
                var seriesPL = pointList[seriesIndex];
                if (serie.type === this.type && seriesPL != null) {
                    var bbox = this._getBbox(seriesIndex, orient);
                    var defaultColor = this._sIndex2ColorMap[seriesIndex];
                    var lineWidth = this.query(serie, 'itemStyle.normal.lineStyle.width');
                    var lineType = this.query(serie, 'itemStyle.normal.lineStyle.type');
                    var lineColor = this.query(serie, 'itemStyle.normal.lineStyle.color');
                    var normalColor = this.getItemStyleColor(this.query(serie, 'itemStyle.normal.color'), seriesIndex, -1);
                    var isFill = this.query(serie, 'itemStyle.normal.areaStyle') != null;
                    var fillNormalColor = this.query(serie, 'itemStyle.normal.areaStyle.color');
                    for (var i = 0, l = seriesPL.length; i < l; i++) {
                        var singlePL = seriesPL[i];
                        var isLarge = curOrient != 'other' && this._isLarge(orient, singlePL);
                        if (!isLarge) {
                            for (var j = 0, k = singlePL.length; j < k; j++) {
                                data = serie.data[singlePL[j][2]];
                                if (this.deepQuery([
                                        data,
                                        serie,
                                        this.option
                                    ], 'calculable') || this.deepQuery([
                                        data,
                                        serie
                                    ], 'showAllSymbol') || categoryAxis.type === 'categoryAxis' && categoryAxis.isMainAxis(singlePL[j][2]) && this.deepQuery([
                                        data,
                                        serie
                                    ], 'symbol') != 'none') {
                                    this.shapeList.push(this._getSymbol(seriesIndex, singlePL[j][2], singlePL[j][3], singlePL[j][0], singlePL[j][1], orient));
                                }
                            }
                        } else {
                            singlePL = this._getLargePointList(orient, singlePL, serie.dataFilter);
                        }
                        var polylineShape = new PolylineShape({
                            zlevel: this.getZlevelBase(),
                            z: this.getZBase(),
                            style: {
                                miterLimit: lineWidth,
                                pointList: singlePL,
                                strokeColor: lineColor || normalColor || defaultColor,
                                lineWidth: lineWidth,
                                lineType: lineType,
                                smooth: this._getSmooth(serie.smooth),
                                smoothConstraint: bbox,
                                shadowColor: this.query(serie, 'itemStyle.normal.lineStyle.shadowColor'),
                                shadowBlur: this.query(serie, 'itemStyle.normal.lineStyle.shadowBlur'),
                                shadowOffsetX: this.query(serie, 'itemStyle.normal.lineStyle.shadowOffsetX'),
                                shadowOffsetY: this.query(serie, 'itemStyle.normal.lineStyle.shadowOffsetY')
                            },
                            hoverable: false,
                            _main: true,
                            _seriesIndex: seriesIndex,
                            _orient: orient
                        });
                        ecData.pack(polylineShape, series[seriesIndex], seriesIndex, 0, i, series[seriesIndex].name);
                        this.shapeList.push(polylineShape);
                        if (isFill) {
                            var halfSmoothPolygonShape = new HalfSmoothPolygonShape({
                                zlevel: this.getZlevelBase(),
                                z: this.getZBase(),
                                style: {
                                    miterLimit: lineWidth,
                                    pointList: zrUtil.clone(singlePL).concat([
                                        [
                                            singlePL[singlePL.length - 1][4],
                                            singlePL[singlePL.length - 1][5]
                                        ],
                                        [
                                            singlePL[0][4],
                                            singlePL[0][5]
                                        ]
                                    ]),
                                    brushType: 'fill',
                                    smooth: this._getSmooth(serie.smooth),
                                    smoothConstraint: bbox,
                                    color: fillNormalColor ? fillNormalColor : zrColor.alpha(defaultColor, 0.5)
                                },
                                highlightStyle: { brushType: 'fill' },
                                hoverable: false,
                                _main: true,
                                _seriesIndex: seriesIndex,
                                _orient: orient
                            });
                            ecData.pack(halfSmoothPolygonShape, series[seriesIndex], seriesIndex, 0, i, series[seriesIndex].name);
                            this.shapeList.push(halfSmoothPolygonShape);
                        }
                    }
                }
            }
        },
        _getBbox: function (seriesIndex, orient) {
            var bbox = this.component.grid.getBbox();
            var xMarkMap = this.xMarkMap[seriesIndex];
            if (xMarkMap.minX0 != null) {
                return [
                    [
                        Math.min(xMarkMap.minX0, xMarkMap.maxX0, xMarkMap.minX1, xMarkMap.maxX1),
                        Math.min(xMarkMap.minY0, xMarkMap.maxY0, xMarkMap.minY1, xMarkMap.maxY1)
                    ],
                    [
                        Math.max(xMarkMap.minX0, xMarkMap.maxX0, xMarkMap.minX1, xMarkMap.maxX1),
                        Math.max(xMarkMap.minY0, xMarkMap.maxY0, xMarkMap.minY1, xMarkMap.maxY1)
                    ]
                ];
            } else if (orient === 'horizontal') {
                bbox[0][1] = Math.min(xMarkMap.minY, xMarkMap.maxY);
                bbox[1][1] = Math.max(xMarkMap.minY, xMarkMap.maxY);
            } else {
                bbox[0][0] = Math.min(xMarkMap.minX, xMarkMap.maxX);
                bbox[1][0] = Math.max(xMarkMap.minX, xMarkMap.maxX);
            }
            return bbox;
        },
        _isLarge: function (orient, singlePL) {
            if (singlePL.length < 2) {
                return false;
            } else {
                return orient === 'horizontal' ? Math.abs(singlePL[0][0] - singlePL[1][0]) < 0.5 : Math.abs(singlePL[0][1] - singlePL[1][1]) < 0.5;
            }
        },
        _getLargePointList: function (orient, singlePL, filter) {
            var total;
            if (orient === 'horizontal') {
                total = this.component.grid.getWidth();
            } else {
                total = this.component.grid.getHeight();
            }
            var len = singlePL.length;
            var newList = [];
            if (typeof filter != 'function') {
                switch (filter) {
                case 'min':
                    filter = function (arr) {
                        return Math.max.apply(null, arr);
                    };
                    break;
                case 'max':
                    filter = function (arr) {
                        return Math.min.apply(null, arr);
                    };
                    break;
                case 'average':
                    filter = function (arr) {
                        var total = 0;
                        for (var i = 0; i < arr.length; i++) {
                            total += arr[i];
                        }
                        return total / arr.length;
                    };
                    break;
                default:
                    filter = function (arr) {
                        return arr[0];
                    };
                }
            }
            var windowData = [];
            for (var i = 0; i < total; i++) {
                var idx0 = Math.floor(len / total * i);
                var idx1 = Math.min(Math.floor(len / total * (i + 1)), len);
                if (idx1 <= idx0) {
                    continue;
                }
                for (var j = idx0; j < idx1; j++) {
                    windowData[j - idx0] = orient === 'horizontal' ? singlePL[j][1] : singlePL[j][0];
                }
                windowData.length = idx1 - idx0;
                var filteredVal = filter(windowData);
                var nearestIdx = -1;
                var minDist = Infinity;
                for (var j = idx0; j < idx1; j++) {
                    var val = orient === 'horizontal' ? singlePL[j][1] : singlePL[j][0];
                    var dist = Math.abs(val - filteredVal);
                    if (dist < minDist) {
                        nearestIdx = j;
                        minDist = dist;
                    }
                }
                var newItem = singlePL[nearestIdx].slice();
                if (orient === 'horizontal') {
                    newItem[1] = filteredVal;
                } else {
                    newItem[0] = filteredVal;
                }
                newList.push(newItem);
            }
            return newList;
        },
        _getSmooth: function (isSmooth) {
            if (isSmooth) {
                return 0.3;
            } else {
                return 0;
            }
        },
        _getCalculableItem: function (seriesIndex, dataIndex, name, x, y, orient) {
            var series = this.series;
            var color = series[seriesIndex].calculableHolderColor || this.ecTheme.calculableHolderColor || ecConfig.calculableHolderColor;
            var itemShape = this._getSymbol(seriesIndex, dataIndex, name, x, y, orient);
            itemShape.style.color = color;
            itemShape.style.strokeColor = color;
            itemShape.rotation = [
                0,
                0
            ];
            itemShape.hoverable = false;
            itemShape.draggable = false;
            itemShape.style.text = undefined;
            return itemShape;
        },
        _getSymbol: function (seriesIndex, dataIndex, name, x, y, orient) {
            var series = this.series;
            var serie = series[seriesIndex];
            var data = serie.data[dataIndex];
            var itemShape = this.getSymbolShape(serie, seriesIndex, data, dataIndex, name, x, y, this._sIndex2ShapeMap[seriesIndex], this._sIndex2ColorMap[seriesIndex], '#fff', orient === 'vertical' ? 'horizontal' : 'vertical');
            itemShape.zlevel = this.getZlevelBase();
            itemShape.z = this.getZBase() + 1;
            if (this.deepQuery([
                    data,
                    serie,
                    this.option
                ], 'calculable')) {
                this.setCalculable(itemShape);
                itemShape.draggable = true;
            }
            return itemShape;
        },
        getMarkCoord: function (seriesIndex, mpData) {
            var serie = this.series[seriesIndex];
            var xMarkMap = this.xMarkMap[seriesIndex];
            var xAxis = this.component.xAxis.getAxis(serie.xAxisIndex);
            var yAxis = this.component.yAxis.getAxis(serie.yAxisIndex);
            if (mpData.type && (mpData.type === 'max' || mpData.type === 'min' || mpData.type === 'average')) {
                var valueIndex = mpData.valueIndex != null ? mpData.valueIndex : xMarkMap.maxX0 != null ? '1' : '';
                return [
                    xMarkMap[mpData.type + 'X' + valueIndex],
                    xMarkMap[mpData.type + 'Y' + valueIndex],
                    xMarkMap[mpData.type + 'Line' + valueIndex],
                    xMarkMap[mpData.type + valueIndex]
                ];
            }
            return [
                typeof mpData.xAxis != 'string' && xAxis.getCoordByIndex ? xAxis.getCoordByIndex(mpData.xAxis || 0) : xAxis.getCoord(mpData.xAxis || 0),
                typeof mpData.yAxis != 'string' && yAxis.getCoordByIndex ? yAxis.getCoordByIndex(mpData.yAxis || 0) : yAxis.getCoord(mpData.yAxis || 0)
            ];
        },
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.series = newOption.series;
            }
            this.backupShapeList();
            this._buildShape();
        },
        ontooltipHover: function (param, tipShape) {
            var seriesIndex = param.seriesIndex;
            var dataIndex = param.dataIndex;
            var seriesPL;
            var singlePL;
            var len = seriesIndex.length;
            while (len--) {
                seriesPL = this.finalPLMap[seriesIndex[len]];
                if (seriesPL) {
                    for (var i = 0, l = seriesPL.length; i < l; i++) {
                        singlePL = seriesPL[i];
                        for (var j = 0, k = singlePL.length; j < k; j++) {
                            if (dataIndex === singlePL[j][2]) {
                                tipShape.push(this._getSymbol(seriesIndex[len], singlePL[j][2], singlePL[j][3], singlePL[j][0], singlePL[j][1], 'horizontal'));
                            }
                        }
                    }
                }
            }
        },
        addDataAnimation: function (params, done) {
            var series = this.series;
            var aniMap = {};
            for (var i = 0, l = params.length; i < l; i++) {
                aniMap[params[i][0]] = params[i];
            }
            var x;
            var dx;
            var y;
            var dy;
            var seriesIndex;
            var pointList;
            var isHorizontal;
            var aniCount = 0;
            function animationDone() {
                aniCount--;
                if (aniCount === 0) {
                    done && done();
                }
            }
            function animationDuring(target) {
                target.style.controlPointList = null;
            }
            for (var i = this.shapeList.length - 1; i >= 0; i--) {
                seriesIndex = this.shapeList[i]._seriesIndex;
                if (aniMap[seriesIndex] && !aniMap[seriesIndex][3]) {
                    if (this.shapeList[i]._main && this.shapeList[i].style.pointList.length > 1) {
                        pointList = this.shapeList[i].style.pointList;
                        dx = Math.abs(pointList[0][0] - pointList[1][0]);
                        dy = Math.abs(pointList[0][1] - pointList[1][1]);
                        isHorizontal = this.shapeList[i]._orient === 'horizontal';
                        if (aniMap[seriesIndex][2]) {
                            if (this.shapeList[i].type === 'half-smooth-polygon') {
                                var len = pointList.length;
                                this.shapeList[i].style.pointList[len - 3] = pointList[len - 2];
                                this.shapeList[i].style.pointList[len - 3][isHorizontal ? 0 : 1] = pointList[len - 4][isHorizontal ? 0 : 1];
                                this.shapeList[i].style.pointList[len - 2] = pointList[len - 1];
                            }
                            this.shapeList[i].style.pointList.pop();
                            isHorizontal ? (x = dx, y = 0) : (x = 0, y = -dy);
                        } else {
                            this.shapeList[i].style.pointList.shift();
                            if (this.shapeList[i].type === 'half-smooth-polygon') {
                                var targetPoint = this.shapeList[i].style.pointList.pop();
                                isHorizontal ? targetPoint[0] = pointList[0][0] : targetPoint[1] = pointList[0][1];
                                this.shapeList[i].style.pointList.push(targetPoint);
                            }
                            isHorizontal ? (x = -dx, y = 0) : (x = 0, y = dy);
                        }
                        this.shapeList[i].style.controlPointList = null;
                        this.zr.modShape(this.shapeList[i]);
                    } else {
                        if (aniMap[seriesIndex][2] && this.shapeList[i]._dataIndex === series[seriesIndex].data.length - 1) {
                            this.zr.delShape(this.shapeList[i].id);
                            continue;
                        } else if (!aniMap[seriesIndex][2] && this.shapeList[i]._dataIndex === 0) {
                            this.zr.delShape(this.shapeList[i].id);
                            continue;
                        }
                    }
                    this.shapeList[i].position = [
                        0,
                        0
                    ];
                    aniCount++;
                    this.zr.animate(this.shapeList[i].id, '').when(this.query(this.option, 'animationDurationUpdate'), {
                        position: [
                            x,
                            y
                        ]
                    }).during(animationDuring).done(animationDone).start();
                }
            }
            if (!aniCount) {
                animationDone();
            }
        }
    };
    function legendLineIcon(ctx, style, refreshNextFrame) {
        var x = style.x;
        var y = style.y;
        var width = style.width;
        var height = style.height;
        var dy = height / 2;
        if (style.symbol.match('empty')) {
            ctx.fillStyle = '#fff';
        }
        style.brushType = 'both';
        var symbol = style.symbol.replace('empty', '').toLowerCase();
        if (symbol.match('star')) {
            dy = symbol.replace('star', '') - 0 || 5;
            y -= 1;
            symbol = 'star';
        } else if (symbol === 'rectangle' || symbol === 'arrow') {
            x += (width - height) / 2;
            width = height;
        }
        var imageLocation = '';
        if (symbol.match('image')) {
            imageLocation = symbol.replace(new RegExp('^image:\\/\\/'), '');
            symbol = 'image';
            x += Math.round((width - height) / 2) - 1;
            width = height = height + 2;
        }
        symbol = IconShape.prototype.iconLibrary[symbol];
        if (symbol) {
            var x2 = style.x;
            var y2 = style.y;
            ctx.moveTo(x2, y2 + dy);
            ctx.lineTo(x2 + 5, y2 + dy);
            ctx.moveTo(x2 + style.width - 5, y2 + dy);
            ctx.lineTo(x2 + style.width, y2 + dy);
            var self = this;
            symbol(ctx, {
                x: x + 4,
                y: y + 4,
                width: width - 8,
                height: height - 8,
                n: dy,
                image: imageLocation
            }, function () {
                self.modSelf();
                refreshNextFrame();
            });
        } else {
            ctx.moveTo(x, y + dy);
            ctx.lineTo(x + width, y + dy);
        }
    }
    IconShape.prototype.iconLibrary['legendLineIcon'] = legendLineIcon;
    zrUtil.inherits(Line, ChartBase);
    require('../chart').define('line', Line);
    return Line;
});define('echarts/util/shape/HalfSmoothPolygon', [
    'require',
    'zrender/shape/Base',
    'zrender/shape/util/smoothBezier',
    'zrender/tool/util',
    'zrender/shape/Polygon'
], function (require) {
    var Base = require('zrender/shape/Base');
    var smoothBezier = require('zrender/shape/util/smoothBezier');
    var zrUtil = require('zrender/tool/util');
    function HalfSmoothPolygon(options) {
        Base.call(this, options);
    }
    HalfSmoothPolygon.prototype = {
        type: 'half-smooth-polygon',
        buildPath: function (ctx, style) {
            var pointList = style.pointList;
            if (pointList.length < 2) {
                return;
            }
            if (style.smooth) {
                var controlPoints = smoothBezier(pointList.slice(0, -2), style.smooth, false, style.smoothConstraint);
                ctx.moveTo(pointList[0][0], pointList[0][1]);
                var cp1;
                var cp2;
                var p;
                var l = pointList.length;
                for (var i = 0; i < l - 3; i++) {
                    cp1 = controlPoints[i * 2];
                    cp2 = controlPoints[i * 2 + 1];
                    p = pointList[i + 1];
                    ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
                }
                ctx.lineTo(pointList[l - 2][0], pointList[l - 2][1]);
                ctx.lineTo(pointList[l - 1][0], pointList[l - 1][1]);
                ctx.lineTo(pointList[0][0], pointList[0][1]);
            } else {
                require('zrender/shape/Polygon').prototype.buildPath(ctx, style);
            }
            return;
        }
    };
    zrUtil.inherits(HalfSmoothPolygon, Base);
    return HalfSmoothPolygon;
});define('echarts/chart/bar', [
    'require',
    './base',
    'zrender/shape/Rectangle',
    '../component/axis',
    '../component/grid',
    '../component/dataZoom',
    '../config',
    '../util/ecData',
    'zrender/tool/util',
    'zrender/tool/color',
    '../chart'
], function (require) {
    var ChartBase = require('./base');
    var RectangleShape = require('zrender/shape/Rectangle');
    require('../component/axis');
    require('../component/grid');
    require('../component/dataZoom');
    var ecConfig = require('../config');
    ecConfig.bar = {
        zlevel: 0,
        z: 2,
        clickable: true,
        legendHoverLink: true,
        xAxisIndex: 0,
        yAxisIndex: 0,
        barMinHeight: 0,
        barGap: '30%',
        barCategoryGap: '20%',
        itemStyle: {
            normal: {
                barBorderColor: '#fff',
                barBorderRadius: 0,
                barBorderWidth: 0,
                label: { show: false }
            },
            emphasis: {
                barBorderColor: '#fff',
                barBorderRadius: 0,
                barBorderWidth: 0,
                label: { show: false }
            }
        }
    };
    var ecData = require('../util/ecData');
    var zrUtil = require('zrender/tool/util');
    var zrColor = require('zrender/tool/color');
    function Bar(ecTheme, messageCenter, zr, option, myChart) {
        ChartBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.refresh(option);
    }
    Bar.prototype = {
        type: ecConfig.CHART_TYPE_BAR,
        _buildShape: function () {
            this._buildPosition();
        },
        _buildNormal: function (seriesArray, maxDataLength, locationMap, xMarkMap, orient) {
            var series = this.series;
            var seriesIndex = locationMap[0][0];
            var serie = series[seriesIndex];
            var isHorizontal = orient == 'horizontal';
            var xAxis = this.component.xAxis;
            var yAxis = this.component.yAxis;
            var categoryAxis = isHorizontal ? xAxis.getAxis(serie.xAxisIndex) : yAxis.getAxis(serie.yAxisIndex);
            var valueAxis;
            var size = this._mapSize(categoryAxis, locationMap);
            var gap = size.gap;
            var barGap = size.barGap;
            var barWidthMap = size.barWidthMap;
            var barMaxWidthMap = size.barMaxWidthMap;
            var barWidth = size.barWidth;
            var barMinHeightMap = size.barMinHeightMap;
            var barHeight;
            var curBarWidth;
            var interval = size.interval;
            var x;
            var y;
            var lastP;
            var baseP;
            var lastN;
            var baseN;
            var barShape;
            var data;
            var value;
            var islandR = this.deepQuery([
                this.ecTheme,
                ecConfig
            ], 'island.r');
            for (var i = 0, l = maxDataLength; i < l; i++) {
                if (categoryAxis.getNameByIndex(i) == null) {
                    break;
                }
                isHorizontal ? x = categoryAxis.getCoordByIndex(i) - gap / 2 : y = categoryAxis.getCoordByIndex(i) + gap / 2;
                for (var j = 0, k = locationMap.length; j < k; j++) {
                    var yAxisIndex = series[locationMap[j][0]].yAxisIndex || 0;
                    var xAxisIndex = series[locationMap[j][0]].xAxisIndex || 0;
                    valueAxis = isHorizontal ? yAxis.getAxis(yAxisIndex) : xAxis.getAxis(xAxisIndex);
                    baseP = lastP = baseN = lastN = valueAxis.getCoord(0);
                    for (var m = 0, n = locationMap[j].length; m < n; m++) {
                        seriesIndex = locationMap[j][m];
                        serie = series[seriesIndex];
                        data = serie.data[i];
                        value = this.getDataFromOption(data, '-');
                        xMarkMap[seriesIndex] = xMarkMap[seriesIndex] || {
                            min: Number.POSITIVE_INFINITY,
                            max: Number.NEGATIVE_INFINITY,
                            sum: 0,
                            counter: 0,
                            average: 0
                        };
                        curBarWidth = Math.min(barMaxWidthMap[seriesIndex] || Number.MAX_VALUE, barWidthMap[seriesIndex] || barWidth);
                        if (value === '-') {
                            continue;
                        }
                        if (value > 0) {
                            barHeight = m > 0 ? valueAxis.getCoordSize(value) : isHorizontal ? baseP - valueAxis.getCoord(value) : valueAxis.getCoord(value) - baseP;
                            if (n === 1 && barMinHeightMap[seriesIndex] > barHeight) {
                                barHeight = barMinHeightMap[seriesIndex];
                            }
                            if (isHorizontal) {
                                lastP -= barHeight;
                                y = lastP;
                            } else {
                                x = lastP;
                                lastP += barHeight;
                            }
                        } else if (value < 0) {
                            barHeight = m > 0 ? valueAxis.getCoordSize(value) : isHorizontal ? valueAxis.getCoord(value) - baseN : baseN - valueAxis.getCoord(value);
                            if (n === 1 && barMinHeightMap[seriesIndex] > barHeight) {
                                barHeight = barMinHeightMap[seriesIndex];
                            }
                            if (isHorizontal) {
                                y = lastN;
                                lastN += barHeight;
                            } else {
                                lastN -= barHeight;
                                x = lastN;
                            }
                        } else {
                            barHeight = 0;
                            if (isHorizontal) {
                                lastP -= barHeight;
                                y = lastP;
                            } else {
                                x = lastP;
                                lastP += barHeight;
                            }
                        }
                        xMarkMap[seriesIndex][i] = isHorizontal ? x + curBarWidth / 2 : y - curBarWidth / 2;
                        if (xMarkMap[seriesIndex].min > value) {
                            xMarkMap[seriesIndex].min = value;
                            if (isHorizontal) {
                                xMarkMap[seriesIndex].minY = y;
                                xMarkMap[seriesIndex].minX = xMarkMap[seriesIndex][i];
                            } else {
                                xMarkMap[seriesIndex].minX = x + barHeight;
                                xMarkMap[seriesIndex].minY = xMarkMap[seriesIndex][i];
                            }
                        }
                        if (xMarkMap[seriesIndex].max < value) {
                            xMarkMap[seriesIndex].max = value;
                            if (isHorizontal) {
                                xMarkMap[seriesIndex].maxY = y;
                                xMarkMap[seriesIndex].maxX = xMarkMap[seriesIndex][i];
                            } else {
                                xMarkMap[seriesIndex].maxX = x + barHeight;
                                xMarkMap[seriesIndex].maxY = xMarkMap[seriesIndex][i];
                            }
                        }
                        xMarkMap[seriesIndex].sum += value;
                        xMarkMap[seriesIndex].counter++;
                        if (i % interval === 0) {
                            barShape = this._getBarItem(seriesIndex, i, categoryAxis.getNameByIndex(i), x, y - (isHorizontal ? 0 : curBarWidth), isHorizontal ? curBarWidth : barHeight, isHorizontal ? barHeight : curBarWidth, isHorizontal ? 'vertical' : 'horizontal');
                            this.shapeList.push(new RectangleShape(barShape));
                        }
                    }
                    for (var m = 0, n = locationMap[j].length; m < n; m++) {
                        seriesIndex = locationMap[j][m];
                        serie = series[seriesIndex];
                        data = serie.data[i];
                        value = this.getDataFromOption(data, '-');
                        curBarWidth = Math.min(barMaxWidthMap[seriesIndex] || Number.MAX_VALUE, barWidthMap[seriesIndex] || barWidth);
                        if (value != '-') {
                            continue;
                        }
                        if (this.deepQuery([
                                data,
                                serie,
                                this.option
                            ], 'calculable')) {
                            if (isHorizontal) {
                                lastP -= islandR;
                                y = lastP;
                            } else {
                                x = lastP;
                                lastP += islandR;
                            }
                            barShape = this._getBarItem(seriesIndex, i, categoryAxis.getNameByIndex(i), x, y - (isHorizontal ? 0 : curBarWidth), isHorizontal ? curBarWidth : islandR, isHorizontal ? islandR : curBarWidth, isHorizontal ? 'vertical' : 'horizontal');
                            barShape.hoverable = false;
                            barShape.draggable = false;
                            barShape.style.lineWidth = 1;
                            barShape.style.brushType = 'stroke';
                            barShape.style.strokeColor = serie.calculableHolderColor || this.ecTheme.calculableHolderColor || ecConfig.calculableHolderColor;
                            this.shapeList.push(new RectangleShape(barShape));
                        }
                    }
                    isHorizontal ? x += curBarWidth + barGap : y -= curBarWidth + barGap;
                }
            }
            this._calculMarkMapXY(xMarkMap, locationMap, isHorizontal ? 'y' : 'x');
        },
        _buildHorizontal: function (seriesArray, maxDataLength, locationMap, xMarkMap) {
            return this._buildNormal(seriesArray, maxDataLength, locationMap, xMarkMap, 'horizontal');
        },
        _buildVertical: function (seriesArray, maxDataLength, locationMap, xMarkMap) {
            return this._buildNormal(seriesArray, maxDataLength, locationMap, xMarkMap, 'vertical');
        },
        _buildOther: function (seriesArray, maxDataLength, locationMap, xMarkMap) {
            var series = this.series;
            for (var j = 0, k = locationMap.length; j < k; j++) {
                for (var m = 0, n = locationMap[j].length; m < n; m++) {
                    var seriesIndex = locationMap[j][m];
                    var serie = series[seriesIndex];
                    var xAxisIndex = serie.xAxisIndex || 0;
                    var xAxis = this.component.xAxis.getAxis(xAxisIndex);
                    var baseX = xAxis.getCoord(0);
                    var yAxisIndex = serie.yAxisIndex || 0;
                    var yAxis = this.component.yAxis.getAxis(yAxisIndex);
                    var baseY = yAxis.getCoord(0);
                    xMarkMap[seriesIndex] = xMarkMap[seriesIndex] || {
                        min0: Number.POSITIVE_INFINITY,
                        min1: Number.POSITIVE_INFINITY,
                        max0: Number.NEGATIVE_INFINITY,
                        max1: Number.NEGATIVE_INFINITY,
                        sum0: 0,
                        sum1: 0,
                        counter0: 0,
                        counter1: 0,
                        average0: 0,
                        average1: 0
                    };
                    for (var i = 0, l = serie.data.length; i < l; i++) {
                        var data = serie.data[i];
                        var value = this.getDataFromOption(data, '-');
                        if (!(value instanceof Array)) {
                            continue;
                        }
                        var x = xAxis.getCoord(value[0]);
                        var y = yAxis.getCoord(value[1]);
                        var queryTarget = [
                            data,
                            serie
                        ];
                        var barWidth = this.deepQuery(queryTarget, 'barWidth') || 10;
                        var barHeight = this.deepQuery(queryTarget, 'barHeight');
                        var orient;
                        var barShape;
                        if (barHeight != null) {
                            orient = 'horizontal';
                            if (value[0] > 0) {
                                barWidth = x - baseX;
                                x -= barWidth;
                            } else if (value[0] < 0) {
                                barWidth = baseX - x;
                            } else {
                                barWidth = 0;
                            }
                            barShape = this._getBarItem(seriesIndex, i, value[0], x, y - barHeight / 2, barWidth, barHeight, orient);
                        } else {
                            orient = 'vertical';
                            if (value[1] > 0) {
                                barHeight = baseY - y;
                            } else if (value[1] < 0) {
                                barHeight = y - baseY;
                                y -= barHeight;
                            } else {
                                barHeight = 0;
                            }
                            barShape = this._getBarItem(seriesIndex, i, value[0], x - barWidth / 2, y, barWidth, barHeight, orient);
                        }
                        this.shapeList.push(new RectangleShape(barShape));
                        x = xAxis.getCoord(value[0]);
                        y = yAxis.getCoord(value[1]);
                        if (xMarkMap[seriesIndex].min0 > value[0]) {
                            xMarkMap[seriesIndex].min0 = value[0];
                            xMarkMap[seriesIndex].minY0 = y;
                            xMarkMap[seriesIndex].minX0 = x;
                        }
                        if (xMarkMap[seriesIndex].max0 < value[0]) {
                            xMarkMap[seriesIndex].max0 = value[0];
                            xMarkMap[seriesIndex].maxY0 = y;
                            xMarkMap[seriesIndex].maxX0 = x;
                        }
                        xMarkMap[seriesIndex].sum0 += value[0];
                        xMarkMap[seriesIndex].counter0++;
                        if (xMarkMap[seriesIndex].min1 > value[1]) {
                            xMarkMap[seriesIndex].min1 = value[1];
                            xMarkMap[seriesIndex].minY1 = y;
                            xMarkMap[seriesIndex].minX1 = x;
                        }
                        if (xMarkMap[seriesIndex].max1 < value[1]) {
                            xMarkMap[seriesIndex].max1 = value[1];
                            xMarkMap[seriesIndex].maxY1 = y;
                            xMarkMap[seriesIndex].maxX1 = x;
                        }
                        xMarkMap[seriesIndex].sum1 += value[1];
                        xMarkMap[seriesIndex].counter1++;
                    }
                }
            }
            this._calculMarkMapXY(xMarkMap, locationMap, 'xy');
        },
        _mapSize: function (categoryAxis, locationMap, ignoreUserDefined) {
            var res = this._findSpecialBarSzie(locationMap, ignoreUserDefined);
            var barWidthMap = res.barWidthMap;
            var barMaxWidthMap = res.barMaxWidthMap;
            var barMinHeightMap = res.barMinHeightMap;
            var sBarWidthCounter = res.sBarWidthCounter;
            var sBarWidthTotal = res.sBarWidthTotal;
            var barGap = res.barGap;
            var barCategoryGap = res.barCategoryGap;
            var gap;
            var barWidth;
            var interval = 1;
            if (locationMap.length != sBarWidthCounter) {
                if (!ignoreUserDefined) {
                    gap = typeof barCategoryGap === 'string' && barCategoryGap.match(/%$/) ? (categoryAxis.getGap() * (100 - parseFloat(barCategoryGap)) / 100).toFixed(2) - 0 : categoryAxis.getGap() - barCategoryGap;
                    if (typeof barGap === 'string' && barGap.match(/%$/)) {
                        barGap = parseFloat(barGap) / 100;
                        barWidth = +((gap - sBarWidthTotal) / ((locationMap.length - 1) * barGap + locationMap.length - sBarWidthCounter)).toFixed(2);
                        barGap = barWidth * barGap;
                    } else {
                        barGap = parseFloat(barGap);
                        barWidth = +((gap - sBarWidthTotal - barGap * (locationMap.length - 1)) / (locationMap.length - sBarWidthCounter)).toFixed(2);
                    }
                    if (barWidth <= 0) {
                        return this._mapSize(categoryAxis, locationMap, true);
                    }
                } else {
                    gap = categoryAxis.getGap();
                    barGap = 0;
                    barWidth = +(gap / locationMap.length).toFixed(2);
                    if (barWidth <= 0) {
                        interval = Math.floor(locationMap.length / gap);
                        barWidth = 1;
                    }
                }
            } else {
                gap = sBarWidthCounter > 1 ? typeof barCategoryGap === 'string' && barCategoryGap.match(/%$/) ? +(categoryAxis.getGap() * (100 - parseFloat(barCategoryGap)) / 100).toFixed(2) : categoryAxis.getGap() - barCategoryGap : sBarWidthTotal;
                barWidth = 0;
                barGap = sBarWidthCounter > 1 ? +((gap - sBarWidthTotal) / (sBarWidthCounter - 1)).toFixed(2) : 0;
                if (barGap < 0) {
                    return this._mapSize(categoryAxis, locationMap, true);
                }
            }
            return this._recheckBarMaxWidth(locationMap, barWidthMap, barMaxWidthMap, barMinHeightMap, gap, barWidth, barGap, interval);
        },
        _findSpecialBarSzie: function (locationMap, ignoreUserDefined) {
            var series = this.series;
            var barWidthMap = {};
            var barMaxWidthMap = {};
            var barMinHeightMap = {};
            var sBarWidth;
            var sBarMaxWidth;
            var sBarWidthCounter = 0;
            var sBarWidthTotal = 0;
            var barGap;
            var barCategoryGap;
            for (var j = 0, k = locationMap.length; j < k; j++) {
                var hasFound = {
                    barWidth: false,
                    barMaxWidth: false
                };
                for (var m = 0, n = locationMap[j].length; m < n; m++) {
                    var seriesIndex = locationMap[j][m];
                    var queryTarget = series[seriesIndex];
                    if (!ignoreUserDefined) {
                        if (!hasFound.barWidth) {
                            sBarWidth = this.query(queryTarget, 'barWidth');
                            if (sBarWidth != null) {
                                barWidthMap[seriesIndex] = sBarWidth;
                                sBarWidthTotal += sBarWidth;
                                sBarWidthCounter++;
                                hasFound.barWidth = true;
                                for (var ii = 0, ll = m; ii < ll; ii++) {
                                    var pSeriesIndex = locationMap[j][ii];
                                    barWidthMap[pSeriesIndex] = sBarWidth;
                                }
                            }
                        } else {
                            barWidthMap[seriesIndex] = sBarWidth;
                        }
                        if (!hasFound.barMaxWidth) {
                            sBarMaxWidth = this.query(queryTarget, 'barMaxWidth');
                            if (sBarMaxWidth != null) {
                                barMaxWidthMap[seriesIndex] = sBarMaxWidth;
                                hasFound.barMaxWidth = true;
                                for (var ii = 0, ll = m; ii < ll; ii++) {
                                    var pSeriesIndex = locationMap[j][ii];
                                    barMaxWidthMap[pSeriesIndex] = sBarMaxWidth;
                                }
                            }
                        } else {
                            barMaxWidthMap[seriesIndex] = sBarMaxWidth;
                        }
                    }
                    barMinHeightMap[seriesIndex] = this.query(queryTarget, 'barMinHeight');
                    barGap = barGap != null ? barGap : this.query(queryTarget, 'barGap');
                    barCategoryGap = barCategoryGap != null ? barCategoryGap : this.query(queryTarget, 'barCategoryGap');
                }
            }
            return {
                barWidthMap: barWidthMap,
                barMaxWidthMap: barMaxWidthMap,
                barMinHeightMap: barMinHeightMap,
                sBarWidth: sBarWidth,
                sBarMaxWidth: sBarMaxWidth,
                sBarWidthCounter: sBarWidthCounter,
                sBarWidthTotal: sBarWidthTotal,
                barGap: barGap,
                barCategoryGap: barCategoryGap
            };
        },
        _recheckBarMaxWidth: function (locationMap, barWidthMap, barMaxWidthMap, barMinHeightMap, gap, barWidth, barGap, interval) {
            for (var j = 0, k = locationMap.length; j < k; j++) {
                var seriesIndex = locationMap[j][0];
                if (barMaxWidthMap[seriesIndex] && barMaxWidthMap[seriesIndex] < barWidth) {
                    gap -= barWidth - barMaxWidthMap[seriesIndex];
                }
            }
            return {
                barWidthMap: barWidthMap,
                barMaxWidthMap: barMaxWidthMap,
                barMinHeightMap: barMinHeightMap,
                gap: gap,
                barWidth: barWidth,
                barGap: barGap,
                interval: interval
            };
        },
        _getBarItem: function (seriesIndex, dataIndex, name, x, y, width, height, orient) {
            var series = this.series;
            var barShape;
            var serie = series[seriesIndex];
            var data = serie.data[dataIndex];
            var defaultColor = this._sIndex2ColorMap[seriesIndex];
            var queryTarget = [
                data,
                serie
            ];
            var normal = this.deepMerge(queryTarget, 'itemStyle.normal');
            var emphasis = this.deepMerge(queryTarget, 'itemStyle.emphasis');
            var normalBorderWidth = normal.barBorderWidth;
            barShape = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                clickable: this.deepQuery(queryTarget, 'clickable'),
                style: {
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    brushType: 'both',
                    color: this.getItemStyleColor(this.deepQuery(queryTarget, 'itemStyle.normal.color') || defaultColor, seriesIndex, dataIndex, data),
                    radius: normal.barBorderRadius,
                    lineWidth: normalBorderWidth,
                    strokeColor: normal.barBorderColor
                },
                highlightStyle: {
                    color: this.getItemStyleColor(this.deepQuery(queryTarget, 'itemStyle.emphasis.color'), seriesIndex, dataIndex, data),
                    radius: emphasis.barBorderRadius,
                    lineWidth: emphasis.barBorderWidth,
                    strokeColor: emphasis.barBorderColor
                },
                _orient: orient
            };
            var barShapeStyle = barShape.style;
            barShape.highlightStyle.color = barShape.highlightStyle.color || (typeof barShapeStyle.color === 'string' ? zrColor.lift(barShapeStyle.color, -0.3) : barShapeStyle.color);
            barShapeStyle.x = Math.floor(barShapeStyle.x);
            barShapeStyle.y = Math.floor(barShapeStyle.y);
            barShapeStyle.height = Math.ceil(barShapeStyle.height);
            barShapeStyle.width = Math.ceil(barShapeStyle.width);
            if (normalBorderWidth > 0 && barShapeStyle.height > normalBorderWidth && barShapeStyle.width > normalBorderWidth) {
                barShapeStyle.y += normalBorderWidth / 2;
                barShapeStyle.height -= normalBorderWidth;
                barShapeStyle.x += normalBorderWidth / 2;
                barShapeStyle.width -= normalBorderWidth;
            } else {
                barShapeStyle.brushType = 'fill';
            }
            barShape.highlightStyle.textColor = barShape.highlightStyle.color;
            barShape = this.addLabel(barShape, serie, data, name, orient);
            var barShapeStyleList = [
                barShapeStyle,
                barShape.highlightStyle
            ];
            for (var i = 0, l = barShapeStyleList.length; i < l; i++) {
                var textPosition = barShapeStyleList[i].textPosition;
                if (textPosition === 'insideLeft' || textPosition === 'insideRight' || textPosition === 'insideTop' || textPosition === 'insideBottom') {
                    var gap = 5;
                    switch (textPosition) {
                    case 'insideLeft':
                        barShapeStyleList[i].textX = barShapeStyle.x + gap;
                        barShapeStyleList[i].textY = barShapeStyle.y + barShapeStyle.height / 2;
                        barShapeStyleList[i].textAlign = 'left';
                        barShapeStyleList[i].textBaseline = 'middle';
                        break;
                    case 'insideRight':
                        barShapeStyleList[i].textX = barShapeStyle.x + barShapeStyle.width - gap;
                        barShapeStyleList[i].textY = barShapeStyle.y + barShapeStyle.height / 2;
                        barShapeStyleList[i].textAlign = 'right';
                        barShapeStyleList[i].textBaseline = 'middle';
                        break;
                    case 'insideTop':
                        barShapeStyleList[i].textX = barShapeStyle.x + barShapeStyle.width / 2;
                        barShapeStyleList[i].textY = barShapeStyle.y + gap / 2;
                        barShapeStyleList[i].textAlign = 'center';
                        barShapeStyleList[i].textBaseline = 'top';
                        break;
                    case 'insideBottom':
                        barShapeStyleList[i].textX = barShapeStyle.x + barShapeStyle.width / 2;
                        barShapeStyleList[i].textY = barShapeStyle.y + barShapeStyle.height - gap / 2;
                        barShapeStyleList[i].textAlign = 'center';
                        barShapeStyleList[i].textBaseline = 'bottom';
                        break;
                    }
                    barShapeStyleList[i].textPosition = 'specific';
                    barShapeStyleList[i].textColor = barShapeStyleList[i].textColor || '#fff';
                }
            }
            if (this.deepQuery([
                    data,
                    serie,
                    this.option
                ], 'calculable')) {
                this.setCalculable(barShape);
                barShape.draggable = true;
            }
            ecData.pack(barShape, series[seriesIndex], seriesIndex, series[seriesIndex].data[dataIndex], dataIndex, name);
            return barShape;
        },
        getMarkCoord: function (seriesIndex, mpData) {
            var serie = this.series[seriesIndex];
            var xMarkMap = this.xMarkMap[seriesIndex];
            var xAxis = this.component.xAxis.getAxis(serie.xAxisIndex);
            var yAxis = this.component.yAxis.getAxis(serie.yAxisIndex);
            var dataIndex;
            var pos;
            if (mpData.type && (mpData.type === 'max' || mpData.type === 'min' || mpData.type === 'average')) {
                var valueIndex = mpData.valueIndex != null ? mpData.valueIndex : xMarkMap.maxX0 != null ? '1' : '';
                pos = [
                    xMarkMap[mpData.type + 'X' + valueIndex],
                    xMarkMap[mpData.type + 'Y' + valueIndex],
                    xMarkMap[mpData.type + 'Line' + valueIndex],
                    xMarkMap[mpData.type + valueIndex]
                ];
            } else if (xMarkMap.isHorizontal) {
                dataIndex = typeof mpData.xAxis === 'string' && xAxis.getIndexByName ? xAxis.getIndexByName(mpData.xAxis) : mpData.xAxis || 0;
                var x = xMarkMap[dataIndex];
                x = x != null ? x : typeof mpData.xAxis != 'string' && xAxis.getCoordByIndex ? xAxis.getCoordByIndex(mpData.xAxis || 0) : xAxis.getCoord(mpData.xAxis || 0);
                pos = [
                    x,
                    yAxis.getCoord(mpData.yAxis || 0)
                ];
            } else {
                dataIndex = typeof mpData.yAxis === 'string' && yAxis.getIndexByName ? yAxis.getIndexByName(mpData.yAxis) : mpData.yAxis || 0;
                var y = xMarkMap[dataIndex];
                y = y != null ? y : typeof mpData.yAxis != 'string' && yAxis.getCoordByIndex ? yAxis.getCoordByIndex(mpData.yAxis || 0) : yAxis.getCoord(mpData.yAxis || 0);
                pos = [
                    xAxis.getCoord(mpData.xAxis || 0),
                    y
                ];
            }
            return pos;
        },
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.series = newOption.series;
            }
            this.backupShapeList();
            this._buildShape();
        },
        addDataAnimation: function (params, done) {
            var series = this.series;
            var aniMap = {};
            for (var i = 0, l = params.length; i < l; i++) {
                aniMap[params[i][0]] = params[i];
            }
            var x;
            var dx;
            var y;
            var dy;
            var serie;
            var seriesIndex;
            var dataIndex;
            var aniCount = 0;
            function animationDone() {
                aniCount--;
                if (aniCount === 0) {
                    done && done();
                }
            }
            for (var i = this.shapeList.length - 1; i >= 0; i--) {
                seriesIndex = ecData.get(this.shapeList[i], 'seriesIndex');
                if (aniMap[seriesIndex] && !aniMap[seriesIndex][3]) {
                    if (this.shapeList[i].type === 'rectangle') {
                        dataIndex = ecData.get(this.shapeList[i], 'dataIndex');
                        serie = series[seriesIndex];
                        if (aniMap[seriesIndex][2] && dataIndex === serie.data.length - 1) {
                            this.zr.delShape(this.shapeList[i].id);
                            continue;
                        } else if (!aniMap[seriesIndex][2] && dataIndex === 0) {
                            this.zr.delShape(this.shapeList[i].id);
                            continue;
                        }
                        if (this.shapeList[i]._orient === 'horizontal') {
                            dy = this.component.yAxis.getAxis(serie.yAxisIndex || 0).getGap();
                            y = aniMap[seriesIndex][2] ? -dy : dy;
                            x = 0;
                        } else {
                            dx = this.component.xAxis.getAxis(serie.xAxisIndex || 0).getGap();
                            x = aniMap[seriesIndex][2] ? dx : -dx;
                            y = 0;
                        }
                        this.shapeList[i].position = [
                            0,
                            0
                        ];
                        aniCount++;
                        this.zr.animate(this.shapeList[i].id, '').when(this.query(this.option, 'animationDurationUpdate'), {
                            position: [
                                x,
                                y
                            ]
                        }).done(animationDone).start();
                    }
                }
            }
            if (!aniCount) {
                animationDone();
            }
        }
    };
    zrUtil.inherits(Bar, ChartBase);
    require('../chart').define('bar', Bar);
    return Bar;
});define('echarts/chart/scatter', [
    'require',
    './base',
    '../util/shape/Symbol',
    '../component/axis',
    '../component/grid',
    '../component/dataZoom',
    '../component/dataRange',
    '../config',
    'zrender/tool/util',
    'zrender/tool/color',
    '../chart'
], function (require) {
    var ChartBase = require('./base');
    var SymbolShape = require('../util/shape/Symbol');
    require('../component/axis');
    require('../component/grid');
    require('../component/dataZoom');
    require('../component/dataRange');
    var ecConfig = require('../config');
    ecConfig.scatter = {
        zlevel: 0,
        z: 2,
        clickable: true,
        legendHoverLink: true,
        xAxisIndex: 0,
        yAxisIndex: 0,
        symbolSize: 4,
        large: false,
        largeThreshold: 2000,
        itemStyle: {
            normal: { label: { show: false } },
            emphasis: { label: { show: false } }
        }
    };
    var zrUtil = require('zrender/tool/util');
    var zrColor = require('zrender/tool/color');
    function Scatter(ecTheme, messageCenter, zr, option, myChart) {
        ChartBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.refresh(option);
    }
    Scatter.prototype = {
        type: ecConfig.CHART_TYPE_SCATTER,
        _buildShape: function () {
            var series = this.series;
            this._sIndex2ColorMap = {};
            this._symbol = this.option.symbolList;
            this._sIndex2ShapeMap = {};
            this.selectedMap = {};
            this.xMarkMap = {};
            var legend = this.component.legend;
            var seriesArray = [];
            var serie;
            var serieName;
            var iconShape;
            var iconType;
            for (var i = 0, l = series.length; i < l; i++) {
                serie = series[i];
                serieName = serie.name;
                if (serie.type === ecConfig.CHART_TYPE_SCATTER) {
                    series[i] = this.reformOption(series[i]);
                    this.legendHoverLink = series[i].legendHoverLink || this.legendHoverLink;
                    this._sIndex2ShapeMap[i] = this.query(serie, 'symbol') || this._symbol[i % this._symbol.length];
                    if (legend) {
                        this.selectedMap[serieName] = legend.isSelected(serieName);
                        this._sIndex2ColorMap[i] = zrColor.alpha(legend.getColor(serieName), 0.5);
                        iconShape = legend.getItemShape(serieName);
                        if (iconShape) {
                            var iconType = this._sIndex2ShapeMap[i];
                            iconShape.style.brushType = iconType.match('empty') ? 'stroke' : 'both';
                            iconType = iconType.replace('empty', '').toLowerCase();
                            if (iconType.match('rectangle')) {
                                iconShape.style.x += Math.round((iconShape.style.width - iconShape.style.height) / 2);
                                iconShape.style.width = iconShape.style.height;
                            }
                            if (iconType.match('star')) {
                                iconShape.style.n = iconType.replace('star', '') - 0 || 5;
                                iconType = 'star';
                            }
                            if (iconType.match('image')) {
                                iconShape.style.image = iconType.replace(new RegExp('^image:\\/\\/'), '');
                                iconShape.style.x += Math.round((iconShape.style.width - iconShape.style.height) / 2);
                                iconShape.style.width = iconShape.style.height;
                                iconType = 'image';
                            }
                            iconShape.style.iconType = iconType;
                            legend.setItemShape(serieName, iconShape);
                        }
                    } else {
                        this.selectedMap[serieName] = true;
                        this._sIndex2ColorMap[i] = zrColor.alpha(this.zr.getColor(i), 0.5);
                    }
                    if (this.selectedMap[serieName]) {
                        seriesArray.push(i);
                    }
                }
            }
            this._buildSeries(seriesArray);
            this.addShapeList();
        },
        _buildSeries: function (seriesArray) {
            if (seriesArray.length === 0) {
                return;
            }
            var series = this.series;
            var seriesIndex;
            var serie;
            var data;
            var value;
            var xAxis;
            var yAxis;
            var pointList = {};
            var x;
            var y;
            for (var j = 0, k = seriesArray.length; j < k; j++) {
                seriesIndex = seriesArray[j];
                serie = series[seriesIndex];
                if (serie.data.length === 0) {
                    continue;
                }
                xAxis = this.component.xAxis.getAxis(serie.xAxisIndex || 0);
                yAxis = this.component.yAxis.getAxis(serie.yAxisIndex || 0);
                pointList[seriesIndex] = [];
                for (var i = 0, l = serie.data.length; i < l; i++) {
                    data = serie.data[i];
                    value = this.getDataFromOption(data, '-');
                    if (value === '-' || value.length < 2) {
                        continue;
                    }
                    x = xAxis.getCoord(value[0]);
                    y = yAxis.getCoord(value[1]);
                    pointList[seriesIndex].push([
                        x,
                        y,
                        i,
                        data.name || ''
                    ]);
                }
                this.xMarkMap[seriesIndex] = this._markMap(xAxis, yAxis, serie.data, pointList[seriesIndex]);
                this.buildMark(seriesIndex);
            }
            this._buildPointList(pointList);
        },
        _markMap: function (xAxis, yAxis, data, pointList) {
            var xMarkMap = {
                min0: Number.POSITIVE_INFINITY,
                max0: Number.NEGATIVE_INFINITY,
                sum0: 0,
                counter0: 0,
                average0: 0,
                min1: Number.POSITIVE_INFINITY,
                max1: Number.NEGATIVE_INFINITY,
                sum1: 0,
                counter1: 0,
                average1: 0
            };
            var value;
            for (var i = 0, l = pointList.length; i < l; i++) {
                value = data[pointList[i][2]].value || data[pointList[i][2]];
                if (xMarkMap.min0 > value[0]) {
                    xMarkMap.min0 = value[0];
                    xMarkMap.minY0 = pointList[i][1];
                    xMarkMap.minX0 = pointList[i][0];
                }
                if (xMarkMap.max0 < value[0]) {
                    xMarkMap.max0 = value[0];
                    xMarkMap.maxY0 = pointList[i][1];
                    xMarkMap.maxX0 = pointList[i][0];
                }
                xMarkMap.sum0 += value[0];
                xMarkMap.counter0++;
                if (xMarkMap.min1 > value[1]) {
                    xMarkMap.min1 = value[1];
                    xMarkMap.minY1 = pointList[i][1];
                    xMarkMap.minX1 = pointList[i][0];
                }
                if (xMarkMap.max1 < value[1]) {
                    xMarkMap.max1 = value[1];
                    xMarkMap.maxY1 = pointList[i][1];
                    xMarkMap.maxX1 = pointList[i][0];
                }
                xMarkMap.sum1 += value[1];
                xMarkMap.counter1++;
            }
            var gridX = this.component.grid.getX();
            var gridXend = this.component.grid.getXend();
            var gridY = this.component.grid.getY();
            var gridYend = this.component.grid.getYend();
            xMarkMap.average0 = xMarkMap.sum0 / xMarkMap.counter0;
            var x = xAxis.getCoord(xMarkMap.average0);
            xMarkMap.averageLine0 = [
                [
                    x,
                    gridYend
                ],
                [
                    x,
                    gridY
                ]
            ];
            xMarkMap.minLine0 = [
                [
                    xMarkMap.minX0,
                    gridYend
                ],
                [
                    xMarkMap.minX0,
                    gridY
                ]
            ];
            xMarkMap.maxLine0 = [
                [
                    xMarkMap.maxX0,
                    gridYend
                ],
                [
                    xMarkMap.maxX0,
                    gridY
                ]
            ];
            xMarkMap.average1 = xMarkMap.sum1 / xMarkMap.counter1;
            var y = yAxis.getCoord(xMarkMap.average1);
            xMarkMap.averageLine1 = [
                [
                    gridX,
                    y
                ],
                [
                    gridXend,
                    y
                ]
            ];
            xMarkMap.minLine1 = [
                [
                    gridX,
                    xMarkMap.minY1
                ],
                [
                    gridXend,
                    xMarkMap.minY1
                ]
            ];
            xMarkMap.maxLine1 = [
                [
                    gridX,
                    xMarkMap.maxY1
                ],
                [
                    gridXend,
                    xMarkMap.maxY1
                ]
            ];
            return xMarkMap;
        },
        _buildPointList: function (pointList) {
            var series = this.series;
            var serie;
            var seriesPL;
            var singlePoint;
            var shape;
            for (var seriesIndex in pointList) {
                serie = series[seriesIndex];
                seriesPL = pointList[seriesIndex];
                if (serie.large && serie.data.length > serie.largeThreshold) {
                    this.shapeList.push(this._getLargeSymbol(seriesPL, this.getItemStyleColor(this.query(serie, 'itemStyle.normal.color'), seriesIndex, -1) || this._sIndex2ColorMap[seriesIndex]));
                    continue;
                }
                for (var i = 0, l = seriesPL.length; i < l; i++) {
                    singlePoint = seriesPL[i];
                    shape = this._getSymbol(seriesIndex, singlePoint[2], singlePoint[3], singlePoint[0], singlePoint[1]);
                    shape && this.shapeList.push(shape);
                }
            }
        },
        _getSymbol: function (seriesIndex, dataIndex, name, x, y) {
            var series = this.series;
            var serie = series[seriesIndex];
            var data = serie.data[dataIndex];
            var dataRange = this.component.dataRange;
            var rangColor;
            if (dataRange) {
                rangColor = isNaN(data[2]) ? this._sIndex2ColorMap[seriesIndex] : dataRange.getColor(data[2]);
                if (!rangColor) {
                    return null;
                }
            } else {
                rangColor = this._sIndex2ColorMap[seriesIndex];
            }
            var itemShape = this.getSymbolShape(serie, seriesIndex, data, dataIndex, name, x, y, this._sIndex2ShapeMap[seriesIndex], rangColor, 'rgba(0,0,0,0)', 'vertical');
            itemShape.zlevel = this.getZlevelBase();
            itemShape.z = this.getZBase();
            itemShape._main = true;
            return itemShape;
        },
        _getLargeSymbol: function (pointList, nColor) {
            return new SymbolShape({
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                _main: true,
                hoverable: false,
                style: {
                    pointList: pointList,
                    color: nColor,
                    strokeColor: nColor
                },
                highlightStyle: { pointList: [] }
            });
        },
        getMarkCoord: function (seriesIndex, mpData) {
            var serie = this.series[seriesIndex];
            var xMarkMap = this.xMarkMap[seriesIndex];
            var xAxis = this.component.xAxis.getAxis(serie.xAxisIndex);
            var yAxis = this.component.yAxis.getAxis(serie.yAxisIndex);
            var pos;
            if (mpData.type && (mpData.type === 'max' || mpData.type === 'min' || mpData.type === 'average')) {
                var valueIndex = mpData.valueIndex != null ? mpData.valueIndex : 1;
                pos = [
                    xMarkMap[mpData.type + 'X' + valueIndex],
                    xMarkMap[mpData.type + 'Y' + valueIndex],
                    xMarkMap[mpData.type + 'Line' + valueIndex],
                    xMarkMap[mpData.type + valueIndex]
                ];
            } else {
                pos = [
                    typeof mpData.xAxis != 'string' && xAxis.getCoordByIndex ? xAxis.getCoordByIndex(mpData.xAxis || 0) : xAxis.getCoord(mpData.xAxis || 0),
                    typeof mpData.yAxis != 'string' && yAxis.getCoordByIndex ? yAxis.getCoordByIndex(mpData.yAxis || 0) : yAxis.getCoord(mpData.yAxis || 0)
                ];
            }
            return pos;
        },
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.series = newOption.series;
            }
            this.backupShapeList();
            this._buildShape();
        },
        ondataRange: function (param, status) {
            if (this.component.dataRange) {
                this.refresh();
                status.needRefresh = true;
            }
            return;
        }
    };
    zrUtil.inherits(Scatter, ChartBase);
    require('../chart').define('scatter', Scatter);
    return Scatter;
});define('echarts/component/dataRange', [
    'require',
    './base',
    'zrender/shape/Text',
    'zrender/shape/Rectangle',
    '../util/shape/HandlePolygon',
    '../config',
    'zrender/tool/util',
    'zrender/tool/event',
    'zrender/tool/area',
    'zrender/tool/color',
    '../component'
], function (require) {
    var Base = require('./base');
    var TextShape = require('zrender/shape/Text');
    var RectangleShape = require('zrender/shape/Rectangle');
    var HandlePolygonShape = require('../util/shape/HandlePolygon');
    var ecConfig = require('../config');
    ecConfig.dataRange = {
        zlevel: 0,
        z: 4,
        show: true,
        orient: 'vertical',
        x: 'left',
        y: 'bottom',
        backgroundColor: 'rgba(0,0,0,0)',
        borderColor: '#ccc',
        borderWidth: 0,
        padding: 5,
        itemGap: 10,
        itemWidth: 20,
        itemHeight: 14,
        precision: 0,
        splitNumber: 5,
        calculable: false,
        selectedMode: true,
        hoverLink: true,
        realtime: true,
        color: [
            '#006edd',
            '#e0ffff'
        ],
        textStyle: { color: '#333' }
    };
    var zrUtil = require('zrender/tool/util');
    var zrEvent = require('zrender/tool/event');
    var zrArea = require('zrender/tool/area');
    var zrColor = require('zrender/tool/color');
    function DataRange(ecTheme, messageCenter, zr, option, myChart) {
        if (typeof this.query(option, 'dataRange.min') == 'undefined' || typeof this.query(option, 'dataRange.max') == 'undefined') {
            console.error('option.dataRange.min or option.dataRange.max has not been defined.');
            return;
        }
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        var self = this;
        self._ondrift = function (dx, dy) {
            return self.__ondrift(this, dx, dy);
        };
        self._ondragend = function () {
            return self.__ondragend();
        };
        self._dataRangeSelected = function (param) {
            return self.__dataRangeSelected(param);
        };
        self._dispatchHoverLink = function (param) {
            return self.__dispatchHoverLink(param);
        };
        self._onhoverlink = function (params) {
            return self.__onhoverlink(params);
        };
        this._selectedMap = {};
        this._range = {};
        this.refresh(option);
        messageCenter.bind(ecConfig.EVENT.HOVER, this._onhoverlink);
    }
    DataRange.prototype = {
        type: ecConfig.COMPONENT_TYPE_DATARANGE,
        _textGap: 10,
        _buildShape: function () {
            this._itemGroupLocation = this._getItemGroupLocation();
            this._buildBackground();
            if (this.dataRangeOption.splitNumber <= 0 || this.dataRangeOption.calculable) {
                this._buildGradient();
            } else {
                this._buildItem();
            }
            if (this.dataRangeOption.show) {
                for (var i = 0, l = this.shapeList.length; i < l; i++) {
                    this.zr.addShape(this.shapeList[i]);
                }
            }
            this._syncShapeFromRange();
        },
        _buildItem: function () {
            var data = this._valueTextList;
            var dataLength = data.length;
            var itemName;
            var itemShape;
            var textShape;
            var font = this.getFont(this.dataRangeOption.textStyle);
            var lastX = this._itemGroupLocation.x;
            var lastY = this._itemGroupLocation.y;
            var itemWidth = this.dataRangeOption.itemWidth;
            var itemHeight = this.dataRangeOption.itemHeight;
            var itemGap = this.dataRangeOption.itemGap;
            var textHeight = zrArea.getTextHeight('å›½', font);
            var color;
            if (this.dataRangeOption.orient == 'vertical' && this.dataRangeOption.x == 'right') {
                lastX = this._itemGroupLocation.x + this._itemGroupLocation.width - itemWidth;
            }
            var needValueText = true;
            if (this.dataRangeOption.text) {
                needValueText = false;
                if (this.dataRangeOption.text[0]) {
                    textShape = this._getTextShape(lastX, lastY, this.dataRangeOption.text[0]);
                    if (this.dataRangeOption.orient == 'horizontal') {
                        lastX += zrArea.getTextWidth(this.dataRangeOption.text[0], font) + this._textGap;
                    } else {
                        lastY += textHeight + this._textGap;
                        textShape.style.y += textHeight / 2 + this._textGap;
                        textShape.style.textBaseline = 'bottom';
                    }
                    this.shapeList.push(new TextShape(textShape));
                }
            }
            for (var i = 0; i < dataLength; i++) {
                itemName = data[i];
                color = this.getColorByIndex(i);
                itemShape = this._getItemShape(lastX, lastY, itemWidth, itemHeight, this._selectedMap[i] ? color : '#ccc');
                itemShape._idx = i;
                itemShape.onmousemove = this._dispatchHoverLink;
                if (this.dataRangeOption.selectedMode) {
                    itemShape.clickable = true;
                    itemShape.onclick = this._dataRangeSelected;
                }
                this.shapeList.push(new RectangleShape(itemShape));
                if (needValueText) {
                    textShape = {
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase(),
                        style: {
                            x: lastX + itemWidth + 5,
                            y: lastY,
                            color: this._selectedMap[i] ? this.dataRangeOption.textStyle.color : '#ccc',
                            text: data[i],
                            textFont: font,
                            textBaseline: 'top'
                        },
                        highlightStyle: { brushType: 'fill' }
                    };
                    if (this.dataRangeOption.orient == 'vertical' && this.dataRangeOption.x == 'right') {
                        textShape.style.x -= itemWidth + 10;
                        textShape.style.textAlign = 'right';
                    }
                    textShape._idx = i;
                    textShape.onmousemove = this._dispatchHoverLink;
                    if (this.dataRangeOption.selectedMode) {
                        textShape.clickable = true;
                        textShape.onclick = this._dataRangeSelected;
                    }
                    this.shapeList.push(new TextShape(textShape));
                }
                if (this.dataRangeOption.orient == 'horizontal') {
                    lastX += itemWidth + (needValueText ? 5 : 0) + (needValueText ? zrArea.getTextWidth(itemName, font) : 0) + itemGap;
                } else {
                    lastY += itemHeight + itemGap;
                }
            }
            if (!needValueText && this.dataRangeOption.text[1]) {
                if (this.dataRangeOption.orient == 'horizontal') {
                    lastX = lastX - itemGap + this._textGap;
                } else {
                    lastY = lastY - itemGap + this._textGap;
                }
                textShape = this._getTextShape(lastX, lastY, this.dataRangeOption.text[1]);
                if (this.dataRangeOption.orient != 'horizontal') {
                    textShape.style.y -= 5;
                    textShape.style.textBaseline = 'top';
                }
                this.shapeList.push(new TextShape(textShape));
            }
        },
        _buildGradient: function () {
            var itemShape;
            var textShape;
            var font = this.getFont(this.dataRangeOption.textStyle);
            var lastX = this._itemGroupLocation.x;
            var lastY = this._itemGroupLocation.y;
            var itemWidth = this.dataRangeOption.itemWidth;
            var itemHeight = this.dataRangeOption.itemHeight;
            var textHeight = zrArea.getTextHeight('å›½', font);
            var mSize = 10;
            var needValueText = true;
            if (this.dataRangeOption.text) {
                needValueText = false;
                if (this.dataRangeOption.text[0]) {
                    textShape = this._getTextShape(lastX, lastY, this.dataRangeOption.text[0]);
                    if (this.dataRangeOption.orient == 'horizontal') {
                        lastX += zrArea.getTextWidth(this.dataRangeOption.text[0], font) + this._textGap;
                    } else {
                        lastY += textHeight + this._textGap;
                        textShape.style.y += textHeight / 2 + this._textGap;
                        textShape.style.textBaseline = 'bottom';
                    }
                    this.shapeList.push(new TextShape(textShape));
                }
            }
            var zrColor = require('zrender/tool/color');
            var per = 1 / (this.dataRangeOption.color.length - 1);
            var colorList = [];
            for (var i = 0, l = this.dataRangeOption.color.length; i < l; i++) {
                colorList.push([
                    i * per,
                    this.dataRangeOption.color[i]
                ]);
            }
            if (this.dataRangeOption.orient == 'horizontal') {
                itemShape = {
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    style: {
                        x: lastX,
                        y: lastY,
                        width: itemWidth * mSize,
                        height: itemHeight,
                        color: zrColor.getLinearGradient(lastX, lastY, lastX + itemWidth * mSize, lastY, colorList)
                    },
                    hoverable: false
                };
                lastX += itemWidth * mSize + this._textGap;
            } else {
                itemShape = {
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    style: {
                        x: lastX,
                        y: lastY,
                        width: itemWidth,
                        height: itemHeight * mSize,
                        color: zrColor.getLinearGradient(lastX, lastY, lastX, lastY + itemHeight * mSize, colorList)
                    },
                    hoverable: false
                };
                lastY += itemHeight * mSize + this._textGap;
            }
            this.shapeList.push(new RectangleShape(itemShape));
            this._calculableLocation = itemShape.style;
            if (this.dataRangeOption.calculable) {
                this._buildFiller();
                this._bulidMask();
                this._bulidHandle();
            }
            this._buildIndicator();
            if (!needValueText && this.dataRangeOption.text[1]) {
                textShape = this._getTextShape(lastX, lastY, this.dataRangeOption.text[1]);
                this.shapeList.push(new TextShape(textShape));
            }
        },
        _buildIndicator: function () {
            var x = this._calculableLocation.x;
            var y = this._calculableLocation.y;
            var width = this._calculableLocation.width;
            var height = this._calculableLocation.height;
            var size = 5;
            var pointList;
            var textPosition;
            if (this.dataRangeOption.orient == 'horizontal') {
                if (this.dataRangeOption.y != 'bottom') {
                    pointList = [
                        [
                            x,
                            y + height
                        ],
                        [
                            x - size,
                            y + height + size
                        ],
                        [
                            x + size,
                            y + height + size
                        ]
                    ];
                    textPosition = 'bottom';
                } else {
                    pointList = [
                        [
                            x,
                            y
                        ],
                        [
                            x - size,
                            y - size
                        ],
                        [
                            x + size,
                            y - size
                        ]
                    ];
                    textPosition = 'top';
                }
            } else {
                if (this.dataRangeOption.x != 'right') {
                    pointList = [
                        [
                            x + width,
                            y
                        ],
                        [
                            x + width + size,
                            y - size
                        ],
                        [
                            x + width + size,
                            y + size
                        ]
                    ];
                    textPosition = 'right';
                } else {
                    pointList = [
                        [
                            x,
                            y
                        ],
                        [
                            x - size,
                            y - size
                        ],
                        [
                            x - size,
                            y + size
                        ]
                    ];
                    textPosition = 'left';
                }
            }
            this._indicatorShape = {
                style: {
                    pointList: pointList,
                    color: '#fff',
                    __rect: {
                        x: Math.min(pointList[0][0], pointList[1][0]),
                        y: Math.min(pointList[0][1], pointList[1][1]),
                        width: size * (this.dataRangeOption.orient == 'horizontal' ? 2 : 1),
                        height: size * (this.dataRangeOption.orient == 'horizontal' ? 1 : 2)
                    }
                },
                highlightStyle: {
                    brushType: 'fill',
                    textPosition: textPosition,
                    textColor: this.dataRangeOption.textStyle.color
                },
                hoverable: false
            };
            this._indicatorShape = new HandlePolygonShape(this._indicatorShape);
        },
        _buildFiller: function () {
            this._fillerShape = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase() + 1,
                style: {
                    x: this._calculableLocation.x,
                    y: this._calculableLocation.y,
                    width: this._calculableLocation.width,
                    height: this._calculableLocation.height,
                    color: 'rgba(255,255,255,0)'
                },
                highlightStyle: {
                    strokeColor: 'rgba(255,255,255,0.5)',
                    lineWidth: 1
                },
                draggable: true,
                ondrift: this._ondrift,
                ondragend: this._ondragend,
                onmousemove: this._dispatchHoverLink,
                _type: 'filler'
            };
            this._fillerShape = new RectangleShape(this._fillerShape);
            this.shapeList.push(this._fillerShape);
        },
        _bulidHandle: function () {
            var x = this._calculableLocation.x;
            var y = this._calculableLocation.y;
            var width = this._calculableLocation.width;
            var height = this._calculableLocation.height;
            var font = this.getFont(this.dataRangeOption.textStyle);
            var textHeight = zrArea.getTextHeight('å›½', font);
            var textWidth = Math.max(zrArea.getTextWidth(this._textFormat(this.dataRangeOption.max), font), zrArea.getTextWidth(this._textFormat(this.dataRangeOption.min), font)) + 2;
            var pointListStart;
            var textXStart;
            var textYStart;
            var coverRectStart;
            var pointListEnd;
            var textXEnd;
            var textYEnd;
            var coverRectEnd;
            if (this.dataRangeOption.orient == 'horizontal') {
                if (this.dataRangeOption.y != 'bottom') {
                    pointListStart = [
                        [
                            x,
                            y
                        ],
                        [
                            x,
                            y + height + textHeight
                        ],
                        [
                            x - textHeight,
                            y + height + textHeight
                        ],
                        [
                            x - 1,
                            y + height
                        ],
                        [
                            x - 1,
                            y
                        ]
                    ];
                    textXStart = x - textWidth / 2 - textHeight;
                    textYStart = y + height + textHeight / 2 + 2;
                    coverRectStart = {
                        x: x - textWidth - textHeight,
                        y: y + height,
                        width: textWidth + textHeight,
                        height: textHeight
                    };
                    pointListEnd = [
                        [
                            x + width,
                            y
                        ],
                        [
                            x + width,
                            y + height + textHeight
                        ],
                        [
                            x + width + textHeight,
                            y + height + textHeight
                        ],
                        [
                            x + width + 1,
                            y + height
                        ],
                        [
                            x + width + 1,
                            y
                        ]
                    ];
                    textXEnd = x + width + textWidth / 2 + textHeight;
                    textYEnd = textYStart;
                    coverRectEnd = {
                        x: x + width,
                        y: y + height,
                        width: textWidth + textHeight,
                        height: textHeight
                    };
                } else {
                    pointListStart = [
                        [
                            x,
                            y + height
                        ],
                        [
                            x,
                            y - textHeight
                        ],
                        [
                            x - textHeight,
                            y - textHeight
                        ],
                        [
                            x - 1,
                            y
                        ],
                        [
                            x - 1,
                            y + height
                        ]
                    ];
                    textXStart = x - textWidth / 2 - textHeight;
                    textYStart = y - textHeight / 2 - 2;
                    coverRectStart = {
                        x: x - textWidth - textHeight,
                        y: y - textHeight,
                        width: textWidth + textHeight,
                        height: textHeight
                    };
                    pointListEnd = [
                        [
                            x + width,
                            y + height
                        ],
                        [
                            x + width,
                            y - textHeight
                        ],
                        [
                            x + width + textHeight,
                            y - textHeight
                        ],
                        [
                            x + width + 1,
                            y
                        ],
                        [
                            x + width + 1,
                            y + height
                        ]
                    ];
                    textXEnd = x + width + textWidth / 2 + textHeight;
                    textYEnd = textYStart;
                    coverRectEnd = {
                        x: x + width,
                        y: y - textHeight,
                        width: textWidth + textHeight,
                        height: textHeight
                    };
                }
            } else {
                textWidth += textHeight;
                if (this.dataRangeOption.x != 'right') {
                    pointListStart = [
                        [
                            x,
                            y
                        ],
                        [
                            x + width + textHeight,
                            y
                        ],
                        [
                            x + width + textHeight,
                            y - textHeight
                        ],
                        [
                            x + width,
                            y - 1
                        ],
                        [
                            x,
                            y - 1
                        ]
                    ];
                    textXStart = x + width + textWidth / 2 + textHeight / 2;
                    textYStart = y - textHeight / 2;
                    coverRectStart = {
                        x: x + width,
                        y: y - textHeight,
                        width: textWidth + textHeight,
                        height: textHeight
                    };
                    pointListEnd = [
                        [
                            x,
                            y + height
                        ],
                        [
                            x + width + textHeight,
                            y + height
                        ],
                        [
                            x + width + textHeight,
                            y + textHeight + height
                        ],
                        [
                            x + width,
                            y + 1 + height
                        ],
                        [
                            x,
                            y + height + 1
                        ]
                    ];
                    textXEnd = textXStart;
                    textYEnd = y + height + textHeight / 2;
                    coverRectEnd = {
                        x: x + width,
                        y: y + height,
                        width: textWidth + textHeight,
                        height: textHeight
                    };
                } else {
                    pointListStart = [
                        [
                            x + width,
                            y
                        ],
                        [
                            x - textHeight,
                            y
                        ],
                        [
                            x - textHeight,
                            y - textHeight
                        ],
                        [
                            x,
                            y - 1
                        ],
                        [
                            x + width,
                            y - 1
                        ]
                    ];
                    textXStart = x - textWidth / 2 - textHeight / 2;
                    textYStart = y - textHeight / 2;
                    coverRectStart = {
                        x: x - textWidth - textHeight,
                        y: y - textHeight,
                        width: textWidth + textHeight,
                        height: textHeight
                    };
                    pointListEnd = [
                        [
                            x + width,
                            y + height
                        ],
                        [
                            x - textHeight,
                            y + height
                        ],
                        [
                            x - textHeight,
                            y + textHeight + height
                        ],
                        [
                            x,
                            y + 1 + height
                        ],
                        [
                            x + width,
                            y + height + 1
                        ]
                    ];
                    textXEnd = textXStart;
                    textYEnd = y + height + textHeight / 2;
                    coverRectEnd = {
                        x: x - textWidth - textHeight,
                        y: y + height,
                        width: textWidth + textHeight,
                        height: textHeight
                    };
                }
            }
            this._startShape = {
                style: {
                    pointList: pointListStart,
                    text: this._textFormat(this.dataRangeOption.max),
                    textX: textXStart,
                    textY: textYStart,
                    textFont: font,
                    color: this.getColor(this.dataRangeOption.max),
                    rect: coverRectStart,
                    x: pointListStart[0][0],
                    y: pointListStart[0][1],
                    _x: pointListStart[0][0],
                    _y: pointListStart[0][1]
                }
            };
            this._startShape.highlightStyle = {
                strokeColor: this._startShape.style.color,
                lineWidth: 1
            };
            this._endShape = {
                style: {
                    pointList: pointListEnd,
                    text: this._textFormat(this.dataRangeOption.min),
                    textX: textXEnd,
                    textY: textYEnd,
                    textFont: font,
                    color: this.getColor(this.dataRangeOption.min),
                    rect: coverRectEnd,
                    x: pointListEnd[0][0],
                    y: pointListEnd[0][1],
                    _x: pointListEnd[0][0],
                    _y: pointListEnd[0][1]
                }
            };
            this._endShape.highlightStyle = {
                strokeColor: this._endShape.style.color,
                lineWidth: 1
            };
            this._startShape.zlevel = this._endShape.zlevel = this.getZlevelBase();
            this._startShape.z = this._endShape.z = this.getZBase() + 1;
            this._startShape.draggable = this._endShape.draggable = true;
            this._startShape.ondrift = this._endShape.ondrift = this._ondrift;
            this._startShape.ondragend = this._endShape.ondragend = this._ondragend;
            this._startShape.style.textColor = this._endShape.style.textColor = this.dataRangeOption.textStyle.color;
            this._startShape.style.textAlign = this._endShape.style.textAlign = 'center';
            this._startShape.style.textPosition = this._endShape.style.textPosition = 'specific';
            this._startShape.style.textBaseline = this._endShape.style.textBaseline = 'middle';
            this._startShape.style.width = this._endShape.style.width = 0;
            this._startShape.style.height = this._endShape.style.height = 0;
            this._startShape.style.textPosition = this._endShape.style.textPosition = 'specific';
            this._startShape = new HandlePolygonShape(this._startShape);
            this._endShape = new HandlePolygonShape(this._endShape);
            this.shapeList.push(this._startShape);
            this.shapeList.push(this._endShape);
        },
        _bulidMask: function () {
            var x = this._calculableLocation.x;
            var y = this._calculableLocation.y;
            var width = this._calculableLocation.width;
            var height = this._calculableLocation.height;
            this._startMask = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase() + 1,
                style: {
                    x: x,
                    y: y,
                    width: this.dataRangeOption.orient == 'horizontal' ? 0 : width,
                    height: this.dataRangeOption.orient == 'horizontal' ? height : 0,
                    color: '#ccc'
                },
                hoverable: false
            };
            this._endMask = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase() + 1,
                style: {
                    x: this.dataRangeOption.orient == 'horizontal' ? x + width : x,
                    y: this.dataRangeOption.orient == 'horizontal' ? y : y + height,
                    width: this.dataRangeOption.orient == 'horizontal' ? 0 : width,
                    height: this.dataRangeOption.orient == 'horizontal' ? height : 0,
                    color: '#ccc'
                },
                hoverable: false
            };
            this._startMask = new RectangleShape(this._startMask);
            this._endMask = new RectangleShape(this._endMask);
            this.shapeList.push(this._startMask);
            this.shapeList.push(this._endMask);
        },
        _buildBackground: function () {
            var padding = this.reformCssArray(this.dataRangeOption.padding);
            this.shapeList.push(new RectangleShape({
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                hoverable: false,
                style: {
                    x: this._itemGroupLocation.x - padding[3],
                    y: this._itemGroupLocation.y - padding[0],
                    width: this._itemGroupLocation.width + padding[3] + padding[1],
                    height: this._itemGroupLocation.height + padding[0] + padding[2],
                    brushType: this.dataRangeOption.borderWidth === 0 ? 'fill' : 'both',
                    color: this.dataRangeOption.backgroundColor,
                    strokeColor: this.dataRangeOption.borderColor,
                    lineWidth: this.dataRangeOption.borderWidth
                }
            }));
        },
        _getItemGroupLocation: function () {
            var data = this._valueTextList;
            var dataLength = data.length;
            var itemGap = this.dataRangeOption.itemGap;
            var itemWidth = this.dataRangeOption.itemWidth;
            var itemHeight = this.dataRangeOption.itemHeight;
            var totalWidth = 0;
            var totalHeight = 0;
            var font = this.getFont(this.dataRangeOption.textStyle);
            var textHeight = zrArea.getTextHeight('å›½', font);
            var mSize = 10;
            if (this.dataRangeOption.orient == 'horizontal') {
                if (this.dataRangeOption.text || this.dataRangeOption.splitNumber <= 0 || this.dataRangeOption.calculable) {
                    totalWidth = (this.dataRangeOption.splitNumber <= 0 || this.dataRangeOption.calculable ? itemWidth * mSize + itemGap : dataLength * (itemWidth + itemGap)) + (this.dataRangeOption.text && typeof this.dataRangeOption.text[0] != 'undefined' ? zrArea.getTextWidth(this.dataRangeOption.text[0], font) + this._textGap : 0) + (this.dataRangeOption.text && typeof this.dataRangeOption.text[1] != 'undefined' ? zrArea.getTextWidth(this.dataRangeOption.text[1], font) + this._textGap : 0);
                } else {
                    itemWidth += 5;
                    for (var i = 0; i < dataLength; i++) {
                        totalWidth += itemWidth + zrArea.getTextWidth(data[i], font) + itemGap;
                    }
                }
                totalWidth -= itemGap;
                totalHeight = Math.max(textHeight, itemHeight);
            } else {
                var maxWidth;
                if (this.dataRangeOption.text || this.dataRangeOption.splitNumber <= 0 || this.dataRangeOption.calculable) {
                    totalHeight = (this.dataRangeOption.splitNumber <= 0 || this.dataRangeOption.calculable ? itemHeight * mSize + itemGap : dataLength * (itemHeight + itemGap)) + (this.dataRangeOption.text && typeof this.dataRangeOption.text[0] != 'undefined' ? this._textGap + textHeight : 0) + (this.dataRangeOption.text && typeof this.dataRangeOption.text[1] != 'undefined' ? this._textGap + textHeight : 0);
                    maxWidth = Math.max(zrArea.getTextWidth(this.dataRangeOption.text && this.dataRangeOption.text[0] || '', font), zrArea.getTextWidth(this.dataRangeOption.text && this.dataRangeOption.text[1] || '', font));
                    totalWidth = Math.max(itemWidth, maxWidth);
                } else {
                    totalHeight = (itemHeight + itemGap) * dataLength;
                    itemWidth += 5;
                    maxWidth = 0;
                    for (var i = 0; i < dataLength; i++) {
                        maxWidth = Math.max(maxWidth, zrArea.getTextWidth(data[i], font));
                    }
                    totalWidth = itemWidth + maxWidth;
                }
                totalHeight -= itemGap;
            }
            var padding = this.reformCssArray(this.dataRangeOption.padding);
            var x;
            var zrWidth = this.zr.getWidth();
            switch (this.dataRangeOption.x) {
            case 'center':
                x = Math.floor((zrWidth - totalWidth) / 2);
                break;
            case 'left':
                x = padding[3] + this.dataRangeOption.borderWidth;
                break;
            case 'right':
                x = zrWidth - totalWidth - padding[1] - this.dataRangeOption.borderWidth;
                break;
            default:
                x = this.parsePercent(this.dataRangeOption.x, zrWidth);
                x = isNaN(x) ? 0 : x;
                break;
            }
            var y;
            var zrHeight = this.zr.getHeight();
            switch (this.dataRangeOption.y) {
            case 'top':
                y = padding[0] + this.dataRangeOption.borderWidth;
                break;
            case 'bottom':
                y = zrHeight - totalHeight - padding[2] - this.dataRangeOption.borderWidth;
                break;
            case 'center':
                y = Math.floor((zrHeight - totalHeight) / 2);
                break;
            default:
                y = this.parsePercent(this.dataRangeOption.y, zrHeight);
                y = isNaN(y) ? 0 : y;
                break;
            }
            if (this.dataRangeOption.calculable) {
                var handlerWidth = Math.max(zrArea.getTextWidth(this.dataRangeOption.max, font), zrArea.getTextWidth(this.dataRangeOption.min, font)) + textHeight;
                if (this.dataRangeOption.orient == 'horizontal') {
                    if (x < handlerWidth) {
                        x = handlerWidth;
                    }
                    if (x + totalWidth + handlerWidth > zrWidth) {
                        x -= handlerWidth;
                    }
                } else {
                    if (y < textHeight) {
                        y = textHeight;
                    }
                    if (y + totalHeight + textHeight > zrHeight) {
                        y -= textHeight;
                    }
                }
            }
            return {
                x: x,
                y: y,
                width: totalWidth,
                height: totalHeight
            };
        },
        _getTextShape: function (x, y, text) {
            return {
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                style: {
                    x: this.dataRangeOption.orient == 'horizontal' ? x : this._itemGroupLocation.x + this._itemGroupLocation.width / 2,
                    y: this.dataRangeOption.orient == 'horizontal' ? this._itemGroupLocation.y + this._itemGroupLocation.height / 2 : y,
                    color: this.dataRangeOption.textStyle.color,
                    text: text,
                    textFont: this.getFont(this.dataRangeOption.textStyle),
                    textBaseline: this.dataRangeOption.orient == 'horizontal' ? 'middle' : 'top',
                    textAlign: this.dataRangeOption.orient == 'horizontal' ? 'left' : 'center'
                },
                hoverable: false
            };
        },
        _getItemShape: function (x, y, width, height, color) {
            return {
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                style: {
                    x: x,
                    y: y + 1,
                    width: width,
                    height: height - 2,
                    color: color
                },
                highlightStyle: {
                    strokeColor: color,
                    lineWidth: 1
                }
            };
        },
        __ondrift: function (shape, dx, dy) {
            var x = this._calculableLocation.x;
            var y = this._calculableLocation.y;
            var width = this._calculableLocation.width;
            var height = this._calculableLocation.height;
            if (this.dataRangeOption.orient == 'horizontal') {
                if (shape.style.x + dx <= x) {
                    shape.style.x = x;
                } else if (shape.style.x + dx + shape.style.width >= x + width) {
                    shape.style.x = x + width - shape.style.width;
                } else {
                    shape.style.x += dx;
                }
            } else {
                if (shape.style.y + dy <= y) {
                    shape.style.y = y;
                } else if (shape.style.y + dy + shape.style.height >= y + height) {
                    shape.style.y = y + height - shape.style.height;
                } else {
                    shape.style.y += dy;
                }
            }
            if (shape._type == 'filler') {
                this._syncHandleShape();
            } else {
                this._syncFillerShape(shape);
            }
            if (this.dataRangeOption.realtime) {
                this._dispatchDataRange();
            }
            return true;
        },
        __ondragend: function () {
            this.isDragend = true;
        },
        ondragend: function (param, status) {
            if (!this.isDragend || !param.target) {
                return;
            }
            status.dragOut = true;
            status.dragIn = true;
            if (!this.dataRangeOption.realtime) {
                this._dispatchDataRange();
            }
            status.needRefresh = false;
            this.isDragend = false;
            return;
        },
        _syncShapeFromRange: function () {
            var range = this.dataRangeOption.range || {};
            this._range.end = typeof this._range.end != 'undefined' ? this._range.end : typeof range.start != 'undefined' ? range.start : 0;
            this._range.start = typeof this._range.start != 'undefined' ? this._range.start : typeof range.end != 'undefined' ? range.end : 100;
            if (this._range.start != 100 || this._range.end !== 0) {
                if (this.dataRangeOption.orient == 'horizontal') {
                    var width = this._fillerShape.style.width;
                    this._fillerShape.style.x += width * (100 - this._range.start) / 100;
                    this._fillerShape.style.width = width * (this._range.start - this._range.end) / 100;
                } else {
                    var height = this._fillerShape.style.height;
                    this._fillerShape.style.y += height * (100 - this._range.start) / 100;
                    this._fillerShape.style.height = height * (this._range.start - this._range.end) / 100;
                }
                this.zr.modShape(this._fillerShape.id);
                this._syncHandleShape();
            }
        },
        _syncHandleShape: function () {
            var x = this._calculableLocation.x;
            var y = this._calculableLocation.y;
            var width = this._calculableLocation.width;
            var height = this._calculableLocation.height;
            if (this.dataRangeOption.orient == 'horizontal') {
                this._startShape.style.x = this._fillerShape.style.x;
                this._startMask.style.width = this._startShape.style.x - x;
                this._endShape.style.x = this._fillerShape.style.x + this._fillerShape.style.width;
                this._endMask.style.x = this._endShape.style.x;
                this._endMask.style.width = x + width - this._endShape.style.x;
                this._range.start = Math.ceil(100 - (this._startShape.style.x - x) / width * 100);
                this._range.end = Math.floor(100 - (this._endShape.style.x - x) / width * 100);
            } else {
                this._startShape.style.y = this._fillerShape.style.y;
                this._startMask.style.height = this._startShape.style.y - y;
                this._endShape.style.y = this._fillerShape.style.y + this._fillerShape.style.height;
                this._endMask.style.y = this._endShape.style.y;
                this._endMask.style.height = y + height - this._endShape.style.y;
                this._range.start = Math.ceil(100 - (this._startShape.style.y - y) / height * 100);
                this._range.end = Math.floor(100 - (this._endShape.style.y - y) / height * 100);
            }
            this._syncShape();
        },
        _syncFillerShape: function (e) {
            var x = this._calculableLocation.x;
            var y = this._calculableLocation.y;
            var width = this._calculableLocation.width;
            var height = this._calculableLocation.height;
            var a;
            var b;
            if (this.dataRangeOption.orient == 'horizontal') {
                a = this._startShape.style.x;
                b = this._endShape.style.x;
                if (e.id == this._startShape.id && a >= b) {
                    b = a;
                    this._endShape.style.x = a;
                } else if (e.id == this._endShape.id && a >= b) {
                    a = b;
                    this._startShape.style.x = a;
                }
                this._fillerShape.style.x = a;
                this._fillerShape.style.width = b - a;
                this._startMask.style.width = a - x;
                this._endMask.style.x = b;
                this._endMask.style.width = x + width - b;
                this._range.start = Math.ceil(100 - (a - x) / width * 100);
                this._range.end = Math.floor(100 - (b - x) / width * 100);
            } else {
                a = this._startShape.style.y;
                b = this._endShape.style.y;
                if (e.id == this._startShape.id && a >= b) {
                    b = a;
                    this._endShape.style.y = a;
                } else if (e.id == this._endShape.id && a >= b) {
                    a = b;
                    this._startShape.style.y = a;
                }
                this._fillerShape.style.y = a;
                this._fillerShape.style.height = b - a;
                this._startMask.style.height = a - y;
                this._endMask.style.y = b;
                this._endMask.style.height = y + height - b;
                this._range.start = Math.ceil(100 - (a - y) / height * 100);
                this._range.end = Math.floor(100 - (b - y) / height * 100);
            }
            this._syncShape();
        },
        _syncShape: function () {
            this._startShape.position = [
                this._startShape.style.x - this._startShape.style._x,
                this._startShape.style.y - this._startShape.style._y
            ];
            this._startShape.style.text = this._textFormat(this._gap * this._range.start + this.dataRangeOption.min);
            this._startShape.style.color = this._startShape.highlightStyle.strokeColor = this.getColor(this._gap * this._range.start + this.dataRangeOption.min);
            this._endShape.position = [
                this._endShape.style.x - this._endShape.style._x,
                this._endShape.style.y - this._endShape.style._y
            ];
            this._endShape.style.text = this._textFormat(this._gap * this._range.end + this.dataRangeOption.min);
            this._endShape.style.color = this._endShape.highlightStyle.strokeColor = this.getColor(this._gap * this._range.end + this.dataRangeOption.min);
            this.zr.modShape(this._startShape.id);
            this.zr.modShape(this._endShape.id);
            this.zr.modShape(this._startMask.id);
            this.zr.modShape(this._endMask.id);
            this.zr.modShape(this._fillerShape.id);
            this.zr.refreshNextFrame();
        },
        _dispatchDataRange: function () {
            this.messageCenter.dispatch(ecConfig.EVENT.DATA_RANGE, null, {
                range: {
                    start: this._range.end,
                    end: this._range.start
                }
            }, this.myChart);
        },
        __dataRangeSelected: function (param) {
            if (this.dataRangeOption.selectedMode === 'single') {
                for (var k in this._selectedMap) {
                    this._selectedMap[k] = false;
                }
            }
            var idx = param.target._idx;
            this._selectedMap[idx] = !this._selectedMap[idx];
            var valueMax = (this._colorList.length - idx) * this._gap + this.dataRangeOption.min;
            this.messageCenter.dispatch(ecConfig.EVENT.DATA_RANGE_SELECTED, param.event, {
                selected: this._selectedMap,
                target: idx,
                valueMax: valueMax,
                valueMin: valueMax - this._gap
            }, this.myChart);
            this.messageCenter.dispatch(ecConfig.EVENT.REFRESH, null, null, this.myChart);
        },
        __dispatchHoverLink: function (param) {
            var valueMin;
            var valueMax;
            if (this.dataRangeOption.calculable) {
                var totalValue = this.dataRangeOption.max - this.dataRangeOption.min;
                var curValue;
                if (this.dataRangeOption.orient == 'horizontal') {
                    curValue = (1 - (zrEvent.getX(param.event) - this._calculableLocation.x) / this._calculableLocation.width) * totalValue;
                } else {
                    curValue = (1 - (zrEvent.getY(param.event) - this._calculableLocation.y) / this._calculableLocation.height) * totalValue;
                }
                valueMin = curValue - totalValue * 0.05;
                valueMax = curValue + totalValue * 0.05;
            } else {
                var idx = param.target._idx;
                valueMax = (this._colorList.length - idx) * this._gap + this.dataRangeOption.min;
                valueMin = valueMax - this._gap;
            }
            this.messageCenter.dispatch(ecConfig.EVENT.DATA_RANGE_HOVERLINK, param.event, {
                valueMin: valueMin,
                valueMax: valueMax
            }, this.myChart);
            return;
        },
        __onhoverlink: function (param) {
            if (this.dataRangeOption.show && this.dataRangeOption.hoverLink && this._indicatorShape && param && param.seriesIndex != null && param.dataIndex != null) {
                var curValue = param.value;
                if (curValue === '' || isNaN(curValue)) {
                    return;
                }
                if (curValue < this.dataRangeOption.min) {
                    curValue = this.dataRangeOption.min;
                } else if (curValue > this.dataRangeOption.max) {
                    curValue = this.dataRangeOption.max;
                }
                if (this.dataRangeOption.orient == 'horizontal') {
                    this._indicatorShape.position = [
                        (this.dataRangeOption.max - curValue) / (this.dataRangeOption.max - this.dataRangeOption.min) * this._calculableLocation.width,
                        0
                    ];
                } else {
                    this._indicatorShape.position = [
                        0,
                        (this.dataRangeOption.max - curValue) / (this.dataRangeOption.max - this.dataRangeOption.min) * this._calculableLocation.height
                    ];
                }
                this._indicatorShape.style.text = this._textFormat(param.value);
                this._indicatorShape.style.color = this.getColor(curValue);
                this.zr.addHoverShape(this._indicatorShape);
            }
        },
        _textFormat: function (valueStart, valueEnd) {
            valueStart = (+valueStart).toFixed(this.dataRangeOption.precision);
            valueEnd = valueEnd != null ? (+valueEnd).toFixed(this.dataRangeOption.precision) : '';
            if (this.dataRangeOption.formatter) {
                if (typeof this.dataRangeOption.formatter == 'string') {
                    return this.dataRangeOption.formatter.replace('{value}', valueStart).replace('{value2}', valueEnd);
                } else if (typeof this.dataRangeOption.formatter == 'function') {
                    return this.dataRangeOption.formatter.call(this.myChart, valueStart, valueEnd);
                }
            }
            if (valueEnd !== '') {
                return valueStart + ' - ' + valueEnd;
            }
            return valueStart;
        },
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.option.dataRange = this.reformOption(this.option.dataRange);
                this.dataRangeOption = this.option.dataRange;
                if (!this.myChart.canvasSupported) {
                    this.dataRangeOption.realtime = false;
                }
                var splitNumber = this.dataRangeOption.splitNumber <= 0 || this.dataRangeOption.calculable ? 100 : this.dataRangeOption.splitNumber;
                this._colorList = zrColor.getGradientColors(this.dataRangeOption.color, Math.max((splitNumber - this.dataRangeOption.color.length) / (this.dataRangeOption.color.length - 1), 0) + 1);
                if (this._colorList.length > splitNumber) {
                    var len = this._colorList.length;
                    var newColorList = [this._colorList[0]];
                    var step = len / (splitNumber - 1);
                    for (var i = 1; i < splitNumber - 1; i++) {
                        newColorList.push(this._colorList[Math.floor(i * step)]);
                    }
                    newColorList.push(this._colorList[len - 1]);
                    this._colorList = newColorList;
                }
                var precision = this.dataRangeOption.precision;
                this._gap = (this.dataRangeOption.max - this.dataRangeOption.min) / splitNumber;
                while (this._gap.toFixed(precision) - 0 != this._gap && precision < 5) {
                    precision++;
                }
                this.dataRangeOption.precision = precision;
                this._gap = ((this.dataRangeOption.max - this.dataRangeOption.min) / splitNumber).toFixed(precision) - 0;
                this._valueTextList = [];
                for (var i = 0; i < splitNumber; i++) {
                    this._selectedMap[i] = true;
                    this._valueTextList.unshift(this._textFormat(i * this._gap + this.dataRangeOption.min, (i + 1) * this._gap + this.dataRangeOption.min));
                }
            }
            this.clear();
            this._buildShape();
        },
        getColor: function (value) {
            if (isNaN(value)) {
                return null;
            }
            if (this.dataRangeOption.min == this.dataRangeOption.max) {
                return this._colorList[0];
            }
            if (value < this.dataRangeOption.min) {
                value = this.dataRangeOption.min;
            } else if (value > this.dataRangeOption.max) {
                value = this.dataRangeOption.max;
            }
            if (this.dataRangeOption.calculable) {
                if (value - (this._gap * this._range.start + this.dataRangeOption.min) > 0.00005 || value - (this._gap * this._range.end + this.dataRangeOption.min) < -0.00005) {
                    return null;
                }
            }
            var idx = this._colorList.length - Math.ceil((value - this.dataRangeOption.min) / (this.dataRangeOption.max - this.dataRangeOption.min) * this._colorList.length);
            if (idx == this._colorList.length) {
                idx--;
            }
            if (this._selectedMap[idx]) {
                return this._colorList[idx];
            } else {
                return null;
            }
        },
        getColorByIndex: function (idx) {
            if (idx >= this._colorList.length) {
                idx = this._colorList.length - 1;
            } else if (idx < 0) {
                idx = 0;
            }
            return this._colorList[idx];
        },
        onbeforDispose: function () {
            this.messageCenter.unbind(ecConfig.EVENT.HOVER, this._onhoverlink);
        }
    };
    zrUtil.inherits(DataRange, Base);
    require('../component').define('dataRange', DataRange);
    return DataRange;
});define('echarts/util/shape/HandlePolygon', [
    'require',
    'zrender/shape/Base',
    'zrender/shape/Polygon',
    'zrender/tool/util'
], function (require) {
    var Base = require('zrender/shape/Base');
    var PolygonShape = require('zrender/shape/Polygon');
    var zrUtil = require('zrender/tool/util');
    function HandlePolygon(options) {
        Base.call(this, options);
    }
    HandlePolygon.prototype = {
        type: 'handle-polygon',
        buildPath: function (ctx, style) {
            PolygonShape.prototype.buildPath(ctx, style);
        },
        isCover: function (x, y) {
            var originPos = this.transformCoordToLocal(x, y);
            x = originPos[0];
            y = originPos[1];
            var rect = this.style.rect;
            if (x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height) {
                return true;
            } else {
                return false;
            }
        }
    };
    zrUtil.inherits(HandlePolygon, Base);
    return HandlePolygon;
});define('echarts/chart/k', [
    'require',
    './base',
    '../util/shape/Candle',
    '../component/axis',
    '../component/grid',
    '../component/dataZoom',
    '../config',
    '../util/ecData',
    'zrender/tool/util',
    '../chart'
], function (require) {
    var ChartBase = require('./base');
    var CandleShape = require('../util/shape/Candle');
    require('../component/axis');
    require('../component/grid');
    require('../component/dataZoom');
    var ecConfig = require('../config');
    ecConfig.k = {
        zlevel: 0,
        z: 2,
        clickable: true,
        hoverable: true,
        legendHoverLink: false,
        xAxisIndex: 0,
        yAxisIndex: 0,
        itemStyle: {
            normal: {
                color: '#fff',
                color0: '#00aa11',
                lineStyle: {
                    width: 1,
                    color: '#ff3200',
                    color0: '#00aa11'
                },
                label: { show: false }
            },
            emphasis: { label: { show: false } }
        }
    };
    var ecData = require('../util/ecData');
    var zrUtil = require('zrender/tool/util');
    function K(ecTheme, messageCenter, zr, option, myChart) {
        ChartBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.refresh(option);
    }
    K.prototype = {
        type: ecConfig.CHART_TYPE_K,
        _buildShape: function () {
            var series = this.series;
            this.selectedMap = {};
            var _position2sIndexMap = {
                top: [],
                bottom: []
            };
            var xAxis;
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].type === ecConfig.CHART_TYPE_K) {
                    series[i] = this.reformOption(series[i]);
                    this.legendHoverLink = series[i].legendHoverLink || this.legendHoverLink;
                    xAxis = this.component.xAxis.getAxis(series[i].xAxisIndex);
                    if (xAxis.type === ecConfig.COMPONENT_TYPE_AXIS_CATEGORY) {
                        _position2sIndexMap[xAxis.getPosition()].push(i);
                    }
                }
            }
            for (var position in _position2sIndexMap) {
                if (_position2sIndexMap[position].length > 0) {
                    this._buildSinglePosition(position, _position2sIndexMap[position]);
                }
            }
            this.addShapeList();
        },
        _buildSinglePosition: function (position, seriesArray) {
            var mapData = this._mapData(seriesArray);
            var locationMap = mapData.locationMap;
            var maxDataLength = mapData.maxDataLength;
            if (maxDataLength === 0 || locationMap.length === 0) {
                return;
            }
            this._buildHorizontal(seriesArray, maxDataLength, locationMap);
            for (var i = 0, l = seriesArray.length; i < l; i++) {
                this.buildMark(seriesArray[i]);
            }
        },
        _mapData: function (seriesArray) {
            var series = this.series;
            var serie;
            var serieName;
            var legend = this.component.legend;
            var locationMap = [];
            var maxDataLength = 0;
            for (var i = 0, l = seriesArray.length; i < l; i++) {
                serie = series[seriesArray[i]];
                serieName = serie.name;
                this.selectedMap[serieName] = legend ? legend.isSelected(serieName) : true;
                if (this.selectedMap[serieName]) {
                    locationMap.push(seriesArray[i]);
                }
                maxDataLength = Math.max(maxDataLength, serie.data.length);
            }
            return {
                locationMap: locationMap,
                maxDataLength: maxDataLength
            };
        },
        _buildHorizontal: function (seriesArray, maxDataLength, locationMap) {
            var series = this.series;
            var seriesIndex;
            var serie;
            var xAxisIndex;
            var categoryAxis;
            var yAxisIndex;
            var valueAxis;
            var pointList = {};
            var candleWidth;
            var data;
            var value;
            var barMaxWidth;
            for (var j = 0, k = locationMap.length; j < k; j++) {
                seriesIndex = locationMap[j];
                serie = series[seriesIndex];
                xAxisIndex = serie.xAxisIndex || 0;
                categoryAxis = this.component.xAxis.getAxis(xAxisIndex);
                candleWidth = serie.barWidth || Math.floor(categoryAxis.getGap() / 2);
                barMaxWidth = serie.barMaxWidth;
                if (barMaxWidth && barMaxWidth < candleWidth) {
                    candleWidth = barMaxWidth;
                }
                yAxisIndex = serie.yAxisIndex || 0;
                valueAxis = this.component.yAxis.getAxis(yAxisIndex);
                pointList[seriesIndex] = [];
                for (var i = 0, l = maxDataLength; i < l; i++) {
                    if (categoryAxis.getNameByIndex(i) == null) {
                        break;
                    }
                    data = serie.data[i];
                    value = this.getDataFromOption(data, '-');
                    if (value === '-' || value.length != 4) {
                        continue;
                    }
                    pointList[seriesIndex].push([
                        categoryAxis.getCoordByIndex(i),
                        candleWidth,
                        valueAxis.getCoord(value[0]),
                        valueAxis.getCoord(value[1]),
                        valueAxis.getCoord(value[2]),
                        valueAxis.getCoord(value[3]),
                        i,
                        categoryAxis.getNameByIndex(i)
                    ]);
                }
            }
            this._buildKLine(seriesArray, pointList);
        },
        _buildKLine: function (seriesArray, pointList) {
            var series = this.series;
            var nLineWidth;
            var nLineColor;
            var nLineColor0;
            var nColor;
            var nColor0;
            var eLineWidth;
            var eLineColor;
            var eLineColor0;
            var eColor;
            var eColor0;
            var serie;
            var queryTarget;
            var data;
            var seriesPL;
            var singlePoint;
            var candleType;
            var seriesIndex;
            for (var sIdx = 0, len = seriesArray.length; sIdx < len; sIdx++) {
                seriesIndex = seriesArray[sIdx];
                serie = series[seriesIndex];
                seriesPL = pointList[seriesIndex];
                if (this._isLarge(seriesPL)) {
                    seriesPL = this._getLargePointList(seriesPL);
                }
                if (serie.type === ecConfig.CHART_TYPE_K && seriesPL != null) {
                    queryTarget = serie;
                    nLineWidth = this.query(queryTarget, 'itemStyle.normal.lineStyle.width');
                    nLineColor = this.query(queryTarget, 'itemStyle.normal.lineStyle.color');
                    nLineColor0 = this.query(queryTarget, 'itemStyle.normal.lineStyle.color0');
                    nColor = this.query(queryTarget, 'itemStyle.normal.color');
                    nColor0 = this.query(queryTarget, 'itemStyle.normal.color0');
                    eLineWidth = this.query(queryTarget, 'itemStyle.emphasis.lineStyle.width');
                    eLineColor = this.query(queryTarget, 'itemStyle.emphasis.lineStyle.color');
                    eLineColor0 = this.query(queryTarget, 'itemStyle.emphasis.lineStyle.color0');
                    eColor = this.query(queryTarget, 'itemStyle.emphasis.color');
                    eColor0 = this.query(queryTarget, 'itemStyle.emphasis.color0');
                    for (var i = 0, l = seriesPL.length; i < l; i++) {
                        singlePoint = seriesPL[i];
                        data = serie.data[singlePoint[6]];
                        queryTarget = data;
                        candleType = singlePoint[3] < singlePoint[2];
                        this.shapeList.push(this._getCandle(seriesIndex, singlePoint[6], singlePoint[7], singlePoint[0], singlePoint[1], singlePoint[2], singlePoint[3], singlePoint[4], singlePoint[5], candleType ? this.query(queryTarget, 'itemStyle.normal.color') || nColor : this.query(queryTarget, 'itemStyle.normal.color0') || nColor0, this.query(queryTarget, 'itemStyle.normal.lineStyle.width') || nLineWidth, candleType ? this.query(queryTarget, 'itemStyle.normal.lineStyle.color') || nLineColor : this.query(queryTarget, 'itemStyle.normal.lineStyle.color0') || nLineColor0, candleType ? this.query(queryTarget, 'itemStyle.emphasis.color') || eColor || nColor : this.query(queryTarget, 'itemStyle.emphasis.color0') || eColor0 || nColor0, this.query(queryTarget, 'itemStyle.emphasis.lineStyle.width') || eLineWidth || nLineWidth, candleType ? this.query(queryTarget, 'itemStyle.emphasis.lineStyle.color') || eLineColor || nLineColor : this.query(queryTarget, 'itemStyle.emphasis.lineStyle.color0') || eLineColor0 || nLineColor0));
                    }
                }
            }
        },
        _isLarge: function (singlePL) {
            return singlePL[0][1] < 0.5;
        },
        _getLargePointList: function (singlePL) {
            var total = this.component.grid.getWidth();
            var len = singlePL.length;
            var newList = [];
            for (var i = 0; i < total; i++) {
                newList[i] = singlePL[Math.floor(len / total * i)];
            }
            return newList;
        },
        _getCandle: function (seriesIndex, dataIndex, name, x, width, y0, y1, y2, y3, nColor, nLinewidth, nLineColor, eColor, eLinewidth, eLineColor) {
            var series = this.series;
            var serie = series[seriesIndex];
            var data = serie.data[dataIndex];
            var queryTarget = [
                data,
                serie
            ];
            var itemShape = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                clickable: this.deepQuery(queryTarget, 'clickable'),
                hoverable: this.deepQuery(queryTarget, 'hoverable'),
                style: {
                    x: x,
                    y: [
                        y0,
                        y1,
                        y2,
                        y3
                    ],
                    width: width,
                    color: nColor,
                    strokeColor: nLineColor,
                    lineWidth: nLinewidth,
                    brushType: 'both'
                },
                highlightStyle: {
                    color: eColor,
                    strokeColor: eLineColor,
                    lineWidth: eLinewidth
                },
                _seriesIndex: seriesIndex
            };
            itemShape = this.addLabel(itemShape, serie, data, name);
            ecData.pack(itemShape, serie, seriesIndex, data, dataIndex, name);
            itemShape = new CandleShape(itemShape);
            return itemShape;
        },
        getMarkCoord: function (seriesIndex, mpData) {
            var serie = this.series[seriesIndex];
            var xAxis = this.component.xAxis.getAxis(serie.xAxisIndex);
            var yAxis = this.component.yAxis.getAxis(serie.yAxisIndex);
            return [
                typeof mpData.xAxis != 'string' && xAxis.getCoordByIndex ? xAxis.getCoordByIndex(mpData.xAxis || 0) : xAxis.getCoord(mpData.xAxis || 0),
                typeof mpData.yAxis != 'string' && yAxis.getCoordByIndex ? yAxis.getCoordByIndex(mpData.yAxis || 0) : yAxis.getCoord(mpData.yAxis || 0)
            ];
        },
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.series = newOption.series;
            }
            this.backupShapeList();
            this._buildShape();
        },
        addDataAnimation: function (params, done) {
            var series = this.series;
            var aniMap = {};
            for (var i = 0, l = params.length; i < l; i++) {
                aniMap[params[i][0]] = params[i];
            }
            var x;
            var dx;
            var y;
            var serie;
            var seriesIndex;
            var dataIndex;
            var aniCount = 0;
            function animationDone() {
                aniCount--;
                if (aniCount === 0) {
                    done && done();
                }
            }
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                seriesIndex = this.shapeList[i]._seriesIndex;
                if (aniMap[seriesIndex] && !aniMap[seriesIndex][3]) {
                    if (this.shapeList[i].type === 'candle') {
                        dataIndex = ecData.get(this.shapeList[i], 'dataIndex');
                        serie = series[seriesIndex];
                        if (aniMap[seriesIndex][2] && dataIndex === serie.data.length - 1) {
                            this.zr.delShape(this.shapeList[i].id);
                            continue;
                        } else if (!aniMap[seriesIndex][2] && dataIndex === 0) {
                            this.zr.delShape(this.shapeList[i].id);
                            continue;
                        }
                        dx = this.component.xAxis.getAxis(serie.xAxisIndex || 0).getGap();
                        x = aniMap[seriesIndex][2] ? dx : -dx;
                        y = 0;
                        aniCount++;
                        this.zr.animate(this.shapeList[i].id, '').when(this.query(this.option, 'animationDurationUpdate'), {
                            position: [
                                x,
                                y
                            ]
                        }).done(animationDone).start();
                    }
                }
            }
            if (!aniCount) {
                animationDone();
            }
        }
    };
    zrUtil.inherits(K, ChartBase);
    require('../chart').define('k', K);
    return K;
});define('echarts/chart/pie', [
    'require',
    './base',
    'zrender/shape/Text',
    'zrender/shape/Ring',
    'zrender/shape/Circle',
    'zrender/shape/Sector',
    'zrender/shape/Polyline',
    '../config',
    '../util/ecData',
    'zrender/tool/util',
    'zrender/tool/math',
    'zrender/tool/color',
    '../chart'
], function (require) {
    var ChartBase = require('./base');
    var TextShape = require('zrender/shape/Text');
    var RingShape = require('zrender/shape/Ring');
    var CircleShape = require('zrender/shape/Circle');
    var SectorShape = require('zrender/shape/Sector');
    var PolylineShape = require('zrender/shape/Polyline');
    var ecConfig = require('../config');
    ecConfig.pie = {
        zlevel: 0,
        z: 2,
        clickable: true,
        legendHoverLink: true,
        center: [
            '50%',
            '50%'
        ],
        radius: [
            0,
            '75%'
        ],
        clockWise: true,
        startAngle: 90,
        minAngle: 0,
        selectedOffset: 10,
        itemStyle: {
            normal: {
                borderColor: 'rgba(0,0,0,0)',
                borderWidth: 1,
                label: {
                    show: true,
                    position: 'outer'
                },
                labelLine: {
                    show: true,
                    length: 20,
                    lineStyle: {
                        width: 1,
                        type: 'solid'
                    }
                }
            },
            emphasis: {
                borderColor: 'rgba(0,0,0,0)',
                borderWidth: 1,
                label: { show: false },
                labelLine: {
                    show: false,
                    length: 20,
                    lineStyle: {
                        width: 1,
                        type: 'solid'
                    }
                }
            }
        }
    };
    var ecData = require('../util/ecData');
    var zrUtil = require('zrender/tool/util');
    var zrMath = require('zrender/tool/math');
    var zrColor = require('zrender/tool/color');
    function Pie(ecTheme, messageCenter, zr, option, myChart) {
        ChartBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        var self = this;
        self.shapeHandler.onmouseover = function (param) {
            var shape = param.target;
            var seriesIndex = ecData.get(shape, 'seriesIndex');
            var dataIndex = ecData.get(shape, 'dataIndex');
            var percent = ecData.get(shape, 'special');
            var center = [
                shape.style.x,
                shape.style.y
            ];
            var startAngle = shape.style.startAngle;
            var endAngle = shape.style.endAngle;
            var midAngle = ((endAngle + startAngle) / 2 + 360) % 360;
            var defaultColor = shape.highlightStyle.color;
            var label = self.getLabel(seriesIndex, dataIndex, percent, center, midAngle, defaultColor, true);
            if (label) {
                self.zr.addHoverShape(label);
            }
            var labelLine = self.getLabelLine(seriesIndex, dataIndex, center, shape.style.r0, shape.style.r, midAngle, defaultColor, true);
            if (labelLine) {
                self.zr.addHoverShape(labelLine);
            }
        };
        this.refresh(option);
    }
    Pie.prototype = {
        type: ecConfig.CHART_TYPE_PIE,
        _buildShape: function () {
            var series = this.series;
            var legend = this.component.legend;
            this.selectedMap = {};
            this._selected = {};
            var center;
            var radius;
            var pieCase;
            this._selectedMode = false;
            var serieName;
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].type === ecConfig.CHART_TYPE_PIE) {
                    series[i] = this.reformOption(series[i]);
                    this.legendHoverLink = series[i].legendHoverLink || this.legendHoverLink;
                    serieName = series[i].name || '';
                    this.selectedMap[serieName] = legend ? legend.isSelected(serieName) : true;
                    if (!this.selectedMap[serieName]) {
                        continue;
                    }
                    center = this.parseCenter(this.zr, series[i].center);
                    radius = this.parseRadius(this.zr, series[i].radius);
                    this._selectedMode = this._selectedMode || series[i].selectedMode;
                    this._selected[i] = [];
                    if (this.deepQuery([
                            series[i],
                            this.option
                        ], 'calculable')) {
                        pieCase = {
                            zlevel: this.getZlevelBase(),
                            z: this.getZBase(),
                            hoverable: false,
                            style: {
                                x: center[0],
                                y: center[1],
                                r0: radius[0] <= 10 ? 0 : radius[0] - 10,
                                r: radius[1] + 10,
                                brushType: 'stroke',
                                lineWidth: 1,
                                strokeColor: series[i].calculableHolderColor || this.ecTheme.calculableHolderColor || ecConfig.calculableHolderColor
                            }
                        };
                        ecData.pack(pieCase, series[i], i, undefined, -1);
                        this.setCalculable(pieCase);
                        pieCase = radius[0] <= 10 ? new CircleShape(pieCase) : new RingShape(pieCase);
                        this.shapeList.push(pieCase);
                    }
                    this._buildSinglePie(i);
                    this.buildMark(i);
                }
            }
            this.addShapeList();
        },
        _buildSinglePie: function (seriesIndex) {
            var series = this.series;
            var serie = series[seriesIndex];
            var data = serie.data;
            var legend = this.component.legend;
            var itemName;
            var totalSelected = 0;
            var totalSelectedValue0 = 0;
            var totalValue = 0;
            var maxValue = Number.NEGATIVE_INFINITY;
            var singleShapeList = [];
            for (var i = 0, l = data.length; i < l; i++) {
                itemName = data[i].name;
                this.selectedMap[itemName] = legend ? legend.isSelected(itemName) : true;
                if (this.selectedMap[itemName] && !isNaN(data[i].value)) {
                    if (+data[i].value !== 0) {
                        totalSelected++;
                    } else {
                        totalSelectedValue0++;
                    }
                    totalValue += +data[i].value;
                    maxValue = Math.max(maxValue, +data[i].value);
                }
            }
            if (totalValue === 0) {
                return;
            }
            var percent = 100;
            var clockWise = serie.clockWise;
            var startAngle = (serie.startAngle.toFixed(2) - 0 + 360) % 360;
            var endAngle;
            var minAngle = serie.minAngle || 0.01;
            var totalAngle = 360 - minAngle * totalSelected - 0.01 * totalSelectedValue0;
            var defaultColor;
            var roseType = serie.roseType;
            var center;
            var radius;
            var r0;
            var r1;
            for (var i = 0, l = data.length; i < l; i++) {
                itemName = data[i].name;
                if (!this.selectedMap[itemName] || isNaN(data[i].value)) {
                    continue;
                }
                defaultColor = legend ? legend.getColor(itemName) : this.zr.getColor(i);
                percent = data[i].value / totalValue;
                if (roseType != 'area') {
                    endAngle = clockWise ? startAngle - percent * totalAngle - (percent !== 0 ? minAngle : 0.01) : percent * totalAngle + startAngle + (percent !== 0 ? minAngle : 0.01);
                } else {
                    endAngle = clockWise ? startAngle - 360 / l : 360 / l + startAngle;
                }
                endAngle = endAngle.toFixed(2) - 0;
                percent = (percent * 100).toFixed(2);
                center = this.parseCenter(this.zr, serie.center);
                radius = this.parseRadius(this.zr, serie.radius);
                r0 = +radius[0];
                r1 = +radius[1];
                if (roseType === 'radius') {
                    r1 = data[i].value / maxValue * (r1 - r0) * 0.8 + (r1 - r0) * 0.2 + r0;
                } else if (roseType === 'area') {
                    r1 = Math.sqrt(data[i].value / maxValue) * (r1 - r0) + r0;
                }
                if (clockWise) {
                    var temp;
                    temp = startAngle;
                    startAngle = endAngle;
                    endAngle = temp;
                }
                this._buildItem(singleShapeList, seriesIndex, i, percent, data[i].selected, center, r0, r1, startAngle, endAngle, defaultColor);
                if (!clockWise) {
                    startAngle = endAngle;
                }
            }
            this._autoLabelLayout(singleShapeList, center, r1);
            for (var i = 0, l = singleShapeList.length; i < l; i++) {
                this.shapeList.push(singleShapeList[i]);
            }
            singleShapeList = null;
        },
        _buildItem: function (singleShapeList, seriesIndex, dataIndex, percent, isSelected, center, r0, r1, startAngle, endAngle, defaultColor) {
            var series = this.series;
            var midAngle = ((endAngle + startAngle) / 2 + 360) % 360;
            var sector = this.getSector(seriesIndex, dataIndex, percent, isSelected, center, r0, r1, startAngle, endAngle, defaultColor);
            ecData.pack(sector, series[seriesIndex], seriesIndex, series[seriesIndex].data[dataIndex], dataIndex, series[seriesIndex].data[dataIndex].name, percent);
            singleShapeList.push(sector);
            var label = this.getLabel(seriesIndex, dataIndex, percent, center, midAngle, defaultColor, false);
            var labelLine = this.getLabelLine(seriesIndex, dataIndex, center, r0, r1, midAngle, defaultColor, false);
            if (labelLine) {
                ecData.pack(labelLine, series[seriesIndex], seriesIndex, series[seriesIndex].data[dataIndex], dataIndex, series[seriesIndex].data[dataIndex].name, percent);
                singleShapeList.push(labelLine);
            }
            if (label) {
                ecData.pack(label, series[seriesIndex], seriesIndex, series[seriesIndex].data[dataIndex], dataIndex, series[seriesIndex].data[dataIndex].name, percent);
                label._labelLine = labelLine;
                singleShapeList.push(label);
            }
        },
        getSector: function (seriesIndex, dataIndex, percent, isSelected, center, r0, r1, startAngle, endAngle, defaultColor) {
            var series = this.series;
            var serie = series[seriesIndex];
            var data = serie.data[dataIndex];
            var queryTarget = [
                data,
                serie
            ];
            var normal = this.deepMerge(queryTarget, 'itemStyle.normal') || {};
            var emphasis = this.deepMerge(queryTarget, 'itemStyle.emphasis') || {};
            var normalColor = this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data) || defaultColor;
            var emphasisColor = this.getItemStyleColor(emphasis.color, seriesIndex, dataIndex, data) || (typeof normalColor === 'string' ? zrColor.lift(normalColor, -0.2) : normalColor);
            var sector = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                clickable: this.deepQuery(queryTarget, 'clickable'),
                style: {
                    x: center[0],
                    y: center[1],
                    r0: r0,
                    r: r1,
                    startAngle: startAngle,
                    endAngle: endAngle,
                    brushType: 'both',
                    color: normalColor,
                    lineWidth: normal.borderWidth,
                    strokeColor: normal.borderColor,
                    lineJoin: 'round'
                },
                highlightStyle: {
                    color: emphasisColor,
                    lineWidth: emphasis.borderWidth,
                    strokeColor: emphasis.borderColor,
                    lineJoin: 'round'
                },
                _seriesIndex: seriesIndex,
                _dataIndex: dataIndex
            };
            if (isSelected) {
                var midAngle = ((sector.style.startAngle + sector.style.endAngle) / 2).toFixed(2) - 0;
                sector.style._hasSelected = true;
                sector.style._x = sector.style.x;
                sector.style._y = sector.style.y;
                var offset = this.query(serie, 'selectedOffset');
                sector.style.x += zrMath.cos(midAngle, true) * offset;
                sector.style.y -= zrMath.sin(midAngle, true) * offset;
                this._selected[seriesIndex][dataIndex] = true;
            } else {
                this._selected[seriesIndex][dataIndex] = false;
            }
            if (this._selectedMode) {
                sector.onclick = this.shapeHandler.onclick;
            }
            if (this.deepQuery([
                    data,
                    serie,
                    this.option
                ], 'calculable')) {
                this.setCalculable(sector);
                sector.draggable = true;
            }
            if (this._needLabel(serie, data, true) || this._needLabelLine(serie, data, true)) {
                sector.onmouseover = this.shapeHandler.onmouseover;
            }
            sector = new SectorShape(sector);
            return sector;
        },
        getLabel: function (seriesIndex, dataIndex, percent, center, midAngle, defaultColor, isEmphasis) {
            var series = this.series;
            var serie = series[seriesIndex];
            var data = serie.data[dataIndex];
            if (!this._needLabel(serie, data, isEmphasis)) {
                return;
            }
            var status = isEmphasis ? 'emphasis' : 'normal';
            var itemStyle = zrUtil.merge(zrUtil.clone(data.itemStyle) || {}, serie.itemStyle);
            var labelControl = itemStyle[status].label;
            var textStyle = labelControl.textStyle || {};
            var centerX = center[0];
            var centerY = center[1];
            var x;
            var y;
            var radius = this.parseRadius(this.zr, serie.radius);
            var textAlign;
            var textBaseline = 'middle';
            labelControl.position = labelControl.position || itemStyle.normal.label.position;
            if (labelControl.position === 'center') {
                x = centerX;
                y = centerY;
                textAlign = 'center';
            } else if (labelControl.position === 'inner' || labelControl.position === 'inside') {
                radius = (radius[0] + radius[1]) * (labelControl.distance || 0.5);
                x = Math.round(centerX + radius * zrMath.cos(midAngle, true));
                y = Math.round(centerY - radius * zrMath.sin(midAngle, true));
                defaultColor = '#fff';
                textAlign = 'center';
            } else {
                radius = radius[1] - -itemStyle[status].labelLine.length;
                x = Math.round(centerX + radius * zrMath.cos(midAngle, true));
                y = Math.round(centerY - radius * zrMath.sin(midAngle, true));
                textAlign = midAngle >= 90 && midAngle <= 270 ? 'right' : 'left';
            }
            if (labelControl.position != 'center' && labelControl.position != 'inner' && labelControl.position != 'inside') {
                x += textAlign === 'left' ? 20 : -20;
            }
            data.__labelX = x - (textAlign === 'left' ? 5 : -5);
            data.__labelY = y;
            var ts = new TextShape({
                zlevel: this.getZlevelBase(),
                z: this.getZBase() + 1,
                hoverable: false,
                style: {
                    x: x,
                    y: y,
                    color: textStyle.color || defaultColor,
                    text: this.getLabelText(seriesIndex, dataIndex, percent, status),
                    textAlign: textStyle.align || textAlign,
                    textBaseline: textStyle.baseline || textBaseline,
                    textFont: this.getFont(textStyle)
                },
                highlightStyle: { brushType: 'fill' }
            });
            ts._radius = radius;
            ts._labelPosition = labelControl.position || 'outer';
            ts._rect = ts.getRect(ts.style);
            ts._seriesIndex = seriesIndex;
            ts._dataIndex = dataIndex;
            return ts;
        },
        getLabelText: function (seriesIndex, dataIndex, percent, status) {
            var series = this.series;
            var serie = series[seriesIndex];
            var data = serie.data[dataIndex];
            var formatter = this.deepQuery([
                data,
                serie
            ], 'itemStyle.' + status + '.label.formatter');
            if (formatter) {
                if (typeof formatter === 'function') {
                    return formatter.call(this.myChart, {
                        seriesIndex: seriesIndex,
                        seriesName: serie.name || '',
                        series: serie,
                        dataIndex: dataIndex,
                        data: data,
                        name: data.name,
                        value: data.value,
                        percent: percent
                    });
                } else if (typeof formatter === 'string') {
                    formatter = formatter.replace('{a}', '{a0}').replace('{b}', '{b0}').replace('{c}', '{c0}').replace('{d}', '{d0}');
                    formatter = formatter.replace('{a0}', serie.name).replace('{b0}', data.name).replace('{c0}', data.value).replace('{d0}', percent);
                    return formatter;
                }
            } else {
                return data.name;
            }
        },
        getLabelLine: function (seriesIndex, dataIndex, center, r0, r1, midAngle, defaultColor, isEmphasis) {
            var series = this.series;
            var serie = series[seriesIndex];
            var data = serie.data[dataIndex];
            if (this._needLabelLine(serie, data, isEmphasis)) {
                var status = isEmphasis ? 'emphasis' : 'normal';
                var itemStyle = zrUtil.merge(zrUtil.clone(data.itemStyle) || {}, serie.itemStyle);
                var labelLineControl = itemStyle[status].labelLine;
                var lineStyle = labelLineControl.lineStyle || {};
                var centerX = center[0];
                var centerY = center[1];
                var minRadius = r1;
                var maxRadius = this.parseRadius(this.zr, serie.radius)[1] - -labelLineControl.length;
                var cosValue = zrMath.cos(midAngle, true);
                var sinValue = zrMath.sin(midAngle, true);
                return new PolylineShape({
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase() + 1,
                    hoverable: false,
                    style: {
                        pointList: [
                            [
                                centerX + minRadius * cosValue,
                                centerY - minRadius * sinValue
                            ],
                            [
                                centerX + maxRadius * cosValue,
                                centerY - maxRadius * sinValue
                            ],
                            [
                                data.__labelX,
                                data.__labelY
                            ]
                        ],
                        strokeColor: lineStyle.color || defaultColor,
                        lineType: lineStyle.type,
                        lineWidth: lineStyle.width
                    },
                    _seriesIndex: seriesIndex,
                    _dataIndex: dataIndex
                });
            } else {
                return;
            }
        },
        _needLabel: function (serie, data, isEmphasis) {
            return this.deepQuery([
                data,
                serie
            ], 'itemStyle.' + (isEmphasis ? 'emphasis' : 'normal') + '.label.show');
        },
        _needLabelLine: function (serie, data, isEmphasis) {
            return this.deepQuery([
                data,
                serie
            ], 'itemStyle.' + (isEmphasis ? 'emphasis' : 'normal') + '.labelLine.show');
        },
        _autoLabelLayout: function (sList, center, r) {
            var leftList = [];
            var rightList = [];
            for (var i = 0, l = sList.length; i < l; i++) {
                if (sList[i]._labelPosition === 'outer' || sList[i]._labelPosition === 'outside') {
                    sList[i]._rect._y = sList[i]._rect.y;
                    if (sList[i]._rect.x < center[0]) {
                        leftList.push(sList[i]);
                    } else {
                        rightList.push(sList[i]);
                    }
                }
            }
            this._layoutCalculate(leftList, center, r, -1);
            this._layoutCalculate(rightList, center, r, 1);
        },
        _layoutCalculate: function (tList, center, r, direction) {
            tList.sort(function (a, b) {
                return a._rect.y - b._rect.y;
            });
            function _changeDown(start, end, delta, direction) {
                for (var j = start; j < end; j++) {
                    tList[j]._rect.y += delta;
                    tList[j].style.y += delta;
                    if (tList[j]._labelLine) {
                        tList[j]._labelLine.style.pointList[1][1] += delta;
                        tList[j]._labelLine.style.pointList[2][1] += delta;
                    }
                    if (j > start && j + 1 < end && tList[j + 1]._rect.y > tList[j]._rect.y + tList[j]._rect.height) {
                        _changeUp(j, delta / 2);
                        return;
                    }
                }
                _changeUp(end - 1, delta / 2);
            }
            function _changeUp(end, delta) {
                for (var j = end; j >= 0; j--) {
                    tList[j]._rect.y -= delta;
                    tList[j].style.y -= delta;
                    if (tList[j]._labelLine) {
                        tList[j]._labelLine.style.pointList[1][1] -= delta;
                        tList[j]._labelLine.style.pointList[2][1] -= delta;
                    }
                    if (j > 0 && tList[j]._rect.y > tList[j - 1]._rect.y + tList[j - 1]._rect.height) {
                        break;
                    }
                }
            }
            function _changeX(sList, isDownList, center, r, direction) {
                var x = center[0];
                var y = center[1];
                var deltaX;
                var deltaY;
                var length;
                var lastDeltaX = direction > 0 ? isDownList ? Number.MAX_VALUE : 0 : isDownList ? Number.MAX_VALUE : 0;
                for (var i = 0, l = sList.length; i < l; i++) {
                    deltaY = Math.abs(sList[i]._rect.y - y);
                    length = sList[i]._radius - r;
                    deltaX = deltaY < r + length ? Math.sqrt((r + length + 20) * (r + length + 20) - Math.pow(sList[i]._rect.y - y, 2)) : Math.abs(sList[i]._rect.x + (direction > 0 ? 0 : sList[i]._rect.width) - x);
                    if (isDownList && deltaX >= lastDeltaX) {
                        deltaX = lastDeltaX - 10;
                    }
                    if (!isDownList && deltaX <= lastDeltaX) {
                        deltaX = lastDeltaX + 10;
                    }
                    sList[i]._rect.x = sList[i].style.x = x + deltaX * direction;
                    if (sList[i]._labelLine) {
                        sList[i]._labelLine.style.pointList[2][0] = x + (deltaX - 5) * direction;
                        sList[i]._labelLine.style.pointList[1][0] = x + (deltaX - 20) * direction;
                    }
                    lastDeltaX = deltaX;
                }
            }
            var lastY = 0;
            var delta;
            var len = tList.length;
            var upList = [];
            var downList = [];
            for (var i = 0; i < len; i++) {
                delta = tList[i]._rect.y - lastY;
                if (delta < 0) {
                    _changeDown(i, len, -delta, direction);
                }
                lastY = tList[i]._rect.y + tList[i]._rect.height;
            }
            if (this.zr.getHeight() - lastY < 0) {
                _changeUp(len - 1, lastY - this.zr.getHeight());
            }
            for (var i = 0; i < len; i++) {
                if (tList[i]._rect.y >= center[1]) {
                    downList.push(tList[i]);
                } else {
                    upList.push(tList[i]);
                }
            }
            _changeX(downList, true, center, r, direction);
            _changeX(upList, false, center, r, direction);
        },
        reformOption: function (opt) {
            var _merge = zrUtil.merge;
            opt = _merge(_merge(opt || {}, zrUtil.clone(this.ecTheme.pie || {})), zrUtil.clone(ecConfig.pie));
            opt.itemStyle.normal.label.textStyle = this.getTextStyle(opt.itemStyle.normal.label.textStyle);
            opt.itemStyle.emphasis.label.textStyle = this.getTextStyle(opt.itemStyle.emphasis.label.textStyle);
            this.z = opt.z;
            this.zlevel = opt.zlevel;
            return opt;
        },
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.series = newOption.series;
            }
            this.backupShapeList();
            this._buildShape();
        },
        addDataAnimation: function (params, done) {
            var series = this.series;
            var aniMap = {};
            for (var i = 0, l = params.length; i < l; i++) {
                aniMap[params[i][0]] = params[i];
            }
            var aniCount = 0;
            function animationDone() {
                aniCount--;
                if (aniCount === 0) {
                    done && done();
                }
            }
            var sectorMap = {};
            var textMap = {};
            var lineMap = {};
            var backupShapeList = this.shapeList;
            this.shapeList = [];
            var seriesIndex;
            var isHead;
            var dataGrow;
            var deltaIdxMap = {};
            for (var i = 0, l = params.length; i < l; i++) {
                seriesIndex = params[i][0];
                isHead = params[i][2];
                dataGrow = params[i][3];
                if (series[seriesIndex] && series[seriesIndex].type === ecConfig.CHART_TYPE_PIE) {
                    if (isHead) {
                        if (!dataGrow) {
                            sectorMap[seriesIndex + '_' + series[seriesIndex].data.length] = 'delete';
                        }
                        deltaIdxMap[seriesIndex] = 1;
                    } else {
                        if (!dataGrow) {
                            sectorMap[seriesIndex + '_-1'] = 'delete';
                            deltaIdxMap[seriesIndex] = -1;
                        } else {
                            deltaIdxMap[seriesIndex] = 0;
                        }
                    }
                    this._buildSinglePie(seriesIndex);
                }
            }
            var dataIndex;
            var key;
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                seriesIndex = this.shapeList[i]._seriesIndex;
                dataIndex = this.shapeList[i]._dataIndex;
                key = seriesIndex + '_' + dataIndex;
                switch (this.shapeList[i].type) {
                case 'sector':
                    sectorMap[key] = this.shapeList[i];
                    break;
                case 'text':
                    textMap[key] = this.shapeList[i];
                    break;
                case 'polyline':
                    lineMap[key] = this.shapeList[i];
                    break;
                }
            }
            this.shapeList = [];
            var targeSector;
            for (var i = 0, l = backupShapeList.length; i < l; i++) {
                seriesIndex = backupShapeList[i]._seriesIndex;
                if (aniMap[seriesIndex]) {
                    dataIndex = backupShapeList[i]._dataIndex + deltaIdxMap[seriesIndex];
                    key = seriesIndex + '_' + dataIndex;
                    targeSector = sectorMap[key];
                    if (!targeSector) {
                        continue;
                    }
                    if (backupShapeList[i].type === 'sector') {
                        if (targeSector != 'delete') {
                            aniCount++;
                            this.zr.animate(backupShapeList[i].id, 'style').when(400, {
                                startAngle: targeSector.style.startAngle,
                                endAngle: targeSector.style.endAngle
                            }).done(animationDone).start();
                        } else {
                            aniCount++;
                            this.zr.animate(backupShapeList[i].id, 'style').when(400, deltaIdxMap[seriesIndex] < 0 ? { startAngle: backupShapeList[i].style.startAngle } : { endAngle: backupShapeList[i].style.endAngle }).done(animationDone).start();
                        }
                    } else if (backupShapeList[i].type === 'text' || backupShapeList[i].type === 'polyline') {
                        if (targeSector === 'delete') {
                            this.zr.delShape(backupShapeList[i].id);
                        } else {
                            switch (backupShapeList[i].type) {
                            case 'text':
                                aniCount++;
                                targeSector = textMap[key];
                                this.zr.animate(backupShapeList[i].id, 'style').when(400, {
                                    x: targeSector.style.x,
                                    y: targeSector.style.y
                                }).done(animationDone).start();
                                break;
                            case 'polyline':
                                aniCount++;
                                targeSector = lineMap[key];
                                this.zr.animate(backupShapeList[i].id, 'style').when(400, { pointList: targeSector.style.pointList }).done(animationDone).start();
                                break;
                            }
                        }
                    }
                }
            }
            this.shapeList = backupShapeList;
            if (!aniCount) {
                animationDone();
            }
        },
        onclick: function (param) {
            var series = this.series;
            if (!this.isClick || !param.target) {
                return;
            }
            this.isClick = false;
            var offset;
            var target = param.target;
            var style = target.style;
            var seriesIndex = ecData.get(target, 'seriesIndex');
            var dataIndex = ecData.get(target, 'dataIndex');
            for (var i = 0, len = this.shapeList.length; i < len; i++) {
                if (this.shapeList[i].id === target.id) {
                    seriesIndex = ecData.get(target, 'seriesIndex');
                    dataIndex = ecData.get(target, 'dataIndex');
                    if (!style._hasSelected) {
                        var midAngle = ((style.startAngle + style.endAngle) / 2).toFixed(2) - 0;
                        target.style._hasSelected = true;
                        this._selected[seriesIndex][dataIndex] = true;
                        target.style._x = target.style.x;
                        target.style._y = target.style.y;
                        offset = this.query(series[seriesIndex], 'selectedOffset');
                        target.style.x += zrMath.cos(midAngle, true) * offset;
                        target.style.y -= zrMath.sin(midAngle, true) * offset;
                    } else {
                        target.style.x = target.style._x;
                        target.style.y = target.style._y;
                        target.style._hasSelected = false;
                        this._selected[seriesIndex][dataIndex] = false;
                    }
                    this.zr.modShape(target.id, target);
                } else if (this.shapeList[i].style._hasSelected && this._selectedMode === 'single') {
                    seriesIndex = ecData.get(this.shapeList[i], 'seriesIndex');
                    dataIndex = ecData.get(this.shapeList[i], 'dataIndex');
                    this.shapeList[i].style.x = this.shapeList[i].style._x;
                    this.shapeList[i].style.y = this.shapeList[i].style._y;
                    this.shapeList[i].style._hasSelected = false;
                    this._selected[seriesIndex][dataIndex] = false;
                    this.zr.modShape(this.shapeList[i].id, this.shapeList[i]);
                }
            }
            this.messageCenter.dispatch(ecConfig.EVENT.PIE_SELECTED, param.event, {
                selected: this._selected,
                target: ecData.get(target, 'name')
            }, this.myChart);
            this.zr.refreshNextFrame();
        }
    };
    zrUtil.inherits(Pie, ChartBase);
    require('../chart').define('pie', Pie);
    return Pie;
});define('echarts/chart/radar', [
    'require',
    './base',
    'zrender/shape/Polygon',
    '../component/polar',
    '../config',
    '../util/ecData',
    'zrender/tool/util',
    'zrender/tool/color',
    '../util/accMath',
    '../chart'
], function (require) {
    var ChartBase = require('./base');
    var PolygonShape = require('zrender/shape/Polygon');
    require('../component/polar');
    var ecConfig = require('../config');
    ecConfig.radar = {
        zlevel: 0,
        z: 2,
        clickable: true,
        legendHoverLink: true,
        polarIndex: 0,
        itemStyle: {
            normal: {
                label: { show: false },
                lineStyle: {
                    width: 2,
                    type: 'solid'
                }
            },
            emphasis: { label: { show: false } }
        },
        symbolSize: 2
    };
    var ecData = require('../util/ecData');
    var zrUtil = require('zrender/tool/util');
    var zrColor = require('zrender/tool/color');
    function Radar(ecTheme, messageCenter, zr, option, myChart) {
        ChartBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.refresh(option);
    }
    Radar.prototype = {
        type: ecConfig.CHART_TYPE_RADAR,
        _buildShape: function () {
            this.selectedMap = {};
            this._symbol = this.option.symbolList;
            this._queryTarget;
            this._dropBoxList = [];
            this._radarDataCounter = 0;
            var series = this.series;
            var legend = this.component.legend;
            var serieName;
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].type === ecConfig.CHART_TYPE_RADAR) {
                    this.serie = this.reformOption(series[i]);
                    this.legendHoverLink = series[i].legendHoverLink || this.legendHoverLink;
                    serieName = this.serie.name || '';
                    this.selectedMap[serieName] = legend ? legend.isSelected(serieName) : true;
                    if (this.selectedMap[serieName]) {
                        this._queryTarget = [
                            this.serie,
                            this.option
                        ];
                        if (this.deepQuery(this._queryTarget, 'calculable')) {
                            this._addDropBox(i);
                        }
                        this._buildSingleRadar(i);
                        this.buildMark(i);
                    }
                }
            }
            this.addShapeList();
        },
        _buildSingleRadar: function (index) {
            var legend = this.component.legend;
            var iconShape;
            var data = this.serie.data;
            var defaultColor;
            var name;
            var pointList;
            var calculable = this.deepQuery(this._queryTarget, 'calculable');
            for (var i = 0; i < data.length; i++) {
                name = data[i].name || '';
                this.selectedMap[name] = legend ? legend.isSelected(name) : true;
                if (!this.selectedMap[name]) {
                    continue;
                }
                if (legend) {
                    defaultColor = legend.getColor(name);
                    iconShape = legend.getItemShape(name);
                    if (iconShape) {
                        iconShape.style.brushType = this.deepQuery([
                            data[i],
                            this.serie
                        ], 'itemStyle.normal.areaStyle') ? 'both' : 'stroke';
                        legend.setItemShape(name, iconShape);
                    }
                } else {
                    defaultColor = this.zr.getColor(i);
                }
                pointList = this._getPointList(this.serie.polarIndex, data[i]);
                this._addSymbol(pointList, defaultColor, i, index, this.serie.polarIndex);
                this._addDataShape(pointList, defaultColor, data[i], index, i, calculable);
                this._radarDataCounter++;
            }
        },
        _getPointList: function (polarIndex, dataArr) {
            var pointList = [];
            var vector;
            var polar = this.component.polar;
            var value;
            for (var i = 0, l = dataArr.value.length; i < l; i++) {
                value = this.getDataFromOption(dataArr.value[i]);
                vector = value != '-' ? polar.getVector(polarIndex, i, value) : false;
                if (vector) {
                    pointList.push(vector);
                }
            }
            return pointList;
        },
        _addSymbol: function (pointList, defaultColor, dataIndex, seriesIndex, polarIndex) {
            var series = this.series;
            var itemShape;
            var polar = this.component.polar;
            for (var i = 0, l = pointList.length; i < l; i++) {
                itemShape = this.getSymbolShape(this.deepMerge([
                    series[seriesIndex].data[dataIndex],
                    series[seriesIndex]
                ]), seriesIndex, series[seriesIndex].data[dataIndex].value[i], i, polar.getIndicatorText(polarIndex, i), pointList[i][0], pointList[i][1], this._symbol[this._radarDataCounter % this._symbol.length], defaultColor, '#fff', 'vertical');
                itemShape.zlevel = this.getZlevelBase();
                itemShape.z = this.getZBase() + 1;
                ecData.set(itemShape, 'data', series[seriesIndex].data[dataIndex]);
                ecData.set(itemShape, 'value', series[seriesIndex].data[dataIndex].value);
                ecData.set(itemShape, 'dataIndex', dataIndex);
                ecData.set(itemShape, 'special', i);
                this.shapeList.push(itemShape);
            }
        },
        _addDataShape: function (pointList, defaultColor, data, seriesIndex, dataIndex, calculable) {
            var series = this.series;
            var queryTarget = [
                data,
                this.serie
            ];
            var nColor = this.getItemStyleColor(this.deepQuery(queryTarget, 'itemStyle.normal.color'), seriesIndex, dataIndex, data);
            var nLineWidth = this.deepQuery(queryTarget, 'itemStyle.normal.lineStyle.width');
            var nLineType = this.deepQuery(queryTarget, 'itemStyle.normal.lineStyle.type');
            var nAreaColor = this.deepQuery(queryTarget, 'itemStyle.normal.areaStyle.color');
            var nIsAreaFill = this.deepQuery(queryTarget, 'itemStyle.normal.areaStyle');
            var shape = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                style: {
                    pointList: pointList,
                    brushType: nIsAreaFill ? 'both' : 'stroke',
                    color: nAreaColor || nColor || (typeof defaultColor === 'string' ? zrColor.alpha(defaultColor, 0.5) : defaultColor),
                    strokeColor: nColor || defaultColor,
                    lineWidth: nLineWidth,
                    lineType: nLineType
                },
                highlightStyle: {
                    brushType: this.deepQuery(queryTarget, 'itemStyle.emphasis.areaStyle') || nIsAreaFill ? 'both' : 'stroke',
                    color: this.deepQuery(queryTarget, 'itemStyle.emphasis.areaStyle.color') || nAreaColor || nColor || (typeof defaultColor === 'string' ? zrColor.alpha(defaultColor, 0.5) : defaultColor),
                    strokeColor: this.getItemStyleColor(this.deepQuery(queryTarget, 'itemStyle.emphasis.color'), seriesIndex, dataIndex, data) || nColor || defaultColor,
                    lineWidth: this.deepQuery(queryTarget, 'itemStyle.emphasis.lineStyle.width') || nLineWidth,
                    lineType: this.deepQuery(queryTarget, 'itemStyle.emphasis.lineStyle.type') || nLineType
                }
            };
            ecData.pack(shape, series[seriesIndex], seriesIndex, data, dataIndex, data.name, this.component.polar.getIndicator(series[seriesIndex].polarIndex));
            if (calculable) {
                shape.draggable = true;
                this.setCalculable(shape);
            }
            shape = new PolygonShape(shape);
            this.shapeList.push(shape);
        },
        _addDropBox: function (index) {
            var series = this.series;
            var polarIndex = this.deepQuery(this._queryTarget, 'polarIndex');
            if (!this._dropBoxList[polarIndex]) {
                var shape = this.component.polar.getDropBox(polarIndex);
                shape.zlevel = this.getZlevelBase();
                shape.z = this.getZBase();
                this.setCalculable(shape);
                ecData.pack(shape, series, index, undefined, -1);
                this.shapeList.push(shape);
                this._dropBoxList[polarIndex] = true;
            }
        },
        ondragend: function (param, status) {
            var series = this.series;
            if (!this.isDragend || !param.target) {
                return;
            }
            var target = param.target;
            var seriesIndex = ecData.get(target, 'seriesIndex');
            var dataIndex = ecData.get(target, 'dataIndex');
            this.component.legend && this.component.legend.del(series[seriesIndex].data[dataIndex].name);
            series[seriesIndex].data.splice(dataIndex, 1);
            status.dragOut = true;
            status.needRefresh = true;
            this.isDragend = false;
            return;
        },
        ondrop: function (param, status) {
            var series = this.series;
            if (!this.isDrop || !param.target) {
                return;
            }
            var target = param.target;
            var dragged = param.dragged;
            var seriesIndex = ecData.get(target, 'seriesIndex');
            var dataIndex = ecData.get(target, 'dataIndex');
            var data;
            var legend = this.component.legend;
            var value;
            if (dataIndex === -1) {
                data = {
                    value: ecData.get(dragged, 'value'),
                    name: ecData.get(dragged, 'name')
                };
                series[seriesIndex].data.push(data);
                legend && legend.add(data.name, dragged.style.color || dragged.style.strokeColor);
            } else {
                var accMath = require('../util/accMath');
                data = series[seriesIndex].data[dataIndex];
                legend && legend.del(data.name);
                data.name += this.option.nameConnector + ecData.get(dragged, 'name');
                value = ecData.get(dragged, 'value');
                for (var i = 0; i < value.length; i++) {
                    data.value[i] = accMath.accAdd(data.value[i], value[i]);
                }
                legend && legend.add(data.name, dragged.style.color || dragged.style.strokeColor);
            }
            status.dragIn = status.dragIn || true;
            this.isDrop = false;
            return;
        },
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.series = newOption.series;
            }
            this.backupShapeList();
            this._buildShape();
        }
    };
    zrUtil.inherits(Radar, ChartBase);
    require('../chart').define('radar', Radar);
    return Radar;
});define('echarts/component/polar', [
    'require',
    './base',
    'zrender/shape/Text',
    'zrender/shape/Line',
    'zrender/shape/Polygon',
    'zrender/shape/Circle',
    'zrender/shape/Ring',
    '../config',
    'zrender/tool/util',
    '../util/coordinates',
    '../util/accMath',
    '../util/smartSteps',
    '../component'
], function (require) {
    var Base = require('./base');
    var TextShape = require('zrender/shape/Text');
    var LineShape = require('zrender/shape/Line');
    var PolygonShape = require('zrender/shape/Polygon');
    var Circle = require('zrender/shape/Circle');
    var Ring = require('zrender/shape/Ring');
    var ecConfig = require('../config');
    ecConfig.polar = {
        zlevel: 0,
        z: 0,
        center: [
            '50%',
            '50%'
        ],
        radius: '75%',
        startAngle: 90,
        boundaryGap: [
            0,
            0
        ],
        splitNumber: 5,
        name: {
            show: true,
            textStyle: { color: '#333' }
        },
        axisLine: {
            show: true,
            lineStyle: {
                color: '#ccc',
                width: 1,
                type: 'solid'
            }
        },
        axisLabel: {
            show: false,
            textStyle: { color: '#333' }
        },
        splitArea: {
            show: true,
            areaStyle: {
                color: [
                    'rgba(250,250,250,0.3)',
                    'rgba(200,200,200,0.3)'
                ]
            }
        },
        splitLine: {
            show: true,
            lineStyle: {
                width: 1,
                color: '#ccc'
            }
        },
        type: 'polygon'
    };
    var zrUtil = require('zrender/tool/util');
    var ecCoordinates = require('../util/coordinates');
    function Polar(ecTheme, messageCenter, zr, option, myChart) {
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.refresh(option);
    }
    Polar.prototype = {
        type: ecConfig.COMPONENT_TYPE_POLAR,
        _buildShape: function () {
            for (var i = 0; i < this.polar.length; i++) {
                this._index = i;
                this.reformOption(this.polar[i]);
                this._queryTarget = [
                    this.polar[i],
                    this.option
                ];
                this._createVector(i);
                this._buildSpiderWeb(i);
                this._buildText(i);
                this._adjustIndicatorValue(i);
                this._addAxisLabel(i);
            }
            for (var i = 0; i < this.shapeList.length; i++) {
                this.zr.addShape(this.shapeList[i]);
            }
        },
        _createVector: function (index) {
            var item = this.polar[index];
            var indicator = this.deepQuery(this._queryTarget, 'indicator');
            var length = indicator.length;
            var startAngle = item.startAngle;
            var dStep = 2 * Math.PI / length;
            var radius = this._getRadius();
            var __ecIndicator = item.__ecIndicator = [];
            var vector;
            for (var i = 0; i < length; i++) {
                vector = ecCoordinates.polar2cartesian(radius, startAngle * Math.PI / 180 + dStep * i);
                __ecIndicator.push({
                    vector: [
                        vector[1],
                        -vector[0]
                    ]
                });
            }
        },
        _getRadius: function () {
            var item = this.polar[this._index];
            return this.parsePercent(item.radius, Math.min(this.zr.getWidth(), this.zr.getHeight()) / 2);
        },
        _buildSpiderWeb: function (index) {
            var item = this.polar[index];
            var __ecIndicator = item.__ecIndicator;
            var splitArea = item.splitArea;
            var splitLine = item.splitLine;
            var center = this.getCenter(index);
            var splitNumber = item.splitNumber;
            var strokeColor = splitLine.lineStyle.color;
            var lineWidth = splitLine.lineStyle.width;
            var show = splitLine.show;
            var axisLine = this.deepQuery(this._queryTarget, 'axisLine');
            this._addArea(__ecIndicator, splitNumber, center, splitArea, strokeColor, lineWidth, show);
            axisLine.show && this._addLine(__ecIndicator, center, axisLine);
        },
        _addAxisLabel: function (index) {
            var accMath = require('../util/accMath');
            var item = this.polar[index];
            var indicator = this.deepQuery(this._queryTarget, 'indicator');
            var __ecIndicator = item.__ecIndicator;
            var axisLabel;
            var vector;
            var style;
            var newStyle;
            var splitNumber = this.deepQuery(this._queryTarget, 'splitNumber');
            var center = this.getCenter(index);
            var vector;
            var value;
            var text;
            var theta;
            var offset;
            var interval;
            for (var i = 0; i < indicator.length; i++) {
                axisLabel = this.deepQuery([
                    indicator[i],
                    item,
                    this.option
                ], 'axisLabel');
                if (axisLabel.show) {
                    var textStyle = this.deepQuery([
                        axisLabel,
                        item,
                        this.option
                    ], 'textStyle');
                    var formatter = this.deepQuery([
                        axisLabel,
                        item
                    ], 'formatter');
                    style = {};
                    style.textFont = this.getFont(textStyle);
                    style.color = textStyle.color;
                    style = zrUtil.merge(style, axisLabel);
                    style.lineWidth = style.width;
                    vector = __ecIndicator[i].vector;
                    value = __ecIndicator[i].value;
                    theta = i / indicator.length * 2 * Math.PI;
                    offset = axisLabel.offset || 10;
                    interval = axisLabel.interval || 0;
                    if (!value) {
                        return;
                    }
                    for (var j = 1; j <= splitNumber; j += interval + 1) {
                        newStyle = zrUtil.merge({}, style);
                        text = accMath.accAdd(value.min, accMath.accMul(value.step, j));
                        if (typeof formatter === 'function') {
                            text = formatter(text);
                        } else if (typeof formatter === 'string') {
                            text = formatter.replace('{a}', '{a0}').replace('{a0}', text);
                        } else {
                            text = this.numAddCommas(text);
                        }
                        newStyle.text = text;
                        newStyle.x = j * vector[0] / splitNumber + Math.cos(theta) * offset + center[0];
                        newStyle.y = j * vector[1] / splitNumber + Math.sin(theta) * offset + center[1];
                        this.shapeList.push(new TextShape({
                            zlevel: this.getZlevelBase(),
                            z: this.getZBase(),
                            style: newStyle,
                            draggable: false,
                            hoverable: false
                        }));
                    }
                }
            }
        },
        _buildText: function (index) {
            var item = this.polar[index];
            var __ecIndicator = item.__ecIndicator;
            var vector;
            var indicator = this.deepQuery(this._queryTarget, 'indicator');
            var center = this.getCenter(index);
            var style;
            var textAlign;
            var name;
            var rotation;
            var x = 0;
            var y = 0;
            var margin;
            var textStyle;
            for (var i = 0; i < indicator.length; i++) {
                name = this.deepQuery([
                    indicator[i],
                    item,
                    this.option
                ], 'name');
                if (!name.show) {
                    continue;
                }
                textStyle = this.deepQuery([
                    name,
                    item,
                    this.option
                ], 'textStyle');
                style = {};
                style.textFont = this.getFont(textStyle);
                style.color = textStyle.color;
                if (typeof name.formatter == 'function') {
                    style.text = name.formatter.call(this.myChart, indicator[i].text, i);
                } else if (typeof name.formatter == 'string') {
                    style.text = name.formatter.replace('{value}', indicator[i].text);
                } else {
                    style.text = indicator[i].text;
                }
                __ecIndicator[i].text = style.text;
                vector = __ecIndicator[i].vector;
                if (Math.round(vector[0]) > 0) {
                    textAlign = 'left';
                } else if (Math.round(vector[0]) < 0) {
                    textAlign = 'right';
                } else {
                    textAlign = 'center';
                }
                if (name.margin == null) {
                    vector = this._mapVector(vector, center, 1.1);
                } else {
                    margin = name.margin;
                    x = vector[0] > 0 ? margin : -margin;
                    y = vector[1] > 0 ? margin : -margin;
                    x = vector[0] === 0 ? 0 : x;
                    y = vector[1] === 0 ? 0 : y;
                    vector = this._mapVector(vector, center, 1);
                }
                style.textAlign = textAlign;
                style.x = vector[0] + x;
                style.y = vector[1] + y;
                if (name.rotate) {
                    rotation = [
                        name.rotate / 180 * Math.PI,
                        vector[0],
                        vector[1]
                    ];
                } else {
                    rotation = [
                        0,
                        0,
                        0
                    ];
                }
                this.shapeList.push(new TextShape({
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    style: style,
                    draggable: false,
                    hoverable: false,
                    rotation: rotation
                }));
            }
        },
        getIndicatorText: function (polarIndex, indicatorIndex) {
            return this.polar[polarIndex] && this.polar[polarIndex].__ecIndicator[indicatorIndex] && this.polar[polarIndex].__ecIndicator[indicatorIndex].text;
        },
        getDropBox: function (index) {
            var index = index || 0;
            var item = this.polar[index];
            var center = this.getCenter(index);
            var __ecIndicator = item.__ecIndicator;
            var len = __ecIndicator.length;
            var pointList = [];
            var vector;
            var shape;
            var type = item.type;
            if (type == 'polygon') {
                for (var i = 0; i < len; i++) {
                    vector = __ecIndicator[i].vector;
                    pointList.push(this._mapVector(vector, center, 1.2));
                }
                shape = this._getShape(pointList, 'fill', 'rgba(0,0,0,0)', '', 1);
            } else if (type == 'circle') {
                shape = this._getCircle('', 1, 1.2, center, 'fill', 'rgba(0,0,0,0)');
            }
            return shape;
        },
        _addArea: function (__ecIndicator, splitNumber, center, splitArea, strokeColor, lineWidth, show) {
            var shape;
            var scale;
            var scale1;
            var pointList;
            var type = this.deepQuery(this._queryTarget, 'type');
            for (var i = 0; i < splitNumber; i++) {
                scale = (splitNumber - i) / splitNumber;
                if (show) {
                    if (type == 'polygon') {
                        pointList = this._getPointList(__ecIndicator, scale, center);
                        shape = this._getShape(pointList, 'stroke', '', strokeColor, lineWidth);
                    } else if (type == 'circle') {
                        shape = this._getCircle(strokeColor, lineWidth, scale, center, 'stroke');
                    }
                    this.shapeList.push(shape);
                }
                if (splitArea.show) {
                    scale1 = (splitNumber - i - 1) / splitNumber;
                    this._addSplitArea(__ecIndicator, splitArea, scale, scale1, center, i);
                }
            }
        },
        _getCircle: function (strokeColor, lineWidth, scale, center, brushType, color) {
            var radius = this._getRadius();
            return new Circle({
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                style: {
                    x: center[0],
                    y: center[1],
                    r: radius * scale,
                    brushType: brushType,
                    strokeColor: strokeColor,
                    lineWidth: lineWidth,
                    color: color
                },
                hoverable: false,
                draggable: false
            });
        },
        _getRing: function (color, scale0, scale1, center) {
            var radius = this._getRadius();
            return new Ring({
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                style: {
                    x: center[0],
                    y: center[1],
                    r: scale0 * radius,
                    r0: scale1 * radius,
                    color: color,
                    brushType: 'fill'
                },
                hoverable: false,
                draggable: false
            });
        },
        _getPointList: function (__ecIndicator, scale, center) {
            var pointList = [];
            var len = __ecIndicator.length;
            var vector;
            for (var i = 0; i < len; i++) {
                vector = __ecIndicator[i].vector;
                pointList.push(this._mapVector(vector, center, scale));
            }
            return pointList;
        },
        _getShape: function (pointList, brushType, color, strokeColor, lineWidth) {
            return new PolygonShape({
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                style: {
                    pointList: pointList,
                    brushType: brushType,
                    color: color,
                    strokeColor: strokeColor,
                    lineWidth: lineWidth
                },
                hoverable: false,
                draggable: false
            });
        },
        _addSplitArea: function (__ecIndicator, splitArea, scale, scale1, center, colorInd) {
            var indLen = __ecIndicator.length;
            var color;
            var colorArr = splitArea.areaStyle.color;
            var colorLen;
            var vector;
            var vector1;
            var pointList = [];
            var indLen = __ecIndicator.length;
            var shape;
            var type = this.deepQuery(this._queryTarget, 'type');
            if (typeof colorArr == 'string') {
                colorArr = [colorArr];
            }
            colorLen = colorArr.length;
            color = colorArr[colorInd % colorLen];
            if (type == 'polygon') {
                for (var i = 0; i < indLen; i++) {
                    pointList = [];
                    vector = __ecIndicator[i].vector;
                    vector1 = __ecIndicator[(i + 1) % indLen].vector;
                    pointList.push(this._mapVector(vector, center, scale));
                    pointList.push(this._mapVector(vector, center, scale1));
                    pointList.push(this._mapVector(vector1, center, scale1));
                    pointList.push(this._mapVector(vector1, center, scale));
                    shape = this._getShape(pointList, 'fill', color, '', 1);
                    this.shapeList.push(shape);
                }
            } else if (type == 'circle') {
                shape = this._getRing(color, scale, scale1, center);
                this.shapeList.push(shape);
            }
        },
        _mapVector: function (vector, center, scale) {
            return [
                vector[0] * scale + center[0],
                vector[1] * scale + center[1]
            ];
        },
        getCenter: function (index) {
            var index = index || 0;
            return this.parseCenter(this.zr, this.polar[index].center);
        },
        _addLine: function (__ecIndicator, center, axisLine) {
            var indLen = __ecIndicator.length;
            var line;
            var vector;
            var lineStyle = axisLine.lineStyle;
            var strokeColor = lineStyle.color;
            var lineWidth = lineStyle.width;
            var lineType = lineStyle.type;
            for (var i = 0; i < indLen; i++) {
                vector = __ecIndicator[i].vector;
                line = this._getLine(center[0], center[1], vector[0] + center[0], vector[1] + center[1], strokeColor, lineWidth, lineType);
                this.shapeList.push(line);
            }
        },
        _getLine: function (xStart, yStart, xEnd, yEnd, strokeColor, lineWidth, lineType) {
            return new LineShape({
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                style: {
                    xStart: xStart,
                    yStart: yStart,
                    xEnd: xEnd,
                    yEnd: yEnd,
                    strokeColor: strokeColor,
                    lineWidth: lineWidth,
                    lineType: lineType
                },
                hoverable: false
            });
        },
        _adjustIndicatorValue: function (index) {
            var item = this.polar[index];
            var indicator = this.deepQuery(this._queryTarget, 'indicator');
            var len = indicator.length;
            var __ecIndicator = item.__ecIndicator;
            var max;
            var min;
            var data = this._getSeriesData(index);
            var boundaryGap = item.boundaryGap;
            var splitNumber = item.splitNumber;
            var scale = item.scale;
            var opts;
            var smartSteps = require('../util/smartSteps');
            for (var i = 0; i < len; i++) {
                if (typeof indicator[i].max == 'number') {
                    max = indicator[i].max;
                    min = indicator[i].min || 0;
                    opts = {
                        max: max,
                        min: min
                    };
                } else {
                    var value = this._findValue(data, i, splitNumber, boundaryGap);
                    min = value.min;
                    max = value.max;
                }
                if (!scale && min >= 0 && max >= 0) {
                    min = 0;
                }
                if (!scale && min <= 0 && max <= 0) {
                    max = 0;
                }
                var stepOpt = smartSteps(min, max, splitNumber, opts);
                __ecIndicator[i].value = {
                    min: stepOpt.min,
                    max: stepOpt.max,
                    step: stepOpt.step
                };
            }
        },
        _getSeriesData: function (index) {
            var data = [];
            var serie;
            var serieData;
            var legend = this.component.legend;
            var polarIndex;
            for (var i = 0; i < this.series.length; i++) {
                serie = this.series[i];
                if (serie.type != ecConfig.CHART_TYPE_RADAR) {
                    continue;
                }
                serieData = serie.data || [];
                for (var j = 0; j < serieData.length; j++) {
                    polarIndex = this.deepQuery([
                        serieData[j],
                        serie,
                        this.option
                    ], 'polarIndex') || 0;
                    if (polarIndex == index && (!legend || legend.isSelected(serieData[j].name))) {
                        data.push(serieData[j]);
                    }
                }
            }
            return data;
        },
        _findValue: function (data, index, splitNumber, boundaryGap) {
            var max;
            var min;
            var one;
            if (!data || data.length === 0) {
                return;
            }
            function _compare(item) {
                (item > max || max === undefined) && (max = item);
                (item < min || min === undefined) && (min = item);
            }
            if (data.length == 1) {
                min = 0;
            }
            if (data.length != 1) {
                for (var i = 0; i < data.length; i++) {
                    _compare(this.getDataFromOption(data[i].value[index]));
                }
            } else {
                one = data[0];
                for (var i = 0; i < one.value.length; i++) {
                    _compare(this.getDataFromOption(one.value[i]));
                }
            }
            var gap = Math.abs(max - min);
            min = min - Math.abs(gap * boundaryGap[0]);
            max = max + Math.abs(gap * boundaryGap[1]);
            if (min === max) {
                if (max === 0) {
                    max = 1;
                } else if (max > 0) {
                    min = max / splitNumber;
                } else {
                    max = max / splitNumber;
                }
            }
            return {
                max: max,
                min: min
            };
        },
        getVector: function (polarIndex, indicatorIndex, value) {
            polarIndex = polarIndex || 0;
            indicatorIndex = indicatorIndex || 0;
            var __ecIndicator = this.polar[polarIndex].__ecIndicator;
            if (indicatorIndex >= __ecIndicator.length) {
                return;
            }
            var indicator = this.polar[polarIndex].__ecIndicator[indicatorIndex];
            var center = this.getCenter(polarIndex);
            var vector = indicator.vector;
            var max = indicator.value.max;
            var min = indicator.value.min;
            var alpha;
            if (typeof value == 'undefined') {
                return center;
            }
            switch (value) {
            case 'min':
                value = min;
                break;
            case 'max':
                value = max;
                break;
            case 'center':
                value = (max + min) / 2;
                break;
            }
            if (max != min) {
                alpha = (value - min) / (max - min);
            } else {
                alpha = 0.5;
            }
            return this._mapVector(vector, center, alpha);
        },
        isInside: function (vector) {
            var polar = this.getNearestIndex(vector);
            if (polar) {
                return polar.polarIndex;
            }
            return -1;
        },
        getNearestIndex: function (vector) {
            var item;
            var center;
            var radius;
            var polarVector;
            var startAngle;
            var indicator;
            var len;
            var angle;
            var finalAngle;
            for (var i = 0; i < this.polar.length; i++) {
                item = this.polar[i];
                center = this.getCenter(i);
                if (vector[0] == center[0] && vector[1] == center[1]) {
                    return {
                        polarIndex: i,
                        valueIndex: 0
                    };
                }
                radius = this._getRadius();
                startAngle = item.startAngle;
                indicator = item.indicator;
                len = indicator.length;
                angle = 2 * Math.PI / len;
                polarVector = ecCoordinates.cartesian2polar(vector[0] - center[0], center[1] - vector[1]);
                if (vector[0] - center[0] < 0) {
                    polarVector[1] += Math.PI;
                }
                if (polarVector[1] < 0) {
                    polarVector[1] += 2 * Math.PI;
                }
                finalAngle = polarVector[1] - startAngle / 180 * Math.PI + Math.PI * 2;
                if (Math.abs(Math.cos(finalAngle % (angle / 2))) * radius > polarVector[0]) {
                    return {
                        polarIndex: i,
                        valueIndex: Math.floor((finalAngle + angle / 2) / angle) % len
                    };
                }
            }
        },
        getIndicator: function (index) {
            var index = index || 0;
            return this.polar[index].indicator;
        },
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.polar = this.option.polar;
                this.series = this.option.series;
            }
            this.clear();
            this._buildShape();
        }
    };
    zrUtil.inherits(Polar, Base);
    require('../component').define('polar', Polar);
    return Polar;
});define('echarts/util/coordinates', [
    'require',
    'zrender/tool/math'
], function (require) {
    var zrMath = require('zrender/tool/math');
    function polar2cartesian(r, theta) {
        return [
            r * zrMath.sin(theta),
            r * zrMath.cos(theta)
        ];
    }
    function cartesian2polar(x, y) {
        return [
            Math.sqrt(x * x + y * y),
            Math.atan(y / x)
        ];
    }
    return {
        polar2cartesian: polar2cartesian,
        cartesian2polar: cartesian2polar
    };
});define('echarts/chart/chord', [
    'require',
    './base',
    'zrender/shape/Text',
    'zrender/shape/Line',
    'zrender/shape/Sector',
    '../util/shape/Ribbon',
    '../util/shape/Icon',
    'zrender/shape/BezierCurve',
    '../config',
    '../util/ecData',
    'zrender/tool/util',
    'zrender/tool/vector',
    '../data/Graph',
    '../layout/Chord',
    '../chart'
], function (require) {
    'use strict';
    var ChartBase = require('./base');
    var TextShape = require('zrender/shape/Text');
    var LineShape = require('zrender/shape/Line');
    var SectorShape = require('zrender/shape/Sector');
    var RibbonShape = require('../util/shape/Ribbon');
    var IconShape = require('../util/shape/Icon');
    var BezierCurveShape = require('zrender/shape/BezierCurve');
    var ecConfig = require('../config');
    ecConfig.chord = {
        zlevel: 0,
        z: 2,
        clickable: true,
        radius: [
            '65%',
            '75%'
        ],
        center: [
            '50%',
            '50%'
        ],
        padding: 2,
        sort: 'none',
        sortSub: 'none',
        startAngle: 90,
        clockWise: true,
        ribbonType: true,
        minRadius: 10,
        maxRadius: 20,
        symbol: 'circle',
        showScale: false,
        showScaleText: false,
        itemStyle: {
            normal: {
                borderWidth: 0,
                borderColor: '#000',
                label: {
                    show: true,
                    rotate: false,
                    distance: 5
                },
                chordStyle: {
                    width: 1,
                    color: 'black',
                    borderWidth: 1,
                    borderColor: '#999',
                    opacity: 0.5
                }
            },
            emphasis: {
                borderWidth: 0,
                borderColor: '#000',
                chordStyle: {
                    width: 1,
                    color: 'black',
                    borderWidth: 1,
                    borderColor: '#999'
                }
            }
        }
    };
    var ecData = require('../util/ecData');
    var zrUtil = require('zrender/tool/util');
    var vec2 = require('zrender/tool/vector');
    var Graph = require('../data/Graph');
    var ChordLayout = require('../layout/Chord');
    function Chord(ecTheme, messageCenter, zr, option, myChart) {
        ChartBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.scaleLineLength = 4;
        this.scaleUnitAngle = 4;
        this.refresh(option);
    }
    Chord.prototype = {
        type: ecConfig.CHART_TYPE_CHORD,
        _init: function () {
            var series = this.series;
            this.selectedMap = {};
            var chordSeriesMap = {};
            var chordSeriesGroups = {};
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].type === this.type) {
                    var _isSelected = this.isSelected(series[i].name);
                    this.selectedMap[series[i].name] = _isSelected;
                    if (_isSelected) {
                        this.buildMark(i);
                    }
                    this.reformOption(series[i]);
                    chordSeriesMap[series[i].name] = series[i];
                }
            }
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].type === this.type) {
                    if (series[i].insertToSerie) {
                        var referenceSerie = chordSeriesMap[series[i].insertToSerie];
                        series[i]._referenceSerie = referenceSerie;
                    } else {
                        chordSeriesGroups[series[i].name] = [series[i]];
                    }
                }
            }
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].type === this.type) {
                    if (series[i].insertToSerie) {
                        var mainSerie = series[i]._referenceSerie;
                        while (mainSerie && mainSerie._referenceSerie) {
                            mainSerie = mainSerie._referenceSerie;
                        }
                        if (chordSeriesGroups[mainSerie.name] && this.selectedMap[series[i].name]) {
                            chordSeriesGroups[mainSerie.name].push(series[i]);
                        }
                    }
                }
            }
            for (var name in chordSeriesGroups) {
                this._buildChords(chordSeriesGroups[name]);
            }
            this.addShapeList();
        },
        _getNodeCategory: function (serie, group) {
            return serie.categories && serie.categories[group.category || 0];
        },
        _getNodeQueryTarget: function (serie, group) {
            var category = this._getNodeCategory(serie, group);
            return [
                group,
                category,
                serie
            ];
        },
        _getEdgeQueryTarget: function (serie, edge, type) {
            type = type || 'normal';
            return [
                edge.itemStyle && edge.itemStyle[type],
                serie.itemStyle[type].chordStyle
            ];
        },
        _buildChords: function (series) {
            var graphs = [];
            var mainSerie = series[0];
            var nodeFilter = function (n) {
                return n.layout.size > 0;
            };
            var createEdgeFilter = function (graph) {
                return function (e) {
                    return graph.getEdge(e.node2, e.node1);
                };
            };
            for (var i = 0; i < series.length; i++) {
                var serie = series[i];
                if (this.selectedMap[serie.name]) {
                    var graph;
                    if (serie.data && serie.matrix) {
                        graph = this._getSerieGraphFromDataMatrix(serie, mainSerie);
                    } else if (serie.nodes && serie.links) {
                        graph = this._getSerieGraphFromNodeLinks(serie, mainSerie);
                    }
                    graph.filterNode(nodeFilter, this);
                    if (serie.ribbonType) {
                        graph.filterEdge(createEdgeFilter(graph));
                    }
                    graphs.push(graph);
                    graph.__serie = serie;
                }
            }
            if (!graphs.length) {
                return;
            }
            var mainGraph = graphs[0];
            if (!mainSerie.ribbonType) {
                var minRadius = mainSerie.minRadius;
                var maxRadius = mainSerie.maxRadius;
                var min = Infinity, max = -Infinity;
                mainGraph.eachNode(function (node) {
                    max = Math.max(node.layout.size, max);
                    min = Math.min(node.layout.size, min);
                });
                var multiplier = (maxRadius - minRadius) / (max - min);
                mainGraph.eachNode(function (node) {
                    var queryTarget = this._getNodeQueryTarget(mainSerie, node);
                    var symbolSize = this.query(queryTarget, 'symbolSize');
                    if (max === min) {
                        node.layout.size = symbolSize || min;
                    } else {
                        node.layout.size = symbolSize || (node.layout.size - min) * multiplier + minRadius;
                    }
                }, this);
            }
            var layout = new ChordLayout();
            layout.clockWise = mainSerie.clockWise;
            layout.startAngle = mainSerie.startAngle * Math.PI / 180;
            if (!layout.clockWise) {
                layout.startAngle = -layout.startAngle;
            }
            layout.padding = mainSerie.padding * Math.PI / 180;
            layout.sort = mainSerie.sort;
            layout.sortSub = mainSerie.sortSub;
            layout.directed = mainSerie.ribbonType;
            layout.run(graphs);
            var showLabel = this.query(mainSerie, 'itemStyle.normal.label.show');
            if (mainSerie.ribbonType) {
                this._buildSectors(mainSerie, 0, mainGraph, mainSerie, graphs);
                if (showLabel) {
                    this._buildLabels(mainSerie, 0, mainGraph, mainSerie, graphs);
                }
                for (var i = 0, j = 0; i < series.length; i++) {
                    if (this.selectedMap[series[i].name]) {
                        this._buildRibbons(series, i, graphs[j++], mainSerie);
                    }
                }
                if (mainSerie.showScale) {
                    this._buildScales(mainSerie, 0, mainGraph);
                }
            } else {
                this._buildNodeIcons(mainSerie, 0, mainGraph, mainSerie, graphs);
                if (showLabel) {
                    this._buildLabels(mainSerie, 0, mainGraph, mainSerie, graphs);
                }
                for (var i = 0, j = 0; i < series.length; i++) {
                    if (this.selectedMap[series[i].name]) {
                        this._buildEdgeCurves(series, i, graphs[j++], mainSerie, mainGraph);
                    }
                }
            }
            this._initHoverHandler(series, graphs);
        },
        _getSerieGraphFromDataMatrix: function (serie, mainSerie) {
            var nodesData = [];
            var count = 0;
            var matrix = [];
            for (var i = 0; i < serie.matrix.length; i++) {
                matrix[i] = serie.matrix[i].slice();
            }
            var data = serie.data || serie.nodes;
            for (var i = 0; i < data.length; i++) {
                var node = {};
                var group = data[i];
                group.rawIndex = i;
                for (var key in group) {
                    if (key === 'name') {
                        node['id'] = group['name'];
                    } else {
                        node[key] = group[key];
                    }
                }
                var category = this._getNodeCategory(mainSerie, group);
                var name = category ? category.name : group.name;
                this.selectedMap[name] = this.isSelected(name);
                if (this.selectedMap[name]) {
                    nodesData.push(node);
                    count++;
                } else {
                    matrix.splice(count, 1);
                    for (var j = 0; j < matrix.length; j++) {
                        matrix[j].splice(count, 1);
                    }
                }
            }
            var graph = Graph.fromMatrix(nodesData, matrix, true);
            graph.eachNode(function (n, idx) {
                n.layout = { size: n.data.outValue };
                n.rawIndex = n.data.rawIndex;
            });
            graph.eachEdge(function (e) {
                e.layout = { weight: e.data.weight };
            });
            return graph;
        },
        _getSerieGraphFromNodeLinks: function (serie, mainSerie) {
            var graph = new Graph(true);
            var nodes = serie.data || serie.nodes;
            for (var i = 0, len = nodes.length; i < len; i++) {
                var n = nodes[i];
                if (!n || n.ignore) {
                    continue;
                }
                var category = this._getNodeCategory(mainSerie, n);
                var name = category ? category.name : n.name;
                this.selectedMap[name] = this.isSelected(name);
                if (this.selectedMap[name]) {
                    var node = graph.addNode(n.name, n);
                    node.rawIndex = i;
                }
            }
            for (var i = 0, len = serie.links.length; i < len; i++) {
                var e = serie.links[i];
                var n1 = e.source;
                var n2 = e.target;
                if (typeof n1 === 'number') {
                    n1 = nodes[n1];
                    if (n1) {
                        n1 = n1.name;
                    }
                }
                if (typeof n2 === 'number') {
                    n2 = nodes[n2];
                    if (n2) {
                        n2 = n2.name;
                    }
                }
                var edge = graph.addEdge(n1, n2, e);
                if (edge) {
                    edge.rawIndex = i;
                }
            }
            graph.eachNode(function (n) {
                var value = n.data.value;
                if (value == null) {
                    value = 0;
                    if (mainSerie.ribbonType) {
                        for (var i = 0; i < n.outEdges.length; i++) {
                            value += n.outEdges[i].data.weight || 0;
                        }
                    } else {
                        for (var i = 0; i < n.edges.length; i++) {
                            value += n.edges[i].data.weight || 0;
                        }
                    }
                }
                n.layout = { size: value };
            });
            graph.eachEdge(function (e) {
                e.layout = { weight: e.data.weight == null ? 1 : e.data.weight };
            });
            return graph;
        },
        _initHoverHandler: function (series, graphs) {
            var mainSerie = series[0];
            var mainGraph = graphs[0];
            var self = this;
            mainGraph.eachNode(function (node) {
                node.shape.onmouseover = function () {
                    mainGraph.eachNode(function (n) {
                        n.shape.style.opacity = 0.1;
                        if (n.labelShape) {
                            n.labelShape.style.opacity = 0.1;
                            n.labelShape.modSelf();
                        }
                        n.shape.modSelf();
                    });
                    for (var i = 0; i < graphs.length; i++) {
                        for (var j = 0; j < graphs[i].edges.length; j++) {
                            var e = graphs[i].edges[j];
                            var queryTarget = self._getEdgeQueryTarget(graphs[i].__serie, e.data);
                            e.shape.style.opacity = self.deepQuery(queryTarget, 'opacity') * 0.1;
                            e.shape.modSelf();
                        }
                    }
                    node.shape.style.opacity = 1;
                    if (node.labelShape) {
                        node.labelShape.style.opacity = 1;
                    }
                    for (var i = 0; i < graphs.length; i++) {
                        var n = graphs[i].getNodeById(node.id);
                        if (n) {
                            for (var j = 0; j < n.outEdges.length; j++) {
                                var e = n.outEdges[j];
                                var queryTarget = self._getEdgeQueryTarget(graphs[i].__serie, e.data);
                                e.shape.style.opacity = self.deepQuery(queryTarget, 'opacity');
                                var other = graphs[0].getNodeById(e.node2.id);
                                if (other) {
                                    if (other.shape) {
                                        other.shape.style.opacity = 1;
                                    }
                                    if (other.labelShape) {
                                        other.labelShape.style.opacity = 1;
                                    }
                                }
                            }
                        }
                    }
                    self.zr.refreshNextFrame();
                };
                node.shape.onmouseout = function () {
                    mainGraph.eachNode(function (n) {
                        n.shape.style.opacity = 1;
                        if (n.labelShape) {
                            n.labelShape.style.opacity = 1;
                            n.labelShape.modSelf();
                        }
                        n.shape.modSelf();
                    });
                    for (var i = 0; i < graphs.length; i++) {
                        for (var j = 0; j < graphs[i].edges.length; j++) {
                            var e = graphs[i].edges[j];
                            var queryTarget = [
                                e.data,
                                mainSerie
                            ];
                            e.shape.style.opacity = self.deepQuery(queryTarget, 'itemStyle.normal.chordStyle.opacity');
                            e.shape.modSelf();
                        }
                    }
                    self.zr.refreshNextFrame();
                };
            });
        },
        _buildSectors: function (serie, serieIdx, graph, mainSerie) {
            var center = this.parseCenter(this.zr, mainSerie.center);
            var radius = this.parseRadius(this.zr, mainSerie.radius);
            var clockWise = mainSerie.clockWise;
            var sign = clockWise ? 1 : -1;
            graph.eachNode(function (node) {
                var category = this._getNodeCategory(mainSerie, node.data);
                var color = category ? this.getColor(category.name) : this.getColor(node.id);
                var startAngle = node.layout.startAngle / Math.PI * 180 * sign;
                var endAngle = node.layout.endAngle / Math.PI * 180 * sign;
                var sector = new SectorShape({
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    style: {
                        x: center[0],
                        y: center[1],
                        r0: radius[0],
                        r: radius[1],
                        startAngle: startAngle,
                        endAngle: endAngle,
                        brushType: 'fill',
                        opacity: 1,
                        color: color,
                        clockWise: clockWise
                    },
                    clickable: mainSerie.clickable,
                    highlightStyle: { brushType: 'fill' }
                });
                sector.style.lineWidth = this.deepQuery([
                    node.data,
                    mainSerie
                ], 'itemStyle.normal.borderWidth');
                sector.highlightStyle.lineWidth = this.deepQuery([
                    node.data,
                    mainSerie
                ], 'itemStyle.emphasis.borderWidth');
                sector.style.strokeColor = this.deepQuery([
                    node.data,
                    mainSerie
                ], 'itemStyle.normal.borderColor');
                sector.highlightStyle.strokeColor = this.deepQuery([
                    node.data,
                    mainSerie
                ], 'itemStyle.emphasis.borderColor');
                if (sector.style.lineWidth > 0) {
                    sector.style.brushType = 'both';
                }
                if (sector.highlightStyle.lineWidth > 0) {
                    sector.highlightStyle.brushType = 'both';
                }
                ecData.pack(sector, serie, serieIdx, node.data, node.rawIndex, node.id, node.category);
                this.shapeList.push(sector);
                node.shape = sector;
            }, this);
        },
        _buildNodeIcons: function (serie, serieIdx, graph, mainSerie) {
            var center = this.parseCenter(this.zr, mainSerie.center);
            var radius = this.parseRadius(this.zr, mainSerie.radius);
            var r = radius[1];
            graph.eachNode(function (node) {
                var startAngle = node.layout.startAngle;
                var endAngle = node.layout.endAngle;
                var angle = (startAngle + endAngle) / 2;
                var x = r * Math.cos(angle);
                var y = r * Math.sin(angle);
                var queryTarget = this._getNodeQueryTarget(mainSerie, node.data);
                var category = this._getNodeCategory(mainSerie, node.data);
                var color = this.deepQuery(queryTarget, 'itemStyle.normal.color');
                if (!color) {
                    color = category ? this.getColor(category.name) : this.getColor(node.id);
                }
                var iconShape = new IconShape({
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase() + 1,
                    style: {
                        x: -node.layout.size,
                        y: -node.layout.size,
                        width: node.layout.size * 2,
                        height: node.layout.size * 2,
                        iconType: this.deepQuery(queryTarget, 'symbol'),
                        color: color,
                        brushType: 'both',
                        lineWidth: this.deepQuery(queryTarget, 'itemStyle.normal.borderWidth'),
                        strokeColor: this.deepQuery(queryTarget, 'itemStyle.normal.borderColor')
                    },
                    highlightStyle: {
                        color: this.deepQuery(queryTarget, 'itemStyle.emphasis.color'),
                        lineWidth: this.deepQuery(queryTarget, 'itemStyle.emphasis.borderWidth'),
                        strokeColor: this.deepQuery(queryTarget, 'itemStyle.emphasis.borderColor')
                    },
                    clickable: mainSerie.clickable,
                    position: [
                        x + center[0],
                        y + center[1]
                    ]
                });
                ecData.pack(iconShape, serie, serieIdx, node.data, node.rawIndex, node.id, node.category);
                this.shapeList.push(iconShape);
                node.shape = iconShape;
            }, this);
        },
        _buildLabels: function (serie, serieIdx, graph, mainSerie) {
            var labelColor = this.query(mainSerie, 'itemStyle.normal.label.color');
            var rotateLabel = this.query(mainSerie, 'itemStyle.normal.label.rotate');
            var labelDistance = this.query(mainSerie, 'itemStyle.normal.label.distance');
            var center = this.parseCenter(this.zr, mainSerie.center);
            var radius = this.parseRadius(this.zr, mainSerie.radius);
            var clockWise = mainSerie.clockWise;
            var sign = clockWise ? 1 : -1;
            graph.eachNode(function (node) {
                var startAngle = node.layout.startAngle / Math.PI * 180 * sign;
                var endAngle = node.layout.endAngle / Math.PI * 180 * sign;
                var angle = (startAngle * -sign + endAngle * -sign) / 2;
                angle %= 360;
                if (angle < 0) {
                    angle += 360;
                }
                var isRightSide = angle <= 90 || angle >= 270;
                angle = angle * Math.PI / 180;
                var v = [
                    Math.cos(angle),
                    -Math.sin(angle)
                ];
                var distance = 0;
                if (mainSerie.ribbonType) {
                    distance = mainSerie.showScaleText ? 35 + labelDistance : labelDistance;
                } else {
                    distance = labelDistance + node.layout.size;
                }
                var start = vec2.scale([], v, radius[1] + distance);
                vec2.add(start, start, center);
                var labelShape = {
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase() + 1,
                    hoverable: false,
                    style: {
                        text: node.data.label == null ? node.id : node.data.label,
                        textAlign: isRightSide ? 'left' : 'right',
                        color: labelColor || '#000000'
                    }
                };
                if (rotateLabel) {
                    labelShape.rotation = isRightSide ? angle : Math.PI + angle;
                    if (isRightSide) {
                        labelShape.style.x = radius[1] + distance;
                    } else {
                        labelShape.style.x = -radius[1] - distance;
                    }
                    labelShape.style.y = 0;
                    labelShape.position = center.slice();
                } else {
                    labelShape.style.x = start[0];
                    labelShape.style.y = start[1];
                }
                labelShape.style.textColor = this.deepQuery([
                    node.data,
                    mainSerie
                ], 'itemStyle.normal.label.textStyle.color') || '#fff';
                labelShape.style.textFont = this.getFont(this.deepQuery([
                    node.data,
                    mainSerie
                ], 'itemStyle.normal.label.textStyle'));
                labelShape = new TextShape(labelShape);
                this.shapeList.push(labelShape);
                node.labelShape = labelShape;
            }, this);
        },
        _buildRibbons: function (series, serieIdx, graph, mainSerie) {
            var serie = series[serieIdx];
            var center = this.parseCenter(this.zr, mainSerie.center);
            var radius = this.parseRadius(this.zr, mainSerie.radius);
            graph.eachEdge(function (edge, idx) {
                var color;
                var other = graph.getEdge(edge.node2, edge.node1);
                if (!other || edge.shape) {
                    return;
                }
                if (other.shape) {
                    edge.shape = other.shape;
                    return;
                }
                var s0 = edge.layout.startAngle / Math.PI * 180;
                var s1 = edge.layout.endAngle / Math.PI * 180;
                var t0 = other.layout.startAngle / Math.PI * 180;
                var t1 = other.layout.endAngle / Math.PI * 180;
                if (series.length === 1) {
                    if (edge.layout.weight <= other.layout.weight) {
                        color = this.getColor(edge.node1.id);
                    } else {
                        color = this.getColor(edge.node2.id);
                    }
                } else {
                    color = this.getColor(serie.name);
                }
                var queryTarget = this._getEdgeQueryTarget(serie, edge.data);
                var queryTargetEmphasis = this._getEdgeQueryTarget(serie, edge.data, 'emphasis');
                var ribbon = new RibbonShape({
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    style: {
                        x: center[0],
                        y: center[1],
                        r: radius[0],
                        source0: s0,
                        source1: s1,
                        target0: t0,
                        target1: t1,
                        brushType: 'both',
                        opacity: this.deepQuery(queryTarget, 'opacity'),
                        color: color,
                        lineWidth: this.deepQuery(queryTarget, 'borderWidth'),
                        strokeColor: this.deepQuery(queryTarget, 'borderColor'),
                        clockWise: mainSerie.clockWise
                    },
                    clickable: mainSerie.clickable,
                    highlightStyle: {
                        brushType: 'both',
                        opacity: this.deepQuery(queryTargetEmphasis, 'opacity'),
                        lineWidth: this.deepQuery(queryTargetEmphasis, 'borderWidth'),
                        strokeColor: this.deepQuery(queryTargetEmphasis, 'borderColor')
                    }
                });
                var node1, node2;
                if (edge.layout.weight <= other.layout.weight) {
                    node1 = other.node1;
                    node2 = other.node2;
                } else {
                    node1 = edge.node1;
                    node2 = edge.node2;
                }
                ecData.pack(ribbon, serie, serieIdx, edge.data, edge.rawIndex == null ? idx : edge.rawIndex, edge.data.name || node1.id + '-' + node2.id, node1.id, node2.id);
                this.shapeList.push(ribbon);
                edge.shape = ribbon;
            }, this);
        },
        _buildEdgeCurves: function (series, serieIdx, graph, mainSerie, mainGraph) {
            var serie = series[serieIdx];
            var center = this.parseCenter(this.zr, mainSerie.center);
            graph.eachEdge(function (e, idx) {
                var node1 = mainGraph.getNodeById(e.node1.id);
                var node2 = mainGraph.getNodeById(e.node2.id);
                var shape1 = node1.shape;
                var shape2 = node2.shape;
                var queryTarget = this._getEdgeQueryTarget(serie, e.data);
                var queryTargetEmphasis = this._getEdgeQueryTarget(serie, e.data, 'emphasis');
                var curveShape = new BezierCurveShape({
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    style: {
                        xStart: shape1.position[0],
                        yStart: shape1.position[1],
                        xEnd: shape2.position[0],
                        yEnd: shape2.position[1],
                        cpX1: center[0],
                        cpY1: center[1],
                        lineWidth: this.deepQuery(queryTarget, 'width'),
                        strokeColor: this.deepQuery(queryTarget, 'color'),
                        opacity: this.deepQuery(queryTarget, 'opacity')
                    },
                    highlightStyle: {
                        lineWidth: this.deepQuery(queryTargetEmphasis, 'width'),
                        strokeColor: this.deepQuery(queryTargetEmphasis, 'color'),
                        opacity: this.deepQuery(queryTargetEmphasis, 'opacity')
                    }
                });
                ecData.pack(curveShape, serie, serieIdx, e.data, e.rawIndex == null ? idx : e.rawIndex, e.data.name || e.node1.id + '-' + e.node2.id, e.node1.id, e.node2.id);
                this.shapeList.push(curveShape);
                e.shape = curveShape;
            }, this);
        },
        _buildScales: function (serie, serieIdx, graph) {
            var clockWise = serie.clockWise;
            var center = this.parseCenter(this.zr, serie.center);
            var radius = this.parseRadius(this.zr, serie.radius);
            var sign = clockWise ? 1 : -1;
            var sumValue = 0;
            var maxValue = -Infinity;
            var unitPostfix;
            var unitScale;
            if (serie.showScaleText) {
                graph.eachNode(function (node) {
                    var val = node.data.value;
                    if (val > maxValue) {
                        maxValue = val;
                    }
                    sumValue += val;
                });
                if (maxValue > 10000000000) {
                    unitPostfix = 'b';
                    unitScale = 1e-9;
                } else if (maxValue > 10000000) {
                    unitPostfix = 'm';
                    unitScale = 0.000001;
                } else if (maxValue > 10000) {
                    unitPostfix = 'k';
                    unitScale = 0.001;
                } else {
                    unitPostfix = '';
                    unitScale = 1;
                }
            }
            var unitValue = sumValue / (360 - serie.padding);
            graph.eachNode(function (node) {
                var startAngle = node.layout.startAngle / Math.PI * 180;
                var endAngle = node.layout.endAngle / Math.PI * 180;
                var scaleAngle = startAngle;
                while (true) {
                    if (clockWise && scaleAngle > endAngle || !clockWise && scaleAngle < endAngle) {
                        break;
                    }
                    var theta = scaleAngle / 180 * Math.PI;
                    var v = [
                        Math.cos(theta),
                        Math.sin(theta)
                    ];
                    var start = vec2.scale([], v, radius[1] + 1);
                    vec2.add(start, start, center);
                    var end = vec2.scale([], v, radius[1] + this.scaleLineLength);
                    vec2.add(end, end, center);
                    var scaleShape = new LineShape({
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase() - 1,
                        hoverable: false,
                        style: {
                            xStart: start[0],
                            yStart: start[1],
                            xEnd: end[0],
                            yEnd: end[1],
                            lineCap: 'round',
                            brushType: 'stroke',
                            strokeColor: '#666',
                            lineWidth: 1
                        }
                    });
                    this.shapeList.push(scaleShape);
                    scaleAngle += sign * this.scaleUnitAngle;
                }
                if (!serie.showScaleText) {
                    return;
                }
                var scaleTextAngle = startAngle;
                var step = unitValue * 5 * this.scaleUnitAngle;
                var scaleValue = 0;
                while (true) {
                    if (clockWise && scaleTextAngle > endAngle || !clockWise && scaleTextAngle < endAngle) {
                        break;
                    }
                    var theta = scaleTextAngle;
                    theta = theta % 360;
                    if (theta < 0) {
                        theta += 360;
                    }
                    var isRightSide = theta <= 90 || theta >= 270;
                    var textShape = new TextShape({
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase() - 1,
                        hoverable: false,
                        style: {
                            x: isRightSide ? radius[1] + this.scaleLineLength + 4 : -radius[1] - this.scaleLineLength - 4,
                            y: 0,
                            text: Math.round(scaleValue * 10) / 10 + unitPostfix,
                            textAlign: isRightSide ? 'left' : 'right'
                        },
                        position: center.slice(),
                        rotation: isRightSide ? [
                            -theta / 180 * Math.PI,
                            0,
                            0
                        ] : [
                            -(theta + 180) / 180 * Math.PI,
                            0,
                            0
                        ]
                    });
                    this.shapeList.push(textShape);
                    scaleValue += step * unitScale;
                    scaleTextAngle += sign * this.scaleUnitAngle * 5;
                }
            }, this);
        },
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.series = newOption.series;
            }
            this.legend = this.component.legend;
            if (this.legend) {
                this.getColor = function (param) {
                    return this.legend.getColor(param);
                };
                this.isSelected = function (param) {
                    return this.legend.isSelected(param);
                };
            } else {
                var colorMap = {};
                var count = 0;
                this.getColor = function (key) {
                    if (colorMap[key]) {
                        return colorMap[key];
                    }
                    if (!colorMap[key]) {
                        colorMap[key] = this.zr.getColor(count++);
                    }
                    return colorMap[key];
                };
                this.isSelected = function () {
                    return true;
                };
            }
            this.backupShapeList();
            this._init();
        },
        reformOption: function (opt) {
            var _merge = zrUtil.merge;
            opt = _merge(_merge(opt || {}, this.ecTheme.chord), ecConfig.chord);
            opt.itemStyle.normal.label.textStyle = this.getTextStyle(opt.itemStyle.normal.label.textStyle);
            this.z = opt.z;
            this.zlevel = opt.zlevel;
        }
    };
    zrUtil.inherits(Chord, ChartBase);
    require('../chart').define('chord', Chord);
    return Chord;
});define('echarts/util/shape/Ribbon', [
    'require',
    'zrender/shape/Base',
    'zrender/shape/util/PathProxy',
    'zrender/tool/util',
    'zrender/tool/area'
], function (require) {
    var Base = require('zrender/shape/Base');
    var PathProxy = require('zrender/shape/util/PathProxy');
    var zrUtil = require('zrender/tool/util');
    var area = require('zrender/tool/area');
    function RibbonShape(options) {
        Base.call(this, options);
        this._pathProxy = new PathProxy();
    }
    RibbonShape.prototype = {
        type: 'ribbon',
        buildPath: function (ctx, style) {
            var clockWise = style.clockWise || false;
            var path = this._pathProxy;
            path.begin(ctx);
            var cx = style.x;
            var cy = style.y;
            var r = style.r;
            var s0 = style.source0 / 180 * Math.PI;
            var s1 = style.source1 / 180 * Math.PI;
            var t0 = style.target0 / 180 * Math.PI;
            var t1 = style.target1 / 180 * Math.PI;
            var sx0 = cx + Math.cos(s0) * r;
            var sy0 = cy + Math.sin(s0) * r;
            var sx1 = cx + Math.cos(s1) * r;
            var sy1 = cy + Math.sin(s1) * r;
            var tx0 = cx + Math.cos(t0) * r;
            var ty0 = cy + Math.sin(t0) * r;
            var tx1 = cx + Math.cos(t1) * r;
            var ty1 = cy + Math.sin(t1) * r;
            path.moveTo(sx0, sy0);
            path.arc(cx, cy, style.r, s0, s1, !clockWise);
            path.bezierCurveTo((cx - sx1) * 0.7 + sx1, (cy - sy1) * 0.7 + sy1, (cx - tx0) * 0.7 + tx0, (cy - ty0) * 0.7 + ty0, tx0, ty0);
            if (style.source0 === style.target0 && style.source1 === style.target1) {
                return;
            }
            path.arc(cx, cy, style.r, t0, t1, !clockWise);
            path.bezierCurveTo((cx - tx1) * 0.7 + tx1, (cy - ty1) * 0.7 + ty1, (cx - sx0) * 0.7 + sx0, (cy - sy0) * 0.7 + sy0, sx0, sy0);
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            if (!this._pathProxy.isEmpty()) {
                this.buildPath(null, style);
            }
            return this._pathProxy.fastBoundingRect();
        },
        isCover: function (x, y) {
            var rect = this.getRect(this.style);
            if (x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height) {
                return area.isInsidePath(this._pathProxy.pathCommands, 0, 'fill', x, y);
            }
        }
    };
    zrUtil.inherits(RibbonShape, Base);
    return RibbonShape;
});define('echarts/data/Graph', [
    'require',
    'zrender/tool/util'
], function (require) {
    var util = require('zrender/tool/util');
    'use strict';
    var Graph = function (directed) {
        this._directed = directed || false;
        this.nodes = [];
        this.edges = [];
        this._nodesMap = {};
        this._edgesMap = {};
    };
    Graph.prototype.isDirected = function () {
        return this._directed;
    };
    Graph.prototype.addNode = function (id, data) {
        if (this._nodesMap[id]) {
            return this._nodesMap[id];
        }
        var node = new Graph.Node(id, data);
        this.nodes.push(node);
        this._nodesMap[id] = node;
        return node;
    };
    Graph.prototype.getNodeById = function (id) {
        return this._nodesMap[id];
    };
    Graph.prototype.addEdge = function (n1, n2, data) {
        if (typeof n1 == 'string') {
            n1 = this._nodesMap[n1];
        }
        if (typeof n2 == 'string') {
            n2 = this._nodesMap[n2];
        }
        if (!n1 || !n2) {
            return;
        }
        var key = n1.id + '-' + n2.id;
        if (this._edgesMap[key]) {
            return this._edgesMap[key];
        }
        var edge = new Graph.Edge(n1, n2, data);
        if (this._directed) {
            n1.outEdges.push(edge);
            n2.inEdges.push(edge);
        }
        n1.edges.push(edge);
        if (n1 !== n2) {
            n2.edges.push(edge);
        }
        this.edges.push(edge);
        this._edgesMap[key] = edge;
        return edge;
    };
    Graph.prototype.removeEdge = function (edge) {
        var n1 = edge.node1;
        var n2 = edge.node2;
        var key = n1.id + '-' + n2.id;
        if (this._directed) {
            n1.outEdges.splice(util.indexOf(n1.outEdges, edge), 1);
            n2.inEdges.splice(util.indexOf(n2.inEdges, edge), 1);
        }
        n1.edges.splice(util.indexOf(n1.edges, edge), 1);
        if (n1 !== n2) {
            n2.edges.splice(util.indexOf(n2.edges, edge), 1);
        }
        delete this._edgesMap[key];
        this.edges.splice(util.indexOf(this.edges, edge), 1);
    };
    Graph.prototype.getEdge = function (n1, n2) {
        if (typeof n1 !== 'string') {
            n1 = n1.id;
        }
        if (typeof n2 !== 'string') {
            n2 = n2.id;
        }
        if (this._directed) {
            return this._edgesMap[n1 + '-' + n2];
        } else {
            return this._edgesMap[n1 + '-' + n2] || this._edgesMap[n2 + '-' + n1];
        }
    };
    Graph.prototype.removeNode = function (node) {
        if (typeof node === 'string') {
            node = this._nodesMap[node];
            if (!node) {
                return;
            }
        }
        delete this._nodesMap[node.id];
        this.nodes.splice(util.indexOf(this.nodes, node), 1);
        for (var i = 0; i < this.edges.length;) {
            var edge = this.edges[i];
            if (edge.node1 === node || edge.node2 === node) {
                this.removeEdge(edge);
            } else {
                i++;
            }
        }
    };
    Graph.prototype.filterNode = function (cb, context) {
        var len = this.nodes.length;
        for (var i = 0; i < len;) {
            if (cb.call(context, this.nodes[i], i)) {
                i++;
            } else {
                this.removeNode(this.nodes[i]);
                len--;
            }
        }
    };
    Graph.prototype.filterEdge = function (cb, context) {
        var len = this.edges.length;
        for (var i = 0; i < len;) {
            if (cb.call(context, this.edges[i], i)) {
                i++;
            } else {
                this.removeEdge(this.edges[i]);
                len--;
            }
        }
    };
    Graph.prototype.eachNode = function (cb, context) {
        var len = this.nodes.length;
        for (var i = 0; i < len; i++) {
            if (this.nodes[i]) {
                cb.call(context, this.nodes[i], i);
            }
        }
    };
    Graph.prototype.eachEdge = function (cb, context) {
        var len = this.edges.length;
        for (var i = 0; i < len; i++) {
            if (this.edges[i]) {
                cb.call(context, this.edges[i], i);
            }
        }
    };
    Graph.prototype.clear = function () {
        this.nodes.length = 0;
        this.edges.length = 0;
        this._nodesMap = {};
        this._edgesMap = {};
    };
    Graph.prototype.breadthFirstTraverse = function (cb, startNode, direction, context) {
        if (typeof startNode === 'string') {
            startNode = this._nodesMap[startNode];
        }
        if (!startNode) {
            return;
        }
        var edgeType = 'edges';
        if (direction === 'out') {
            edgeType = 'outEdges';
        } else if (direction === 'in') {
            edgeType = 'inEdges';
        }
        for (var i = 0; i < this.nodes.length; i++) {
            this.nodes[i].__visited = false;
        }
        if (cb.call(context, startNode, null)) {
            return;
        }
        var queue = [startNode];
        while (queue.length) {
            var currentNode = queue.shift();
            var edges = currentNode[edgeType];
            for (var i = 0; i < edges.length; i++) {
                var e = edges[i];
                var otherNode = e.node1 === currentNode ? e.node2 : e.node1;
                if (!otherNode.__visited) {
                    if (cb.call(otherNode, otherNode, currentNode)) {
                        return;
                    }
                    queue.push(otherNode);
                    otherNode.__visited = true;
                }
            }
        }
    };
    Graph.prototype.clone = function () {
        var graph = new Graph(this._directed);
        for (var i = 0; i < this.nodes.length; i++) {
            graph.addNode(this.nodes[i].id, this.nodes[i].data);
        }
        for (var i = 0; i < this.edges.length; i++) {
            var e = this.edges[i];
            graph.addEdge(e.node1.id, e.node2.id, e.data);
        }
        return graph;
    };
    var Node = function (id, data) {
        this.id = id;
        this.data = data || null;
        this.inEdges = [];
        this.outEdges = [];
        this.edges = [];
    };
    Node.prototype.degree = function () {
        return this.edges.length;
    };
    Node.prototype.inDegree = function () {
        return this.inEdges.length;
    };
    Node.prototype.outDegree = function () {
        return this.outEdges.length;
    };
    var Edge = function (node1, node2, data) {
        this.node1 = node1;
        this.node2 = node2;
        this.data = data || null;
    };
    Graph.Node = Node;
    Graph.Edge = Edge;
    Graph.fromMatrix = function (nodesData, matrix, directed) {
        if (!matrix || !matrix.length || matrix[0].length !== matrix.length || nodesData.length !== matrix.length) {
            return;
        }
        var size = matrix.length;
        var graph = new Graph(directed);
        for (var i = 0; i < size; i++) {
            var node = graph.addNode(nodesData[i].id, nodesData[i]);
            node.data.value = 0;
            if (directed) {
                node.data.outValue = node.data.inValue = 0;
            }
        }
        for (var i = 0; i < size; i++) {
            for (var j = 0; j < size; j++) {
                var item = matrix[i][j];
                if (directed) {
                    graph.nodes[i].data.outValue += item;
                    graph.nodes[j].data.inValue += item;
                }
                graph.nodes[i].data.value += item;
                graph.nodes[j].data.value += item;
            }
        }
        for (var i = 0; i < size; i++) {
            for (var j = i; j < size; j++) {
                var item = matrix[i][j];
                if (item === 0) {
                    continue;
                }
                var n1 = graph.nodes[i];
                var n2 = graph.nodes[j];
                var edge = graph.addEdge(n1, n2, {});
                edge.data.weight = item;
                if (i !== j) {
                    if (directed && matrix[j][i]) {
                        var inEdge = graph.addEdge(n2, n1, {});
                        inEdge.data.weight = matrix[j][i];
                    }
                }
            }
        }
        return graph;
    };
    return Graph;
});define('echarts/layout/Chord', ['require'], function (require) {
    var ChordLayout = function (opts) {
        opts = opts || {};
        this.sort = opts.sort || null;
        this.sortSub = opts.sortSub || null;
        this.padding = 0.05;
        this.startAngle = opts.startAngle || 0;
        this.clockWise = opts.clockWise == null ? false : opts.clockWise;
        this.center = opts.center || [
            0,
            0
        ];
        this.directed = true;
    };
    ChordLayout.prototype.run = function (graphs) {
        if (!(graphs instanceof Array)) {
            graphs = [graphs];
        }
        var gl = graphs.length;
        if (!gl) {
            return;
        }
        var graph0 = graphs[0];
        var nl = graph0.nodes.length;
        var groups = [];
        var sumSize = 0;
        for (var i = 0; i < nl; i++) {
            var g0node = graph0.nodes[i];
            var group = {
                size: 0,
                subGroups: [],
                node: g0node
            };
            groups.push(group);
            var sumWeight = 0;
            for (var k = 0; k < graphs.length; k++) {
                var graph = graphs[k];
                var node = graph.getNodeById(g0node.id);
                if (!node) {
                    continue;
                }
                group.size += node.layout.size;
                var edges = this.directed ? node.outEdges : node.edges;
                for (var j = 0; j < edges.length; j++) {
                    var e = edges[j];
                    var w = e.layout.weight;
                    group.subGroups.push({
                        weight: w,
                        edge: e,
                        graph: graph
                    });
                    sumWeight += w;
                }
            }
            sumSize += group.size;
            var multiplier = group.size / sumWeight;
            for (var j = 0; j < group.subGroups.length; j++) {
                group.subGroups[j].weight *= multiplier;
            }
            if (this.sortSub === 'ascending') {
                group.subGroups.sort(compareSubGroups);
            } else if (this.sort === 'descending') {
                group.subGroups.sort(compareSubGroups);
                group.subGroups.reverse();
            }
        }
        if (this.sort === 'ascending') {
            groups.sort(compareGroups);
        } else if (this.sort === 'descending') {
            groups.sort(compareGroups);
            groups.reverse();
        }
        var multiplier = (Math.PI * 2 - this.padding * nl) / sumSize;
        var angle = this.startAngle;
        var sign = this.clockWise ? 1 : -1;
        for (var i = 0; i < nl; i++) {
            var group = groups[i];
            group.node.layout.startAngle = angle;
            group.node.layout.endAngle = angle + sign * group.size * multiplier;
            group.node.layout.subGroups = [];
            for (var j = 0; j < group.subGroups.length; j++) {
                var subGroup = group.subGroups[j];
                subGroup.edge.layout.startAngle = angle;
                angle += sign * subGroup.weight * multiplier;
                subGroup.edge.layout.endAngle = angle;
            }
            angle = group.node.layout.endAngle + sign * this.padding;
        }
    };
    var compareSubGroups = function (a, b) {
        return a.weight - b.weight;
    };
    var compareGroups = function (a, b) {
        return a.size - b.size;
    };
    return ChordLayout;
});define('echarts/chart/force', [
    'require',
    './base',
    '../data/Graph',
    '../layout/Force',
    'zrender/shape/Line',
    'zrender/shape/BezierCurve',
    'zrender/shape/Image',
    '../util/shape/Icon',
    '../config',
    '../util/ecData',
    'zrender/tool/util',
    'zrender/config',
    'zrender/tool/vector',
    '../chart'
], function (require) {
    'use strict';
    var ChartBase = require('./base');
    var Graph = require('../data/Graph');
    var ForceLayout = require('../layout/Force');
    var LineShape = require('zrender/shape/Line');
    var BezierCurveShape = require('zrender/shape/BezierCurve');
    var ImageShape = require('zrender/shape/Image');
    var IconShape = require('../util/shape/Icon');
    var ecConfig = require('../config');
    ecConfig.force = {
        zlevel: 1,
        z: 2,
        center: [
            '50%',
            '50%'
        ],
        size: '100%',
        preventOverlap: false,
        coolDown: 0.99,
        minRadius: 10,
        maxRadius: 20,
        ratioScaling: false,
        large: false,
        useWorker: false,
        steps: 1,
        scaling: 1,
        gravity: 1,
        symbol: 'circle',
        symbolSize: 0,
        linkSymbol: null,
        linkSymbolSize: [
            10,
            15
        ],
        draggable: true,
        clickable: true,
        roam: false,
        itemStyle: {
            normal: {
                label: {
                    show: false,
                    position: 'inside'
                },
                nodeStyle: {
                    brushType: 'both',
                    borderColor: '#5182ab',
                    borderWidth: 1
                },
                linkStyle: {
                    color: '#5182ab',
                    width: 1,
                    type: 'line'
                }
            },
            emphasis: {
                label: { show: false },
                nodeStyle: {},
                linkStyle: { opacity: 0 }
            }
        }
    };
    var ecData = require('../util/ecData');
    var zrUtil = require('zrender/tool/util');
    var zrConfig = require('zrender/config');
    var vec2 = require('zrender/tool/vector');
    function Force(ecTheme, messageCenter, zr, option, myChart) {
        var self = this;
        ChartBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.__nodePositionMap = {};
        this._graph = new Graph(true);
        this._layout = new ForceLayout();
        this._layout.onupdate = function () {
            self._step();
        };
        this._steps = 1;
        this.ondragstart = function () {
            ondragstart.apply(self, arguments);
        };
        this.ondragend = function () {
            ondragend.apply(self, arguments);
        };
        this.ondrop = function () {
        };
        this.shapeHandler.ondragstart = function () {
            self.isDragstart = true;
        };
        this.onmousemove = function () {
            onmousemove.apply(self, arguments);
        };
        this.refresh(option);
    }
    Force.prototype = {
        constructor: Force,
        type: ecConfig.CHART_TYPE_FORCE,
        _init: function () {
            var legend = this.component.legend;
            var series = this.series;
            var serieName;
            this.clear();
            for (var i = 0, l = series.length; i < l; i++) {
                var serie = series[i];
                if (serie.type === ecConfig.CHART_TYPE_FORCE) {
                    series[i] = this.reformOption(series[i]);
                    serieName = series[i].name || '';
                    this.selectedMap[serieName] = legend ? legend.isSelected(serieName) : true;
                    if (!this.selectedMap[serieName]) {
                        continue;
                    }
                    this.buildMark(i);
                    this._initSerie(serie, i);
                    break;
                }
            }
            this.animationEffect();
        },
        _getNodeCategory: function (serie, node) {
            return serie.categories && serie.categories[node.category || 0];
        },
        _getNodeQueryTarget: function (serie, node, type) {
            type = type || 'normal';
            var category = this._getNodeCategory(serie, node) || {};
            return [
                node.itemStyle && node.itemStyle[type],
                category && category.itemStyle && category.itemStyle[type],
                serie.itemStyle[type].nodeStyle
            ];
        },
        _getEdgeQueryTarget: function (serie, edge, type) {
            type = type || 'normal';
            return [
                edge.itemStyle && edge.itemStyle[type],
                serie.itemStyle[type].linkStyle
            ];
        },
        _initSerie: function (serie, serieIdx) {
            this._temperature = 1;
            if (serie.data) {
                this._graph = this._getSerieGraphFromDataMatrix(serie);
            } else {
                this._graph = this._getSerieGraphFromNodeLinks(serie);
            }
            this._buildLinkShapes(serie, serieIdx);
            this._buildNodeShapes(serie, serieIdx);
            var panable = serie.roam === true || serie.roam === 'move';
            var zoomable = serie.roam === true || serie.roam === 'scale';
            this.zr.modLayer(this.getZlevelBase(), {
                panable: panable,
                zoomable: zoomable
            });
            if (this.query('markPoint.effect.show') || this.query('markLine.effect.show')) {
                this.zr.modLayer(ecConfig.EFFECT_ZLEVEL, {
                    panable: panable,
                    zoomable: zoomable
                });
            }
            this._initLayout(serie);
            this._step();
        },
        _getSerieGraphFromDataMatrix: function (serie) {
            var nodesData = [];
            var count = 0;
            var matrix = [];
            for (var i = 0; i < serie.matrix.length; i++) {
                matrix[i] = serie.matrix[i].slice();
            }
            var data = serie.data || serie.nodes;
            for (var i = 0; i < data.length; i++) {
                var node = {};
                var group = data[i];
                for (var key in group) {
                    if (key === 'name') {
                        node['id'] = group['name'];
                    } else {
                        node[key] = group[key];
                    }
                }
                var category = this._getNodeCategory(serie, group);
                var name = category ? category.name : group.name;
                this.selectedMap[name] = this.isSelected(name);
                if (this.selectedMap[name]) {
                    nodesData.push(node);
                    count++;
                } else {
                    matrix.splice(count, 1);
                    for (var j = 0; j < matrix.length; j++) {
                        matrix[j].splice(count, 1);
                    }
                }
            }
            var graph = Graph.fromMatrix(nodesData, matrix, true);
            graph.eachNode(function (n, idx) {
                n.layout = {
                    size: n.data.value,
                    mass: 0
                };
                n.rawIndex = idx;
            });
            graph.eachEdge(function (e) {
                e.layout = { weight: e.data.weight };
            });
            return graph;
        },
        _getSerieGraphFromNodeLinks: function (serie) {
            var graph = new Graph(true);
            var nodes = serie.data || serie.nodes;
            for (var i = 0, len = nodes.length; i < len; i++) {
                var n = nodes[i];
                if (!n || n.ignore) {
                    continue;
                }
                var category = this._getNodeCategory(serie, n);
                var name = category ? category.name : n.name;
                this.selectedMap[name] = this.isSelected(name);
                if (this.selectedMap[name]) {
                    var node = graph.addNode(n.name, n);
                    node.rawIndex = i;
                }
            }
            for (var i = 0, len = serie.links.length; i < len; i++) {
                var e = serie.links[i];
                var n1 = e.source;
                var n2 = e.target;
                if (typeof n1 === 'number') {
                    n1 = nodes[n1];
                    if (n1) {
                        n1 = n1.name;
                    }
                }
                if (typeof n2 === 'number') {
                    n2 = nodes[n2];
                    if (n2) {
                        n2 = n2.name;
                    }
                }
                var edge = graph.addEdge(n1, n2, e);
                if (edge) {
                    edge.rawIndex = i;
                }
            }
            graph.eachNode(function (n) {
                var value = n.data.value;
                if (value == null) {
                    value = 0;
                    for (var i = 0; i < n.edges.length; i++) {
                        value += n.edges[i].data.weight || 0;
                    }
                }
                n.layout = {
                    size: value,
                    mass: 0
                };
            });
            graph.eachEdge(function (e) {
                e.layout = { weight: e.data.weight == null ? 1 : e.data.weight };
            });
            return graph;
        },
        _initLayout: function (serie) {
            var graph = this._graph;
            var len = graph.nodes.length;
            var minRadius = this.query(serie, 'minRadius');
            var maxRadius = this.query(serie, 'maxRadius');
            this._steps = serie.steps || 1;
            this._layout.center = this.parseCenter(this.zr, serie.center);
            this._layout.width = this.parsePercent(serie.size, this.zr.getWidth());
            this._layout.height = this.parsePercent(serie.size, this.zr.getHeight());
            this._layout.large = serie.large;
            this._layout.scaling = serie.scaling;
            this._layout.ratioScaling = serie.ratioScaling;
            this._layout.gravity = serie.gravity;
            this._layout.temperature = 1;
            this._layout.coolDown = serie.coolDown;
            this._layout.preventNodeEdgeOverlap = serie.preventOverlap;
            this._layout.preventNodeOverlap = serie.preventOverlap;
            var min = Infinity;
            var max = -Infinity;
            for (var i = 0; i < len; i++) {
                var gNode = graph.nodes[i];
                max = Math.max(gNode.layout.size, max);
                min = Math.min(gNode.layout.size, min);
            }
            var divider = max - min;
            for (var i = 0; i < len; i++) {
                var gNode = graph.nodes[i];
                if (divider > 0) {
                    gNode.layout.size = (gNode.layout.size - min) * (maxRadius - minRadius) / divider + minRadius;
                    gNode.layout.mass = gNode.layout.size / maxRadius;
                } else {
                    gNode.layout.size = (maxRadius - minRadius) / 2;
                    gNode.layout.mass = 0.5;
                }
            }
            for (var i = 0; i < len; i++) {
                var gNode = graph.nodes[i];
                if (typeof this.__nodePositionMap[gNode.id] !== 'undefined') {
                    gNode.layout.position = vec2.create();
                    vec2.copy(gNode.layout.position, this.__nodePositionMap[gNode.id]);
                } else if (typeof gNode.data.initial !== 'undefined') {
                    gNode.layout.position = vec2.create();
                    vec2.copy(gNode.layout.position, gNode.data.initial);
                } else {
                    var center = this._layout.center;
                    var size = Math.min(this._layout.width, this._layout.height);
                    gNode.layout.position = _randomInSquare(center[0], center[1], size * 0.8);
                }
                var style = gNode.shape.style;
                var radius = gNode.layout.size;
                style.width = style.width || radius * 2;
                style.height = style.height || radius * 2;
                style.x = -style.width / 2;
                style.y = -style.height / 2;
                vec2.copy(gNode.shape.position, gNode.layout.position);
            }
            len = graph.edges.length;
            max = -Infinity;
            for (var i = 0; i < len; i++) {
                var e = graph.edges[i];
                if (e.layout.weight > max) {
                    max = e.layout.weight;
                }
            }
            for (var i = 0; i < len; i++) {
                var e = graph.edges[i];
                e.layout.weight /= max;
            }
            this._layout.init(graph, serie.useWorker);
        },
        _buildNodeShapes: function (serie, serieIdx) {
            var graph = this._graph;
            var categories = this.query(serie, 'categories');
            graph.eachNode(function (node) {
                var category = this._getNodeCategory(serie, node.data);
                var queryTarget = [
                    node.data,
                    category,
                    serie
                ];
                var styleQueryTarget = this._getNodeQueryTarget(serie, node.data);
                var emphasisStyleQueryTarget = this._getNodeQueryTarget(serie, node.data, 'emphasis');
                var shape = new IconShape({
                    style: {
                        x: 0,
                        y: 0,
                        color: this.deepQuery(styleQueryTarget, 'color'),
                        brushType: 'both',
                        strokeColor: this.deepQuery(styleQueryTarget, 'strokeColor') || this.deepQuery(styleQueryTarget, 'borderColor'),
                        lineWidth: this.deepQuery(styleQueryTarget, 'lineWidth') || this.deepQuery(styleQueryTarget, 'borderWidth')
                    },
                    highlightStyle: {
                        color: this.deepQuery(emphasisStyleQueryTarget, 'color'),
                        strokeColor: this.deepQuery(emphasisStyleQueryTarget, 'strokeColor') || this.deepQuery(emphasisStyleQueryTarget, 'borderColor'),
                        lineWidth: this.deepQuery(emphasisStyleQueryTarget, 'lineWidth') || this.deepQuery(emphasisStyleQueryTarget, 'borderWidth')
                    },
                    clickable: serie.clickable,
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase()
                });
                if (!shape.style.color) {
                    shape.style.color = category ? this.getColor(category.name) : this.getColor(node.id);
                }
                shape.style.iconType = this.deepQuery(queryTarget, 'symbol');
                shape.style.width = shape.style.height = (this.deepQuery(queryTarget, 'symbolSize') || 0) * 2;
                if (shape.style.iconType.match('image')) {
                    shape.style.image = shape.style.iconType.replace(new RegExp('^image:\\/\\/'), '');
                    shape = new ImageShape({
                        style: shape.style,
                        highlightStyle: shape.highlightStyle,
                        clickable: shape.clickable,
                        zlevel: this.getZlevelBase(),
                        z: this.getZBase()
                    });
                }
                if (this.deepQuery(queryTarget, 'itemStyle.normal.label.show')) {
                    shape.style.text = node.data.label == null ? node.id : node.data.label;
                    shape.style.textPosition = this.deepQuery(queryTarget, 'itemStyle.normal.label.position');
                    shape.style.textColor = this.deepQuery(queryTarget, 'itemStyle.normal.label.textStyle.color');
                    shape.style.textFont = this.getFont(this.deepQuery(queryTarget, 'itemStyle.normal.label.textStyle') || {});
                }
                if (this.deepQuery(queryTarget, 'itemStyle.emphasis.label.show')) {
                    shape.highlightStyle.textPosition = this.deepQuery(queryTarget, 'itemStyle.emphasis.label.position');
                    shape.highlightStyle.textColor = this.deepQuery(queryTarget, 'itemStyle.emphasis.label.textStyle.color');
                    shape.highlightStyle.textFont = this.getFont(this.deepQuery(queryTarget, 'itemStyle.emphasis.label.textStyle') || {});
                }
                if (this.deepQuery(queryTarget, 'draggable')) {
                    this.setCalculable(shape);
                    shape.dragEnableTime = 0;
                    shape.draggable = true;
                    shape.ondragstart = this.shapeHandler.ondragstart;
                    shape.ondragover = null;
                }
                var categoryName = '';
                if (typeof node.category !== 'undefined') {
                    var category = categories[node.category];
                    categoryName = category && category.name || '';
                }
                ecData.pack(shape, serie, serieIdx, node.data, node.rawIndex, node.data.name || '', node.category);
                this.shapeList.push(shape);
                this.zr.addShape(shape);
                node.shape = shape;
            }, this);
        },
        _buildLinkShapes: function (serie, serieIdx) {
            var graph = this._graph;
            var len = graph.edges.length;
            for (var i = 0; i < len; i++) {
                var gEdge = graph.edges[i];
                var link = gEdge.data;
                var source = gEdge.node1;
                var target = gEdge.node2;
                var otherEdge = graph.getEdge(target, source);
                var queryTarget = this._getEdgeQueryTarget(serie, link);
                var linkType = this.deepQuery(queryTarget, 'type');
                if (serie.linkSymbol && serie.linkSymbol !== 'none') {
                    linkType = 'line';
                }
                var LinkShapeCtor = linkType === 'line' ? LineShape : BezierCurveShape;
                var linkShape = new LinkShapeCtor({
                    style: {
                        xStart: 0,
                        yStart: 0,
                        xEnd: 0,
                        yEnd: 0
                    },
                    clickable: this.query(serie, 'clickable'),
                    highlightStyle: {},
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase()
                });
                if (otherEdge && otherEdge.shape) {
                    linkShape.style.offset = 4;
                    otherEdge.shape.style.offset = 4;
                }
                zrUtil.merge(linkShape.style, this.query(serie, 'itemStyle.normal.linkStyle'), true);
                zrUtil.merge(linkShape.highlightStyle, this.query(serie, 'itemStyle.emphasis.linkStyle'), true);
                if (typeof link.itemStyle !== 'undefined') {
                    if (link.itemStyle.normal) {
                        zrUtil.merge(linkShape.style, link.itemStyle.normal, true);
                    }
                    if (link.itemStyle.emphasis) {
                        zrUtil.merge(linkShape.highlightStyle, link.itemStyle.emphasis, true);
                    }
                }
                linkShape.style.lineWidth = linkShape.style.lineWidth || linkShape.style.width;
                linkShape.style.strokeColor = linkShape.style.strokeColor || linkShape.style.color;
                linkShape.highlightStyle.lineWidth = linkShape.highlightStyle.lineWidth || linkShape.highlightStyle.width;
                linkShape.highlightStyle.strokeColor = linkShape.highlightStyle.strokeColor || linkShape.highlightStyle.color;
                ecData.pack(linkShape, serie, serieIdx, gEdge.data, gEdge.rawIndex == null ? i : gEdge.rawIndex, gEdge.data.name || source.id + ' - ' + target.id, source.id, target.id);
                this.shapeList.push(linkShape);
                this.zr.addShape(linkShape);
                gEdge.shape = linkShape;
                if (serie.linkSymbol && serie.linkSymbol !== 'none') {
                    var symbolShape = new IconShape({
                        style: {
                            x: -5,
                            y: 0,
                            width: serie.linkSymbolSize[0],
                            height: serie.linkSymbolSize[1],
                            iconType: serie.linkSymbol,
                            brushType: 'fill',
                            color: linkShape.style.strokeColor
                        },
                        highlightStyle: { brushType: 'fill' },
                        position: [
                            0,
                            0
                        ],
                        rotation: 0
                    });
                    linkShape._symbolShape = symbolShape;
                    this.shapeList.push(symbolShape);
                    this.zr.addShape(symbolShape);
                }
            }
        },
        _updateLinkShapes: function () {
            var v = vec2.create();
            var n = vec2.create();
            var p1 = vec2.create();
            var p2 = vec2.create();
            var edges = this._graph.edges;
            for (var i = 0, len = edges.length; i < len; i++) {
                var edge = edges[i];
                var sourceShape = edge.node1.shape;
                var targetShape = edge.node2.shape;
                vec2.copy(p1, sourceShape.position);
                vec2.copy(p2, targetShape.position);
                var edgeShapeStyle = edge.shape.style;
                vec2.sub(v, p1, p2);
                vec2.normalize(v, v);
                if (edgeShapeStyle.offset) {
                    n[0] = v[1];
                    n[1] = -v[0];
                    vec2.scaleAndAdd(p1, p1, n, edgeShapeStyle.offset);
                    vec2.scaleAndAdd(p2, p2, n, edgeShapeStyle.offset);
                } else if (edge.shape.type === 'bezier-curve') {
                    edgeShapeStyle.cpX1 = (p1[0] + p2[0]) / 2 - (p2[1] - p1[1]) / 4;
                    edgeShapeStyle.cpY1 = (p1[1] + p2[1]) / 2 - (p1[0] - p2[0]) / 4;
                }
                edgeShapeStyle.xStart = p1[0];
                edgeShapeStyle.yStart = p1[1];
                edgeShapeStyle.xEnd = p2[0];
                edgeShapeStyle.yEnd = p2[1];
                edge.shape.modSelf();
                if (edge.shape._symbolShape) {
                    var symbolShape = edge.shape._symbolShape;
                    vec2.copy(symbolShape.position, p2);
                    vec2.scaleAndAdd(symbolShape.position, symbolShape.position, v, targetShape.style.width / 2 + 2);
                    var angle = Math.atan2(v[1], v[0]);
                    symbolShape.rotation = Math.PI / 2 - angle;
                    symbolShape.modSelf();
                }
            }
        },
        _syncNodePositions: function () {
            var graph = this._graph;
            for (var i = 0; i < graph.nodes.length; i++) {
                var gNode = graph.nodes[i];
                var position = gNode.layout.position;
                var node = gNode.data;
                var shape = gNode.shape;
                var fixX = shape.fixed || node.fixX;
                var fixY = shape.fixed || node.fixY;
                if (fixX === true) {
                    fixX = 1;
                } else if (isNaN(fixX)) {
                    fixX = 0;
                }
                if (fixY === true) {
                    fixY = 1;
                } else if (isNaN(fixY)) {
                    fixY = 0;
                }
                shape.position[0] += (position[0] - shape.position[0]) * (1 - fixX);
                shape.position[1] += (position[1] - shape.position[1]) * (1 - fixY);
                vec2.copy(position, shape.position);
                var nodeName = node.name;
                if (nodeName) {
                    var gPos = this.__nodePositionMap[nodeName];
                    if (!gPos) {
                        gPos = this.__nodePositionMap[nodeName] = vec2.create();
                    }
                    vec2.copy(gPos, position);
                }
                shape.modSelf();
            }
        },
        _step: function (e) {
            this._syncNodePositions();
            this._updateLinkShapes();
            this.zr.refreshNextFrame();
            if (this._layout.temperature > 0.01) {
                this._layout.step(this._steps);
            } else {
                this.messageCenter.dispatch(ecConfig.EVENT.FORCE_LAYOUT_END, {}, {}, this.myChart);
            }
        },
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.series = this.option.series;
            }
            this.legend = this.component.legend;
            if (this.legend) {
                this.getColor = function (param) {
                    return this.legend.getColor(param);
                };
                this.isSelected = function (param) {
                    return this.legend.isSelected(param);
                };
            } else {
                var colorMap = {};
                var count = 0;
                this.getColor = function (key) {
                    if (colorMap[key]) {
                        return colorMap[key];
                    }
                    if (!colorMap[key]) {
                        colorMap[key] = this.zr.getColor(count++);
                    }
                    return colorMap[key];
                };
                this.isSelected = function () {
                    return true;
                };
            }
            this._init();
        },
        dispose: function () {
            this.clear();
            this.shapeList = null;
            this.effectList = null;
            this._layout.dispose();
            this._layout = null;
            this.__nodePositionMap = {};
        },
        getPosition: function () {
            var position = [];
            this._graph.eachNode(function (n) {
                if (n.layout) {
                    position.push({
                        name: n.data.name,
                        position: Array.prototype.slice.call(n.layout.position)
                    });
                }
            });
            return position;
        }
    };
    function ondragstart(param) {
        if (!this.isDragstart || !param.target) {
            return;
        }
        var shape = param.target;
        shape.fixed = true;
        this.isDragstart = false;
        this.zr.on(zrConfig.EVENT.MOUSEMOVE, this.onmousemove);
    }
    function onmousemove() {
        this._layout.temperature = 0.8;
        this._step();
    }
    function ondragend(param, status) {
        if (!this.isDragend || !param.target) {
            return;
        }
        var shape = param.target;
        shape.fixed = false;
        status.dragIn = true;
        status.needRefresh = false;
        this.isDragend = false;
        this.zr.un(zrConfig.EVENT.MOUSEMOVE, this.onmousemove);
    }
    function _randomInSquare(x, y, size) {
        var v = vec2.create();
        v[0] = (Math.random() - 0.5) * size + x;
        v[1] = (Math.random() - 0.5) * size + y;
        return v;
    }
    zrUtil.inherits(Force, ChartBase);
    require('../chart').define('force', Force);
    return Force;
});define('echarts/layout/Force', [
    'require',
    './forceLayoutWorker',
    'zrender/tool/vector'
], function (require) {
    var ForceLayoutWorker = require('./forceLayoutWorker');
    var vec2 = require('zrender/tool/vector');
    var requestAnimationFrame = window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (func) {
        setTimeout(func, 16);
    };
    var ArrayCtor = typeof Float32Array == 'undefined' ? Array : Float32Array;
    var workerUrl;
    function createWorkerUrl() {
        if (typeof Worker !== 'undefined' && typeof Blob !== 'undefined') {
            try {
                var blob = new Blob([ForceLayoutWorker.getWorkerCode()]);
                workerUrl = window.URL.createObjectURL(blob);
            } catch (e) {
                workerUrl = '';
            }
        }
        return workerUrl;
    }
    var ForceLayout = function (opts) {
        if (typeof workerUrl === 'undefined') {
            createWorkerUrl();
        }
        opts = opts || {};
        this.width = opts.width || 500;
        this.height = opts.height || 500;
        this.center = opts.center || [
            this.width / 2,
            this.height / 2
        ];
        this.ratioScaling = opts.ratioScaling || false;
        this.scaling = opts.scaling || 1;
        this.gravity = typeof opts.gravity !== 'undefined' ? opts.gravity : 1;
        this.large = opts.large || false;
        this.preventNodeOverlap = opts.preventNodeOverlap || false;
        this.preventNodeEdgeOverlap = opts.preventNodeEdgeOverlap || false;
        this.maxSpeedIncrease = opts.maxSpeedIncrease || 1;
        this.onupdate = opts.onupdate || function () {
        };
        this.temperature = opts.temperature || 1;
        this.coolDown = opts.coolDown || 0.99;
        this._layout = null;
        this._layoutWorker = null;
        var self = this;
        var _$onupdate = this._$onupdate;
        this._$onupdate = function (e) {
            _$onupdate.call(self, e);
        };
    };
    ForceLayout.prototype.updateConfig = function () {
        var width = this.width;
        var height = this.height;
        var size = Math.min(width, height);
        var config = {
            center: this.center,
            width: this.ratioScaling ? width : size,
            height: this.ratioScaling ? height : size,
            scaling: this.scaling || 1,
            gravity: this.gravity || 1,
            barnesHutOptimize: this.large,
            preventNodeOverlap: this.preventNodeOverlap,
            preventNodeEdgeOverlap: this.preventNodeEdgeOverlap,
            maxSpeedIncrease: this.maxSpeedIncrease
        };
        if (this._layoutWorker) {
            this._layoutWorker.postMessage({
                cmd: 'updateConfig',
                config: config
            });
        } else {
            for (var name in config) {
                this._layout[name] = config[name];
            }
        }
    };
    ForceLayout.prototype.init = function (graph, useWorker) {
        if (this._layoutWorker) {
            this._layoutWorker.terminate();
            this._layoutWorker = null;
        }
        if (workerUrl && useWorker) {
            try {
                if (!this._layoutWorker) {
                    this._layoutWorker = new Worker(workerUrl);
                    this._layoutWorker.onmessage = this._$onupdate;
                }
                this._layout = null;
            } catch (e) {
                this._layoutWorker = null;
                if (!this._layout) {
                    this._layout = new ForceLayoutWorker();
                }
            }
        } else {
            if (!this._layout) {
                this._layout = new ForceLayoutWorker();
            }
        }
        this.temperature = 1;
        this.graph = graph;
        var len = graph.nodes.length;
        var positionArr = new ArrayCtor(len * 2);
        var massArr = new ArrayCtor(len);
        var sizeArr = new ArrayCtor(len);
        for (var i = 0; i < len; i++) {
            var n = graph.nodes[i];
            positionArr[i * 2] = n.layout.position[0];
            positionArr[i * 2 + 1] = n.layout.position[1];
            massArr[i] = typeof n.layout.mass === 'undefined' ? 1 : n.layout.mass;
            sizeArr[i] = typeof n.layout.size === 'undefined' ? 1 : n.layout.size;
            n.layout.__index = i;
        }
        len = graph.edges.length;
        var edgeArr = new ArrayCtor(len * 2);
        var edgeWeightArr = new ArrayCtor(len);
        for (var i = 0; i < len; i++) {
            var edge = graph.edges[i];
            edgeArr[i * 2] = edge.node1.layout.__index;
            edgeArr[i * 2 + 1] = edge.node2.layout.__index;
            edgeWeightArr[i] = edge.layout.weight || 1;
        }
        if (this._layoutWorker) {
            this._layoutWorker.postMessage({
                cmd: 'init',
                nodesPosition: positionArr,
                nodesMass: massArr,
                nodesSize: sizeArr,
                edges: edgeArr,
                edgesWeight: edgeWeightArr
            });
        } else {
            this._layout.initNodes(positionArr, massArr, sizeArr);
            this._layout.initEdges(edgeArr, edgeWeightArr);
        }
        this.updateConfig();
    };
    ForceLayout.prototype.step = function (steps) {
        var nodes = this.graph.nodes;
        if (this._layoutWorker) {
            var positionArr = new ArrayCtor(nodes.length * 2);
            for (var i = 0; i < nodes.length; i++) {
                var n = nodes[i];
                positionArr[i * 2] = n.layout.position[0];
                positionArr[i * 2 + 1] = n.layout.position[1];
            }
            this._layoutWorker.postMessage(positionArr.buffer, [positionArr.buffer]);
            this._layoutWorker.postMessage({
                cmd: 'update',
                steps: steps,
                temperature: this.temperature,
                coolDown: this.coolDown
            });
            for (var i = 0; i < steps; i++) {
                this.temperature *= this.coolDown;
            }
        } else {
            requestAnimationFrame(this._$onupdate);
            for (var i = 0; i < nodes.length; i++) {
                var n = nodes[i];
                vec2.copy(this._layout.nodes[i].position, n.layout.position);
            }
            for (var i = 0; i < steps; i++) {
                this._layout.temperature = this.temperature;
                this._layout.update();
                this.temperature *= this.coolDown;
            }
        }
    };
    ForceLayout.prototype._$onupdate = function (e) {
        if (this._layoutWorker) {
            var positionArr = new Float32Array(e.data);
            for (var i = 0; i < this.graph.nodes.length; i++) {
                var n = this.graph.nodes[i];
                n.layout.position[0] = positionArr[i * 2];
                n.layout.position[1] = positionArr[i * 2 + 1];
            }
            this.onupdate && this.onupdate();
        } else if (this._layout) {
            for (var i = 0; i < this.graph.nodes.length; i++) {
                var n = this.graph.nodes[i];
                vec2.copy(n.layout.position, this._layout.nodes[i].position);
            }
            this.onupdate && this.onupdate();
        }
    };
    ForceLayout.prototype.dispose = function () {
        if (this._layoutWorker) {
            this._layoutWorker.terminate();
        }
        this._layoutWorker = null;
        this._layout = null;
    };
    return ForceLayout;
});define('echarts/layout/forceLayoutWorker', [
    'require',
    'zrender/tool/vector'
], function __echartsForceLayoutWorker(require) {
    'use strict';
    var vec2;
    var inWorker = typeof window === 'undefined' && typeof require === 'undefined';
    if (inWorker) {
        vec2 = {
            create: function (x, y) {
                var out = new Float32Array(2);
                out[0] = x || 0;
                out[1] = y || 0;
                return out;
            },
            dist: function (a, b) {
                var x = b[0] - a[0];
                var y = b[1] - a[1];
                return Math.sqrt(x * x + y * y);
            },
            len: function (a) {
                var x = a[0];
                var y = a[1];
                return Math.sqrt(x * x + y * y);
            },
            scaleAndAdd: function (out, a, b, scale) {
                out[0] = a[0] + b[0] * scale;
                out[1] = a[1] + b[1] * scale;
                return out;
            },
            scale: function (out, a, b) {
                out[0] = a[0] * b;
                out[1] = a[1] * b;
                return out;
            },
            add: function (out, a, b) {
                out[0] = a[0] + b[0];
                out[1] = a[1] + b[1];
                return out;
            },
            sub: function (out, a, b) {
                out[0] = a[0] - b[0];
                out[1] = a[1] - b[1];
                return out;
            },
            dot: function (v1, v2) {
                return v1[0] * v2[0] + v1[1] * v2[1];
            },
            normalize: function (out, a) {
                var x = a[0];
                var y = a[1];
                var len = x * x + y * y;
                if (len > 0) {
                    len = 1 / Math.sqrt(len);
                    out[0] = a[0] * len;
                    out[1] = a[1] * len;
                }
                return out;
            },
            negate: function (out, a) {
                out[0] = -a[0];
                out[1] = -a[1];
                return out;
            },
            copy: function (out, a) {
                out[0] = a[0];
                out[1] = a[1];
                return out;
            },
            set: function (out, x, y) {
                out[0] = x;
                out[1] = y;
                return out;
            }
        };
    } else {
        vec2 = require('zrender/tool/vector');
    }
    var ArrayCtor = typeof Float32Array == 'undefined' ? Array : Float32Array;
    function Region() {
        this.subRegions = [];
        this.nSubRegions = 0;
        this.node = null;
        this.mass = 0;
        this.centerOfMass = null;
        this.bbox = new ArrayCtor(4);
        this.size = 0;
    }
    Region.prototype.beforeUpdate = function () {
        for (var i = 0; i < this.nSubRegions; i++) {
            this.subRegions[i].beforeUpdate();
        }
        this.mass = 0;
        if (this.centerOfMass) {
            this.centerOfMass[0] = 0;
            this.centerOfMass[1] = 0;
        }
        this.nSubRegions = 0;
        this.node = null;
    };
    Region.prototype.afterUpdate = function () {
        this.subRegions.length = this.nSubRegions;
        for (var i = 0; i < this.nSubRegions; i++) {
            this.subRegions[i].afterUpdate();
        }
    };
    Region.prototype.addNode = function (node) {
        if (this.nSubRegions === 0) {
            if (this.node == null) {
                this.node = node;
                return;
            } else {
                this._addNodeToSubRegion(this.node);
                this.node = null;
            }
        }
        this._addNodeToSubRegion(node);
        this._updateCenterOfMass(node);
    };
    Region.prototype.findSubRegion = function (x, y) {
        for (var i = 0; i < this.nSubRegions; i++) {
            var region = this.subRegions[i];
            if (region.contain(x, y)) {
                return region;
            }
        }
    };
    Region.prototype.contain = function (x, y) {
        return this.bbox[0] <= x && this.bbox[2] >= x && this.bbox[1] <= y && this.bbox[3] >= y;
    };
    Region.prototype.setBBox = function (minX, minY, maxX, maxY) {
        this.bbox[0] = minX;
        this.bbox[1] = minY;
        this.bbox[2] = maxX;
        this.bbox[3] = maxY;
        this.size = (maxX - minX + maxY - minY) / 2;
    };
    Region.prototype._newSubRegion = function () {
        var subRegion = this.subRegions[this.nSubRegions];
        if (!subRegion) {
            subRegion = new Region();
            this.subRegions[this.nSubRegions] = subRegion;
        }
        this.nSubRegions++;
        return subRegion;
    };
    Region.prototype._addNodeToSubRegion = function (node) {
        var subRegion = this.findSubRegion(node.position[0], node.position[1]);
        var bbox = this.bbox;
        if (!subRegion) {
            var cx = (bbox[0] + bbox[2]) / 2;
            var cy = (bbox[1] + bbox[3]) / 2;
            var w = (bbox[2] - bbox[0]) / 2;
            var h = (bbox[3] - bbox[1]) / 2;
            var xi = node.position[0] >= cx ? 1 : 0;
            var yi = node.position[1] >= cy ? 1 : 0;
            var subRegion = this._newSubRegion();
            subRegion.setBBox(xi * w + bbox[0], yi * h + bbox[1], (xi + 1) * w + bbox[0], (yi + 1) * h + bbox[1]);
        }
        subRegion.addNode(node);
    };
    Region.prototype._updateCenterOfMass = function (node) {
        if (this.centerOfMass == null) {
            this.centerOfMass = vec2.create();
        }
        var x = this.centerOfMass[0] * this.mass;
        var y = this.centerOfMass[1] * this.mass;
        x += node.position[0] * node.mass;
        y += node.position[1] * node.mass;
        this.mass += node.mass;
        this.centerOfMass[0] = x / this.mass;
        this.centerOfMass[1] = y / this.mass;
    };
    function GraphNode() {
        this.position = vec2.create();
        this.force = vec2.create();
        this.forcePrev = vec2.create();
        this.speed = vec2.create();
        this.speedPrev = vec2.create();
        this.mass = 1;
        this.inDegree = 0;
        this.outDegree = 0;
    }
    function GraphEdge(node1, node2) {
        this.node1 = node1;
        this.node2 = node2;
        this.weight = 1;
    }
    function ForceLayout() {
        this.barnesHutOptimize = false;
        this.barnesHutTheta = 1.5;
        this.repulsionByDegree = false;
        this.preventNodeOverlap = false;
        this.preventNodeEdgeOverlap = false;
        this.strongGravity = true;
        this.gravity = 1;
        this.scaling = 1;
        this.edgeWeightInfluence = 1;
        this.center = [
            0,
            0
        ];
        this.width = 500;
        this.height = 500;
        this.maxSpeedIncrease = 1;
        this.nodes = [];
        this.edges = [];
        this.bbox = new ArrayCtor(4);
        this._rootRegion = new Region();
        this._rootRegion.centerOfMass = vec2.create();
        this._massArr = null;
        this._k = 0;
    }
    ForceLayout.prototype.nodeToNodeRepulsionFactor = function (mass, d, k) {
        return k * k * mass / d;
    };
    ForceLayout.prototype.edgeToNodeRepulsionFactor = function (mass, d, k) {
        return k * mass / d;
    };
    ForceLayout.prototype.attractionFactor = function (w, d, k) {
        return w * d / k;
    };
    ForceLayout.prototype.initNodes = function (positionArr, massArr, sizeArr) {
        this.temperature = 1;
        var nNodes = positionArr.length / 2;
        this.nodes.length = 0;
        var haveSize = typeof sizeArr !== 'undefined';
        for (var i = 0; i < nNodes; i++) {
            var node = new GraphNode();
            node.position[0] = positionArr[i * 2];
            node.position[1] = positionArr[i * 2 + 1];
            node.mass = massArr[i];
            if (haveSize) {
                node.size = sizeArr[i];
            }
            this.nodes.push(node);
        }
        this._massArr = massArr;
        if (haveSize) {
            this._sizeArr = sizeArr;
        }
    };
    ForceLayout.prototype.initEdges = function (edgeArr, edgeWeightArr) {
        var nEdges = edgeArr.length / 2;
        this.edges.length = 0;
        var edgeHaveWeight = typeof edgeWeightArr !== 'undefined';
        for (var i = 0; i < nEdges; i++) {
            var sIdx = edgeArr[i * 2];
            var tIdx = edgeArr[i * 2 + 1];
            var sNode = this.nodes[sIdx];
            var tNode = this.nodes[tIdx];
            if (!sNode || !tNode) {
                continue;
            }
            sNode.outDegree++;
            tNode.inDegree++;
            var edge = new GraphEdge(sNode, tNode);
            if (edgeHaveWeight) {
                edge.weight = edgeWeightArr[i];
            }
            this.edges.push(edge);
        }
    };
    ForceLayout.prototype.update = function () {
        var nNodes = this.nodes.length;
        this.updateBBox();
        this._k = 0.4 * this.scaling * Math.sqrt(this.width * this.height / nNodes);
        if (this.barnesHutOptimize) {
            this._rootRegion.setBBox(this.bbox[0], this.bbox[1], this.bbox[2], this.bbox[3]);
            this._rootRegion.beforeUpdate();
            for (var i = 0; i < nNodes; i++) {
                this._rootRegion.addNode(this.nodes[i]);
            }
            this._rootRegion.afterUpdate();
        } else {
            var mass = 0;
            var centerOfMass = this._rootRegion.centerOfMass;
            vec2.set(centerOfMass, 0, 0);
            for (var i = 0; i < nNodes; i++) {
                var node = this.nodes[i];
                mass += node.mass;
                vec2.scaleAndAdd(centerOfMass, centerOfMass, node.position, node.mass);
            }
            if (mass > 0) {
                vec2.scale(centerOfMass, centerOfMass, 1 / mass);
            }
        }
        this.updateForce();
        this.updatePosition();
    };
    ForceLayout.prototype.updateForce = function () {
        var nNodes = this.nodes.length;
        for (var i = 0; i < nNodes; i++) {
            var node = this.nodes[i];
            vec2.copy(node.forcePrev, node.force);
            vec2.copy(node.speedPrev, node.speed);
            vec2.set(node.force, 0, 0);
        }
        this.updateNodeNodeForce();
        if (this.gravity > 0) {
            this.updateGravityForce();
        }
        this.updateEdgeForce();
        if (this.preventNodeEdgeOverlap) {
            this.updateNodeEdgeForce();
        }
    };
    ForceLayout.prototype.updatePosition = function () {
        var nNodes = this.nodes.length;
        var v = vec2.create();
        for (var i = 0; i < nNodes; i++) {
            var node = this.nodes[i];
            var speed = node.speed;
            vec2.scale(node.force, node.force, 1 / 30);
            var df = vec2.len(node.force) + 0.1;
            var scale = Math.min(df, 500) / df;
            vec2.scale(node.force, node.force, scale);
            vec2.add(speed, speed, node.force);
            vec2.scale(speed, speed, this.temperature);
            vec2.sub(v, speed, node.speedPrev);
            var swing = vec2.len(v);
            if (swing > 0) {
                vec2.scale(v, v, 1 / swing);
                var base = vec2.len(node.speedPrev);
                if (base > 0) {
                    swing = Math.min(swing / base, this.maxSpeedIncrease) * base;
                    vec2.scaleAndAdd(speed, node.speedPrev, v, swing);
                }
            }
            var ds = vec2.len(speed);
            var scale = Math.min(ds, 100) / (ds + 0.1);
            vec2.scale(speed, speed, scale);
            vec2.add(node.position, node.position, speed);
        }
    };
    ForceLayout.prototype.updateNodeNodeForce = function () {
        var nNodes = this.nodes.length;
        for (var i = 0; i < nNodes; i++) {
            var na = this.nodes[i];
            if (this.barnesHutOptimize) {
                this.applyRegionToNodeRepulsion(this._rootRegion, na);
            } else {
                for (var j = i + 1; j < nNodes; j++) {
                    var nb = this.nodes[j];
                    this.applyNodeToNodeRepulsion(na, nb, false);
                }
            }
        }
    };
    ForceLayout.prototype.updateGravityForce = function () {
        for (var i = 0; i < this.nodes.length; i++) {
            this.applyNodeGravity(this.nodes[i]);
        }
    };
    ForceLayout.prototype.updateEdgeForce = function () {
        for (var i = 0; i < this.edges.length; i++) {
            this.applyEdgeAttraction(this.edges[i]);
        }
    };
    ForceLayout.prototype.updateNodeEdgeForce = function () {
        for (var i = 0; i < this.nodes.length; i++) {
            for (var j = 0; j < this.edges.length; j++) {
                this.applyEdgeToNodeRepulsion(this.edges[j], this.nodes[i]);
            }
        }
    };
    ForceLayout.prototype.applyRegionToNodeRepulsion = function () {
        var v = vec2.create();
        return function applyRegionToNodeRepulsion(region, node) {
            if (region.node) {
                this.applyNodeToNodeRepulsion(region.node, node, true);
            } else {
                if (region.mass === 0 && node.mass === 0) {
                    return;
                }
                vec2.sub(v, node.position, region.centerOfMass);
                var d2 = v[0] * v[0] + v[1] * v[1];
                if (d2 > this.barnesHutTheta * region.size * region.size) {
                    var factor = this._k * this._k * (node.mass + region.mass) / (d2 + 1);
                    vec2.scaleAndAdd(node.force, node.force, v, factor * 2);
                } else {
                    for (var i = 0; i < region.nSubRegions; i++) {
                        this.applyRegionToNodeRepulsion(region.subRegions[i], node);
                    }
                }
            }
        };
    }();
    ForceLayout.prototype.applyNodeToNodeRepulsion = function () {
        var v = vec2.create();
        return function applyNodeToNodeRepulsion(na, nb, oneWay) {
            if (na === nb) {
                return;
            }
            if (na.mass === 0 && nb.mass === 0) {
                return;
            }
            vec2.sub(v, na.position, nb.position);
            var d2 = v[0] * v[0] + v[1] * v[1];
            if (d2 === 0) {
                return;
            }
            var factor;
            var mass = na.mass + nb.mass;
            var d = Math.sqrt(d2);
            vec2.scale(v, v, 1 / d);
            if (this.preventNodeOverlap) {
                d = d - na.size - nb.size;
                if (d > 0) {
                    factor = this.nodeToNodeRepulsionFactor(mass, d, this._k);
                } else if (d <= 0) {
                    factor = this._k * this._k * 10 * mass;
                }
            } else {
                factor = this.nodeToNodeRepulsionFactor(mass, d, this._k);
            }
            if (!oneWay) {
                vec2.scaleAndAdd(na.force, na.force, v, factor * 2);
            }
            vec2.scaleAndAdd(nb.force, nb.force, v, -factor * 2);
        };
    }();
    ForceLayout.prototype.applyEdgeAttraction = function () {
        var v = vec2.create();
        return function applyEdgeAttraction(edge) {
            var na = edge.node1;
            var nb = edge.node2;
            vec2.sub(v, na.position, nb.position);
            var d = vec2.len(v);
            var w;
            if (this.edgeWeightInfluence === 0) {
                w = 1;
            } else if (this.edgeWeightInfluence == 1) {
                w = edge.weight;
            } else {
                w = Math.pow(edge.weight, this.edgeWeightInfluence);
            }
            var factor;
            if (this.preventOverlap) {
                d = d - na.size - nb.size;
                if (d <= 0) {
                    return;
                }
            }
            var factor = this.attractionFactor(w, d, this._k);
            vec2.scaleAndAdd(na.force, na.force, v, -factor);
            vec2.scaleAndAdd(nb.force, nb.force, v, factor);
        };
    }();
    ForceLayout.prototype.applyNodeGravity = function () {
        var v = vec2.create();
        return function (node) {
            vec2.sub(v, this.center, node.position);
            if (this.width > this.height) {
                v[1] *= this.width / this.height;
            } else {
                v[0] *= this.height / this.width;
            }
            var d = vec2.len(v) / 100;
            if (this.strongGravity) {
                vec2.scaleAndAdd(node.force, node.force, v, d * this.gravity * node.mass);
            } else {
                vec2.scaleAndAdd(node.force, node.force, v, this.gravity * node.mass / (d + 1));
            }
        };
    }();
    ForceLayout.prototype.applyEdgeToNodeRepulsion = function () {
        var v12 = vec2.create();
        var v13 = vec2.create();
        var p = vec2.create();
        return function (e, n3) {
            var n1 = e.node1;
            var n2 = e.node2;
            if (n1 === n3 || n2 === n3) {
                return;
            }
            vec2.sub(v12, n2.position, n1.position);
            vec2.sub(v13, n3.position, n1.position);
            var len12 = vec2.len(v12);
            vec2.scale(v12, v12, 1 / len12);
            var len = vec2.dot(v12, v13);
            if (len < 0 || len > len12) {
                return;
            }
            vec2.scaleAndAdd(p, n1.position, v12, len);
            var dist = vec2.dist(p, n3.position) - n3.size;
            var factor = this.edgeToNodeRepulsionFactor(n3.mass, Math.max(dist, 0.1), 100);
            vec2.sub(v12, n3.position, p);
            vec2.normalize(v12, v12);
            vec2.scaleAndAdd(n3.force, n3.force, v12, factor);
            vec2.scaleAndAdd(n1.force, n1.force, v12, -factor);
            vec2.scaleAndAdd(n2.force, n2.force, v12, -factor);
        };
    }();
    ForceLayout.prototype.updateBBox = function () {
        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;
        for (var i = 0; i < this.nodes.length; i++) {
            var pos = this.nodes[i].position;
            minX = Math.min(minX, pos[0]);
            minY = Math.min(minY, pos[1]);
            maxX = Math.max(maxX, pos[0]);
            maxY = Math.max(maxY, pos[1]);
        }
        this.bbox[0] = minX;
        this.bbox[1] = minY;
        this.bbox[2] = maxX;
        this.bbox[3] = maxY;
    };
    ForceLayout.getWorkerCode = function () {
        var str = __echartsForceLayoutWorker.toString();
        return str.slice(str.indexOf('{') + 1, str.lastIndexOf('return'));
    };
    if (inWorker) {
        var forceLayout = null;
        self.onmessage = function (e) {
            if (e.data instanceof ArrayBuffer) {
                if (!forceLayout)
                    return;
                var positionArr = new Float32Array(e.data);
                var nNodes = positionArr.length / 2;
                for (var i = 0; i < nNodes; i++) {
                    var node = forceLayout.nodes[i];
                    node.position[0] = positionArr[i * 2];
                    node.position[1] = positionArr[i * 2 + 1];
                }
                return;
            }
            switch (e.data.cmd) {
            case 'init':
                if (!forceLayout) {
                    forceLayout = new ForceLayout();
                }
                forceLayout.initNodes(e.data.nodesPosition, e.data.nodesMass, e.data.nodesSize);
                forceLayout.initEdges(e.data.edges, e.data.edgesWeight);
                break;
            case 'updateConfig':
                if (forceLayout) {
                    for (var name in e.data.config) {
                        forceLayout[name] = e.data.config[name];
                    }
                }
                break;
            case 'update':
                var steps = e.data.steps;
                if (forceLayout) {
                    var nNodes = forceLayout.nodes.length;
                    var positionArr = new Float32Array(nNodes * 2);
                    forceLayout.temperature = e.data.temperature;
                    for (var i = 0; i < steps; i++) {
                        forceLayout.update();
                        forceLayout.temperature *= e.data.coolDown;
                    }
                    for (var i = 0; i < nNodes; i++) {
                        var node = forceLayout.nodes[i];
                        positionArr[i * 2] = node.position[0];
                        positionArr[i * 2 + 1] = node.position[1];
                    }
                    self.postMessage(positionArr.buffer, [positionArr.buffer]);
                } else {
                    var emptyArr = new Float32Array();
                    self.postMessage(emptyArr.buffer, [emptyArr.buffer]);
                }
                break;
            }
        };
    }
    return ForceLayout;
});define('echarts/chart/map', [
    'require',
    './base',
    'zrender/shape/Text',
    'zrender/shape/Path',
    'zrender/shape/Circle',
    'zrender/shape/Rectangle',
    'zrender/shape/Line',
    'zrender/shape/Polygon',
    'zrender/shape/Ellipse',
    '../component/dataRange',
    '../component/roamController',
    '../config',
    '../util/ecData',
    'zrender/tool/util',
    'zrender/config',
    'zrender/tool/event',
    '../util/mapData/params',
    '../util/mapData/textFixed',
    '../util/mapData/geoCoord',
    '../util/projection/svg',
    '../util/projection/normal',
    '../chart'
], function (require) {
    var ChartBase = require('./base');
    var TextShape = require('zrender/shape/Text');
    var PathShape = require('zrender/shape/Path');
    var CircleShape = require('zrender/shape/Circle');
    var RectangleShape = require('zrender/shape/Rectangle');
    var LineShape = require('zrender/shape/Line');
    var PolygonShape = require('zrender/shape/Polygon');
    var EllipseShape = require('zrender/shape/Ellipse');
    require('../component/dataRange');
    require('../component/roamController');
    var ecConfig = require('../config');
    ecConfig.map = {
        zlevel: 0,
        z: 2,
        mapType: 'china',
        mapValuePrecision: 0,
        showLegendSymbol: true,
        dataRangeHoverLink: true,
        hoverable: true,
        clickable: true,
        itemStyle: {
            normal: {
                borderColor: 'rgba(0,0,0,0)',
                borderWidth: 1,
                areaStyle: { color: '#ccc' },
                label: {
                    show: false,
                    textStyle: { color: 'rgb(139,69,19)' }
                }
            },
            emphasis: {
                borderColor: 'rgba(0,0,0,0)',
                borderWidth: 1,
                areaStyle: { color: 'rgba(255,215,0,0.8)' },
                label: {
                    show: false,
                    textStyle: { color: 'rgb(100,0,0)' }
                }
            }
        }
    };
    var ecData = require('../util/ecData');
    var zrUtil = require('zrender/tool/util');
    var zrConfig = require('zrender/config');
    var zrEvent = require('zrender/tool/event');
    var _mapParams = require('../util/mapData/params').params;
    var _textFixed = require('../util/mapData/textFixed');
    var _geoCoord = require('../util/mapData/geoCoord');
    function Map(ecTheme, messageCenter, zr, option, myChart) {
        ChartBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        var self = this;
        self._onmousewheel = function (params) {
            return self.__onmousewheel(params);
        };
        self._onmousedown = function (params) {
            return self.__onmousedown(params);
        };
        self._onmousemove = function (params) {
            return self.__onmousemove(params);
        };
        self._onmouseup = function (params) {
            return self.__onmouseup(params);
        };
        self._onroamcontroller = function (params) {
            return self.__onroamcontroller(params);
        };
        self._ondrhoverlink = function (params) {
            return self.__ondrhoverlink(params);
        };
        this._isAlive = true;
        this._selectedMode = {};
        this._activeMapType = {};
        this._clickable = {};
        this._hoverable = {};
        this._showLegendSymbol = {};
        this._selected = {};
        this._mapTypeMap = {};
        this._mapDataMap = {};
        this._nameMap = {};
        this._specialArea = {};
        this._refreshDelayTicket;
        this._mapDataRequireCounter;
        this._markAnimation = false;
        this._hoverLinkMap = {};
        this._roamMap = {};
        this._scaleLimitMap = {};
        this._mx;
        this._my;
        this._mousedown;
        this._justMove;
        this._curMapType;
        this.refresh(option);
        this.zr.on(zrConfig.EVENT.MOUSEWHEEL, this._onmousewheel);
        this.zr.on(zrConfig.EVENT.MOUSEDOWN, this._onmousedown);
        messageCenter.bind(ecConfig.EVENT.ROAMCONTROLLER, this._onroamcontroller);
        messageCenter.bind(ecConfig.EVENT.DATA_RANGE_HOVERLINK, this._ondrhoverlink);
    }
    Map.prototype = {
        type: ecConfig.CHART_TYPE_MAP,
        _buildShape: function () {
            var series = this.series;
            this.selectedMap = {};
            this._activeMapType = {};
            var legend = this.component.legend;
            var seriesName;
            var valueData = {};
            var mapType;
            var data;
            var name;
            var mapSeries = {};
            var mapValuePrecision = {};
            var valueCalculation = {};
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].type == ecConfig.CHART_TYPE_MAP) {
                    series[i] = this.reformOption(series[i]);
                    mapType = series[i].mapType;
                    mapSeries[mapType] = mapSeries[mapType] || {};
                    mapSeries[mapType][i] = true;
                    mapValuePrecision[mapType] = mapValuePrecision[mapType] || series[i].mapValuePrecision;
                    this._scaleLimitMap[mapType] = this._scaleLimitMap[mapType] || {};
                    series[i].scaleLimit && zrUtil.merge(this._scaleLimitMap[mapType], series[i].scaleLimit, true);
                    this._roamMap[mapType] = series[i].roam || this._roamMap[mapType];
                    if (this._hoverLinkMap[mapType] == null || this._hoverLinkMap[mapType]) {
                        this._hoverLinkMap[mapType] = series[i].dataRangeHoverLink;
                    }
                    this._nameMap[mapType] = this._nameMap[mapType] || {};
                    series[i].nameMap && zrUtil.merge(this._nameMap[mapType], series[i].nameMap, true);
                    this._activeMapType[mapType] = true;
                    if (series[i].textFixed) {
                        zrUtil.merge(_textFixed, series[i].textFixed, true);
                    }
                    if (series[i].geoCoord) {
                        zrUtil.merge(_geoCoord, series[i].geoCoord, true);
                    }
                    this._selectedMode[mapType] = this._selectedMode[mapType] || series[i].selectedMode;
                    if (this._hoverable[mapType] == null || this._hoverable[mapType]) {
                        this._hoverable[mapType] = series[i].hoverable;
                    }
                    if (this._clickable[mapType] == null || this._clickable[mapType]) {
                        this._clickable[mapType] = series[i].clickable;
                    }
                    if (this._showLegendSymbol[mapType] == null || this._showLegendSymbol[mapType]) {
                        this._showLegendSymbol[mapType] = series[i].showLegendSymbol;
                    }
                    valueCalculation[mapType] = valueCalculation[mapType] || series[i].mapValueCalculation;
                    seriesName = series[i].name;
                    this.selectedMap[seriesName] = legend ? legend.isSelected(seriesName) : true;
                    if (this.selectedMap[seriesName]) {
                        valueData[mapType] = valueData[mapType] || {};
                        data = series[i].data;
                        for (var j = 0, k = data.length; j < k; j++) {
                            name = this._nameChange(mapType, data[j].name);
                            valueData[mapType][name] = valueData[mapType][name] || {
                                seriesIndex: [],
                                valueMap: {}
                            };
                            for (var key in data[j]) {
                                if (key != 'value') {
                                    valueData[mapType][name][key] = data[j][key];
                                } else if (!isNaN(data[j].value)) {
                                    valueData[mapType][name].value == null && (valueData[mapType][name].value = 0);
                                    valueData[mapType][name].value += +data[j].value;
                                    valueData[mapType][name].valueMap[i] = +data[j].value;
                                }
                            }
                            valueData[mapType][name].seriesIndex.push(i);
                        }
                    }
                }
            }
            this._mapDataRequireCounter = 0;
            for (var mt in valueData) {
                this._mapDataRequireCounter++;
            }
            this._clearSelected();
            if (this._mapDataRequireCounter === 0) {
                this.clear();
                this.zr && this.zr.delShape(this.lastShapeList);
                this.lastShapeList = [];
            }
            for (var mt in valueData) {
                if (valueCalculation[mt] && valueCalculation[mt] == 'average') {
                    for (var k in valueData[mt]) {
                        valueData[mt][k].value = (valueData[mt][k].value / valueData[mt][k].seriesIndex.length).toFixed(mapValuePrecision[mt]) - 0;
                    }
                }
                this._mapDataMap[mt] = this._mapDataMap[mt] || {};
                if (this._mapDataMap[mt].mapData) {
                    this._mapDataCallback(mt, valueData[mt], mapSeries[mt])(this._mapDataMap[mt].mapData);
                } else if (_mapParams[mt.replace(/\|.*/, '')].getGeoJson) {
                    this._specialArea[mt] = _mapParams[mt.replace(/\|.*/, '')].specialArea || this._specialArea[mt];
                    _mapParams[mt.replace(/\|.*/, '')].getGeoJson(this._mapDataCallback(mt, valueData[mt], mapSeries[mt]));
                }
            }
        },
        _mapDataCallback: function (mt, vd, ms) {
            var self = this;
            return function (md) {
                if (!self._isAlive || self._activeMapType[mt] == null) {
                    return;
                }
                if (mt.indexOf('|') != -1) {
                    md = self._getSubMapData(mt, md);
                }
                self._mapDataMap[mt].mapData = md;
                if (md.firstChild) {
                    self._mapDataMap[mt].rate = 1;
                    self._mapDataMap[mt].projection = require('../util/projection/svg');
                } else {
                    self._mapDataMap[mt].rate = 0.75;
                    self._mapDataMap[mt].projection = require('../util/projection/normal');
                }
                self._buildMap(mt, self._getProjectionData(mt, md, ms), vd, ms);
                self._buildMark(mt, ms);
                if (--self._mapDataRequireCounter <= 0) {
                    self.addShapeList();
                    self.zr.refreshNextFrame();
                }
            };
        },
        _clearSelected: function () {
            for (var k in this._selected) {
                if (!this._activeMapType[this._mapTypeMap[k]]) {
                    delete this._selected[k];
                    delete this._mapTypeMap[k];
                }
            }
        },
        _getSubMapData: function (mapType, mapData) {
            var subType = mapType.replace(/^.*\|/, '');
            var features = mapData.features;
            for (var i = 0, l = features.length; i < l; i++) {
                if (features[i].properties && features[i].properties.name == subType) {
                    features = features[i];
                    if (subType == 'United States of America' && features.geometry.coordinates.length > 1) {
                        features = {
                            geometry: {
                                coordinates: features.geometry.coordinates.slice(5, 6),
                                type: features.geometry.type
                            },
                            id: features.id,
                            properties: features.properties,
                            type: features.type
                        };
                    }
                    break;
                }
            }
            return {
                'type': 'FeatureCollection',
                'features': [features]
            };
        },
        _getProjectionData: function (mapType, mapData, mapSeries) {
            var normalProjection = this._mapDataMap[mapType].projection;
            var province = [];
            var bbox = this._mapDataMap[mapType].bbox || normalProjection.getBbox(mapData, this._specialArea[mapType]);
            var transform;
            if (!this._mapDataMap[mapType].hasRoam) {
                transform = this._getTransform(bbox, mapSeries, this._mapDataMap[mapType].rate);
            } else {
                transform = this._mapDataMap[mapType].transform;
            }
            var lastTransform = this._mapDataMap[mapType].lastTransform || { scale: {} };
            var pathArray;
            if (transform.left != lastTransform.left || transform.top != lastTransform.top || transform.scale.x != lastTransform.scale.x || transform.scale.y != lastTransform.scale.y) {
                pathArray = normalProjection.geoJson2Path(mapData, transform, this._specialArea[mapType]);
                lastTransform = zrUtil.clone(transform);
            } else {
                transform = this._mapDataMap[mapType].transform;
                pathArray = this._mapDataMap[mapType].pathArray;
            }
            this._mapDataMap[mapType].bbox = bbox;
            this._mapDataMap[mapType].transform = transform;
            this._mapDataMap[mapType].lastTransform = lastTransform;
            this._mapDataMap[mapType].pathArray = pathArray;
            var position = [
                transform.left,
                transform.top
            ];
            for (var i = 0, l = pathArray.length; i < l; i++) {
                province.push(this._getSingleProvince(mapType, pathArray[i], position));
            }
            if (this._specialArea[mapType]) {
                for (var area in this._specialArea[mapType]) {
                    province.push(this._getSpecialProjectionData(mapType, mapData, area, this._specialArea[mapType][area], position));
                }
            }
            if (mapType == 'china') {
                var leftTop = this.geo2pos(mapType, _geoCoord['å—æµ·è¯¸å²›'] || _mapParams['å—æµ·è¯¸å²›'].textCoord);
                var scale = transform.scale.x / 10.5;
                var textPosition = [
                    32 * scale + leftTop[0],
                    83 * scale + leftTop[1]
                ];
                if (_textFixed['å—æµ·è¯¸å²›']) {
                    textPosition[0] += _textFixed['å—æµ·è¯¸å²›'][0];
                    textPosition[1] += _textFixed['å—æµ·è¯¸å²›'][1];
                }
                province.push({
                    name: this._nameChange(mapType, 'å—æµ·è¯¸å²›'),
                    path: _mapParams['å—æµ·è¯¸å²›'].getPath(leftTop, scale),
                    position: position,
                    textX: textPosition[0],
                    textY: textPosition[1]
                });
            }
            return province;
        },
        _getSpecialProjectionData: function (mapType, mapData, areaName, mapSize, position) {
            mapData = this._getSubMapData('x|' + areaName, mapData);
            var normalProjection = require('../util/projection/normal');
            var bbox = normalProjection.getBbox(mapData);
            var leftTop = this.geo2pos(mapType, [
                mapSize.left,
                mapSize.top
            ]);
            var rightBottom = this.geo2pos(mapType, [
                mapSize.left + mapSize.width,
                mapSize.top + mapSize.height
            ]);
            var width = Math.abs(rightBottom[0] - leftTop[0]);
            var height = Math.abs(rightBottom[1] - leftTop[1]);
            var mapWidth = bbox.width;
            var mapHeight = bbox.height;
            var xScale = width / 0.75 / mapWidth;
            var yScale = height / mapHeight;
            if (xScale > yScale) {
                xScale = yScale * 0.75;
                width = mapWidth * xScale;
            } else {
                yScale = xScale;
                xScale = yScale * 0.75;
                height = mapHeight * yScale;
            }
            var transform = {
                OffsetLeft: leftTop[0],
                OffsetTop: leftTop[1],
                scale: {
                    x: xScale,
                    y: yScale
                }
            };
            var pathArray = normalProjection.geoJson2Path(mapData, transform);
            return this._getSingleProvince(mapType, pathArray[0], position);
        },
        _getSingleProvince: function (mapType, path, position) {
            var textPosition;
            var name = path.properties.name;
            var textFixed = _textFixed[name] || [
                0,
                0
            ];
            if (_geoCoord[name]) {
                textPosition = this.geo2pos(mapType, _geoCoord[name]);
            } else if (path.cp) {
                textPosition = [
                    path.cp[0] + textFixed[0],
                    path.cp[1] + textFixed[1]
                ];
            } else {
                var bbox = this._mapDataMap[mapType].bbox;
                textPosition = this.geo2pos(mapType, [
                    bbox.left + bbox.width / 2,
                    bbox.top + bbox.height / 2
                ]);
                textPosition[0] += textFixed[0];
                textPosition[1] += textFixed[1];
            }
            path.name = this._nameChange(mapType, name);
            path.position = position;
            path.textX = textPosition[0];
            path.textY = textPosition[1];
            return path;
        },
        _getTransform: function (bbox, mapSeries, rate) {
            var series = this.series;
            var mapLocation;
            var x;
            var cusX;
            var y;
            var cusY;
            var width;
            var height;
            var zrWidth = this.zr.getWidth();
            var zrHeight = this.zr.getHeight();
            var padding = Math.round(Math.min(zrWidth, zrHeight) * 0.02);
            for (var key in mapSeries) {
                mapLocation = series[key].mapLocation || {};
                cusX = mapLocation.x || cusX;
                cusY = mapLocation.y || cusY;
                width = mapLocation.width || width;
                height = mapLocation.height || height;
            }
            x = this.parsePercent(cusX, zrWidth);
            x = isNaN(x) ? padding : x;
            y = this.parsePercent(cusY, zrHeight);
            y = isNaN(y) ? padding : y;
            width = width == null ? zrWidth - x - 2 * padding : this.parsePercent(width, zrWidth);
            height = height == null ? zrHeight - y - 2 * padding : this.parsePercent(height, zrHeight);
            var mapWidth = bbox.width;
            var mapHeight = bbox.height;
            var xScale = width / rate / mapWidth;
            var yScale = height / mapHeight;
            if (xScale > yScale) {
                xScale = yScale * rate;
                width = mapWidth * xScale;
            } else {
                yScale = xScale;
                xScale = yScale * rate;
                height = mapHeight * yScale;
            }
            if (isNaN(cusX)) {
                cusX = cusX || 'center';
                switch (cusX + '') {
                case 'center':
                    x = Math.floor((zrWidth - width) / 2);
                    break;
                case 'right':
                    x = zrWidth - width;
                    break;
                }
            }
            if (isNaN(cusY)) {
                cusY = cusY || 'center';
                switch (cusY + '') {
                case 'center':
                    y = Math.floor((zrHeight - height) / 2);
                    break;
                case 'bottom':
                    y = zrHeight - height;
                    break;
                }
            }
            return {
                left: x,
                top: y,
                width: width,
                height: height,
                baseScale: 1,
                scale: {
                    x: xScale,
                    y: yScale
                }
            };
        },
        _buildMap: function (mapType, mapData, valueData, mapSeries) {
            var series = this.series;
            var legend = this.component.legend;
            var dataRange = this.component.dataRange;
            var seriesName;
            var name;
            var data;
            var value;
            var queryTarget;
            var color;
            var font;
            var style;
            var highlightStyle;
            var shape;
            var textShape;
            for (var i = 0, l = mapData.length; i < l; i++) {
                style = zrUtil.clone(mapData[i]);
                highlightStyle = {
                    name: style.name,
                    path: style.path,
                    position: zrUtil.clone(style.position)
                };
                name = style.name;
                data = valueData[name];
                if (data) {
                    queryTarget = [data];
                    seriesName = '';
                    for (var j = 0, k = data.seriesIndex.length; j < k; j++) {
                        queryTarget.push(series[data.seriesIndex[j]]);
                        seriesName += series[data.seriesIndex[j]].name + ' ';
                        if (legend && this._showLegendSymbol[mapType] && legend.hasColor(series[data.seriesIndex[j]].name)) {
                            this.shapeList.push(new CircleShape({
                                zlevel: this.getZlevelBase(),
                                z: this.getZBase() + 1,
                                position: zrUtil.clone(style.position),
                                _mapType: mapType,
                                style: {
                                    x: style.textX + 3 + j * 7,
                                    y: style.textY - 10,
                                    r: 3,
                                    color: legend.getColor(series[data.seriesIndex[j]].name)
                                },
                                hoverable: false
                            }));
                        }
                    }
                    value = data.value;
                } else {
                    data = {
                        name: name,
                        value: '-'
                    };
                    seriesName = '';
                    queryTarget = [];
                    for (var key in mapSeries) {
                        queryTarget.push(series[key]);
                    }
                    value = '-';
                }
                this.ecTheme.map && queryTarget.push(this.ecTheme.map);
                queryTarget.push(ecConfig);
                color = dataRange && !isNaN(value) ? dataRange.getColor(value) : null;
                style.color = style.color || color || this.getItemStyleColor(this.deepQuery(queryTarget, 'itemStyle.normal.color'), data.seriesIndex, -1, data) || this.deepQuery(queryTarget, 'itemStyle.normal.areaStyle.color');
                style.strokeColor = style.strokeColor || this.deepQuery(queryTarget, 'itemStyle.normal.borderColor');
                style.lineWidth = style.lineWidth || this.deepQuery(queryTarget, 'itemStyle.normal.borderWidth');
                highlightStyle.color = this.getItemStyleColor(this.deepQuery(queryTarget, 'itemStyle.emphasis.color'), data.seriesIndex, -1, data) || this.deepQuery(queryTarget, 'itemStyle.emphasis.areaStyle.color') || style.color;
                highlightStyle.strokeColor = this.deepQuery(queryTarget, 'itemStyle.emphasis.borderColor') || style.strokeColor;
                highlightStyle.lineWidth = this.deepQuery(queryTarget, 'itemStyle.emphasis.borderWidth') || style.lineWidth;
                style.brushType = highlightStyle.brushType = style.brushType || 'both';
                style.lineJoin = highlightStyle.lineJoin = 'round';
                style._name = highlightStyle._name = name;
                font = this.deepQuery(queryTarget, 'itemStyle.normal.label.textStyle');
                textShape = {
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase() + 1,
                    position: zrUtil.clone(style.position),
                    _mapType: mapType,
                    _geo: this.pos2geo(mapType, [
                        style.textX,
                        style.textY
                    ]),
                    style: {
                        brushType: 'fill',
                        x: style.textX,
                        y: style.textY,
                        text: this.getLabelText(name, value, queryTarget, 'normal'),
                        _name: name,
                        textAlign: 'center',
                        color: this.deepQuery(queryTarget, 'itemStyle.normal.label.show') ? this.deepQuery(queryTarget, 'itemStyle.normal.label.textStyle.color') : 'rgba(0,0,0,0)',
                        textFont: this.getFont(font)
                    }
                };
                textShape._style = zrUtil.clone(textShape.style);
                textShape.highlightStyle = zrUtil.clone(textShape.style);
                if (this.deepQuery(queryTarget, 'itemStyle.emphasis.label.show')) {
                    textShape.highlightStyle.text = this.getLabelText(name, value, queryTarget, 'emphasis');
                    textShape.highlightStyle.color = this.deepQuery(queryTarget, 'itemStyle.emphasis.label.textStyle.color') || textShape.style.color;
                    font = this.deepQuery(queryTarget, 'itemStyle.emphasis.label.textStyle') || font;
                    textShape.highlightStyle.textFont = this.getFont(font);
                } else {
                    textShape.highlightStyle.color = 'rgba(0,0,0,0)';
                }
                shape = {
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase(),
                    position: zrUtil.clone(style.position),
                    style: style,
                    highlightStyle: highlightStyle,
                    _style: zrUtil.clone(style),
                    _mapType: mapType
                };
                if (style.scale != null) {
                    shape.scale = zrUtil.clone(style.scale);
                }
                textShape = new TextShape(textShape);
                switch (shape.style.shapeType) {
                case 'rectangle':
                    shape = new RectangleShape(shape);
                    break;
                case 'line':
                    shape = new LineShape(shape);
                    break;
                case 'circle':
                    shape = new CircleShape(shape);
                    break;
                case 'polygon':
                    shape = new PolygonShape(shape);
                    break;
                case 'ellipse':
                    shape = new EllipseShape(shape);
                    break;
                default:
                    shape = new PathShape(shape);
                    if (shape.buildPathArray) {
                        shape.style.pathArray = shape.buildPathArray(shape.style.path);
                    }
                    break;
                }
                if (this._selectedMode[mapType] && this._selected[name] || data.selected && this._selected[name] !== false) {
                    textShape.style = textShape.highlightStyle;
                    shape.style = shape.highlightStyle;
                }
                textShape.clickable = shape.clickable = this._clickable[mapType] && (data.clickable == null || data.clickable);
                if (this._selectedMode[mapType]) {
                    this._selected[name] = this._selected[name] != null ? this._selected[name] : data.selected;
                    this._mapTypeMap[name] = mapType;
                    if (data.selectable == null || data.selectable) {
                        shape.clickable = textShape.clickable = true;
                        shape.onclick = textShape.onclick = this.shapeHandler.onclick;
                    }
                }
                if (this._hoverable[mapType] && (data.hoverable == null || data.hoverable)) {
                    textShape.hoverable = shape.hoverable = true;
                    shape.hoverConnect = textShape.id;
                    textShape.hoverConnect = shape.id;
                } else {
                    textShape.hoverable = shape.hoverable = false;
                }
                ecData.pack(textShape, {
                    name: seriesName,
                    tooltip: this.deepQuery(queryTarget, 'tooltip')
                }, 0, data, 0, name);
                this.shapeList.push(textShape);
                ecData.pack(shape, {
                    name: seriesName,
                    tooltip: this.deepQuery(queryTarget, 'tooltip')
                }, 0, data, 0, name);
                this.shapeList.push(shape);
            }
        },
        _buildMark: function (mapType, mapSeries) {
            this._seriesIndexToMapType = this._seriesIndexToMapType || {};
            this.markAttachStyle = this.markAttachStyle || {};
            var position = [
                this._mapDataMap[mapType].transform.left,
                this._mapDataMap[mapType].transform.top
            ];
            if (mapType == 'none') {
                position = [
                    0,
                    0
                ];
            }
            for (var sIdx in mapSeries) {
                this._seriesIndexToMapType[sIdx] = mapType;
                this.markAttachStyle[sIdx] = {
                    position: position,
                    _mapType: mapType
                };
                this.buildMark(sIdx);
            }
        },
        getMarkCoord: function (seriesIndex, mpData) {
            return mpData.geoCoord || _geoCoord[mpData.name] ? this.geo2pos(this._seriesIndexToMapType[seriesIndex], mpData.geoCoord || _geoCoord[mpData.name]) : [
                0,
                0
            ];
        },
        getMarkGeo: function (mpData) {
            return mpData.geoCoord || _geoCoord[mpData.name];
        },
        _nameChange: function (mapType, name) {
            return this._nameMap[mapType][name] || name;
        },
        getLabelText: function (name, value, queryTarget, status) {
            var formatter = this.deepQuery(queryTarget, 'itemStyle.' + status + '.label.formatter');
            if (formatter) {
                if (typeof formatter == 'function') {
                    return formatter.call(this.myChart, name, value);
                } else if (typeof formatter == 'string') {
                    formatter = formatter.replace('{a}', '{a0}').replace('{b}', '{b0}');
                    formatter = formatter.replace('{a0}', name).replace('{b0}', value);
                    return formatter;
                }
            } else {
                return name;
            }
        },
        _findMapTypeByPos: function (mx, my) {
            var transform;
            var left;
            var top;
            var width;
            var height;
            for (var mapType in this._mapDataMap) {
                transform = this._mapDataMap[mapType].transform;
                if (!transform || !this._roamMap[mapType] || !this._activeMapType[mapType]) {
                    continue;
                }
                left = transform.left;
                top = transform.top;
                width = transform.width;
                height = transform.height;
                if (mx >= left && mx <= left + width && my >= top && my <= top + height) {
                    return mapType;
                }
            }
            return;
        },
        __onmousewheel: function (params) {
            if (this.shapeList.length <= 0) {
                return;
            }
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                var shape = this.shapeList[i];
                if (shape.__animating) {
                    return;
                }
            }
            var event = params.event;
            var mx = zrEvent.getX(event);
            var my = zrEvent.getY(event);
            var delta;
            var eventDelta = zrEvent.getDelta(event);
            var mapType;
            var mapTypeControl = params.mapTypeControl;
            if (!mapTypeControl) {
                mapTypeControl = {};
                mapType = this._findMapTypeByPos(mx, my);
                if (mapType && this._roamMap[mapType] && this._roamMap[mapType] != 'move') {
                    mapTypeControl[mapType] = true;
                }
            }
            function scalePolyline(shapeStyle, delta) {
                for (var i = 0; i < shapeStyle.pointList.length; i++) {
                    var point = shapeStyle.pointList[i];
                    point[0] *= delta;
                    point[1] *= delta;
                }
                var controlPointList = shapeStyle.controlPointList;
                if (controlPointList) {
                    for (var i = 0; i < controlPointList.length; i++) {
                        var point = controlPointList[i];
                        point[0] *= delta;
                        point[1] *= delta;
                    }
                }
            }
            function scaleMarkline(shapeStyle, delta) {
                shapeStyle.xStart *= delta;
                shapeStyle.yStart *= delta;
                shapeStyle.xEnd *= delta;
                shapeStyle.yEnd *= delta;
                if (shapeStyle.cpX1 != null) {
                    shapeStyle.cpX1 *= delta;
                    shapeStyle.cpY1 *= delta;
                }
            }
            var haveScale = false;
            for (mapType in mapTypeControl) {
                if (mapTypeControl[mapType]) {
                    haveScale = true;
                    var transform = this._mapDataMap[mapType].transform;
                    var left = transform.left;
                    var top = transform.top;
                    var width = transform.width;
                    var height = transform.height;
                    var geoAndPos = this.pos2geo(mapType, [
                        mx - left,
                        my - top
                    ]);
                    if (eventDelta > 0) {
                        delta = 1.2;
                        if (this._scaleLimitMap[mapType].max != null && transform.baseScale >= this._scaleLimitMap[mapType].max) {
                            continue;
                        }
                    } else {
                        delta = 1 / 1.2;
                        if (this._scaleLimitMap[mapType].min != null && transform.baseScale <= this._scaleLimitMap[mapType].min) {
                            continue;
                        }
                    }
                    transform.baseScale *= delta;
                    transform.scale.x *= delta;
                    transform.scale.y *= delta;
                    transform.width = width * delta;
                    transform.height = height * delta;
                    this._mapDataMap[mapType].hasRoam = true;
                    this._mapDataMap[mapType].transform = transform;
                    geoAndPos = this.geo2pos(mapType, geoAndPos);
                    transform.left -= geoAndPos[0] - (mx - left);
                    transform.top -= geoAndPos[1] - (my - top);
                    this._mapDataMap[mapType].transform = transform;
                    this.clearEffectShape(true);
                    for (var i = 0, l = this.shapeList.length; i < l; i++) {
                        var shape = this.shapeList[i];
                        if (shape._mapType == mapType) {
                            var shapeType = shape.type;
                            var shapeStyle = shape.style;
                            shape.position[0] = transform.left;
                            shape.position[1] = transform.top;
                            switch (shapeType) {
                            case 'path':
                            case 'symbol':
                            case 'circle':
                            case 'rectangle':
                            case 'polygon':
                            case 'line':
                            case 'ellipse':
                                shape.scale[0] *= delta;
                                shape.scale[1] *= delta;
                                break;
                            case 'mark-line':
                                scaleMarkline(shapeStyle, delta);
                                break;
                            case 'polyline':
                                scalePolyline(shapeStyle, delta);
                                break;
                            case 'shape-bundle':
                                for (var j = 0; j < shapeStyle.shapeList.length; j++) {
                                    var subShape = shapeStyle.shapeList[j];
                                    if (subShape.type == 'mark-line') {
                                        scaleMarkline(subShape.style, delta);
                                    } else if (subShape.type == 'polyline') {
                                        scalePolyline(subShape.style, delta);
                                    }
                                }
                                break;
                            case 'icon':
                            case 'image':
                                geoAndPos = this.geo2pos(mapType, shape._geo);
                                shapeStyle.x = shapeStyle._x = geoAndPos[0] - shapeStyle.width / 2;
                                shapeStyle.y = shapeStyle._y = geoAndPos[1] - shapeStyle.height / 2;
                                break;
                            default:
                                geoAndPos = this.geo2pos(mapType, shape._geo);
                                shapeStyle.x = geoAndPos[0];
                                shapeStyle.y = geoAndPos[1];
                                if (shapeType == 'text') {
                                    shape._style.x = shape.highlightStyle.x = geoAndPos[0];
                                    shape._style.y = shape.highlightStyle.y = geoAndPos[1];
                                }
                            }
                            this.zr.modShape(shape.id);
                        }
                    }
                }
            }
            if (haveScale) {
                zrEvent.stop(event);
                this.zr.refreshNextFrame();
                var self = this;
                clearTimeout(this._refreshDelayTicket);
                this._refreshDelayTicket = setTimeout(function () {
                    self && self.shapeList && self.animationEffect();
                }, 100);
                this.messageCenter.dispatch(ecConfig.EVENT.MAP_ROAM, params.event, { type: 'scale' }, this.myChart);
            }
        },
        __onmousedown: function (params) {
            if (this.shapeList.length <= 0) {
                return;
            }
            var target = params.target;
            if (target && target.draggable) {
                return;
            }
            var event = params.event;
            var mx = zrEvent.getX(event);
            var my = zrEvent.getY(event);
            var mapType = this._findMapTypeByPos(mx, my);
            if (mapType && this._roamMap[mapType] && this._roamMap[mapType] != 'scale') {
                this._mousedown = true;
                this._mx = mx;
                this._my = my;
                this._curMapType = mapType;
                this.zr.on(zrConfig.EVENT.MOUSEUP, this._onmouseup);
                var self = this;
                setTimeout(function () {
                    self.zr.on(zrConfig.EVENT.MOUSEMOVE, self._onmousemove);
                }, 100);
            }
        },
        __onmousemove: function (params) {
            if (!this._mousedown || !this._isAlive) {
                return;
            }
            var event = params.event;
            var mx = zrEvent.getX(event);
            var my = zrEvent.getY(event);
            var transform = this._mapDataMap[this._curMapType].transform;
            transform.hasRoam = true;
            transform.left -= this._mx - mx;
            transform.top -= this._my - my;
            this._mx = mx;
            this._my = my;
            this._mapDataMap[this._curMapType].transform = transform;
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                if (this.shapeList[i]._mapType == this._curMapType) {
                    this.shapeList[i].position[0] = transform.left;
                    this.shapeList[i].position[1] = transform.top;
                    this.zr.modShape(this.shapeList[i].id);
                }
            }
            this.messageCenter.dispatch(ecConfig.EVENT.MAP_ROAM, params.event, { type: 'move' }, this.myChart);
            this.clearEffectShape(true);
            this.zr.refreshNextFrame();
            this._justMove = true;
            zrEvent.stop(event);
        },
        __onmouseup: function (params) {
            var event = params.event;
            this._mx = zrEvent.getX(event);
            this._my = zrEvent.getY(event);
            this._mousedown = false;
            var self = this;
            setTimeout(function () {
                self._justMove && self.animationEffect();
                self._justMove = false;
                self.zr.un(zrConfig.EVENT.MOUSEMOVE, self._onmousemove);
                self.zr.un(zrConfig.EVENT.MOUSEUP, self._onmouseup);
            }, 120);
        },
        __onroamcontroller: function (params) {
            var event = params.event;
            event.zrenderX = this.zr.getWidth() / 2;
            event.zrenderY = this.zr.getHeight() / 2;
            var mapTypeControl = params.mapTypeControl;
            var top = 0;
            var left = 0;
            var step = params.step;
            switch (params.roamType) {
            case 'scaleUp':
                event.zrenderDelta = 1;
                this.__onmousewheel({
                    event: event,
                    mapTypeControl: mapTypeControl
                });
                return;
            case 'scaleDown':
                event.zrenderDelta = -1;
                this.__onmousewheel({
                    event: event,
                    mapTypeControl: mapTypeControl
                });
                return;
            case 'up':
                top = -step;
                break;
            case 'down':
                top = step;
                break;
            case 'left':
                left = -step;
                break;
            case 'right':
                left = step;
                break;
            }
            var transform;
            var curMapType;
            for (curMapType in mapTypeControl) {
                if (!this._mapDataMap[curMapType] || !this._activeMapType[curMapType]) {
                    continue;
                }
                transform = this._mapDataMap[curMapType].transform;
                transform.hasRoam = true;
                transform.left -= left;
                transform.top -= top;
                this._mapDataMap[curMapType].transform = transform;
            }
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                curMapType = this.shapeList[i]._mapType;
                if (!mapTypeControl[curMapType] || !this._activeMapType[curMapType]) {
                    continue;
                }
                transform = this._mapDataMap[curMapType].transform;
                this.shapeList[i].position[0] = transform.left;
                this.shapeList[i].position[1] = transform.top;
                this.zr.modShape(this.shapeList[i].id);
            }
            this.messageCenter.dispatch(ecConfig.EVENT.MAP_ROAM, params.event, { type: 'move' }, this.myChart);
            this.clearEffectShape(true);
            this.zr.refreshNextFrame();
            clearTimeout(this.dircetionTimer);
            var self = this;
            this.dircetionTimer = setTimeout(function () {
                self.animationEffect();
            }, 150);
        },
        __ondrhoverlink: function (param) {
            var curMapType;
            var value;
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                curMapType = this.shapeList[i]._mapType;
                if (!this._hoverLinkMap[curMapType] || !this._activeMapType[curMapType]) {
                    continue;
                }
                value = ecData.get(this.shapeList[i], 'value');
                if (value != null && value >= param.valueMin && value <= param.valueMax) {
                    this.zr.addHoverShape(this.shapeList[i]);
                }
            }
        },
        onclick: function (params) {
            if (!this.isClick || !params.target || this._justMove || params.target.type == 'icon') {
                return;
            }
            this.isClick = false;
            var target = params.target;
            var name = target.style._name;
            var len = this.shapeList.length;
            var mapType = target._mapType || '';
            if (this._selectedMode[mapType] == 'single') {
                for (var p in this._selected) {
                    if (this._selected[p] && this._mapTypeMap[p] == mapType) {
                        for (var i = 0; i < len; i++) {
                            if (this.shapeList[i].style._name == p && this.shapeList[i]._mapType == mapType) {
                                this.shapeList[i].style = this.shapeList[i]._style;
                                this.zr.modShape(this.shapeList[i].id);
                            }
                        }
                        p != name && (this._selected[p] = false);
                    }
                }
            }
            this._selected[name] = !this._selected[name];
            for (var i = 0; i < len; i++) {
                if (this.shapeList[i].style._name == name && this.shapeList[i]._mapType == mapType) {
                    if (this._selected[name]) {
                        this.shapeList[i].style = this.shapeList[i].highlightStyle;
                    } else {
                        this.shapeList[i].style = this.shapeList[i]._style;
                    }
                    this.zr.modShape(this.shapeList[i].id);
                }
            }
            this.messageCenter.dispatch(ecConfig.EVENT.MAP_SELECTED, params.event, {
                selected: this._selected,
                target: name
            }, this.myChart);
            this.zr.refreshNextFrame();
            var self = this;
            setTimeout(function () {
                self.zr.trigger(zrConfig.EVENT.MOUSEMOVE, params.event);
            }, 100);
        },
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.series = newOption.series;
            }
            if (this._mapDataRequireCounter > 0) {
                this.clear();
            } else {
                this.backupShapeList();
            }
            this._buildShape();
            this.zr.refreshHover();
        },
        ondataRange: function (param, status) {
            if (this.component.dataRange) {
                this.refresh();
                status.needRefresh = true;
            }
            return;
        },
        pos2geo: function (mapType, p) {
            if (!this._mapDataMap[mapType].transform) {
                return null;
            }
            return this._mapDataMap[mapType].projection.pos2geo(this._mapDataMap[mapType].transform, p);
        },
        getGeoByPos: function (mapType, p) {
            if (!this._mapDataMap[mapType].transform) {
                return null;
            }
            var position = [
                this._mapDataMap[mapType].transform.left,
                this._mapDataMap[mapType].transform.top
            ];
            if (p instanceof Array) {
                p[0] -= position[0];
                p[1] -= position[1];
            } else {
                p.x -= position[0];
                p.y -= position[1];
            }
            return this.pos2geo(mapType, p);
        },
        geo2pos: function (mapType, p) {
            if (!this._mapDataMap[mapType].transform) {
                return null;
            }
            return this._mapDataMap[mapType].projection.geo2pos(this._mapDataMap[mapType].transform, p);
        },
        getPosByGeo: function (mapType, p) {
            if (!this._mapDataMap[mapType].transform) {
                return null;
            }
            var pos = this.geo2pos(mapType, p);
            pos[0] += this._mapDataMap[mapType].transform.left;
            pos[1] += this._mapDataMap[mapType].transform.top;
            return pos;
        },
        getMapPosition: function (mapType) {
            if (!this._mapDataMap[mapType].transform) {
                return null;
            }
            return [
                this._mapDataMap[mapType].transform.left,
                this._mapDataMap[mapType].transform.top
            ];
        },
        onbeforDispose: function () {
            this._isAlive = false;
            this.zr.un(zrConfig.EVENT.MOUSEWHEEL, this._onmousewheel);
            this.zr.un(zrConfig.EVENT.MOUSEDOWN, this._onmousedown);
            this.messageCenter.unbind(ecConfig.EVENT.ROAMCONTROLLER, this._onroamcontroller);
            this.messageCenter.unbind(ecConfig.EVENT.DATA_RANGE_HOVERLINK, this._ondrhoverlink);
        }
    };
    zrUtil.inherits(Map, ChartBase);
    require('../chart').define('map', Map);
    return Map;
});define('zrender/shape/Path', [
    'require',
    './Base',
    './util/PathProxy',
    '../tool/util'
], function (require) {
    var Base = require('./Base');
    var PathProxy = require('./util/PathProxy');
    var PathSegment = PathProxy.PathSegment;
    var vMag = function (v) {
        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
    };
    var vRatio = function (u, v) {
        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
    };
    var vAngle = function (u, v) {
        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
    };
    var Path = function (options) {
        Base.call(this, options);
    };
    Path.prototype = {
        type: 'path',
        buildPathArray: function (data, x, y) {
            if (!data) {
                return [];
            }
            x = x || 0;
            y = y || 0;
            var cs = data;
            var cc = [
                'm',
                'M',
                'l',
                'L',
                'v',
                'V',
                'h',
                'H',
                'z',
                'Z',
                'c',
                'C',
                'q',
                'Q',
                't',
                'T',
                's',
                'S',
                'a',
                'A'
            ];
            cs = cs.replace(/-/g, ' -');
            cs = cs.replace(/  /g, ' ');
            cs = cs.replace(/ /g, ',');
            cs = cs.replace(/,,/g, ',');
            var n;
            for (n = 0; n < cc.length; n++) {
                cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
            }
            var arr = cs.split('|');
            var ca = [];
            var cpx = 0;
            var cpy = 0;
            for (n = 1; n < arr.length; n++) {
                var str = arr[n];
                var c = str.charAt(0);
                str = str.slice(1);
                str = str.replace(new RegExp('e,-', 'g'), 'e-');
                var p = str.split(',');
                if (p.length > 0 && p[0] === '') {
                    p.shift();
                }
                for (var i = 0; i < p.length; i++) {
                    p[i] = parseFloat(p[i]);
                }
                while (p.length > 0) {
                    if (isNaN(p[0])) {
                        break;
                    }
                    var cmd = null;
                    var points = [];
                    var ctlPtx;
                    var ctlPty;
                    var prevCmd;
                    var rx;
                    var ry;
                    var psi;
                    var fa;
                    var fs;
                    var x1 = cpx;
                    var y1 = cpy;
                    switch (c) {
                    case 'l':
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'L':
                        cpx = p.shift();
                        cpy = p.shift();
                        points.push(cpx, cpy);
                        break;
                    case 'm':
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'M';
                        points.push(cpx, cpy);
                        c = 'l';
                        break;
                    case 'M':
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'M';
                        points.push(cpx, cpy);
                        c = 'L';
                        break;
                    case 'h':
                        cpx += p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'H':
                        cpx = p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'v':
                        cpy += p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'V':
                        cpy = p.shift();
                        cmd = 'L';
                        points.push(cpx, cpy);
                        break;
                    case 'C':
                        points.push(p.shift(), p.shift(), p.shift(), p.shift());
                        cpx = p.shift();
                        cpy = p.shift();
                        points.push(cpx, cpy);
                        break;
                    case 'c':
                        points.push(cpx + p.shift(), cpy + p.shift(), cpx + p.shift(), cpy + p.shift());
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'C';
                        points.push(cpx, cpy);
                        break;
                    case 'S':
                        ctlPtx = cpx;
                        ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if (prevCmd.command === 'C') {
                            ctlPtx = cpx + (cpx - prevCmd.points[2]);
                            ctlPty = cpy + (cpy - prevCmd.points[3]);
                        }
                        points.push(ctlPtx, ctlPty, p.shift(), p.shift());
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'C';
                        points.push(cpx, cpy);
                        break;
                    case 's':
                        ctlPtx = cpx, ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if (prevCmd.command === 'C') {
                            ctlPtx = cpx + (cpx - prevCmd.points[2]);
                            ctlPty = cpy + (cpy - prevCmd.points[3]);
                        }
                        points.push(ctlPtx, ctlPty, cpx + p.shift(), cpy + p.shift());
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'C';
                        points.push(cpx, cpy);
                        break;
                    case 'Q':
                        points.push(p.shift(), p.shift());
                        cpx = p.shift();
                        cpy = p.shift();
                        points.push(cpx, cpy);
                        break;
                    case 'q':
                        points.push(cpx + p.shift(), cpy + p.shift());
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'Q';
                        points.push(cpx, cpy);
                        break;
                    case 'T':
                        ctlPtx = cpx, ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if (prevCmd.command === 'Q') {
                            ctlPtx = cpx + (cpx - prevCmd.points[0]);
                            ctlPty = cpy + (cpy - prevCmd.points[1]);
                        }
                        cpx = p.shift();
                        cpy = p.shift();
                        cmd = 'Q';
                        points.push(ctlPtx, ctlPty, cpx, cpy);
                        break;
                    case 't':
                        ctlPtx = cpx, ctlPty = cpy;
                        prevCmd = ca[ca.length - 1];
                        if (prevCmd.command === 'Q') {
                            ctlPtx = cpx + (cpx - prevCmd.points[0]);
                            ctlPty = cpy + (cpy - prevCmd.points[1]);
                        }
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'Q';
                        points.push(ctlPtx, ctlPty, cpx, cpy);
                        break;
                    case 'A':
                        rx = p.shift();
                        ry = p.shift();
                        psi = p.shift();
                        fa = p.shift();
                        fs = p.shift();
                        x1 = cpx, y1 = cpy;
                        cpx = p.shift(), cpy = p.shift();
                        cmd = 'A';
                        points = this._convertPoint(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
                        break;
                    case 'a':
                        rx = p.shift();
                        ry = p.shift();
                        psi = p.shift();
                        fa = p.shift();
                        fs = p.shift();
                        x1 = cpx, y1 = cpy;
                        cpx += p.shift();
                        cpy += p.shift();
                        cmd = 'A';
                        points = this._convertPoint(x1, y1, cpx, cpy, fa, fs, rx, ry, psi);
                        break;
                    }
                    for (var j = 0, l = points.length; j < l; j += 2) {
                        points[j] += x;
                        points[j + 1] += y;
                    }
                    ca.push(new PathSegment(cmd || c, points));
                }
                if (c === 'z' || c === 'Z') {
                    ca.push(new PathSegment('z', []));
                }
            }
            return ca;
        },
        _convertPoint: function (x1, y1, x2, y2, fa, fs, rx, ry, psiDeg) {
            var psi = psiDeg * (Math.PI / 180);
            var xp = Math.cos(psi) * (x1 - x2) / 2 + Math.sin(psi) * (y1 - y2) / 2;
            var yp = -1 * Math.sin(psi) * (x1 - x2) / 2 + Math.cos(psi) * (y1 - y2) / 2;
            var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
            if (lambda > 1) {
                rx *= Math.sqrt(lambda);
                ry *= Math.sqrt(lambda);
            }
            var f = Math.sqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp)));
            if (fa === fs) {
                f *= -1;
            }
            if (isNaN(f)) {
                f = 0;
            }
            var cxp = f * rx * yp / ry;
            var cyp = f * -ry * xp / rx;
            var cx = (x1 + x2) / 2 + Math.cos(psi) * cxp - Math.sin(psi) * cyp;
            var cy = (y1 + y2) / 2 + Math.sin(psi) * cxp + Math.cos(psi) * cyp;
            var theta = vAngle([
                1,
                0
            ], [
                (xp - cxp) / rx,
                (yp - cyp) / ry
            ]);
            var u = [
                (xp - cxp) / rx,
                (yp - cyp) / ry
            ];
            var v = [
                (-1 * xp - cxp) / rx,
                (-1 * yp - cyp) / ry
            ];
            var dTheta = vAngle(u, v);
            if (vRatio(u, v) <= -1) {
                dTheta = Math.PI;
            }
            if (vRatio(u, v) >= 1) {
                dTheta = 0;
            }
            if (fs === 0 && dTheta > 0) {
                dTheta = dTheta - 2 * Math.PI;
            }
            if (fs === 1 && dTheta < 0) {
                dTheta = dTheta + 2 * Math.PI;
            }
            return [
                cx,
                cy,
                rx,
                ry,
                theta,
                dTheta,
                psi,
                fs
            ];
        },
        buildPath: function (ctx, style) {
            var path = style.path;
            var x = style.x || 0;
            var y = style.y || 0;
            style.pathArray = style.pathArray || this.buildPathArray(path, x, y);
            var pathArray = style.pathArray;
            var pointList = style.pointList = [];
            var singlePointList = [];
            for (var i = 0, l = pathArray.length; i < l; i++) {
                if (pathArray[i].command.toUpperCase() == 'M') {
                    singlePointList.length > 0 && pointList.push(singlePointList);
                    singlePointList = [];
                }
                var p = pathArray[i].points;
                for (var j = 0, k = p.length; j < k; j += 2) {
                    singlePointList.push([
                        p[j],
                        p[j + 1]
                    ]);
                }
            }
            singlePointList.length > 0 && pointList.push(singlePointList);
            for (var i = 0, l = pathArray.length; i < l; i++) {
                var c = pathArray[i].command;
                var p = pathArray[i].points;
                switch (c) {
                case 'L':
                    ctx.lineTo(p[0], p[1]);
                    break;
                case 'M':
                    ctx.moveTo(p[0], p[1]);
                    break;
                case 'C':
                    ctx.bezierCurveTo(p[0], p[1], p[2], p[3], p[4], p[5]);
                    break;
                case 'Q':
                    ctx.quadraticCurveTo(p[0], p[1], p[2], p[3]);
                    break;
                case 'A':
                    var cx = p[0];
                    var cy = p[1];
                    var rx = p[2];
                    var ry = p[3];
                    var theta = p[4];
                    var dTheta = p[5];
                    var psi = p[6];
                    var fs = p[7];
                    var r = rx > ry ? rx : ry;
                    var scaleX = rx > ry ? 1 : rx / ry;
                    var scaleY = rx > ry ? ry / rx : 1;
                    ctx.translate(cx, cy);
                    ctx.rotate(psi);
                    ctx.scale(scaleX, scaleY);
                    ctx.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
                    ctx.scale(1 / scaleX, 1 / scaleY);
                    ctx.rotate(-psi);
                    ctx.translate(-cx, -cy);
                    break;
                case 'z':
                    ctx.closePath();
                    break;
                }
            }
            return;
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            var lineWidth;
            if (style.brushType == 'stroke' || style.brushType == 'fill') {
                lineWidth = style.lineWidth || 1;
            } else {
                lineWidth = 0;
            }
            var minX = Number.MAX_VALUE;
            var maxX = Number.MIN_VALUE;
            var minY = Number.MAX_VALUE;
            var maxY = Number.MIN_VALUE;
            var x = style.x || 0;
            var y = style.y || 0;
            var pathArray = style.pathArray || this.buildPathArray(style.path);
            for (var i = 0; i < pathArray.length; i++) {
                var p = pathArray[i].points;
                for (var j = 0; j < p.length; j++) {
                    if (j % 2 === 0) {
                        if (p[j] + x < minX) {
                            minX = p[j];
                        }
                        if (p[j] + x > maxX) {
                            maxX = p[j];
                        }
                    } else {
                        if (p[j] + y < minY) {
                            minY = p[j];
                        }
                        if (p[j] + y > maxY) {
                            maxY = p[j];
                        }
                    }
                }
            }
            var rect;
            if (minX === Number.MAX_VALUE || maxX === Number.MIN_VALUE || minY === Number.MAX_VALUE || maxY === Number.MIN_VALUE) {
                rect = {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                };
            } else {
                rect = {
                    x: Math.round(minX - lineWidth / 2),
                    y: Math.round(minY - lineWidth / 2),
                    width: maxX - minX + lineWidth,
                    height: maxY - minY + lineWidth
                };
            }
            style.__rect = rect;
            return rect;
        }
    };
    require('../tool/util').inherits(Path, Base);
    return Path;
});define('zrender/shape/Ellipse', [
    'require',
    './Base',
    '../tool/util'
], function (require) {
    var Base = require('./Base');
    var Ellipse = function (options) {
        Base.call(this, options);
    };
    Ellipse.prototype = {
        type: 'ellipse',
        buildPath: function (ctx, style) {
            var k = 0.5522848;
            var x = style.x;
            var y = style.y;
            var a = style.a;
            var b = style.b;
            var ox = a * k;
            var oy = b * k;
            ctx.moveTo(x - a, y);
            ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
            ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
            ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
            ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
            ctx.closePath();
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            var lineWidth;
            if (style.brushType == 'stroke' || style.brushType == 'fill') {
                lineWidth = style.lineWidth || 1;
            } else {
                lineWidth = 0;
            }
            style.__rect = {
                x: Math.round(style.x - style.a - lineWidth / 2),
                y: Math.round(style.y - style.b - lineWidth / 2),
                width: style.a * 2 + lineWidth,
                height: style.b * 2 + lineWidth
            };
            return style.__rect;
        }
    };
    require('../tool/util').inherits(Ellipse, Base);
    return Ellipse;
});define('echarts/component/roamController', [
    'require',
    './base',
    'zrender/shape/Rectangle',
    'zrender/shape/Sector',
    'zrender/shape/Circle',
    '../config',
    'zrender/tool/util',
    'zrender/tool/color',
    'zrender/tool/event',
    '../component'
], function (require) {
    var Base = require('./base');
    var RectangleShape = require('zrender/shape/Rectangle');
    var SectorShape = require('zrender/shape/Sector');
    var CircleShape = require('zrender/shape/Circle');
    var ecConfig = require('../config');
    ecConfig.roamController = {
        zlevel: 0,
        z: 4,
        show: true,
        x: 'left',
        y: 'top',
        width: 80,
        height: 120,
        backgroundColor: 'rgba(0,0,0,0)',
        borderColor: '#ccc',
        borderWidth: 0,
        padding: 5,
        handleColor: '#6495ed',
        fillerColor: '#fff',
        step: 15,
        mapTypeControl: null
    };
    var zrUtil = require('zrender/tool/util');
    var zrColor = require('zrender/tool/color');
    var zrEvent = require('zrender/tool/event');
    function RoamController(ecTheme, messageCenter, zr, option, myChart) {
        if (!option.roamController || !option.roamController.show) {
            return;
        }
        if (!option.roamController.mapTypeControl) {
            console.error('option.roamController.mapTypeControl has not been defined.');
            return;
        }
        Base.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.rcOption = option.roamController;
        var self = this;
        this._drictionMouseDown = function (params) {
            return self.__drictionMouseDown(params);
        };
        this._drictionMouseUp = function (params) {
            return self.__drictionMouseUp(params);
        };
        this._drictionMouseMove = function (params) {
            return self.__drictionMouseMove(params);
        };
        this._drictionMouseOut = function (params) {
            return self.__drictionMouseOut(params);
        };
        this._scaleHandler = function (params) {
            return self.__scaleHandler(params);
        };
        this.refresh(option);
    }
    RoamController.prototype = {
        type: ecConfig.COMPONENT_TYPE_ROAMCONTROLLER,
        _buildShape: function () {
            if (!this.rcOption.show) {
                return;
            }
            this._itemGroupLocation = this._getItemGroupLocation();
            this._buildBackground();
            this._buildItem();
            for (var i = 0, l = this.shapeList.length; i < l; i++) {
                this.zr.addShape(this.shapeList[i]);
            }
        },
        _buildItem: function () {
            this.shapeList.push(this._getDirectionShape('up'));
            this.shapeList.push(this._getDirectionShape('down'));
            this.shapeList.push(this._getDirectionShape('left'));
            this.shapeList.push(this._getDirectionShape('right'));
            this.shapeList.push(this._getScaleShape('scaleUp'));
            this.shapeList.push(this._getScaleShape('scaleDown'));
        },
        _getDirectionShape: function (direction) {
            var r = this._itemGroupLocation.r;
            var x = this._itemGroupLocation.x + r;
            var y = this._itemGroupLocation.y + r;
            var sectorShape = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                style: {
                    x: x,
                    y: y,
                    r: r,
                    startAngle: -45,
                    endAngle: 45,
                    color: this.rcOption.handleColor,
                    text: '>',
                    textX: x + r / 2 + 4,
                    textY: y - 0.5,
                    textAlign: 'center',
                    textBaseline: 'middle',
                    textPosition: 'specific',
                    textColor: this.rcOption.fillerColor,
                    textFont: Math.floor(r / 2) + 'px arial'
                },
                highlightStyle: {
                    color: zrColor.lift(this.rcOption.handleColor, -0.2),
                    brushType: 'fill'
                },
                clickable: true
            };
            switch (direction) {
            case 'up':
                sectorShape.rotation = [
                    Math.PI / 2,
                    x,
                    y
                ];
                break;
            case 'left':
                sectorShape.rotation = [
                    Math.PI,
                    x,
                    y
                ];
                break;
            case 'down':
                sectorShape.rotation = [
                    -Math.PI / 2,
                    x,
                    y
                ];
                break;
            }
            sectorShape = new SectorShape(sectorShape);
            sectorShape._roamType = direction;
            sectorShape.onmousedown = this._drictionMouseDown;
            sectorShape.onmouseup = this._drictionMouseUp;
            sectorShape.onmousemove = this._drictionMouseMove;
            sectorShape.onmouseout = this._drictionMouseOut;
            return sectorShape;
        },
        _getScaleShape: function (text) {
            var width = this._itemGroupLocation.width;
            var height = this._itemGroupLocation.height - width;
            height = height < 0 ? 20 : height;
            var r = Math.min(width / 2 - 5, height) / 2;
            var x = this._itemGroupLocation.x + (text === 'scaleDown' ? width - r : r);
            var y = this._itemGroupLocation.y + this._itemGroupLocation.height - r;
            var scaleShape = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                style: {
                    x: x,
                    y: y,
                    r: r,
                    color: this.rcOption.handleColor,
                    text: text === 'scaleDown' ? '-' : '+',
                    textX: x,
                    textY: y - 2,
                    textAlign: 'center',
                    textBaseline: 'middle',
                    textPosition: 'specific',
                    textColor: this.rcOption.fillerColor,
                    textFont: Math.floor(r) + 'px verdana'
                },
                highlightStyle: {
                    color: zrColor.lift(this.rcOption.handleColor, -0.2),
                    brushType: 'fill'
                },
                clickable: true
            };
            scaleShape = new CircleShape(scaleShape);
            scaleShape._roamType = text;
            scaleShape.onmousedown = this._scaleHandler;
            return scaleShape;
        },
        _buildBackground: function () {
            var padding = this.reformCssArray(this.rcOption.padding);
            this.shapeList.push(new RectangleShape({
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                hoverable: false,
                style: {
                    x: this._itemGroupLocation.x - padding[3],
                    y: this._itemGroupLocation.y - padding[0],
                    width: this._itemGroupLocation.width + padding[3] + padding[1],
                    height: this._itemGroupLocation.height + padding[0] + padding[2],
                    brushType: this.rcOption.borderWidth === 0 ? 'fill' : 'both',
                    color: this.rcOption.backgroundColor,
                    strokeColor: this.rcOption.borderColor,
                    lineWidth: this.rcOption.borderWidth
                }
            }));
        },
        _getItemGroupLocation: function () {
            var padding = this.reformCssArray(this.rcOption.padding);
            var width = this.rcOption.width;
            var height = this.rcOption.height;
            var zrWidth = this.zr.getWidth();
            var zrHeight = this.zr.getHeight();
            var x;
            switch (this.rcOption.x) {
            case 'center':
                x = Math.floor((zrWidth - width) / 2);
                break;
            case 'left':
                x = padding[3] + this.rcOption.borderWidth;
                break;
            case 'right':
                x = zrWidth - width - padding[1] - padding[3] - this.rcOption.borderWidth * 2;
                break;
            default:
                x = this.parsePercent(this.rcOption.x, zrWidth);
                break;
            }
            var y;
            switch (this.rcOption.y) {
            case 'top':
                y = padding[0] + this.rcOption.borderWidth;
                break;
            case 'bottom':
                y = zrHeight - height - padding[0] - padding[2] - this.rcOption.borderWidth * 2;
                break;
            case 'center':
                y = Math.floor((zrHeight - height) / 2);
                break;
            default:
                y = this.parsePercent(this.rcOption.y, zrHeight);
                break;
            }
            return {
                x: x,
                y: y,
                r: width / 2,
                width: width,
                height: height
            };
        },
        __drictionMouseDown: function (params) {
            this.mousedown = true;
            this._drictionHandlerOn(params);
        },
        __drictionMouseUp: function (params) {
            this.mousedown = false;
            this._drictionHandlerOff(params);
        },
        __drictionMouseMove: function (params) {
            if (this.mousedown) {
                this._drictionHandlerOn(params);
            }
        },
        __drictionMouseOut: function (params) {
            this._drictionHandlerOff(params);
        },
        _drictionHandlerOn: function (params) {
            this._dispatchEvent(params.event, params.target._roamType);
            clearInterval(this.dircetionTimer);
            var self = this;
            this.dircetionTimer = setInterval(function () {
                self._dispatchEvent(params.event, params.target._roamType);
            }, 100);
            zrEvent.stop(params.event);
        },
        _drictionHandlerOff: function (params) {
            clearInterval(this.dircetionTimer);
        },
        __scaleHandler: function (params) {
            this._dispatchEvent(params.event, params.target._roamType);
            zrEvent.stop(params.event);
        },
        _dispatchEvent: function (event, roamType) {
            this.messageCenter.dispatch(ecConfig.EVENT.ROAMCONTROLLER, event, {
                roamType: roamType,
                mapTypeControl: this.rcOption.mapTypeControl,
                step: this.rcOption.step
            }, this.myChart);
        },
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption || this.option;
                this.option.roamController = this.reformOption(this.option.roamController);
                this.rcOption = this.option.roamController;
            }
            this.clear();
            this._buildShape();
        }
    };
    zrUtil.inherits(RoamController, Base);
    require('../component').define('roamController', RoamController);
    return RoamController;
});define('echarts/util/mapData/params', ['require'], function (require) {
    function decode(json) {
        if (!json.UTF8Encoding) {
            return json;
        }
        var features = json.features;
        for (var f = 0; f < features.length; f++) {
            var feature = features[f];
            var coordinates = feature.geometry.coordinates;
            var encodeOffsets = feature.geometry.encodeOffsets;
            for (var c = 0; c < coordinates.length; c++) {
                var coordinate = coordinates[c];
                if (feature.geometry.type === 'Polygon') {
                    coordinates[c] = decodePolygon(coordinate, encodeOffsets[c]);
                } else if (feature.geometry.type === 'MultiPolygon') {
                    for (var c2 = 0; c2 < coordinate.length; c2++) {
                        var polygon = coordinate[c2];
                        coordinate[c2] = decodePolygon(polygon, encodeOffsets[c][c2]);
                    }
                }
            }
        }
        json.UTF8Encoding = false;
        return json;
    }
    function decodePolygon(coordinate, encodeOffsets) {
        var result = [];
        var prevX = encodeOffsets[0];
        var prevY = encodeOffsets[1];
        for (var i = 0; i < coordinate.length; i += 2) {
            var x = coordinate.charCodeAt(i) - 64;
            var y = coordinate.charCodeAt(i + 1) - 64;
            x = x >> 1 ^ -(x & 1);
            y = y >> 1 ^ -(y & 1);
            x += prevX;
            y += prevY;
            prevX = x;
            prevY = y;
            result.push([
                x / 1024,
                y / 1024
            ]);
        }
        return result;
    }
    var mapParams = {
        'none': {
            getGeoJson: function (callback) {
                callback({
                    type: 'FeatureCollection',
                    features: [{
                            type: 'Feature',
                            geometry: {
                                coordinates: [],
                                encodeOffsets: [],
                                type: 'Polygon'
                            },
                            properties: {}
                        }]
                });
            }
        },
        'world': {
            getGeoJson: function (callback) {
                require(['./geoJson/world_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'china': {
            getGeoJson: function (callback) {
                require(['./geoJson/china_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'å—æµ·è¯¸å²›': {
            textCoord: [
                126,
                25
            ],
            getPath: function (leftTop, scale) {
                var pList = [
                    [
                        [
                            0,
                            3.5
                        ],
                        [
                            7,
                            11.2
                        ],
                        [
                            15,
                            11.9
                        ],
                        [
                            30,
                            7
                        ],
                        [
                            42,
                            0.7
                        ],
                        [
                            52,
                            0.7
                        ],
                        [
                            56,
                            7.7
                        ],
                        [
                            59,
                            0.7
                        ],
                        [
                            64,
                            0.7
                        ],
                        [
                            64,
                            0
                        ],
                        [
                            5,
                            0
                        ],
                        [
                            0,
                            3.5
                        ]
                    ],
                    [
                        [
                            13,
                            16.1
                        ],
                        [
                            19,
                            14.7
                        ],
                        [
                            16,
                            21.7
                        ],
                        [
                            11,
                            23.1
                        ],
                        [
                            13,
                            16.1
                        ]
                    ],
                    [
                        [
                            12,
                            32.2
                        ],
                        [
                            14,
                            38.5
                        ],
                        [
                            15,
                            38.5
                        ],
                        [
                            13,
                            32.2
                        ],
                        [
                            12,
                            32.2
                        ]
                    ],
                    [
                        [
                            16,
                            47.6
                        ],
                        [
                            12,
                            53.2
                        ],
                        [
                            13,
                            53.2
                        ],
                        [
                            18,
                            47.6
                        ],
                        [
                            16,
                            47.6
                        ]
                    ],
                    [
                        [
                            6,
                            64.4
                        ],
                        [
                            8,
                            70
                        ],
                        [
                            9,
                            70
                        ],
                        [
                            8,
                            64.4
                        ],
                        [
                            6,
                            64.4
                        ]
                    ],
                    [
                        [
                            23,
                            82.6
                        ],
                        [
                            29,
                            79.8
                        ],
                        [
                            30,
                            79.8
                        ],
                        [
                            25,
                            82.6
                        ],
                        [
                            23,
                            82.6
                        ]
                    ],
                    [
                        [
                            37,
                            70.7
                        ],
                        [
                            43,
                            62.3
                        ],
                        [
                            44,
                            62.3
                        ],
                        [
                            39,
                            70.7
                        ],
                        [
                            37,
                            70.7
                        ]
                    ],
                    [
                        [
                            48,
                            51.1
                        ],
                        [
                            51,
                            45.5
                        ],
                        [
                            53,
                            45.5
                        ],
                        [
                            50,
                            51.1
                        ],
                        [
                            48,
                            51.1
                        ]
                    ],
                    [
                        [
                            51,
                            35
                        ],
                        [
                            51,
                            28.7
                        ],
                        [
                            53,
                            28.7
                        ],
                        [
                            53,
                            35
                        ],
                        [
                            51,
                            35
                        ]
                    ],
                    [
                        [
                            52,
                            22.4
                        ],
                        [
                            55,
                            17.5
                        ],
                        [
                            56,
                            17.5
                        ],
                        [
                            53,
                            22.4
                        ],
                        [
                            52,
                            22.4
                        ]
                    ],
                    [
                        [
                            58,
                            12.6
                        ],
                        [
                            62,
                            7
                        ],
                        [
                            63,
                            7
                        ],
                        [
                            60,
                            12.6
                        ],
                        [
                            58,
                            12.6
                        ]
                    ],
                    [
                        [
                            0,
                            3.5
                        ],
                        [
                            0,
                            93.1
                        ],
                        [
                            64,
                            93.1
                        ],
                        [
                            64,
                            0
                        ],
                        [
                            63,
                            0
                        ],
                        [
                            63,
                            92.4
                        ],
                        [
                            1,
                            92.4
                        ],
                        [
                            1,
                            3.5
                        ],
                        [
                            0,
                            3.5
                        ]
                    ]
                ];
                var str = '';
                var left = leftTop[0];
                var top = leftTop[1];
                for (var i = 0, l = pList.length; i < l; i++) {
                    str += 'M ' + ((pList[i][0][0] * scale + left).toFixed(2) - 0) + ' ' + ((pList[i][0][1] * scale + top).toFixed(2) - 0) + ' ';
                    for (var j = 1, k = pList[i].length; j < k; j++) {
                        str += 'L ' + ((pList[i][j][0] * scale + left).toFixed(2) - 0) + ' ' + ((pList[i][j][1] * scale + top).toFixed(2) - 0) + ' ';
                    }
                }
                return str + ' Z';
            }
        },
        'æ–°ç–†': {
            getGeoJson: function (callback) {
                require(['./geoJson/xin_jiang_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'è¥¿è—': {
            getGeoJson: function (callback) {
                require(['./geoJson/xi_zang_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'å†…è’™å¤': {
            getGeoJson: function (callback) {
                require(['./geoJson/nei_meng_gu_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'é’æµ·': {
            getGeoJson: function (callback) {
                require(['./geoJson/qing_hai_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'å››å·': {
            getGeoJson: function (callback) {
                require(['./geoJson/si_chuan_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'é»‘é¾™æ±Ÿ': {
            getGeoJson: function (callback) {
                require(['./geoJson/hei_long_jiang_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'ç”˜è‚ƒ': {
            getGeoJson: function (callback) {
                require(['./geoJson/gan_su_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'äº‘å—': {
            getGeoJson: function (callback) {
                require(['./geoJson/yun_nan_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'å¹¿è¥¿': {
            getGeoJson: function (callback) {
                require(['./geoJson/guang_xi_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'æ¹–å—': {
            getGeoJson: function (callback) {
                require(['./geoJson/hu_nan_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'é™•è¥¿': {
            getGeoJson: function (callback) {
                require(['./geoJson/shan_xi_1_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'å¹¿ä¸œ': {
            getGeoJson: function (callback) {
                require(['./geoJson/guang_dong_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'å‰æž—': {
            getGeoJson: function (callback) {
                require(['./geoJson/ji_lin_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'æ²³åŒ—': {
            getGeoJson: function (callback) {
                require(['./geoJson/he_bei_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'æ¹–åŒ—': {
            getGeoJson: function (callback) {
                require(['./geoJson/hu_bei_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'è´µå·ž': {
            getGeoJson: function (callback) {
                require(['./geoJson/gui_zhou_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'å±±ä¸œ': {
            getGeoJson: function (callback) {
                require(['./geoJson/shan_dong_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'æ±Ÿè¥¿': {
            getGeoJson: function (callback) {
                require(['./geoJson/jiang_xi_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'æ²³å—': {
            getGeoJson: function (callback) {
                require(['./geoJson/he_nan_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'è¾½å®': {
            getGeoJson: function (callback) {
                require(['./geoJson/liao_ning_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'å±±è¥¿': {
            getGeoJson: function (callback) {
                require(['./geoJson/shan_xi_2_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'å®‰å¾½': {
            getGeoJson: function (callback) {
                require(['./geoJson/an_hui_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'ç¦å»º': {
            getGeoJson: function (callback) {
                require(['./geoJson/fu_jian_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'æµ™æ±Ÿ': {
            getGeoJson: function (callback) {
                require(['./geoJson/zhe_jiang_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'æ±Ÿè‹': {
            getGeoJson: function (callback) {
                require(['./geoJson/jiang_su_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'é‡åº†': {
            getGeoJson: function (callback) {
                require(['./geoJson/chong_qing_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'å®å¤': {
            getGeoJson: function (callback) {
                require(['./geoJson/ning_xia_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'æµ·å—': {
            getGeoJson: function (callback) {
                require(['./geoJson/hai_nan_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'å°æ¹¾': {
            getGeoJson: function (callback) {
                require(['./geoJson/tai_wan_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'åŒ—äº¬': {
            getGeoJson: function (callback) {
                require(['./geoJson/bei_jing_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'å¤©æ´¥': {
            getGeoJson: function (callback) {
                require(['./geoJson/tian_jin_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'ä¸Šæµ·': {
            getGeoJson: function (callback) {
                require(['./geoJson/shang_hai_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'é¦™æ¸¯': {
            getGeoJson: function (callback) {
                require(['./geoJson/xiang_gang_geo'], function (md) {
                    callback(decode(md));
                });
            }
        },
        'æ¾³é—¨': {
            getGeoJson: function (callback) {
                require(['./geoJson/ao_men_geo'], function (md) {
                    callback(decode(md));
                });
            }
        }
    };
    return {
        decode: decode,
        params: mapParams
    };
});define('echarts/util/mapData/textFixed', [], function () {
    return {
        'å¹¿ä¸œ': [
            0,
            -10
        ],
        'é¦™æ¸¯': [
            10,
            10
        ],
        'æ¾³é—¨': [
            -10,
            18
        ],
        'é»‘é¾™æ±Ÿ': [
            0,
            20
        ],
        'å¤©æ´¥': [
            5,
            5
        ],
        'æ·±åœ³å¸‚': [
            -35,
            0
        ],
        'çº¢æ²³å“ˆå°¼æ—å½æ—è‡ªæ²»å·ž': [
            0,
            20
        ],
        'æ¥šé›„å½æ—è‡ªæ²»å·ž': [
            -5,
            15
        ],
        'çŸ³æ²³å­å¸‚': [
            -5,
            5
        ],
        'äº”å®¶æ¸ å¸‚': [
            0,
            -10
        ],
        'æ˜Œå‰å›žæ—è‡ªæ²»å·ž': [
            10,
            10
        ],
        'æ˜Œæ±Ÿé»Žæ—è‡ªæ²»åŽ¿': [
            0,
            20
        ],
        'é™µæ°´é»Žæ—è‡ªæ²»åŽ¿': [
            0,
            20
        ],
        'ä¸œæ–¹å¸‚': [
            0,
            20
        ],
        'æ¸­å—å¸‚': [
            0,
            20
        ]
    };
});define('echarts/util/mapData/geoCoord', [], function () {
    return {
        'Russia': [
            100,
            60
        ],
        'United States of America': [
            -99,
            38
        ]
    };
});define('echarts/util/projection/svg', [
    'require',
    'zrender/shape/Path'
], function (require) {
    var PathShape = require('zrender/shape/Path');
    function toFloat(str) {
        return parseFloat(str || 0);
    }
    function getBbox(root) {
        var svgNode = root.firstChild;
        while (!(svgNode.nodeName.toLowerCase() == 'svg' && svgNode.nodeType == 1)) {
            svgNode = svgNode.nextSibling;
        }
        var x = toFloat(svgNode.getAttribute('x'));
        var y = toFloat(svgNode.getAttribute('y'));
        var width = toFloat(svgNode.getAttribute('width'));
        var height = toFloat(svgNode.getAttribute('height'));
        return {
            left: x,
            top: y,
            width: width,
            height: height
        };
    }
    function geoJson2Path(root, transform) {
        var scale = [
            transform.scale.x,
            transform.scale.y
        ];
        var elList = [];
        function _getShape(root) {
            var tagName = root.tagName;
            if (shapeBuilders[tagName]) {
                var obj = shapeBuilders[tagName](root, scale);
                if (obj) {
                    obj.scale = scale;
                    obj.properties = { name: root.getAttribute('name') || '' };
                    obj.id = root.id;
                    extendCommonAttributes(obj, root);
                    elList.push(obj);
                }
            }
            var shapes = root.childNodes;
            for (var i = 0, len = shapes.length; i < len; i++) {
                _getShape(shapes[i]);
            }
        }
        _getShape(root);
        return elList;
    }
    function pos2geo(obj, p) {
        var point = p instanceof Array ? [
            p[0] * 1,
            p[1] * 1
        ] : [
            p.x * 1,
            p.y * 1
        ];
        return [
            point[0] / obj.scale.x,
            point[1] / obj.scale.y
        ];
    }
    function geo2pos(obj, p) {
        var point = p instanceof Array ? [
            p[0] * 1,
            p[1] * 1
        ] : [
            p.x * 1,
            p.y * 1
        ];
        return [
            point[0] * obj.scale.x,
            point[1] * obj.scale.y
        ];
    }
    function trim(str) {
        return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }
    function extendCommonAttributes(obj, xmlNode) {
        var color = xmlNode.getAttribute('fill');
        var strokeColor = xmlNode.getAttribute('stroke');
        var lineWidth = xmlNode.getAttribute('stroke-width');
        var opacity = xmlNode.getAttribute('opacity');
        if (color && color != 'none') {
            obj.color = color;
            if (strokeColor) {
                obj.brushType = 'both';
                obj.strokeColor = strokeColor;
            } else {
                obj.brushType = 'fill';
            }
        } else if (strokeColor && strokeColor != 'none') {
            obj.strokeColor = strokeColor;
            obj.brushType = 'stroke';
        }
        if (lineWidth && lineWidth != 'none') {
            obj.lineWidth = parseFloat(lineWidth);
        }
        if (opacity && opacity != 'none') {
            obj.opacity = parseFloat(opacity);
        }
    }
    function parsePoints(str) {
        var list = trim(str).replace(/,/g, ' ').split(/\s+/);
        var points = [];
        for (var i = 0; i < list.length;) {
            var x = parseFloat(list[i++]);
            var y = parseFloat(list[i++]);
            points.push([
                x,
                y
            ]);
        }
        return points;
    }
    var shapeBuilders = {
        path: function (xmlNode, scale) {
            var path = xmlNode.getAttribute('d');
            var rect = PathShape.prototype.getRect({ path: path });
            return {
                shapeType: 'path',
                path: path,
                cp: [
                    (rect.x + rect.width / 2) * scale[0],
                    (rect.y + rect.height / 2) * scale[1]
                ]
            };
        },
        rect: function (xmlNode, scale) {
            var x = toFloat(xmlNode.getAttribute('x'));
            var y = toFloat(xmlNode.getAttribute('y'));
            var width = toFloat(xmlNode.getAttribute('width'));
            var height = toFloat(xmlNode.getAttribute('height'));
            return {
                shapeType: 'rectangle',
                x: x,
                y: y,
                width: width,
                height: height,
                cp: [
                    (x + width / 2) * scale[0],
                    (y + height / 2) * scale[1]
                ]
            };
        },
        line: function (xmlNode, scale) {
            var x1 = toFloat(xmlNode.getAttribute('x1'));
            var y1 = toFloat(xmlNode.getAttribute('y1'));
            var x2 = toFloat(xmlNode.getAttribute('x2'));
            var y2 = toFloat(xmlNode.getAttribute('y2'));
            return {
                shapeType: 'line',
                xStart: x1,
                yStart: y1,
                xEnd: x2,
                yEnd: y2,
                cp: [
                    (x1 + x2) * 0.5 * scale[0],
                    (y1 + y2) * 0.5 * scale[1]
                ]
            };
        },
        circle: function (xmlNode, scale) {
            var cx = toFloat(xmlNode.getAttribute('cx'));
            var cy = toFloat(xmlNode.getAttribute('cy'));
            var r = toFloat(xmlNode.getAttribute('r'));
            return {
                shapeType: 'circle',
                x: cx,
                y: cy,
                r: r,
                cp: [
                    cx * scale[0],
                    cy * scale[1]
                ]
            };
        },
        ellipse: function (xmlNode, scale) {
            var cx = parseFloat(xmlNode.getAttribute('cx') || 0);
            var cy = parseFloat(xmlNode.getAttribute('cy') || 0);
            var rx = parseFloat(xmlNode.getAttribute('rx') || 0);
            var ry = parseFloat(xmlNode.getAttribute('ry') || 0);
            return {
                shapeType: 'ellipse',
                x: cx,
                y: cy,
                a: rx,
                b: ry,
                cp: [
                    cx * scale[0],
                    cy * scale[1]
                ]
            };
        },
        polygon: function (xmlNode, scale) {
            var points = xmlNode.getAttribute('points');
            var min = [
                Infinity,
                Infinity
            ];
            var max = [
                -Infinity,
                -Infinity
            ];
            if (points) {
                points = parsePoints(points);
                for (var i = 0; i < points.length; i++) {
                    var p = points[i];
                    min[0] = Math.min(p[0], min[0]);
                    min[1] = Math.min(p[1], min[1]);
                    max[0] = Math.max(p[0], max[0]);
                    max[1] = Math.max(p[1], max[1]);
                }
                return {
                    shapeType: 'polygon',
                    pointList: points,
                    cp: [
                        (min[0] + max[0]) / 2 * scale[0],
                        (min[1] + max[1]) / 2 * scale[0]
                    ]
                };
            }
        },
        polyline: function (xmlNode, scale) {
            var obj = shapeBuilders.polygon(xmlNode, scale);
            return obj;
        }
    };
    return {
        getBbox: getBbox,
        geoJson2Path: geoJson2Path,
        pos2geo: pos2geo,
        geo2pos: geo2pos
    };
});define('echarts/util/projection/normal', [], function () {
    function getBbox(json, specialArea) {
        specialArea = specialArea || {};
        if (!json.srcSize) {
            parseSrcSize(json, specialArea);
        }
        return json.srcSize;
    }
    function parseSrcSize(json, specialArea) {
        specialArea = specialArea || {};
        convertorParse.xmin = 360;
        convertorParse.xmax = -360;
        convertorParse.ymin = 180;
        convertorParse.ymax = -180;
        var shapes = json.features;
        var geometries;
        var shape;
        for (var i = 0, len = shapes.length; i < len; i++) {
            shape = shapes[i];
            if (shape.properties.name && specialArea[shape.properties.name]) {
                continue;
            }
            switch (shape.type) {
            case 'Feature':
                convertorParse[shape.geometry.type](shape.geometry.coordinates);
                break;
            case 'GeometryCollection':
                geometries = shape.geometries;
                for (var j = 0, len2 = geometries.length; j < len2; j++) {
                    convertorParse[geometries[j].type](geometries[j].coordinates);
                }
                break;
            }
        }
        json.srcSize = {
            left: convertorParse.xmin.toFixed(4) * 1,
            top: convertorParse.ymin.toFixed(4) * 1,
            width: (convertorParse.xmax - convertorParse.xmin).toFixed(4) * 1,
            height: (convertorParse.ymax - convertorParse.ymin).toFixed(4) * 1
        };
        return json;
    }
    var convertor = {
        formatPoint: function (p) {
            return [
                (p[0] < -168.5 && p[1] > 63.8 ? p[0] + 360 : p[0]) + 168.5,
                90 - p[1]
            ];
        },
        makePoint: function (p) {
            var self = this;
            var point = self.formatPoint(p);
            if (self._bbox.xmin > p[0]) {
                self._bbox.xmin = p[0];
            }
            if (self._bbox.xmax < p[0]) {
                self._bbox.xmax = p[0];
            }
            if (self._bbox.ymin > p[1]) {
                self._bbox.ymin = p[1];
            }
            if (self._bbox.ymax < p[1]) {
                self._bbox.ymax = p[1];
            }
            var x = (point[0] - convertor.offset.x) * convertor.scale.x + convertor.offset.left;
            var y = (point[1] - convertor.offset.y) * convertor.scale.y + convertor.offset.top;
            return [
                x,
                y
            ];
        },
        Point: function (coordinates) {
            coordinates = this.makePoint(coordinates);
            return coordinates.join(',');
        },
        LineString: function (coordinates) {
            var str = '';
            var point;
            for (var i = 0, len = coordinates.length; i < len; i++) {
                point = convertor.makePoint(coordinates[i]);
                if (i === 0) {
                    str = 'M' + point.join(',');
                } else {
                    str = str + 'L' + point.join(',');
                }
            }
            return str;
        },
        Polygon: function (coordinates) {
            var str = '';
            for (var i = 0, len = coordinates.length; i < len; i++) {
                str = str + convertor.LineString(coordinates[i]) + 'z';
            }
            return str;
        },
        MultiPoint: function (coordinates) {
            var arr = [];
            for (var i = 0, len = coordinates.length; i < len; i++) {
                arr.push(convertor.Point(coordinates[i]));
            }
            return arr;
        },
        MultiLineString: function (coordinates) {
            var str = '';
            for (var i = 0, len = coordinates.length; i < len; i++) {
                str += convertor.LineString(coordinates[i]);
            }
            return str;
        },
        MultiPolygon: function (coordinates) {
            var str = '';
            for (var i = 0, len = coordinates.length; i < len; i++) {
                str += convertor.Polygon(coordinates[i]);
            }
            return str;
        }
    };
    var convertorParse = {
        formatPoint: convertor.formatPoint,
        makePoint: function (p) {
            var self = this;
            var point = self.formatPoint(p);
            var x = point[0];
            var y = point[1];
            if (self.xmin > x) {
                self.xmin = x;
            }
            if (self.xmax < x) {
                self.xmax = x;
            }
            if (self.ymin > y) {
                self.ymin = y;
            }
            if (self.ymax < y) {
                self.ymax = y;
            }
        },
        Point: function (coordinates) {
            this.makePoint(coordinates);
        },
        LineString: function (coordinates) {
            for (var i = 0, len = coordinates.length; i < len; i++) {
                this.makePoint(coordinates[i]);
            }
        },
        Polygon: function (coordinates) {
            for (var i = 0, len = coordinates.length; i < len; i++) {
                this.LineString(coordinates[i]);
            }
        },
        MultiPoint: function (coordinates) {
            for (var i = 0, len = coordinates.length; i < len; i++) {
                this.Point(coordinates[i]);
            }
        },
        MultiLineString: function (coordinates) {
            for (var i = 0, len = coordinates.length; i < len; i++) {
                this.LineString(coordinates[i]);
            }
        },
        MultiPolygon: function (coordinates) {
            for (var i = 0, len = coordinates.length; i < len; i++) {
                this.Polygon(coordinates[i]);
            }
        }
    };
    function geoJson2Path(json, transform, specialArea) {
        specialArea = specialArea || {};
        convertor.scale = null;
        convertor.offset = null;
        if (!json.srcSize) {
            parseSrcSize(json, specialArea);
        }
        transform.offset = {
            x: json.srcSize.left,
            y: json.srcSize.top,
            left: transform.OffsetLeft || 0,
            top: transform.OffsetTop || 0
        };
        convertor.scale = transform.scale;
        convertor.offset = transform.offset;
        var shapes = json.features;
        var geometries;
        var pathArray = [];
        var val;
        var shape;
        for (var i = 0, len = shapes.length; i < len; i++) {
            shape = shapes[i];
            if (shape.properties.name && specialArea[shape.properties.name]) {
                continue;
            }
            if (shape.type == 'Feature') {
                pushApath(shape.geometry, shape);
            } else if (shape.type == 'GeometryCollection') {
                geometries = shape.geometries;
                for (var j = 0, len2 = geometries.length; j < len2; j++) {
                    val = geometries[j];
                    pushApath(val, val);
                }
            }
        }
        var shapeType;
        var shapeCoordinates;
        var str;
        function pushApath(gm, shape) {
            shapeType = gm.type;
            shapeCoordinates = gm.coordinates;
            convertor._bbox = {
                xmin: 360,
                xmax: -360,
                ymin: 180,
                ymax: -180
            };
            str = convertor[shapeType](shapeCoordinates);
            pathArray.push({
                path: str,
                cp: shape.properties.cp ? convertor.makePoint(shape.properties.cp) : convertor.makePoint([
                    (convertor._bbox.xmin + convertor._bbox.xmax) / 2,
                    (convertor._bbox.ymin + convertor._bbox.ymax) / 2
                ]),
                properties: shape.properties,
                id: shape.id
            });
        }
        return pathArray;
    }
    function pos2geo(obj, p) {
        var x;
        var y;
        if (p instanceof Array) {
            x = p[0] * 1;
            y = p[1] * 1;
        } else {
            x = p.x * 1;
            y = p.y * 1;
        }
        x = x / obj.scale.x + obj.offset.x - 168.5;
        x = x > 180 ? x - 360 : x;
        y = 90 - (y / obj.scale.y + obj.offset.y);
        return [
            x,
            y
        ];
    }
    function geo2pos(obj, p) {
        convertor.offset = obj.offset;
        convertor.scale = obj.scale;
        return p instanceof Array ? convertor.makePoint([
            p[0] * 1,
            p[1] * 1
        ]) : convertor.makePoint([
            p.x * 1,
            p.y * 1
        ]);
    }
    return {
        getBbox: getBbox,
        geoJson2Path: geoJson2Path,
        pos2geo: pos2geo,
        geo2pos: geo2pos
    };
});define('echarts/util/mapData/geoJson/an_hui_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '3415',
                'properties': {
                    'name': 'å…­å®‰å¸‚',
                    'cp': [
                        116.3123,
                        31.8329
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„Â„nJÂ‚UXUVÂƒÂ°UÂ„Ã‘nU@mlLVaVln@@bn@VU@xlb@lÂšLnKlÂÂšÂƒVIÂ„JÂšUVxnI@lVL@bÂ„ÂŽÂ°VX@Â˜bÂ„xÂ„nVVUnVVnUÂ‚Â›@kX@VwV@Â„alÂ¥UUnUWa@Âƒ@wÄ¸UÂ„LUÂ¥lKUa@aUI@alLVaUÂƒÂ¯anÂƒWkUKm@XÂV@VaXÂlW@aU_UWVUÂƒIÂ¯@maÂ¯WÂ¯Â™Â™I@UU@WWU@U@@UU@VkV@@WUUm@UaU@Â„ÂlK@IUKÂ„L@KWmXUWaXI@Âƒ@a@a@U@U@KVÂ¥lwÂ„kÂ°bÂ²JVIVKlV@UXÂ„laÂ„Ul`ÂœUVLVVVUÂšJÂ„U@Lnm@_VK@KUIW@Â™J@Xk@WW@UÂ—ÂƒmÂmÂ™XmWk@ÂkK@aUUÂƒVmmkÂUwUmWLÂ™ÂÂ@WmU@Â™ÂUJmUULkKWakLWVkIÂƒlÂƒwULÂÂƒW@XÂ°lÂUJ@Â°ULÂƒÂWVÂ—wmJ@bmbÂ¯VkÂm@@WÂkWmÂ¯wÂƒL@lkXÂƒWmXÂymÂ¯UImJUbkVÂ™@VnÂ¯Â„@V@lUbÂƒ@mkÂ@maUxmlUbULWn@JÂ—LmKUkWKkwUKÂƒbmÂ„XÂ„WxkVUKmLkVVÂ@JUUWL@xkJUUÂƒV@X@VVlUbVX@xkÂ¤ÂšxÂ‚Â¼ÂœxWxnÂ„Â‚nn@ÃžÂ¼Â„JVbÂ°aVnÂ„@ÂšmlnXUÂ„JlbVlkz@Â‚lÂUÂŽlÂXJmxVxXnWxXÃˆWlUÂŽ@ÂšUxU@VX@xUL@ÂšUÃ†mLnV@lWXk@@JlbXblnlJ'],
                    'encodeOffsets': [[
                            118710,
                            33351
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3408',
                'properties': {
                    'name': 'å®‰åº†å¸‚',
                    'cp': [
                        116.7517,
                        30.5255
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nÂ°Â‚znWÂ„XlW@kÂ„KÂ°xXnÂ‚l@Xn@lÂ‚Â°Una@anIÂ˜xXUÂ„ÂŽVK@Â¯VIkÂWÂ¯X@Â‚Â„VKÂ„xÂ„klJXUlKXblLVKnVVIÂšÂŽV@XnÂ‚@ÂšÂŽXKVnVxlÂŽnnÂ„UlmV@Â²Ã³UkVÂ™lWÂ„bÂ„ÂlÂƒÂšÂƒn@VVVIn@lw@WVIXblVÂ„@ÃˆxÂ‚aUaVIVVnKVLÂšKÂ„Âƒln@bÂ²K@Â»UÂ£ÂƒÃ‘Ä·ÂƒÄ¡ÃÃ…bÂ™KÂ™a@Im@Ã›ÂÂ„Â@kWÃ“kkmKÃ…nÃ³JÂƒUÃ…Â£Â›W@wÂ„Ä•@wÄ‰Å£Â¯Â¯ÂƒUkKÂ±lÂ¯UÂƒÂ¥UÃ‘kÂÃUÄ·Â»ÃÂ¥Â¯ÂÂ™JÂƒIUÂŽVbUlÂ¯ÃˆVÂ¼VJUÂ¼Vb@bkLUl@Â„VJ@bUXÃ‡Âš@lkVmXmKkLVxÂÂšÂ‚ÂŽÂ„VÂƒL@VkVVÂVlÂzWÂ˜kbmLUUUbVbUVÂ™ÂšlÃ’nJlUnLllUL@bUÂ„VxÂ„lÂ‚LXVÃ†Â¦ÃˆVUÂ¦WJ'],
                    'encodeOffsets': [[
                            118834,
                            31759
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3411',
                'properties': {
                    'name': 'æ»å·žå¸‚',
                    'cp': [
                        118.1909,
                        32.536
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÂšÂ„@`nnl@Â„xÂšK@XÂ°KXVÂ˜IXVlbXVWnXÂ‚lL@ÂšÃˆÂ»Â‚LVan@VJÂ„ÃªVVn@Â‚ÂX@laÃžbVaÂƒyn@Â„_Â‚xnWVXnWl@VnUVkI@lÂ‚nXKVLVV@V@ÂkW@LlVÃ´Â„@J@bVnnKnkVa@Â»lÃ§@ÂƒnwÂšKmaÂ™UUUVÃ‘Âš@nÂ™mWXalI@alVn@VwUaVUÂ„@Â„nlaÃ´JnUÂ„VVXlJÂšaXXVK@UÂšV@VWx@nXVWÂšXVÂšUlLUbVÂ‚ULVVnUVbUbVbÂš@@aÂ„KÃ†nnKVK@U@UU@@aÂ„@VÂƒÂ°Â¯ÃˆJVIlÄ·@aÂaÂ˜ÂUaVKU_@mkxUI@aÂƒUlyU@@ÂÂ™wkKWmUbUnUVWbkJW_ÂJ@bÂƒn@Vm@@KULk@V@@bVbÃ…m@LW@UVVbkK@UkKWL@VULUKWIUJUbkK@_WVXUÂ›Jka@XÂƒVÂa@kÂšy@aVIUUW@@mÂ„UlLÂœKWÃ‘UKVan@UkVmmIXKÂƒaVaUwVU@UmykUÂ¯@Â±UUL@WUIVÂUU@KkIWaÂƒaU@kUUaÃ‡ÂƒUÂÃ³Â»mKÂƒkÂ¯@Ây@kWK@bkIÂ¯`mnÂ™lÂ¯XWlkVUzUJlbUbVJl@nnmÂ„@VULV`XnWÃ†Â—bmUUnÂ™JmUknÂƒJÂ¯km@Âƒyk@kUÂ›xÂL@VUbmnnÂ¤lX@`Â™z@JmaULUVl@Xn@xllkXWaÂ—aW@UVmUÂbÂƒ@mVXÂšWxXbWbUÂŽÂƒÃ’nVVnVVUL'],
                    'encodeOffsets': [[
                            120004,
                            33520
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3418',
                'properties': {
                    'name': 'å®£åŸŽå¸‚',
                    'cp': [
                        118.8062,
                        30.6244
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Vb@Â„XLÂ˜JXxlIXxlVlV@IÂ²Â¤ÂšnlUnVÂšU@VULWVUJ@Lnb@lV@UnV@@VVVlLnbnJÂ‚UVkUUVWn@@anUVnVJVIVÂ‚Â@@nUJVbUbÂ‚Â„@VUbVK@bn@VbnIlxkllXVlXKWUXUlLÂ°Â¤UVVb@bÂšÂ„UlkXWÂ‚ÂƒxXz@Â‚Â„IlaÂ„UlÂƒnUlJVInVÃ†JÂ„UÂ„LVUnVÂ„KÂ°@VnlVnxV@XLlK@wVL@KnUlJXUÂ˜bnKVLXÂ„lÂUw@ÂVWlLXKm@@aÂ„@VLnmlIVVnKn@ÂškVaÂšVlwk@@a@k@ÂƒVIUaÂ™Â@ÂmaUa@wna@kmWÂƒÂ™UUmVUIVÃ‡Â—Â@aÂƒKmÂÂ™aÂƒÂ™kUÂ™J@InÂmUUaVaÂ„kÂ‚lX@Vk@m@ÂVU@wnK@alKVUkUkKÂƒbmUkmÂƒ@UÂ£WVk@@UÃbÂbÂƒaÃ‡x@bÂ@WVUaÂ¯Âƒ@wVwUUV@VwnK@KWaÃ…Â@KÂšIUyUI@WmXÃ³Â™UbWaÂKmÂÂ™@km@IUyÂƒIUaWKÂƒx@zUKUL@llVUnkLVVkJWX@VUKUVÂƒIkVWakb@VWb@n@JkXUlmL@xkL@`VxÂšLUÃˆUJ@Vm@@bmIUlUL@VUVVbknm@mKUwÂ™KVÃˆ@J@LÂVÂ±kkJUIÂƒl'],
                    'encodeOffsets': [[
                            120803,
                            31247
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3412',
                'properties': {
                    'name': 'é˜œé˜³å¸‚',
                    'cp': [
                        115.7629,
                        32.9919
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VÂ™nÂƒÂš@ÂšaÂ„kÂ°aÂšÂ±@ÂÂ‚Â¥@UUI@aUmlwUUÂxÂ›b@Â¥XU@mmI@a@Kn@@_W@@WÂ„I@mÂšUVVXUl@XaV@Â‚K@I@aÂ„LXÂ@aVIÂ°K@KVLÂ„UUwÂ‚yXkÂšK@kÂšKÃ†bXnlK@k@aÂ„JlU@w@U@Â»@aXKWÂƒn_Â‚JXkVKnÂƒ@ÂÂ°LlKXÂƒW@Â¯UÂƒÂ@aUK@kmJUwÂ™VÂƒIUJÂ™Â„kÂŽmLÂ™K@kka@wUVm@@am@UkUbkK@nmVÂƒÃ’Â¯VUÂ„WVÂVmIÂƒÂƒULk@ÂƒÂƒma@kkKÂƒÂƒ@nUbUamUÂ™`UUVUkKVkkÂƒW@@bkmÂƒnÂƒmUXVKXVÂƒL@VÂƒbUÂ„mÂ‚Â™bVXÂJ@nmKÃ…I@KWKUXVJUL@VUKUX@KUKWL@LUJmaXXm@kVVV@L@VUL@VlK@L@V@LUK@VUb@UUU@Â°@nVxU`Â‚Lkn@`@XVJ@XÂ™VmÂ„k@UKmVÂ¯LVVÂnÂ±WÂÂm@Ub@JlLUlÂ„@VLkÂ„@lmVVn@bnV@VÂ°IVÂ™ÂšaVJXIÂ°KÂ°V@XXVlVVUÂ„nÂšKVlUÂšÂ„bWXnV@bV`UÂ„Â„@@Âm@@Â‚Âƒ@nxmn@bXVlL@Â¤nbÂ„UlÂ¦ÂšVVUnJVUÂ„Vl@@bÃžL'],
                    'encodeOffsets': [[
                            118418,
                            34392
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3413',
                'properties': {
                    'name': 'å®¿å·žå¸‚',
                    'cp': [
                        117.5208,
                        33.6841
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@UWU@bkW@aWU@aUIkWVÂ™lLXbÂ„lVIUVV@Â‚mn@V_n@VaUK@IÂ‚@UaÂšanJVUÂ„@lVÂ„UVnnKVVlaUaÂ„I@wnKÂ‚Lnll@nVlk@wVKXkl@@bÂ„bUJ@VÂ‚U@UÂ„UUyVk@aVUXwlWXXÂ‚WUÂ¹@aUÂ™@WUI@mlUÂšnÂ„J@Il@ÂšaXbV@VKl@XxVL@WÂ„IÂšJlbÂ„@Â„al@Â„IUUm@@aVK@Â¥Â¯Â—@mUÄ·Â¯bWÂƒkÂ£Vm@aÂkm@VaÃ…@UVWaÂƒ@UÂÂJWkÂƒJÂ—UÂƒbWbU@UlÂƒXk@ÂƒamV@KÂ¯nk@ÂƒlU@Uxmz@bU`Ã‡bUbÃ…VmÂ£U@WwÂ™x@akLUK@UlakwUJWVkLmaUal@n_ÂƒmVUnKVUUmÃ…XWaÂ™@kJmx@XUJ@bVLXxl@VVUVVÂ„UbkLWbU@@lUVVÂ„VVXÂ„Â›K@XkJ@nU@@bV@VxUVlbÂ„U@xXLWÂŽn@UxVbVÄŠÂ„V@b@XV`mnkJ@kUKmbÂƒaU@VbnbÃ†x@XU@@`k@@blÂ„Â™@@bkL@WÂƒakXWaU@Vmkx@XWW@Â@wUUUbÂƒJÂ™UÂ¯VÂ™@Â¯ÃžU@WxXÂŽlL@bkb@ÂŽlVlnÂbÂ™JW@kkU@mbkaWJÂ—IVlmzÂ¯`UnU@mbÂ™@@Â„Âƒ`@bkVlÂœnV@b@ÂšV@Â„aVxn@VxÂ‚KXnl@nbVKÂ„bVK@aÂ„_V@VÂƒÂ„w@WÂ„LlwnK@UmIU@VWÂš@ÂšUÃˆ@lKnalÂÂ„wÂš@@VÂ°@ÂšaUmlUUw@ÂÂ„ÂƒV@@UXK'],
                    'encodeOffsets': [[
                            119836,
                            35061
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3410',
                'properties': {
                    'name': 'é»„å±±å¸‚',
                    'cp': [
                        118.0481,
                        29.9542
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lXnlWX@VUJVnUJVzXJVxÂ„kVJlIÂ²lÂ‚U@K@IUÃ‡ÂšLVxnLn@lmUaVU@UVKVknJ@an@@UVIVÃ‡Â™KUw@_lK@wnKVklW@I@mXa@UlaXblUÂ„JVUVL@UXWlIUUlKVmkU@kVKVL@yÂ„wXLVbÂ„JVz@JlnÂš@nÂŽÂ‚LXbVaÃ´ÂšnW@Âla@UVWUa@Â@a@mk@WIk@VwUaÂ¯Â¥m@UUVK@ImK@aXÂ£ÂƒÂkKÂ›Ã…ÂVÂ™aÂ™Â™Âƒ_@Â±ÂƒakXWWÂ—LÂƒÂƒÂƒnU@@a@Â¯mK@LÂ™JÂUWwUVÂ™VmbXX@lWLn`mzUJUbÂ™LÂƒÂ„k@makVWmkXÂ™ambkKknÂƒaÂƒ@ÂƒaÂƒb@Â‚U@Unm@Â—ÂƒWVÂƒ@ÂÂVbUbUJWIk@@lmL@Â°UVUVmÂ„nÂšÂ™@@kmWkb@xÂƒ_m@@aU@Âb@JlÂŽUzÂ™lWxXnÂ„@Â‚bÂ²@l`Â„IVlÂ„UlL@VÂšKÂ„nVbUl@VlIn@@bÂ„bVWUkÂ‚@@bX@Valb@bnbÂ°Vn@Â„xVKlbVnÂV@VÂ‚xÂ„L@ln@UXVVÂ‚LÂÂ˜'],
                    'encodeOffsets': [[
                            120747,
                            31095
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3414',
                'properties': {
                    'name': 'å·¢æ¹–å¸‚',
                    'cp': [
                        117.7734,
                        31.4978
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VV@blL@ÂŽXlWnnÂšnÂŽÂ˜Â„@VXXl@@WÂšIX@VJ@LÂšxÅŽxlnÂšÂŽ@bXJVblX@VVbUVn@VbUVlb@LnJVbVLVÂ‚XLÂšÃ’VLÂ„Ã’ÂšVÂ„bVIVylUXkÂ°WÂšknmÂ°_lJ@aXL@lÂ‚zÂ°@Â„lnLÃ´Â¼VÂ‚ÃˆÂ„VUUaVKUÂ@WW@@UUa@knmVLlaV@Â„a@kÂšakÂ±@UmwkKmkÂ™Ç‰Â™ÃUUkL@mlIVmnÃWkkUÃ@ÂKÆ‘Ä‰Â™a@Â»ÂƒmmaÂ@mXÂ™Â¤Â¯UÂƒw@Âƒ@ÂUU@bUÂ±Â±L@akmÂƒÂ„Â™LUKmLUUUJVbÂbÃ‡wÂƒ@kUWaUJ@Xkxm@UJUUm@Â™Â„kÂ„ÂƒÂ‚ÂƒakXUÂšVlÂ±Ã´U@kn'],
                    'encodeOffsets': [[
                            119847,
                            32007
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3416',
                'properties': {
                    'name': 'äº³å·žå¸‚',
                    'cp': [
                        116.1914,
                        33.4698
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lU@Un@@anUlw@KVmUwlaX_lKna@KU@@kWKUU@ankWÂ™XKÂ˜@@VÂ²VVIÃˆU@al@VaÃˆamK@wUÂ™@klaUÂƒV@XÂƒVUUÂ»WUUbkmUkVÂmk@aÃˆw@mWU@VkIkVWKUÃ‘Ä·XÈ­ÂºUÂ¯lÂƒ@kkLWmÃ…aÂ™L@lÂ™LWlÂzVxÂƒVUK@LÂ¯LUJ@bWÂÂƒK@b@JÂLU@Wbk@WVUUÂ™V@nÂƒJ@XX@@`m@@L@bnJ@nWV@Â¦ÂœaÂ‚wVVkxVn@bVJ@VÂÂ¦@ÂŽÂ™Â²Â¯bÂƒlÂ™bÂ™@mÂ„UÂšUÂŽÂƒÂŽ@Â¼ÂƒÂ¦XbÂ‚UV`@nnxUxWLkUkVWKkV@XV@@VVL@VXÂ„@lVV@L@blL@`ÂšL@xXKVLÂ‚@Â„VnUÂš@lwnU@ml@XnV@@UVWÂ°LnalÂƒUI@aUK@aÂ‚a@UÂ„kXW@I@mWL@UXK@UVW@UÂ‚@@kÂ„WnÂÂ‚@@VÂ„@XblaVxÂšL@bVKXbÂ„IlJ'],
                    'encodeOffsets': [[
                            119183,
                            34594
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3417',
                'properties': {
                    'name': 'æ± å·žå¸‚',
                    'cp': [
                        117.3889,
                        30.2014
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': [
                        '@@Â„VÂ°Â°ÄŠÅ¤@xÂƒÄ–@xÂœXÃ†Â¤Â„VÃ´IÃ†mnLllXÃ”@lÂƒÂÃœÂŽn@@JÂšbÂšLÃ†aÄ¢ÃžÄ¸Â„Â°VVUUKVanK@UV@VLÂ„VVnÂ„ln@Â‚xnklxXamk@WV@XaÂ˜@naVkÂ„KlÂkÂ™@mkUWwkJWwÂ—IWK@ÂƒUaUwWIUyVIUmVI@UXWmkkWÂ‚Â—ÂKUUVWm@@kÂƒKÂw@UÂ‚UUmkaULÂƒwm@Â¯Uma@akaUbW@@aÂ@VlUXÂƒa@am@kJ@UVkUaÂƒmÂ™L@UkKÂƒVUkÂƒJk_Â±@ÂaÂƒ@WmXwÃ‡kkaVaUaÂ±ÂƒÂœwV@VkÂƒwnyUaW@UUÂ¯amLk@mÂÂ™@kmmUÂ™Â™Â¯K@L@lUXÂ¯ÂƒWlkXÂƒÂŽVbÂ„bÂƒVUL@J@LVKnÂlJXnlb@`nXlalV@bnL@VnbÂ˜Â¼@lXbWlkLÂ™K@zUJmIUxUVUVmX',
                        '@@llUL@VlxÂšL@a@UÂƒwXaÂ¯@'
                    ],
                    'encodeOffsets': [
                        [
                            119543,
                            30781
                        ],
                        [
                            120061,
                            31152
                        ]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': '3401',
                'properties': {
                    'name': 'åˆè‚¥å¸‚',
                    'cp': [
                        117.29,
                        32.0581
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„LÂ„xVÂ‚ÄŠLÃžkÂšVlVVÂXaWaXwWÂ™nUÂ„@Â‚anVVUX@Â˜bXblWkk@wWmk@VUVKnb@IÂšy@_kWmÂ£nmVa@UÂ‚KÂœwlVl@Â„zn@Â°lÂ„IlmnVÂšIVmnVÂ˜aXÃ…WmU_VK@UnÂƒmmk@UIVakaÂƒaÂ™UÂƒÃ‘UKÂ™Ã‘WKUÂUKUamI@KkaVUUam@VUUa@UkWUaWI@aÂ™ÂkmÅwÂ™wUL@`mn@KÂƒVÂ™IUVUUUKÂ›Vk_ÂƒVkbWÂƒ@VkUULUJÂ±IÂ¯aÂƒlkxUÂ¦@L@V@V@b@b@Â„WJXbWVXn@LÂƒKVL@JkLÂƒÂŽV@Vbn@VV@XU@UlV@@VV@V@XXV@@VÂšJÂ°ÂšÂ°XnbÂ°@Â„JUVVXV`@bkXWÂŽUbU@WÂŽn@VLXlmÂ„Â°bVÂ„UbkK@bVJ@bVbkLVÂ¦ÂƒKÄ·V@x@Â„XbmVVVkÂ¦'],
                    'encodeOffsets': [[
                            119678,
                            33323
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3403',
                'properties': {
                    'name': 'èšŒåŸ å¸‚',
                    'cp': [
                        117.4109,
                        33.1073
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VÃ’XLlUlJ@UXV@nÃ‡x@bnlUÂVllnVaXVVÂ¼UVWÂ„U@VÂ„Â²wVV@Vl@Â„VnwlIÂš@XbÃ†WVnUVmLUVÂ„nm`k@VbnblKXUVIlxkb@VVLlK@bÂšwXxV@nÂ¤Ã†UVaÃˆaV_@anyVwV@Â„kl@Â°m@LnUÂ„bl@Â„WVkV@XaÂ„aÂ˜VÂ„IXlÂ‚IVÂ‚Â„@XbVUÃ†@XKWwUkmW@_UmnIlJXkWKXmV@Â‚w@_XV@Kl@kU@KlX@Â@UUUUKWLÂm@klJVUUmk@mXUWmXÂwÂƒ`m@Â„zUbÃakbW@ÂÂm@UUÂƒÃ©UIm@UbÂKÃ‡Â¼@Â™kKWÂXmWUkaWUÂ—JWUÂ¯L@WÂ™LÂƒwk@mm@_Â™ÂƒÃ…lÂ™UVkmWUnÂV@VWLUbÂ™bÆ‘Ä¬Â¯l'],
                    'encodeOffsets': [[
                            119543,
                            33722
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3402',
                'properties': {
                    'name': 'èŠœæ¹–å¸‚',
                    'cp': [
                        118.3557,
                        31.0858
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„bVaV@XllLXUÂ°ÂŽlL@V@VUnVlÂ¯IkÂšÂ›VUVU@@b@lUXUWmbÂ„n@Â¼ÂšbÆ’ÄŠÂ‚LÃž@lVXlmÃžUnkJ@nlKVVÂšÃžXklWVaVI@aUKnÂ»lL@Kn@Â‚XXwlm@mnÂÂ°@Â„V@ÂWyÂ„wXÂlWVkÂ™Âƒ@aUaVUÂ¯Â£kKWVXVWLUkkWlkkwmJUam@@aULVa@UÂÂƒVaUaVI@mÂ‚@UÂUJUIUmmV@bm@UXVVUlÂVmImakKUU@UU@VmU@@kma@KVIXUVK@UÂ™VmUkVÂ™mÂ±Â£@JkU@nlÂškÂ‚ÂƒLUlmbÂ—@WbU@@XnlWb'],
                    'encodeOffsets': [[
                            120814,
                            31585
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3406',
                'properties': {
                    'name': 'æ·®åŒ—å¸‚',
                    'cp': [
                        116.6968,
                        33.6896
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@lnnK@Â¦n@@VÂ‚VÂ„@@VV@nIVÂ„V@VWÂ²a@b@bVnUVVV@VÂ™z@lÂš@Â°UÂšVÂ„IVaVV@x@ÂŽXX@WlwUnV@XblWÂ„b@XlK@aÂš@kÂƒ@al@@_V@@WÃ…wmaUaV@Â„bnaVL@llInmU_@W@aÂƒUUÄ‰UaVwm@XÂWK@wÂƒVkaVUUwU@@aV@@mlI@WÂœLWÂƒUUUÂƒVU@kV@XalKVaUÂƒVUUUk@WwUK@aVI@WÂƒUk@@UUUÂ±xkb@lVÂš@xnLÃ‡bUbk@@bÃ‡VUJÂ±U@UÂ—@WLXÂšml@bVVXL@lV@@LmbkLW`kbVxUn@LkxmV@bm@@VkV'],
                        ['@@VVVkV@ÂÂ¥@UV@U@VUUJÂƒkWakKUÂšlXVJ@bXV@blX@aXV@V']
                    ],
                    'encodeOffsets': [
                        [[
                                119183,
                                34594
                            ]],
                        [[
                                119836,
                                35061
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': '3404',
                'properties': {
                    'name': 'æ·®å—å¸‚',
                    'cp': [
                        116.7847,
                        32.7722
                    ],
                    'childNum': 2
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â°kÆ’Ä«ÂšaVaXK@UÂ‚UVmnXUlÂšVÃ†kVKUUUmmUÂ„Ã‘kUÂ™UÃlÄ‰KUÂÂƒwÂƒKÂƒbU@UxW@@lÂÂœmVUUVmUUÂƒmÂƒwÂ—aWÂ„kLÂ¯K@ÂŽmÂ„ULWlÂIm`XÂ„WL@b@Â¼@V@xkVÂƒI@b@l@lkÂ„VÂ°È®Â¹Ä¸W'],
                    'encodeOffsets': [[
                            119543,
                            33722
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3405',
                'properties': {
                    'name': 'é©¬éžå±±å¸‚',
                    'cp': [
                        118.6304,
                        31.5363
                    ],
                    'childNum': 2
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÂšÇŠnllLnxV@laXLVKmaÂ„aXbVIÂ„bVKVVVIVyn@n_ÂƒÂƒW@@ÂƒÂ„UnJlUVVXÂlLnaUWlÂV@VVÂ„IXW@_W@XK@K@UVUUwVamÃ‘XmmwÂƒwÂ™KUnUKÂ™Ã§U@ÂƒJÂƒUÂ¯@mÂŽ@nknWxÂWm@@LkKmÂ¼VL@bUJUbkXWl'],
                    'encodeOffsets': [[
                            121219,
                            32288
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3407',
                'properties': {
                    'name': 'é“œé™µå¸‚',
                    'cp': [
                        117.9382,
                        30.9375
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@Â„Ã’VÂ¤@Â¼VÂ²@aVV@ÂŽ@Â„Â„xÂ°VÂšÂ£nWÂ‚@nbnaVXVW@k@aV@VUÂœUlÂ™Â°JUkVm@U@UkKÂ¯ÂWVkKWkU@UbÂƒakwmlÂwm@ÂƒkUmÂƒUUKU@@VmLUbVLUVÂ¯U'],
                        ['@@ÂLllUL@VlxÂšL@a@UÂƒwXamK']
                    ],
                    'encodeOffsets': [
                        [[
                                120522,
                                31529
                            ]],
                        [[
                                120094,
                                31146
                            ]]
                    ]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/ao_men_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [{
                'type': 'Feature',
                'id': '8200',
                'properties': {
                    'name': 'æ¾³é—¨',
                    'cp': [
                        113.5715,
                        22.1583
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@HQFMDIDGBI@E@EEKEGCEIGGEKEMGSEU@CBEDAJAP@F@LBT@JCHMPOdADCFADAB@LFLDFFP@DAB@@AF@D@B@@FBD@FADHBBHAD@FAJ@JEDCJI`gFIJW'],
                    'encodeOffsets': [[
                            116325,
                            22699
                        ]]
                }
            }],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/bei_jing_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '110228',
                'properties': {
                    'name': 'å¯†äº‘åŽ¿',
                    'cp': [
                        117.0923,
                        40.5121
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@vIHZDZQtDLNMXIbHRCXXITbJ@H`LGPRDDJNCLHTOCWFGvGBUJMKGFO^IHWXITQCIÂ’Y^AXGfRÂˆDXF`DJOLB~G\\DZIHHpErUVMhHb]\\MÂ†BVF@FTP`@zTbD\\@~M\\K`H^EVODWICAakAQXoIcCOCIgGYNWFWNGGKKGaJEGMEIKYJUT_J_Go@_SyQaSFMEGTcYOQLIIi@EKAUPCV[EEXQCW|aMUMAaYCYNIDGGACIMGGSKDQGaF_C[GaB@GOIiOKAYLÂ“mI@CN]F[SWWAcKKI@HMUimEKbeYQYISNUOcBKPIFBNgvDPGZYFSf]CMSIWGEUFgDIQ[MeDMJS@RR@LphFPCHaBAJKF@J]IBJO@HlO@@RKAMPJHCNDJTHFP@ZGNANBRFH@J_fM^ONJNF\\VTDJHDON@XÂRND\\XRCPVETCLBVKDFJINHRGPRV@\\CLJN@VbXbLVT'],
                    'encodeOffsets': [[
                            119561,
                            41684
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '110116',
                'properties': {
                    'name': 'æ€€æŸ”åŒº',
                    'cp': [
                        116.6377,
                        40.6219
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@JHTVHXCHPfnDJGHNDJSB[JSBGVSAOH@PMPuDEHHXZN@PHF@ZLJ@LHVYJA\\OFWP]BMtMBSRGV[JeVAPQVIFENMDÂ¡Â–@^NV\\JH@NNL@NM\\kTQ\\I^FNIpBHGTBFFAZQfKDIXQTLXFXNNVMVHRGpCFLlRLEVBBH`IVO\\G`RDPAXLXBXORHZEHTDLLN@VGTMrQNFPeASKG@GMOAKBYMK@GTUHUXSHMVDNMOUEOZMJML@^KRACMZEZMRQLUHE@OFENPR@DI\\ChMHIDG\\GJMDWHCKGMDCIQCHO_K@GaIJSWWQDaGWJMNCKRsCYGYuJUSaKaW@UIMDK@[QUHOGQJMEILCAUDKFSOUQD[WMCÂ‚Q@WPMGCCIUSE[IMPMN]`e@IEGAQBMHM@YEOSGCIDMIGNOLB@QP@GkP@AI^J@ILEBIbADGEOog@KQQWSekWQQUOFKZLF@PUNmIaHIUeBCTSHENcJa@_IWSaGu`GLSBKJQFOXGDXVQVOBIHcDSJWBEFGTMH[^mLaXcHiKElTRKtFXZ`MHMPCNRDxZÂˆB\\ICIHK@KÂŽHbIVFZ@BPnGTGbDXRDJaZKRiGEFSFEJhjFNZFjn'],
                    'encodeOffsets': [[
                            119314,
                            41552
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '110111',
                'properties': {
                    'name': 'æˆ¿å±±åŒº',
                    'cp': [
                        115.8453,
                        39.7163
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@h@bl@HRJDZ``TA\\VVD^H`\\pF\\JÂŒ`JGv@ZO\\GPSTEjPTR`FnEbDTDHEhLFMTK@ETSPULKEI@OVISKSJACEQNQbVÂ˜IXGDIN@dMB[IIBcN]ZHNLP@XOWCFWÂŠCNRHTpATD@^NVNLED@Rh@jCEF}E[OOHUEW]W@QGGDIQSH_MmFmCUT_K]i@MHÂCMWÂ—FCFÂ‹E{BMHMPOHKS]CFNGBELDH_@BcAKOACESAOBELaXAROB@FODMEDWJAG[aE@UM@DImEWJMC@OeCA{aE[@{L@MINUCQXKfUJORCHqJBF@TCXWNQX]M[EAJO@@KMBQJIC]EWMCCUBEBFHKDOTMBGNGF]MWDBRDdMDQVyE@LPVHDCP@JVVMTG~HNSH[CmRUvHPHBbA\\PTNRC\\YNJÂ€PRARPJDDR'],
                    'encodeOffsets': [[
                            118343,
                            40770
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '110229',
                'properties': {
                    'name': 'å»¶åº†åŽ¿',
                    'cp': [
                        116.1543,
                        40.5286
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@^AXOPEB[ZIGU@KKI@YGE@OYMGWFGvCNO@OPGTBHUTA\\ITACIGMIHmCOeDGGWSUIGimYEEMgiFITEFEjHLQbYCIWQaCSHmHAOY@UEaJÂG@LGLDJ[JÂ‡AwYQCDMNONGY_EWLsSQFkMO[NWAIGaIYL@HMBOKiOQDWEUDMQSF_QIUBWdg@[NaAKQ@M]OQ@WhgLUMMFYQDIRCEUZOOCIOJ[KIUMKL@HIDKVEBM`HJAJSJUdBLGNEdMBMO[BYEWJSNKNaD]PE\\SjOT_RQVEZPpÂƒNQXfÂŠNA~lNG`@PNLpÂ¼RFLfbdKbATUh@FSNWjGFZVLFHVA~XÂ¨PPROfFJbNJPLFbENJPrEFNPFRHDDJdENJLVEPBJTVTHGHFRFH@PXP\\ORQHW\\BjWFDERLPPBbB\\E`B\\D\\L`@F]FCnJ^AZL'],
                    'encodeOffsets': [[
                            119262,
                            41751
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '110109',
                'properties': {
                    'name': 'é—¨å¤´æ²ŸåŒº',
                    'cp': [
                        115.8,
                        39.9957
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@V@XMnGPYÂ²Â‰JQNEhH\\AZMPDVTTDZCPiJkHSHCjIdFtEHITCNITQEKUAMCEIKCECABYESKFWAKBEIIHABGDCKCAIHMHALKEI\\CFIBILIJQZS]BBEECS@E@@C]COKI@CABAAEEDMGÂƒCH]A[M@CJWHÂ—JaUMRFRBDTITLUJ@PFJKLOVST@FSLENgKGFSCaCmF_ESQiOSFOT[HYPu@IHÂ‹_[IoE_[]GUC[USB__CYQI@Gakg@qZeHQNMNV\\FVLPgJAFJPRLCH[XcPELUT[JiV_EELFTADBXRTRLJC@fHXHHbPd`fR@NfT`@TLplHMpCEJHJBVLFÂŽ@JTÂ‚VnG^KXDXHNVGRLRXFJVdDHSNWLGfEzA'],
                    'encodeOffsets': [[
                            118635,
                            41113
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '110114',
                'properties': {
                    'name': 'æ˜Œå¹³åŒº',
                    'cp': [
                        116.1777,
                        40.2134
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VNLJI\\JPPDYPFVQDCJZRNEVNhKXgR@^P@NLRbB\\Mh@XcVARJE`RTCNFVÂ€XRCjPPLNA@GZKbJJHXB\\MNPjLdGbWnK\\]NGHSFEXATIdCJGPARUWUHCPWRELITAHKv_E@iYCaW_BQ\\Y@QIO@QDCIGZCEMWGFMFAFgHEDOCSqKCCFGAMKEAC@ODGCGs@WH@KQA@EE@CE@GEA@EH@GGUEEJEAYD@JM@@DAA@FHD@FTJEHUC@JUBKCKG@G[CIIQReAYhO@OXGDO@@FF@IHJFCPEBACBIAAKDOABXARHPÂNEHGbQAAKQFGIAM[C@WHKaGiCEGOAÂ‹HUKCIokSCUSOCYN[BgGMFIRÂ±ÂŠOZmHWNU@ShbbXDHVXXGJ^lZ@PZ\\Nb@\\FHJAD'],
                    'encodeOffsets': [[
                            118750,
                            41232
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '110115',
                'properties': {
                    'name': 'å¤§å…´åŒº',
                    'cp': [
                        116.4716,
                        39.6352
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@F\\E~DFN@BDFEpHFCHBBEGCDCJBHUDSBB@ELCPbF@B\\J@BJVAFJ\\ADKTCBGECFMT@BMN@@FH@DaNBEnvB@FPBATK@FHEFIAKFBFL@@PKBFJHC@FXBRAFCDMPDTOL@JIVFDHH@DDH@BGRFCDLD@N^@@CNA@KNOAEBCECFEGCFGMGFIPMOEJOLBADBBHGG@GCHIECY@INC@DMGS\\AIOZAAEYA@GT@KKMBEETCGMVINFxA@MJADB@FlA@HJA@NND@DFA@DVAZBBOFKH_JA@K^GBC@EFEÂ„G@gAENMXKJigC@IbSJMqGOPÂ£RGSMGE@kbQFDPEFiBSGGSBK]I{CDWCIDOic[C_G@SuSO@EWKCO@MNY@\\uZOPENQD[LKESSKGBKEG@EJGAGHoHÂ¥CqhifeJkX_XFFGHFNEDFPENKHM^IFIVL^S`DVEnNnG`RTCJHH@R^XFXGVPP'],
                    'encodeOffsets': [[
                            119042,
                            40704
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '110113',
                'properties': {
                    'name': 'é¡ºä¹‰åŒº',
                    'cp': [
                        116.7242,
                        40.1619
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': [
                        '@@EhEBENXHFNYDJHCD@RJP@R[ZARX`DbjZF@bHXT`Jb@dIFMTGDSfAJVbGnJVM@OKELYPERVXRflXTT@NIfC\\NJRhCVEHFJXNT^DTeZEHYCOhuAMJELOdAVPTMOWBWNMNEJgl]@WGUFIC[T{EEDEHGCIGMI@SECUQI[D{A{GQESPUH]CsiMCmHUeoHENcAaDGCMDGMQCACCBaCGLMAHB@DIEQLOAAEEJ@CW@CDINGAAGKQOCgV@LG@BEGDKNeREFBNCFIDOPKD[@YRW@GFWDAFE@EHDDrLDTCPGF',
                        '@@KrJEH[\\B@FF@CHFBHUNÂ‹AJKADGECBCMAG^E@EbI@BEGP'
                    ],
                    'encodeOffsets': [
                        [
                            119283,
                            41084
                        ],
                        [
                            119377,
                            41046
                        ]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': '110117',
                'properties': {
                    'name': 'å¹³è°·åŒº',
                    'cp': [
                        117.1706,
                        40.2052
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ZJZRafFLjnÂ€VGNJ@LLBdXX\\T^EDMJ@Â”nZKLBjPPJ@HbA\\H`DbERHLCFK^BZaFWXQLAGMHa\\OLO@SBIpBdCLÂƒVQfElO@GSAKEDQTC@GEBKG@ORIJBDAPDFA@CaOq@GGQAAEJK@KMUGAAGEAa@MGMBGCGSIIW@WSUCMDOJeWOM@IUF{WMWaDIMgIoRoCOKeEOEAG_I[cg@wLIFENQFDVTFJ@HNDJGHCFFFS|D\\EJHV@Xk^IhMFMNAXPX'],
                    'encodeOffsets': [[
                            119748,
                            41190
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '110112',
                'properties': {
                    'name': 'é€šå·žåŒº',
                    'cp': [
                        116.7297,
                        39.8131
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@FDAJTGDNDCTDDEDBBE@DT@@EHCDGJ@EIZ@@FDBR@ATFBBVFFE@@HNA\\VE@CLIFNJFNJBCP]A@LJFA@HJEDD\\C@DBCHLAEPF@@DH@APHAERDF\\GIxDTM@CFLBBFJ@CNUPMHECGDBF]BMFPDLRBHHBJMDCX@@DFIBFPBRKJF@CGANBHKbDDABDRDHNNCHDbCdBFMpGHiOYMefKJMC}HWAUNW\\NNBNAÂ„kNU|]HMTMN@MZBLFFF@RIRUTÂ‘BMFIEGaAGGAOIIUGTSFcYKS@MSLYPKRUBU]EWDOI]CKGASgW@MTWKIMCS@uMAKKADMECGAKVUTSDy@IjWLMNBF@hÂƒHEF@FAD]H@LIBG`ELAPYAUB@CEB@CMC@MIB@GkB@ECAIB@NwBMEUJHNSDFFNALLS@@HZBBFYBJP[BHTCND@JMZ@FDGJHDH@GHAABCKAIPPFONEJNHEHHDEFFDADBFMP@L'],
                    'encodeOffsets': [[
                            119329,
                            40782
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '110105',
                'properties': {
                    'name': 'æœé˜³åŒº',
                    'cp': [
                        116.4977,
                        39.949
                    ],
                    'childNum': 2
                },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@bFGHBHFBFIVFHHG@@FFB@HDFF@@FRB@LXGt@DHCH@PBDLFBNF@BEXCHEX@ZQ\\@LCPOJCDEAMFEfQLMHCAFH@@KhUNE^AAEHCFDNGVODMI@AEKADEN@CSJw[HCEFQGBBOG@@CE@FOKBDGCAD@C[FCGIB@IE@K^BDOIAEMMIJEDKF@[UMB@GF@EEAUEABSQ@CA@EY@FJI@CHGD@FS@@CAFCACFSCCDCMSHBIECMB@D]@@MKCDCQEAHG@CCG@CGUEIJK@SPOCCNEDQBDNDB@DJCDLFCBBALJB@BVGPBKVO@KHCCCD@FE@BNA@FNCTDDJA@FGB@NBDW@CL@hT@@ZHHQDDDAFSAANBC@HG@EFS@@DE@@PCB@Ue@CADNJB@FCBWA@LI^ix@FIHrH'],
                        ['@@HUNÂ‹AJKADGECBCMAG^E@EbI@BEGPKrJEH[\\B@FF@CHFB']
                    ],
                    'encodeOffsets': [
                        [[
                                119169,
                                40992
                            ]],
                        [[
                                119398,
                                41063
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': '110108',
                'properties': {
                    'name': 'æµ·æ·€åŒº',
                    'cp': [
                        116.2202,
                        40.0239
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@plDJVLÂŒGPBFHjDbHGL@X\\DBNHJREBLRBHaFGÂŽMGOBQAWPBLCBBAJBDFADOIEJGE@@EP@HCPWP@ZgfBRQJJ\\D@HLHLDVA@IVDFGSI@EGC@EBB@CN@@IZCAGHGaEqGJG@EjwJ]@K@GSA@e_I@NE@CA@Kg@KC@ENCFÂƒAKQAW@WIMK@VÂ‹@I@@F@^EDFB@HcIaDYCBRRDCHD@EFLN@FE@CJUPEJOJMTBPEDIFCMIAKNOGMRFJNDVBFLSRMJSDGJsFcEiJGDGTIlOjYD'],
                    'encodeOffsets': [[
                            118834,
                            41050
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '110106',
                'properties': {
                    'name': 'ä¸°å°åŒº',
                    'cp': [
                        116.2683,
                        39.8309
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@hMN@NFTQCFRCBJFA@HJ@@HJ@HJ\\FTACDÂŒ@@UNLXJX@@MA@@IECAQlDFEHBDI~D@GXCFMVDFCH@@NF@ANJC@FnAB@AMF@@EDCDDLGP@LUOAUH@AIABKAAEDCKID@CCACMWA@EGDEILA@OK@AELEJBFEEGL@BSOA@EuAFmMACbG@@EM@ANS@ENFDAHSDCL[BEIUBAII@A[E@OaKD@FAACTGVIACDHDAFGAEDoGEFACM@iÂ€g@@QFCMKMU@]SCoBGSMQÂ‰DEXXDWPO@MKYGM^AdJJA\\cNB\\G^Â„DNHFCBFABDBJ@PL^D@DF@T@FDAF^A'],
                    'encodeOffsets': [[
                            118958,
                            40846
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '110107',
                'properties': {
                    'name': 'çŸ³æ™¯å±±åŒº',
                    'cp': [
                        116.1887,
                        39.9346
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@NQPHLMJBDNJEFCAONSPIFIVODIF@@EKMFEC@DGQCAQZDbCdJ@GEAFC@]@EJ@DCSB[EGII@@GI@@GEBAIQDDESRMEM@gNYTIRKJAJEJ[DFJKLGBGNBJLDCDAHGBJJAFBLEXTLZFBAFDLD'],
                    'encodeOffsets': [[
                            118940,
                            40953
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '110102',
                'properties': {
                    'name': 'è¥¿åŸŽåŒº',
                    'cp': [
                        116.3631,
                        39.9353
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XBDA@EIACM@IJAD]BC@SFABISAD]H@@OÂAEDQEW@BLEÂ„MD@FLDh@@LDBF@@M`J@fTB@H'],
                    'encodeOffsets': [[
                            119175,
                            40932
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '110101',
                'properties': {
                    'name': 'ä¸œåŸŽåŒº',
                    'cp': [
                        116.418,
                        39.9367
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@DBf@@VDA@OF@@CT@FEH@@GADBMTBBECCRCGG@YS@@gDK@AÂ‘C@PG@C^TBAJEB@TADC^IB@J'],
                    'encodeOffsets': [[
                            119182,
                            40921
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '110104',
                'properties': {
                    'name': 'å®£æ­¦åŒº',
                    'cp': [
                        116.3603,
                        39.8852
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@RBX@RFFCÂŽBFU@aK@WA}CCJGAEFkCBRFD@JB@@N'],
                    'encodeOffsets': [[
                            119118,
                            40855
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '110103',
                'properties': {
                    'name': 'å´‡æ–‡åŒº',
                    'cp': [
                        116.4166,
                        39.8811
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XBL@@bEVÂ’D@BX@AC@MHA@EIBCCDSEMmB@EIDBME@@MG@EDUCENWD@H'],
                    'encodeOffsets': [[
                            119175,
                            40829
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/china_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': 'xin_jiang',
                'properties': {
                    'name': 'æ–°ç–†',
                    'cp': [
                        84.9023,
                        41.748
                    ],
                    'childNum': 18
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@Â›ÏÈÃ´Æ§Æ¦Ã³É™Êµ×¡ÊµÃ³ÆªÔ«ÊµÑµÍ©Æ§Í©Ú“Â›Ï…à¡“É›Êµ@Èƒ@Ã³á‡‘ÑµÆ¨ÉÉšÃ´Ã³ÐÑºÍ©ÉœÌÔ­ÊµÃ´Æ§ÉžÃ±@Ï…Æ©Â—Ý‡È‚Ã³Æ©Æ§@ÑµÈ‚Ï…ÂœÆ¥ÅŒà¨—Â—à¥¥É›Ã³ÊµÑµÆ§Ñ¹Â˜Ý‡Ìà¢¯Â˜É™ÉžÏ…Â˜ÏÍ©ÌÃ³à¨™Æ¨Æ§Å‹Ã´ÅÃ³ÂšÌÍ©Ã³Êµ×ŸÂ›Ã³Å‹Ú“ÍªÆ§Ñ¶@ÉœÔ­Â—Ô«Æ¦É›È„ÌÂ›ÉÈ„Ã¶Ï‚Æ©È‚ÌÂœÃ±È€ÌÂœÆ©Ã³Ã³ÅŽÉ™Â˜@ÅÌŽ@ÉžÈ€ÉÅŽÃ´Æ¨Ã³× ÑµÈ„Æ§@Ã³ÅÉÂœÃ³ÉœÃ´ÅŽÌÍ¨Ï‚ÅŽ@Æ¨Ã³Ã´Æ¨ÉžÝˆÊ¶Ã³Æ¨Ï†Ã³ÌŽÈ€Æ¨ÌÔ®Ã²Ñ¸Ô®×ž@ÑºÈ€@Æªá¬Ö†Ã²È‚Ã±ÌÃ²È‚ÉœÂ˜Ã³Æ¨Ì’ÅŽÌ‘ß¼@Ï†ÏÈ€@Åà¹Ï‚ÌŽÆ§Ï†@ÉÏ†Ú”à³¦Ô®Ç¿à¢°@Æ¦ÅÔ®Æ¨Æ¨È„Æ§Û¬ÉœÊ¶Ú”ÅÉšÉšÃ³ÅÃ´Æ¨ß¼Â˜Ã´Æ§Æ§Ã³ÌÆ¥Ã³ÅÑºÇ¿Æ¦ÈÏ†Æ§Ï‚Â˜Æ¨Æ§Ì’@ÉœÆ¥Æ¦Ï…ÌÉ›ÆªÍ©Æ©É™ÆªÊ·Ì‘É™@ÈƒÆ¨Êµ× Å‹à¾¸Åà¨šÔ­ÔªÂ—@ÉÆ¨Å‹Ì’Ö…Ï‚ÊµÃ´Æ§'],
                    'encodeOffsets': [[
                            98730,
                            43786
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'xi_zang',
                'properties': {
                    'name': 'è¥¿è—',
                    'cp': [
                        88.7695,
                        31.6846
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã´ÅŒ× ÂœÃ´Ê¶ÌŽÍªÃ´Â™Ã³ÅŽÆ¨ÅŒà¨šÆ§ÌÃ´Ï‚ÍªÏ†Â—ÉšÉà¢°Â—ÝˆÌŽÑºÂ—Ñ¶Æ¨Ã´Ê¶à¥¦Éœà¨˜Â˜Æ¦Å‹Ï†Â›Ñ¶ÈÌÂ—Ã´ÅÉšÅ‹@Ì‘É™Â—@ÅÃ²ÌÉœÂ›Ã³Æ¥Ã´Ê·Æ§ÌÏ†Ñ¹ÔªÌ×¢@Ñ¸Ê·Éœ@Ã´Ã±× @Ñ¶É›ÉžÃ´ÌÅÑ¶Æ¨Ñ¸Æ§Æ¥ÅÆ¦ÂœÃ´ÅÃ´Â—@Æ§Ã´Æ©Ì’Å‹Æ¨ÅŒÆ¦Ç¿Ã´ÌŽÉœÈÌ’Â—Ã³Ê¶Ñ¶Ã´Ã´ÐžÌ’Â›Ï‚Æ¥ÉœÐÏ†ÏƒÉ›ÈÌŽÏ…Æ¨à°±Æ§Å@ÊµÆ¥Âœ@ÅŒÃ³Ã³Ã³Í©Æ¨Æ§Ã³Å‹Ì‘ÃµÃ³ÉžÃ³ÉÔ©ÍªÉÏÃ´Æ§ÌÆ§Ñ¹Í¨Ú‘ÅŽÌ‘ÅÃ³Æ§à¢­Í©ÌÑµÉÃ³à°±Ã³Ã³ÔªÏ…Ã´@Ì’Æ¥ÅŒÌÆ§Ì‘È„Ý‡ÅŽÆ§Â›ÑµÓ@É›ÃµÅÉ›È„Ã´Ó’Æ§ÅŒÑµÇ¿ÉÂ˜Æ§Å‹Ô«@ÌÊ´Æ¥@Ã³Ç¿Ì‘È€Ã³Ç¿ÌÏ‚Ã³Ã³Ï…Ã´@Ê¶É›Ã±ÏÆ¦Æ©ÅÃ³ÌŽÃ³ÂœÑµÃ³Ì‘Íªà¢¯ÐžÃ³Éœ×ŸÂ˜Æ§ÌÆ¥È„ß»ÌŽÌÌ×ŸÅŽÉÉœÃ¶ÉžÆ©È€Ã´Ã¶É›È€Ã³ÍªÌÆ¨ÆªÌÌŽÈ‚Æ¥ÔªÏ…Ðž@Ï†ÉžÂ˜Ã´Æª'],
                    'encodeOffsets': [[
                            80911,
                            35146
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'nei_meng_gu',
                'properties': {
                    'name': 'å†…è’™å¤',
                    'cp': [
                        117.5977,
                        44.3408
                    ],
                    'childNum': 12
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@áŠŠÈà«ŠÃ¶ß¼Æ©ÉœÉ›× Ã±Ô®É›Ñ¶Ã³Ô®Ã´@ÈÑ¸Ã³×žÌŽà¶œÑºá¬@ß¼Ê¶Ô®Ó’ß¼ÌŽ@ÅÑ¹Ó’Ì’ÔªÆ¨Ã¶à¶œÌ‘Ñ¶È„Ì’Ï‚à¥¤ÂœÑ¶ÉšÃ¶ÉžÉœÊ´Ú”Ã´Ã´È‚ÌŽÂ—ÑºÈ€Ï‚Â—Æ¨Â˜ÆªÃ³ÔªÂ—ÉœÃ´É›Ðžà¨•Ú”Ô­Â˜ÑµÌÑ¹È‚Ô«Â›É›Æ¥ÌÈ‚Ã³ÉœÌŽÃ´@Ê¶ÝŠà©²à¢®ÊµÚ–Íª× Æ¨Ã´È‚Æ§Â˜ÌÍª@ÅÆ¦Æ¨Ï†Ô¬Ñ¶ÉœÃ´Æ¦@ÅÆ§Ã´Ã´Æ¦É™ÅÌÂ›@ÅÚ’Ñ¶Ô¬Ã´ÌÊ³Ô©ÐÏ‚ÅÃ´ÅÉž@Æ¨È‚Ñ¶É™Ã³Æ§Ì’Ø»ÌŽÃ³ÌÅ× Ã³Æ¨Ã´Ì’@Æ¨ÉšÉš@×¢Ô«É›É›@ÈÏ…Í©Æ¥Ê³Ã²Ö‡ÏÂ—Ì‘à¡—Æ§Íªà¼ƒà¥£Ô®ÖƒÌŽÆ¦@Ã´Ã´@Ã´Å@Âš@ÈÑµÃ³Æ¨ÌÏ…ÈƒÃ³ÊµÉ›Æ¨Æ¥Ã³Ï…È‚Ã³É™ÆªÂ›ÌÏÆ§Í©ÉœÔ­Ú”È„ÌŽØ¹Æ§ÈÌÅÃ³ÌÉ›Â›Æ¥Æ§Ì‘Ã³ÏÅ@Æ§ÌÂ˜ÉÉ™É›Â˜ß»Í©ÌÍ©ÉÐžÌÆªÆ§Ã³Ã³Ó“Æ¨Ã³Æ§Ê³Ý‡@ÉÏ‚ÆªÂœ@Ê´Æ©Â—Æ§Æ¦Ã´Æ¨É›È„É™Â›Æ§Å‹Ï…Â›Ã³Í©Ñµ@ÉÇ¿Ã³ÅŒ×ŸÌÉ›Â˜Ã³ÐžÌÂœÌ‘ÌÃ´ÈÌÅÃ²ÈÃ±Ã³Æ¦Í©@Ç¿É™@É›Æ§Ì‘Â˜ÏÈÏ…Ã´ÌÖ…Ñ¹ÂœÃ³ÈƒÉ™Â™@È‚ÏƒÊµÑ·ÆªÃ²Æ©ÌÂ—Ã´Ã³ß»Û¯Ã´Ê³Æ§Â™Ã³ÂšÃµÊµÑµÃ³Ñ¹ÉœÌÈ‚Ñ¹Ã´É›ÅŒÏ†ÖˆÆ©Í¨ÏÃ³Ï…Ó‘Ã³ÞŸà°±Ì‘Ý‡ÍªÃ³ÆªÆ¨ÅŒÃ³È„Ú”Ô¬Æ©Ï‚×Ã±Ì‘ÈƒÑµÅÔ­ÅÆ¨ÈÉ›Ç¿ÏÃ´ÃµÉšÉ›Ã³Æ§ÐžÉ™@Ñ¹ÌÑµÃ¶ÔªÍ¨Ã´ÍªÉ›Ì’×ŸÅÆ§Æ¥Ã³Ã´Æ¥Æ§É›ÅŒÃ´Ã³ÉÃ³@Ì’Ý‡Ó’Ì’ÅŒ@ÅŽÔ­à¢°'],
                    'encodeOffsets': [[
                            99540,
                            43830
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'qing_hai',
                'properties': {
                    'name': 'é’æµ·',
                    'cp': [
                        96.2402,
                        35.4199
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Æ¨@Ã´ÆªÝˆÈÆªÂ˜@Ï†ÉÃ²Ã³Æ¨Ô®Ê¶É›ÌÑ¹ÍªÃ´ÐžÉ™Ã³Æ§Éžá‡’Ñ¶@Ã´Ú–Ã´@Ç¿Ñ¶Â›ÆªÈÏ‚ÂœÉœÍ©Ï†Â˜Ï‚Å‹ÉžÃ´Ñ¶É›Æ¨ÅŒÉžÂ—@ÉšÏ‚ÅÃ±Ôªà¥¢Í©Æ¨È‚ÉžÃ³Æ¨ÅÌŽÅ×¢ÓÌŽÃ³Æ§Æ¦Ã´ÂœÌ’ÈÉœÂ›Ï‚Í©Ì’ÂœÉšÉ›Æ¨Ã´Æ¨ÉÏ†É›Ã³ÈÆ¨Å‹Ã³Ã³ÉšÍ©Æ¨Ã³Ã³Æ©@Æ§É™Å‹Æ¦Æ©Ì@Æ§Æ§Ã´Ç¿Ï…Ì‘@ÈÉžÇ¿ÃµÅÏÆ¥×¡ÉšÆ§Ã³Ï„Ô«ÉžÂœÃ´Æ§Æ¦@Ã±ÈƒÃ²Ã±Æ¥Ã³Ï…Ã´Ã´Ñ¹ÑµÂ—@ÅÌÈ„ÉÃ³@È‚É™ÅŒÃ³É™Ñ¹Æ¦@ÅÌÅŒÏ…ÝˆÔ©ÅÆ§Ã³Ã´Æ§Ì‘Â›Ã´ÊµÉžÆ§Ì‘ÑµÃ´Æ©ÉžÆ§Ì‘ÂœÃ³ÐÑµÃ³Ã´ÊµÌ‘Â˜É›È‚Ã³ÌÆ¥È€Æ§Å‹Ì‘ÅŒÃ³Æª@Æ¨Ã³Â˜Ã³ÅÆ¥Â›Æ¦ÅŽÑ·Æ¨ÑµÆ§ÌÅÉÃ³ÑµÉœ×Ÿ@Ã³Ã²É›@Ñ·Ê¸×¡@Ô©ÌŽÏ…ÑºÆ¨ÌŽÃ³Ê¸Ã´Æ¦É›ÂœÃ±ÌŽ@ÅÉšÂ˜@Ì’É™ÅŒÃ³ÅÌŽÂ˜'],
                    'encodeOffsets': [[
                            91890,
                            36945
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'si_chuan',
                'properties': {
                    'name': 'å››å·',
                    'cp': [
                        102.9199,
                        30.1904
                    ],
                    'childNum': 21
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã´Â˜Ã´Å‹Ã³Ì‘Ô®Ì’É›Ðž×žÍªÆ¨ÅÃ¶Í«ß¼Æ¥Ã´ÈƒÆ¨Ã³Ã³Ã±Ã´Æ§Ã³Æ§Ã´ÅÚ”ÅÆ¨Å@ÅŽÃ´Â˜Ã²Æ¥ÑºÅŽ@ÅÉœÃ³× Â˜Ã´Ç¿Ã´Â›Æ¦Ã´Ô®ÌÉœÃ´ÉšÂ›Æ§Â—Ã±É›ÉšÈÌÆ§É›Ö‡Ï…@Ã³Ã³Ã´Å‹ÏÔ­É@Æ§Ê¸ÌÅÏ…ÉœÆ§Æ§Ã³Æ§Æ¨ÈÏÌÆ¨ÈƒÉšÂ—Ã´ÊµÏ†Ã³Ã´Ì‘ÌÈ‚Ì‘ÊµÉœÊµÉž@Æ¨Ê³×¡Æ©Ã³ÅŽÉ™Â—Ã³ÉœÆ§Ã´Æ©Æ§ÏÂ˜Ã³Ã´Ã´Ã´@ÅŽÆ§Æ¨Æ¨ÆªÑ¹Â˜Ã³ÌÌÆ©@ÌÑ¹ÐÃ´ÞŸÌÆ©Ã³ÆªÏ…ÉÉ›Â—É™Æ¨Ã´ÅŽÉ›È€@È‚@Ã±ÉÊ¶@ÅŒÏ× ÌÂ—ÃµÃ³É›Í¨Æ¨È‚ÑµÐžÉ›Êµ@ÌÆ©ÅÃ³ß¼Æ§à°²ÌÏ†ÉœÈ‚Ï…Ï„É›ÐžÏÆ¦ÉÆ¨Ã³ÆªÌ’Ñ¶ÉÆ¨Ã³Ê¶Ì’ÂœÃ³Æ¨Æ¨Ã´ÔªÅÏ†Ý‡ÌŽÅ‹@ÅÑºÆ¥Ã´ÉšÉšÅ‹@ÈÉžÃ´ÌÈƒ@ÅÑ¶Â˜Ã³ÑºÏ†Ã³Æ¦Ã´Ã±Ã²Ã²È„'],
                    'encodeOffsets': [[
                            104220,
                            34336
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'hei_long_jiang',
                'properties': {
                    'name': 'é»‘é¾™æ±Ÿ',
                    'cp': [
                        128.1445,
                        48.5156
                    ],
                    'childNum': 13
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@á‡”È‚à¨šÐÆ¨ÅÑ¶ÅÃ¶Æ¥Ï‚ÅÃ±Æ§Æ¦Ã³Æ¨È@Ã³Æ¨Â—Ã³ÈÏ†Ó‘Ã³Ã³Æ¨Â˜Ã³Ç¿ÌŽÌ‘Ã´ÐÉžÂ—Ã³Ì‘ÉœÉ™ß¼Â›ÌŽÇ¿Ì’Ã´Ú’Ó‘Ï†@Æ§ÈÌŽÌÆ¥Æ©ÌŽÏà°¶Â˜Ã´È‚Ï‚Æ¨Ï†@× ÉžÝˆÂ˜Ì‘Æ¥Æ§É›Æ¨ÊµÆ§ÈƒÆ¥@Æ§Æ¥@ÅÌ‘Ô©Ã´ÉÏÏÃ³É›Æ§Â›Æ©Í©Æ§Ã³ß»Ê¸ÌÊ·Ñ¹Æ¥ÉžÚ•ÃµÌÃ¶ÉÏ…Â—ÌÈ‚Æ§ÌÌ‘ÅÃ³Æ¨Ã±Å‹Ñ¹Ã³Ã³ÈÌÂ›ÌÔ¬ÃµÊ¸ÌÅ@Ç¿Ì@Æ§ÐžÏ…@Ã±Æ¨Ã²È€Æ¥ÅŽÌ‘ÅÑµÃ³É›ÅŒÃ³È‚Ô«ÅÆ§ÅŽÑ¹Ã±ÌÊ¶Ã³Ðž×Ÿ@Æ§ÌŽÑ¶Ã´@È‚@Â™Ã³ÅŽÃ³@@Ã³ÌÆ¥Ô­Ö„à¼„à¥¤Æ¨Í©Ì’à¡˜Ï‚Â˜Ã±ÖˆÆ¦Ê´Ï†Íª@È‚ÉœÉœ×¡Ô¬É™@Æ§É™Ì‘@Æ§Ã³×ŸÃ´ÌÅÌÃ´Ì‘Ø¼Ã´Æ¨ÑµÉšÆ§ÈÉ@Ã³ÅÏÅŽÔªÐžÌÊ´'],
                    'encodeOffsets': [[
                            124380,
                            54630
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'gan_su',
                'properties': {
                    'name': 'ç”˜è‚ƒ',
                    'cp': [
                        95.7129,
                        40.166
                    ],
                    'childNum': 14
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ú”Ã´Ô®à¢¯@ÅÌ‘Å‹ÝˆÓ‘@Ì‘ÉžÃ´Ã³Ã´ÉœÅ‹Æ¦Æ¨Ã´Ã³Æ¨Æ¦× ÅÉœÌ‘Ã³Í©Ô©Í§Ñ¶ÃµÑºÌÉš@Æ¨ÐÉœÃ´Ã¶É™Ï‚Ã³ÉœÈ€Æ§È‚Ô®ÅÑ¶ÅÌ’È„×žÃ²ÆªÏÚ“Ô«Ã´ÈƒÆ§Å‹Ã´Æ©ÝˆÍ©Éš@@Ç¿Éœ@Ï†Í©Ã³ÅÉœÓ‘Æ§ÅÃ´Ç¿ÌŽÂ›Ã´Æ¥ÆªÃ³ÃµÂ›Ã¶@Ã´Â—Æ¨Â˜Ã´Æ§Æ¦Ã´Ã³Ì’Éœ@ÉžÅŒÃµÊ¶ÌÅ@È€Ã³Ã´Æ¨È‚@Ê¶×¢@@Æ¥à­¾Ó‘Ã³Ì‘Ã³Å‹Ã´ÊµÃ³É›Ú“@@Æ©Ã¶Ã³Æ©Ã³ÏÂ—É›Æ¨Ì‘@Ã³Ê·Æ¥Æ¥ÌŽÉ›Æ§Â›Ã´ÅÆ§Ç¿Ã´Í©ÑµÃ´ÉÈƒÉžÈÃµÆ§ÏÃ³Ã³Â—@ÅÆ§ÅÚ“ÅÃ³ÅŽÃ´Æ¨Ã³Æ¨Ã´Ã²Æ§Ã´Ã³È„ß»Æ¦ÃµÍ¬Æ§ÅŽ×Í©ÉœÐÔ­Ì‘Ã´Ì’Ã³ÅŒÃ³Â—Æ¥@Ã³Æ¨ÉÂ›ÏƒÔ¬Æ¨Ã´×¢É™Ï‚Æ¦Ã¶ÅÉÈ€@È‚Ï†Ì’Ã³È€Æ¨Æ¨ÌŽ@Æ¥ÆªÉšÅŒ@Æ¨Ã´ÆªÆ§Ã´É™ÍªÃ´Ã´Æ§ÅŒÃ´È‚Ï…ÉœÆ§ÉžÆ§Ã³É™ÉœÌ‘Â›ÏÍªÉ›ÂœÌ‘È‚Ã³Â›Æ¨Æ¥ÌÃ´×¡ÓÌÅÆ§ÅÉÃ´Æ§Èà¥¡ÍªÃ²Ô©ÏÅ@É™ÉÂ˜Æ§Å‹ÑµÉœÉÃ³ÏÅŒÏ…Â—É›ÍªÏÂ›Æ©È‚ÑµÂœ@È€Ú•Ã³@È„ÉœÊ¶Ï†à¡”Ú”ÂœÆ¨ÍªÑ¶ÍªÔ¬Ê¶Ã´Æ©×¢Ê¶ÉšÊ¶Æ¥Ã´Ã³Æ¨Ï‚È‚'],
                    'encodeOffsets': [[
                            98730,
                            43740
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'yun_nan',
                'properties': {
                    'name': 'äº‘å—',
                    'cp': [
                        101.8652,
                        25.1807
                    ],
                    'childNum': 16
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã´ÉžÃ´ÉÌ’Ã¶Ã´ÅŒÆ§Æ¨Ã´ÍªÃ´Ã´@Å‹Æ¦Â›@Ê¶Æ¨ÅÃ´ß»ÆªÅ@ÌÉœÊ¶Ñ¶ÐÆ§ÈÉœÍ§Ã¶Ã´ÌÂ˜Ï‚×Ÿ@Å‹ÉžÊµ@Ã²@ÈÉœÇ¿Ã³ÅÉšÆ§ÉœÂ˜Ï†ÉžÃ´Æ©ÌŽÆªÃ³Þ ÑºÐž@ÌÌŽÆªÃ´ÌŽÑºÂ—Æ§Æ©Æ¨Æ§@ÅÃ³Ã³Ã´Ã³Ï‚Â—ÆªÆ¨Æ¨Ã³Ã´É›Ã³Ì‘Ô­Â—Æ¥ÅŒÉ›Ç¿ÉÆ¨É›Í©Ã´Â›@Ç¿Æ¨ÈÑºÅŒÉšÉ›Ì×ŸÑ¶ÐÉ›Æ§Ã´Ã³Æ¥ÈÆ¦Í©Ã´ÅŽÉžÂ—Æ¨Ì‘ÉœÂ—Ã²Ã´Ï†@Æ¨Êµ@É›Ñ¹ÅÃ³ÈƒÉ™Æ¨Ï…Ç¿Ã³ÊµÏÆ§Æ§ÅŒÆ©É›ÌÈ„Ã±Æ§Æ§È€ÉÌÔ©Ê¶Æ§Ì‘Ï…Â—Ã³ÅŒÆ¥Ê³ÉšÓ‘Ã³ÐÆ¥Ã´Ì‘Â›Ã³Ó’ÑµÊµÑ¹ÂœÆ§Ó×ŸÃ´ÆªÏ†ÃµÅŒÆªÌ’Ô«ÅŒÆ§Ø¼Æ¨Æ¨×¡Â›ÏÈÆ§ÂœÆ¨È‚Ã³Ê¶Ã³@@Ê´Æ¨Ã´Ã´Ï†ÌŽÅŽ@È€Æ¨Â—ÆªÉšÆ¨ÂœÃ³Æ¨Ã´Ã´Ã´Ï‚Ã³Þ¤Æ§ÅŒÆ©Å‹Æ§Ôª'],
                    'encodeOffsets': [[
                            100530,
                            28800
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'guang_xi',
                'properties': {
                    'name': 'å¹¿è¥¿',
                    'cp': [
                        108.2813,
                        23.6426
                    ],
                    'childNum': 14
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Æ¦Å‹ÑºÌŽÚ”ÊµÆ¨Å@Æ¦×žÈ„ÆªÃ´Ã³È‚ÉœÅŒÉšÍ©Éœ@Ã¶Ã³ÉœÃ´Ã´È‚Æ¦Ã´ÉœÈ@ÉžÏ†Â›Ã³È„ÌŽÂ›Æ¨Ê¶ÉžÅ‹Æ¨Ê´ÉšÇ¿ÌÌŽÔ¬@Ã´Ã±@ÌÆ¨Â›ÏÛ«Ã´Â›ÉšÆ¨Æ¨ÐÆªÅÌŽÂ›Æ¥Ã³Æ¦ÊµÆ¥Å‹@ÈƒÃ³Æ¥Æ§@@ÅÉÇ¿Ã´Ï…Æ§ÈÑµÉ›@É™Ã³ÅÌ‘@@É™ÌÂ›Ã³Æ§Ã³Â—@ÈÆ©Â˜ÏÃ³Ã²ÐÆ¥Ã´@Ó’Ì‘@Ã³ÅŽÌÆ¥ÏƒÅŽÏ…@ÌÆ¨@ÅŒÌ‘Ã´Ã³ÍªÆ¨Ì’Ã³ÅŒÚ“ÂœÌÅŽ@ÅŒÃ´È„ÑºÅŽ@ÉœÆ§Ê¶Ï…@Ã±Ã³É›Â˜Æ§Ì’ÉÂ˜Ã³ÅÆ¥Íª'],
                    'encodeOffsets': [[
                            107011,
                            25335
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'hu_nan',
                'properties': {
                    'name': 'æ¹–å—',
                    'cp': [
                        111.5332,
                        27.3779
                    ],
                    'childNum': 14
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@Ö„ÉœÐžÆ¨@Ã¶Å×žÃ³ÆªÃ´Æ©ÉšÌ’Åß¼ÈÏ‚Í©ÉœÃ²ÆªÂ—ÉœÈ€Ã²Â—Ã±ÉÃ²Â—ÑºÍª@ÅÆ¨Å‹Ã³ÉÃ´Ç¿Æ¨Â™ÉšÈƒÃ³É™Æ¨ÈƒÑµÍ©Ã³Ì@ÈƒÆ¨Ã³Ã³Æ¥Æ¨Æ§@ÊµÆ¦Â›Ã³Í©ÉœÂ—É›Ã³Ã±Ô­É›ÅÏ…È‚ÌÆ§Æ¦Å@É›Æ¥Â—É›È€Ì‘ÂœÃ³Ê·Ã³ÅÌÂœÆ©ÅÆ§ÐžÉ™Æ§Ã³ÂœÏ‚Û¬Æ§Âœ@ÌÃ³Ã²Ô«@ÌÌÉ™È€Æ§Ê³ÉÅŒÃ³ÉžÆ§Â˜Æ¨ÉœÃ³ÅÆ¨Ã²@È„Æ§ÅŒÏÅ‹Ã³Ã´ÔªÐžÃ³Ê¶@ÌŽÃ³È„'],
                    'encodeOffsets': [[
                            111870,
                            29161
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'shan_xi_1',
                'properties': {
                    'name': 'é™•è¥¿',
                    'cp': [
                        109.5996,
                        35.6396
                    ],
                    'childNum': 10
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ï‚Ã´Ã¶Æ¨ÉÈ‚ÉžÈ„Ñ¶Ã³Ã³ÍªÆ¨È€Ã³ÅŽÆ¨ÂœÌÉœÆ¦Æ¦Ã´Ê¸Ì’@ÉœÆ§Ï‚Â˜ÆªÃ´ÃµÃ´@ÆªÚ”@Ã´ÉœÃ³Ê¶Ã´ÅŒÃ´Ì’à­½Ó’@Æ¦@ÑºÌŽÉœÑºÉ›Ñ¶Ã´Ã¶Ê¶Ã´Â™Æ¨ÂšÃ³Ê´ß¼Û°Ã³Ã´ÌŽÂ˜Ã±ÆªÑ¸Æ©Ï„Ê¶@ÈÃ²Å‹É™Ñ¹Ã³Ç¿Ì‘Êµ@ÈÌ’Ê·Ï…ÖƒÃ´Ý‰Ã´ÐÌØ·@ÈÆ¨Ã³Ã´ÌÆªÃµ@Ê³ÌÊµ@ÉÉ›Å‹Æ©ÅŒÉ›Ã³×ŸÃ´Æ§Å‹Ì’Ã³@ÅÌÆ¥@ÅÏ…@Æ§Æ§Ã´×ŸÌ@Æ¥È‚Ñ¹ÉœÉ™ÂœÉ›Ã³Ô­ÌŽÆ¥Ã³Ã³ÂœÃ³È€×ŸÂ—É›Ã´@ÅŽÑ¹ÅÃ±Æ¦'],
                    'encodeOffsets': [[
                            108001,
                            33705
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'guang_dong',
                'properties': {
                    'name': 'å¹¿ä¸œ',
                    'cp': [
                        113.4668,
                        22.8076
                    ],
                    'childNum': 21
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': [
                        '@@@È‚Ã´Â˜Ã´Æ¨ÌŽÂœ@ÉšÌ’@Ã´Å@ÉšÑ¶ÉœÆ¨È‚Ã³Ï†ÉžÈ€@ÅÆ¨@Ã´Æ¦@È„Æ¦ÅŒÆ¥Ê¶Æ¦Ã´Ã´ÅŽÃ´Ê¸Ì’Â›ÉœÇ¿Æ¦Â˜@ÉœÆ¥ÅŽÌŽÆ¨Ï†ÈÉœÅŽÃ²Æ¥Ô®ÅŽÆ¨ÅÃ³ÅÉ›Æ§ÉÉ™ÉžÆ§ß¼ÉœÏ‚ÈƒÃ±È„Æ¦ÅŽÌ’ÅÃ´Ã²Æ¨É™Æ¨Â˜ÉšÐ@É™Æ¨ÌÆªÊµÏ…ÅŒÉ™É›Ã³É™Ô­ÅÉ™ÂœÃ³ÅÑ¹ÂœÏÊµÉÆ¦ÌÂ™Æ¥Ê³Ñ¶Â›Ã¶ÅÌ‘Ã³Ã³Å‹ÏÈ€Ï…Æ§Æ¥É›Ñ¹ÅÆ§Ã´×ŸÂ—É›ÅÑµ@Ã³Å‹Ã´ÊµÉÂ›ÆªÔ©Ãµ@Æ§ÅÌ@Æ§@@Æ¦ÉÔ®ÆªÐž@@',
                        '@@XÂÂ¯aWÄ€Â„@lÂ'
                    ],
                    'encodeOffsets': [
                        [
                            112411,
                            21916
                        ],
                        [
                            116325,
                            22697
                        ]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'ji_lin',
                'properties': {
                    'name': 'å‰æž—',
                    'cp': [
                        126.4746,
                        43.5938
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@× @Ã´ÐÌŽÊµÑºÃ²Æ¨ÅÔ¬ÅŽÃ´ÈÉœÅ‹Ñ¶Ã´Ì’ÅÆ¦ÅÃ±Ç¿Ã²Æ§Ï†@Æ¨ÐÌŽ@@È€ÌÅÃ¶Ê·ÌÔ«ÌŽÂœÃ´È‚ÑºÃ´Ã²ÅŒÃ´Æ§Ì’ÅÆ¨ÌÌŽÈÏ†Â˜@Å‹Æ©Í©×ÈƒÆ¨Â—@ÈÌ‘Ê¶@ÅŒÃ³Ã´É›ÂœÆ¥Ñ¹Ì‘Â—ÏƒÏ…Ý‡@ÉœÏÆ§Èƒà¢¯Æ¨Ã´ÂœÉ™È‚É›ÅÆ©É›ÌÏ…ÏÃ³ÃµÂœÆªÊ´Ï…Ï†@Ê¶Ã´ÅŒÃ³ÂœÏÖ„@ÉœÆ§@ÉÇ¿Æ§ÍªÏÈ€Æ©Ã³ÌÅÆ¨È‚ÌØºÚ“ÈƒÉ›Ô®Æ¨ÍªÌÏ‚Æ©ÂœÃ´ÉšÏ†ÈÆ¦Ã´ÉœÆ§Ã´Ê¶Ï†È„'],
                    'encodeOffsets': [[
                            126181,
                            47341
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'he_bei',
                'properties': {
                    'name': 'æ²³åŒ—',
                    'cp': [
                        115.4004,
                        37.9688
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@Æ©Ì’ÌÅŒÑºÌ’Æ©Â˜Ã³È„Æ§ÅŒÆ¥ÍªÃ²Ã´Ã±È‚ÌŽÅÃ³È‚Ì’ÌÌŽÂ›Ã´ÐÉœÂ—× ÌŽÃ´Å‹ÉžÈ€Ñ¶@Ã´ÍªÏ†ÂœÆ¨ÅŒÉšÂœÉœÈƒÃ³Æ§Æ¨Æ¥ÆªÂ˜@Ê³Æ©Â›ÉžÏÝˆ@Ï…ÐÏ†ÊµÉœÂ˜Æ¦ÏÆ¨Æ§ÌÉÃ³É›Ñ¹ÌÏÅÌ‘Ã´Ã³Æ¨@ÂœÆ§Æ¦Ã´Æ¨É›@Æ¥Æ¨@È‚Æ¦@@Ã´É™ÅÆ§Ê¶Æ¨ÅŒÏ…ÂœÌÌŽÉ›Å‹Ã´ÅÉ@Ã³Æ§ÌÂ›Æ¦ÊµÑµÊ³Ã´ÊµÉœÅÏ‚Ã´ÆªÅ‹Æ¨ÅŒÉš@Ã´ÐÆ¥Æ§@ÅÑ¸É›ÌÃ´ÌŽÊµÑµÐÔ­@ÌÌÆ§Ã²@ÈÉ@É™ÏÏ…Í©ÆªÌÆ©ÃµÆ§ÅŽÆ§ÅÃ³Âšà¥¡È„É›Ê¶ÉœÈ€@ÉžÏ‚Ñ¶Æ§ÂœÆ¥Ï‚É›Å@ÉšÉœÉœ@ÅŽÃ´Ã´Ï‚ÂœÆªÏ‚'],
                        ['@@ÃµÉ™@Æ§É›Â˜@ÅÃ³Æ¦Ï†Ã´']
                    ],
                    'encodeOffsets': [
                        [[
                                117271,
                                40455
                            ]],
                        [[
                                120061,
                                41040
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'hu_bei',
                'properties': {
                    'name': 'æ¹–åŒ—',
                    'cp': [
                        112.2363,
                        31.1572
                    ],
                    'childNum': 17
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã±È„Ï…Æ¦Ã¶ÅÆ©Â˜Ã³× Æ¨Æ¨Ï†@@ÅÌÆ¦@ÅÌ‘Ã´Æ¨ÅŒ× Ã³ÉœÃ´ÆªÅ‹ÉœÅŒÑ¶Ö…Ú”É™ÝˆÃ²ÉžÅÉœÅŽÃ´ÓÆ¦Ã³Æ¨Ã´Ì’Ã³Ã´ÈƒÆ¨Ã³ÌŽÅÃ´Æ§Æª@Æ¨ÈÏ‚Æ§É™Ì‘ÌŽÐ@ÌÆ§ÅÏÃ´Ô­Í©Ô«Â—ÌÊµÆ§ÂšÃ³È€Ã´ÉžÆ§ÅŒ@ÅÑ¹Í©Ã±Â˜Ã²ÉžÃ±Â˜É›Ç¿Æ©Â˜É›Ã±ÏÍªß»È‚Ì‘ÅÆªÉ™Æ©Ã³×Ã´ÃµÅÆ§@É›ÐÆ¥È„Ã³Â›Ì‘ÑºÆ§Â›Ã´Ï†Ã³Æ¨Æ¨Æ¦ÆªÃ³ÉœÅÃ´Ã³Ã²Ã´Æ¨Ã³Ï†ÌÆ¨Ã³Æ¦ÌŽ'],
                    'encodeOffsets': [[
                            112860,
                            31905
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'gui_zhou',
                'properties': {
                    'name': 'è´µå·ž',
                    'cp': [
                        106.6113,
                        26.9385
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÉœÈ€Æ¦Å‹Ô®Â˜Ã´Ì’ÉšÂ˜Ã´Å×¢ÆªÆ§Ê´É@É›Ê¶Ì’Ê¶ÌÈÆ¦ÂœÃ³È‚Ã´@Ã´Å@ÅÃ´Â—Æ¨Ê¶Ñ¸Ã´@Ê¶Æ¨Â˜ÉžÃ³@ÅÏ„Ã¶Ã²Ï…Æ¨@@É™Æ¨Ã´@É›Ì’@Æ¦ÉœÃ´Èƒ@ÌÃ´ÊµÔ©ÐÃ´Ã³Ï‚ÅŒÆ¨Å‹@ÈƒÆ§Ã±Ã´ÅÆ§É›Æ¨Â—Ã´ÉÆ§ÊµÌÂœÃ´ÈƒÏ…Âœ@ÉÉ›È‚Æ¥Ã³Ã³ÈÉ›Ã³ÃµÃ´É›@É™ÍªÉ›Å‹Ã´ÈÆ©Ã³×Èƒ@Æ¥Æ§ÅÚ“Ê¶Ñ¹ÌÆ¥ÅŒÆ¦È‚Ã³Ã´ÉœÆ¨ÑµÐžÌŽ× É™ÉœÑ¹Å‹Æ§È‚@È€Ã³ÂœÉœÍªÉžÆ§'],
                    'encodeOffsets': [[
                            106651,
                            27901
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'shan_dong',
                'properties': {
                    'name': 'å±±ä¸œ',
                    'cp': [
                        118.7402,
                        36.4307
                    ],
                    'childNum': 17
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Æ©ÌÏ†ÍªÉšÏ‚Éž@@È‚Æ¨Ã±ÌŽÌŽÔ®@Ñ¶ÐžÆ¨Æ§Ú”@Ï†ÐÌ‘Å‹@Æ©Ì’Ç¿ÌŽ@Æ¨ÉœÔ¬Ï‚Ã´Ê¶ÌÊ¶Ã¶Ô«Æ¨Æ§× Æ¥ÉœÅŽÃ´ÅÌŽ@Ã´ÅÃ³ÏÆ§ÅÔ«Ã´Ã³Æ§Ô©Ã³@Æ¥ÉœÆ§Ô­Ã³Æ¨ÊµÉ›Æ¨ß»Ó‘ÉœÐÔ©Â˜Ã³Ã´Ì‘Ã³Æ§Ê³É™Â™Ã³É›Æ§@ÃµÈ€Æ§ÂœÌÈƒÉ›ÅÃ³ÅÏ…ÐžÌÂ—Ã³ÉÆ©Â—Ô©@Æ§ÉšÔ«È„ÉšÊ¶Æ¨Â˜ÉžÊ¶ÔªÌÚ“É›ÆªÌ’'],
                    'encodeOffsets': [[
                            118261,
                            37036
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'jiang_xi',
                'properties': {
                    'name': 'æ±Ÿè¥¿',
                    'cp': [
                        116.0156,
                        27.29
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Æ§È„Ã´ÉšÉ™È„ÌŽÊ¶Ô¬Â˜Ô®ÍªÏ‚Ã³Æ¨ÅÆªÂ›Ï„ÉžÆ¦ÅÆ¥Æ§@ÅÏ‚Ã´Ã³ÅÃ´Ã´Ì’Ê·Ñ¶Â—ÆªÆ©Æ©Ç¿@ÅÌ’É›Ã´Ï…@Â—Æ§ÈÑ¹É›É™Æ¨Ñ¹Ì‘Æ¨ÌÃ³Æ¥ÑµÊ·Ã´ÌÉ›ÈÃ´ÅÉÇ¿Æ§Ô«Æ§Â›Ã´Ê³Æ¥ÅÃ²ÈƒÏÈ„ß»É›ÉÆ¨ÉžÉšÉœÆ¨Ã´ÅÆ§ÅŽÔ­ÅÃ±Æ¦Ã²Ô®ÉœÃ´É›Â˜Ã´ÍªÆ¥Âœ@Ê¶Æ§Æ¨Ã´Æ¦Æ§Ã´@È„Ã´ÌŽÑ¶Íª'],
                    'encodeOffsets': [[
                            117000,
                            29025
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'he_nan',
                'properties': {
                    'name': 'æ²³å—',
                    'cp': [
                        113.4668,
                        33.8818
                    ],
                    'childNum': 17
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ï†Â˜ÌŽÆªÌÂ˜ÉžÈ„Éš@@È‚×¢Ã³ÌŽÅŒÑºÌ’Ã´Ö†à¥¢ÈƒÃ´Â™Æ¨ÅŽÆ¨ÅÆªÃ¶Æ©Ì‘Ú”ÉœÔ©ÌÉÊµÆ§Â—É™ÊµÔ¬ÈƒÆ¨É™Ôª@@Æ§Ì’ÅÃ´ÌÏ…ÈÆ§ÉšÌÃ´Ã³Å‹@ÉÆ§Å‹ÃµÌ‘ÏƒÂ—@ÅÉœÅ‹Ã´ÉÌ’Æ§ÉšÃ´Ã´Ø·ÏÃ³Ã³É›Æ©@Ã³Æ¨ÌÅÆ§Ã´Ã³È„Ì‘Ã´Æ§Ã³Æ¥Ã´Ã³ÓÉ›ÅÉÅŽÝ‡Ã±Ú“ÉšÑµÖ†@ÉžÌÊ¶@Ê´Æ©Ã¶Ã³Ì'],
                    'encodeOffsets': [[
                            113040,
                            35416
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'liao_ning',
                'properties': {
                    'name': 'è¾½å®',
                    'cp': [
                        122.3438,
                        41.0889
                    ],
                    'childNum': 14
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Æ¨Ê´Æ§Ã´Ã´Ó”Æ¨Ã´ÌŽÆ©ÉžÐÌŽÍªß¼ÍªÉœÂ—ÉžÉšÌÂ—@Æ¨Ï‚ÅÌ’Ã´Æ¦Æ¨ÉœÂœÃ´ÌŽÆªÃ´Ï‚Ç¿Æ¨Í©ÉžÈ€Æ¨@@É›Ï‚ÖƒÃ´Â›Ã³Å‹@ÊµÏ†Ï…Æ©Ê³Ã¶Â›à¥¥ÖƒÏÑ¹×¡@É™É›@Í©à¢¯@Ñ¹ÊµÏÂ—Æ©Ê¶Ï†È€Æ§Ì’ÝˆÛ¬Ã³Ê¸ÉÅŽÑµ@Ô­Ô«×ŸÉ›Æ§Æ¨Æ¥Ï‚É›Â—Ï…Ê¶Ï†Ðž'],
                    'encodeOffsets': [[
                            122131,
                            42301
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'shan_xi_2',
                'properties': {
                    'name': 'å±±è¥¿',
                    'cp': [
                        112.4121,
                        37.6611
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÉšÑºÃ±ÅŒÉšÂšÃ´È„ÑºÂ›ÌŽÖ†Ï†Ã³Ï‚È‚Ì’Â—ÉœÆ¨Éš@@È€Æ¨Å‹Ã´ÈƒÆªÂ—Ñ¹Ì‘ÌÅ‹ÆªÌ‘Æ©ÏÏÂ›Ã³Ã³@ÅÉ›É›@É™ÉœÅÆ¦ÏÆ¨Â›ÏÑµ@ÉÉ›Ç¿ÉœÊµÃ³Ö…Ñ¹Ì‘ÌÅ‹×¡Ã´@ÈÉ™@ÉÈƒÌÂ—ÌÆ©Ï…Â—Æ§Ã´@È‚ÌØ¸Ã³ÐžÃ³ÝŠÏ†Ö„Ì‘Ê¸@È‚Ì’Ê¶Ã´È€'],
                    'encodeOffsets': [[
                            113581,
                            39645
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'an_hui',
                'properties': {
                    'name': 'å®‰å¾½',
                    'cp': [
                        117.2461,
                        32.0361
                    ],
                    'childNum': 17
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã³ÌŽÌ‘Å@Æ¨ÆªÂ˜Ñ¶Ç¿ÉœÌ‘Ï†Â—Æ¦ÊµÌÂ˜Æ§ÑµÃ´Ã³ÆªÃ´Ã´Ï…Ï‚Â—Æ¨È‚ÉžÅ@ÌÔ«Ã´Ã²Ì‘Æ¥Â—Ã³ÈƒÑ¶Í©Æ§Æ¥Ã´ÅÑºÂœÃ´ÅÆ¦Â—@Â›Æ¥Í©Æ§Â—Ã´ÈÏ…Ã³@Ì‘Æ§É›ÑµÊµÆ©ÆªÑµÂ˜Ì‘Ê¸Ã³Ã³Ã´ÅÏÃ³@ÅÆ¦Æ¨Æ¥ÅŽÏƒÉÆ©Âœ@ÌŽÌÐžÉšÌ’ÏÆ¨Æ§È‚Ã´ÉœÏ‚Ã´Ã³Ø¸É™Ã³Ì‘Æ¨Ã³ÉžÉ›ÅŒ@ÅÏ„Â˜Ã¶Ì’Æ¨ÅŒ@ÉžÃ´ÅŒÌŽÃ³Æ¨É™Ï†È‚'],
                    'encodeOffsets': [[
                            119431,
                            34741
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'fu_jian',
                'properties': {
                    'name': 'ç¦å»º',
                    'cp': [
                        118.3008,
                        25.9277
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÌŽÂ›Ã³ÈÆ¨Ó‘Ì’Â—ÌŽÉšÆ¨Í©Ï†ÅÆ¨ÉÌŽÅ‹Ã³ÅÏÂ—@ÅÆ¨Â›Ã²Ê³É™Ã³Æ¨ÅÌÂ˜ÃµÉ›Æ§@Æ¨ÑµÆ§ÅÉ™ÅÃ³Å‹Æ§Ã´Ì‘ÉÉ›Ê³Æ¥@@Ã³É›Ãµ@Æ§Ì‘Æ§Ã³ÈÉ™Æ§Ì‘Â—Æ§Ì@ÉšÉ™ÐžÆ§Â—Æ§ÉšÃ³Ã±Ì‘ÅŽÃ³Ê´Æ¨ÂœÆ¨Ô¬ÉžÈ€Ã³ÅÉœÈ‚Ã³ÌŽÑ¶Ê¸Ã´Æ¦Æ§ÌÑºÌ’ÉšÆ§ÑºÉœÆ¨È‚'],
                    'encodeOffsets': [[
                            121321,
                            28981
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'zhe_jiang',
                'properties': {
                    'name': 'æµ™æ±Ÿ',
                    'cp': [
                        120.498,
                        29.0918
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ñ¶Ê¶Æ¨Éœ@Ì’Ï†Ã´Ã³È‚Æ¨Â˜Æ¦Íª@ÂœÌÂ˜Ñ¸ÌÏ„È‚Ì’Ì‘× Å×žÃ´ÆªÆ§Ã´Ó‘Ì‘Â›@Æ¥ÏÍ©Æ¨Ö…Ì@@Ï…ÉÃ³@Å‹É›@Ã´Æ©É™Ã³Æ§ÑµÏ…Ã³@Æ©ÉœÅ‹Æ§@ÌÅŒÆ§ÉžÏ…ÅÆ§ÍªÌÉ™Ì‘Â˜Æ§Ó’Ã´È‚ÌÂœ@Â˜Ã³Ï†Ì‘Éœ@ÅŽÆªÈ€'],
                    'encodeOffsets': [[
                            121051,
                            30105
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'jiang_su',
                'properties': {
                    'name': 'æ±Ÿè‹',
                    'cp': [
                        120.0586,
                        32.915
                    ],
                    'childNum': 13
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã´ÉžÌŽÂ˜Ï†ÐÃ´ÅÉœÅÌŽÈ„Æ¨Â›Ã¶Ç¿Æ¨@Ã´ÉœÉšÂšÆ¨Ê´Ì’Ã´Ã´Ã³@Æ§ÌŽÉ™Ô®ÈƒÔªà«‰Ã¶Í©ÌÆ§Ã²ÊµÏ†Æ§Ã´Êµ@Ã³Ú“ÉœÃ³ÅÉœÇ¿Æ§Â›ÉÏÏƒÈÑ·ÌŽÌÂ—Æ¥Â˜Ã³ÅÑ¹Â›Ã³ÅÆ¨Æ¦ÑµÍªÃ´È„Æ¦Â˜Ã±Ì’Ô¬Ã³@ÌŽÉÅÆ§ÈÏÂ˜Ã³Ï†Æ©Ã³Ã³Ã´Æ¨Ñ¶ÌÂ—Æ¥Ê¶Ï…Â˜É›Ì’ÑµÈ€'],
                    'encodeOffsets': [[
                            119161,
                            35460
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'chong_qing',
                'properties': {
                    'name': 'é‡åº†',
                    'cp': [
                        107.7539,
                        30.1904
                    ],
                    'childNum': 40
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@É™È‚Ã²ÉœÆ¨Â˜ÑºÉ›Æ¦ÈÌ@ÆªÂ—ÃµÅÏ†Æ¥Ã²ÈƒÆ¥ÌÆ§Ã´Ï…ÌÆ§Ã´Ã±Ã³Ã³Ã´É›ÅÆ©Ã´Æ§Æ¥Ã´Æ§Ã³Ï…Æ¨ÂœÌ’Ñ¹Ã´ÂœÆ¦Èƒ@ÖƒÆ¥É›Ì‘@@ÉœÆ§Ã³@ÉšÆ§@Ã±Ï†ÏƒÃµ@ÅŽÉÃ´Æ§Â—@ÊµÑ·Ã³Æ§ÊµÃ³Â˜@ÅŽÃ³ÅÃ³@Ã´ÈÆ¥Â›Ã³Ì’Ï…Ã´Ã³Ê¶É™Â˜Æ§È„Ï‚ÌŽÆ§È‚Ã´Æ¨Æ¨Æ¨Ï†É›ÌŽÅÆ¨Ê·Éž@Ï‚Ô®Ã³ÅŒÃ´Ã´Ï†@ÉœÖˆÌŽÆ¨'],
                    'encodeOffsets': [[
                            111150,
                            32446
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'ning_xia',
                'properties': {
                    'name': 'å®å¤',
                    'cp': [
                        105.9961,
                        37.3096
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@à°²Ì’Ã´Þ Ï†Ó’Ï‚Ã´ÆªÍ§Ï…Ö‡ÉœÅ‹ÑºÃ³ÌŽÈÌÉ›@Ñ¹×¡@@ÊµÆ§ÈÃ´Ã³@Ç¿ÌÅÃ¶ÊµÉÅ‹É›@Ã´Ì‘Æ¥Ã³Ã³Æ¨Æ§Â—Ã³Â˜Ã´ÂœÃ³@Æ©Ã´Ã³Æ¦ÌÂœÃ³È€Æ¨ÅŽÉ›Ó’Ã´ÅÏ…ÍªÉ›@@È€É™@'],
                    'encodeOffsets': [[
                            106831,
                            38340
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'hai_nan',
                'properties': {
                    'name': 'æµ·å—',
                    'cp': [
                        109.9512,
                        19.2041
                    ],
                    'childNum': 18
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ï†ÉœÆ¦Ê¶ÌÃ´Ï†Ã´ÌŽ@Æ¨ÅŽÃ¶@Ï„ÊµÆ¦Â˜Ô©Û«ÃµÐÌÃ³Æ¥ÈƒÆ§@Æ©É™×Æ¨Ì‘Æ¦@Þ¤'],
                    'encodeOffsets': [[
                            111240,
                            19846
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'tai_wan',
                'properties': {
                    'name': 'å°æ¹¾',
                    'cp': [
                        121.0254,
                        23.5986
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã´Â—Æ©ÉÃ¶Æ§ÉÑµÉ™Þ£ÌÏÆ©Ô­Ã³ÅÃ³ÍªÏÉžÆ§ÐžÃ´ÔªÝˆà¬¦Ñ¶ÉœÌ’É›'],
                    'encodeOffsets': [[
                            124831,
                            25650
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'bei_jing',
                'properties': {
                    'name': 'åŒ—äº¬',
                    'cp': [
                        116.4551,
                        40.2539
                    ],
                    'childNum': 19
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã³Ã³Ã³Â›Ï…Ã³Ã´Æ¥@ÅÃ³Ã³É™@Æ§Å‹Æ©ÅŒÏÃ³É›ÅÃ³Ê¶Ñ¶Ê´Æ¥Ê¶ÌŽÂœÃ´Æ¨Éž@Ã³ÅŽÉœÅŒÌŽÌÏ†Â›Æ§Å‹Æ¨Êµ'],
                    'encodeOffsets': [[
                            120241,
                            41176
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'tian_jin',
                'properties': {
                    'name': 'å¤©æ´¥',
                    'cp': [
                        117.4219,
                        39.4189
                    ],
                    'childNum': 18
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã´Ã´ÉœÂ—@Æ¨Ã¶ÉšÃ´ÂœÃ´Ã´ÉšÅ@Ã³Æ¥@@ÈÆ¦Æ§Éœ@Ã³Æ§Æ¨Æ¥@Â›Æ§Ã³É™ÐÌÃ³Ñ·Éœ@ÅŽÆ¦Æ¨Ã³Ðž'],
                    'encodeOffsets': [[
                            119610,
                            40545
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'shang_hai',
                'properties': {
                    'name': 'ä¸Šæµ·',
                    'cp': [
                        121.4648,
                        31.2891
                    ],
                    'childNum': 19
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÉžÏ‚Æ¨ÂœÉ›È€Ã´ÅÚ”É›Ã³Ï…Ã´Ì×ŸÅÌ‘Ì’'],
                    'encodeOffsets': [[
                            123840,
                            31771
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'xiang_gang',
                'properties': {
                    'name': 'é¦™æ¸¯',
                    'cp': [
                        114.2578,
                        22.3242
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã³É›Æ©@Ï@Ã³ÂœÃ´È€ÉšÅŽÆ¨@Ã¶@@ÅÆ¨@'],
                    'encodeOffsets': [[
                            117361,
                            22950
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'ao_men',
                'properties': {
                    'name': 'æ¾³é—¨',
                    'cp': [
                        113.5547,
                        22.1484
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XÂÂ¯aWÄ€Â„@lÂ'],
                    'encodeOffsets': [[
                            116325,
                            22697
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/chong_qing_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '500242',
                'properties': {
                    'name': 'é…‰é˜³åœŸå®¶æ—è‹—æ—è‡ªæ²»åŽ¿',
                    'cp': [
                        108.8196,
                        28.8666
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XJÂ°ÂœlJX@lbl@XbV@VLnJlxnbÂšÂƒUU@IVK@lVIVwnJlU@n@J@L@Jn@l_nWVLVln@@blLÂšmV@@xÂœÃ”Â‚`nÂœÂ™xVÂ‚ÃˆLlxÂ„LVxVVÂšÂƒV_UÂ»VWn_mÂ¥XwVmnXÂ°ÂƒlmUUVwÃžaVÂƒÂk@a@mmIUa@Â™mwk@Â™Âƒm@@UÂ¯a@UV@@KÂ™Â@ykkmwkV@kU@ÂƒÃ‘ÂƒVkKWLÃ…amaUÂm@kyU@WkU@UaÂ™IUaÂšÂVaUUmUUa@aVLXKWaÂ¯UUbmJXnWnX`l@@xkzWÃ†@VÂ„LUÂ¦Â‚x@b@JkIkJ@LmbUamJÂwm@Ã³xÂƒnk@VÂ„@xÂ„ÂŽVnUVmVUÂVÂŽUbVlUbkXWÂŽ'],
                    'encodeOffsets': [[
                            110914,
                            29695
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500236',
                'properties': {
                    'name': 'å¥‰èŠ‚åŽ¿',
                    'cp': [
                        109.3909,
                        30.9265
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@WVXbÂ‚UnK@x@bÂ‚Â²kxmKklÂ¯_ÂƒVVÂ°Â™VUÂ@bnKVVV@@nkÂŽ@nÂ›bnÂ‚@ÂšÂ°@VLÄŒUÂš@Â°WV@VÂ™nU@InKVÂl@nUÂ„bÂ˜KnXÂ„WlknLlKUwnalLÂšaÂ„VlUXmWk@UU@UWWIUyÄ·Â¹XaWW@ÂXÂ™ÂƒKUIVmÂ„U@W@UVU@KV@nÂ»VkUkÃ‡mUmVIUmULUbm@ÂƒwUaÂƒKkkmÂÂ¯Ã‘UL@bWVnx@VmxUI@Â„klmkkK@aÂƒK@IlJ@IÂ¯Âƒk@mak@mnkJVL@bV@UbÂ„Â„W`UUUVÂ™I@VÂƒU@VVbUJVLUVVbUXÂ„VVxkÂ¦VJUnVxnVVUÂšJV@Ubl@@bXV@L'],
                    'encodeOffsets': [[
                            111781,
                            31658
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500238',
                'properties': {
                    'name': 'å·«æºªåŽ¿',
                    'cp': [
                        109.3359,
                        31.4813
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nLWbXÂ‚VLVUÂ„V@KÂšIVl@bÂ„@lbÂšUÂ„VnU@JÃ†U@V@nÂ°KÄ¢Ul@VbÃžKÂšVÂš@Â„_Â„VÂ‚KXUÂ‚U@KXÂƒ@wlkkU@mWKUU@UÃ´J@XV@ÂœaVmÃžIVaVLÂƒÂƒ@Â»kmÂƒ@ÂƒUkLÂ™U@aU@WWÂƒLUUUÂ™Â™KkbÂƒwWa@KU@kaÂƒXmWÂ—LÂƒamVk@UÂmL@JmVUÂšU@Â¯XÂ™@Ä‹VUKÂ¯@Ã…nWKÂ™LkKULWK@UXK@wW@Â™LkV@bVLÂƒlXnÂ›`Â¯xUÂ„Â°LnÂŽlV@nÂ°Lnl'],
                    'encodeOffsets': [[
                            111488,
                            32361
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500234',
                'properties': {
                    'name': 'å¼€åŽ¿',
                    'cp': [
                        108.4131,
                        31.2561
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@n@naÂ‚IÂ„wÂš@@VVKÂ„LVbVxnVÃ†UnanKWÂXamKmkÂ¯K@mkUmÂÂ¯KVÂƒÂ°wÂÂ@Wm@UIUUlKUU@aÂ¯KWanwmUXamKkÂUÂWUnU@KÂƒkUwWKXaWLUWkImaUUUÂƒÂƒKkaÂ±Âk@lÂƒÂ¯wÂ™wmbUÂƒÂ™ÂƒkXm@UJkIWÂ‚XXÂƒbÂƒmÂƒÂ„UJÂ™XUV@Â°ÂšKlÂÂšlVXÂV@xmbnV@blV@VÂšÂœU`UL@VÂ™a@bULlbÂ°VXbÃœÂš@V@bÂƒL@JÂ„xnLVb@lVb@VÂ@@zÂ˜bXWÂšXÂ„KVLVÂ‚Âš@@bUVVL@bÂ„Â„lVna@ll@Â„zl@@J'],
                    'encodeOffsets': [[
                            111150,
                            32434
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500243',
                'properties': {
                    'name': 'å½­æ°´è‹—æ—åœŸå®¶æ—è‡ªæ²»åŽ¿',
                    'cp': [
                        108.2043,
                        29.3994
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„Jlb@nVV@bXb@Ã†lLÂ„Ul`nÂVKUÂ¼VxkbWÂ„nlUxlXXÂ‚@ÂÂ°Â°WnnJ@VUn@JÂ„kÂ°L@VlV@nUJÂ„x@bVVVz@VnLlaÂ„KnalVlIUÂŽÂ„Â¼@nV@@anKUwVal@UÂlJÂœÂƒlI@akU@UWÂXKVIÂ‚Â¯Uak@@KmkXWÃœkXÂWykIWwXw@ÂlaXamkVUUym_XmlkkmmakwmIUKU@Wak@kaW@kIÂ¯Â›WIkÂ¦VÂŽÂƒUUÂƒmaUV@XkVUVÂ±aUbÂ¯bÂ¯Â¥m@@ImJÂ—@mÂƒmL@kUKUkkJÂƒbVÂ¦'],
                    'encodeOffsets': [[
                            110408,
                            29729
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500235',
                'properties': {
                    'name': 'äº‘é˜³åŽ¿',
                    'cp': [
                        108.8306,
                        31.0089
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lbÂ„LVÂ„VVnblJVXXKWbXLVxÂ„l@LmVXVVÂlÂ‚nLWbnVmxXbÂ°L@bVVkLVVVJn@@XÂ‚Â‚Âœ_WmÂ„kUK@alUÂšKX@@xWL@VXLVKlLÂšKXLÃ†m@Â™mÂÂœa@mlÂ@mU@UUmL@aVÂÂšUUÂ¯Â„UÂ°`lknLlwÂÂ±@a@wmLÂVWaXU@KWU@ak@VaU@Â™IUVmUUwVmUIlÂ¥UwÂƒUVWUaVUUKVIUa@UUUUJÂƒUUmÂ™kÂƒÂ„nl@Â„@VWV@LÂ¯aUbÂ™UlxÂƒ@@b@VULUx@VUxVVÂ™U@bU@mxUÂ„U@mUVÂŽklkkÂƒ@WxknlxÂK@amLÂƒKUÂ„ÂK'],
                    'encodeOffsets': [[
                            111016,
                            31742
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500101',
                'properties': {
                    'name': 'ä¸‡å·žåŒº',
                    'cp': [
                        108.3911,
                        30.6958
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ä¸ÄŠVIÂ„ÂƒÂ„nÂ„aWWXÂlJVIn@lWÂšÂ„VÂ„naÂšxÂ°xkÂ„l@Â²ÂŽÂ‚LVÂƒÂ„LnK@bÂ‚LkwlmXwÂ„@lllkUÂnVV@VÂƒnwV@@aÂšVUUVw@UVwVK@U@aÂ„@kwÂšVVaÂ°b@KXU@U@ÂƒmkÂ„ÂƒÃ‡Ã‘ÂamlÂ™kUVmn@VULUÂ˜m@kUVkUaÂƒwUWm@UwÂ¯Â„mKUUmVUUULUKUÂ„W@XbWVkaWwkUUÂ™ÂƒÂ™k@maUbmbVlkÂ¦ÂƒxUVUIWVUÂ„kJVVkL@UmJÂ™UUVU@lLUVUÂ„lxÂ„@@ÂVbÂƒJÂ™UÂ™LÂ¯Â¤@VÂƒÂ„'],
                    'encodeOffsets': [[
                            110464,
                            31551
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500229',
                'properties': {
                    'name': 'åŸŽå£åŽ¿',
                    'cp': [
                        108.7756,
                        31.9098
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VK@wÂ¯L@m@UÃ…V@ImVÂƒUÂ™VkaÂƒ@@aUkÂ™J@LÂƒUUVUKmLmbÃ…VmUUwUaÂƒKUL@UÂ™@ÂƒxÂJmbm@ÂnVJ@X@VkVÂ‚nÂ™lÂƒLXxÂ™@Âƒb@bUVÂƒLU`UnÂƒbU@@ÂŽmVVX@JX@VLVVÂšklVÂ—Â„Â‚`@bUL@VÂ„LVKn@Â‚U@Â„UJkn@lmLmK@X@Jn@mbÂ„nÃžWVXnJÂ‚kÂ„KÄŒÃ‘Ã†@VK@knaÃœmXÂlUÄŒWÂ°kÃ´Ã‡Ã†Â@a@yÃž_VmÂƒUnU@K'],
                    'encodeOffsets': [[
                            111893,
                            32513
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500116',
                'properties': {
                    'name': 'æ±Ÿæ´¥åŒº',
                    'cp': [
                        106.2158,
                        28.9874
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„InWUUlU@LVaÂšlX@Â°Â²lÃ’XxlK@Ul@@Un@UaVJ@I@W@UÂƒUUVUwVIUKUaÂ‚UUÂVwn@Ãœx@XUlnnÂ‚bÂœJ@Â¥VklKUUlk@ynU@kVÂƒUUVWnI@Â¥VÂ£VWVIUKU@UVÂƒa@n@Vm@@nÂlUaVkUwÂƒJ@blLkLW@XWmXkmmLnÂ™@m@U@UVm@Â™Â„UVÂUUlakUVaÂ„ÂƒVkV@@wnaWUk@VwkÂƒlmVIkUUxmJ@UÂ„Â™@KÂƒIkxÂ±V@IUm@K@IUKkbWKUbnÂ„mÂ„@bmVnbmb@xkxUJ@ÂULW`@bX@WVXL@VÂƒÂšÂ¯Â„mkÂ¯@UJ@VmLUaWnX@WJ@nkKkxW@UIV@@KkImmkK@UW@XaWIU@UÂ‚ÂƒIkbWbÂ„xXÂŽlLVbnV@bWlX@VxVLnl@nÃ†ÃžVÃœ'],
                    'encodeOffsets': [[
                            108585,
                            30032
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500240',
                'properties': {
                    'name': 'çŸ³æŸ±åœŸå®¶æ—è‡ªæ²»åŽ¿',
                    'cp': [
                        108.2813,
                        30.1025
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„Âš@kl@ÂšÂ¼UbmVXJ@bV@nxVIVJULVVk@@LWbnJVU@bVbUJ@blLXnWVÂ—@mbnVÂ‚@VÂ„Â„bn@VJVLnaVanbl@Â„ÂšVÂšlVXxlbXUWaX@VÂƒUUVwUUVm@I@WmI@aÂ„mlLÂœÂ™lK@alwnUV@kÃ³VaÂƒÃÂk@UlbVK@Â™VUÂÂ»VÂUÂUVWUÂƒ@U`ULkwm@@KmU@knKÂƒÂ»VÂkJkUmbÂƒLkbmK@UUyUU@aÂƒwm@@XXJ@VVLVVUbVnUJVX@KÂ„Â„k`WXXJWXUbmW@bkLÂ™Um`XnÂƒb@JVL@LU@Â™Â°VVXKVnUxVLUbmJ'],
                    'encodeOffsets': [[
                            110588,
                            30769
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500237',
                'properties': {
                    'name': 'å·«å±±åŽ¿',
                    'cp': [
                        109.8853,
                        31.1188
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@kVÂƒUÂ™bkKmbVxkLmKkllbV@@LXbÂ„xlaÂšLVÂšVVÂ„KXXV@@bÂšVlKÂ„VÂ„@ln@Â¼Â°KXaÂ„U@UlwÂ°JXalIUaÂ„ÃWÂXW@kVU@ÂƒVUVWUUUamUÂw@aVamwn@VUUÂƒlLXWmÂ£@wÃ‡Ä‰kKklmLUÃ’Â¯ÂƒWnÂ™@ÄŸÂÂ±ÂkwmaÂWmÂ¼U@@LUV@V@XÂƒVUnVJÂ„LWÂš@Â‚XXWbÄ¸ÂºVzXJVXV@@VXlWn'],
                    'encodeOffsets': [[
                            112399,
                            31917
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500102',
                'properties': {
                    'name': 'æ¶ªé™µåŒº',
                    'cp': [
                        107.3364,
                        29.6796
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nÃ¨VblÄ–VVnLÂšÂŽÂ„@ÂšxÂ‚VÂ„n@nÂšJ@LÂ„UVVX@lbUJV@@nn@VVVK@zÂ„Â˜V@nzVJVUlmX@@_VVVbnaVal@@knW@wnaÂƒÂVK@aVIÂ„J@Â£kUVW@ÂÂ‚wXUVJÂ„amÂƒ@IkÂƒÂƒÂƒÂƒ_XÂ¥Âƒ@WwkKkwmÂŽÂ™ÂšÂƒkUxÂƒnÃ…mmÂ¥Â™ÂÂWVÂ@Um@UlVL@JU@@XÂƒ@UVkKVkÂ™KVkÂ™Kkb@bmJVXUÂ„VVUbU@@`W_UVÂ¯b'],
                    'encodeOffsets': [[
                            109508,
                            30207
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500230',
                'properties': {
                    'name': 'ä¸°éƒ½åŽ¿',
                    'cp': [
                        107.8418,
                        29.9048
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÃžÃ¨@XUK@LlV@blbUJ@Â„Â„V@bnVÂ‚Â@VVVXU@ÂƒlbXal@VXnKV@maXUÃžÂƒ@amk@aVKXVÂ‚anbÂšÂ£Â°mnIVaUKVwUmWLUUÂšÂ¯V@@KUK@IÂ„aWmn_ÂšVlK@anXVaXWWIXWl_ÂƒÂƒ@LUWVIUmVaUUUK@UWI@Wn@VI@mkU@UÂ¯KÂƒl@ImVÃ…LÂƒwUÂ¤Ã³bUU@wWÂXkmm@LU@@VUIWVUL@JUnÂƒaÂƒx@JnÂ„ÂƒbUIWVÂx@ÂŽUXlV@Â¤ÂƒIUJ@bULÂ„ÂŽmb@xmX@lk@UbmbUaUU@`W@kn'],
                    'encodeOffsets': [[
                            110048,
                            30713
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500232',
                'properties': {
                    'name': 'æ­¦éš†åŽ¿',
                    'cp': [
                        107.655,
                        29.35
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lÂ„Â„wÂ„bVm@IVKXUVJ@UV@@KnnWlXÂ@xVVÃ´aVÂ£Â„xÃ†KnUVm@UmIXmÂ¯Â¯@ÂWÂkWVwmkXÂƒlaUwVÂ»ULmÂk_ÂƒVkK@Ã…Wa@aUU@mkaÂƒIÂƒb@Â‚nÂ¼ÂƒnmÂ‚Â_@mmK@UÂƒLUVÂVmI@aUJ@XWJ@ÂU`UIkmÂ±kk@@lULmUmKUnVÂšnlUVmI@VkVlxÂ™bkIÂƒVmLUxkKUÂŽÂ‚XÂšÂ‚nÂ¦Ã†nÂ„mVwÂ„lÂšÂ™nÂlxlLXxÂ„@WÂ¦Â„`Â„Â„'],
                    'encodeOffsets': [[
                            110262,
                            30291
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500119',
                'properties': {
                    'name': 'å—å·åŒº',
                    'cp': [
                        107.1716,
                        29.1302
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VÂšUbVJVUn@VLX@WVXVVI@VUVWxU@mÂš@ÄŠX@@Â¼VÂÂ°aVUX`@_V@VaUUVÂƒUWnI@alaÂšLUlÂšLUllLVUÂ„@@WV@@IUKVkn@@VlLVwnKÂ„UlJÂšakwlU@UnJVUmkUÂ™VmXa@wVK@UUwÂ™@VÂƒVI@akÂƒ@alInwlKXUmaUW@wWLkÂ™Â™KVak_Ã‡aUÂƒÂƒV@ÂšXbÂƒLVxUlWIk@UK@VÂ™@ÂƒkU@VbUVUlVnÂƒLUV@lVXmxkV@L@V@Vk@WbUwmL@JUI@xVxkx'],
                    'encodeOffsets': [[
                            109463,
                            29830
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500241',
                'properties': {
                    'name': 'ç§€å±±åœŸå®¶æ—è‹—æ—è‡ªæ²»åŽ¿',
                    'cp': [
                        109.0173,
                        28.5205
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XlV@lzn@VÂŽnbÃ†bXKlLÂ„UÂ„Ã’V@@llUnxll@zÂšÂŽ@LU@@VÂ°b@Vn@ÂšÂ„l@VÃ‘UÂƒnK@UÂšU@aUaÂƒkVm@KÂ¯wÂƒklmnnÂ„Ul`nI@almkIUwmWVkUaÂƒkkJmUUa@K@aU@@_m@@wUyVUUa@UmÂƒ@aÂwlÂ@WkaÂ±Â„UkUykIWVÂ™b@bUVk@Â›aU@UXUÂ‚UIWakUWmUxUV@nUVWbÂšÂŽ@XXVVÂŽmXXÂŽ@VÂƒbVLkVWx'],
                    'encodeOffsets': [[
                            111330,
                            29183
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500114',
                'properties': {
                    'name': 'é»”æ±ŸåŒº',
                    'cp': [
                        108.7207,
                        29.4708
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VX@V@LV@VJUL@lVnnxlb@VXVÂ‚XV@@WÂ„@UIVK@kUKna@Â£VWUaVUUalIVJVIUWÂ„_lm@bXKV@mn@JÂ„UUw@KnIVll@VanLVmUkVKXLVKUIVamw@ÂUaU_lwÂ„KlwUWV_Ua@aUa@KUÂÂšwmÂ›Â_Â›Ã“@wU@Â™nkK@am@UkUKmXk`m@@I@K@I@mkVmIUxUJ@kUL@JVVÂ™Â„lnklWnn`VzUVnlWbkb@ÂWxXxlJXzWÂŽÃ›lWXnl@Ll@VbÂÂ°UJWLXÂ@VlV@bkJ'],
                    'encodeOffsets': [[
                            111106,
                            30420
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500117',
                'properties': {
                    'name': 'åˆå·åŒº',
                    'cp': [
                        106.3257,
                        30.108
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XKVXlKÂ„ÂƒVL@UnV@aValXXKÂ„U@WVwUaVU@IV@@aVWÂ„L@U@anVV@@bVK@UVL@bnJWL@VnUnbÂ˜@@JnIlVÂlÂ‚@@bXIWbn@UKVLVKXLlaV@VVnK@bVLÂ„mÂ„IVÂƒ@KmknUUWVI@aVJ@_Â„WU_VmUwÂƒU@KÂ™ÂƒVaÂk@amÂ¯mJU_UJUkU@WÂkIV`UI@JVÂ@LmmU@@mÂƒbUzÃ…Â›Â™Â@Â„VK@nUKÂƒÂ„ÂƒbÂ™akb@UWK@bkVVbVÂ„Ã›@@`ÂƒXk@WÂŽ@n@lXL@bmb@VVJUn@JnUlnUlmX@`XLlbkJW@kzlb@`@b@b'],
                    'encodeOffsets': [[
                            108529,
                            31101
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500222',
                'properties': {
                    'name': 'ç¶¦æ±ŸåŽ¿',
                    'cp': [
                        106.6553,
                        28.8171
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@Â¦Â‚@XÂ„lVX@@UVKlÂ„VUX@lanVlUVbXWVXVÂƒÂ„VVUnKVUlwUwU@UJ@nmVkUVÂ™lwXam@VaUUUw@W@kkÂ»mV@UmKkwVKVUU@@LUKVI@mV@XVWxnXVKUUUK@wWU@UUWnUlLXaÂ‚mUIÂ„amÂ@wÂI@K@amImÂ‚UUkI@mÂ‚akUkKWUUanÂƒ@wÂƒamLVxk@UVmUUL@Vm@kV@I@ak@@bWVXJlLVbVL@Âš@bn@@`UnÂ„@WbUKULWVXbÂƒ@UVmbXÂ„WVÂƒb@bÂVmxUKUÂÂƒV@ÂšUn@V@V@nmÂšnKlnnWWXX@lKkK@aÂ„IVxUlVbÂ‚k@mn@@U@mÂ„bVUV@VLUJUXUÂ¤'],
                    'encodeOffsets': [[
                            109137,
                            29779
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500233',
                'properties': {
                    'name': 'å¿ åŽ¿',
                    'cp': [
                        107.8967,
                        30.3223
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VLÃžÄŠÂ„U@WÂšÂ@Â¼VÂ‚Â„@lk@wÂ²mlÂšVUÂœÂ„llÂšVnI@VlKUUlIVÂƒXUVJVUÂ„wlÂ¥UkUKUIm@ÂƒaUÂƒÂ@mUnaÂ˜@XUWmkK@aVIUa@aUVmIXa@Kl@UUVKUIUJmwU@@aWInUVaÂ™Â»k@@lÂƒÂ™Â¯nÂ™Â¤maÂbWUUL@bnl@bÃÂ„WVnbU@mLUWk@Wbka@Â„WVUU@UÂÂmUmVkUULVÂ„lVUxÂ„l@L@VÂƒbÃˆÃ’lb'],
                    'encodeOffsets': [[
                            110239,
                            31146
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500228',
                'properties': {
                    'name': 'æ¢å¹³åŽ¿',
                    'cp': [
                        107.7429,
                        30.6519
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XLV@VV@bÂ°Â°nÂšÂƒnkb@bÂƒÂšnJWVXblIUVÂšxWnUJnVVLVUÂ„JlUnLVK@UnUVJÂšÂ²nKVbVKla@aXÂlJÂ„kÂ„KlbÂ„Âƒ@UÂ°Â£ÂšKÂšVÂ„IUa@ÂÂƒ@kwVÂƒVUkKV@VUkkÂ›ÂƒUVkÂ™Â±n@xklÂƒ@UÂ@Â»Â™Â‚@XÂƒVÃÄ‰UJnxWbÂ@UXÂ›KkVUbUKWUkVmkkLU`Â›b'],
                    'encodeOffsets': [[
                            109980,
                            31247
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500113',
                'properties': {
                    'name': 'å·´å—åŒº',
                    'cp': [
                        106.7322,
                        29.4214
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nxnVlJlUXLÂƒÂ¦@x@Vl@nKVVX@V_V@@KlVXUÂ„@lKlxXIl@ÃˆÄŠ@Vl@n_VJlÂŽnÂVlnbÂ„Â²VVVJVÂVmUUkÄ•UamÃ§UÂ@Â»W@@Ä‰nÂ™V@XwVU@UUJWUXUW@UKm@UVUIVaUÂ™UVmLUVÂƒUUÂ„UWWXUakVmUkbW@UVkÂƒUL@VW@kUWÂƒÂ@mJUXVVUÂ„@lmV@zklVVkLUl@Â¦Â›I'],
                    'encodeOffsets': [[
                            108990,
                            30061
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500223',
                'properties': {
                    'name': 'æ½¼å—åŽ¿',
                    'cp': [
                        105.7764,
                        30.1135
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@a@a@_kalyX@lIkaWK@_nWVkkmmV@IVmUI@Una@aWK@k@mkbWaknmJUk@mk@@kUal@UaÂš@Wa@aXLlwUKlkkÂƒ@KmI@VUJ@Lk@@VUUmL@amJUÂ£kKUaWakLmU@bVVUbnbWV@xkL@bUbÂ‚xUxVbXJVbUVWIUVU@kLWxkKWV@nÂ¯VUbU@@VVX@VmaUL@VUK@VVbn@lVnIÂ‚@@lnLULm@Ub@ÂŽl@naÂ„@lK@XVVkJ@b@zl@@VnV@bVb@J@bnXV`lXXmVI@W@InbV@@aVKUblKVLUanLlmnLlK'],
                    'encodeOffsets': [[
                            108529,
                            31101
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500118',
                'properties': {
                    'name': 'æ°¸å·åŒº',
                    'cp': [
                        105.8643,
                        29.2566
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@bÃœÂ„nWVLXÂ„lxVÂ„VxXxlVn@@bVblK@a@UnLVJV@@UnLVU@VXaVKVXÂš@n`WÂUÃ¿@IUKlaUUUkWyUÃ›Ã…Ã@mmkUKUwW@Xk@amUUakKWÂÂƒwXaÂƒK@VVLklÂƒXVlkxVÂ„UL@bm@Vxn`ÂƒIVxUVkLVÂšUÂšl@@lkXmmÂƒVUn@VV@Xb'],
                    'encodeOffsets': [[
                            108192,
                            30038
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500231',
                'properties': {
                    'name': 'åž«æ±ŸåŽ¿',
                    'cp': [
                        107.4573,
                        30.2454
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÂšÄŠÂ°Â¤nÃ’Â˜Â¼ÂœaV_lKnllUXVVLValUÂœLVWÂ‚@XamwVIUKkaÃ‡Ã‘Â„a@U@KÂƒkVwkUUÂƒVKlVnU@aÂƒU@ÂƒVIka@akU@KVL@WÃÃ§UV@VmbÃ…Â¯@LÂ™KÂƒnnJWÂ„ÂƒVkxlL@VX@VxmnXVWxUb@bkn'],
                    'encodeOffsets': [[
                            109812,
                            30961
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500112',
                'properties': {
                    'name': 'æ¸åŒ—åŒº',
                    'cp': [
                        106.7212,
                        29.8499
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@bVVXLÂ‚a@lnbWn@LÂ„@XVlK@VVLUVlbkLUKVVVL@VÂšnXÂ‚VL@VV@UbVb@x@Â¦UxVb@bUJÂƒL@LÂ„VVxlK@Â™nk@U@WÂ„UVLlKXVÂ„@VblU@UUKVU@wn@VJVanLlkX@VaVKÂ™Â¯@a@U@U@ÂƒVaUKÂ„kUUÂƒÂ±maUkm@UUkbm@@Vk@@JÂƒwU@Ub@I@JmwUL@aÂƒ@@KkVÃ‡LkÂƒWkÂƒ@kUU@@xUVmKUnllUb'],
                    'encodeOffsets': [[
                            109013,
                            30381
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500115',
                'properties': {
                    'name': 'é•¿å¯¿åŒº',
                    'cp': [
                        107.1606,
                        29.9762
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VVÂšUÂ„bXÂ‚lXÂ„Â¥l@XnVmlxUxÂ„@@blVnnÃ´Ä€lm@aVaXwWUnmUwW@@UkKlwÂ„UXÂƒmIÂ„mÂšL@KÃ†Â°na@UUImyU@ÂƒÂ—@yULUUm@@mU@VIkaW@UUÂƒV@KÂ™I@mÂƒmÂUÂ™wÂƒ@Â™ÂmKUnUÂ‚UIÂƒlVLUb@Â„@V@V@bÂšÂ°ULUbW@klmKUbUIm@@xUVVL'],
                    'encodeOffsets': [[
                            109429,
                            30747
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500225',
                'properties': {
                    'name': 'å¤§è¶³åŽ¿',
                    'cp': [
                        105.7544,
                        29.6136
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XUmaVaUU@anVlKXbValU@aV@@IXKÂš@@bV@VxVK@UXLlUÂšJXa@_Â‚@@aVKÂ—Ã…WVkwWaÂÂƒÂƒwUa@am@kUWLU@kWmX@ykI@W@UV@na@LlLV@UÂƒkwWÂƒUKmXX`mIVl@bXLWVkbkkÂƒx@`VXm@@J@U@UUKUxk@WbUIVl@VXLWÂ„ÂƒJUkUlUImxXlmb@X@VUJUnVbÂšW@UV@@VVX@bnW@LVxUnlJUV@nÂ„@VxVIn@l`Â„UVVVL'],
                    'encodeOffsets': [[
                            108270,
                            30578
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500224',
                'properties': {
                    'name': 'é“œæ¢åŽ¿',
                    'cp': [
                        106.0291,
                        29.8059
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VblLVÂ¤nI@bnKVV@Ul@@KVI@UnJ@LlÂ„klVLkxWK@bXbÂ™@Vbk@Vb@ll@@nVlnIlmXblaXÂl@Â„W@_Ãœ@UÂƒUalU@aXL@VlaÂšbÂ„aÂ„ÂƒVL@mUL@ÂƒUUÂƒÂƒÃ‡ÂXUWÂ›X_WaÂƒÂƒUÂƒÂÂ»m_Â™@UWULWb@UUVmK@VU@UImK@V@bkLÂ„xÂ‚Â„XblxXUÂ˜Ã†UL@bÂ@@`WbÂ™IkVWK@VULUwU@@aÂ™@WL@JU@@bkVUb'],
                    'encodeOffsets': [[
                            108316,
                            30527
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500226',
                'properties': {
                    'name': 'è£æ˜ŒåŽ¿',
                    'cp': [
                        105.5127,
                        29.4708
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VI@U@WnaWknwVJVkVlÂ„IXÂƒWK@UUkVJXal@VwVL@V@V@In@UW@_Â„wlllaXUWK@aUknJW_Ã›Âƒ@aWaU@@UVmÂ„UUaUImJVnÃ…UmVÂUm`kUUVWLnVU@VVmXÂƒK@Â„nxmÂŽULkxÂ™ImJ@nU`@X@Vkn@`@nlV@nVJVaXÂ„VLnK@bVV@nV@lbXWÂš@'],
                    'encodeOffsets': [[
                            108012,
                            30392
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500227',
                'properties': {
                    'name': 'ç’§å±±åŽ¿',
                    'cp': [
                        106.2048,
                        29.5807
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XzVlVVkbVL@JVÄ€XÂŽÂ‚Â¼VÂ„Â„Â„XbW`XÂœWVÃˆÂŽÂ„Â„VVÂšÂŽVkV@@UXa@alK@IÂƒÂƒU@UKWÂUyUI@wVUUWVak@VUkÂƒWÂ¹@WXI@yVIUK@kWwkÃ‘Â¯Â±W@Â™kUb@KkVVVmXÂƒJ'],
                    'encodeOffsets': [[
                            108585,
                            30032
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500109',
                'properties': {
                    'name': 'åŒ—ç¢šåŒº',
                    'cp': [
                        106.5674,
                        29.8883
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XÂ‚VLV@Â„Â„@JkL@bWb@VU@UlÃ†ÂœVyÂ„a@nV@nn@KUÂ@IVJU_lJXÂV@VlVIV`nInÂ°@bÂ‚lUbÂšÂ„Â„KVI@aUaVw@Â¥@wUaVaU@@UUKWÂÂ™m@UUKUUVLlKkaVUUK@UkLWUÂƒ@@KXmma@kÂbWKUU@aUamLnÃž@VWLk@@Wm@ULU@@UÂ™KUVWI'],
                    'encodeOffsets': [[
                            108855,
                            30449
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500110',
                'properties': {
                    'name': 'ä¸‡ç››åŒº',
                    'cp': [
                        106.908,
                        28.9325
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VIV@@wVJ@InKVxXal@@U@U@KlUnwUW@kVUÂ„KUmVkUa@I@KW@@bk@@mÂƒU@m@k@a@aÂƒIUxmJk@ÂƒwULÂƒwkKmVVX@VXV@xVLVVULmWXwWUU@@nUJVL@KV@UVULlxnL@VnUlÂ¼@l@XVxVVUbn@WbkxUÂšlVnU@m'],
                    'encodeOffsets': [[
                            109452,
                            29779
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500107',
                'properties': {
                    'name': 'ä¹é¾™å¡åŒº',
                    'cp': [
                        106.3586,
                        29.4049
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XKÂ‚L@VÂš@XbV@lW@UV@@VXIV@UÂ™VKlL@KnÂnJ@VV@VU@IÂ„@@mVUVWUUmL@VÂ¯LUK@UV@UU@a@U@yU@WLUK@X@KUVmL@Âƒ@aXI@w@ammVk@WÃ›wm@UxVÂÂVVbVLUJVxVUÂ„V@V@X@JUIVbm@@Vk@@VkL@lVLUJ@zWJ@X'],
                    'encodeOffsets': [[
                            108799,
                            30241
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500106',
                'properties': {
                    'name': 'æ²™åªååŒº',
                    'cp': [
                        106.3696,
                        29.6191
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XÂºlÂ„UVl@UbVXUV@xVJVzXJVUÂšL@VV@VKn@@Xl@XK@UmÃnKVbVakkVm@kÂ„ÂƒUK@UmImÂ@LkKULVÂšU@WJ@UU@@VkXU@WaÂ™@@UÂKWL'],
                    'encodeOffsets': [[
                            108799,
                            30241
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500108',
                'properties': {
                    'name': 'å—å²¸åŒº',
                    'cp': [
                        106.6663,
                        29.5367
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VVÂ„JVL@bUVVnl`XIlwXJlwÂ°nnlÂ‚IXW@UÃ‡Ä‰k@WJkwkLÂƒ@WVkU@LU@U`W@UXUV@n'],
                    'encodeOffsets': [[
                            109092,
                            30241
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500105',
                'properties': {
                    'name': 'æ±ŸåŒ—åŒº',
                    'cp': [
                        106.8311,
                        29.6191
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nLVU@wV@lVÂ„@XllÂ„ÃˆKlU@LÂ„@@bVKnx@I@JVaV@Â„x@Il@@Un@laVVn@mÂkÂUIm`k@WXÂJmkÂ¯mkxWIkxWJk_UmVUUKÂƒ@UUÂ™@ÂƒÂ„@l'],
                    'encodeOffsets': [[
                            109013,
                            30319
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500104',
                'properties': {
                    'name': 'å¤§æ¸¡å£åŒº',
                    'cp': [
                        106.4905,
                        29.4214
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@k@@U@wÂ„Â¥WKkVkImUmwÂa@b@xWJ@b@Â„nKVU@L@WVLXKV@@z@V@bVVU@@VVLÂ°K@U'],
                    'encodeOffsets': [[
                            109080,
                            30190
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500111',
                'properties': {
                    'name': 'åŒæ¡¥åŒº',
                    'cp': [
                        105.7874,
                        29.4928
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@WwUwU@kK@KmbU@@V@XlJ@znWlXV@XK'],
                    'encodeOffsets': [[
                            108372,
                            30235
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '500103',
                'properties': {
                    'name': 'æ¸ä¸­åŒº',
                    'cp': [
                        106.5344,
                        29.5477
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VLÂš@VVÂ„@VL@aUKÂƒIUUÂƒ@@JUVU@'],
                    'encodeOffsets': [[
                            109036,
                            30257
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/fu_jian_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '3507',
                'properties': {
                    'name': 'å—å¹³å¸‚',
                    'cp': [
                        118.136,
                        27.2845
                    ],
                    'childNum': 10
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@knyÂƒk@ÂÂƒKUÂ¥ÂšwV@nkÂƒWÂƒzUmk@@ÂlKUa@aVI@UÂƒKUamKUUVaUIÂÂ‚@XÂƒ@UV@KÂ±IUVVlUbUbUL@KWUXmWk@KkXmmkÃ…ÂƒKUÂƒÂ™a@amUÂƒbkUkKWUnwUÂƒÃ‡wVÂ™UUÂƒÃUKVÂ£UÂ™@ÂƒnKWwXLVKmÂ¥@wUXkmWk@Âƒ@wX@lUÂ„@ÂšyVImaXwVÂƒÂƒ@kÂŽÂƒnU@mbk@mlUXÂƒmU@mV@n@bnW@bUIWJÂ—ImVUKWbUK@nkKÂƒaU@W_ÂVUUmWmL@UU@Â™bUWUL@V@bmVUz@`mUUVVbXL@VÂ™L@lmLUxmVÂamXkW@xWbUÂ„VbUxkUÂ±@Ã…UmmkLUbW@@`kLknVlV@lbXxlVUXVVÂ™ÂŽUÂ„U@UbWÂŽkIWVUUUJkI@llbUxVL@VÂ™VÂƒUUÂ°ULUmWXUV@VULWbÂ@Â™xm@UaVLVKUa@ÂƒÂw@VÂ›bkÂmVÂambUUm@@VkK@Â„@bÂ„xlxX@Â‚Â„nÂ¤@XÂƒ@@lkLWV@ÂŽnÂ„VÂ„kb@bWJXLWx@nkxmmÂ™bXn@VWVUn@VnJ@bVXl@Â„Â™VJXnWbX`lLÂ„UlJVI@ÂŽÂœ@VXV@Vl@bn@@Ã†mn@VÂšxXU@mVIlxÂšVÂšÂšnIÂ„l@nVJÂ‚aXI@mlU@aXkVmÂ°klmnVV_naÂšÂ°@V@xÃœÂ¦XKÂ„VÂ‚nnUlVXbVKÂ‚LXKV@naV@@ÂVVl@@lXblXÂšWnLlbVKÂ²nÂš@@Â‚VLUnlV@lÂƒXÂxÃ´Â°Â‚V@UnaUUlKXLVUVVUbVVlUnJVXÂ„@VW@an@lbÂ„@nÂl@VU@anÂƒÂšUVW@kÂƒaUm@InVVKVU@ÂkUW@Uam@km@kVa@a@Â™nwÂšU@WlI@mVI@WXaW_nÂƒ@Â™nÂƒlkkW@UÂ‚Â¥@kV@Uw@wUÂÂƒ@@IXKÂ‚Â¥VIn@nU@`@Xl@VVÂ„LnaÂšWÂ‚bVaUwnUÂ„@VIÂšKlV'],
                    'encodeOffsets': [[
                            122119,
                            28086
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3504',
                'properties': {
                    'name': 'ä¸‰æ˜Žå¸‚',
                    'cp': [
                        117.5317,
                        26.3013
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lL@Un@VVnaÂ‚bnUlÂÂœa@UÂ‚x@Â„VbULUKVbn@ÂšwÂ‚@XaVK@UVUXWVnVKVÂ¯Â„VÂšU@UUKVwka@klJVIVVXUlJXÂVaV@VÂƒÂšÂUUVWkUWwkaU@UklmlK@_X@ValKnnÃ†VÂ²@lVVwUaVÂƒXa@wlXnWÂ‚bnUVwnK@kÂšK@UWKUaVUnV@_VynU@a@UVKVXÂšaV@@VnKnXVVÂ‚UX`V@Â„blL@mVLXaVLnUÂ˜JXIVJ@amX@a@mnUV@Â„nVWnkl@naV@Â„mlÂÂ„@@KmÂÂKUam@UU@Âƒ@UlKUÂ™VkÂ™UÂ™K@aVaUwVÂ™UÂ¥UIkJ@wmI@Â‚mbkwkVW@UXÂƒKULU`Â™IVKUa@LÂƒkkVmUU@WlULUWÃ…U@I@ÂƒWWÂ™nU@@w@a@ÂƒUam_XyVIVWkkÂƒ@mwVKXUV@nwÂ˜VXkWÂƒÃ…Â™U@ÂƒaÂƒUÂ¯KUnÂƒK@ÂƒÂ¯ÂšmUÂƒLXÂŽVLnWVbVbUVm@UbÂ¯Â¼W@ÂamÂÂƒ`kbÂ™amLUUUÂƒÂ™aUXV`@x@XmJ@n@L@xkJUU@kU@mWm@kUUwUUVWl@VUkIÂƒy@kkaVUUmÂ™IWVXbWxU@kÂ„mVkK@nWVXÂ¦WxU@@bkx@VU@WÂŽk@Â™kUbmJUUmkUW@_kKWKÂƒ@knVÂ¤kIUKWLUbVÂ‚Â@Wbk@@VWL@VkI@lUXVxUVU@@mWIÂƒV@aÂ¯nUaÂƒaUV@Â„ÂƒJÂ™b@bÃžÂ°VbUÂš@XÂ™aUVmL@Â‚VXÂblÂŽnVÂ„Â°Â˜n@VnxÂ„@VUUUlK@InJVb@Â„Vlnn@VÂ™L@VWJUÂ„Âx@XlJUVVÂVl@LUUUJ@LÂƒÂ„@lULÂ°Â¦kÂ˜VÂ„VnV@Â„xVÂ„Â„l@blLnlÂšLVaXll@ÂšnVUn@Â‚xn@nmlÂÂ°Â‚X@lb'],
                    'encodeOffsets': [[
                            119858,
                            27754
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3508',
                'properties': {
                    'name': 'é¾™å²©å¸‚',
                    'cp': [
                        116.8066,
                        25.2026
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÂšaÂ„I@ÂƒVUÂ„bVbÂ°m@bÂ„UXJ@nV@VUUwVW@klJ@UXK@Ul@XaÂ‚@UÂVaXKVLlJUÂ£lmÂ„@XLlL@`VXnlVVnIVaÂšll@XÂV@@Ulw@aV@XwWÂ¥XU@mlLnUlÂƒV@XwWaXUÂšJVnUVlb@lÂ„zlJUVk@UXVVVxlVn@nXV@@lVVlI@w@K@mnI@W@wU_VWÂšbVÂ„VVnKÂšblaÂ„_nÂÂ‚bX@Â°Â»Van@VUUaUamXUKWÂÂ„K@a@UkÂƒ@wWkXÂƒWW@wUUÂ™KÂw@_lyÂƒwUkU@@UÂƒ@kamVmÂƒXaÂšUVUka@ÂWk@Â»UUUVÂƒKkbWUÂ™VUbk@mkÂƒxkÂƒÂƒKnIVUmW@kUKmXUmVaU@kU@ÂmÂ@KÂUWVkIWJ@ÂŽU@UI@wUUUa@KWÂ»nU@mVkUmm@XwWU@ÂƒUUmLÂ@Âƒw@mnÂƒVÂUU@aWak@@amxU@UxULWVXbVLU`mbUImVUÂ„ÂƒbnÂ‚V@@bVn@bnVWxÂLmyUbÂƒIUKÂƒ@ÂaÂƒVmÂÂ™akbVÂ‚UXWÂ„UlÂKWbkV@Â„WLUlk@@nÂšbÂƒb@lkKmU@ÂƒUIWJkwÂ¯UUVVxm@@XkbWxÂ—ÂÂ›XÂKÂƒlUzWJkUUL@bmKkVÂƒ@@VUIUlWV@XÂ„K@VkbWxÂ°xUb@LUbk@@VWb@LXJ@VWXU@@bUVVÂ„VVn@VVlLnÂ„@lÂ„@Â‚xkÂ¦Vx@bVJXbÂƒn@JlnXxV@@Â„nJ@X@V@lmxÂ„bUn@xVL@VVKlL@lÂ„Â„nLVaVL@xkl@LÂƒxVlÂ°ÂšÂ„XÂ„WVXÂ„VlÂ„ÂœJWÂnxlJ'],
                    'encodeOffsets': [[
                            119194,
                            26657
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3509',
                'properties': {
                    'name': 'å®å¾·å¸‚',
                    'cp': [
                        119.6521,
                        26.9824
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@LVKVaVaUkVUÂ²J@LVUÂ„@@WÂ‚ÂVJUbVVnLVbÂ„L@VUJ@bVbkL@ÂŽl@VnÂ„yÂ„XmlU@Â™xVÂ¦Â„L@ÂŽÂ„lmz@lnL@bVVÂšbVb@lÂ„nÂšKVkÂ„VlÂ¤@zXV@Âšl@XJVLVKnXVKÂ‚VnU@wUm@ÂÂšKUÂƒ@UlVlw@U@U@ÂƒUaUKlU@kXKlmXIWKXaVIVUVK@KU@@kÂ„JVUnLVJUL@VÂ‚IVa@VnLÂšKUnl`VbÂ„VÂ„ÂV@ÂšÂ‚Vbn@Vzn@lKnVlIÂ„VVKUalkXJl@XXVWVLVUUmVU@UnmÂ„Â£lK@Uk@WUXK@U@WVwVkÂšÂƒÄ kÄ¢Ã‡Â°aUÃ…UwmaÅ£ÂƒÉ±UÃ‡aÂ™wÂ„Â±VÂ¹XalKÃ´xÂ„@Â„UVaÃœÊ“Í¿VÃ³bÃ…LÂƒJmÂ„Â¯VkÂ¦ÂƒÂŽk@mamXkKUÂƒULÂ›akbk@mV@LkJWb@VkÂ„mXk@UVmaUV@amLUKUamI@KUaU@WbU@UUUÂƒUIWJUkm@ÂÂšÂƒwÂ™KkÂ„VJm@kxÃ‡ÂVÂƒUKÂ@mUVUkmlkkVm@ÂamwÂƒLVWU@UbVLkÂšUbÂƒ@VÂƒmK@ÂXaVWU_VJnwV@@kUmWakxÂƒ@kwWakIWxnbUJÂ™zÂƒ@kVW@@x@Â„XllnVW@xnÂ¦ULWKXxmL@Â„VÂšUÂ¤VLÂ„ÃžVVUÂšÃˆxVÂ„mxXVlLlVÂ„anV@bÂšbVÂ„Â„LlÃ†nnlW@LXlWnXV'],
                    'encodeOffsets': [[
                            121816,
                            27816
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3501',
                'properties': {
                    'name': 'ç¦å·žå¸‚',
                    'cp': [
                        119.4543,
                        25.9222
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lxna@ÂnJ@xlIVJVÂ¦UÂšVxUb@bÂšLÂšVUlVÂškL@V@Â„VVn@VbÂ‚LnÂ‚@LUÂ„lJXblxÂ„@lwXbVn@lU@mxUIV`UXWb@Â‚nLUÂ„Â„@ValÂ™UKVaV@UXÂ„KnxÂ‚bn@lUkllnUVnVÂ‚@VLUÂ„ÃˆÂ‚lwn@UIlÂƒÂšLÂ„xÂ‚Â™n@VlXIVJVÂ„VVV@XaV@Vb@LnJVbVLnK@bVUnbVUl@nWlÂƒ@UXalI@KnUl@laÂœbVKVÂ„lLnWnbl@Â„ÂlÂ¥Â°UnÂƒÂ„IÃ†KÃ´aÎ€UÂ„a@UUwÃ‡WÇ“IUWUÃ…VkÆ¨m@Âƒ@Â£@KmLUÂ¤ULË£JÂ™kUÂƒVÇŸUUÄ·@Ä‰VÂƒKUk@Ã‘Â°wÃ´Ã‡ÂšÃ§@Ä«ÂšÃ©@Ã…Å£Â¥mÄ«Ã›kmÂ¼Ã…@ÂƒVÄ·VÃ³Â°ÅÂ¦UÂ°Âƒn@bVJXVVL@bUÂŽÂƒakLmx@xmxXzW`XbWnXV@bWLÃ›@Â™aÂƒ@ÂƒaXbWVkaÃwU@mlÂÂWKkLWWkLUKULW@kVmVUUÃÂUamVÂ—Â¤Â›n@xUVUzkJVÂ¦lJUÂ„'],
                    'encodeOffsets': [[
                            121253,
                            26511
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3506',
                'properties': {
                    'name': 'æ¼³å·žå¸‚',
                    'cp': [
                        117.5757,
                        24.3732
                    ],
                    'childNum': 10
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@bl@Xb@bVVUÂŽmÂ„@nÂ„xÂ‚@nKVV@Â„XVWxn@VnUl@nmVXÂ¼@LVbVV@xVJV@@ÂXIlJXUÂ‚V@LnÂ‚@ÂlVV@UbVnnWVL@lnXUVmJÂ„LlÂ„Â„wnll@VaÂšUXVlaÂ„LVUVV@Â¼Xl@ÂlbUVÂ™VWbnÂ„nUlbÂ„@@VV@Â„aVUÂšmlÂUaÂšUny@kU@Wkk@WaUVk@@ammk@@U@UlU@aUa@wl@ÂšmXLllnLÂ‚U@anVnU@L@VVV@KlXnWVnVanUÂšw@w@wmÂ›nÃ…@wÂƒaUam@UkÂ„mUÂl@@aÂ„a@U@Â¥ÂškÃ´KÂ‚wÃˆÂ¯Â°w@Å»kwÇ•aÂKÂ›Ã‘Ã›k@Ä•ÅÅ™Ä‹Â£ÄµÂƒUKWÂ»kÃ…Å»LU@UlÄ¡w@Â¤VzÂ™VUbkKUbmLmlULUÂ¼UxmbXl@bWVÂƒb@bUnVÂ‚UÂšVbULU@@VkbVL@`U@WX@ÂŽXV@bÂ°Â„@bÂ¯Âš@Â¤@Xm@@b@`UÂ„VVUL'],
                    'encodeOffsets': [[
                            119712,
                            24953
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3505',
                'properties': {
                    'name': 'æ³‰å·žå¸‚',
                    'cp': [
                        118.3228,
                        25.1147
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VlÂ„xkz@`Â‚xÂšLVV@xXXWÂ„Xl@xlÂ„@V@bnVÂ°Â™@Â„Â„LVmÂ°LÂ„VÂ„bV@Ã†ÂšXÂ„WlÂ—UmxU@WVULnxÂ„@llUXUJWzn`Vb@Â„@b@xV@ÂšmXX@Â„@JÃ†VVXVKXkV@nVlUÂ„l@KVbULÂšJV_VKÂ„LVWX@lUVÂƒkIUÂ¥lIVyVU@wÂœmÂ˜Â£nUVWUÂ@aÂƒm@UÂmWw@UX@@amÂ™VUn@@aUUlUVanaWUXWmUnkÂšK@VÂšUlVVUUwÂš@XLWWXÂ™ma@knmÂ‚bVbÂ„VXbVLÂ‚@XJlInlÂšLÂ„wÂ˜mXÃ³Âšw@Ã§VÂ»Ã‡Ã§Å‹aÄ·Æ§Ã³Æ…Ã³KÄ¡Â°nÃ…UÄ·Æ‘UÃ‡W@Â—Â¯xÃ‡Â°Ã¶Ã†lÂVÂ„n@llÂšaÂš@Â„LÂšbÂƒ`Â™@Â™Â„VÂšXVÂƒÂVx@V@bULVJUÂkÂ‚Ã‡@ÂƒÂ¼ÂƒXUKk@mmULkaWbk@Âƒx@UkL@a@K@U@UmKmbU@kV@UmVUbUmmXkW@LUU@U@KmVmU@bÂVmKkkWKÂ™nk@@xVb@bkV@V@Vl@nn@bl@VUXbl@XlV@@lmzÂ™VVbkÂŽÂ™nUVÂƒb'],
                    'encodeOffsets': [[
                            120398,
                            25797
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3503',
                'properties': {
                    'name': 'èŽ†ç”°å¸‚',
                    'cp': [
                        119.0918,
                        25.3455
                    ],
                    'childNum': 2
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VbÃžÂ‚VVnUlUX@VKVLlKXXlKXLÂ‚Â‚nkV@ÃžxlbXUWaÂ„bÂ„@ÂšbÃœ@XK@aWUXmWaX_Wynw@wnwlKÂ„bVÂ@aUKWUUI@aÂ„mVÂ¯ÅŽÂ¥Ã´Â¯Ä¸UÂ„UÃ†@nÂ»Â¯aÆ¿Ã©@Å£Â¯nÄ‰Ä¬ÃKÂ™Ã³Ã³@Â™Ã‘UÂ¼@Ã¨Â™xWÃ´Â—nÂƒxÂ™KmkkJWIÂ@UKWaÂƒUUaÂamn@lnbWÂšXXWKÂ™@VxUVkUÂ™V@UÂ™LmlnVWXXVmbUbkVVV@bm@UVnÂš@bW@@VXxÂ‚n@VÂ„n@bVÂ‚UX'],
                    'encodeOffsets': [[
                            121388,
                            26264
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3502',
                'properties': {
                    'name': 'åŽ¦é—¨å¸‚',
                    'cp': [
                        118.1689,
                        24.6478
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@VlUV@nanL@V@V@L@blK@VÂ„wl@XalbVKnnl@VLÂ„WÂ„Â»Ãˆ@lÂVÂUIVK@a@UUwÂ„ÂWUUÂ™ÂšÂƒÂš@Â„_Â™aÂƒKÂ™@Â™bkkm@UÂƒkÂÃµÃ…ÂxÃ³LÂ™l@Â¦@VÂƒb@bk@VÂŽÂƒnVln@VbÂ„b@xmÃ†nÂœ@x@xÂ™x'],
                    'encodeOffsets': [[
                            120747,
                            25465
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/gan_su_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '6209',
                'properties': {
                    'name': 'é…’æ³‰å¸‚',
                    'cp': [
                        96.2622,
                        40.4517
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã‡nÃ…aÄ‰@ÂƒUÂ¯Â¥Â›UÅ¹Â‚ÂƒÂ£Â™WUÃ½UUÂ±JkkUwÂ‚yÃžIÄŒxÄŠÄ•ÄŠÂ¯ÂšÂ¥Ã†UkÅ£Â™UÃ…Ã“Â±Â¼Â™IUxÂ¯UÂƒÃ’Æ‘Â‚ÃÂÃ…Â°ÂƒKÃnÄŸÂ°Ã…U@ÂŽÂƒ@Vn@Ã¾ÂšÂ¼Â¯ÂšWnÅŽÂ°XLWlnVnbWnÂƒVXxmbÂƒaÂ—bÃ³UÂƒlÇ•UUaÂ™IUmlUÂ™ÂƒÂšÂ¥Â™kÂƒÂ¥Ä‰wkkÂƒÃÉ›a@Â¯Â™Â™UÂ¯Â°mVÂƒkÂVÂnKlÂƒÅÃ‘Ã‡Ã‘U@klÂ™UÄ¡ÂŽkUÅ»nUWÂ™@ÂšÂ¯ÂƒÂkÂ»ÂšÂmWVÂ£UKnUÂƒmUwÂ‚w@ÂƒUIVaXÂ™ÂšwmÂ»ÃˆmmwnÂ¯Ä‹Â™Â¯LÄ‰ÂŽUÂÂƒJUalÂkaÂ±VÂa@UÂ‚k@ÂƒÃ›Ã‘Â„Â¯WmnÂUaÉÂ¤Ã›ÂmÂƒnÂÂ¯mÂ±x@wÃ³xÃ›LÄ¡Ã’UxÂ¯VÂƒÃˆÂ™JUbÃ³zÃÂƒÃ‡KÄ‰Â¯ÅlÃUÃ…ÂŽWÂÂlÂ¯nÅ¥bÃ@Â¯ÂÇ©LÄ¡ÂmV@Ã†Â¯Ä¢kÃ†mÂÂ™ÄŠkVÅ¥LÉƒmÃXÃ³Â°@Â„Ä¢bVÂŽÃ³VÃÂ¦É±@Æ§aÄ¡Â„UVÂ„Ä Ã‡ÃˆVÂ¼UVÅ£wmbÂJÃ‡wË‹aÂ™XmÃ‡Â¯KkkmÂŽÂƒbXÂšmÂ¼VÂ¼Ç¬ÅšÂ²Â¤Ã´Å°Ã†Æ´Ã´ÌÅ¤ÇªnÉ†Ó¨Â¼É†LÃ†Å‚UÄŠÂšxÅŽÆžÈ˜Ç”ËŽÇ¬ÇªnÆ¨Å®Ç¬Ã¶Â°Â»ÂšÄ¡Â„ÂÂ„ÃžÃœÃ†Ä¸Ã’ÄŠÂ„Ç€bÆ¾Ã¨Ã´Ãˆ@Â¼Â¯Ã¾Å¤Ä¸Æ§Â°VÄ€Â¯b@lÃˆÄŠÂ‚ÂšÊ Å„ÌÂ„È˜KÇ€ÂŽÖ²à¥—Å£Ã¿Ç•Ã½@ÂÊŠÇ“Æ¨Ã³Ã†Ã‘Ç–ÅƒÃ´w@Î‹ÊˆÆ†Ã…ÃˆVVÄŠVÂ„Ã³ÄŠÃ…@ÃžÆ’Ä¬V@ÃžÄ«Âš@Â°ÂŽÂ„V@Ä¸Ä¢ÂƒÂ°XÏ„ÆœÄ @ÃˆaÃœÂ¥ÅÆ…Â‚Â™nÄŸÃ³Ä•VÄ¡UÅ¯Æ¿Å‹Â—Ä•ÂƒaÂ±VÂ—UÅ¥Ã‡ÄŸÃ‘'],
                    'encodeOffsets': [[
                            101892,
                            40821
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6207',
                'properties': {
                    'name': 'å¼ æŽ–å¸‚',
                    'cp': [
                        99.7998,
                        38.7433
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÃˆÃ’ÅŽÃ’kÂ„mLUÂŽlÂŽUÂ„Â¯nVÂ°ÂšÂš@Â°ÉœbÂ„ÃžÄ aÃˆÂ»Ä¸lÂ‚ÂšÂ„LVUÃˆ@ÄŠÂ@Ã½UmÂ„@@ÂÃ†VÄ Â¯ÃžmÂ„LÃ†Â¯ÃžÂÆ’ÂÂ„Ã‘Â°VVwÂšJÂ²Â»Ã†Ã”ÂšVlÅ¤Ã…VÂ™Â¦Ä‰Â°Ä‰Ä–Ä‹wÃJÂzVxllÂ²IVVVÃ¾ÂšXÂ„Â¤ÅºÂÂœVÂ°Â¦Â„VÄŠ@Ã†bÃˆmÇ”LÄ¸ÂÄ Â¯Ä¢aÃ´Â¯Ä¸mÃ†Ã›UÂƒlÃ‡Ä¸kÂ°ÂXyÄŠUÇ”VÂ„Ç©nmVÂ»Âƒa@Ã½nKÂ°Ân@lÂ¥@Â»Å¼Â„ÄŠÂ¤mÃ§ÂšÂƒ@Â£ÄŒU@mÂƒmVkÃžUÆÂ±Â²Â¹Â°Â‚Ä wÂÃ…Æ‘ÅƒUÂÂ¯Â™Â›VÂ¯aÃˆÅÂšÂƒÃ‡Â»Â™Ä¡n_Â°xÅŽKlxÂœklxÂ„@ÃžwÂ‚Â„Â„@Ã†mÂ²bÂ‚Ã‡Â²LlkÂšWXaÅ¥Â¯ÄŠaÂœÃ‘ÂšKÂ±w@wÂƒUÃ…Ã§VÂ±UkÂ™@@Â„Â¯ÂšÂ¯xÂƒUÂ™Â±Â±UUÂ°ÅxVxÃ…Ã”ÅÂ°Ã³Â¯UÂÃÂ¦Ã³bÃÃ¾Âƒ@Ä‰ÃˆÃ³UVÂ‚UxÂ„Â„@ÂVÂŽUVÃwÃ…ÃˆÃ‡ÂŽÃ³VkkÂ¯JÃ‡ÂkmmL@Â„Â™KÃ‡x@bkÂšÂ™@UÂ°Ä·Â²Ã³`ÂƒÂÂšÂ™ÂšmnÂ¯Â°ÂƒUwlÃ…kUÂƒ`Â™Â¦É›Ã´Â™ÂŽÄ·z@ÂŽÃ…nÃ‡Â°UÂ¼Â¯KmVkÂ²ÂƒJÂƒÂ¼ÆÃžÄ·Ã´ÂšÂ¤ULÂƒ@mnÄŸ`Â™ÂšÃ‡nUxÃ‡@Ã›Ã¿Â™U@ÂƒÂƒkÅ»ÂŽ@xÂ@mÂÃ³JkÃ…ÂƒÂ¥VÂÅ¹Ä‰Ã³Ã’Ä‰lÄ‹Â°Ä·Â„UÂÆ½ÃœÂƒÂÂ@Â›x'],
                    'encodeOffsets': [[
                            99720,
                            40090
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6230',
                'properties': {
                    'name': 'ç”˜å—è—æ—è‡ªæ²»å·ž',
                    'cp': [
                        102.9199,
                        34.6893
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÃžÂÂšÂ™nKlnÂšwXÂ¥WÃXkÂ˜xÃžUnÂƒÂ°aÄŠVnUUKlÂÃžÂÄ¶WXnÄ Â¥Ã´Â»Â„Â™@ÂnmVL@Â¤Â°Â™VzÂ„JÂšanU@aÃ†wna@kÂ›ÂƒUÂ¯ÂšyX_Â›aÄ‰bÂ™ÂƒÂ„wÂƒÃ©XkWwÃ…aÂšÂ¯VÂ¥mÂƒÂ¯ÂUÂƒÂƒI@ÂƒÂš@Â„mÂšbÂ°aÃˆÃ§ÂšUÂšÂ¥@Â»Â‚knwÉœÆ‡Â°IÂ°Ã‘ÃˆmVUÂ™Â¯Xa@wÂ‚W@wÂšÂVÂ¯ÄŒÂ¥lÂ¯Uwnm@kÂ˜aUaÃ³Kkk@Â™Ã‡aÂ™b@ÂŽÂÃ’WaÂ¯IÃ‡xÃ›amÂ¼Â™VUÂÂƒxÂÃ’lÂ‚@zÃÃ’Â¯bÃaÄ‰VÄ‰wÃ‡Â„ÂWÂ›zÂJÂ™ÂmJnÂ²mÃœÂ¯UÂƒÂ¯Ä‰@Ä¡Â¤Ã…b@Â²nÂšmlÂƒ@@ÂŽÂ„Â„UÂ„ÂƒLVxÂšVÂ™Â„UÂ¼Ã…lmaÂ™b@ÂÂƒÂ°Â™lÂ@WIUÂƒÂ¯@mÂƒÂ™@Â™Â™Ã³ÂÂ„Â™Â„@UÂÂ›zÅ£yÂƒXÂÃ‡UÂ™Ã‡VUUVLkbWakVWmUbkkÂƒKUÂÃ†Â»nÂÂƒÂÂ°Knk@aÂƒUVmÂšnkÂ»lÂ¯Ä¢Â›lw@_kKVU@ÂƒnaÂƒ@lUk@Â¯Â¥mV@kmbÂWÂ™bÂ¯Ã…Ãµa@mkU@ÂkÂƒÃ‡ÂŽkU@ÂÂ›`@Â™Ã³Ã³Â—blÂ¼UxÂƒnÂ„Â¼ÂšlVÃˆÂ„x@blVkVVnÂƒ`XÃˆÄ¡Ãˆ@Ã‡ÂƒKÂÂ£ÃJmUUnUÄ–mlUÂ„mKUnÂ™VÃ…aUwÂ›UÄ‰`Â¯nÂ¯wWÂ¼nxVÂŽÂ™Âš@bÄ‰nÂƒÂ‚kIÄ‹Å˜kXUÂŽÂ±Ã’Â™xÂšÃˆ@ÂŽXÂÂ°`lÂ„ÂœVÂ˜IÃˆÂ¯ÄŠVÂ„ÂƒÂšVVan@VaÂšUVaÅ¼ÂVmÂšblkÃˆWÂ„ÂƒWIXaÂ„alL@wVbÂ„ÂÂ„VÂ„Â¦lL@lÄ Â™nÃ’Â„UÂ‚nkÂ‚ÂšL@Ã†ÃžkÂšÃžÂšKÂ‚bÃ±Ã¾WÂ¦Ã›Â„Ä‹VÂƒÂ„ULUÂºkÃˆlÅŽUxÃ†xÃžUUxÂšÃ’Â‚xÂ„@XbÂšL@lÃ†@Â„Ã’lXVln@Â„bmÂ¼ÂƒJ@Â„Ã…nÂ„ÂšÂƒx@bnÂšÄ mÂ„xVXmbÃˆÃ¨@ÂŽÄŠÂ£ÄŒWÂ˜w'],
                    'encodeOffsets': [[
                            105210,
                            36349
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6206',
                'properties': {
                    'name': 'æ­¦å¨å¸‚',
                    'cp': [
                        103.0188,
                        38.1061
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â±Â¯ÂÂ¥@klwUÂ»ÂƒÂƒÃžÃmwÂKmÂÂ¯Â™Â™Ã§@ÂÂ™kVÃ‡ULÂ¯lVÂUKÄ¡Â„Ä¡m@a@UÂ„@XÂ£Â°lÂ°LÅŽÃ‡@aÅVÃwÂ™Ã”ÂƒKUÂŽÃ…ÂšÂ„ÂWJÂ¯Âlm@ÂÃ›VWaÂ™@klÄ‰UmaÂƒLUanaÂƒÂ™ÂƒkÂ¯JÂ„ÂÂ™Â™Â±KkXÃ³ÃœÃ…xÂƒÂ²Ã‡Â‚@Â„Â„nUÃ’ÄŠbÂ°@Â™Ã†kLÂ™ÂŽÂ™XÃ‡Ã†@xÃnÂ—xWxÅ£Â„Â¯Â¤ÂƒI@Ã†nÂ„ÂƒVVÂ„VlUÂ²Ã†Ã¨Â„V@xÂ²xÂ™LÂ›Ã’Ä‰bÅ¦Â°WbÂ™XklÃžÂ„Âš@lÂ¤ÂšXÄŠ`Â„wl@Ä¢ÃˆÅŽm@bÂšnVÂ‚UbÂƒÂ„@ÃˆÂ™Ã†Ã›LÂƒÃ¨Ã‡ÂšUÃ’Ã…Â¦lÄ¸Â™`Â°Ä®ÊŸÃ†Ç“bÄ‰Ã´ÏšÄŠÃ†ÂšÄ¢nÅ¤Ã©Î€Ã‘Ä¸Ä€ÄŠÂ¦Â„@@lÂ°lÂœÂ¦È®Â¦É†ÃžÄŠKÅ¤ÂÂ™ÄµÄ¸Å¯Â„Â»mÅÂyÄ¡Â™Ä·Å­@Ã‡É±È­Â¯mÆ§UÄŠÄ·nÅÅ»Â»UaUÂ™Â˜Æ›ÉžÃÆ¨Å¯'],
                    'encodeOffsets': [[
                            106336,
                            38543
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6212',
                'properties': {
                    'name': 'é™‡å—å¸‚',
                    'cp': [
                        105.304,
                        33.5632
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÂšÃˆÃž@l`UÂmVÂƒÂ¼ÂœÂŽÂ‚@nnÃ†wVlnVVaÂ„LVÂƒÃˆ_Â‚Ã¿ÃžÂƒ@nÂ„aÂ„xÃ†@Â„lÂš_Âš@VxnK@llLnxmÃˆÅŽJnbUxÂšIÂ°ÂŽl@nÂ¦Â‚lÃˆIlmXÂ¥Â„kÂ°@ÂškÂ‚JÂ„kÂ²Ã©Â˜@kÂlaUaVaU@@ÃnIWÂnmnxÂ‚kÂ„ÂºÃžÂ„Â„aVÂ™Â°Â„V@nwÂ‚KÂšxÃ´bÃžÂ£ÂšVÂšUÂ„bÂšÃ¾ÂšLnÂ»mÂƒVwÂ„IÂšJÂ°ÂŽ@Â„nb@Â°Â°IÂ„Ä¡UkÃ‡KVÂƒÂ™Â™@Ã…Â¯Â»lÂƒÂ„LnmÂƒÂ£@anK@Ã‘ÃœÂnÂ@Â»mL@Â£Â™ykÂ„UUmbUÃžÃ@kyÃ‡bÃ³Â»Â™XUxÂƒWVzÂbÂ±mÃbXaÂƒwUamLÂ¯Â»@wUKVwmÂ¯ÄµJÂ°Ã…UWVkÂ„KVkÂ°wÃˆVÂšÂVÃ‘ÂƒlUÂšÂƒÂ¥ÂšÂkmVamknÂƒUwÂ¯Â¯ÂƒbÄ‹Â¥Ã…KÂƒkÂ™KkÂ„Â™VÄ‹VkÂ£kKVwÂ‚Ã‘Â„a@kÃ³yÃ›Â¯Ã‡VkÂ™Ã³wÂ›ÂšÂ—XÅÂ¥Ã‡Â¼Ã³wÂ™ÂŽÂ¯UÂ±Â‚kÂ„Âƒ@ÂxÂ›IÄ‰Ã’Ã…VmÃˆnÂšÃœ@nÂ°Â„bUbÃVÂ‚ÂŽUnnJÂ¯Ä®@Â‚mÂ¦nVÃœÂƒ@Â„Â„LÂ°JXbÂ‚Ã‘@ÂÂšaÃˆb@ÂšllÃ´LVbÂ—b@lmnVxkÂ°Ä‹Â¦UÂ°Â™ÂŽ@xÂX@xWbÂšÂ°UVÃ‡nÂ¯Ã’Â¯JÉ›ÆˆmxÂl@Â¼'],
                    'encodeOffsets': [[
                            106527,
                            34943
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6210',
                'properties': {
                    'name': 'åº†é˜³å¸‚',
                    'cp': [
                        107.5342,
                        36.2
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@kwÂ‚Ä‰Â—Â»VamÂƒÂƒVÂ¯wÂƒIÃ³VklÂ¯ÂÂ™KmÂÂ™VÅÂ¯ÃWkL@bÃKÅÂ¦@ÂŽÂ™Â„@ÂšÂ™LÂxÂ›@Âb@lÂ™a@km@@lÂ¯nm@UaÃ…@ÂƒÂ„Ã³WUXmÂ¥Â™nÂƒwÂ`@UUxÄ·Ã´Ã‡Â°ÄŸÂ¦@Â„VJÂš_nÂ‚Â‚IVÂŽnalxkXÂ„JWnÂ¯ÂšnVÂƒLÂšxlÂ¤nnVbklVX@xnxmV@bUK@nm@@xÂƒVÂ—Â°Â±aÃ…nÂƒÂŽkUWnUaÂƒx@mÂ™n@ÂƒÂ¯LÂƒÂšÂšmUÄ€lU@lÂV@blLUblxklkIÃ‡xÂ¯Â°Â‚UXbÂšaVÂŽUnÂšV@Â°Â‚LUlnbÂšX@`Â°ÂnVmbnÃ†mÂVÂ‚kLmKÂ™Â¦UÂŽ@XÂ„y@kl@UÂ„Â°K@Â¼XbWÂ„ÂƒÂš@bÂ„WnLVaÂ„VÂšÂƒVz@xlVÄŒÂ¥lbUxÃžÂlVÂ„U@nÃ†WÃ´nÂ²Â™VJlUÂ„Æ§Â„LnmÃœLXaÂ˜n@mÂœw@wlUlVÂ²mÂšblwÂšVÃˆÂƒlLÃžÂÂ„Â±@ÂlVnUlxnkma@mÂškÂšJ@kXVÂ‚U@mn@ÂšÂ¼VXUÂƒVÂƒlLnmVbÃ´aVÂnWVÂ»ÃˆUlÂ°ÃˆÂ¯Ã†InÂ›Ã†U@kkÂ»mKkÂÃ†Ä¡kÂ¯@Â»mÂƒkÂ—Â¯@Ã³Ã‡lÃ‡@Â—VykklÂ™UmlÂ¯ÃžÂ™@w'],
                    'encodeOffsets': [[
                            111229,
                            36383
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6204',
                'properties': {
                    'name': 'ç™½é“¶å¸‚',
                    'cp': [
                        104.8645,
                        36.5076
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VKUÃˆÂšl@ÂÂšÃ¨Â°ÂšnÂŽÂ‚LnxÃÃžÂ„Â„VÂ¼kx@lÂ‚Â¦Â²Â°ÄŠÃ³Ä ÂÂ„Â™ÄŠÂ»Âš@ÃˆxÂšaÄŠxlwÃˆVÅ¤a@Â¯Â²aÃ‡Â£ÂƒJkÂ£lÂƒnUÃž@Â°ÂšÃ´Â™@yÂ„wlÂ»lIXÂ¥ÇªÂnw@Ã‘ÃžWlaÂ„Ã…lL@ÂƒUwÄ‰akÂƒlÂ@ÂƒÂšÂ¯mwnaÂ°JÂ„ÂVÂ¯nUVÃ“ÃžÃ‘mÂ£Â²Ã³WaUÂƒÃ‡@Ã³ÃUÃ§VÂ»ÃˆkkW@Â¯Â‚xV@XÂlK@wX@Vmm_@wÃˆÃÂ™KUÂ¯Ã‡wVwÃ…KÂ¯VÂƒkÂƒJÂ™Â™Â™XkWVaÂƒImÂŽÂ¯UkÂ„Ã‡lVÂšÂœÄ€VÂ°mxÃ³ÂškÂ„@Â¼Ã³Â„WxÄ‰ÃœU@UbÂ‚zÃ›JÃ‡kÂ@Â‚Ã†nVlÃ”Â™@kÂŽÂ„xÂ™Ã´@Ä¬WLÂ¯ÂƒÂƒK@aÃ›ImmÂ™@ÂƒIUaÂƒ@Â™Â™UÂŽÃ‡ÃªUÂ¤ÂÂVÃ’Ã‡xÂ¯Ã’VÂ„ÂšÂšÂ™lk@WbÄ‰Â¦UbkWV_Â‚yÂ¯LÂƒaÃ³Â„kÂŽ@b@nmbkxÂ„Â°'],
                    'encodeOffsets': [[
                            106077,
                            37885
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6211',
                'properties': {
                    'name': 'å®šè¥¿å¸‚',
                    'cp': [
                        104.5569,
                        35.0848
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„aÂ‚VÂ²wVJV_@ÂÂ„LlanÃ…llÅ¦Ã§ÃœÃ“Âš_ÂšlnÂƒWaÃ´kÂ„xUÂšÂ„bmV@ÂÃˆÂ°lÃ¨ÂšnkÂ°lÂ¦Â„`@nnLÂ‚@ÃˆlÃœIÂyVaV@ÄŠÃ›XwÃ´Âƒ@Â»lÂƒÃ´Â™nwUÂ¯Â›Ã¿UÂ™ÃˆklÂƒÂ°VnÂÂ„JUblXÂšWÂšÂšÂ„IÂ„lÂ°UÂ„ÂƒVÂƒÂšÂ—@aVVVmnL@Â„lÂƒÂ„UUwÂ‚mkÂƒÂšÂ£Â„bVÂ¥VUVwÃ›Â‚ÂƒÂlaÂÃ‡ÃÃžÂƒmkÂ£ÂƒLUyÂ¯L@ÂWlkKW_XaWÂƒÂ—mÂƒÂ„Ä¡U@aÂ™kÂ™Â‚ÂƒakXkmVwmÂÅ¹VÂƒUÂ™bÂ™WÂƒÃ³nÂmwnWWÂ£Â„KÃˆnVÂ¥ÂƒÂ¥Â„ÂƒÃ†_kÂ™lWÂ„bUÂ¯Â„VÂ°aÃ´bnaVwmaÅInÃ‡mwkK@kmLUwÂ™@Â™`ÂƒkÃ…@ÂƒwÂƒb@mÃÂ„ÂÄ€Ã‡`UÂ„ÂƒKUbmUUkÃ…xmmÂ@Â›ÂÂ„Â»nUVÂk_Ã@Â™Ã‡Â™Â¦Â™VÃ‡Ã¨Â¯bÂ™aÂƒnÂ™@@Â„Â„JVÂ„Â°ÂŽnÂ„UÂ¦Â™Â°Ã†bXxWlÂ„ÃªÂƒxÂšÂ„ÄŠaÂœbW`Â™zVÂ°ÂœÂ„@lmbÃ…x@bmVÂ™bÂƒIÂ™`Â™Â¦@Ã’UVUI@Ã†ÂƒL@bÂšÂ¼@ÂšÂšÂŽ@Â„ÂšlmxnLÂ„Â°ULÂƒÂŽÂƒÃžÄŸÃžÂ›Â°kLUÂŽÂƒLÂ™Â°Â™xVÂŽÂ„nÂ„KVÂƒl@ÂšzX@'],
                    'encodeOffsets': [[
                            106122,
                            36794
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6205',
                'properties': {
                    'name': 'å¤©æ°´å¸‚',
                    'cp': [
                        105.6445,
                        34.6289
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@UyÃˆÂVÂƒVUnn@ÂƒVUÂ„`UblzÂšJnkÂ‚@VbÂ„KUÂ„Â°lÂ„wÂšÂ„Â„WÂ°Â„nkVÂŽÂ‚UÃˆlÂšÂ£Â°V@ÂnÂ¥ÂšVÂ„klÂ™kUÂ˜Â±UÂÂ„ÂƒnÂ™ÂƒÂlwÂ¯UkwmKUÂlmkUmnkym@Ã…Â@UÂ„mWÂÃˆUÂ°lÂ°anÂlJÂškUKlUÂ„Â¯Ãˆm@kmWVÂ»kkÃLUWUxÂ±bÂÂ™@Â¯ma@ÂƒÂ¯ÂÂ™IÂƒJUxnÂ„mÂ¼Â™KÂ™Ã½ÂƒaÂ™VÂ™UÃÂ¤Ã³aÂ™wÂLmxU@Â¯ÂƒUÂšÂƒbÃÂƒÂƒÂ¹ÂlmwmnXÂŽmJ@ÃžV@UbVbkblÂŽÂ—@Â±ÃªÂƒlÂIÂ™lÂ¯@ÂƒlWÂ¦knÃ‡JÂkmÂ¥k@Â¯ÂÂ™JmbÃ³aÂ¯bÂƒUVÂ°ÂƒakXlÂšÃ…`ÂƒÂ„Â„Â¦UÂ¦Ã‡mÂƒLXÂ¤mXnxmÂ‚Â„Ã´ÂšXÂšaÂ„VÅºUnÂŽUxlnlWÂ„bÂšÂÂšl@bÄ¢VÂ„ÂƒÂ˜nXÂ„WbX`lLXk@ÂŽÂ°KVzÂ„KlÂ¤Â„nÃžÃÂ‚ÃˆkbÂ„Â‚ÃœÂ'],
                    'encodeOffsets': [[
                            108180,
                            35984
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6201',
                'properties': {
                    'name': 'å…°å·žå¸‚',
                    'cp': [
                        103.5901,
                        36.3043
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@lWÂ²LÂšÂšÂƒÂŽÂ°IÂ„lÂ„ÂšmbVbÂ„KnbÄŠVlkÂš@XbÃœU@ÂŽknÂ°Â‚XIÂƒÂÃ†Â™VÂÂ„LÂšÃ“ÃžxÅŽUlÂÃ´ÂƒÂ„bÂ°KÂzU`lXVaÄŠÂ¥Xal@ÂškÂ™Â™UÂƒÂ°Ã‘ÃˆwUÃ‘Â‚ÂVÂ£ÃˆÃ©VÂÂšÂšÂ„@VbÂ„JÂš@nnÃœJ@bÂ„LÂ°Â„XK@Ä«ÂšÃ³ÂƒwlÂÂš@kÃ“mUÂÃ…mK@mÂƒ_kÂ¥lÂ¯Â™mkÃ§Ã‡Â¯@ÂnUÂƒaVÂ™ÂƒwÃ³lXbmÂ„Â™kÂ™`Ã›Ã”Å¥Ã¨kkmÃ†kbÂƒK@ÂU`UIÂ±xÂUÂƒbWlXÂ„mbVbÃ…Ã’Ã³lkÂƒÂƒIWJkÂšÂƒ@ÂƒzÂ—KÅ»Â¼Â™@Â™xUxÃ³ÂŽÂƒÂ„Â¯LWb@ÂŽÃ…Ã’Â„Â„Â±Â¦U`nbÅ¥Ä€UÂšVbÂ„LÂšÂŽÂ„U'],
                        ['@@ÂƒÂ¯lwna@mÅÃˆÂ¯KÂ¯kWÂ¤Âƒ@@V@bÄ¢nÄ¢ÂƒVLUÂ‚Â°k']
                    ],
                    'encodeOffsets': [
                        [[
                                105188,
                                37649
                            ]],
                        [[
                                106077,
                                37885
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': '6208',
                'properties': {
                    'name': 'å¹³å‡‰å¸‚',
                    'cp': [
                        107.0728,
                        35.321
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': [
                        '@@Ã†LUxÃˆxVÂ°ÂšLÃ‡Ãž@xn`Ãœ@XÂ@nÄŠÂŽÃ†wnJmwUxÂÂÂ‚aUkÂšw@V@wÂ„aVmlLXÃl@XÂÂ‚VÄ¢mVÂÂ°@nl@UUUWK@wÂ„Ã¿VIÂ²Ã’lmÂš@nÃÄŠÃ½VV@nÂšJÂ°Â„Â„ÂšUÅ‚m@kÂVÂ¼nKÂ›Ä¢ÃˆÂ¤Ã´KÂ„blÂnKllVkÂ²aÄ Â¥ÃˆÂ¯Ä¸Ã³Vw@VÂ‚_Â„xÂšmnÂ¦VWÃ´XÂ„ÂƒÃ†@Vbn@Â°m@kn@@lÂšb@kÂ‚aÂœ@Â‚wÂšK@Â™ÂšÂƒ@ÂÂUlKVaÂÂƒWXÂ™WÂ²Â¹lÃ“Â„w@_Â°Â›n@@_lKÃ…ÂÄ·WÂ™Â@ÂŽmLUWÂƒnÂ™Â»Ã›@Â›lÂ_Ã‡`ÂƒÂÃ›mmÂ°Ã…bWb@ÂšÂ—VWbÂƒUUÂÂKÃ‡Â„Ã…aÄ¡lmkÂUÄ¡lÂƒÂ»Â—LÂƒlÂ™UmÂ¦@ÂŽÂ¯UÂ™Â¤Ã‡kÂVUÂmlÂ¯ÂƒÂƒXÂ™ÂƒÂƒxÂ¯kVÂƒÂƒLUaÂ@mlÂ™IkyVaÂƒ_UV@Â„mmUVUÂ„Ã‡ÂŽVzUxUVUÂ¦ÂƒaÂ™Â¤lÂ„ÂnVxÂƒVkÂ„@ÂƒmKUnUU@bÂ™Â˜UÂ„ÂƒÂ„',
                        '@@@ÂŽÅ¼Â@Â™mlkÂƒÄ¡k'
                    ],
                    'encodeOffsets': [
                        [
                            107877,
                            36338
                        ],
                        [
                            108439,
                            36265
                        ]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': '6229',
                'properties': {
                    'name': 'ä¸´å¤å›žæ—è‡ªæ²»å·ž',
                    'cp': [
                        103.2715,
                        35.5737
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Âš@Å¼Â»Â˜LÂ„yÂ„@lÂ™XIÂ„JlÂ„Ã´kÃ†Ã‘UanaWÂƒXkW@Â™yk@UÂ„ÂƒLÂƒmUÂÂšwÂšÂ¯Â„KVÂlKÂœÂ¯Ä ÃÂ„ÃÂ„ÂVKÂƒÂ¯mKnwÂ™k@ÂƒÂ™Â@Â™Â™Â»@aÂ„K@Ã…VJVU@Ã‘ÂšÂ¥Âš_UyÂ¯Âš@Â£UKmn@Â‚ÂƒÂšÃ³Â¼ÄŸÂ¦WmÄµXÃÂŽkÂŽVLmVÄ‰UÂ¯bmÂ„ÃVÂ—wWlXÃžWÂ¦Â™xkmmLÂ™ÂšÃÂŽÂœÂ„Â±U@VÃžÂŽÂ™Âš@Â„Ã…ÃˆWÂ°XÂ„ÃœÂ¼Æ¨yUÄ®nÂŽWÂŽnXÃxUxÂ°lVÂXJlÂÃ´V'],
                    'encodeOffsets': [[
                            105548,
                            37075
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6203',
                'properties': {
                    'name': 'é‡‘æ˜Œå¸‚',
                    'cp': [
                        102.074,
                        38.5126
                    ],
                    'childNum': 2
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÂšÄ¢ÃˆÂ¼Â™Â„Ã‡Å‚Â°bÂœUÂ°ÂšVÂ‚Æ’Å„Â‚Ã†Ç–Å°nÂšÃ†Â„ÅÄ¬Ç”aÊ Ã…Â¯Ä­Âš_kÄ·Ã†Â¥VÃ‘ÃˆÂ™Â„Ã§ÃœKÂšÃ…@Ã‡Â„ÂƒVaUÂÂ™m@aÅnÄ¡Ã‡k@ÂƒxÄ‰_Â™WkÂ£Â™@ÃÂƒÂ±KÂÃˆÂ±aÃ…nÂƒ@ÂÂƒÃxÂƒ@kwÂ›lkwÅLÂ¯wm`'],
                    'encodeOffsets': [[
                            103849,
                            38970
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6202',
                'properties': {
                    'name': 'å˜‰å³ªå…³å¸‚',
                    'cp': [
                        98.1738,
                        39.8035
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@llÄŠxÂ„Â¦ÂšlÂ™Â¦ÂšÂ„kVVnÂšJVbÇ–VÂ„kÃ´VÂ˜aÂ„bnaWwÂ„UXmmamUXkWKÅÂ¯XmÂ°Â™Â™Â»Ä‰ÂÃ‡@UVÂƒKÂÂ™Ä·kÃ‡Â¼ÄŸb'],
                    'encodeOffsets': [[
                            100182,
                            40664
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/guang_dong_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '4418',
                'properties': {
                    'name': 'æ¸…è¿œå¸‚',
                    'cp': [
                        112.9175,
                        24.3292
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lÃ‡Â¯ÂkÃ¿ÂƒaVÂ¯Â™ÂVaÃˆUÂ„Â¥Ã†Ã‡Â„IlxÂšmnbÂ‚UÂœxlÂ™Â„UÃ´lÂ°kÂšÂ„Â„WlÂ„Âš@Ã´Â™VwUanUl@Â„xVkÂšaXÂ¥Â‚kUÂ»Â„aÂšÂ¯Â±Â@kka@ÂƒUwmUkwÂƒJkÂ™Â˜ÂÂ„Â±k@ÂƒÂ™Â™L@ÂÃWUwVÃÂƒÂÂ—xÃ‡UÂ¯ÂŽÃ‡X@mÂ™Ã…Âƒ@@yÄ‰Â£VmUwÈ—Â»Ã‡ÂšUnÂ„lUnWUÂ¯`UkÂƒ@@Â„Â™xÂ„ÂŽ@bÃ‡xXÂ¼ÂƒVVÂšÂ¯LÂšÄ€kÂ‚ÃLÂƒÂ„Â¯@VÂŽÂƒÄ€Â¯lnÄŠWÂ¦kVÃ‡Ã´kUÃ‡Â„UK@Å£Â™U@aÂ™Â™Ã³ÃœÂƒUUÂ»Âƒ@Â™Â¦k@VxÂ„KVbÂ„nÂ‚Âš@Â„ÂÃ†Â™Â„lÂ„@xÂÂšÂƒbWÂšnlUÂ„lxÃˆlVÂ„ÃˆÂ°Ã†Â„@Â¼Â™Â„@xÂ„ÂšWxÂœÅŽÂ‚VÂ„ÂÂšKÂ°Â„ÂšÂ¥ÂšÂšnÂƒÃ†kÅŽ@ÃˆÃ‘mÂ™Â„K@Â¥Âšk@Â™Ã´@Â„nÃ´V'],
                    'encodeOffsets': [[
                            115707,
                            25527
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4402',
                'properties': {
                    'name': 'éŸ¶å…³å¸‚',
                    'cp': [
                        113.7964,
                        24.7028
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@WÂ™XkÂ±Ã‘@ÂƒUwÂ™mUwÄ‰wlmn@Ã†wnÂ£mÂkIÂšÂ¥Ã‡Ã…@Â¥ÂšaÂƒÃ³nÂ£nWWwÂšÂ£V`Ãž@ÂšÂnVml@xÃ´Â¼Â„IVÂ¥ÂƒkUmkamUkVWwÃ›Â»mÃ³ÂƒÂ£UVÃ…Kmn@xÂ™@kbmmÂ¯aÂ™XkaÂ›VÄ‰aUbÃÂƒÂƒÂ²Â—Â‚lÂšÂ„IlxnVVx@Â„lb@lÂ²ÂÂ™Â°ÂƒbVÂ¼ÂlWÂ¦Â™bUlÂƒwk@mVVbUxÃ³ÂšÂ™@kÂƒÂƒXÂ™ÂƒÂ¯lÃ³kÂƒVkÂšÂ›wÂVmaÂ™nkwÂƒJÃ…ÃˆÂƒÂ¦Ã‡VUbÂšÂŽUÂ°Â„blÄ€Â°ÂŽkÃˆ@xÂ™Â¦Ã†ÃœÂ™Â°@Â„Â°Â„ÂÂ¦Ã³aÂ™VUÃ´lUlbXÂl@nÂÃœVÂ„Â„nKlÂŽnIVÃžÂ°WÂšÂ„Â°U@bnm@Â¥ÂšIVÂƒÂ²UlÂƒÂ°VnalzXyl_VyÆ’Â¦lÂƒÂœLlxÂšÂ„@ÂŽÃžbÂšKmÂÂ„knVWanwÂƒÃ‘VwÄŒÂºÂ˜@n_ÃžVÂ„aVÂŽÃœIÂœl@Â„Â˜KÃˆÂšÂ„ÂVJ@aÂšÂ£Ãˆ@Â˜Â™@ÂÂkmÂ™Â„aVÂÂ¯W@_ÂƒaÂ¯KmbkÃ‡kLmwÂƒ@Ã…Â¥'],
                    'encodeOffsets': [[
                            117147,
                            25549
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4408',
                'properties': {
                    'name': 'æ¹›æ±Ÿå¸‚',
                    'cp': [
                        110.3577,
                        20.9894
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@ÂƒkXÂƒÂ™@aÂ„UUÄ‹lkÂ„JÂƒkÂ„Â™@wVJXUWkÂ°W@ÂnKnwlUlÂšÂ²ÂƒÂ„blU@Â‚lIÂ„l@Â„XbWÂ„Âšxnm@ÂlW@wÂ„wUÂÂ‚JXÂ¯VUÂ°`ÅŽÃ³Ë‹kÃÃkÃ…@Ã‡mÄŸÃˆÅ™mwÂ™aÄµVÂ›xUÃ›ÂÂ»Â°Â™Ä Ç·nÃ½mÃ³XÂ¥É…ÄµÒÃ‡@Â°Â²ÄŠUÄ–Â±Ä®UÂ¤Ã‡Â°Â™Ä€Â¯ÉnÅ¼UÄŠÄŠÄ¬VÂ@Ã¨Â„ÂŽ@Ã”ÂƒÃ’UÂ¼lÂ¤nÂƒÄ bÂ„ÃªVÄ Â°ÂÃˆyÂ„zVaVÂ‚nUÃ†LÂ„aÂšbVlÂ„wÃ†@'],
                    'encodeOffsets': [[
                            113040,
                            22416
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4414',
                'properties': {
                    'name': 'æ¢…å·žå¸‚',
                    'cp': [
                        116.1255,
                        24.1534
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„Â‚nÃ”ÂšlWÂ¼ÂxÂ‚Â¦@lÂœVlÂ™lLkÃ¨Â„a@zÂšÂ¤ÂƒÄ–Â„Â¼UxlnUKUbÃlUÂ¼lb@Â„VxÂ„VÂ„klJÃˆwVÂ¯Âš@Ä lÃ›Ä–ÂšnÂƒbkÂšÃ†ÅºÃžÂƒUÃˆÃ´klmÂšLÂ„Â¥Â‚LÂœWÂ˜Â„Â„Â™nKUkVaÂ°VÂ„x@IVV@xÂ°bUkÂ„aÂ™a@mV@Â„Â@yÂ„wÂ‚LÂ„Ã‘UwVUÂšVÂ„Â‚Â„UÂ‚bÃžVVannÂ‚@XwÃ‡Ã¿ÂšÂ¯Â²aVamkXaÃ†Â»@Â»nw@Â¥Â›UXaÂƒÂkbWaÂ¯KUw@Â¥m@kwmLUÂ»UUÂ™J@kmU@UUWUÂÂƒ@ÂƒyÂƒanwmÃ§Ã›lÂ¯ÂÂƒÂŽÂ¯UÂƒÂmKUmÂƒwVÂkmÃXÂbW@XWÃbÂƒkÂ¯@Â±Â‚Âw@Â»U@WÂ¯Ã…@ÂƒÂÃ‡Â¥UÂƒU@ÂƒÂƒÂ™IUÂ™ÂƒakJÂƒÄ€Â„ÃªÂƒÂ°ÂšÃ¾ÂƒXkamÂŽ@ÂŽÂƒ_ÂJÂ°ÂmÂ‚@X'],
                    'encodeOffsets': [[
                            118125,
                            24419
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4416',
                'properties': {
                    'name': 'æ²³æºå¸‚',
                    'cp': [
                        114.917,
                        23.9722
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â°VlmXÂ¹laÄ¢Ã’lmÂ„@Â„Â„ÂšVÂšÂ£Â‚Â‚@Â¦Ä¢klynÂnÂ¼lWÂ°zÂ„WÂ„Â„Â°ÂVbÃˆV@lÃ†bnnÂ‚JÂškXÂ„ÂšVÃ†aÂšÃ…Â„W@Â™ÂƒUUw@ÂƒkaVÂ»ÃžkVaVLkmVwÂƒÂ»Â„Ä•Â™Â£@yÂƒblÃ§kKkÂšÂ›U@kÂÂ¥Â‚wXÂ»Â™kmÃ“ÂƒÂ@WnÂÂ¯ÂÂ‚IÂ„`@ÂnÂlbÂ„WÂ™Ã½Â„Â¯ÂƒÃ©Â„Ã¿lI@Â™XUmWUwÂƒ@@ÂUJUÂ„Ã‡Â„mKUV@xÂ™Â„Å£kÂ¯ÂÂ¯LWÂƒÂƒnUxÂK@Ã…Â±Â»VwÂaÂ¯Âš@Â¤WX@ÂŽÃ›Â¦@Â¤Ã‡IÃˆÂ¼WxXÂŽÂƒ@WxÂ—wÂ›ÂŽUnVbÃ…Ã¨mVÂaÂ±Â²ÂUWl@ÂŽkÂ„lÃˆÂ„Â¤nÃ´ÃœÂ¼XxlUnVlbVnÂ„lUÂ¦ÂƒJÃ³Â»@wnkmUÂ™Â‚Ã@U_Â™Â¤XxmXmÂ¤Â„Ã´Â™b@Â¦ÃˆÃ†Â™Â¦lJnÂ'],
                    'encodeOffsets': [[
                            117057,
                            25167
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4412',
                'properties': {
                    'name': 'è‚‡åº†å¸‚',
                    'cp': [
                        112.1265,
                        23.5822
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@l@ÂšÂ¥Â„@VÂ¼Â„VÃ´Ã›ÂšÂš@bÂšV@Å¤VLÃˆÂƒlVÃˆÃ³lUXÂ¥mÄ‰Â°kÂ„Ã¿UÂÂ°@Â„ÂƒÃžKlÂÂ™Ã¿Â°KUÂ™Â„UWÂ»Ãˆw@aÂƒÂÂšw@ÂƒÂ„@nm@wÂ›Â£kÃ“VUVnÂ„KÂšÂ™kÂ¥Â™Â£VamÂƒ@nkKkbÃ†Ç«maÂ—kmLUÂ¥Â™UmÂƒÃ›wmVUÂ™mUÂƒJÂ—ÂÃ‡aUxÃ‡In`mb@ÃžÂ¯b@Â„nJ@nlÂ„UÂ‚VÂ„lVUÂ„ÂLÂ›WÂ¯Â—Ã›`Ã‡_Â¯`mÂšÂ¯IÂ™bÄ‰WÄ‹zÂxÂ±JÂ™xÂšÂÂ¯Ã†UÂƒÂƒ_k@Â™ÂšÂƒJ@UmbÂ„ÂšXÃ´lLÂšÂ˜nÂ¦@Â¼ÄŠxlUXÂŽÂ˜xUbÂLÂ‚Ä Â„UnVÄŠwlÂšUÂšÂ„b@ÂlWÂ„XÂ„Â‚mÂ²ÂÂ˜@ÃžWxXÂšÂ‚Unb'],
                    'encodeOffsets': [[
                            114627,
                            24818
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4413',
                'properties': {
                    'name': 'æƒ å·žå¸‚',
                    'cp': [
                        114.6204,
                        23.1647
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lbÂšWÂ°bnnlaÂš@@wnmÃ†LVUkÃ‡lÂƒ@ÂXkÂ‚VÂ²Â±Â‚bnUÃ†Ã§UaVmÂœÂÂ˜xXwÂ„@WÂXwÃ‡Â»ÃˆJ@Â£ÃœÂ¥@ÂXW@Â£Â°Â™Â‚bUxÂ²Â¼@Ã†Â‚LVwÂ„mXÂ„Â°KÂ°ÂÅ¤lÂšÂƒ@wVUnLÃˆÂƒVÂƒVIkyÂ±wkÂÂƒKUÂ¯ÂƒÂÃ…kÂƒÂÂ™XÄ¡Ã‘Ã›ÂƒlwUwlm@mÂ„ÂnKWaÂšÃ…ÂmÂ›Â¯ÂÃ³Ã‡mÄŸbÂ¯alÄ‰UwÄ·bmb@lÃžÃ’VnÂ—ÂšmÄ€Å¹@VÂŽÂƒbVÂŽUnmakLm`@xÄ‰kklVÃ”VJVnÂ—lVÂ„UnmJmaÂLUblÂ‚Â™zmÂŽkLÂ™aÂ™Â‚Å@@zÂšÂ‚VÂ¦UÂŽVÂ²kJÂ„nÃœU@Â˜VXUÂŽÂL@Â„lJÂƒL@bÃÂ¤UnVÂŽÂ—b@xVnlKÂ²Â„VxÂ°VÂ„xlIÂ„lkVlÂ²kÂ¤@n'],
                    'encodeOffsets': [[
                            116776,
                            24492
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4409',
                'properties': {
                    'name': 'èŒ‚åå¸‚',
                    'cp': [
                        111.0059,
                        22.0221
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â‚LnÃ‡lkÂ„KnkÃ†LÂ„ÂÂƒUmÂ™ÃˆxlUÂœJlÃ³Â°n@ÂšÂšanÂŽÂšÂ„Â„a@ÂƒÂ˜@X_@mÃÃ³Ã³U@aÂ™aUÂ¯mLÂ¯ÂƒÂƒÂkÂVÂ¯Â™Ã‡Vwkw@ÂVÂ±ÅŽÂ£@Â™Â™Â@ÂÂšalwÂÂ±Vk@mÂ„Ã…mÂ¯Â™Ã¿Ã…ÂƒÆ§IÃ‡`ÅÃ´Â¯_UVWÂ°ÂIVÂ‚Âƒx@xkX@ÂŽmnÂ™wXÂƒWa@ÂƒÂƒkkJ@ÂkVÂƒaÂ±Â„kÂ™kVmxmL@Â‚Â¯XXlWVUI@xÂƒÂšÂ„lÂƒIklVÄŒÂƒV@bÂ„ÂšlW@Â„@nUxVbÂlVxkÃ´lxÂ™ÂnÂ„Â‚yÂ„ÂšnIÃ†Â»Ã†Â°Â„aXwlKÂ„bVnÂƒÂŽXbÂ‚LÂ„Â¤Â„kÂ‚LÂ—Ã¨ÂƒVVÂ¼ÂƒÂŽÂ²IlÄ VXÂ„ynzÂ°KVxÂ°@VlÂœLlblKÂœÂš'],
                    'encodeOffsets': [[
                            113761,
                            23237
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4407',
                'properties': {
                    'name': 'æ±Ÿé—¨å¸‚',
                    'cp': [
                        112.6318,
                        22.1484
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lUXxÂ°JWnnÃ†ÂšXVÂšÂ„WÂ„X@Â„ÂšÂºVLVÂ¯nUÂ‚VnbÂ™Ã´Â„xÂ‚aXmWÂ™XIÂšÂŽUbÂ°xlKÂ„ÂlÂ¯ÂœKÂ˜xXÃžÂ°ÂŽÂšXÃˆÂ¥Ãœ@Â„Ä‰ÃžÂUÂ™Â‚Ã§ÂšÂ»nÃ³ÂƒVmaÂ—xÂ‚Â¯UÃ…UÂ¥ÃÂ¯@ÂƒÂƒÃ§@È™@Ã§Ä‰Ã…UmUÃ§Â±ÂƒÄ‰KÃxÃ_Ã…JÂƒkÂ¯Â»Ã³ÂÂ¯nmÃ¨kÇ€ÂšÂŽWxÂœÂ¼mnUÃœÄ¡Â°@Â¦Â@ÂƒxÂƒLkÂŽÃ‡aVnUxVÂ„Â™ÂšVlnIlbnÃ†Ã†KXÂ¦'],
                    'encodeOffsets': [[
                            114852,
                            22928
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4417',
                'properties': {
                    'name': 'é˜³æ±Ÿå¸‚',
                    'cp': [
                        111.8298,
                        22.0715
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â°Â„nKVÂ°Âšb@bÃ´VÃžÃ´@nÂ„VlÃ’Ã´Ã†Unlnn@lmkmVkÂƒaÃˆkÃ†Ã†Â„Â™kÂ¥Â‚Ã…ÃžÂ»Ã†KXkWÂ¥Ã…LmÃ…kamJUkÂšÂ™UÂƒVwUmÃˆblÂÂ„KÂ„wÂ‚@@Â¥Ä¢Â¯VÃ›nmÂ›Â»XwÂ™ÂlÆ¿Â™@kbWÂ™Â—aÊµ@Ã³LÂ›lÂ¯ÂÆ½@Â™ÂƒÂƒLnÂ°ÂƒÃ†@nUlÂ‚Â²kxÂ™b@Â‚ÂšÂ@ÂšÅÂ¤UÂ²@ÂŽlxUxÂšÃˆUÂ°lÂŽÂ„Â'],
                    'encodeOffsets': [[
                            114053,
                            22782
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4453',
                'properties': {
                    'name': 'äº‘æµ®å¸‚',
                    'cp': [
                        111.7859,
                        22.8516
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@VÂ„IÂšÂ™l@Â„`VÂ„Â°Ã…Â™ÂÂšwÂ²IÂ‚wÄŒyÄŠXÂšaÂ°JnÂ™Â°_Ãˆ`Ãœ_Â°Â˜ÂœXÂ‚KVÂƒkUUÂƒVÂkÂƒ@mmI@ÂƒÂ°a@Ãnam_ÃˆJVwlÄ‰X@Â„ÂšlUÂšÃ³maÂUmVUÂ°UKÂ™Â¹@ÂƒÂƒWÂƒXUÂ™Â™WmÃ…XmÂ¯IWwkVWlÃ…LÃÂ¼ÂÃ†lÂ¦ÂƒÂšÃ…Ã…Ã‡lÂ„bUllnknm@kmVmÃ³Ã…kÃ‘ÂƒUW`Â—@@Â„ÂƒbÂ™ÂƒmÂÂ™b@Â™Â¯mkÃ´Â›IkVÃ‡wnÂšÂ„VÂƒÂÃ…KmlÂƒLklmÃˆÂKÂƒÂÂšVÄŠKÂ°Â²Â„`nÂÂ˜Â¤nÂ„UÂÂ„bWlÂ„xVxÂ™LUx@Â°nXm`VÂklVxmnnx'],
                    'encodeOffsets': [[
                            114053,
                            23873
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4401',
                'properties': {
                    'name': 'å¹¿å·žå¸‚',
                    'cp': [
                        113.5107,
                        23.2196
                    ],
                    'childNum': 13
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@È˜Â¼VxUnÄŠÂ¤@zÂ„@ÂšÃ†@nÃˆWÂ°ÂÃˆVÂ˜wÂ„ÂŽUÃžVxÃžX@ÂŽÂšKÂ„Âšl@ÃžÂ„VaÄŠbÂœU@mlÂ£kÂ±lUÂƒkkJÂƒwÂ¯UUwÂ±ÂƒkLUm@wÂ˜aUÂVmÃžÂ£@aÂ„KkI@ÂƒÂ‚KVÂUW@Â—Ã›VÂƒmlIUÂ±VÂUÂ¥Â™Â@yÄŸzÆ§Ã‡ÂƒÂƒÂšÆ½Ä Å™ÂšÃ…nÄ«Â±mÂ@ÂƒÂ²Â¯lÂƒÂ°@nÃÃ†Ã³ÂUll@XnÃVUÂ¦mVVÂ°Â—Â„VÂ¼Â™JÂƒnÂ„b@Â°mbnÂ„ÂƒÂ‚@Â²Â¯Â‚Â¯wVwÂƒ@@nmxXÂ¤Â¯L@ÂŽVLUÂ„m@@l'],
                    'encodeOffsets': [[
                            115673,
                            24019
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4415',
                'properties': {
                    'name': 'æ±•å°¾å¸‚',
                    'cp': [
                        115.5762,
                        23.0438
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@Â‚Â„@VxnXWV@ÂšÂ„bVÂšÂšJÂ„Â„V@ÃžÃ…UÂ¥ÄŠxÂšÂ£UWUÂÂ‚wÃ…UUÂ¥WVUkÄŠÃ‡nkV`Â°LVÂ™Â„wÂƒÂƒnU@Â™Â„ÂƒlbÄŠÂ¯Â„VnalÂšÂš@@Ã§kUÃÂ¥Ä¡aÃ³Â¯Ã…aÃ…LÅ»Ã†UÃ½myÂ¯ÂÃ³@Ä‰Ã†Ã³Â„È¯wÂ™Ã†XbmLÂƒÂ‚@nknVxkxÃœÂ„Ä¢Ã’ÂšWÂ„ÂÃ†lÂ„ÂVÂ°Â„LlÂ‚Â²xlz'],
                    'encodeOffsets': [[
                            118193,
                            23806
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4452',
                'properties': {
                    'name': 'æ­é˜³å¸‚',
                    'cp': [
                        116.1255,
                        23.313
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VÂ„ÃˆÂ¦Â„ÂÃ†@XÂ°V@@Â¼Â‚xÂ²ÂÂ°@Â„lÃžaWXX@Â‚aÃžWlnUÂŽÂ„xVnnLÂ„Â‚Â°VÂ„Â@kÂ‚mÄ¢ÂlÂ@ÂÂ„akÂ™@mlkÂ°aXÂƒÂ±Â„nwmÂ±Â™Â²Â¯JVÂ²Â@ÂƒwWÂ˜Â—_mÂÂƒaÂ„ÂVÂ»ÂƒU@mÂ¯Ä‰UÃ‘Â„Â™ÂšJlÂ™Â„aÂšbVnÂ„lÄ¸LlÆ…Ã›Ã‡Â±wÃ@Ä‰xÃ³Â@Ã¨Â™@kÂ™mbÂƒUÄ‰Â°kaÂƒÂ„@ÂšmVÂ„Â„ÂƒxUÂšÂ¯KU_mlÄ‰ÃˆVlXUVÂ¦Ã†VÂxVÂŽVXÂ™Â¤Ä‰wVÂ¦ÃÃ†'],
                    'encodeOffsets': [[
                            118384,
                            24036
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4404',
                'properties': {
                    'name': 'ç æµ·å¸‚',
                    'cp': [
                        113.7305,
                        22.1155
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': [
                        '@@Â„Ã¨@Â„ÃžÂ°VÂ¦VÃ†ÂÂ°Â˜wnbÂ„UÃ†Â»nÃ§Ã†Â@ÂnxÃœÂ¤ÂÂ²llUÂ°VnÃˆJÃžÂÂ°UÃ´Ã©ÂšÄ·UklÂƒÃ´Â£VVËŒKÃžVÂ°Â£nÂ¥ÂƒÂ£È—Â™ÃyÂ¯Â¯mÃ…kwÂ¯bÃ‡Ä”ÄŸ@ÃnÂ¯ÄŠÂƒVÄŸÂÅÅÅ»ÂƒÄ·J@Èš',
                        '@@XÂÂ¯kmÃ¨VbnJÂ‚Â™'
                    ],
                    'encodeOffsets': [
                        [
                            115774,
                            22602
                        ],
                        [
                            116325,
                            22697
                        ]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': '4406',
                'properties': {
                    'name': 'ä½›å±±å¸‚',
                    'cp': [
                        112.8955,
                        23.1097
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÃˆbÂ˜ÂŽÂ„InVVÂšnUÃœxnÂ„ÂšVVÂ¦nKÂ˜lnbÃ…Ç¬lalL@mnÂ„UbÂšÂ¤lÂ¦Â™ÂšÂƒLUmUVlÃ”ÂœÂ¤@xmnVlÂ°_XVVmÂƒkVmÃˆÂ™@kn@VÂƒUK@ÂÂ°KWÂ£nw@mÂ„@UxÂ°xÂ°Â@Â±Â„ÂmÂƒna@Â¯ÂƒaÂ„mÂšIUÂ»Â˜ÂƒUÂ¯nUVÂ¥ÃžUWmk@VkÂ¯ÂÂ™UknÂ›Ã‘ÂWÃÂÂƒÄŠÃ›@Ã‡Â¦Â™WÂ¯ÂWÃÂ—wÂ›LkÂ°ÂƒÂkLÂ¯wVaÂ™ÂWJXÂšWnÂbÂƒwkVÂƒÂ™W@kÄŠ'],
                    'encodeOffsets': [[
                            115088,
                            23316
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4451',
                'properties': {
                    'name': 'æ½®å·žå¸‚',
                    'cp': [
                        116.7847,
                        23.8293
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â°ÂŽÃœknÃ¨mxÂ„bÂ„zÂ„@VÂ‚VX@VnV@lÂšIVVVÂ¼nKlxn@@Â¦VxÂ°LXblaÂ„ÂŽWbÂœVÂ°Â£Â¯Â™WÂ@ÂnW@Â™Â‚aUÃ±VÂÂœwWÂÂšÂ»@Â¥Å¤Ã…UÃÇ“ÃÃ³V@Å„Ã‡ÂŽkUVmÂƒIUwÃ…VWÃ‡XÂ¹Â›ÂÂ—@WÂ„Â¯bkl@nlÂšÂƒb@Â‚kÂÄ¡ÂŽÂn@l'],
                    'encodeOffsets': [[
                            119161,
                            24306
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4405',
                'properties': {
                    'name': 'æ±•å¤´å¸‚',
                    'cp': [
                        117.1692,
                        23.3405
                    ],
                    'childNum': 2
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â‚@UÂ±Â°IÂšÂ±nÂ²mxÂ²ÂƒÂ˜@ÂœÂWÂºXÃˆÃ†UVxÂ„JUnlVÃˆÂ@ÅƒÃ´UÇ”ÃžVÃ§nÂ»VyÄ¢Ã›Vm@Â»kaÃUÃ‡Â¼Ã³ÂšÃ›ÃˆÄ·KÄ‹Â¥XÂÂ„Â¥WwÄŸkÂ™ÂƒÂ¯@ÂƒwÄ·KÂƒkUmÂ™aÂƒbkÂšÂ™IÂƒÂšVÃ’Â°ÄŠ@nÂ„VUÂ¼ÂƒÂ‚Â„bnÂÂ˜`XÂ—Â„x'],
                    'encodeOffsets': [[
                            119251,
                            24059
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4403',
                'properties': {
                    'name': 'æ·±åœ³å¸‚',
                    'cp': [
                        114.5435,
                        22.5439
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÃžLÂšÂ„@xÂšbVÂ„ÂšVÂšKÂ°Â™XÂÂ°KÃ´Â¥Vw@anUÂ„Ã¨ÂƒÂÂšÂ‚lkÄŠl@wn_lKnbVmUÂÂ„aUÂÅº@nÃ¿Â˜Â™UmÃÃ‘Â¯UÂƒbkÂ„@Ã†kxÅ»@Â™aÃ‡XÂ—wÂƒJÂƒÂƒÂ¯LÄ·ÃUÄ•Â™Ã³Â™Ä¸Ã³ÃªWÂº@bÂ²nmÄ¬Â™Ã†'],
                    'encodeOffsets': [[
                            116404,
                            23265
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4419',
                'properties': {
                    'name': 'ä¸œèŽžå¸‚',
                    'cp': [
                        113.8953,
                        22.901
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÅŽ@ÂšÂÂšblKnÂÂšykÂVaÂ‚KnbnIVmUÂƒÂ˜kUmUIUÃ“Â™ÂÂ„ÂÂƒÃ§mV@bUxÃ³Â¦Â¯LWÂ‚Â¯ÂšÂ™LÂ™UUÂƒÂ™a@wÂ™ÂƒÃKÄŸÅšÂ™Æ¾Â„Â„Æ¨ÃˆÄ y'],
                    'encodeOffsets': [[
                            116573,
                            23670
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4420',
                'properties': {
                    'name': 'ä¸­å±±å¸‚',
                    'cp': [
                        113.4229,
                        22.478
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â‚XÂœÃ’lmÂšVÂ°ÂÃ´ÂÃžÃ…@mÂ„Â¯Â°kÂ„Â±Â‚@@aXÂ¹Â¯VÃÂÃ‡IUmVÂ¯kkÂ‚Â±Ã›Â£mw@Â‚Ã…ÂmÃ¨Ã…Â¼mÃ´Â™Â¼ÂÃ¨VÂš'],
                    'encodeOffsets': [[
                            115887,
                            23209
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/guang_xi_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '4510',
                'properties': {
                    'name': 'ç™¾è‰²å¸‚',
                    'cp': [
                        106.6003,
                        23.9227
                    ],
                    'childNum': 12
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lklWXL@VÂšIÂ‚l@XnJn@VUUalÂk@mK@kny@UlU@aÂ°Â™Â„ÂƒUU@VmaU@Ua@UWwÂ@Âƒn@KmLÂm@alkÂšmnIÂ‚m@an@VIUamWÃ…ImwU@@a@KÂ„X@JVLÂ„UVmUaVkUa@mÂ„@@UlmkkÂ°ÂƒUaVUlKXbVwVIkaVmUk@KVk@aÂ„aWÂÂ¯m@wÂ„Â¥laÂœX@KmaÂškVmnUl@nxVKÂšInU@yVaVIV@naÂ°KlxX@@_lmXÂÂšUV`VIVÂ™V@Â„Ân@lÂÂšbn@@WUkValK@ÂÂ²yl@Â„Â„VUV@@KÂ°L@KU@@UVaXIVVV@naVkVa@K@UUK@UUaÂ™LWaÂ—w@m@K@UVÂVÂƒ@mVÂUUVKnLÂ„mVLÂ„KÂ‚bVK@UUIkÂ›mI@mUIVK@IUK@VkLÂƒ@WU@mÂU@WmUk@ÂƒI@VÂƒJk@WwX_@amK@UUWkIÂƒÂ„ÂƒK@LVbÂ@mVmakL@J@bU@Ux@xÂƒbmI@`ÂƒIÂwm@UbmKUaÂUWaÂ¯UkJWV@XÂƒJUUÂ¯LUmV@ma@kkamKÂwÂƒLUUmWVkkm@aVUUkVKnVVUmÂXK@UW@km@Ukkm@@W@UÂ™kUy@I@aUUmbÂƒÂ¤U@kUmL@bmJU@Ua@wkLWWkL@UÂƒ@VaU@ÂƒLUakKWbkUWVkKkLVLUV@JVbÂƒz@VÂƒÂ„Â@ÂƒVmUU@kVmKÂ¯@VÂƒU_Â™VWakVmIUKUaU@@bml@XU@@V@LmKUVÂÂ„mVUKÂƒÂÂƒKÂƒbkaUXÂƒKUL@x@V@l@Â„mxUÂ¦Â„V@ÂŽlL@V@Ln@@VV@Â„nlKUaV@nLUbmJnL@VWLkbmVÂ„@@LÂ„WÂ‚Â„XLlxÂ„VVIVV@x@VÂ²blUVmÂ„LVUÂœK@kWWXUlV@Xl`Â„LXÂ„l@@VÂšÂŽÂƒn@VnbVÂš@lVÂUVUÃˆVbÂš@@`UXU`l@@XUVm@kÂš@xmVknUJVXUbmKULmbÂx@VlJ@LVbkKUbVLÃ‡UUVÂƒUVmU@VaUkUKÂƒVUwmLkUUVVlÂƒbkaÂ™XmwÂƒKUÂšVVU@@ÂÂVÂ±Uk@VWUUmÂ»XamUÂ™bÂƒKkÂÂ™`ÂƒÂ„Â™U@UnWW_kKmbUVUVmnUV@Â„nJVUlÂšUbU@UV@n@JmI@VmbnVUXlxÂ¯ÂŽkKmnVV@L@VÂ™bkVÂ™UmmÂ™@UbÂ¯LmlÂUÂƒL@VWLkmkLmmnÂ£WmnKU_mWÂ™ÂšÂ™bnbmxÂƒ@UÂ¦UJUÂ„@XmlkÂ¦@Â‚mnUUm@@Jn@lVÂ„Ã”VJnIVWÂ„I@aÂ„ÂƒÃ†K@I@aVKÂ„IlÂŽÃžnnl@nl`nbÃ†XÂ²l@xVÂ„@llbVnÂ²ÂŽVVl@nnÂ„V@IlW@Un@@kVaÂ°KÂšnÃˆmVaVÂXUlaVÂƒÃˆUÂ„VlwÃ´UlynIVaÂšan@lVXbÂ‚IÂš@nÂ¥la@KÂš_nÂ‚@bÃ†x@XnJVÂ„nKVz@`VXVÂšU`@bÂƒÂ¦UV@VÂšIlxÂ„UnVÂ‚KÂ„XÃˆbÂšVllÂšbVbnVn@'],
                    'encodeOffsets': [[
                            109126,
                            25684
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4512',
                'properties': {
                    'name': 'æ²³æ± å¸‚',
                    'cp': [
                        107.8638,
                        24.5819
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lLVlÂ„bVV@nXVlI@JVXÂ„mÂšnÂ„WÂ°bÂ„IVV@Â‚lnÂ„@nalVUbÂ„nWÂ‚@ÂkVkÃ’lbVKnÂ²Â°bUÂŽlVÂ²@Â˜X@`nbÂ„aUI@ÂƒÂ°wlU@aXJVI@aVK@wUamIXmÂ‚@XUV@@bV@VmÂ„ImÂnUUwVaVKXUÂ‚nVK@akÂƒVwV@nL@UV`n@@XÂ‚lnIUJl@XÂ¦Â˜V@aUIVm@anÂƒV@UwnL@VlbVL@KVVXUWÂƒÂ„wUUVUka@UVJnUlbnalbVVn@Â°Â„Â„LV`Ãž@ÂšXVxV@@bVlUVVbXnWlXnmlÂš@XXWVXJmbUI@VÂ„llUVkn@@VWV@VnbÂ„@VXUJVnn`lLVkÂ„aÂ„Â»lVÂšLnw@WV@lInw@WnU@U@mÂ‚knUVÃ³Â„KÂ‚wUmUXUÂƒU@@wVJVIl@XKVVVbVIÂ„J@Un@lÂŽVLnmÂ„b@U@Ul@nUÂšÂ°VUVJnnVJV@Â„Â@mVU@Âƒ@wkUVwkKWkÂ™yUUkU@alkÃˆ@lJ@xÂ„IlÂƒ@UUWVkUw@Kn@@kmaÂƒVUlÂ™UULÂ™Ã‡ÂƒUUKl@UUmL@aXU@mlUUwmKÂkUUVKVUÂƒaÂƒKUÂnK@U@Vl@XUWUÂ„KlwX@Âšb@KÂ‚@XkV@UwWJka@aUwmV@UÂ™@@U@wUm@Â»kLWVkIWÂŽXnmV@VkbmKÂƒLUbkÂ™Va@aÂƒaÂ@@aVU@aVakÂ£@ÂƒÂ±UkVUÂ¯VÂ™UUÂƒJVÂƒUIÂƒ@kxmUmWUbÂLÂ›w@K@aU@@aVU@ÂÂKma@aka@_VWkk@UWVUKULWKULUÂš@KUnÂƒwVaUKÂƒxU@UÂmaÂƒLÂ—m@kVmVa@UkÂƒmI@Âƒ@KmIkxU@@KÂ™U@mmakI@VÂƒLkmWkkJÂ™_UÂ‚@V@L@nÂ˜xXbÂšKVb@VVL@V@LUbUlmbU@UUWJUb@VV@@LÂ¯K@LU@UVÂƒÂƒk@Â±z@Â‚kLUbVl@Xm@Â™akÂm@ÂƒÂU@UÂšUJU_Â™VWÂŽkn@`W@kwÂ¯LmbU@UJUb@zmVÂ™JULmwk@mVUnÂ™lnb@LÂ›WkbÂƒÂ¦@xÂ°nXÂŽÂƒb@bUl@LVlUnlbUJUxWakLUVVbÂ¯Â„llkn@VÂƒ@@nVbUlVbUnÂƒVUK@IÂƒW@L@bV@nxÃ†JnXVbUJm@@bÂnmJÂ™nkl@bÂ‚nnK@LÂ„mÂ‚@Xx@VVbV@nb@UVVÂƒÂ„Â¯Âš@bkV@Vmz@lnLl@kÂŽVbUVm@mI@WÂkÂ™J@UWKkXkl'],
                    'encodeOffsets': [[
                            109126,
                            25684
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4503',
                'properties': {
                    'name': 'æ¡‚æž—å¸‚',
                    'cp': [
                        110.5554,
                        25.318
                    ],
                    'childNum': 13
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nU@JÂ‚X@`XLmÂ¦VbÂ`lÂšVXXWÂš@VblÄŒnVÂšÂŽlanLnmVLÂšK@_VaÂƒÂ¥@kUaÂ„@VmVbÂ„aV@XVVzlVVK@knKVmXÂ£VKÂšLlbnÂš@b@llL@xÄŠÃ´XaV@Â°Ãˆ@Â¤Â„bnÂ„V@@Wl_Â„VÂ„U@WÂ„nVamwÂ„wVbn@Â„KÂ‚VÂšLX@VmVÂUxlV@ÂšnVV_nK@mÂ‚I@Wn@@IÂšUÄŠ@@wVWX@@IÂ°VVm@wmU@m@IUÂƒVÂ™kÂƒlkÂUmmkÃ…V@@aV@@Wn_UKla@kÂšaVÂ„ÂšlVanb@kÂ„@@KlVn@@aV@nIWWÂ™UUaVU@Â™kKmwU@UImKk@UU@w@W@ÂÂ‚Â™kÂ@Â™UkWÂƒ@mk_W@Ua@aÂ™ÂƒÂƒ@Â—Â¯ÂƒmVÂ£@mÂƒUUam@Â—kWakÂƒVama@UUm@Ânw@alaUmnUlVlIÂœVÂ‚Â™ÂšLVykÂ£Vm@k@UUJkÂÂƒK@kmKUwÂ™KkÂWK@UXImyVwnI@mÂ‚ÂƒkUlkUKkUVmÂƒw@kkJWUÃˆm@_k@@aÂƒaW@UÂ„UJUwU@@IWKkÂƒmUUV@nVl@bVb@bUÂ‚UXÂƒakw@ÂƒWUkbkKÂƒbm@Â™xUlkLm@@wmKUX@Â‚Â™ÂUaVWÂ™XVmU@@UUUÂƒxkmWXkKkUWaUaUbÂ™L@`UL@LV`UXmK@VmakLVbkLÂ‚xUJUIVbUVVbÂ¯KÂƒV@Xnl@ÂlVXbmÃ’nV@L@VWKkVUIWJkIÂƒÂŽUamUUbm@UÂ„kU@JUbW@XÂ„WxUam@kbVVUnUJmUUV@bÂƒU@UUVÂ™@ÂƒVk@ÂƒbÂƒmULVÂ¦U@VÂ„U`VLUL@xVbn@UJ@nWJXXVÂŽVV@bkxVbUxÂ‚LÂšÂš@xÂ„Â¦@ÂšUÂ‚lXUVVlULV@@ÂšnÂŽUÂ„Âƒb@xlÂ„nJVnlVknUlVÂUbmÂŽU@ÂƒbVÂšÂ„x'],
                    'encodeOffsets': [[
                            112399,
                            26500
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4501',
                'properties': {
                    'name': 'å—å®å¸‚',
                    'cp': [
                        108.479,
                        23.1152
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lKnbnUÂ‚@Ua@KÂ„LÂ„ÂƒlJVX@VnL@bW`Xxl@Â„I@UÂ„Jl@nV@XÂ‚V@nXVÂ„@lK@UVL@JULVJ@nnJlÂœVJ@VULÂaÂƒLUKÂƒnmKULVVUÂŽ@nUÂ„Âš`lIXllnÂ„K@UlJnb@nÂšV@LV@lwnJ@L@Â„nJlÂ„@VUbUn@lÂ˜nÂ„KnbVÂŽV@Â„wVLUbÂ„xVm@LVÂ™VKXLVKVLXU@VllUX@`lb@bnbÂ‚L@ÂŽUV@bV@@b@LÂœxÂ‚KVanXVÂƒUUmVUUUaVUkyÂ‚UUaÂ„ImK@mUUVUkKU_@W@UVVVIUWÂ„UVaVU@UUKnÂƒ@k@al@ll@bnL@bÂ„VUVÂ˜X@VÂœ@@bÂ‚Knblmn@V_@aUalL@a@akK@kVKUKlwUUnÂVÂ¥VmU_VWVIVaX@VaÂ„alÃ…Â„K@LVJnalL@LnKÂ„wlVUwÂ‚mX@VXÂšÂƒlLUVnblaUmVUVwXU@WmÂ¯Va@ÂÃžKnw@wÂ™mÂškÂ„Â»Â‚UVWÂ²a@_mW@U@IÂ„yÂ„LVUUKW@@Â™Â„LX@VUV@@yVU@UV@nwUUmJka@IU@ÂƒmÂƒVkaW@UwUX@`Âƒ@kLWUk@mÂƒkUUm@kÂ‚UUWkUÂƒkWxk@@VÂƒK@nÂV@UVaÂƒUUJmIkVÂƒ@UamLUbkVmamLkaÂ™@ÂƒÂ‚ÂkmLÂ¯ÂWI@wÂJmwÂƒx@akU@aUKmbkaW_nW@_U@Wm@a@wkwUKmÂƒk@ÂƒbkbÂ›wÂ@mKUkkU@J@bW@kVWz@bÂVUaÂ›VUx@Â„ULkJWbXVVXÂƒ`@ÂœmJUVU@@Lk@WbU@UJlnXlmÂ„Vx@Ln@Â‚b@KÂ„LXÂ„WJUÂUW@kÂƒaUVUbmV@nnV@n@lVLÂƒVmLXÂ‚mXkVÂ±@kxÃ…LÂ›ÂšUbÂJWIÃ…J@IÂ‚mXalkUamKkÂškLÂ±aVwÂKÂƒUU@mÃžnbWJXÂ„mÂ„@lÂbmKULWUUVkaÂƒbnn@Vl@VVÂV@VÂƒbVbnLWLXJWxXLV@@VVÂ'],
                    'encodeOffsets': [[
                            109958,
                            23806
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4502',
                'properties': {
                    'name': 'æŸ³å·žå¸‚',
                    'cp': [
                        109.3799,
                        24.9774
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÂƒwUÂ™Â„aV@nÂVaUÂVklmkUUmmIkÂƒ@wÂ„aVÂƒmÂ@Â™U@VKUkVUkWVÂ@Â™ÂƒÂ¥@wÂ™Â™ÂKVwUalw@aUUUÂWWXI@mVIm@Ua@wVKUKV_UÂƒV@UÂ¥VKÂ„nÂ„al@Â„UÂš@VU@VÂ„V@aVUnVVIVmUUlan@VbXwWÂƒX@Va@IlVVÂƒn@VanVVbÂ„ÂlJXIVJlUXL@U@KmUnÃ‘WakU@ÂmkÂƒJUI@mkÂ™@wUmmUVÂ@JXaWIXWmaUIÂƒJÂƒkk@WÂ„nJ@Â„ÂƒaUak@Â›kkJ@kUKU_Âƒ@myUÂÃ³WUkmÂ¥kUmL@KUKm@k_UmVa@Âƒk@@UmU@mm_Â—JWIUVUÂŽWLUlÂbVÂUJÃ‡VUIVwÂƒKUVk@mU@n@lUL@Km@@l@LÂ™VÂƒzÂJmUUÂ¤m@UbVÂ²U`U@@Â¼Vn@x@VÂš@@VnUVx@blbXIVxU@WlÂ@@LÂ™aW@kxÂƒLXVWVk@@U@VmLVÂŽÂ„LÂ„bUVULVVÂ‚lnLVxkV@nWV@bnKVVk@VLÂ„VÂšÃˆVKÂšVVkÂ„Unb@lm@@LVxUlVX@VkÂ„ÂƒJ@wkIÃ‡@kl@blVVVÂšzXllLUxlV@x@Â„UV@nÂƒÂ‚U@UImmUIUVÂ™Â¯mVk@@V@VÂƒamnUKkÂm@@VÂƒIUJUaUUWLk@UJUI@xV@VÂ„VWVnÂxÂƒLUÃ´mVVÂ„@VkVVVUnV@UVkL@VVV@bVxla@bkXVJVnÂ„`nU@bÂƒb@bVL@VnJ@Â„l@ÂšVÂ„aU@@_lW@UUU@UnÂƒlll@XLl@@UX@Â°bVWVanLlknVV@VVX@VVÂƒnUÂŽVLmbXJ@nllXX@`VXÂƒlmaÂXVWk@WkÂƒwÂ—J@Â„VL@JÂ‚bnU@bn@@bVKUnVJVIVVVLÂ²a@bV@@Vl@nUVakalmÂšÂ„UL@VUL@VÂ‚a@mXÂl@nK@UlKÂ„L@Vl@@nkllb@ÂšÂ„Vnn@Â‚ÂšnVÂ„Â™VÂ°lÂ„ÂšVInwlKXxlUÂ°ÂŽn@@ÂƒÂ‚I@UnVlakÂUJWkUK@anUWK@_ÃžJ@U'],
                    'encodeOffsets': [[
                            112399,
                            26500
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4514',
                'properties': {
                    'name': 'å´‡å·¦å¸‚',
                    'cp': [
                        107.3364,
                        22.4725
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@JVzÂšl@V@Xn@ll@VlnX@@VWLnÂŽUVmUULVlUV@blnUlnXVVÂ„KÂ‚xnLlb@lnbU@VnÂ°KVVÂ„I@WXUlIÂ°VXbÂ‚VVbnLVan@Â‚xÂ„J@_nJÂ„a@wVwV@@a@IUÂ@UU@WKXwWIXKmKUaÂ„a@UÂ‚UUUk@@UmmÂ„albVUXVVKnLÂ‚a@knÂƒWÂƒXImanÃV@Â„VÂ‚LUxÂ²blKlÂ™nLVbklWbÂn@JÃ†IXJÂ‚IVaÂœÂ™Ã†KlwÂ²@lUnWWÂnKÂ„UUK@k@mmU@mnUVaVUÂ„b@lVXVÂXIWÂƒÂƒK@LÂam@@KUwnÂƒWkkmVIV@Xal@@KV@VUnI@Â›Â„_UWWUkam@kkm@ka@mÂƒk@wkJWIUÂU@WXkWÂ™XkWWLUUÂƒ@UakLÂƒWÂ™XVÂ±VIVWUU@anUWaUK@IU@Vak@@UUKWaÂƒÂ@m@ak@@wUkla@mUaUklakwVÂƒÂ¯Â¯@WWUkLkKmaÂƒÂ™kLUnV`UxWX@Jkn@bmlÂƒakkk@Âƒb@lÂ¯bmÂ„ÂƒbÂJÂ›b@VXnÂ„bVV@Â„ÂƒbÂƒJUkkKWVU@mÂœÃ›VUUW@UVUJWXkVkKmÂUL@WW@UÂ„Vl@XXKWÂ„XJ@XVlmbUxnnm@UlVnV@XVmÂ¦VJÂb@ÂšmLkKÃ‡bXblVkn@l@bWnX`V@@IVV@ÂŽVÂ„VÂ°n@@_naÃ†VVbUVVbUJnzlVUlÂ‚XkV@Vlx@XÂ„VnxÂƒbÂƒKUK@bÂ¯ÂVVUVÂ™L'],
                    'encodeOffsets': [[
                            109227,
                            23440
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4513',
                'properties': {
                    'name': 'æ¥å®¾å¸‚',
                    'cp': [
                        109.7095,
                        23.8403
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nVlwÂ„@VJUÂ„Â„IVVUÂšVÂ°lUÂ²V@Â„lÂ¤Ub@bUV@bÂ‚@Â„b@bUblÂšVaÂ„KnLla@UnUWmXÂlJXUlKV@V_UÂ±Van@VÂ£nVÂ‚IÂ„yÂšU@K@kn@@LVK@k@mnVl@VUÂ„LUxVJÃˆUVIUÂÂ‚aVkXKVÂVUXJÂ˜In`@nnV@Vl@@Â„UbVnl`n@VL@LnKlVnÂ¦VlÃ´XVÂ‚nzÂ„@V`VL@llIÂœll@VbÂ„b@ÂƒmIXÂƒl@Â„lÂ„IVJnbWXXJWb@IUÂ‚nVVn@xlÂš@nVJÂ„I@WÂ„UÂ°LUaVUUaVJVIÂwlKUalKnb@UnLVWU_@KVK@_ÂšKVaÂ„@VKUÂ¯VLVKn@laÂ„aUkU@maVUÂ„J@kÂ™@Um@XmbkyVaUIUU@KV@laVn@KXKWUkUk@ÂƒaWÂ™UUVw@aXKmÂƒVaUUkÂšmIÂƒlUU@wUaÂ™xUmmUÂ™Â¯Â™U@WÂƒLUÂÂmVIUym@UÂVmUa@wmw@Ã§Âm@aWLUÂ„Â™JUIUamKmL@Â™ÂaÂƒxÂ¯Â¥ÂƒkUÂ¥U@Â±Â„kÂ„UVmKU_mJUbkKmÂ„ÂƒLÃ…Ã‡Â™_@WWUXUmaVUkKÂ™Â„UWW@ÂnVxkUÂƒxmL@KkKmbUI@KÂƒLkÃ†ÂƒbUbW@UbUJUXV`UnUÂ¦mÂŽVVkxVLUL@llL@b@bkKVb@bU`m@knmaÂL@aÂ›@@UÂ—WVUÂƒU@amK@akkk@@b@lmÂ„VL@VUVUbÂƒVVXUJUU@V@XV`lLUVVV@nnLÂƒJVbÂVlzUVVbVVnUVVUÂ„'],
                    'encodeOffsets': [[
                            111083,
                            24599
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4509',
                'properties': {
                    'name': 'çŽ‰æž—å¸‚',
                    'cp': [
                        110.2148,
                        22.3792
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VJUXVVXlWX@VÂ™xVnX@@`ÂšÂšULWÂŽUXÃ…bWK@mULUUmJ@nÂ¯b@l@VULVxÂ„xÂ‚XU`VXXJVIÂ„V@nm`@nUÂŽVXn@lWVn@b@Jn@nU@Lm`@Xn@WJÂƒÂ¦U@@VnLÂ„lV@@Xl`nIlJnkVLÂ„w@KVK@UÂšaVL@bVKXÂ™lUUKVK@IÂ„VÂšLÂ„a@U@WÂšLUlVL@bU@@blb@VlbUxVbXUVJ@xVLÂ„UÂ„lV@VUÂ„bVLnKlÂ„XJ@LÂ‚b@an@VanL@`VLÂšKV_UWl@U_Â„a@WVInlVUUUVm@I@W@wVakIWm@U@ÂƒXwlaVbnI@ÂƒmÂ»Va@aXaVLÂšUÂ„Â»@aVa@kÂ™KkL@KmU@WÂƒzUK@wU@VWUUVUUKUa@ÂmKmbUK@_nWVaUkVaUaVUVLXKVÂƒVUVmVI@UkKkLm`UkW@UwÂWW_Â„ÂUaU@WakXmK@xUXÂƒJkÂƒUUWUk@WlÂ—ÂmJ@km@@aUKÂzmyVkÂ„a@kkWVUUÂ¯lmU@@wÂ‚kkmV@Vk@mÃ…IÂƒÂ‚UkÂƒaÂƒ@UbÂ@m@UUU`mÂUbWaÂWmbÂ™XÂ™ÂXKWIXUWm@Ã…ÂƒÂ™@y@UkIUJUUWLUWÂƒL@UkVUxW@kaWbÂKWnXxWÂ¦nÂ„m`XLVlUbVbUxÂ™I@JmLUKUb@VW@@bkL@b@VlU@xkÂš@L@lÂƒxXxWXXÂ°V@VVVbUVV@UVVbULVnVJUbÂ²bÂ‚aUb@VVVVInlV@VnXaVUÂšÂlIÂ„VUb'],
                    'encodeOffsets': [[
                            112478,
                            22872
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4504',
                'properties': {
                    'name': 'æ¢§å·žå¸‚',
                    'cp': [
                        110.9949,
                        23.5052
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VbXblVlLXWlnÂ„wVV@VV@UnÂšWUXVbÂšÂ‚@ÂVWXa@kVKÂ„ÂUaVaVkÂšUlyX@VaÂƒÂ—VmUwUaVU@UÃˆymI@aUÂÂ°@ÂšÂ™nWV@VaVaÂw@IV@VmnLVK@kmmna@Â™Â„Â™VbVI@aV@XbW`UÂ„Â„LUVVxÂ„@VbUV@bl@VLXblJnÂ¦lLÂ„Â°Â°@nÂ™@K@UlLnKÂ„aÂ°LWbnJÂ„Â¦UÃ’VÂ„UllLlVnKnbWnnÂ„V`Â„wÂ‚@@ÂXaÂ±Â™nÂ™l@XKV_Â„WVkVa@kVyUa@wUÂ£UW@ÂUIVWÂ‚@@aÂ—wWaX_WKkVmUULmak@UJUI@Â±mÂ»Â™Â—k@mÂ»VyUImÂ™nmmwnkUmVaVIUÂn_mW@Â»VkÂ„@VwkmmUXa@IÂƒaVÂmÂÂ—ÂmÂƒ@Wm_U@ÂÂmIUWÃ³LmUk@laXmmkUK@UmKULUUmWULÂƒ@VakUÂ™@Ub@bÂƒÂ¼Â™VUKWb@bUbnÂ¼@Â„mJUakbWx@Â„@VXnlJUb@x@X@JUnVVUVmkUJ@XÂƒbV`k@VXU`Â™LUK@_mKUbm@@b@Â„U`@nlV@bÂ„UnbVbn@@`VbUbVVÂ¯bm@@ÂmJXb@bVnUllVXUlbUl@LUÂ¦VVmÂŽkLVb@bÂ™l@V@XlK@V@nUJUzÂ„Â°mÂŽÂwmLmlXbWVU@UUUlÂƒIU@VVmVÂ@@Â¦Â‚bXbWxXÂ„WlXVWL@LUmkbU@@LVVVJUblzna@WVnÂš@@lÂƒIUVnbV@VlÂƒbkbm@ULUKVÂ°ULÂƒ@'],
                    'encodeOffsets': [[
                            112973,
                            24863
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4511',
                'properties': {
                    'name': 'è´ºå·žå¸‚',
                    'cp': [
                        111.3135,
                        24.4006
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nL@xn@lKVkÂšwn@Â„alLlaXV@Â„lxÂ„bVWVÂ@aUa@aUk@mVUnVlÂ„XL@JV@VxVIVÂƒX@Â„b@bl@@`Ã‡nXVlI@lÂ„xUnlVVLkllVÂÂ„@nmJUxnzWJ@VXLlÂŽÂšLVxnL@lÂ„LlÂŽVI@V@lUnlÂ¤UzÂ™KÂÂš@Â„Vl@ÂšÂ„LÂ‚lÂ„LnÂšÂ‚b@VnVVU@kÂ„aÂ‚Knxn@VkVJ@Ã…Â„UlakmWIUaVanm@_UK@UVWUa@klÂXamÂ™U@VmÂƒÂ™VIXWÂ„@lUVknVlKVLXÂŽVXÂšW@b@VlÂšnnVL@KXLÂ‚Kn@lb@UnWÂ°@VaÂ„XÂ„WVbÂ°aVa@IÂ¯aUkUaVKVwÂƒaXk@aÂ„aÂ‚Â™@wkm@alanUVw@alK@ÂUmkw@UÂƒaUmU@WXUaUK@UW@UaÂVWI@Â¥Xa@w@ÂWWÂšÂVÂƒXwÂƒÂU@mKUXUWVU@aÂ¯klÂ@akU@UULmKÂ¯VUVW@U_m`U@@xVbUz@lUbUlÂƒXU`WLk@mÂšÂ²ÂšWb@ÂŽÂ@ÂƒxU_mÂƒXmmamLkUkKVkUÂƒVÃ‘ÂƒÂ¥mIXaÂ¯KÂƒbmLkK@V@LmÂšÂ¯@ÂƒÂ¯kKmÂ¥kIWaUKk@@aVUUaÂƒ@UwVUÂƒKVÂƒX_WaU@@bUJUaÂƒÂš@Âšmbnn@lULmKUnU@@JÂ‚xUbUbU@mXÂ™ÂšÂ¯@VÂŽ@bnJÃ‡z@VUVVbVxUnÂ„Â˜UbW@kzÂ™VUlUbVbÂƒÂŽUL@lWb'],
                    'encodeOffsets': [[
                            113220,
                            24947
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4507',
                'properties': {
                    'name': 'é’¦å·žå¸‚',
                    'cp': [
                        109.0283,
                        22.0935
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@IlVVlnLÂ‚@ÂœxlaÂ„al@nÂ„VLlx@x@bXnV@@`mXX`lbnaVL@blV@bÂ„wnxÂ‚I@xXJÂ°ÂnKÂ‚lÂ„ÂÂš@lbnKnblUVanKVbÂ„@lUnJVIÂ„VUb@VÂ‚U@mÂ„L@Ul@XwÂ„llVVXÂV@lVnlVnÂ„l@XVlKÂ„@@_VWVxX@lbÂ„UÂ„nV@@JlbnIlmnVV@UwVK@U@kÂ°a@mnIVVVK@nXLÃ†aVWXÂVKÂ™Â™@_W@UmÂšw@UXWWkUUVWUIVaÂƒUkJÂ™ÂUVWbUmU@mkUJUU@UVaÂbÂ±aVaUIUmVKUaVUU@VUUaUUU@WÂ¯XWWwÂ„w@k@KlÂ™@wkV@U@alK@aX@@UmIUWUIÂƒ@mmkXU`U_WJUnUJmUk@@amLU@UVW@UkU@@VÂƒbUWVUk@@wmKkUWLUWÂX@JmIÂƒlUkkKWKkLWUÂ@UKWa@bU@@a@_UKWÂƒÂUUUmJmw@ÂnÂV_@Ä¡ÄŸKÃ³LmbUÂ¼VÃ†@xUXÂƒ@Um@wklVnUnÂ›lkaUV@Â„lVÂÂ²WVklWXXbWlkVkIm`UUÂƒLÂƒUU@UWÂƒx@XU@@lWLU@kbUbV`UXllUV@bmb@LnKVbULmÂ‚ÂšÂnVVIV`X@'],
                    'encodeOffsets': [[
                            110881,
                            22742
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4508',
                'properties': {
                    'name': 'è´µæ¸¯å¸‚',
                    'cp': [
                        109.9402,
                        23.3459
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@n@VzUJÂ‚nVÂŽÂ„K@XÂšVÂšÂ°nVVnÂšwVb@xVVÂ„knJlÂ™VVUbnÂ„WL@bUxVVXÂšÂ„bl@lVXkWÂƒXwWaÂa@Â¥Â‚@nUUUV@Â„JVkVVV@XUWanknKÂ‚xnÂÂƒÂ¯VyVI@m@UkL@W@UÂšk@aUalKnÂUUVÂ¥@KVkkaWVkUVkUm@aWanI@Ân@Â°aUUVaUa@_m@UamaÂƒV@akU@mV_@ÂƒÂa@KWIkÂƒmLUKÂƒaUVU@ÂƒkÂƒVUK@wUIWVUaVwka@Uka@aV@@aUKVkÂ™K@X@VÂƒbÂ™KÂƒU@JULVLkVWÂšUL@aUKÂ™b@VUL@LÂƒxUKmlkImJk_@WU@ÂƒkmK@UV@Â„Â¥XIm@@Wn_@KmVm@@I@aUmkXm@UWVÂ@mn_@mÂƒUUJWIUWV_ÂWÂƒwU@mUknVVmxU@@VUV@zU@UVW@ÂƒK@ÂšX@VLUVÂƒKÂƒz@J@VnX@`Â±bUXÂVÂƒÂ¼Â™lÂšn@xmxÃL@Â‚UbnÂ°@XWVUxUVVnkbWVXV@XÂš`Ã†ÃˆÂ„KnÂƒlLVanIV`nLVUlÂƒÂ²ÂƒV@VÂ¦Â„lÂ°Â¦Â„wÂ‚b@ÂšnKnLVbVJÂšIVÂƒXK@bÂ‚n@Ã¨nx@xVbUnVÂ‚'],
                    'encodeOffsets': [[
                            112568,
                            24255
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4506',
                'properties': {
                    'name': 'é˜²åŸŽæ¸¯å¸‚',
                    'cp': [
                        108.0505,
                        21.9287
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XV@XÂ°Â°UÂ„lxkbVlVb@nkbVl@xl@@b@nÂ„Â‚XbVL@Vl@UbV@@JVLXbmV@bVVUXUJUÂ²ÂšWÂ„XlKVbÂ„@VVXKlXÂšWlXXWV@VÂXJlI@xÂ„l@nlbn@lln@lbXalIVK@ÂƒVwÂœUVbÂ‚U@aXylUX@@aW@U_UJmUÂ™ÂnÂVKUamL@Kna@aVUkkVWU_ValaV@XK@kV@@WÂ„wVXV@Â„VÂ„KVVn_lJlUXkWaXWlkXUÂ‚Â±kU@ÂƒVUlbÂœkVmUmlkÂ™Â¯ÃÂ™Â™WÂ@mb@Â¦VxULmÂ™kJUU@ÂmaÂ¯wÂƒmkX@VÃ³JÂ±bUVUXÃWkÂÂ™lWXXlÂƒxUaÂƒbÂƒIÄŸÂ™Ã‡@U@mVUKkkm@UJm@XnWV@x'],
                    'encodeOffsets': [[
                            110070,
                            22174
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4505',
                'properties': {
                    'name': 'åŒ—æµ·å¸‚',
                    'cp': [
                        109.314,
                        21.6211
                    ],
                    'childNum': 2
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VaVLnK@IÂšJVwUaVaUkWKn_mÂƒXÂ¥WwXmÂ‚LXalbUÂ£UyVÂÂ„Ã…@ÃÂ™wm@Â™Â°ÂlÂ›LÃ…UÂƒmkÂ™mwÃ›aÆ‘LÃUUm@È£Ã†ÂƒV_Â„Ã“@Â£UÂƒÂƒUÂVÂƒÂ„Â™Â¼UÂ°WÌ„Â™ÃžVbXbÃ´x@b@bmVÂ@Ã‡ÂƒÂ™UÃ@@Ä¢U`mÂ@ÂŽnxnIVVÂ‚VXÂ„VL@`@bV@@aXbVLÂ‚@XVlKXLlLVlÂ„knJ@IÂ‚WVXXKlVnL@xl@UVVXÂ„a@UV@VlX@VUV@nK@bl@nVVIVmXIV`V_lWnnÂ„@VJVXnJ'],
                    'encodeOffsets': [[
                            112242,
                            22444
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/gui_zhou_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '5203',
                'properties': {
                    'name': 'éµä¹‰å¸‚',
                    'cp': [
                        106.908,
                        28.1744
                    ],
                    'childNum': 14
                },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@@UnUlJnÂÂ„wÂ‚JUÂ°VL@bnVÂšUÂ„wlJ@XÂƒÂŽXVlU@klVUJknlÂ„UllL@bUJ@xULUlÂƒÂ„UblVkblbnwÂ‚UXmla@ÂÂ„wV@VK@L@UXaVKVLXWÂƒUVa@U@Im@@W@Â£UKUakKWIXU@al@@llUnL@W@Un@@VlUV@VIUanKl@Xb@lmxVb@bÂ°bÂb@nlJVVnÂnJ@b@LÂ‚V@lnÂ„@LmV@VÂx@blnVKÂ„nlJXIlwÂ„J@Ã’Â„b@nlK@Un@UL@VVVVUUUVKÂ„lÂ„@VUVLÂ„J@UVUUwÂ„@Wm@Â™Â„UVÂ„ÃˆVlbUb@JÂšLlÂŽX@@xÂ„Â„ÂƒLmÂŽk@@nlx@bUJUzVJÂ„@@LVxUV@bWxnLnVVK@_Â‚KÂ²xVbV@nÂ¥@aVI@bÂ„@l@VaÂ„Knb@nÂ‚`nÂÂ„mmÃ½Â„W@ÂƒU_ÂšwV@VlVV@Vn@nÂ„Â˜@nI@Jn@Â°Â¦VaUU@Â™Â„mVÂVWVaUÃ…Â„U@aVKnÂƒVbVÂUmmU@a@kUwÂ™m@aUUmUUJÂ¯ÂlakUÂ‚aXaWUUaVÂƒkkÂ„amÂkmUnVlULÂƒVlJ@XU@UJWUUwÂ„k@aU@WbkWÂƒL@U@WU@@XUKmV@aUÂVwUÄ•UJUamUUVUÃ‘mÂ™nIVJ@kl@XalJVn@KVLÂœÂ¥@UWIXWmU@mVÂUKnUWLUKUaWUUKVU@U@anUny@UlUkK@w@a@aVUÂƒÂ»UkVw@WmkÂ—JÂƒÃ…mUUVmwXalLXWWUnam@XkÂƒJ@UVU@U@WÂ„@@U@I@Wl@Ãˆnlw@KXLWbÂ„lVUkalKUUÂ„VVaV@@wnIlaUmkUÂƒKWU@KkUkLWaÂƒKUÂUWUn@VÂƒK@LnnWJUIÂƒVkUWVnV@VÂ™@@XÂƒK@VUIUJ@IWJkX@VVJÂ™IÂƒVkK@I@UVaUWk@mÂ„@wnUWKk@mxk@@Â„lV@bÂ„xmb@x@VÂUmLkUÂƒJ@nVV@b@VkLVbU`Â¯IÂ›l@Â™U_UW@UU@Â™Â™ÂƒKÂ¯wm@Â™xÂƒLÂ¯Â¥kIÂƒÂ™ÂƒÂ‚@bkbÂƒ@Ua@ÂÂƒm@kkW@XVbmV@ÂŽkV@bWbUbV@Â„Â¦ÂƒxXlmVk@ÂƒÂ¦Â™bkaWL@KUImK@wUK@VUIÂ™b@bmK@LÃ…y@akXW@kbWlXblL@ÂŽULUbÂƒ`@UÂ™kUymXÂ¯@mÂšUJUÂUJÂƒL@Lm@@WÂX@lUÂ„VlÂšXllÂ„@l@ÃˆkÂ°VÂ°ÂŽÂ„X@VU@UVll@XUJVXUVm@@VXLWlnV@XÂƒÂšk@mVULnxV@@bmÂ‚kL@VWLUbU@UVm@ÂƒbÂ@Ä·Â¥UnmJ@UUVÂƒkkJUÂšlÃ”U`UIW@ÂƒÂ°kLUlUI@WVIÂ™U@mWKkXk@ÂƒÂ‚WU@bXÂšWÂ„@J@xÂX@l@LVl@xÂšLVxXX@xÂ‚KnxVknbÂ‚KVV@UÂ„LÂ„WlXU`@nUlÂšX@llVXÂšVUÂ„KlkUKlI@anKVLXKVaUIVWV_VK@VnLlUÂ„Â»VKVLÂ„m'],
                        ['@@@KlKkUUVVX']
                    ],
                    'encodeOffsets': [
                        [[
                                108799,
                                29239
                            ]],
                        [[
                                110532,
                                27822
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': '5226',
                'properties': {
                    'name': 'é»”ä¸œå—è‹—æ—ä¾—æ—è‡ªæ²»å·ž',
                    'cp': [
                        108.4241,
                        26.4166
                    ],
                    'childNum': 17
                },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        [
                            '@@VV@XkV@bUbWJUÂ¼Vb@Vnb@bÂšÂ„@J@bÂƒL@LV@UVÂƒlUI@aÂ™KULVb@bkJmxÂ„ÂšlLVxknVJkÂ„Â‚xnKmnnL@bn`WIXlWLU@UxVbUVmKVÂ„XI@JVIVJ@UÂ„L@WÂš@@UmUXUlVÂ„UVJXImm@KÂ„L@UVmVXVÂ‚Â„LXblKlV@LXVÂ„LlVVnkbmJ@xnXl@ÂšbXaÂ‚@VanaÂ„Ã’ÂšLÂ„mÂ‚VnIlÂ‚ÃžÂ¦Â°k@bÂ„@@lVÂ„nJlUnÂšÂ‚VX_Â„@lVlKÂ„ÂÂšVÂ„UUxVLVWVIXJÂšUlnnWlI@KUaUUVKn@VaVXV@na@ÂƒmwÂ¯@mUkJUamI@lk@@am@@IÂ„ÂƒUmVImUUÂÂwÂ˜Â™@anUVaUU@LU@WaÂWUXWWÂ„wV@VwnU@L@ynbl@@X@aÂ„J@nW@@Vn@Â„lVLlxnIÂ„lÂš@@UWKUÂƒnIlJXIVllIVVÂšÂ¼XK@aVIÂ„VÂ‚@@bn@VKXLVKVVVInwÂ„J@UWI@mX@WKnI@KmUÂ„UVJUL@VÂ„KW@@kÂ„Â@aU@@W@InJWUXwWI@WÂƒ@Â¯wkaVaUIl@nÂŽValIXWWI@UUm@anwWkXWWIUbk@UJmIUamKVUUUÂVVamaÂ¯VkIVÂVUlKnXVwX@@WVaUUVa@IlÂƒÂaVmÂƒknaÂ›wkÂ™UU@ÂƒU@mUVÂƒÂšUVwÂœlÂ°LVbnJVUÂ™Â¯la@mX@@UWKXU@aV_V@@JlkUÂƒÂ¯@VÂ™nK@kmÂÂ¯kÂ„U@ÂƒWUÂW@ÂmmÂƒU@Â™kmlU@wkL@WÂƒUkL@VmLÂƒJ@b@V@bknUUVK@UVKUK@Uk@Wa@LUVVnUbmVk@@UU@@aÂƒVÂ¯K@U@UU@WmUL@aU@WVÂ—w@ÂƒÂ˜IÂ„xXll@UXÂ‚K@KXXVJna@wWaÂƒÂ£naUKVÂÂ„m@UU@mUmaÂlm@@XkVm@ÂU@VÂƒLmWU@kkWxU@@bVV@VkXVlÂƒVÂƒ@UUk@@ÂƒmI@KUwÂ„m@UmVÂƒUUwU@lwkV@IUa@mUaVIVKVa@w@U@Â™UJkb@n@bmJ@XmlÂVUxWXkJmUkUUVWÂÂ™xUlU@ÂƒaULUÂšmbU@@Â‚WXkmÂƒL@xUV@nUxÃ‡m@Â„XLWbnlÂƒnVÂ‚nnUVÂ˜ÂUÂ‚nVVzÂ„@lbUVVlULVb@V@nUJkwm@Ux@bWbUK@UULkaÂ›JÂbÂƒUÂ™U@U@lUK@XUJmnÂ™J@bU@UwWaÂ™x@zkJWnUJUUVÂšVV@bXn@xVb@JÂ™LÂ™m@XÂ™w@`@bkb@VmXUVÂ¯L@mW@@n@V@Â‚ÂƒL@KÂ—IW@@aÂƒaUxÂ¯@UÂ„m@XbW@@LÂ„V@bnVWVkKUzlV@bÃ†a@lnI@VV@@LnVVKUaV_VJVbnU@bn@Â‚Â‚nX@yVIVxXKVLlUVaXUÂ°J',
                            '@@@KlKkUUVVX'
                        ],
                        ['@@UUVUkUmV@ln@VXVK@K']
                    ],
                    'encodeOffsets': [
                        [
                            [
                                110318,
                                27214
                            ],
                            [
                                110532,
                                27822
                            ]
                        ],
                        [[
                                112219,
                                27394
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': '5224',
                'properties': {
                    'name': 'æ¯•èŠ‚åœ°åŒº',
                    'cp': [
                        105.1611,
                        27.0648
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': [
                        '@@UkVÂƒ@kÂ‚W@Xn@@KÂ„KVIVÂVInÂ™Â°@nWVzÂšl@VÂ„_VaVK@ÂkKWaXklaX@lW@bÃ†z@KnL@aÂšaVJ@UVL@xnLVJ@LXKlbÂšaÂ„Â¥l@nUWkÂ„wÂƒÂ¥U@VaXa@amLkUÂƒKmÂƒÂ¯kÂƒmkIUaÂƒKUIWÂƒkKmÂ@anw@mlwXIÂƒmÂƒUkÂ¯@a@amUÂƒ`kÂkKWVkxmUUak_mJmw@wÂ„mXUWÂ¯XÂÂ›_@WnI@aVwkWWÃ½Ã…ÂƒU@WLkUÂ™aUbVV@lUVVnm@kUmVÂ¯Â™kKÂ™LÂƒwmVÂUUaWVÂ™aÂaWwÂ¯wÂƒÃˆ@VULUVUUÂƒK@nWJkIÂ™l@Umxnbm@kbUJÂƒaÂ¯bUbVxmLUVÂ™aUÂ@VUUWxkVVV@bUV@XWbnlUbÂƒbUJlbUVÂ¯b@zÂ„`WbXnmbÂƒaÂƒwUwVWÂUÂƒbUxmbU@UamÂÂ™Â@ÂVÂƒkÂ™VÂÂaÂƒwVaUÂƒWI@mUKÃ³z@lUlÃ…@WIÂƒb@xXxml@XklULWKUÂmwUaÂ¯KUXWJkaULmKkLWbkKUVÂƒImÂƒÂÂƒWa@kUaULÂƒWÂ¯LÂƒKÂ¯@kbÂƒL@bÂ™x@J@bmnnlUÂšlzU`U@@UÂƒb@Â„mÂ‚nÂ¦Â°bUÂ„Vx@bkVmÂ¼mxÂ@mkÂ™mVV@bkxVnÂ„aVV@bU@mL@bÂ²`lIVV@lXLlÂšÂ„bVxn@@bl@XllIVÂšnbVÂšnÂ°Â°wlbXw@mVaÂ°ÂlVnU@mÂšÂ™VLVbn@@bÂ„@@WVnUV@Xlxn`VznJVb@L@bV`V@ÂšUnwÂšUÂ„@WUXKV@UUlmUUlaXalLÂšmÂ„bÂšIVbnJVIlVVaUUnWVXnÂ‚VLÂ‚k@ÂƒnWnblnlbÂ²xÂ„xVKVXlVXLVWÂ„LlUVJna@wVLÂ„Â¼@JVX@`@nnx@nWJU@Vx@XXKÂšÂŽUblxUÂÂšÂ°Â„LVKVVlL@KnbVUnJÂ„IlUÂšÂƒnKlÂ£VWÂ„xÂ„IlJ@nÂšVÃžUVVnbÂ‚VX@V_Â°lnK',
                        '@@@UmWUwkU@Um@@VkL@V@Â„Â„Â‚VÂ„VkV@nbVa@Âƒ'
                    ],
                    'encodeOffsets': [
                        [
                            108552,
                            28412
                        ],
                        [
                            107213,
                            27445
                        ]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': '5227',
                'properties': {
                    'name': 'é»”å—å¸ƒä¾æ—è‹—æ—è‡ªæ²»å·ž',
                    'cp': [
                        107.2485,
                        25.8398
                    ],
                    'childNum': 12
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â‚V@IÃ¶alK@UV@@KUaVIVVÂœLlaVbVWnX@Â‚@LnUlxl@naVLXVVaVUÂ„J@ÂlUUanWWIÂ„@VlV@XbÂƒb@VÂ„n@VmVVbk@kU@VÂ›V@XÂ„J@zn`ULW@kK@_WVUK@LUb@Jlxn@nnWlU@@bÂ„x@XVVU@UbVbÂ‚@n`VI@VVLUlUIUV@KmL@VV@XIV@@lVLVmXVÂ„@WLXLW@U`Âšnkb@Vl@UL@VVVÂ„LÂ„llX@`lIXbÂ„JÂ˜IXWÂ„LÂ‚aVL@ÂŽXXWÂ‚ÂÄ¢Â™b@bmK@L@Â°@VnxmxÂšnÂ„K@xVn@VkL@VÂ™LÂƒakbl`VnnxVnUlÂšÂšV@@VVXV`@ÂšÂœkÂ°JV_UalK@U@aUU@mÂ„IlVnKÂ‚V@U@wnaÂƒw@akU@Âƒl@nwl@XLmV@xnÂƒl@VXUb@V@JlLÂ„UÂšJUI@UlWUÂƒnLVUUaVwV@XKWkXJm_@amKnmmLÂwlÂƒUIlmUwkKÂƒÂ™nwlI@aUaVKÂšL@bVJÂ„kVUU@@KÂ„K@a@IÂ™Âƒ@ama@UUaVÂ»XIVa@alU@WUUÂ¯IWVUbkVUKWLUwUJ@zmWÂÂm@@amVUaUIU`VbULmU@KU@@UmJ@kÃ…b@akUVylLXUmU@aÂƒU@KX@Wan@VÂƒÂ°@VwÂ„b@bX@Â˜J@LÂ„K@Â@U@mX@@nÂ°KVUnW@Ula@a@_Âšx@WÂšnÂšK@IUa@wWm@aUUUÂ™VVVIXmlI@yÂšwXbVxV@@aÂšInmVI@WVL@k@VÂšVÂ„VÂ‚aÂœIlbVK@VVLXa@aVwn@lxVI@m@UUaVKUkVUkaÂƒ@UymUVÂÂ—ÂVUmmUÂÂ„mmkXaWK@ÂƒÃˆnVw@mVU@wÂ„KlnXW@ÂV@naVÂ™VKUk@KVIUWÂƒ@mk@KXU@Um@@lÂVÂƒk@UVJna@UWaÂƒL@a@ÂƒXa@kmmVUUk@mkkÂƒamJÂ—ImJUUmIÂmÂ±aUUkambkamVUU@VlbUbVVÂƒxXÂ„WVUU@VUakU@UmUVÂ‚U@mnUVVnUbVJ@bÂ—UWÂ¥kLVamVÂkUaWJU_UVWKk@@nlÂ„UVVJUXÂm@Vm@UnVlmbnÂmJUbULU@@UUKWVÂIWxnJVb@xUL@bUJWIkxÂƒbkb@xVJÂƒbmU@kÂWÂ±LkKUkVa@aÂ¯amÂ¥ULkalÃ‘lKXUWÂƒXÂÂƒaVakImVÂƒ@ka@ÂUUÂƒJÂ¯aÂƒXÂ™mmbÂ—KWU@wUUÂƒaUaÂ™KmU@UXlWbÂ—Â¼WLUKUbÂ°Â„UlVbkbVL@VÂƒÂšÂƒJ@nVlUbUXmJ@VX@lbUbU@@bWb@VnLVJ@bVVUzÂ„ÂŽVL@lnL@bÂ™VVVULmKUkÂ™Jkbm@ÂƒxVb@VÂ—kÂƒKVnnV@b@ÂŽWXUÂ‚Â„nVÂ„lÂ‚ÂVVXVJUXlVXbWV@VU@Ubk@@KWbUUmL@JnXVÂ°XJ@_Â‚`UbkXVVlÃ†kbÂƒ@VLXVV@Â‚V@kÂ„KXX@`V@@n'],
                    'encodeOffsets': [[
                            108912,
                            26905
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5222',
                'properties': {
                    'name': 'é“œä»åœ°åŒº',
                    'cp': [
                        108.6218,
                        28.0096
                    ],
                    'childNum': 10
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â°a@aÃˆbVUlU@aVKnVVÂÂ„VUÂlyXÂ¹lWVa@ÂUÂ™VÂƒnUVU@mÂ™Â@mUÂl@Â„mÃžwÂ„@Â‚xnIVbna@KVIÂ‚J@kÂwVÂ¥ÂƒUXÃ‡VkVW@kkKWU@aXUWmnIVaÂ°VXbmL@VVbnVVVUbÂ™ÂVbÂšJVbVKXkVKVanU@aWÂnWUÂWa@UÂ™Ânk@mVIVK@wXxlLXbVJVÂlKÂœbl@VI@mÂšaXalVVÂ„VbX@@aÂšalnkx@b@VÂ‚b@Vnx@bVVUXnÂ¤WXn@Vl@Vlzn@Âš`@I@KUU@ÂƒVÂ£namÂVkXa@aVKÂ‚nnU@anVlKÂƒa@UUU@amk@Â»kÂƒUÂ¯@aÂšÂ„VWnkWmkImU@akaVm@Â»VUV@UKnkWÂ¯XWlkUKnIWaÂš@nmlIXmWUnwUwWm@wULmaUJkIUaÂƒaWaÂ—klwkwmJmU@bkJ@XUJÂ¯ÂW@XbWbUKUkWJUUVKnn@UmmXUWa@mU@@UÂI@WmXVykwm@kaULWwU@Â¯ÂƒlKUUVU@mU@UkmaUbmV@bÂ—ÂšÂ‚xVÂnVUJVnÂƒÂ„@Jn@@bl@@knJVblInVÂ°@nx@Â„mbU@UWUbm@ULVVVb@LkJmXkmÂ™VWIUJUXUKVwÂƒVÂ™UÂƒÂŽkLkUÂƒ@W`ÂUmÂ™kVmIUÂƒ@kÂƒ@@aÂ¯lÃÂ¥kÂmJÂUÂƒnÂ™KÂƒÃ‘mbUbÂ@WbÂ™ak@mWU@UbÂƒUVVkLlbUVÂƒkXaWK@LkxÃ‡mk@@X@J@VÂƒ@@X@VUV@VÂ„IWln@mbXVWXkKWbnxVUnVÂ„Ã†Â˜Inl@XUxVlÂ„Â¼UV@b@b@xlLkV@VmzmV@b@VUVVLXVVbVLXKmVVLUÂ‚@nnVWXXJ@VÂ›Â¦UK@LUmkIWbk@@lUImJnÂšVÃ’VUnVVbVIVÄ–UxVÂ‚@bnUVL@WV@@X@VÂ„KlXXaV@@bÂƒlVxXVVIV@@WkIÂ„UVKUkVmlnnÂŽÂƒbllUÂ„VbXVWbÂblVkbÂ°ÂŽVInVVV@bÂšnVx@l@bnVVnUÂŽUamÂ„UL@bÂƒVVÃ†UbUXUÂ‚Âƒn@ÂšVVUb'],
                    'encodeOffsets': [[
                            110667,
                            29785
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5223',
                'properties': {
                    'name': 'é»”è¥¿å—å¸ƒä¾æ—è‹—æ—è‡ªæ²»å·ž',
                    'cp': [
                        105.5347,
                        25.3949
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VL@Vl@@IXW@kVUVbnW@XlKVVnUÂ„VlL@bÂ„aVbÂƒb@xXÂ‚Â°Ã”UxV@kbm@VxkxWJÂœÂ„VÂ¦ÂƒÂŽ@ÃˆnÂšVKÂšxWÂXJmV@nÂ„Ã’@xVbn@@blLk`VX@bÂšÂšlaÂ²JVUlnn@UÂ±lw@wnw@mlwVIX@@m@klKnkÂ‚aÂ„KnwmmXkÃ†ÂVmÂ„UÂšÂ¥l@nbÂ°Ân@Â„aVwVmVIVÂnI@aÂ„Â¯@mÂšUÂ°Âƒl@@VnI@JV@UV@b@IUbVJmXÃ¶ÂºÂƒzllUbVa@aXUl@Â„U@llLnKVaUa@UmK@UÂšwVÂÂ„bnKV@VwVK@UXÂƒV@Vbn@Â‚w@UÂ„WnXÂ‚@Â„a@mÂ„IÂ„Â™@UUKlaUaVkÂ¯ÂƒVaVLXKÂ˜Â»XaWkÂ¯mÂƒkÄŸwmWÂ@mIÂƒVkwÂƒJUIÂšÃ‡VwUÂ™UkVKkÂƒm@UkmU@WÃ…wmÂ£ÂVÂƒÂ„mÂ¤Â¯IkJWaÂ™_Â™lUbmJÂzÃJkÂ„ÂƒUÃ‡VUÂ„ÂƒÂ‚@bUÂ„ÃnÂ™mÂ¯LUb@`mL@VkL@VÂƒUmmk@UUÂ±ÂUmka@kUÂƒ@ÂÄ·ymUkk@mmkÃmUaUakImV@V@VÃ…LÂƒÂ¦ÂƒJUXmJXÂšWb@nÂ°Ã†ÂœxÂ‚Â¼nV@LlbUÂŽUbmLÂ¯@ÃžbVÂ¤nbVx@bUVlblIÂœÂ™@KVVUnVJUn@VlLUlmLUUUxmK@IÂ@@VW@@bU@UJmUkLVVUl@b@V'],
                    'encodeOffsets': [[
                            107157,
                            25965
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5202',
                'properties': {
                    'name': 'å…­ç›˜æ°´å¸‚',
                    'cp': [
                        104.7546,
                        26.0925
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@Ã´yVL@nXJVÂ„UbÂ„xÂ‚bUÂŽlÂšUÂ„@ÂŽÂšÂnÂŽVbV@naVwÂ„aÂ‚VUXVxÂ„xÂ„bnaWmXaÂƒ_@yÂ°aVUkaVIÂ„aVamkXa@WVU@aUUlUXwVV@UVÂÂšbVUnKUwVaÂ°aÂ„bVIlan@manw@VÂšklJXI@mÂ„LVVVUVK@UÂ„Ã‡Âƒk@KUa@UkaVU@UVWV_XWVXVWlLXKlLXaÃ†KÂšwVL@akKm@UwÂƒ@@XUVk@VÂUI@wWK@aUVÂ™I@UkK@ÂƒmLÂ™WÂƒ@kImJÂƒUÃ…VmkXUW@UJkx@nmx@xkxVÂ²m@kmUVÂ±IkbÂ™Â™@aUWl_kK@am@Ua@wÂƒÃ‘@mnUWIXÂÂ™wULmÂ™@Ã‡Â„ÂUÂ¥Â›ÂƒXIlwUwn@laU@VwÂ¯Ã“WÂ@wÂ„aUaÂƒb@akKÂƒUmVUUkL@WmXUaUV@lWX@Jk@@UUKULmLUJmzkKmVXÂ°VÂšUnWKULÂ™ÂƒÂƒL@mU@UnVJ@b@Â„UV@XÂƒ`m_@lÂ@@bmbXJmnnÂš@Â°Â˜wnn@ÂŽVLX@VÂ‚@nVl@nk@@bÂ‚l@nnÂ°WlXzW`XXVKnUlxVbUb@Â‚VÂ„Xb@ÂŽÂ‚ÂVxÃˆbVlnbmn@ÂŽkVUL@Â„ÂƒÂŽmLUVVL'],
                        ['@@@Âƒ@UmWUwkU@Um@@VkL@V@Â„Â„Â‚@Â„V@VkV@nbVa']
                    ],
                    'encodeOffsets': [
                        [[
                                107089,
                                27181
                            ]],
                        [[
                                107213,
                                27479
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': '5204',
                'properties': {
                    'name': 'å®‰é¡ºå¸‚',
                    'cp': [
                        105.9082,
                        25.9882
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lL@bUKÂ™xÃ…LWbkKWLkKUXUWWXU`UX@VUVlb@VVb@LÂ„lÂ°xXxÂ‚bÂšbXUVbÂ‚VnUÂ„xÂšKlLÂ°ÂšnUlVn@UmVU@kUUVaÂšblVXKV@Ã†Â„XÃ¾lXUxnU@mVK@_@ml@UUÂ„@ÂšblU@KnLVyUwÂ„@@UmkÂšWVw@UVK@VXzVK@nÂ„VVUUW@kVJnÂlaÂš@nKWÂ™kaWL@UÂ—Â™Ãµb@JÂU@mU@@_WWÂƒL@lÂUU@WUUKÂ„@lakÃ…UUlWVaÂ_@`WIUÂ¯mW@InKVVXa@Ll@VaV@@UXUWakUVWUIUWÂ‚UkÂUÂƒÂƒmVÂXW@Â@amUUmÂ„LÂ˜l@UUaÂ„wn@laÂšIVlnLVKUUÂšU@amK@kUKÂƒÂVyUU@aUImK@UXa@aV@VakaW@@UnIVWVaUkÂƒbÂ@mWÂƒX@VÂxm@UaU@WÂ„@VULUxU@mLÂƒaUÂŽÂ™x@VnL@VVbUbmLkK@kÂƒVk@WV@bUbVakkÂ„yÃµÂ¹nWUIVa@J@aVUU@@ImJ@Uk@Â¯Â„Â™V@nÂƒÂ°@bmJUÂUJUnUxÂƒbm@Â¯ÂŽmak@Â™Â¦ÂƒVUnÃ…ÂŽWlnnmxÂƒLÂbmlkL@l@nWVnlÃ†UÂ„VnIlJÂ„@ÂšXnK@Â„lL@VÂšJVU@bXL@xVJUÂl@VU@WÂ„@Vxn@'],
                    'encodeOffsets': [[
                            108237,
                            26792
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5201',
                'properties': {
                    'name': 'è´µé˜³å¸‚',
                    'cp': [
                        106.6992,
                        26.7682
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nÂŽlLXÂ„VJÂ„LVblJÂ„nÂ°lnÂ„Â„LlVnKlU@ÂnUUa@WlX@lÂ„n@Â‚VbÂ„@la@aÂ„ÂÂ„ÂšlJÂ°Â¦Â„KÂšwn@Â°xÂ„LVkUmmwUmk_laÂ„bÂšK@UlK@UUm@wÂƒLÂ™mnwmw@U@Â¯@KnL@aÂšaÂ‚Ä¡XÂWW@ÂUKÂbÂƒKWXÂ—JÂƒIWakJ@_kWÂƒkÂƒKUU@UVKk@@UlaÂ™mV_X@WKXKÂƒ@WUUnUK@kU@WJU@@UnK@LVUVJVkUK@UUJm_Â@UaVaV@UU@WÂƒw@aV@Xkmmm@kw@IVa@KVLXU@`lLX@VKm_@yÂƒI@WÂœU@UlVl@UanU@UÂƒm@UÂ„aWaU@UkÂƒ@XJmXVbkV@ÂŽÂƒIUVUbWUUKmbk@kwmV@K@ÂmWUXUakbÂ›KUUUJVb@LU@@VkLÂ˜Âš@VXKlbXÂšmLÂ™@kbmÂ‚UI@lVXUVÂƒU@mULWy@UUL@VUxÂ™Xnl@VÂƒ@VxUzmK@LkVÂ™aÂƒ@VVk@@n@`UL@nmV@bmJ@XÂœ`WÂXÂ°WVÂƒn@xnxnIl`VbnVlwXUlLlÂ‚Â„_nV@b@blÂ°Â„VÂ„nWJkx@nmx@b'],
                    'encodeOffsets': [[
                            108945,
                            27760
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/hai_nan_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '469003',
                'properties': {
                    'name': 'å„‹å·žå¸‚',
                    'cp': [
                        109.3291,
                        19.5653
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã Â®Â¼jpnrÂ’``ÂŽpRVHÃŠÂ˜ÃŒÂ¤ÂžZt^JÃ–AÂ˜[Â†CÃ¢lTÃ©bQhRPOhMBcRSQiROE[FYdGNOEIH]MgEAMLLIAG_WMCSL@ED]PCLYC[ZIHgjSxJTMbHNEFCMEE_HSDFHSLECRNSFDRICHNADGPI\\RZGIJTIAHLDQOHG`GTNCOIC@eIGDWHIS[kiE[FMbECÂZS@KKS[FDWsCeRuU_DUQNOE[LKGUBMÂ¨EDQP@HWHGDImÂXÂƒCogÂ_~Â‹I_fGDG|QDUWKBC\\ore|}[KLsISBHVXHCN`lNdQLOnFJSXcUEJMCKSHOUMDIm_Â‹DI`kNDIGEYFM\\YPEEIPMSGLIKOVAU_EBGQ@CIk`WGGDUM_XcIOLCJphHT_NCISG_R@V]\\OjSGAQSAKF]@q^mGFKSW^cQUC[]T}SGD@^_ÂˆaRUTO@OHATÂŸÂ”'],
                    'encodeOffsets': [[
                            111506,
                            20018
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '469005',
                'properties': {
                    'name': 'æ–‡æ˜Œå¸‚',
                    'cp': [
                        110.8905,
                        19.7823
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â€hÄ²Â¤ÄªÂ¯LQDaFÃŸL[VQÃ¬wÂ€GÂ‚F~Z^Ab[Â€Â¹ZYÃ¶pFÂºÂ lNÂ®DÂ´INQQk]UÂ‘[GSUÂ©S_Â­cÂ‹}aoSiAÂ£cÃ…ÂÂ¡Â©EiQeUÂÂ­qWoESKSSOmwÂŸÄ‡ÃµWkÂÃ mJMAAMMCWHGoM]gA[FGZLZCTURFNBncVOXCdGB@TSbk\\gDOKMNKWQHIvXDJ\\VDTXPERHJMFNj@OwX@LOTGzL^GHN^@RPHPE^KTDhhtBjZL[Pg@MNGLEdHV[HbRb@JHEV_NKLBRTPZhERHJcH^HDRlZJOPGdDJPOpXTETaV[GOZXTARQTRLBLWDa^QAF`ENUPBPÂ…\\Eji`yÂºEvÃ¥Ã '],
                    'encodeOffsets': [[
                            113115,
                            20665
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '469033',
                'properties': {
                    'name': 'ä¹ä¸œé»Žæ—è‡ªæ²»åŽ¿',
                    'cp': [
                        109.0283,
                        18.6301
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÂªVLP`@PEdNRAHOPEAKHEVL`GZBJfvdTAXNNTZJFPrHHNpKTD\\ILHbEVd^JÂ‚OHLh@NNBnHP`\\xH@NBRLJTlÂŽNv_^CTLd@bNDVFbxdFVÂ€UPBTKOGEOUO@OEBXQP[H_EI\\EbeYa@UO_JÂ‹MEJ_IEDKJUGMDcNUd_FMTEJSGoZ]EIYGO[YWÂ‘gEQ]a@WHEDQKUSDUGAbYBUpSCYNiWqOSQEoF[UcQISWWNÂMSDe_cLQ_UBiKQOOASQAWgSÂ­Ä]ZaÂŽSPÃZ]XMXSÂŒ[^oVÃ‹NgNKlEÂ RÃ´EÃ¸'],
                    'encodeOffsets': [[
                            111263,
                            19164
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4602',
                'properties': {
                    'name': 'ä¸‰äºšå¸‚',
                    'cp': [
                        109.3716,
                        18.3698
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â®Ä‚hTBXTRPBRPjLVAR`dKf`TCÂ‚NXMTXRJVdE\\FpTRrPjXZMTDVoZABaVHTCLVCRGF@X^bFRÂ’hZXP\\ZHHMA[^wBWXJlWÂ¤EJ[bCTOFÂ‹WWMm@ILMGWQ@DQ^QNWFSHEbF`OXNbOÂ„VNKTEPDTLTCCVTREfvfEHNbRAENH^RJXCFHNFRpVGHWISDOTMVCZeGamaLoLÃ›DÂ¹Â¹Ä—gsia{OÅ³EÂ—TtÂ‰lÃ‰Â‚wr}jÂŸRÂ±E{L}j]HÄ…KÃƒT[P'],
                    'encodeOffsets': [[
                            111547,
                            18737
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '469036',
                'properties': {
                    'name': 'ç¼ä¸­é»Žæ—è‹—æ—è‡ªæ²»åŽ¿',
                    'cp': [
                        109.8413,
                        19.0736
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@bRFnHNbHÂŒgN@NPEnbXP@bND`NT\\@\\QZb@`@J]V@XhÂžDpWÂ„nÂCJGHGXO@CRÂ§FANHVKLF\\MPVR`CvVfQtDPKpGHG@S`WJP~^dSTHWX\\RHTFACQTIAUPOU@MG__IaYSFQKÂ‘NSbORHXCZeTFJgÂ„B`YBMNMFi~IVDV[tGJWXGDQRGF]ÂˆJrALgESLSAYDGIaFeXQLS\\MKSLSQYJY}eKO[EHiGSaK[Yw[bmdURgEK^_kcSGEOHKIAS]aFSU@Y]IWFUTYlkP_CUOUEkmYbSQK@EMWUuAU\\M@EpK^_ZMDQ^OXwC_ZODBrERURGVVZ\\DTXcFWNIAWJWAYUUFYEWLQQaCIZeDM`cLKRGpanJZQd'],
                    'encodeOffsets': [[
                            112153,
                            19488
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '469007',
                'properties': {
                    'name': 'ä¸œæ–¹å¸‚',
                    'cp': [
                        108.8498,
                        19.0414
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÂºÂŸxÂ‹JYZQÂ”IÂŠYXLl@dR\\WZEn]bA\\S~F`KXaDeTiNO^EEKWEDQXITBXaWaDQMUJOIaTWf@NJV@dSxGZÂ‰Fu_Â@WMKAUÂˆ}AQ@MwG_[GOAmMMg@GKÂP]IUcaFKG[JSCoLGMqGEOYIMSWMSBucIeYA_HUKGFBLOFGPQBcMOF_@KOÂ©UAtERadwZQ\\@ÃŠJÃ’gÃ²UÄªRlRÂ°KÄ®VÂŽLJ'],
                    'encodeOffsets': [[
                            111208,
                            19833
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4601',
                'properties': {
                    'name': 'æµ·å£å¸‚',
                    'cp': [
                        110.3893,
                        19.8516
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Å„ZÆ‚tÄ¢Â¬Ã¦ÃŸFuzÂ¹j_FiÂ†[AOVOFME_RBb]XCAKQKRSBQWSPY\\HbUFSWSPoIOcCOHIPkYCQ]GdGGIFQYgSOAQLK`MFUIGa@aQ\\GGUFcHKNMh@\\OYKAigsCgLSF]GOQO]@GM]HyKSHKPW@Pxi@EMINYREXWRQ@MQcFGWIAwXGRH\\yDI`KJIdOCGRNPNtd\\UTMbQYi@]JeYOWaL[EcICMUJqWGDNZEXGJWFEXNbZRELFV]XQbAZFrYVUBCLNFCHmJaMIDDHXHEhQNXZ_TARFHVB@DTQIRR@YHAJVnAbKFUEMLd\\c^ÃÃž'],
                    'encodeOffsets': [[
                            112711,
                            20572
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '469006',
                'properties': {
                    'name': 'ä¸‡å®å¸‚',
                    'cp': [
                        110.3137,
                        18.8388
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@^J@ZTVbET^JBGLFPTHld]`FLQhcVanx\\\\ZbLHTGj\\FLP~fIZRZPVTQFSVAFJE^NDLEE[~LjsxVTG\\NZZNGlLRRGLJTV@hPZANN^@T\\NEPPbDZXO`d^HSvcJDIV\\XZAJUFCLNP@PQÂ¤@[Ã¯KÂLÃ‘IÃ]Ã‡EÂ±I{uÂƒÂ­YÅ›UÄ‡FcYUmsVeBSVgB[RO@aYYPO^]@UVaNeDShMLG\\EfFVE\\F`'],
                    'encodeOffsets': [[
                            112657,
                            19182
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '469027',
                'properties': {
                    'name': 'æ¾„è¿ˆåŽ¿',
                    'cp': [
                        109.9937,
                        19.7314
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@T\\GJCXJH@fJDDPNCNJENN^NLHBNSx@DDYbBLLDRbjZTj@`XXTlG^Xr@PJLW\\WLTlWR@HDJTD@X_PO@STMDNTMVV@NLDM`M\\XM\\JNBH[PYZÂ‡ÃºYzÅ¸`ÄŠ\\ÃŽÃd]c[NKVFLEBaUmBIZGQ@JQSR@CUAEGBQ`SWYRMFgWGCGJCbNnIDGMEDKVAZUEqBYRa^WEUFKYQMaFWXEHIFWMYHCrXVIIiaK@aMCUYNSIISTwXALKH@XWXIEIJQCG[IEQDE_XSBaa[AIPW@]RS[FWS[CD]PEBYNGFSaSyJG]@ugEUDQlGHiBKHUIoNSKqHFaPMICK]UUHIPDJMuCA[SCPIDIOILGAEmU[POPBVSJDREBGS[QXWSGcT}]IO_X@TGHoHOLCX\\ELT@LYTDÂ‚aFENF\\lj'],
                    'encodeOffsets': [[
                            112385,
                            19987
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '469030',
                'properties': {
                    'name': 'ç™½æ²™é»Žæ—è‡ªæ²»åŽ¿',
                    'cp': [
                        109.3703,
                        19.211
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@D\\RV]dTXELnHr]^@LETBBRTHPi^[@U`QTHDJ`MGSogDIPKdJ`WVNHCXHl_DJR@AH`FBVPUJLHKNTJOFFZON[ZEHFCJlMJ_ÂŒCn`CJVNGPLTNDFIdVTWEIPmRKMc_kDMWGGUTAtJLK~\\f{pqD[LAVXRCH{HC`eÂŒJ`}@W^U@I@_Ya[R[@MSC_aMO@aWFmMOM@Â‹haGGMEmaQ[@MESHaIQJQÂ…Â…MckBIw[AOSKKAMPSDSLOAV_@@`KJRbKRDfMdHZERgAWVsDMTUHqOUr@VQXTT@TÂƒfgÂ‚L^NH\\Â@heTCZaESNObHPÂƒHeZF\\X^ElM^F^'],
                    'encodeOffsets': [[
                            111665,
                            19890
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '469002',
                'properties': {
                    'name': 'ç¼æµ·å¸‚',
                    'cp': [
                        110.4208,
                        19.224
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@TP\\pATHTGlZDJGAQjE\\Rb@jVBDCN`JZ[NCNHNXbULPrP\\KNbMTLjJJRFP`Â“pNLZz^FLRHjVPZ@hxVKbHBHMNNJFRlLzGPnNHhIrHHADcPWdUAmEMVQDSKYHY\\EhBN^HpXGNDBNNBnIÂÃŸÂ‹Ã…_g{Â³So]ÃƒÂ£@ORO@KMEDIVYB[WJUICudGTc]P_YWaCOOMFS[]@MMYBgOU@ISHKQQkKMHYY[MSHwUit}KF\\KFMCF]EIUBETSROUKTLT[NKTWREfJbCHBZKTFTKh'],
                    'encodeOffsets': [[
                            112763,
                            19595
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '469031',
                'properties': {
                    'name': 'æ˜Œæ±Ÿé»Žæ—è‡ªæ²»åŽ¿',
                    'cp': [
                        109.0407,
                        19.2137
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@`ZÄ¤dÂ–`Ã²Ã¼ÂˆÂ˜Â Â“BSPGP@VSbQ`Â‡@]HC~T^SE]N]FkW]E[fYÂ„GGOPaTMbFDYfS@g[ÂMGK]hÂÂ„e@SSSRW@UVqrPVGNStCXUhBFQGYNcCeLQQaLI@_`@EUwcEaCUaMc@SK]Du`ÂMSkKIÂ‡~BVNL@X`Â‚EvYÂŠwHcTU@MIe@SXJbIPNVCRXbWbSAWJCRXFFL]FMPSjCfWb_L}E[TaBm^YF[XcQk@WKÂ‰ZÂ“JYRIZwÂŒÂ¹Â '],
                    'encodeOffsets': [[
                            111208,
                            19833
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '469028',
                'properties': {
                    'name': 'ä¸´é«˜åŽ¿',
                    'cp': [
                        109.6957,
                        19.8063
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@jD`hNd\\^dZÃ¤dÄ’HÂ´Op@ÂˆÃ¹ZY\\OAGIMN[[W_NCNMKU@NUMSNCTSP@`O@WSCCI@GXQSkXKX[IK@OWqH]SkWW@_SiiYQaKCAKZaCCw@MTGAMKM]FMMIMDSM_HGHRPKCBGSJJIYH[QOJCHMBDGQJECMTDQKFGTCEGTF`NFEDMFaGSNwIiTGhYJD\\KZODC^@FTKND`XBHKJNKFBNhG^FJMPcHEZF\\QPRjQTAdgNOPgQaRSÃª'],
                    'encodeOffsets': [[
                            112122,
                            20431
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '469034',
                'properties': {
                    'name': 'é™µæ°´é»Žæ—è‡ªæ²»åŽ¿',
                    'cp': [
                        109.9924,
                        18.5415
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@R]NC`YL]FoN@V[vBXVFNL@TRZalnVFVP`DlOZkVSXEE_F[EUFeH[NKTgfCbMVU^@P]ZObZP@\\QhATUfAtUasÃ±ÂiÄEoI]eYÇ¯@aKmaeÂƒWuCÂºKÃœKpnbHbYfUDSNCPJTRAHJTDJSfDNLHXC``VBNGTYCQDIXMDSP@xLNEFRNXBIpVNLXah@RgF@`qOML@LJNSPLbaHAh@Jdj'],
                    'encodeOffsets': [[
                            112409,
                            19261
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '469026',
                'properties': {
                    'name': 'å±¯æ˜ŒåŽ¿',
                    'cp': [
                        110.0377,
                        19.362
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@\\OnVBFKHPJCJOJTDB\\vDINOCGJVVL^JDONEbrGTLpMVJLGjAHGRkVChF@vH^zIbTETMHAZOFC^\\DXT\\EffAP\\PdAV@UIYfS|S@YPICMeM@sC[_A]VQEwyHSMuNcAUlQJMVGMS@mVBZPFO\\CSÂFQK[LqDMACiUa@[QiFBRIHYCHkGSBS[oSOqBÂ‡IE^QHCRWHIXsHU\\UC}JEjMNAN_ZÂƒAIhSEYfWDQGaPMTLÂ’ERZTJb``NHV@'],
                    'encodeOffsets': [[
                            112513,
                            19852
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '469025',
                'properties': {
                    'name': 'å®šå®‰åŽ¿',
                    'cp': [
                        110.3384,
                        19.4698
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@JjDNdJ\\FbKPXfZ^Ij@RZNaVSc[MsMOHQPDJcLIJ_zCG[HQxWJBHXdENRR@XQFWZQQGOFSWUCI[WCJuRGLXNMPLhCl[Ta@SqGgJMGOmyHkKEQMINMAGaGULgwY@UOGiKQ]EYyMKÂ”oO_QEIIKiNSMa[LqOKOaVMWMGMDY\\_IKrL\\ERTÂ[DEPYOUA@nNTUHINkRBVMdNvGTxzRF^U`BD\\@tfNDNOJ@Z{TeTJZ@VUÂ€cB[OBOeeQT@^OXBJb\\AbWTF`RCJFH\\RDJIJFXW@WLGBKxWTSJJMTVZND@bbL'],
                    'encodeOffsets': [[
                            112903,
                            20139
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '469035',
                'properties': {
                    'name': 'ä¿äº­é»Žæ—è‹—æ—è‡ªæ²»åŽ¿',
                    'cp': [
                        109.6284,
                        18.6108
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@FJp@fxpQ\\ApN\\GNPNBM`HLMrXLXj\\PEHnI@WUCEM\\GTc\\GZYHTPBHRCPTdÂ€H\\K\\@HXiÂ–BJILJJAVNTOZJNtFPC`YxDPWci@IBgbGKaTOIM@KNKrP@_hE@QbgKWUMJoWAQMFEKM@wTONCJWRCZDHSAM_UD_GWMKeCITSCGIQBGXUHQoMEEGWDQIG]FMQBMaFGueFeSQDUSDSKOCSFMLÂƒUaPWM_PaEGFETMX]RCRR@HXKN@JNnXXEÂŒSPaDI\\Â£FkXWIAX]xB\\GN'],
                    'encodeOffsets': [[
                            112031,
                            19071
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '469001',
                'properties': {
                    'name': 'äº”æŒ‡å±±å¸‚',
                    'cp': [
                        109.5282,
                        18.8299
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@TCNOLBTLBPx\\AJdlÂ†NRÂ†RIbJTGNF\\@RcIYbmHoLQdKN_fCJYbDRRXKZFVEZVXBXIJBXMdESW[CUYHUVQFQAqsEIMPYMSBUIIJKAIjÂ•GW[@[LGScDOGQOAGSYZ[HSd[HFNVD@XmJFG[OWiWKNqGKN_MAMO[HoM[BoRewo@Y^HpITSFENc`MVCdHNIVCLJFI`NFIÂŒP`@VZbaf[FFJG`O\\WRFA@PVPFPPH'],
                    'encodeOffsets': [[
                            111973,
                            19401
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/hei_long_jiang_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '2311',
                'properties': {
                    'name': 'é»‘æ²³å¸‚',
                    'cp': [
                        127.1448,
                        49.2957
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VÂÃˆÃž@ÂŽkxÂ˜nXÂŽÂ°VÃˆaÂ°V@kÃ´wÂ„bÂ‚ÂšÂ„JVÂškXlVUxÂ„Â„@ÂŽlL@xkVVÂ°ÂƒÂ„VbÂxlVUnVxk@ÂƒÂ„ÂƒKkÂŽVbÂ„IlÂÂ„Â@Â°kVlÂ„@Â„Â™lÃ†nkll@@VÂÂ„VXÂƒÂŽÂš@VÂ„Â²bUlÂƒVlVÂ„UÂ„VÃ‡n@nkJÂšÂŽlkVbÂœ@Â›xÂ²V@nÂ°VUnlKUÂ„n`@nÂ°bWLnVUblVUVVbknV`Â°kkÂŽl@@VÂ°@nzÂ„J@XÂšxlWXbÂ°n@bÂƒÄ lbXbÂ™bVbÂƒJ@VÂšbÂ„a@Â„Â„@lbUbÂšVmnÂœ@lÂšVmnIWÂ‚Âœ@WbÃž@Â„n@xÂ°@ÂšÂ„Ä¢aÆÃ©ÏšnÂœÂ„Â‚lÄŒÂ¯Ä Å»ÃˆwmÂ@ÂÃ´Ã§UÂÂ™mmÂ£XyÂ°UVÂÂ™Â›@wÃˆÂ£ÇªÂ¯kÃµÃÃ§UÃ‘ÂšÂ™UÄ·Â‚ÂƒÄ¢kVÃ‘Â„ÂÃ†ÂÂšÂÃžUÂ°nÅŽÂ¥ÄŒUÄŠxÂ°mÂ°Â¦Å¼VÆÂÂœxÂ°ÂƒÃ‡Â£@yÂ„UÃ´nÃžÂƒÃ†@ÃˆÄ‰Â°KÃ´Â¦ÂšWÂ„kWUÂ—bÃ‡Â»@Â™ÃˆÄ•WÃ‡ÃˆÂ£Å¤U@Â›nÂ£Ã†UUKVamanwÃ…ÂƒmÂÃJÂ¯k@JÂƒIkaVaUUÃ‡bkaÃ†Ã‘kWmÂÃUÃ›Â™Â™Ã@Â™ÂƒwnUÂ±Âƒ@ÂkkVÂÂ¯KUkÂƒJÂƒÂ¼UÂ¦ÂƒÂšÃ…@Ã³wÄ·aÄ·Å¯VÂ¥UaÃ³@Ã…wmÂƒÂƒ_kVÂƒwÄ‰Â‚Ä‰Âmmn_VÂ»Â™a@UÂ™ÂƒVwÄ·Ã³ÂƒÂ‚UÂ¦ÂLÇ«Ã©Ã³XÃ‡mÅLÇ“Ã‡Ä·xÃkÂƒÂƒÄ‰Â™kÂmakbUÄ¶Â°@WÂ¼Â„Â@bÂƒÂšÃˆÃ†@Ä–Â™LÂ„l@Â„Â°JÂ¯Â„mÂklÂ¯LÃÂƒÂ±LÂ—amJ@Â¼ÂƒÂ„Â™VÆ§UÃ³Â„Â™UXÂ˜Ä‹bÂ¯Å„VbkÃ†ÃI@llxÂ„kÂ°VÂ²ÂšV@UxÃžÂŽÂ˜L@bÂÂ„@bÂ™`ÂƒÂšÃ‡zkÂÃ³kÃÂ¤@ÂÄŸÂÂ¯ÂWÂƒÂ™LÄ‰Ã‡Â™LmmÂnÄ‹VkbUaÂƒL@ÂŽÂ¯Â„Â‚bUÂ°ÄŸLÃÂ‚Ã@'],
                    'encodeOffsets': [[
                            127744,
                            50102
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2327',
                'properties': {
                    'name': 'å¤§å…´å®‰å²­åœ°åŒº',
                    'cp': [
                        124.1016,
                        52.2345
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÂkÂ›ÂƒÏ™mÆÃªÄ¡bÂ™ÂƒÂ¯@@wÂƒmÃ@XV@IlÂŽl@ÂbUxlÂÂ¯VlVÂ™bV@ULVlUVÂ™_kxÂ™VVVÂ™ÃˆÃJ@Â„Â¯ÂšUÂ„Â™lmÂÂ¯x@xÃ³Ã’Ä‰Â¼mÂ„Â¯WÂƒxÅ£@UzÂ¯ÂƒWwnÂUwÅ¥Âƒ@knÂÂƒWÂƒÂ£Ã³VÂƒUUwÄŸyÃ³Â¦WIÂ—VmmÂ™I@Â±kwÃ‡@@bÂƒ@Ä‰Â¼Ã³@Â¯wÃ³@Â¯aÃ³Â¼Â›KÃ…ÂÂƒaUwmWUwÃ…I@aÂƒKÃ³@UaÂ™LÂƒaÂƒVÃ…wÅÂ¼UUÃlÂ±IÂ—Â¤VxÃ‡x@zkJmnnÂ‚mbnzÂ™xlÂŽÂƒlÂ¯ÄŒkJlÂÂ™Â°@Â„kbÂ„ÂŽmx@xÂ™@kÃªmVnÂŽWxÃ´XÂšxUÂ°Â„bWLÃ³JÂnÃ‡WÄµÂ„VÂ¦Â™ÂŽÂƒUUbÂ™bÂ™Ã†Ä¡KÂ™ÂškÂÂ¯Â™VUÂ±aXmÄ‹Ã‘UwÄ‰KÄ¡Â„kÂ„Â™ÂŽVxkÂ„Ã‡KkbÂƒIÂƒÂ‚Ã›XWlÂ¯bÂƒÂŽÂ™XÂ¯KÂ™bÄŠÂšÂ„Â„ÃžVÃ†ÂšnÂŽÄ¸Â²lxUÂŽÂ°nÂ°Ã²ÃˆbÂ‚Â¦Â—xVbÂƒÂŽÂƒ@Â¯Â„Vx@ÂÂ¯VÄ·ÃžÄŒlÄŠÂÂ°KÄ¸ÂŽÈ˜IÂ°Â¤ÄŒIÃ´ÂŽÃ²Â»Æ¨nÈ°KÇ¬Â¦Ã´WÅŽÃˆÆ¨wlÂƒnKVXmbX`lbÂšwÂkVWÂ‚XXÂŽÂ„LÂ°aÂ„ÂÆ¾aÄŠÂ£nÂƒÂ°@Â°Â¥ÅŽzÃžÂ¥Â‚Â»ÂœalwÃ´kÆ’JÂ„a@ÂÄ¶KÂ„Â£Â„bUÂ°ÄŠxÅºVÃˆUÄ Â¥Æ¨Â™VI@ÂXUÂ°xÂ°LnÂ¥ÂšwÂ°UmwXmÃÂVÂ¥Ä¢ÂŽÂ°@nU@mÃ†Â£ÂšÂ¯lKÂœÂšÃœw@aÃ…UÂ‚Â¥UaÃIkmVÂÂ²ÂÂ‚nn@Ä¶Â»@UkÂ¥VKÃž@ÃžÃ›@ÂÂƒkVmÄ¢a@_ÂƒJÃ³ÂmÂƒÇ–Â¯Ã†wÂ—Ã³Ã‡a@alÂƒUwÂšwÄ¢Å™Âšk@wÃ†WXUWÂXÂƒWaÂ™m@_Æ’Â»Ã‡Ã©XaÄ¸wVa@ÂÃKkUWkXÂÂ‚kÂšKXxÂƒn@lÄŠV@ÂÂ¯ÂmÂ¯nÅ™Ã†wÂšÂ¥'],
                    'encodeOffsets': [[
                            130084,
                            52206
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2301',
                'properties': {
                    'name': 'å“ˆå°”æ»¨å¸‚',
                    'cp': [
                        127.9688,
                        45.368
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â°`Â„_ÂšJlUÂšÂŽ@Â„Â„@VÂ¦Â°JUÂÂšÂŽnLÃ´ÂlnÅ¤@@ÂšÃˆaUÃ’VbkblÂ¤ÂƒzkÂ°Ã‡VÃ›Ã´Â°IlVUVÃ´UÂ„xÃ†UÂ„ÂŽ@bÅºÄ€Â„Âº@Â¦Âšb@lÂ²ÂÂ‚UVlÂœ@Â°Ã’Ä xÂšnXxÃ†VÃ´Â¼Ãž@ÃœxÂ²KÃžÂlÂƒVÃ‘Â°UÈ°Ã´lwÃ´@Â²ÂƒÄ¸ÂÂ°Â„lanV@Â„ÂšVÅŽUll@bÃˆnÃœmÂ„wÄ¢@la@ÃÃžbÂ°UXbÂ˜lÅŽÂÂ²Ã†ÂškÂšVÂ‚I@ÂŽnJnÂÄ ÂŽÂ°knÂƒÃœbÄ¢wna@aÂ˜kÃžKÆ’Ä€Â„aÂ‚Â™ÂœÂ‚Â‚IVbUÂ¥ÂwÄ wkÃ´Â˜xnLÂƒÄ‹VÃ§kaUÂƒÂ±IUmÂnÄ¡WÂ„ÂÂ°WÃ´Ä‰ÂšalÂƒÃžÃ…ÄµÂ¯@ÂWÂ¹XÂÃaÂƒbÂ¯aÂ±XÂ¯ÂºÂLÂƒaVÂƒmÂkLÃ³ÂƒÂƒbkaÂƒVUKVkkKV_@aÃykkÂ±L@ÂƒÃ…U@yV_Â™aUÂ¥Ã³wÃ‡xÂ™@UkVÂƒn@lÂƒkÃ…lwÂšWVwUkÄ‰mkklW@ÂÂšaÂšbVwnWWÂƒÂ—wWLÂ™Â™@UÂšÂƒÂ™UÂÂƒÃ‡LÂšÃ‡mÂƒÂ„Â@wÂƒJÄ‰ÂÂƒLÂÂ¥@ÂƒÃ_@aÂ¯yÂ„UWwÂ¯ÂƒÂ¯UÄ¡xÂ¯aÃXVmÂaUÂ£Ã³Â±Â›Â¯nwÂƒaÂ¯Ã³Ã…VÂƒXmanÂ™Â„UÂƒÂ›lUXkWa@mkIÂ„ÂÂ›ÂÄŸaÂƒmÂ™IklÃ‡UÂ™Â„kÄŠÂƒÂÂƒzkKÂƒÂšÂ„lUÂ„ÅÄ¬lÂšÂ™Â„@ÂŽnXÂ°@llUxÅ¹Â²mKÄ‰VWwk@UbUK@bmVmIÂ—ÂÂƒVmwÂaWxXlWÄŒÂÂšmÂºÂšÃžÃ†bUxV@ÄµÅ„WÃ†Ä‰LkWUbÂƒaWzkbÄ‰`UÂ„Â±LklÅwUVÃÂ£Â™UW`Uwk@mkÂ¯VkaÃµVX@WbÂLÂ™K@XÆ§ÂºWzÂxÂƒK@lmX@bkVVÃ†kÂ¼Vbk@Vn'],
                    'encodeOffsets': [[
                            128712,
                            46604
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2302',
                'properties': {
                    'name': 'é½é½å“ˆå°”å¸‚',
                    'cp': [
                        124.541,
                        47.5818
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ãž@ÃžÂÄ KVÂ¯ÂaÂ°Âƒ@ÂÂ„KVblaÄŒUÂ‚mnnÂšKÄŠÃˆÂšKXÂ„Â°ÂŽÄ Â@ÂÃžÂ£Ã´llÂÃˆyÂ„Â™Âš_@aÂ‚Âƒ@aÂ—KÃÂVwU@Â±Â™Â¯UÂƒlkw@kÃžJlÃ…UaÂ°ÅƒÄŒaWÂ—ÂšVÃ´ÂƒÆ¨VÂšUÂ„Âƒ@Â»nIÂ˜bÂ²KÃžÂ„Â°KlknÂÂ°ÂƒÂ¯I@ÂƒÂƒkÂšK@Ä•Ã‡Ã…Â„Â™@aÂƒÂXÂ»Â¯@VÄµlaÂÃ¿VamI@aÃ…Ãà¤‰Ã½ÂƒÄŠÈ—JÂƒÃ´ÈÃ…kmÆ‘Ã›Âƒ@kxÄ¡@@lÂ™aVkÂ¯Â»ÂƒÄ«Å¹aÂƒkÂƒÂ¥Ã…Â¯Â™JUaWÂU@@wÂ™aÂƒÂ»Â„KUkÃ†kUmÂ„UmwÃ›Â±Â±UUbUÂŽUXÂƒwWÂÂwÃ†ÃkÂ™lkUanaWwnKlÂ™kalÂ¯kaÂ™ÂÆ½aÂ›kÃ…xÂ™aÂ¯@Â™ambÂ¯VÂ™lÃ‡wÃ›Ä€Â™V@xÂ™ÂšmÃªVÃ†ÂœVVÂÂ‚aÃ´VÂ„wÃˆx@ÂšËŒxÂ„Â¦VÃžÂ¯VÂšlmX@Â‚ÂƒL@Â¯UaÂ¯LmV@Â„Â„Â°XÂ„Ä‹KÂ™VÂ™ÂÂƒ@UÂƒÃˆ@Â‚Â¥@wÂ—ÂƒÄ¡IUÂÂ™kmÂ¥Å¹wÂƒÂ¦Â¯lmn@Â°kxVV@Â¦Ã³amÂ„nÂ¦l@nxÂ™lÄ‰VÃ³ÂšmxÂ™nÂ™Ã’Ä‰Ä€ÄŠÂ¼Â„Ã¾Â„ÂšÇ”ÃªÃžÂ°ËŒÄ ÃžÃ’Â°Ä€É²Ä€Æ¨ÅºË¤È¤Æ¨ÄŠÂ°w@Â£nymwnkUUVÂ¥Ã´Ã‘VmkÂÃ†mUUVaÂ™mVIkmÃ´Â„lxkXÃžÃ¾ÂƒblÂ„Âƒl@ÂkVÂ„Æ†ÂƒVÂ„xV@ÂšÂ¼VÃ’@ÂÂšÂŽUÂŽÂšnnÃžÂ‚J'],
                    'encodeOffsets': [[
                            127744,
                            50102
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2310',
                'properties': {
                    'name': 'ç‰¡ä¸¹æ±Ÿå¸‚',
                    'cp': [
                        129.7815,
                        44.7089
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@U`lLUlVLÂ„UlbÂ„aÃ´Â„lKnÂŽUÂ„Â„bÂ‚KÂ°Â¹Â²WÂ°bÂ„aÃžbÂ˜knyUÂlUkamÅ™Â²L@mÂ°@lÂÂšmÂšÂ²n`Ã´Ã…lKÂ„xÂ„ÂÃœKnxV@Â„Âl@ÂœÂƒÂ›Ã…XyW_k@Â™wmÂ™Å¹Ä•mÂƒXÂÂ™Â»Â‚ÂƒÃ›Â™lÂÂ°ÂƒÃ´ÂšÃˆÂÂ„Â»ÂšÂ—Ã´Â˜Ã´_WW@UÂœalÂ»ÂšwU@@wÂšUVÂƒÂš@VÂƒXI@wÂ‚ÂÄ¢Í‘ÃžÈ»Â›aU_@mUkly@ÂÂ¯Ã³VÂ»XmWUXUWmnÂmÂ¥nUUaWLkÂ»Ã†ÂÂ²IÃ‡aÂ™wÃ…aÃÂ°Â¯nUaÂ±aÂ™ÂƒÂ™@ÂÂ¦ÃµÃ†ÄŸÂ„@Â„Â™@Ã…bÂ›xUÃœÂnÃ‡Å‚lbÂ¯Â¦Â„Ã´Ã³Â»mÂƒÂ—@Â±ÂƒUÂk@WwÂƒaÂ¯xUÂ„VÂ°ÂƒxXbÃ‡ÂŽÃ…ÂUVÂ™Â™ÂƒK@Â¹ÂƒKUaÈ¯@ÅÃÂ™XÂƒaÂlÂ™ÂƒlÃ›kalÃ‡UÂÇ«Ã‡Ã…Â„Ã‡akbÃÆ†Â¯nlÂšÂ¯ÂŽ@Â¼Â™VUx@xÂ¯ÂWÂ¼Â™Ã†Â¯ÂšmÄ–Â„Ä¬Â¯ÄŒÂƒVkÂ‚Ä·Ã…mxÂœÂ°Ã´Â²VÂ¤Â‚bUnÃžWÂ°bÄ¢wÂ°VÂ°Â„XxÂƒVÂ°z@bÃž`@Â„Â‚Â¦Â„KÄŠÂŽÂ„I@xÂƒÂŽnÂ„Â™ÃˆÃˆKÂ‚Â„ÂšVÂ™Â„@VÂšÂšXKÂ˜xXÂ„mXUxÂ™aÂ™b@Â‚kXllÄŠnVlUxÂ™XkxlÃ†kÂ„m@UÂ„VlÂš@ÃˆwÃ´xVÂ¦ÂšbU`@zÃ†V@Â„Â²KllÃžz@b'],
                    'encodeOffsets': [[
                            132672,
                            46936
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2312',
                'properties': {
                    'name': 'ç»¥åŒ–å¸‚',
                    'cp': [
                        126.7163,
                        46.8018
                    ],
                    'childNum': 10
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@à¤ŠÃ¾Ã†Ãž@bnJUbÂ‚Ä€nblÂŽÄŠÂšÂ„Â„ÃžlÄ¸wÇ”ÃˆÅŽKÃˆnÃ´WÇ¬ÃªÂ‚KVÂ¥Â„ÂÄ¸Ã´UxÂšÂ„@VÂšbUÂ¼m`nnÄŠÂŽÄŠÂÂ„xlUÂšmkaVÃ¿ÂšLÂšwÂš@Â°Â»UÂmbÂKmÃÂ™UÂšwUmVknKUUlÂ¯ÂƒKUÂ™ÂƒUÃˆÂƒÂ‚Â™nK@ÂÄ kXÂ±lXÂ„Â°Â„L@ÂÂ¯Â¥@wV_mÂ›ÄµÂ¯WwÂ™LÂ¯ÂƒUkÅÂƒÃ‡VÂUÂ™lÂ›wÂ—VÃ³ÂÂ±ÂƒÂ¯aÂƒVkaÂ°wVkÂ°mÃžÂ¯Å¦Å™Ã†Â™lÂ™Â²Â™ÅŽkÂ™U@ÂƒmUkbÂ¯ÂƒÄ·ÂŽÂ±Â„Ã³@kxÈ¯Ã³Â¯VUÃ’kÂ„ÃÂŽÂ±LÃ›wÃ@Ã³Â»Ã…UWwÂ™mÄŸwÂ¯Ã‘Â›@UkÂVÂ±Â@kÂ™a@Â¥ÂƒÂ¹Å¹Ã¿@aÂƒÂÃ…VÂƒwÃ³VVUkUÂ¯JÃœÃ³ÃˆUlÂ¯Â„ykÂ£laUaVÃ‘Ã‡b@Â™Å£@kmÃ³ÂmKÂ™ÂVÂÂ¯IUÂ¥Âƒ@@ÂƒÂ™ÂkVÂ™IÂƒ`@Ã´Â™Â¼Â„blUÂ„lÂƒÂÂ™bÃˆb@xÃ‡KkÄ¢É³aÃ…É†Å@ÂƒÂŽÂVÂƒK@zÂ™@@Â¥Ã†KnÂÃœ@@aÃ›ÂUwÂ›wÂnUÂ‚Ä·@Âƒ_ÂƒVÂ°ÂŽ@Â„klVÂšÂšnULVVÃžbVl@Â°Â™@nxÂ™nÂ°LÃ…ÂšÃ†lVÂ„ÃˆÂƒmUÂ²@VmÄ LÂƒxÂ„nÂ¯xkWÂƒzÂšJÂ‚wnLmbXbWÂ°ÂÂšÃ†Â‚Â™Â²Â™@Â™ÂŽÂšx@ÂÂJVxÂ„LÂ‚Ä€Â²Ã†Â°IÂ¯ÂºÂ‚Ãˆ@Ã’nÃˆ'],
                    'encodeOffsets': [[
                            128352,
                            48421
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2307',
                'properties': {
                    'name': 'ä¼Šæ˜¥å¸‚',
                    'cp': [
                        129.1992,
                        47.9608
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÂƒKÂƒÂ¯kWWÂ²ÄŸl@ÂŽmLÂÂšÃ‡Â„Â„VVÂšÂ„LkÂ°VVmLUlVnÂ™xÂšVnÃžÂ‚LnaVÂŽÂ¯Â¼Â™@Â™xÂ™KUÄ€lbÂ™nÂ„`nÂ„Ã†xÃ´@VbUÂ¦Ä¸Å°Ä¸bÃ´xÃ†@Â„Â™VÂ¥Â„Â»Â„IVlÂ°LUÂŽll@ÂÂ²Â„mVÂ„x@ÂšÂšÃžÃœÂšÃžVnÂŽlXÃ…Ã’lbÃˆaVVUblbÂ„J@IÂ°lÃžInÂ‚Ã†Â„mxnbUbVLÃ…VmÂ¤@ÂœÅ£VÃ‡Â¤XÃˆÃ‡Ä–@ÂšÃˆÂ¼Â˜aXVÃœaXbWÂŽnzÅŽaÂšÅ™Â„KÃ´bÂšUlw@Â¯naÃ†KnUUÂ¯Ãœa@mkkVUÄŠmÂ„Â™Å¼ÃÂ‚ÂÇ–ÂŽÂ‚KÂ„Â™Â°LÂ²lÃ†I@ÂƒÂ¯Â¥Ä‰Æ›VaÃžk@ÃVaÄ lnUVwÂƒÂÂœÃ³maÂƒ@Â™wÄ‰@Â™aÂ™VÂƒxÂamX@aÂƒ@UaÃ…LÂƒaVWÂƒ_nWmÂ£nWm_Ã…VÂ¯Âƒm@mÂ„Ã³Â¤ÂÂšÃÂ¦ÂƒÂ¯Ã…almXÂ£ÂƒÂÂ™ÂVWUÃ…ÂšwÂ™mÃ‡@@IVÂ™Â„WUw@aÂšI@ÂÂ„k@wÅŽÂ»WÂƒÂ„ÂƒÂ™Ã…VaÂœKÂ›Ika@Â¥lUkUlwÃ…wVyÃˆwWU@aÂ¯UÂ°mÂ—ÂÃ‡@UÃ§ÂƒaVaÂ¯mVÂ»Ã…wÃUlÂƒUkÂ™V@kÂ„mUkÂ‚ÂXÂ£ÂšwÂ°@@Ã‡ÂƒaÃIÂÂƒÂƒamÂ™Ã›amÂ„Â¯lÄŸÂmÂmI@ÂÂJÂ™UÂ™lÂ±Ã…ÅÂŽÂ—kWaÂ¯VÃa@ÃžkbÄ¡@ÂƒxÃ›nÃ‡m@akkÅVÅlÂ±ÂškÂšÃ…ÂšÅ¥ÅšÃÂ°Â¯nUlÂ¯xlbÂ„UÂ°bÂ²Â„Ã´Â‚Â˜UÂœxÂškÂ‚VÃˆUÅŽÂ„VlÂ°Â„ÂšKXxÄ¶Â°nÂœU`@xÂ°Â¦@Â'],
                    'encodeOffsets': [[
                            131637,
                            48556
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2308',
                'properties': {
                    'name': 'ä½³æœ¨æ–¯å¸‚',
                    'cp': [
                        133.0005,
                        47.5763
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nÂšÂ„bÂ‚Â„ÃžJÂ„b@ÃˆÂ¯@Â™xWÂ¤ÂÂVlÂƒn@lÂšUVlkÂ„ÃžVÃ†xUÂ¼Â°nUbÂ„bVÃ¨Ãˆ@Â˜ÂŽnInÂÂ‚@ÂšÂÄ¢mlÂUwÂ°Â™Å¼ÂƒÂ‚VUn@lnL@VÃ´bÂšwÄŠÂ‚lÂœÂ„JÄ·Ä¸Ä¢lÂ„wÃ´wÆ¨xVÂVUÂƒÂÅ¦ÂÂšxÂšLÅºÂ™ÃˆÂšÂ°`nnÄ wÅŽJÃžÂÄ¶wÃ´JÂ„Â@Â¤XnÃœÂ„Ä¸lÂšnÂ°Â¼ÃˆÂ°lÂŽÂ„Â„UÂšÂ‚bÂ„xÂš@Â„l@ÃžÃžÃˆmÂ°Â„lÃ´wÂšLÂ°Â¼Ä¸Â‚Â°ÃžÂ²nÄ @Ã´wÃž`Å¤IÂ„VÂ„Ã’Ä UÂ„Â„@Â„VJÄ¸bÃ†Â„Â²@Â°ÂŽÄŠKÂšÂœÂ„JÄ¶aÄ¢ÂÈ°@Ã´Â¥Â°nÂšÂ¤Â‚bÄŒUÂš@VxÂ„mUw@aÃÂÅ£ÂƒÃ‡Â™Ä·Âƒ@Ä•Ä·Ä«UÂ¯Â²Â@ÂÃ†mVÃ‘Ã´Â¯XÂ¥Ä‹Ã§@Â™Ä‰Â»UÂ¥ÃÂÅ£KWVÃ…kUVÃÅŽUmÃ‡ÂÃxÂ¯aÄ·xÃ›UÃ³LÂ¯aÂ±Ã³ÅbÂ¯Â™ÂƒÃ‘Ã…ÂƒVÃ¿Âƒ_Ã…Ä·Â„a@UÂƒK@wm@Van@UmmLVaÂ—@VImmXUWÂƒÃUÃ…Â™ÂƒKUwÃUUÂƒkVÂƒk@lÂ¯XÂ›Â‚Ã…_ÂƒJÂ¯kÂ™JmÂ„Ã…LÂƒa@Â¥U@Â¯VÂƒzÂ¯@Âƒ`@Â¼ÂšÂmxÆ¥ÂšÅKÃ›k@Â±laÃ›@@Xm@Â™Âƒ@xÆ½@WÅŽnÂšË£Ä•Ã…@@aÃ…@@nÃbÃ‡ÂÂ¯@Âƒ_UÂ›kUWÂƒkbÂ™wÃU@Ã§Â„Wlw@anIÂƒÂ¯lyÂœXÂ°mÂ°VÂšaÂšÃ›Âšm@ÂÂ„mVwÃžKÂ°ÂƒÂšXlaXmm_Âƒ@UÂƒkwÃK@ÂƒVIÂ™ÂƒXmVÂ»ÂƒI@aÂƒÂ¯ÄŸWÂ™bÄ¡aU_Â¯JUÂ¯Ä¡ÂŽÂƒÂ„Ä‰Â„kÂ„Å`Â±nÃÃ†kÂ„Â™bÃ³ÄŠÂ¯XÂƒÂ‚Ä¢XÂ‚mVnÂ²JVÂ„lbUÃ¨Â„ÄŒmKÂ—wlÃ³ÄŸxÂ‚xVÂ¦UaÂJÂ›ÂÂÂšÂƒbÆ‘Ã¿ÃLÂ—l@bmbÄ¡x'],
                    'encodeOffsets': [[
                            132615,
                            47740
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2303',
                'properties': {
                    'name': 'é¸¡è¥¿å¸‚',
                    'cp': [
                        132.7917,
                        45.7361
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â‚LÂšKVVnkÂšbVÂšÃˆbÂ‚ÂÂ²UÂ°VnklVlaÃˆL@anUÂ°ÃœmXV`ÂœnÃ´LÂƒÃ¨ÂšxlÂŽÂšLXÂ„Â˜LÂ²aÂšVVmÃˆX@Ä·Â˜lnUÂ„Ãˆl`ÃˆÂ¹Âš@Å¤ÂŽÂ°U@xÂ„KnnVÂ„mlnnUlÂ‚lVnnaÅŽwlVÃžÃ’Â„@nÂ¦ÂšLVÂŽÂ°lÂšwVkÂ„LÂšaÃžÂŽlÂ„nÃ’Â„Âš@xmLÃžÂ¤WnÂœÂ¼Â‚WÃˆLVVUxlÃˆÃ´Â„Â„WVaU_VKÂšKXUÃ†bnÂ™Â‚nÃ´KÂ„bÃžwÂ°bÃ†WXamÂVwÂœKÂ˜Â™UwÂ¯WUkÂ„UlJUwVÂUaÂ™@@kmyÂzmÂ›Ä‰w@kVwÂšÂkÂÂƒÂWÂ¯Ã…KU_VmÂƒÂƒÂ™xÂU@aW@@ÂkK@wÂ„a@KÂƒ@@kVUÂƒakyÂ°_VmÂ™knaÂ¯K@Â™ÂƒLÂ™wÄ¡Âk@@IÃ‡Ã³XÂ™ÂƒwVakmV@mwXUWanÂƒlÄ‰Â@Ã‡Â™UwÂ™KÂƒÂƒÃ³ÂšÜ›ÇŠÃ›Â„mÂ°Â@Â›wÂ—Ã…@ÂƒÂ±bÂ¯WÂƒÂ¹Â„WVwÅ¹Ä•Â¯kVmÅbÂ¯w@aÂƒwmVÂ™UUbÂ™VÂ™IkaVwÄ·ÂÂ™xkÂ¼Â›b@VXXÃ³`Ã³Â—Â™Â˜ÂƒÂ¼Ã‡ÂÃ³Â™Â¯Â„kÂŽÃœÂšÂÂ„ÂšÂ¼WÂŽnÂ„ÅºÄ–nÂšÂšxl@X`WzÂœÃ†'],
                    'encodeOffsets': [[
                            133921,
                            46716
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2305',
                'properties': {
                    'name': 'åŒé¸­å±±å¸‚',
                    'cp': [
                        133.5938,
                        46.7523
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â™UÂƒÂƒUwÃ³Â™mÃ‘ÃžÃ‘UÃÃUkmmÃ…ÂƒyVÂÂ¯Ä«Â„Â¥ÂƒÂUÃ¿Ä‰Â¯mÃ‡kaWbÃ…XÂ¯aÃxÂƒaÃ³LÂmmÂšÃ…aWVÂ™LULV`UbÂƒXÃ³ÂƒkÃ‡VwUUÃ‡KÂXÂ›Â»XmÃÂ£nK@wÂƒÂ™mÃ‘kÂƒÃÂÂ™bÂƒKUlÂ™xÂ¯kUÂÂ™KmÂ¥Âƒ@ÃÃ‘kUÅxmbUmÂkVkmmnkUÂƒmmÂƒL@wÂ¯VÅ£ÂÂ™@Ã‡Âºk_ÂƒÃ‡mVÂ—k@Ä¸VxÂ‚VÃˆÂ°lLkllÂšUbÅwÂƒnÂVWÂ¼nlUxÂ¯XmWUnÃ@Â™xÃUÃ³Â¼Â¯J@LVbkJWnkbÂ™WÂ¯Â„ÃLUxÂƒn@Â‚Â™nÂ™ÃœÂ™bÂ¯UÂ¯nÂ›WkzÂ„Â°mJ@bkxÂƒX@Ã¨ÃžVÂšxlaXÂ„lVVÂœÂ„`Â°@ÃˆÂÃža@mÃ†@@bÃ†@Ë¤Ä–mÂ™XÅÆ¾@@wÂšÂ„n@@WÃœ@kb@Â²ÃœlÅLÆ¦Â™nwÂ™Â@Â»Â„_Â°@Â„yÂ°UV@@Â¦Â„bÃ†KnÂƒÂšIÂ°lÂ„IÃ†`ÂœÂÂ°W@kÂ„llUVÂ„ÃžVVxÂ„LÃ†ÂšÃžVXÂ„WVnnUJÂ˜@UbnKVnm@Ubn@@xÂ„L@VÂƒbÃ†Ä¸Â„`UÄ€Ã†Â„Â„Ã’Â°ÂšÅŽaÂ²Ã´Â°bÃ´KÃœVÄ¸wÂ°bÃžwÃˆÂŽVnÃžÅVUÃ†lXU'],
                    'encodeOffsets': [[
                            137577,
                            48578
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2306',
                'properties': {
                    'name': 'å¤§åº†å¸‚',
                    'cp': [
                        124.7717,
                        46.4282
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@mÃ‡@Ã‘ÂÃ‡Â°Â¹Â¯JÂ±Ã…ÂÃ¿ÂƒKUwÂ‚I@ÂÂ™wÂšÂÂš@ÂšÂ±Ã…ÂÂ‚Â™XÂ¯WanamKÂxÂ™IÂ„ylXÂ°wÂƒmÂ„wÄŸKUnÂ±@nVÃ‡Â„UÂƒÃ…kÃ†Â™Â¯KÂšmmwÂš@@Â¯UkÃaUUVKÂ™mUÂ™lk@ÂƒÂ¯ÂÂ„UÂ„`Ä¸@VÂÂ‚mÂœxVxÃœÂ@bÃ›@mÂ‚Ã…L@Â¦Âš@@yÂ„LÂ‚UÂ„ÂÅŽ@Ã†É…É´blÄ¡ÃˆL@wÃ‡aÂšaÂ„ÂÂƒkkVÂƒaÂšÂ»@Ã³Â¯_ÃJÂ™wÃ‡aÃ…XnyÂ›UÂ¯Â¥Ã…Â„@wÂ™bÃaÂ™LmmÂ@@ÂÂƒVUÂŽlbÄŸVmÂšÂ™Â¯XÂƒm_Âƒ`Â¯_UxÂ™mÂ™LÂ™aÂ¯b@mÂƒaÃ³Â¦Ã‡kÂ™Â¤VÂ„@bÃ³JknVxÂ™VXxÂ±aÂƒLUbVxkLVlÂLWlÂƒ@nX@VÃ…bWlÃˆnÂƒxÂ„bWÂšÃ…bmÂŽ@xÂœbmlÂ°bÂ™Â„XbWÂ„XVmnn`ÂƒLmÂšnbmb@Âšk@mwU@@ÂšÂ¯JlbkÂ°lbkÂšmLXxmbVbkllÂšÃ…ÃžÂ‚xXÂÂ„xVWVÂVaÂ²VÃœÂ²nxÂƒVVnÃ…lVlÂƒLÂ„Â¼Âšb@xV@XÂŽVbÂšIÃ†Â°Â„Â¦Â„lÅºbÂ„Ä¬Â°Â¼UlÂšb@kÄ¢@lwÂ„@Æ’ÃœlnÈ‚Ã†Â„Ã³È˜IÂ„Ä‰'],
                    'encodeOffsets': [[
                            128352,
                            48421
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2304',
                'properties': {
                    'name': 'é¹¤å²—å¸‚',
                    'cp': [
                        130.4407,
                        47.7081
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÃžÂ¥Â‚Â™Ã´Â£nÂƒn@Â°Â„Ã†Un`mXnÂ¤mXÂ„`UXÂ„bÃ†KVbÂ„@@bnWÂ‚bÂ„wÂšUÂšbÄŠ@ÂšxÂ„@nbÂšWVÂmÂƒÂ_mm@ÂÃ³Â»UmÂ„Ã…Â˜WXkÄ Â»Â²Â¯Â‚Â¯nÄ·ÂšwÅŽ@ÄŠÂšÅŽKÂ°bÄ¸UnÃ‘Â˜KÄŒÂ¦Ä ÂÃˆbÃ†knJÂšÂšÃ†UÄ¢VÂ°IÂšÂŽÂšVÆ¾ÂÂƒwÂaVÂ™ÂƒÂƒkÂÃ‡Â¯Â¯Â»Â™mÄ·kÃ›ÂƒWm@Â£ÂƒÂÃ³IÄµxÃÂÅIÄŸxmmÂ¯_Ã‡Â™Å¹ÂšÂ™KÂ™wÅ¥ÂŽÂ„ÂUVUÂŽÆ§wÃ³xÂƒxÄ¡kÄ¸Ä·ÂƒIkÂ›Ä‰ÂÂ™xÃ³a@UmK@kVmÂUÅ»Â„Â¯ÂšVxkÂŽÄ¡nÂ™Â‚Â@mÂmJÂ¯nÂ°V@bXVÃ‡xUzÃ†xkxlVkV@Â¦lbÂœJÂ›LUbÂšÃ†ÂƒÂ„XÂ„ÅÂ¼@xÂƒl@ÂÂ™J@bVxÂƒXUÂš@JÃˆ@ÂšnÂ™xVÃ†UXÂšÂ‚Â„ÂWÂ¤knÃ†bÂ„Â°'],
                    'encodeOffsets': [[
                            132998,
                            49478
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2309',
                'properties': {
                    'name': 'ä¸ƒå°æ²³å¸‚',
                    'cp': [
                        131.2756,
                        45.9558
                    ],
                    'childNum': 2
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â²mÅŽ_lÂƒÄŠÂƒÂ„ÂƒÄ¢ÂVÂ°Â°IV`Ä¢bÂšaÄ XÂ„Â°@bÂ„JUÂ¼WnÂšÂ„UJ@Â„ÃžLlxVÂ„Â„@n`lIUa@KÂ°IÃ´Â»ÃžVÂšwÃž@VmnXÂ°WVwmkXÂ»Â‚UÂ„mÅŽxVakÂ™lkkKÃ‡Â¯ÂUUwÃ‡WUnÂ™UÂ±bÂ—KWÂƒÂ™KkÂÂ™wÂ„Ã§Ã³KÂ›mU_nWÂ¯Ã›mV@bÃ‡KkbkUmlÂ¯UÂ±VÂÂÃ‡aUÂ™Â™amlUUÂ™LÂKÂ›Â„k@ÂƒÂU@mwÃ›LÂƒÂŽÂƒwkLÃ³Ã†m_Â™Â±Â™nkÂŽÂ¯@@nÂ±KnÅšlbkVVÂ‚mzÂ—lWÂXÂº@ÂÄ¶Â°'],
                    'encodeOffsets': [[
                            133369,
                            47228
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/he_bei_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '1308',
                'properties': {
                    'name': 'æ‰¿å¾·å¸‚',
                    'cp': [
                        117.5757,
                        41.4075
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lLnlmxnÂ„Â„IVVlUnb@VVxXJWL@LÃžÂŽVnnVÂ„JÂ˜_@wkmÂšKÂ„bÂ‚xÂ„wXkÂ˜WXXÂšKlbÂ²K@nVVVbÂ„L@WlUÂ²Â„lKVnUJVz@VVb@lÃ…Â¼mVUVnbÃ´aVX@Â°Ub@lWbXÂš@b@bVbÂ°xÂ„@VxÃˆLVlÂšaÃ†@ÃžbÂ²kÂ°@lVUÂŽ@Xn@VWÂ‚LXb@Â¤VXÂšKVVVLnmÂ°_Æ¨Â¤@aUIVaÂ„alkXÂ›Â°kÂ„Â™V@Â„alwUÂVyÂ„U@kÃ³Â™Â°ÂƒnaÂ°UVUUmUÂÃ†w@mkLVUÂƒWVIÂ„WÂšLnn@xlVnKÂ„ÂmyU@ÂƒUÂ°UXaV@UÂ¥ÂƒU@UÃ†Â™@aVUkWUÂ¯ÂƒaU@WLUV@bkbmKULmKkUVUkmVIUwlWVÂÂ²Â™UmlÂÂ°U@WÂ„LUwVm@UUK@_ÂƒKUUÃœaXw@ÂƒVKUU@mVIUUlmnIVVVbÃˆVlKnbVKÂš@nIÂ˜@nVnwVLVKÂ„KÂ„Â„Â˜Vnb@aUIVW@InÂ™Â°@lVnIÂš@lWÄ¢@Â°UVL@bÂ„@VyUUÂƒa@wÂ@WUnU@WÃ‡Â¯Â™K@ÂUkkJWaÃ›bmk@mVaÃžU@amkÂWÂƒ@mXUKkÃ¿ÂƒÂ£@aÂ„kl@UmÂ°UXwlaÂ„al@nmlXnWÂ°znW@aÂƒwVÂÂ™@ÂƒakbÄ‰Â¥VmU@ÂƒIÂƒVÂƒUÂƒJÂkUmWUÂ™KÂbmkUaÂƒKkUVU@KV@@klwÂ—Â™WaU@kmÂƒXVÃ¨nbmlUUÂƒKÂƒXÂ¯JkbÂƒI@JmIUWU@ÂƒLml@XkJ@UÂ™kÂƒK@aVKÂwWaÂ—IWwÂƒmÂUÂƒ@mU@JÂ@UaÄ‹UÂ™aUUÂƒVkIÂ±Âƒk@UUÂƒ@UbVVm@UVÂKÂƒLÂƒlkIWaULUWÂƒXUJUÂ„Âƒ@WbUb@lkXUxm@@JVn@J@bÂ„nÂƒb@Vkx@bÂšLUÂ‚Ã†nÂ„JÂšaVXnKVVmzXÂ‚Â°V@_lJXxWXÂƒKÂ¯bÃ…amUÂƒ@ÂlUIÂ›bÃ±J@LÃ‡KkIÃ‡`kxWL@Â„Âƒ@@bUVUbÂ¯xWKkÂ„Ã…Â„VlULW@ÂƒÂŽnÂ¦Ul@IÂ™lmUUUVm@ÂkWÂƒnkKmaÂ¯XUKWmnwVwÃLÂÂ„mÂŽÂ™VUbUVWb@LnxmÂ„ÂxVÂŽmbXxÂ›Â¦@Â„nb@`Â™Â„ÂƒVÂƒ@kbÂƒLUÂ„mVUlkbVXkÂºmnm@@xkÂ¦ÂšbÄ¢ÃœlÂš'],
                    'encodeOffsets': [[
                            118868,
                            42784
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1307',
                'properties': {
                    'name': 'å¼ å®¶å£å¸‚',
                    'cp': [
                        115.1477,
                        40.8527
                    ],
                    'childNum': 15
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@kÂ™Ä¡Ã›Â™alÂ¥@wn@nmlÂ¹UWlaVknUVÂƒÂ„KlaÂ„@Â„UÂšÂƒ@_ma@ÂƒÂœÂ¥WwnaUÂÂ‚wnÂƒmw@KXaVUVaÂšUnÂmWUkÂ°Â™lÂƒnUVUXWVwÂ™IWVÃ³KUI@WÂXÂƒxUU@mma@kUKWLkw@yk@ÂƒaVkUUÄ‹aUU@Wk@Unm@UVmLÂmÂ±IUÂƒkJÂ™kWÂƒ@aÂ„I@m@UÂ„ÂƒVÂƒÂ„UlaÂ„@VXVÂƒXmVwnkWKÂƒKU_k@mÂ¥ÂƒmX_Â™JmnU@km@U@KmUÂ™VÂƒU@UÂ™@Umk@@LÂƒmW@Ã›Â£WÂƒka@wkÂ™@aÂƒI@mmk@mUa@UmUÂÂÂƒIÂƒwÂW@aWUÂƒbU@kbÃ‡@kwÂƒ@makVUkÂ™U@aÂƒm@aU@mxkUÂƒbÂƒKUXUÂƒÂ±KXVWLUK@wkU@VÂ™@WXUaÂ@WbUxÂƒJÂIÂƒÂŽ@Â¦VÃ¨VVX@Â±ÃªÂ¯KUIÂƒ`Â¯UULVx@VÂƒ@UKÂƒIÂƒVkLmVkKmÂš@nUJÃbkIUJVXÂšVVxVbUÂ„VJÂ„UnÂ™Â°bVÂ„mlUÂ°Â„XnK@Ul@lVÃˆVUXÂšx@WÂ„@VXÂšVÂ‚KÃžbÂ„n@VnbVÂ„m`ÂƒUÂxÂ™kW@UVkLÂ™KmÂ¼@lUnUJVnVÂ„XV@Vm@@LVÂ„klÂƒIkl@VÂƒÂWlÂÂŽULWKUL@ÂmJÂÂ„@blbUVUlmzUJUxm@UÂUbÄ‹Ãœk@Ub@VÂšLVVÂ„Â¦Ã´bVÂŽmÂšUKUkU@mÂ„ÂÂ„@VlVnÂ¼WbUJÂ¯@@Â„Â°ÂšnIllÃˆlÂ˜@nXÂšWlLÂœkÂ‚J@bkxlxkxlXUlkÂlJÂƒÂšXL@bWÂ„n`@nÃ†ÂŽXxlL@xl@XbÂ‚LÂœKlVlIXblVUbUJWÂ@lX@VL@VVÂŽÂšXÂšJÂšwÂ„n@WnLÂ°KÂ„bVbl@VI@KÂ„Â@U@ÂnmVmV@XUWI@aXm@Â™VUUkWmn@lmUUk@mUmK@UnwVÄ‰@ÂƒÂƒmU_V@XJÃ´VVUÂšLVUn@ÂšllUnJl_n@Âšml@XÂŽlLlwÂ²LVJUL@VmbVbÂlVXmVnlÂš@Å¤Â¦Â„nn@ÃœÂŽ@bÂšlÂ„@@XV`Â„Unb@VlLVbÂ²JÂ‚XnÂ¥Ã†Ã‘@Â¥Ãž@'],
                    'encodeOffsets': [[
                            118868,
                            42784
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1306',
                'properties': {
                    'name': 'ä¿å®šå¸‚',
                    'cp': [
                        115.0488,
                        39.0948
                    ],
                    'childNum': 23
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VbXWÂš@@UlV@xVLXKWUÂ²LVÂ„VWÂ„LÂ„alVnwV@@bÂ„n@bÂšVVllUnbÂ„@lxÃˆ@laV@Â„aXV@bÂ‚XÂ„xÂ„JÂ‚ÂnV@VVb@nnl@nÂ„J@blÂšl@Â„aÂšÂƒU_VWUwVUÂškUmÂ™UkbÂ±mVwÂœU@ÂVIUW@UWkÂ„@VU@ynLÂ„m@IV@Â‚bnKÂ„LVaVmnIlaXwV@@WVLÂ°@@xnXÂ„@V`V@VbUVVLVKnwnL@ll@@_V@VVnaÃ†@ÂœKVXÃ†@nÂƒ@wÂƒKmUÂ—Â™Wm@Âkm@kÃœKXU@Ã‘WÂ±nIUwVÂƒÂ„Kla@IÂ°wUÂ±kÂÂškmmÂ¯mÂƒ_ÂƒJÂnÂƒaÂƒwÂW@IVaUama@wÂƒUÂÂƒmU@mVw@aXk@mWa@Â£km@aÂƒ_kVmUnWW@Â¯bÂƒkUmk@ÂƒÂVÃ‡m@@kUUÂ™KUUÂ™@UVUamVUaWIkb@xU@@amUkKÂƒVkam@@kVUkUWmÂKmUkLUb@xmJÂƒÂ™U@UImVÃ›VmnUwÂƒJÂƒU@VÂƒXÂ@UWm@UbÂ°Â¦UÂšmxklmX@`ULU@@UW@@xknÂ¯@makVÂ™UmxUbÂ™Â°ÂƒlUÂšÂƒbUbÂƒnUJÂƒUUVÂƒaÂ™LkbUUÂ›JUUÂ@mUUUÂƒJkaÂƒ@Â™xUIWJÂƒUÂnÂƒJ@VÂ™zÂƒ@kb@`@bln@lÂ™bÂƒÂŽ@X@Âš@ÂšÂ„@XlÂ‚bnbVbÂ„@Â„Â„VJlInlÂšbVw@UÂ„KÂ„Âl@lbnan@VbÂ‚JÃ´LnÂ‚UzlV@lÃˆLVbVK@LVxÂ—VWXX`WxXzÂ‚bV`UXVÂ¤nx@ÂÂ„bVlVnVlUL'],
                    'encodeOffsets': [[
                            117304,
                            40512
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1302',
                'properties': {
                    'name': 'å”å±±å¸‚',
                    'cp': [
                        118.4766,
                        39.6826
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„@VVl@Â²Â„lJÂ„UVVÂšbÄŒVVbÂ‚@@InVÂ„@Â‚VÂ„nXxÂ˜JXbÂ‚xUL@bÂ„LÂšl@VlI@WnkÂ„KV@VXnJ@IÂ„JlaÂ°IÂ„WÂ„LVVnkmaUÃ§Â„WVkÃ´aÃœÂ¯Â„@nVÂ°wnJlaV@VUnUUaWÂÂ¯wXWWwna@Â£UaWKUÂ¯ÂƒÂ¯@aVUkKUamUUÂƒnÂ»Â‚anÂ™Â„IVwUWlkÂš@Â„LlWVakU@KÂ„_lÂƒÂšbÃžUÂ°@ÂšyÂ°nÂ„@Â„KÃˆkWWÂ™ÂÅ£Â¥Ä‰ÅÂƒkÄ¡WUwÂ¯Â£Â¯ÂƒÃ‡wÅ£wÂƒ@kK@kÂƒÂ¥ÃwÃ…bÃ‡Â¤Ã›ÂÅ¥VÂ™lÂÂWÂ°@Ä¸Â™x@VVVULVLkl@V@XÂƒ`Ub@Xm@UWÂbÂƒk@Ã†VbnLWV@lnXUblÂ‚@XÂ¯lmUÂ™VkKWLkK@_UK@U@UmmUxmVXLWVULkU@`W@ULUK@XlJXzV@@xml@VU@UX@Kk@WbUK@Xn`ÂƒXmJnÂšmÂškxUÂVbUVlVVxUbV@nKlLÂ„kVKÃžbVKXIÂ°KVÂšmVUIUKULVxVJVLkV@VÂƒ@UbU@WUU@UbUK@b@nÂƒV@VkLmb@b'],
                    'encodeOffsets': [[
                            120398,
                            41159
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1309',
                'properties': {
                    'name': 'æ²§å·žå¸‚',
                    'cp': [
                        116.8286,
                        38.2104
                    ],
                    'childNum': 15
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@ln@UÃˆÂ„ÂŽl@VnÂ„lÂ°aX@mXnVlUÂ„`@bln@Â¤Xb@nWl@bUx@nnVÂ‚Â„Â„V@xnbVbUb@JÂ‚XÂ„xÂ„bÂ‚mXa@kÂ„UVwlWÂ„kÂ„KÃ´ÂVm@wÂ™kkK@klÂ»ÃˆÂƒmÂ™VKXklaÂ°@XVV@VI@ml@@Vn@VX@V@JÂ„@VxUzVVÂšÂšÂ²blVkÂ¦@ÂšÄ @@Â»Âš@VK@VÃˆLlK@XnJ@alIUÂlÂÂ„aÂ„VVbÂš@Â„n@aÂ„U@WUIV@mUn@mKXml@lL@LnWÂšb@XV@@aÂ„VVbÂ„VÂ„@VVÂ„IVWÃˆbÂ˜IÃˆÂ»Æ’ÇŸlWÂšaVUÃ…UÂƒÂƒÂ™ÂUm@kVUÂ™WVkÂaUwmaÃ³UÂƒJUUÂ¯Ã‘UÂ¥mkÂ™Â¯UaÂƒKÃ…nÃ‡yÃ³XmWÃ›XÂ¯aÄ‹bÃ›aÂ›JÂ—ÂWÂ™ÃÂUÂÂ¯Â»ÂƒaÃ³Ã³ÂUmÂ@IÂƒÂšÂVVl@bÂƒLUJWLX@@xÂšXUxlÂ¤V@VÂ„nVUVÂ„XVbVÂš@ÂŽÂ„@@VVnÂ„Â°VÂŽ@ÂÅ£UÂ¯VÂƒUmÂƒÂUWV@mUXÂƒaÂƒbUKUwUaÃ‡KnÂ„ÂƒVkÂ¦Wb@VnLmV@bkV@nÂ„xW`Ã…_UVÂƒV@bÂƒUklVX@VmlUÂÂƒx@VVL@xÂ—VWVÂL@VW@UUm@'],
                    'encodeOffsets': [[
                            118485,
                            39280
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1301',
                'properties': {
                    'name': 'çŸ³å®¶åº„å¸‚',
                    'cp': [
                        114.4995,
                        38.1006
                    ],
                    'childNum': 19
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@laÂ„@Âšy@UÂ„IÂ‚mÂ„VXIVJÂšwÂ„@lbÂ„IVVnVÂ‚@VVÂœIVVlaÂšKÂ„bVUÂ„VVIÂ„mVaÂ„aVÂ™Â„kÂšÂ¯VanwÂšVlUnbÂ°@lm@wX@@VV@VK@_nWlknwVÂ™Â¯Â¥Van@VXÂ‚@Â„W@UÂ„VÂ„IVxnmÃœUnUVJV@Â„ÂšnI@wValKnV@kÂ‚mUÂ£na@mVkÂ°KÂ„LVa@UU@UÂƒmknWWkXU@aWWÂ@@km@UaU@@klK@UkaWaUÂnamm@UÂ„aÂ¯wWÂU@UkÂƒL@ÂŽUn@xÂ™VÂ™lUXVJUbÂ™LmU@aUWUkmKkLUUm@mWÂ—XÂƒaÂƒmmkkWUÂm@@UÂ¯JUUmÂ™kUÂ¯@mKÄ‰xÃwÃÂ¥ÂLÂƒUÃ³ÂŽmwkUUUWVkKmÂ™kKmLXÂ„lxVLVxXJ@nVJnz@VWL@`nX@ÂšÂƒxÂƒ@kVUUmJmIXxÂ„JVÂ„ÂƒnUVÂƒ@UVVÂ„@LUÂšÂƒ`UXVVÂƒÂ„ÂƒlXL@l@b@VmX@bÂ™xnÂ°Â™UÂƒbkKWLXlW@@bÂƒKÂÂ„mKULmakLUlmb@ÂšXb@xmXU`VÂÂ„b@`lLÂx@nWVXL@Â‚Â°ÂWlXnlbÂ„KVKÂ„XVb@Â˜X@l_lJ@V@XnÂŽÂ„I'],
                    'encodeOffsets': [[
                            116562,
                            39691
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1305',
                'properties': {
                    'name': 'é‚¢å°å¸‚',
                    'cp': [
                        114.8071,
                        37.2821
                    ],
                    'childNum': 18
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nKlLnÂšlLXUVVlVnxÃ´ÂÂ„VÂ‚KÃžÂ¦ÃžxÄŠwnLÂ°@lVnÂšVVÂ°I@Vn@VÂ‚lXnlÂ„nÂ„bÂ˜WnXn@VVlKnLVlVX@bnVÂšKVaUIVWÂškÂšU@wVm@ÂÂ¯@UÂ¥VmU_Â°lÂšKÂ„kÂ‚w@LXÂ‚VaÂ„U@wÂšUÂƒUUKlUÃ³W@UVUÂœUlÂƒÂ°KÂ„wlKU_naÂ„KVnlKkkÂšWWa@IÂœJVa@IlJnU@ÂÂ„KVUUmVÂlaXUl@lm@kXWÃÃ‘nkÂƒÂ™Â±Â™kÂ@wÄŸÂÂ›@@UÂ@mKÄ‰LmVÂJ@zmlnÂŽWLÂUÃJU_Âƒ@@ÂšmJkXUVlbklÃ@ÃaÂ™bÂ¯@Â¯ÂÂ±JÃ…wÄ¡aUU@ÂƒkUÂ™@mVÂIÂ±bUKÂƒLÂ™WUXÂƒJkaÂƒLÃ³KULWbUVkKmnk@@bmLUÂŽÂƒl@bÂ@mnmJkUULÂƒaÂƒbnÂŽmn@lVV@Â¦n@Â„l@bÂ‚znx@`Vz@bÂ„xnV@xlÂ„lbnKVx'],
                    'encodeOffsets': [[
                            116764,
                            38346
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1304',
                'properties': {
                    'name': 'é‚¯éƒ¸å¸‚',
                    'cp': [
                        114.4775,
                        36.535
                    ],
                    'childNum': 18
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„bVKlVnInmÂ‚@@aÂ„kVÂnK@al@nmlLVUXaVKÃ´LÂ„KlbÂ„IVWÂšXÂ„KVLÂ²aÂ‚JnUÂš@lV@Â„VVÄ¢bÃ†xÂ²IÂ°ÂŽÂ°@ÂšaÃžbÃž@lkkaVUlWnI@Â™Â„@V`ÃžIÂ‚VXKmÂnk@yÂ‚InUÄŠKÂƒÃ‡kUUamUUkÂƒÂƒ@aU@UÂ™Âƒk@WUwVkVJVkkwÂ°a@ÂÂ„ÂmK@UX@VVÂ„LVW@wÂšwVa@Â¯XÂm@@lUIWaU@UWkXWmU@UwmUkKmn@lkVÂƒÂ²Â™VÂƒaULUVmJUUUwÂƒLma@Â™UmkIUmÂ›LÂ—mVÂšmx@bÂ™LUamKÃ…L@VmbkUÂ¯KÃamzkJUbÂ±VkbÂ™L@lU@WIkJÂƒzkKmKÂƒnUaÂlWkkKW@@nkbk@WWÂ¯XUVUJ@XlJ@XÂƒ@XlWLkUÂƒ`VUnaWaÂÂ„UV@UVIÂƒaUxUUmVÂƒK@I@WÂ@Ã‡Â„U@@U@bÂƒÂ‚@nmKÂXmxÂ™@UxkVWUXÂ„@`VLlL@`Â™zXÂ‚Ãb@bÂ‚Â„@VUVkIUJVzÂ°KVlnLlKnLÂ„xlLVVUVlXUJ@nnÂ‚Â„I@mVUlbn@@ÂŽmÂ„@bVÂ„nV'],
                    'encodeOffsets': [[
                            116528,
                            37885
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1303',
                'properties': {
                    'name': 'ç§¦çš‡å²›å¸‚',
                    'cp': [
                        119.2126,
                        40.0232
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lnV@XbÂ˜Âškx@lU@@LUVlVÂ„LVbnlÂ‚aÂšLXVVnÂ‚lÂ„IÂ„VÂ„UÂ„JV@UnÄŠÂ¦laÂ„bÂš@nJÂ°UmÂƒV@Â„wn@VUÂ„JVIÂ°bnWlXnWVLVKÂ²bÂ‚akkÂ„ÂlI@aUaVÂƒUwVUUalaVwnUVakÂ¥ÂšX@WÂ‚kÂœLVÃ“mÂÂ„mUK@_lWÂš@n_UK@alÃ…@ÂÄŸÃ…Æ‘ÅƒÃÂmÂƒ@Ã‘Â—Å£Ã‡lÂƒLÂƒ@Â¯mÂ™zÂ¯@ÃVÂ™akÂ„Âƒ`@LlVUbkXÂƒKÂ™@klVXUxÂƒJmÂšÂbmÂ¼VÂ„nVVblLUV@bÂ„Â°VÂ°XLVb@Â¤mbXxWXÂ°xXÂŽVbmVUVU@kbmIÂ¯xmUÂƒ@Ã›Â°Ã³bUl'],
                    'encodeOffsets': [[
                            121411,
                            41254
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1311',
                'properties': {
                    'name': 'è¡¡æ°´å¸‚',
                    'cp': [
                        115.8838,
                        37.7161
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„KVlV@XÂÂ°xÂƒb@VnnmbVÂŽXblb@VkL@lV@Vbn@@lÂ‚@XX@bWVXlmXnlVÂ„V@@VUbÂƒKÂ¯LUl@nmbVÂ¤Ân@lÂ‚LXnlVUV@ln@lbÂ„UlLnV@bV@@wlaXJVbnUVbVUÂš@VVÂšLVVn@VVX@@UÂ‚KXUÂ˜U@wUK@UÂ„wVÂnk@UUWlkÂ„V@aÂ„UVUÃ†`X_Âƒw@mlU@anUmK@UXalÂ¥Â„UmÂƒÃˆLVbVxVLÂ„aÂ„bVW@nXUÂ‚VnÂ„Â„VÂ°UÅ¤V@ÂUÂÂƒÂ¯Um@UÂƒ@@ÂUÂ™UaÂƒWVUmUUÂƒU@kÂ£VwÂ™W@wW@XKÂƒIUa@wU@@al@UK@_mKXKÂƒbUU@aVKmÂÂš@XmÂƒÂƒÂ±@kbÃ‡akLÄŸÂVaUw@a@ÂƒmkUJÂƒk@ykw@Â£ÂƒÂWX@lknk@WVkbUÂŽVnUVÂƒL@Â‚mVkI@JUbÂ›I@JXbÂ™XllkLUmÂƒLmbV`kLÂƒxÂ¯LkÂ„Â›VUV@VÃ´XkVVLÂ„VÂ™V@xÂƒVUbWÂ@KÂxÂƒlÂ™LÂ¯kV`UnVÂ¦Â°@'],
                    'encodeOffsets': [[
                            118024,
                            38549
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1310',
                'properties': {
                    'name': 'å»ŠåŠå¸‚',
                    'cp': [
                        116.521,
                        39.0509
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@laÂ„UÂšÂÂš@ÂšUnL@VWbklWxnIVVÂ„V@XÂ„JlbUlÂšXVbn@@KÂ„mV@@XÂ°WVInJmnÂ²@lmVbnL@amKV_kwlmX@@LVamaXaÂƒaVU@UnJVanLlUkaW@UaVakK@IlKUU@an@ln@alKUÂƒkIVa@a@klaUKUV@UkUVÂ¯ÂšKVÂƒV@kUmÂƒU@@aÂ¯ImJUU@VV@UL@UÂƒ@@WXUWa@UkwmÂ™@ÂƒX@@w@al@@aVIUmVUUUVWUknK@I@Â™lÂ¥kUÂ±aÂ™Â™UUVyUwÂƒ@@I@UUWm@@Uk@@nUJU@WUÂ¯@kbWlULnÂšÃ‡Â„kÂ¼@llLÂšl@xUnÃ³ÂŽÂƒLÂƒlkXUxÂƒV@lWbÂ„IÂ„`Â°nnnÂ™llÂŽVÂ²Â¯x@JkbÂƒLUÂ„VxmJXÂ²@Ã’WVÃ›L@lln@Â‚XnÂ˜ÂšnVÂ„L'],
                        ['@@@kX@ValaÂa@KWI@UXW@ÂWanaUIW@UaUKÄ·ÂŽk_W@UVUKUÂš@bÂƒ@UamxVXnJUbWVXLVbn@WÂ°kb@U@WÃ³Â¼mIUÂ¼k`VÂ„@bVbl@Â„lX@lUÃ´VlUÂœIV`lXÂ„Vn@lUlVn@Â„l@UVaÂƒIUWlÂ£UmÂ™ÂVWU@@UUKlUUUnÂƒVL@KÂšUnLVWUaÂ›@Â™U']
                    ],
                    'encodeOffsets': [
                        [[
                                119037,
                                40467
                            ]],
                        [[
                                119970,
                                40776
                            ]]
                    ]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/he_nan_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '4113',
                'properties': {
                    'name': 'å—é˜³å¸‚',
                    'cp': [
                        112.4011,
                        33.0359
                    ],
                    'childNum': 12
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lKl@nVV@Â„bnÂ„@VVnmÂ‚nLÂ‚LXx@ÂšÂ„Â‚VLlKVUÂ„IXWÃœ@ÄŒÂ™lbl@XUÄŠUlwnWÂ„LÃžwÂ‚m@ÂÃžUVmnVl@nXÂ‚JXLm@VnnJlaÂ„I@VkxVbÂ„@VÂŽlnÂ„J@knKVnÂ„@Â°aVanal@XKÂ°bÂ„ÂÂ‚@ÂšÂ¯VJXIÂšÂ„VK@al@nVÂ„kÂ‚@nKÂ„aÂ‚bÂ„@XL@blVVKVLXKÂ„@VaVIÂ°mVaX@V_@a@yUkVwÂ„VÂšIVaÂšJÂ°Â™@anIlaV@nKnXÃ†m@wUUVÂ±UUWÂUKnaWwXUWmÃ…ÂÂ¯VÂƒam@kakImÂƒUKÂƒÂ»lan@VXXaÂ˜W@ÂÂÂ@UlUUa@a@UlwUÂƒV@Xal@@anIVaUK@VÂ™XmwVmUmVÂÂ„LXlÂ‚@nalLnal@Â„ÂšnKlkV@@UnJÂ‚UXnl@nVlÂ¦V@@VnJ@nUVVVVIn@VaÂ„JÃ†Â—n@@K@mÂ„kÂƒa@kmWVaUI@a@Â™k@@aUL@mmaVIUKUVÂƒ@@IU@mÂƒUmmL@K@UÂUUU@mW@@nU@ÄŸÂ»mVmbk@klW@UXnV@LÂƒJmÂ„Â™lUnUJÂ™UUUWÂƒÂƒ@UnkKÂƒxmLÂa@ÂÂƒ@@lUUÂ™bmUVWk@@nkUmam@UakJU_ÂƒVm@Ã…lÃ‡LUVmVUwULÂƒKU@Âƒk@UÂƒVUlU@@UÂƒ@UaUUWaÃ…ÂŽÂƒzÂJÂƒaWLklÂ™b@bmL@Â„kKÂƒaÂbWÂŽUVÂƒ_Â@mV@bÂ¯JmXUbUKÂ™Â¤Ã‡LUU@b@JkLWmkUWIkJ@VmX@JUbVXU`Â¯ÂVVÂ¯blK@LXKlÂ„UV@Um@@Uk@kxWÂŽkbÂƒL@KkbmL@Â‚UXmaU@@l@x@blX@xUJ@bULUlULÃ‡@@VÂšnU`W@@nÃ›Â¼U@@VmKUkm@VVX@@xÃ‡Âš@bUbVb@VX@@xÂ‚LUb@lÂƒÂ¼XLlbUlVVUÂ„Ub@n'],
                    'encodeOffsets': [[
                            113671,
                            34364
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4115',
                'properties': {
                    'name': 'ä¿¡é˜³å¸‚',
                    'cp': [
                        114.8291,
                        32.0197
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VllInJlknJVkVU@mXÂlUÃž`VnVÂ™VU@U@yÂ„@nXlKVÂ„nJVkXKWaXIÂ‚b@yVkÂ„VUkVwn@Â‚K@ÂnW@kÂ„KlUXVVUlbnUV`n@V_V@llX@@VÂ„b@bV@@nlVUbÂ¯Â‚WLnbmb@ÂŽnLnKÂ˜bÂ„UÂ„bVWnLlaX@VVUX@Vln@`kL@ll@VXVJÃˆIVl@XÃžJÂ°UnaÂ„LlylU@UXKlnn@lanLWWnbVI@KXKVL@LVWVL@UVKUIVWX@@XÃ†J@In`@ÂlJVI@aÂ„WÂšÃ›nK@UlK@UU@VKÂ„nlmÂ„nXalÂ„UllLUbVVÂšknJ@nV@Vm@aÂ„Âl@@xnVÂ„Â„lJVUU@Â™w@aÂƒkÂ„@XW@_mWnUlÅUmVKVÂ@ÂVÂXwWÂ»XÂƒWaUwnkWUkÂVÂUÂƒU@@Â@WlaUkkaÂƒIWVkmÂ¯xmIUmÂƒLUVÂƒaUIÃ³Â»m@ÂmmwXk@aÂ›mkÂ¯Â¯ÂlÂ™@wÂƒmkLmmU@UbkUWJ@XUbÂƒJ@b@l@znÃ†mK@Xk@Ub@lm@ÂƒI@akmVKUUVUkU@UÂ±JUbkÂƒ@IWmkxÂƒa@UUVÂ™UWVkIUaW@UlÂLWn@VkJÂƒI@VkK@L@bmKÂƒÂkJmUUaUKWXkÂ¼VxnJ@Â„V@@VULVÂ¼Âƒ@@UkaUlWL@U@W@IkKmL@KULUWULWKUXUJmIÂƒbÂ—KÂƒÂŽÂƒÂ²UWÂ™nWKUUkLUÂƒmUUam@UUÂ™@ÂƒmUL@xkV@Â„VV@bmV@Vk@mwkUÂƒVUx@ÂmbXÂ‚Ã‡nVbÂ„Â‚ULÂ¯ÂšWÂŽnUVLVb@xnlWnU@UVUÂVVUbVVlVkn@llVUXUWUXVbUJ@bmLUJnb@nVK@bl@@Âš@bVJUbnX@lÂ„b'],
                    'encodeOffsets': [[
                            116551,
                            33385
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4103',
                'properties': {
                    'name': 'æ´›é˜³å¸‚',
                    'cp': [
                        112.0605,
                        34.3158
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VVUllLXl@LWn@JÂÂ„@bÂƒKUVmnÂL@`VblLnbV@Â„b@JmL@LnV@VV@Â¯Â„VJVnXLÂ˜@nm@aÃž@Â‚aÂ„k@mÂ„IÂšmVbXLÂ‚ynLÂškÂ°@Â°aVJnUV@UVVXk@WJ@VXLlUnJVnnÂƒÂ°U@Â»Â°UÂ„wl@ÂšbÂ„WmUXÂƒÃ†@VLXU@m@UÂ„a@IÂ›mkbÂ™a@ÂnaWW@_@WXUV@@UÂ‚ÂƒÂ²@Â„K@IÂ±U@Â¥kKWLÃ³LÂlÂƒa@Â£Um@kWKXU@mlLXUVKUUÂ±JÂ¯_@`ULÂ¯ÂWmk@WaÂ„kkÂƒlUnÂƒVUVaUÂ@KUU@mmK@_Âƒa@KX@VaUImÂ±Â™kÂ„aVKVUkwÂ™@kaÂƒÂƒW@kbkLÂ±UUaÂƒK@UUKVakÂ£Âƒ@UmmL@lÂƒIkmUÂÂƒ@Ualw@UÂƒJkbmIUmn@WKÂImWk@mUUnÃV@ÂŽÂnÃxÂƒKmXkxÄ‰VWVk@kaÄ‹ÂšÃ›@WXÂƒJUV@zÂÂŽmÂ„VWnbUbVbÂšLlUnÂŽÂ‚lUÃ’nÂWVÂ—VWnk@@Vm@kxm@UnÂ™l@Ll@@V@ÂšXnÂƒÂškJVÂ„ÂšV@nlVXxÂ˜U@lÂ„n@aÂš@VLnWÄŠÂ¦nxÂš@lbVKXLl@ÃžÂƒVLÂƒÂ„XJl@XXl`lIXVl@XlÂ‚XUVÂšKÂ„wV@lanxÂ„zUbVJ@VVX@b'],
                    'encodeOffsets': [[
                            114683,
                            35551
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4117',
                'properties': {
                    'name': 'é©»é©¬åº—å¸‚',
                    'cp': [
                        114.1589,
                        32.9041
                    ],
                    'childNum': 10
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@n@Â„bÂ°UÃ†Â‚XnVlnLÃœ@VLÂœm@nÂ˜@na@JÂ„Â„m@kÂ„@lVÂšVxXX@Â„V`lLVÂ„XVV@VVÃžLVVÂ°Â„Â²@laÂšbnxV@@bÂ„LÂšmlmÂ„_VWnIWUna@lÂšLÂšbnVÂ°ÂƒVL@KÂšVÂ„LVUVaVLXK@mÃ†Xna@wVmÂ„aÂ‚@Xw@KlL@aÂ„@Va@wUÂkaWÂnIVÂƒla@Kn@VÂn@VUl@nKVnÂ„J@LnK@aVkVUUWÂƒ@VakUVanIÂ‚ÂÂ²XÂ‚W@UUUÂ°KnUVLl@XaVK@aÂšU@KUI@W@_lm@KkLUKV_UÂƒ@Â»@UVJ@XV@@mVL@K@U@Kk@VwUUm@kmWL@VkVkzÂƒKmbÂ¯VÃI@WUkÃ‡JUIUWk@@klK@_km@UVWUUW@kbmKUXÂƒaÂƒVÂ—amLmK@ÂnamaXKÂ°ÂVakU@mU@@aÂƒa@UW@kkU@U`m@U_mVkaUVWUkVÂƒL@lmX@ÂŽÂLm@UxVlÂƒUUl@zÂaWJXbWLUlmIUÂƒkLmWÂƒ@@z@VUVUÂšUmÃ_kVWÂŽ@nUVUlmIklmIkJUkÂƒl@n@Lm@Ã…Â˜ÂƒIUbm@UJUUVU@mmI@UU@kÂ¥mUk@WmÂVmI@VU@klmLÂƒÂ™k@mbkKmbÂ@WkÂƒKUÂŽVnUnnxÂšW@UVLUbmJ@bk@WbU@VÂ„kx@V@bVbkV@VÂ‚Â@Â‚Â—XWbUWm@kbÂ„Â¼VLnÂ„lJlb'],
                    'encodeOffsets': [[
                            115920,
                            33863
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4116',
                'properties': {
                    'name': 'å‘¨å£å¸‚',
                    'cp': [
                        114.873,
                        33.6951
                    ],
                    'childNum': 10
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lÂšnb@xlJ@UnLlKXUlJl_Â„KnV@xVL@bkbVVUÃ¨@ÂšWb@Â„UbmÂšÂ„ÂŽkÂšVÂšmbXÂ„VJnUl@Â„aÂ°@@bÂ„LVbÂƒlXxÂ˜InmnLVwÂ‚anJÃ†wÂ²IlmnXVlÂ°VVbÃˆaVbÂ„@lkn@VWnLlUVmÃžUUklÂƒkÂƒVkUaVaVaUwÂ™K@kkaVWmwÂ„_Â„Â‚l@nUÂ„VVb@bÂ„aV@VV@zXJl@@kl@ÂšlÂœkÂ°WVnÃ†bnbUÂšVJÂ„IÂš@VKVm@kÂ™K@_kK@a@aU@@wW@@k@aUW@IUWVUnLlUlVXKVwmk@W@ÂÂ—VWaÂ„Â¥@k@ÂlÂnÂƒUIÃ‡KUaU@ÂƒUUVmIUVÂ™UkÂ¥ÂƒVma@Â¯k@WanwmÂƒÂ„@@Ân@@Âm@UIVÂƒkUVamUXWÂƒaVÂ™U_Â™@ÂƒmUVUImW@aUIÄ‰K@VmIÂ™b@lU@@nÂ™JÂƒkUÂ™@KÂƒIUmmLk@UVm@UÂŽm@@LkbUÂ„mJXÂlbVÂ‚@xUbÂƒ@@bkK@LWxÂ@ÂƒbUn@xmbÃ…W@nWLUKUbUVÂƒKÂ™U@LUKÂ¯Â„mU@ÂšVV@xULUÂŽVL@bU`WÂšUzÂ¯aUamKUaÂƒ@@xkX@x'],
                    'encodeOffsets': [[
                            116832,
                            34527
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4114',
                'properties': {
                    'name': 'å•†ä¸˜å¸‚',
                    'cp': [
                        115.741,
                        34.2828
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XVl@lLÃˆÂƒÂ„@VkV@VÂ»UanÂƒWÂX@VaÃ†Ã‡Ã´@ÃˆaVX@xVJXUÃžUÂ‚aVLÄ¸bXKlÂ„V@ÂšmÂ°Vn_nyÂ˜XXÂ»mUkÂ¥lK@aÂ„_@yÂšInaVKVaÂ°_@WXI@Âƒ@KÂ‚VnIlbnaV@Â„lÂ„@Â‚a@_Âw@ÂƒlwUKmÂ™Xa@UV@ÂšÂ»VÂƒÂšw@kUKVUUm@wÂ±VUXUKUwmJUUÂƒ@Âkm@@Â±mXkmUIÂ™@mmÂ™KUwkbWakLWaUIkJmÂŽÂƒX@lÂ@@VUX@JWbX@VbULWbÂƒlUVULknlV@bVJkÂ„mbÂ¯KknWmk@@nmVkxÂ™@ÂƒVmUÂ¯KUnULÂ™@ÂƒJUIVÂ™maÃ…aUmÂ¯XÂ›lÂ™kk@@lk@WI@yUUU@Âƒb@aUaÂƒUmVk@ÂƒÂÂƒ`nxUXlb@lÂšLVxUbUbVbUllÂ„kÂ„VlÃVUnkVmKUXm@klÂƒ@ÂƒnUx@xnxÂƒn@`VX@VÂ²x@V@b@Â„Wl@zU`VÂUVVbÂ„L@VÂƒbÂ™W@bkXllkLWV@VÂ„@VVÃˆwlVÂœ@@XÂ˜KÂ²LlbÂ„WnnÃ†L@VnJWn'],
                    'encodeOffsets': [[
                            118024,
                            35680
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4112',
                'properties': {
                    'name': 'ä¸‰é—¨å³¡å¸‚',
                    'cp': [
                        110.8301,
                        34.3158
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@WKUmUIÂ°ÂƒU@@UmU@KnK@IÂƒaU@makKUa@_Â‚KnmVUÂ„L@aÂ‚Âƒ@IXm@KWkkKVkUU@aUW@UUIVaÂƒymwkbU@ÂƒxÂ™LVUÂWWkk@WUkJk_WWk@WIÂ„ÂƒUKÃÂ„k@WKULkaÂ™@mwÄ‰Â¥mXUKÂ™@@bÂƒm@kÂ—VWwkU@mÂ™UUÂƒlIÂ„Â™Wm@Â™@Uk@@KÂškVmn@lwn@@Ul@XmÂ˜UXUmÂVÃ‘ÂkmÂkVÂ™KUaVamaUXnÂƒÂ‚Â@ykLUKÂƒÂ@Â™WwÂKmKnÂUm@UmÂƒÂƒaU@mUk@kL@lÂƒxÄ‹xUnkVmnXxWb@`kzWJ@VÂ—LmVUnÂ™lmUÂL@lW@Ub@VÂšXUbÂš`VLUbUJ@nmnUlUUm@@bUJlnUÂ„ÂšÂ‚U@lxkbÂƒ@@XÂƒJUnÂƒ@kbÂ¯VVVmlXXlJlzn@VlkVWÂ@bkKÂ™bmÂškÂŽUbVbÂ„lÂƒXVxÂšKÃˆnÂšwÃžlÄŠKlÂÂšVnKlwX@lL@xlUnVnÂ„@Âšl@lmX@Ã†Â„ÃˆbÂ°Â¼ÃˆwVJlxÂ„_Â°xÂšaÂšlÂšUÃˆxlUnbVxnL@lllÂšbmÂ„n@nbÂ‚@@VÂ„L@VÂ„@@Â„VLÂšJnIVVlKnVÂ„_'],
                    'encodeOffsets': [[
                            114661,
                            35911
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4107',
                'properties': {
                    'name': 'æ–°ä¹¡å¸‚',
                    'cp': [
                        114.2029,
                        35.3595
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XVlLÂ„KÂ°bUblbUbÂšl@nX@WÂ„XVVKVkÂš@@ÂŽmb@Â„UbnÂ„W`kLÂ„LÂƒV@VVLnKlVXIlVÂš@@aÂ„@lÂ£nWlÂƒkÂVaÂ„@Â°bnUlLVlnaÂ‚bnUVUXKlU@Âƒ@Âlk@aÂ„IÂ°yÂ„@Ã´kUU@wÂšmÃ´ÂšnkWakmlÂ™UkVmkUlmUUm@nkUKWanamUÂ„LXW@UÂ‚VnUlnÂ„`lÂ„ÂœblLÂ°KXV@ÂÄ J@LÂ°Â„ÂšJÂšUVwÂ„anK@UUImmÂƒÂkK@Â¯Â±UÂm@IVmUmmÃ…nÂWaUKÂ¯aUkÂ„w@WÂ±kÂVÂƒxÂ™UÂ™VÂƒwÂƒnÃ…JUIWaÃJÃ³IÂ—bm`ÃbÃ…ImJUIÂ¯Â¥Â¯@mUÂ¯UÂƒJmnUVÃ³UklÂ±V@zXlÂ„bWVXL@bmÂ„mÂºÂ@@XmJUXUÂ°llkÂ„@nWJk@UÂ„@Â¦U`mÂÂ¯ÂŽWx'],
                    'encodeOffsets': [[
                            116100,
                            36349
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4104',
                'properties': {
                    'name': 'å¹³é¡¶å±±å¸‚',
                    'cp': [
                        112.9724,
                        33.739
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lÂ¤UbVL@VÂ„LVbÂ²VlKlaX@Â„Â„lbÂš@lxUVULÂƒbÂšlnÂ²VJUbW@@LÂ„b@`nL@nVV@LVÂŽUbUVmÂ„kVlÂ„ÂƒlXbl@XnÂ°ÂŽVK@_Â°`Â²IVVV@VUVJnInaWK@UÂš@Â„KÂ„LÃ†@nmlXXWVUUw@klKVa@knyVkVanIÂ‚JXUl@XbVUl@@aÂša@mXkÂ‚bnK@UlK@UUUVaXaWmkUmÂ¥nÂ—WmXaWaÂœkl@VmÃžbÂ„KVL@aVI@mUwVmÂ„Â@KÃ…ÂmÃ©ULÂ™KVaUk@kUK@UÂ˜WXI@VlKXUÂ‚@VVnInVV@VLlK@UUÂƒkKU_@ÂƒWWUwUÂ™@klÂƒn@ÂƒÂƒ@ImbÂ—@@mÂ›nUKÃ›@mKUkWVXxmbVLXÂŽVVUÂ²VV@xÃ…nmWmLU@kbmJ@bÂ¯ÂšÂ™IUbÂ™JÂƒUUxVl@z@bU`W@UbÂ¯nUJUbÂƒ@WLUKULkU@aWKÂƒ@ÂaÂƒbmLÂ@ÂƒlmUk@@bULÂ™ÂƒWJUIÂ™Â°Â@ÂƒÂŽÂ¯aWLk@mbUbÂ¯b'],
                    'encodeOffsets': [[
                            114942,
                            34527
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4101',
                'properties': {
                    'name': 'éƒ‘å·žå¸‚',
                    'cp': [
                        113.4668,
                        34.6234
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@nWVUKÃ…@WÂ„nVnIÂ‚ÂŽV@ÂœkÃ†Â‚ÂšwV@Âšnn@lxÃžlnÂÃ´JÂ˜zXJl@nalUÄŒVlÂƒl@Â²UlkÃ´VVUnmÂ„IÂ°VnVÂ°@Â°Â¦VJnIÃ†JÃžan_VmUÂ@amaÂ™@kUÂ˜Â¥kaUklw@ÂUIVÂ¥kVUI@ÂƒmmUÃ…mUÂlÂƒwVU@amUÂ—JWbUakVÂƒÂ—VÃ©Â¯Im`ÂƒkÂ—@ÂƒwVWmLkUÂ¯ÂŽÂƒXkWmLmxÂ@UUÂƒbm@@xÂ™J@LÂbW@UUVWUkVKÂƒ@kaÂ™IUamKUkkmmLÂƒUkJUVWXkWmnÃ…@ÂƒKÂƒLÂ™@@VXLmbmJUIUVU@ULWVkK@nWVXL@lVn@Â¤Â„bÂ‚kÃ´KXKlL@Â¦Â²V@JÂƒLÂ±@ÂÂ„@VU@WV@X@`XXmb@ÂŽÂšblaÂœn@JÂƒb@V'],
                    'encodeOffsets': [[
                            115617,
                            35584
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4105',
                'properties': {
                    'name': 'å®‰é˜³å¸‚',
                    'cp': [
                        114.5325,
                        36.0022
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â°kVaVÂ¥kÂVmUkWkÂWVkVKUwkkmKUU@aÂ„wWWXÂWakKWkXmlaÂšIVmXÂ¥ÂƒU@aÂ„@WÂnK@kÂƒÂƒÂ™VÂ™IÂ¯Âƒ@KÄŸI@ÂWUÂ¯LkKÂ›akÂƒÂƒ_kmmVÂU@VWXÂƒKnVmbXbVLmln@VVknlVUnVlkÂšlnXbmlmlXblnÃˆlWbn@@nÂšK@VÂ„LÂ„bVVÂ°VVzÂšlnÂš@VÂ™xÂƒIÂ™bÂ™ÂŽU@WLUaÂ¯VÂ™UkWÃµ@Â¯kkÂmxkÂ¼lÂ‚Â„XUlVbVLnlULmU@lÂƒLkVUlÂƒX@xW@Â¯mUÂƒ@UmIUWÂ™L@aXaÂ˜kUÂ™Â¯anÂƒWkÂ°@kÂ™kKmmUIWaÂambUkkKmVÂ¯aÂƒ@UblÂŽkÂ„mXkÂ¤Âƒ@@bÂ™@UbULWVnb@lUVVnmÂšnVVUÂ„J@bWXX@WJkL@blVUÂ°UV@XlWnXUbW@UVkVÂšVWbnLUJWLUK@Lnn@blVUÂ‚Â„nUblxVUVJXUÂ„aÂ˜@UbÂ„LnUVV@mVIVVn@UbV@Â‚ÂXbmbUVÂ„_lVXUWanJVI@WkI@WVIVUÂ°WXXl@la@mX@lLXlÂ‚kVbÂœmÂ‚XÂ„ylIXJV@@kÂšKlaÂ²UVaÂ„IVyÃžbÂ°LlVna@UÃ†KnLVbÂšK@anwUÂ™'],
                    'encodeOffsets': [[
                            117676,
                            36917
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4102',
                'properties': {
                    'name': 'å¼€å°å¸‚',
                    'cp': [
                        114.5764,
                        34.6124
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lUVbXaÂ˜InV@bUVÂ„xÂ‚knVVÃ†nn@Â„VJlUUÂ¦VJ@ÂkxVllbÂ—Â¦lVÂš@nb@bVÂŽUnÂ˜aÃ´JÃžIXbVJÃ†IÂ„mÂ„xÂšUÂšVÂ„wÂ‚UÂ²l@XÂƒxVlÂ°bVLXbÂ‚`XklUnmVblLÂœ@lmÂšxÂ°LVK@UXIVaÂšWlL@UkÂƒÂ°KkÂVaVUXmmI@UÃ…KmmÂƒXkaÂ±KÂ—L@WÂ›@kUÃ‡xUUÂƒ@@UXUlKkklW@aÂšXÂ„a@UÂƒKUaVUUÂV_@yXk@Âƒ@a@UÂ±w@UUW@_Â„mmw@wVwÂ„mUaÃ‡bUaÂ¯UUkmWknÂ±JÃ…xmIÂbUxmKmnÂ—JWwÂ„kUaÂƒK@aÂ¯@Âƒbk@mVUIWÂƒÂ—Lmwm@UaÂ@WJUb@LUlÂ™@UUmLUbWJ@VÂL@VmXÂWWzUJUÃªÂ„Â˜'],
                    'encodeOffsets': [[
                            116641,
                            35280
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4108',
                'properties': {
                    'name': 'ç„¦ä½œå¸‚',
                    'cp': [
                        112.8406,
                        35.1508
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@V@VL@x@bXÂŽWV@XkÂšÂšlUÂŽWX@JÂ„@nI@KlLÂ„KÂšUVaV@ÂœJlL@KUk@KÃžLÂ‚lÂ²_Â‚@nWlLÂ„UVVÂš@nLWVUJVn@anV@aÂ„wÃžUVLVxÂ„bÂ„@lWÂ„@lbXnÂ‚Vn@@Â¼ÂšLÂ°mÂšKVn@bnl@nVK@blbÂ„LÂ„WÂ„U@VWLXV@nlKn@lVVbXwÂ°ÂnÂV_@Â¥VÂƒl@XI@mlÂƒkkVÂ¯VWnI@WÂ‚@nÂ¹nÂƒ@aWKXUÂƒaWk@yk@kÂ„Ä‹UkVmbk@WIÂ—yÃ³ImÂÃkkwm@Â™mU@Â™xÃ…ÂÂ›lU@ÂÂmJÂƒXÂ™ak@ÂƒxÂ¯V@Â¼Â¯VmÂ„UmmIkVWK@UXIl@UWVUU@mVUIÂ¯bÂ¯@Â™lmKÂzWKUaÂ™nÂƒJ@nÂƒlÂbÃ@@b'],
                    'encodeOffsets': [[
                            114728,
                            35888
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4110',
                'properties': {
                    'name': 'è®¸æ˜Œå¸‚',
                    'cp': [
                        113.6975,
                        34.0466
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lIÂ„VnKlnVlnLVbÂšJlbÂ„@ULVlUXVVX@Â‚a@KÂšI@wn@Â„aVVÂ‚@nwnKlXÂ„WÂ°ÂlVnKUXÂ„xÂ˜@Â„ln_Â°JVIXyÂ‚XnW@UÂ‚K@UXIVanKVVÂš@Vk@KVaXIÂ‚@Vbn@nxÂ˜KnaUÂ™lÂ™ÂƒÂnÂ™Va@ÂƒXa@Â™VÃ§UUla@aUK@wmUÂƒLk`kIWVkLmK@V@XUlÂƒn@JXV@nmÂ„Â™bUÂ‚Ã³IÂƒmUaÂ±@@Ã‘Ã³VUUk@UÂlKVU@akWVUUÂlUUaUK@UUKWbUkÃ…J@XWaÂƒ@XbmJ@nUJ@bUKÂƒLÃaUnk@Â›lXbWbXnmÂ˜nÂ¦lVXnWbUbVV@VkL@VmLÂaWl@nÂ™b@bk@UVWak@WVÂImJUbUlmz@lUbkL@lVx'],
                    'encodeOffsets': [[
                            115797,
                            35089
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4109',
                'properties': {
                    'name': 'æ¿®é˜³å¸‚',
                    'cp': [
                        115.1917,
                        35.799
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lLXbWÂ‚XXÂƒx@bVVnLllVxULUlÂ‚XXlVlUnlÂŽUÂ¦UbÂ¯lÂ˜nÂœK@VÂ‚bVb@ÂšXbVLÂ„KVxVVnIlaÂšbÂ„aÂ„Â¥lU@wnalLnVVlVLXnlWVXn@@lVI@WnU@mÂƒÃ…WÂ¥Â—aW_k@WwXy@kmÂƒ@wUÂÂ„mÂšÂ„ÂšÂ¦ÂšlUxVLV@UwÂšJÂ°xÂš@VXÂ„@VbÂ„@Âš`VX@VX@llÂšIVbnJlIÂ„bÂšVÂ„lÂ„ÂÂ˜J@ÂÂÂƒmÃ‘Â¯LÃ³a@ÂƒÂƒKUaÂ„kÂ™ÂƒÂ™XÂƒ@UK@wU@ÂƒlWUUÃÂ¯ImWÂ¯aÂƒLUKU@ÂƒkÂƒÂ»Âk@mÂƒwÂƒa@UnKWI@ÂƒUU@akVWKÂ—k@aÂ±ÂƒÂbÃ³UWKXUmkÂ™KUÂmLÂƒbUxÂ„Â„@lmLXÂŽÂƒ@@bÂ„VWÂ¦UnÂ™JkbWnXl'],
                    'encodeOffsets': [[
                            117642,
                            36501
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4111',
                'properties': {
                    'name': 'æ¼¯æ²³å¸‚',
                    'cp': [
                        113.8733,
                        33.6951
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@LÂƒÂ‚UnVxnIWaÂ„@Xb@WÃ†IVlXaVL@VVLVbkVVÂŽUVlX@bUVkLVÂ‚l@VVÃ´U@Ã’Â²@VbÂ„nÃ´JVÂÂšanÂƒ@mWU@IÂ„mVk@WkI@wmakÂ™@wlW@wÂ„@VbnLVbÂ°bVyXÂ™V_@aUKVÂVK@wUU@Â™Â™aÂ™K@kmbXVmJUXÂƒ`knÂ™nÂƒK@aU@mwÂ™akbÂ±@Â¯ÂƒUUÃKUUU@WU@VkLUKU@mUmJUUÂ@WVkL@UWJÂ—X@VVL@lVlUbÂšLVKnÃªÃ†ÂŽ'],
                    'encodeOffsets': [[
                            116348,
                            34431
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4106',
                'properties': {
                    'name': 'é¹¤å£å¸‚',
                    'cp': [
                        114.3787,
                        35.744
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã³Â™Â™n@xVVÃ³lÂƒ@Â¯zÂƒJ@bkl@Â@Â„kVWLUVmVXbVJnnlLlÂšÂ¯@XlmÂ„Â°bVÂšÂ—lWb@bÂšKVXnJ@VVÂ„Â°nX@@wÂ„WVklUÂ„K@knVVKmkUKUaVkÂƒWkÂlÂ»nwlÂŽÂ°lÃ¶@lXÂšVÂ°UVbXKV@ÂšÂÂšaÂ„JÂšw@UmÂ™Â™kUyÂ¯UUUÂƒaÂƒK@UÂ™L@mm@XaÃ‡kkmWank'],
                    'encodeOffsets': [[
                            117158,
                            36338
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/hu_bei_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '4228',
                'properties': {
                    'name': 'æ©æ–½åœŸå®¶æ—è‹—æ—è‡ªæ²»å·ž',
                    'cp': [
                        109.5007,
                        30.2563
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VKÂ‚bX@lbUVnLÂ°Â„@VlVnUl@VUX@Â„aVÂƒmaXÂƒlaÂšUUU@wmaVUn@VÂƒnmmk@mÂ™U@knaÂ™aUÂ¥VamÂ™X_@WÂƒUÂ™ÂmW@_kÂƒVaVKnLÂ‚lÂœ@VÂVal@kÂ¥@kUW@kUKVUlUVÃ‘ÂW@kÃ‡aUÂ»VaÂÂlmkUVUVakÂ™@aÂƒVÂ¯_@WÂ‚UkmVUlU@aÂœÂƒÂƒalI@akkVWUaWÂXUWwÂœWVbÃ†@Â„ÂÂ„lÂ„alIVK@UÂ™m@ÂUUÂ„W@alÂÂ²aÂ‚Â¯UaÄŸÃ‡m@Âƒbkk@wÂƒ@@WÂ™aULmxÂƒIUÂ‚Â™ÂÂƒbÂ¯@U`UXÂ™JmLÂ¯aÂƒKÂXÂ›WUL@aknmKÂ™@ÂaWUXaWm@I@UÃ…mVU@Â™Â™aUV@bÂ™VÂƒI@WkUÂ›bXkm@VakwUKULWKXÂmJ@XUK@ÂƒmL@KUwVaUI@KU@mmnÂ™mXka@Â»V@@UUaÂƒwÂ¯yVk@ÂƒUUVmmkÃ›ÃˆU@mWUnmxÂ„ÂšmlUbVÂ¦UlÂbWVUL@UUÂƒÂ™IUmÃ‡KVÂ„VbUVVxknÂ™LUxV`VX@ÂšÂ„Â„kJVVUXWaUVVlUnmKUbkI@WULmK@L@LVlÂƒLnmUIWV@aknÂƒ`VXUJÂIVlUVVbUX@Â¤mbnLmÂ‚m@UXk@mm@UkaÂƒÂ¥@kV@@KkU@aUKWbkLWVkIVÂŽk@UbVlmX@bU@@mmL@bn`@Ln@llVLVkÂ„@XVVU@`VXUÂšÂ‚Â¼k`VÂULka@VllVInÂ¤VÂU@@blÃœÂƒbkx@bkLÂ›ÂškKÂƒn@bn@@b@JUnV`UnVbVKlVXUlbn@Â°ÂƒVxÂ„@@bÂ„nVbUllVn@VÂ—VK@UnW@UVUÂšlnkÂ‚VÃˆÃžÂšxVbÂ„VVIÂ„xVaÃ†@@aka@UVaU@@aÂ„k@Wl@nbVIÃ†ÂŽ@Jk@Â„L@VlXnlla@ÂVJnw@UmwXU@aVKÂ°Ã’nÂllnLlbÂ„xnKVaV@lÂ¦Â²nVl@llLÂ„x@XVVÂœÂ‚Ä¶ÂÂš@naÂšx@U@alÂ™XUVaÂ‚LÃˆÃ¾VÂ°XxWXkK@ÂšmLnlUb@bÂ‚xnLVlVVkb@ÂUJ@xWXXÂš'],
                    'encodeOffsets': [[
                            112816,
                            32052
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4203',
                'properties': {
                    'name': 'åå °å¸‚',
                    'cp': [
                        110.5115,
                        32.3877
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@@a@w@kV@nbVK@ÂƒnUlaÂ„@laÂ„Ã…l@nlVakwWX@WkLÂšaVmÂšwVÂ@anK@UlIXmWkk@@mmLkWlwk@U_mKXwWK@UÂ¯K@UU@ÂƒVUaÂ™kmÂƒkIÂ™yUUVUmanU@mlwkÂƒ@_mWXaÂƒUWUÂ@Ã‡Âƒ@U@aUaVwUKUIÂƒVkK@UWIXÂƒmaV@k@Vm@UnwlÂƒUamk@V@Â„ULUamxUJkU@IÂƒ`WkkKÂ¯XWak@@W@IUVÂ™LWJkXkaÃ‡VUKÂƒ@kUmbmUUÂƒUKÂƒbkKWUkI@ÂƒkKÃ@@aÂƒUmÂ»nI@mÂƒU@UnWV_@aUmWbkLUlÂ¯b@aÂ›kkÂk@WkkJm_k@UVÂ±@ÂJ@bÂ›nU@@WÃIUJVbXL@nlJkx@Â„Wn@VkJmbÂ—LmUÂƒ`VbUL@xVnÂ„@XVÂƒÂŽ@Â„mVVnnJVbUÂ„Âƒx@Â„VÂ„nVUbVVÂƒx@ÂšnÂ„Â™bUK@bÂƒÂ„@bÂƒJÂ„ÂšmÂ²Â„VUÂ‚lbXzVJVÂ„Â„JVbn@@Xmb@V@bVJÃˆ@Â‚Vnkn@Â°aVVV@ÂšXÂ„KnalLVmÂšUnnVKVlnLWlXXÂ„KlkÂ°ÂšÂ™ÂšXÂŽWÂškLUVVV@nU@mlÂ¯nmbk@W`Ã…@mbÂ—LWmÂ¯UÂƒxnÃªVÃ¨k@mbÂƒVÂƒnUKÂ™@kKmXk@@JUIÂ›lÃ›LllnbVnlJ@LULnlÃ†aVLnÂŽV@nkVJÂ„@lkÃ´@Â²bÃ†mÂ°wÂ„LÂ„WV@VXÂšKÂšVXI@WÂ°ÂÃ†VÂšKÂ„bÂ°UÂ„JVIVVÂ„Â¦XKVL@lÂ‚InaVÃnUl@@bX@Â‚Â™nmVL@lVLÂ„lVLVUnbVW@xXnÂ˜bÂœUÂ°Â¤V@ÂšÂ™Â„a@kWKUUn@VlnL@UV@ÃœÂ»@mX@V_ÂƒakaÃž@VKÂ‚Â¯@kkW'],
                        ['@@mUkUUm@nllVKXXVK']
                    ],
                    'encodeOffsets': [
                        [[
                                113918,
                                33739
                            ]],
                        [[
                                113817,
                                32811
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': '4205',
                'properties': {
                    'name': 'å®œæ˜Œå¸‚',
                    'cp': [
                        111.1707,
                        30.7617
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â°`Â„U@blÂšUbUVlVknÂ‚ÂŽUbVÂ¼Ãˆb@lÂ‚XUÃ’kVUVVL@lVX@llÂ¦k@UbUÂ‚Â›@ÂkmKULUblÂ„@`nXÂšÂŽÂ„V@XW`nÂšUbVÂ¦Âšbmb@lÂšV@nnlmnUÂ„m@UVnb@xVVÂ™VkbWÂ„nbÂ‚VnÂVa@an@UaVUÂ‚JXnWlXX@lÂ„Â¦@ÂŽlKÃ†XÂ„bXÂ‚V@VVÂ„@Â°Â¯Â°xXxÂ‚XV@nVÂ°UVWU_VWXkmaVÂnWVkn@lln@lb@UVLXWlnX@Â˜aXUmaVK@UXUÂ„U@WVIÂ‚WÂ„XXVÂ‚U@Â¥VKÂœ@Â‚UÃžÂŽÂ„Â„Â‚aÂ²LlV@kV@UanKma@UVUnK@UVLXyVLÂ‚knJ@UV@@UXKWUXaV@Vb@mVLnKWÂÂ„m@aUUm@@UkK@UlaÂ„LXKWaXI@alKlmUk@wVKXL@m@ÂWWnÂ@UVa@K@wna@aW_XWWkXbVW@k@UÂ¯WWwka@UUaVIVÂƒkU@mÂ±@U@@wVKkaÂš_@VV@XUVwUÂ¥Â‚ÂÂšyUkm@ÂVÂ±ÃˆUKkÂ»Ã‡LÂÂ„mÂ˜mLk@Ã³Â£kmWwÂƒm@UÂ„IkÂWKXwWU@ÂƒkLÂƒwkbmaÂƒbkK@VÂƒLkmWIUKkUUÂƒÃ‡IÇ«JÂ™XÃ…JULVÂŽÃ‡LUVÂƒ@UKÂ™@kI@WVI@ÂUaÂƒWmXVVULÂ`Â±kÃ…LmKkÂƒÂƒkÂƒÂÃ…@UaÂ›XXxWVXÂŽVbUXll@bkJÂ„bÂ›Â„@bkVUVlnÂV@X'],
                    'encodeOffsets': [[
                            112906,
                            30961
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4206',
                'properties': {
                    'name': 'è¥„æ¨Šå¸‚',
                    'cp': [
                        111.9397,
                        31.9263
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': [
                        '@@@Xl@XbÂ°WlLXlÂ„_@JlVVInwVbVK@Âƒ@UnlVbkÂ„mx@VUnl@U@nbWÂ„XJ@VlLÂ„UVJVLUxVb@b@VÃˆÂ„Â‚@XVÂ„VWbnX@`lÂ„kx@nmVnbUVVVÂšzlJnÂ„ÂšlVbÂ„UV@@VÂ°L@VXLWxnLV`l@kxlXnK@nl@XlWnÂ„`Xnl@@UVa@VÃˆKÂšÂ£VLVanWÂ°U@UVUÂ„@Â„`VInÂÂ‚mV@Â„nV@Xa@aVW@UÂšalkXKÂšblIÂ„yÃ†ÂXnlJXbl@@VV@nklU@`Â„nVKÂ„LVKVb@VÂ„U@UÃˆKÂ„UVKÂšIlUX@V`lIVbn@nblVVmV@@XXJÂšUVV@knKVn@`@XÂ‚VnKÂ„wlLVmUUU@ÂƒU@aXL@WlU@UUW@UmU@KkLWaXkWmXUWm@U@Âƒnk@UmK@U@UÂaUÂVUUKV_@al@namWUI@KUÂÂƒK@aVÂ@WUIÂƒbÂƒÂ¥ULUJkImÂ™ÂƒK@U@KÂ™V@U@a@UkU@K@wVaUwlU@mUÂƒULmKUkV@@anIWmUK@IÂ¯Â„mKkl@LUbÂ±lUakLmkÂ@WwUKÃVUIm`Â¯n@Uk@makJU_@ÂƒÂƒJmaÂ¯ImwUVkKÂƒbÂ™aUÃ…@wWaU@VU@mXIVmmUkJkwm@mIÂlUKWzUK@VmLUV@VnbmLVbU@@lkUÂ±KÂbÂƒÂƒÃÂÂVÂ›@UL@Â¦ÂVWUÂƒWÂXUJ@XÂƒVWV@VULnbWVÂ—bW@kmWXUK@Vkam@kkm@UlmXUÂŽnbWlUXV`UXÂ¯VmUU@Ul@Lll@nnJ@LÂƒnÂWmbmÂš@bÂÂÂ™`ÂƒÂš',
                        '@@kUUm@nllVKXXVKmU'
                    ],
                    'encodeOffsets': [
                        [
                            113423,
                            32597
                        ],
                        [
                            113794,
                            32800
                        ]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': '4211',
                'properties': {
                    'name': 'é»„å†ˆå¸‚',
                    'cp': [
                        115.2686,
                        30.6628
                    ],
                    'childNum': 10
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VVUnWVXnVJ@Â„Â‚U@V@VXÂŽV@@IVJUÂnÂŽ@V@L@KlIVlVanLVbnVlIÂ„Âƒn@@a@Kl@@IÂ„JlI@aXU@KlKÂ„kVblJXUÂ„VlU@VÂ„bVkVKXn@VlxVaÂ²I@VlVUxln@bÂšJXklaVWnLmÃ…@y@k@aÂšI@W@aXIlVVaV@nnlKnLVW@IUa@a@KÂ„UVVlI@wXKVV@IUÂƒlaÂ„@lUXwWÂƒnÂƒnalLlxXLllÂ°@XwVKVaXIlÂ™nbÂ˜@nln@Va@U@kÂ°ÂƒUmÃ†UVaXIÂ„JVÂ¯Ã‡UÂmmkU@WaÂKmakÂVm@U@aVKkkmKkVmIkÃ‡Â°Â£@aUUVaVVnKlkXÂÂ‚mkÂƒ@ÂƒlUVaX@@Um@ÂÂÂ‚Â™UmlUXVÂ„UVU@wÂ‚KÂ²Â¥Ua@I@UVÂ™l@UÂ™VÂ±UIUÃ‡Â°Â»VkUmVI@a@UÂ™mÂ™ÂÄ‰Â™Â¯VÂ±bÅ¹Ä–ÄŸaÃ‡LÂ¯lmÂŽkX@Â‚Ã³Ä€@ÂŽmÂšÃÃªÂbÂ±WkLÂƒn@xXx@ÂŽ@b@V@LW@UbÂƒlÅ£XÂƒ`kxWnXÃ´Â¯Â¦Ã†V@L@JVLÂƒxkK@V@bkzÂ°lÂ‚lXz@JÂ„UlVla@XUVÂ„bVKXnW`XXV@laVV@VÂ„X@VÂ¯xÂƒx@xULVbUJ@n@LU@VmmakbUK@bÂ™IWWUUVkUmkLm@VJkb@nUJÂƒÂ@`V@kXÂ™aUaVmmLkUmJ@Uk@UÂ„Â±lkzmJUb@bÂ„VUxVXUÂ¤ÂƒL@JÂƒX@VlL@JkLUVU@mnUlÂ„Â¦@V'],
                    'encodeOffsets': [[
                            117181,
                            32063
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4210',
                'properties': {
                    'name': 'è†å·žå¸‚',
                    'cp': [
                        113.291,
                        30.0092
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÃˆJVÂ„lVVLXJlnÂ„K@UlLÂ„anblaÂ„xlK@Â„XVWxXLlÂÂƒJ@VÂ„nXxlnÃ´Â¤l@nKnÂ—Â‚ÂƒÃˆKlÂ¼VLÂ²Ã‡Â‚Un@VlÂ™zÂÂŽVÂ¦UxWVU@@UÂ™`lbUL@xV@Â²@@nlVUÂ„UJVb@VlbXxÂ°XVWX_VKUwVKVa@UVKUUVk@KnblaUU@wnWl@UX@lÃ†@@aÂ„IVmUkÂ„Â™ÂšxVJÂ„UÂ„bÃœÂ™@Uk@WWnk@ÂVÂƒÂ„Â™Vm@I@m@Un@mÂ™XUlVlUnJ@knJVUÂ°@@aÃ†LX@ÂƒllL@Â¦nJV@XblLVaÂ²U@UlWÂš@VX@`@LV@@bXJlIXml_lJÂœUÂ°bÂ„KÃ†LnVVlÂ‚@Ã¶Â—VÂƒÂ‚mXaVIÄ¢llUlVnLVlX@@bÂ‚aÂšnnxÂšVÂ„LÂ‚bn@Â°ÂÃ†ÂXmmkÄ‰ÂƒÂ¯wÂ±Â™ÂÂ™Â™UÄ‹@ÂKÃÃ…Æ§ÅƒÃÃ§Â™Â™UwÂ¯ÂƒmÂÂ™Â¯k@WÂ‚kV@Â¯UIUJWÂ¼kbÂ™UÂƒwk@W`@Â¦UÃ´nb@VÃ†ÂšlÃˆ@VU@ÂÂƒÂƒÂ£UWWnUÃ†UnmJkUÃ‡Â£VWUI@aUU@WkI@UÂƒa@JW@kÂ£kaWVUKmnkKÂƒbÂ™kkVWbÂ—VmUUÂmwU@kkÂ›@UakUUa@V@nlx@lUbÂ±lUbnnWLUyk@UamÂœUKÂ™@mlk@Wb@VXL@x@xWI@aÂ¯ÂŽÂ¯V@bVn@LkKmL@`ÂXmKmVU@@bkL@VÂ±bk@UaÂƒaÂ™LÂ™KUVÂƒIÂƒÂ„Â™WÂ™XÂamVVbUK@b@Lm@UWkxULWVUnm@UlUX'],
                    'encodeOffsets': [[
                            113918,
                            30764
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4208',
                'properties': {
                    'name': 'è†é—¨å¸‚',
                    'cp': [
                        112.6758,
                        30.9979
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@n@lxlInVUnWJ@nUVV@Xb@xVÃ†ÂšbÂ„alLVUnxÂ°JnbÂ„I@Â„V`lInbl@@VÂ°mn_VJÃžUVLXxÂ‚@nllKVbÂ²kVa@KlknLÂ°Âƒ@JVLXnmJ@bU@VlnLVKVÂ„@nX@lUÂšKVaXal@VKnÂ@Â¥Â°L@UnwÂ˜bnaÂšV@KV@VUX@lVXI@KW@@IXWV@laVLÂ„ÂÂ„KlaXUVVnkVWV@lwXblIXWVkVmÂšaUÂ£VaUmVIkU@y@ÂWakKUamU@UUK@kmK@wÂ@@ÂmK@LÂƒVÂ¯Â™U@WwkmULÂƒamVÂVUU@ÂƒÂƒIÂƒbUKUaÂ™kmÂƒm@UakLmxU@UÃ’WlULÅ£Ã¿mwkIUm@aÂ‚kÃˆblW@UÂVÂƒUUk@JW@XkWWUkUKUIlw@aUWknWUUmnIWÂƒÂ™aUwVaÃ›ÂšÂƒaÂƒVUIÂ™wÂƒÂšVlUnÂƒJ@bÃ…@@kVWk@mX@xVVkbma@LUlVVUL@VUbULVxULW`UX@V@lUXWaXlWXX`@bmb@x@LUb@VmÂŽXX@Â‚@nWKUL@xVlknkL@bWJXbWLÂƒKkb@VlL@Vn@VV@bÂƒnXÂ‚mLUK@nUaU@WbXVWL@VU@@V'],
                    'encodeOffsets': [[
                            114548,
                            31984
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4212',
                'properties': {
                    'name': 'å’¸å®å¸‚',
                    'cp': [
                        114.2578,
                        29.6631
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÃžÃ†Â‚LÄŒ@ÂšVÂ‚ÂšÂ²ÂšÂ°xÄŠÂ„nlWnÃ…ÂŽÂ¯Âm@ÂaÂƒK@Â„Â„Â°Â‚nÂ„JÂšwnÂ™VIUaÃ†JÂšÃ…@wÂšwVÂ™XW@aV_l@Â²VÂ°lÄŠwlaXLÂšwlUkalVVaX@lVXI@aÂ˜UXJ@UÂ°UUÂ¥VIVKVÂkÂlanLVa@VÃˆIVÂV@nk@aVa@mV_@aÂ„K@klKUa@UnKWkÂ@@lU@@UW@@nUWUwmaVIXÂƒÂ„lV@mLXblJ@kV@kk@KU@WÂƒkUWVÃ…wkLmW@UmL@lULÂ™KULÂƒak@maUUÃwUJÂƒIÂbÂ›KUUÂƒ@ÂÂšÂ™aWK@kUWVkUwVwÂ@Â™mÃ@Â™I@wkW@aÂ›wÂw@LUÂ¥Â™kÂƒJ@nVJÂƒIkVVnkVÂ›UkyUIUl@xWUkaW@@Â°kzÂ„ÂŽWxkLUWmzk@@bVVVÂšÂ„b@Â‚@XlVÂœ@Vl@bVbUnÂ™`WnÂ—@WbÂ„VVI@`Â„LVbXLV`mnU@@lÂƒL@LUÂŽÂƒak@ÂƒLk@WbUJnÂ¦@lVb@xVb@n'],
                    'encodeOffsets': [[
                            116303,
                            30567
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4213',
                'properties': {
                    'name': 'éšå·žå¸‚',
                    'cp': [
                        113.4338,
                        31.8768
                    ],
                    'childNum': 2
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„@nÂÂš`lwÂ„kÂ„ÂƒÂ„UmUVWX@lkÂ„@VanUÄ Â¼V@@mX@@nVVÂ‚VXLmJVLnK@bÂ„ÂV@@JÂ„@VUn@VaVUUUVWVLV@@Kk_@almÂaVkUU@WVÂƒVUVLXmmk@wUaUKUV@ÂÂ°Â™@kmaUaÃˆmWÂÂ„mUÂƒVklaX@lVnxl@@UnaUk@ÂƒVUVwVKÂ„nÂš@VVn@VbVJUknUmmVmk_VwÂ„KUUmÂ™VakÂ¥@UVKVIkW@UmIVWkIVÂƒkmmLkwmVUÂƒ@LÂƒUU@VVXL@JmLUbmK@UUKmÂkKUUmVUaUnÃ‡lkÂÂ¯Â™mJUnmLUaUJUaWL@UkJÂ™ÂÂƒUÂƒ@ÂƒaklkU@Â¯@KWLUmUUWVkbÂƒLÂƒÂŽUKkbU@WX@JX@@LWJkUW@UVU@@LÂ™UmbÂ—amx@VÂ¯K@Â¦mÂŽULk@WbUbÂ™LkVW@kVVxUb@x@LlV@V@b@VÂšU@L@VÂ„LnÂšlJVIVKÂ„Â¦Â„aVJ@XUÂŽ@bÂ„LVÂ‚@LVJnXmbk@@bU`VLUVVÂÂ‚b@V@VnL@Vml@Â„@VXnWVXnWlXblK@LnV@VVX@VkV@XWK@bÂ„VV@VV'],
                    'encodeOffsets': [[
                            115830,
                            33154
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4209',
                'properties': {
                    'name': 'å­æ„Ÿå¸‚',
                    'cp': [
                        113.9502,
                        31.1188
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VnXK@L@Â°lVlkÂ„bÂ„@Â„VÂšÂlI@VXKVbVIVbnKVmnIÂ°ÂšlÂŽÃˆkVmVbnUVVlLnÂVL@VnLVanK@IWKUUV@Â„V@KVÂ„nUlxnKlnUÂ„lJUXnJ@VlXUJUL@VlÂ¦UbnÂšVVÂƒLUxl`UnnnmVVlnÂVKÂ„bÂšmVX@aÂ°ÃÂ°LÂšaXJV@VUnKVXVK@LnKlLUbVVX@VwVJVnÂ„@@UUÂ¥V@@UUK@ÂƒmaUÂVÂUkkJ@L@K@UmÂVÂUI@JU@WÂ@U@UÂV@ÂƒUIWmXUVmUUÃ‡@UVmIÂlmnmakK@akaW@UwVUkKVÂnUlKVwkÂÂ™ÂƒVÂU_WKUkVW@UXaWkUa@w@ÂVU@ÂXaWÂ±@IkbÂƒKÂƒbÂ¯L@WÂƒXkWÂƒ@UakL@UV@UmVUmL@UXWVL@aÂšUÂƒÂVUUUVU@yUUÂƒIUa@wUKWVU@kÂƒÂ™Â™WkÂ¯UkwVKÂƒLUxÂ™K@nVxUlUUWVÂUmw@wÂƒUUyÂXWlXÂ¦WbUV@Â„UÂ‚@blbUVVbXXÂƒl@lVL@bk@lxkVVnVxÂ™Â¦Âƒ`UnkL@V@L@ÂŽÂ‚@@xnL@lVL@VnVVblLXb@Â‚@zlVUJVnUbVÂ¤Â™bUnUlWXkJWakxU@UXml'],
                    'encodeOffsets': [[
                            116033,
                            32091
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4201',
                'properties': {
                    'name': 'æ­¦æ±‰å¸‚',
                    'cp': [
                        114.3896,
                        30.6628
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nbnmÂ‚knJVUÃˆ@@UÂƒÂ¥VknmV@VUlK@IkK@UÂ„W@IÂ„KVÂ£UWVwÂƒU@aVanIlyÂ²kVÂƒl@@VnIlVnKUnVbÂšblWU@@_Â„Â‚VI@mlaUIn@lKVnUlVVXXÂšJ@aVLlanbUnV@@K@mVIUaVK@wÂ„wÂ°w@UÂƒW@UUUkbU@WWX_WmULÂƒaVU@WkbkUÂƒV@IWyÂkÂ¯kly@a@UlLÂ„wUK@I@KÃ…UW@Ã…ÂƒÂ±UÂm@wlÂ¥kaÂƒ@@_Vw@Ä·Âƒa@akw@ÂƒkKWÂ£XÂVUVwVwUaU@VUUÂ™Â™xWKkbÄ‰xÂ¯kÂ±Uk@U`@bWXUÂšÂ™x@xÂ™Ã†Ã…IVbUJmÂšÂ™xÂƒIÂmÂƒÂ¯@ÂƒÂ™UmxÂ™nUVVbnJVÂ„@LÂƒ@@ÂŽkV@bVnÂƒ@UVULlxÂ°VXlÂšÂšlÂ„V@XUVL@xVbÂ„JVV@zUVVVUVÂ„ÂÂ™V@bUKWX@VnKUVVnU@@VlKVbÂ„@lXÂ„W@XÂ°KÂ„aÂ„Lla@JXÂ²Wb@ÂŽUV@Â@xVbXlWb@VUXVlXLV`UÂÂšÂ„lÂŽUxkLmVUÂŽlLUVVxX@lb@blL'],
                    'encodeOffsets': [[
                            117000,
                            32097
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4202',
                'properties': {
                    'name': 'é»„çŸ³å¸‚',
                    'cp': [
                        115.0159,
                        29.9213
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VÂšUVV@VbUxÂ„aWUÂœblUVmnKlX@bXJVIlVUxVVVIUÂ‚ÂzlxÂ¯Âš@Â‚VbnL@xÂ‚x@UVaXKÂ„bÂ˜@XkÂ‚WU_VmÂ²klWÂ„XVKÂ„ÂŽl@nXV@@wÂ„mlKÂ²XÂ‚aÃžÃ©nÂ™@ÂÃ´Ã¿@ÂlWnÂÂ°kUKmmUÃ‘Â™ÂUmm@ÂƒwkImWU@UakL@bVLUVÄ‹@Â™bUK@alIXKWK@Â™nXnKmkUÂVwÂƒ@Â¯b@LÂ„lULÂ±WÂ™n@KULUaW@kL@lÂƒL@bU`@nUb@bmlU@UÂÃ‡J@UUbmKkblÂŽUÂULUJVÂ¦Â¯V@VWIÂ—V@bWJkUW@UbkUlbkV'],
                    'encodeOffsets': [[
                            117282,
                            30685
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '429021',
                'properties': {
                    'name': 'ç¥žå†œæž¶æž—åŒº',
                    'cp': [
                        110.4565,
                        31.5802
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@n`lIXll@lÂÂœl@bÂ°aVklKXaVn@bU`mX@VÂ„V@nmJnÂ¼Â„V@bÃž@lL@Â„lJXVlLÂ„aVLVÂ„nVnalVÂ„@VLÃˆUlblWXIÂšKVU@JÂ„Â™Âš_Â‚Â@anÂ™naÂ‚XÂ„m@KmI@mkk@KVkÂWWwÂ¯wÂ¯Â°Âƒ@UUU@WÂÂƒaÃ…WkL@ÂÂƒÂ¥@kWWXkWmÂIUVVbm@@bUbmÂÂUUÂ„ÂƒbW@UVk@mVkU@UÂ¯ÂƒmKVUkaW@ÂaULÂƒÃ†VbÂƒb@VÃ…@Un@VÂƒLWlÂ¯LÂšÂ„'],
                    'encodeOffsets': [[
                            112624,
                            32266
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '429006',
                'properties': {
                    'name': 'å¤©é—¨å¸‚',
                    'cp': [
                        113.0273,
                        30.6409
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@K@UlKVmÂ„_ÂšÂ¥UwUmlUkwl@@aUK@kÂ„kWWUaVUka@aVÂ@ÂƒVUXaWÂ¥Xk@WWIklm@Ã…xmIÂ™VÃUkxkaÂƒÂ„@bWJÂaUL@Â„W@Â™lÂ¯UULUÂ‚ÂƒbÂƒkVÂ™UaÂ¯bmÂ¤UnÃ‡UkmUÂšUxÂ˜b@VkXÃ‡aÂl@bVnlJnxÅ¤Ä€VKXkVÃ‘V@nwlKVbn@nÂ„ÂšlVbVLÂ„aÂ„J@Â„VVÂ‚UnUÂ„bVKlnXxV@Â°ÂšÂ„U@KnL'],
                    'encodeOffsets': [[
                            116056,
                            31636
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '429004',
                'properties': {
                    'name': 'ä»™æ¡ƒå¸‚',
                    'cp': [
                        113.3789,
                        30.3003
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VKÂ°VÂškX@@ÂƒVKÂ‚bXI@aÂ„ÂƒlblwÃžVÂšUnJÃ†wn@lkXJ@XÂ‚WVzÂ„V@xnxÂ‚VXUVVVkUw@mÂšLVwÂ„KVUÂ„@Um@alU@ÂÂ„@@KUÂƒmIUaVUÂšmnwmwÂ™mÂb@aW@UkmKkUkVÄ¡kUJWbÂnUÂ„ÃµÂ˜Â@UkmUÃ…KÂƒLÂ¯aÂ›VkIk`WnkJÂƒÂ@xVLUVVbUbk@WlXbmÂ„VxnxUblbUVÂ™@@VUV@nVL'],
                    'encodeOffsets': [[
                            115662,
                            31259
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '429005',
                'properties': {
                    'name': 'æ½œæ±Ÿå¸‚',
                    'cp': [
                        112.7637,
                        30.3607
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@UbVxÂšbXÂ„mJVnXVlmVX@bkxVJVLVlXXWlX@@IVlÂ„VÂ‚UÂ—aVwVÂ™lnÃˆVVmnÂ£Â°aVbUÂšÂ„lÂ„aVÂUK@mVU@UÂš@VUkaVamwUwnÂƒWaXkl@VaUaVUUK@wÂ„ÂWI@aU@@K@_UWÂ™@kX@VÂ±VUbkKWaU@mI@Â¥kKÂ„kW@Ã…K@bÂ¯@UVmI@lmIkVkUWVnÂšm@@V@n@JUnÂƒÂšUÂ„@ÂŽmlXXl@@V'],
                    'encodeOffsets': [[
                            115234,
                            31118
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4207',
                'properties': {
                    'name': 'é„‚å·žå¸‚',
                    'cp': [
                        114.7302,
                        30.4102
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â°Â¥WÃ³XmlwÂ„_Å¤WÂ„kVaX@@K@U@a@ÂWwU@mWk@ÂƒÂULÂƒWkXÂ±lUnV`ÂXWlÂ—@ÂƒaWLUb@VÂw@wmKUa@ÂÂ°Â™kwÂ‚yVÂUJUUVwkUUJWI@akWmLUnkVÂ›aXVÂƒbUxUVWÂXÂ¤lL@Â„lx@bÂ„b@Ä¸Ux@`Â„@lbkÂ¦@xÂ‚nÂ²VÃ†Â„X@'],
                    'encodeOffsets': [[
                            117541,
                            31349
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/hu_nan_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '4312',
                'properties': {
                    'name': 'æ€€åŒ–å¸‚',
                    'cp': [
                        109.9512,
                        27.4438
                    ],
                    'childNum': 12
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': [
                        '@@@nÂ„Â‚@b@XnJ@kÂ°x@aVUnlÂ‚UXnV@@VnJWÂUJVÂ„nIVVÂ°ÂŽUbVVVL@ÂŽÂ²LUÂVaÂ°V@aV@nmÂ‚UXblLXWVXVmVLVK@an_Â„`@X@lÂ°Â„VlXXW`nX@Jmn@bÂ„@nV@Lm`Â„bUbÂ‚n@VUVl@nIVbUlÂƒV@LkJUnVV@xVblVUbU@ÂƒzUKU@mx@xUnn@@WV@lbUb@ÂšnVWXXÂ‚V@VIV@VUnJ@VUz@JWbXllI@VXVVL@ÂŽVn@Â„Â„Wlb@ÂÂ„ÂŽlÂ„XVlLÂ„aV@VJ@XX`Â„kVwVl@bkÂ„Â‚bUÂŽlVXIlÂƒnLVaÂ„mVwV@@nV@XaVJVbX@lwV@nÂ„@nV@VWnIVVUÂŽÃ†@XxÂ‚a@IÂ„UUKmk@mVÂƒÂ„IXmWUÂšÂ™VJnUVU@anaVwkÂ™Â›U@UXa@WÂ™@m_@aÂ¯@@K@UVÂƒÂ„bnK@blIlbXa@WW_n@VÂƒU@Â¯bmyÂƒUkÂUJÃ‡Ã…@WÂU@kWKÃ…wÂƒÂnmÂ°KVkmankVWnXVWV@UÂƒÂƒwXkV@mÂƒÂ„UlLnaÂƒÂVaX@VUn@VnVK@xlnXWÂšU@aÂ™@@klakÂ™VwÂ™mUaV@Â™wmIÃ›`mÂ—@mVUXmlIXÂƒVÂÂ‚I@K@aU@UaV_UK@wkUmmUKWXÂÂŽmVkUÂƒL@mÂƒÂƒU_nKÂ‚Â™@aVU@UkakÂ»@UÂ™Â™@ymUÂƒÂ„Â¯Â™ÂƒUUÂƒVKkam@Â™nka@ÂƒmwkLWbÂ¯mkaÂƒ_VaVKUÂƒÂ™IUw@ÂkKmÂU@WK@UnÂƒmaULkU@wUalWVÂ¹U@@WUI@WU@Â‚_@W@UÂ@mÂƒU@WbÂbUK@Um@@UmbUwÂWWkk@WUÂ„a@anUUwlWUwUU@wlJVUnnV@@mnI@mÂ‚K@U@wÂ„a@wUm@_mÂƒVUUaVUkÂƒÂƒÂÂƒ_kÄ‹UkÂ™VWLÂÂƒ@mlU@knÂ¥W@UwÂUWV@VÃU@lXLWVUbVLXlVIlÂ‚knmU@VUJk@@Â„Âƒ@Â™ÂkVmwmVkxU@@XmVUb@xnKVLl@VxUxkIU`@bWVXX@JWL@bkbÂ„Â¤@bmUUUÂ¯KÂƒkmb@VÂ™VUÂ„VVn@@Â„Vb@`lnÂœxmbÂ„lUnÂ‚bkÂ„@xUÂ„mV@bmWÂbUÂV@VJÂ„Il@nVUbÂ‚K@nn@VbnJVIlJVkXJ@X@lmx@bnnWVXJWXU@UlU@mÂk@@llbÂ°xÂ„IUbnJ@VWbXVmI@JVX@bkÂ‚@bWL@JUXUK@U@UÂƒ`n@@Xm@XVW@@nX@@`ÂƒImxU@@JUI@KÂƒLmK@UÃ…UUV@VW@Â™Â¯kUU@UamVUUmJ@nÂ„xmLÂKÂƒkmJkwkKm_mKXU@aÂƒU@b@Wk@ma@zUJVUmbUlU@Â™xnXlWlXXblKÂ„Â¤V@@nUVVLkVÂšÂ„l@Xb@VVKÂ‚nXKVx@znW@XÂ‚@@lVK@X@JXbWbnn@JUamLVVXIVxnK@aWUX@Â˜x@VnI@WlI@anVÂ„IVxkÂ‚l@lbXXÂšxVVVJVInbV@@lnÂ¦ml@XXVWbkJWb',
                        '@@XLVKVXVKUa@UUUmV@l'
                    ],
                    'encodeOffsets': [
                        [
                            112050,
                            28384
                        ],
                        [
                            112174,
                            27394
                        ]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': '4311',
                'properties': {
                    'name': 'æ°¸å·žå¸‚',
                    'cp': [
                        111.709,
                        25.752
                    ],
                    'childNum': 10
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lxUXVÂ‚lXUVnlVÄ¢Â„JVbUXVJV@XUWÂ¯Â„ÂVIUK@klW@Un@Â„nl@V`XUVL@l@ÂšVx@Â„XXW`UnUbÂšxUlVnUÂšVÂ„lb@VnJÂšUVVVInJlUÂšVnwVklKnwÂ„LVJVÂšV@nIV@nbVa@KVVVUUaÂ„KV_nVVJ@_VWÂ„nV@nÂ¥lI@anÂƒlÂ¥X_VKlwVlULUVVVÂš@ÂšU@VXLÂ˜Âƒ@IUmn@VU@wmKXUWU@mÂ²Âšl@VIXWWkÂWUkWlkIVamUXamUnmWUU@@UnÂ™lK@ÂXJl@kÂVÂUk@mWKXkl@@aVU@UVWUUVaÂ„In`VUVLnw@U@K@UÂƒÂƒ@w@UVmUUÂƒÂ™Â°K@UnV@bV@Xk@KVm@amkÂ„aUÂ£VWUUmUUwm`UbULkaÂ›KXU@kVmUÂ™@aV_UWVIn@Â˜yÂ„XXK@klmVÂÂ„ÂV_kWVUn@WUU@UÂƒmaU@Â™wnwWanUmmXkÂƒam@UakLmK@bÂ™xUUUU@KmÂ¥VaÂƒÂ¯@ÂƒkÂUaVUlmÂ„UUÂ@mUUÃ‡mUkÂ™ÂUyÂƒbÂ™bUaÂ™XUWWbÃ…LmL@VÂ™aÂL@WWXUKmmkÂ@a@UUKÂ™XWÂ¥kU@VÂƒUkxmVkUWbUJnÂVJ@nVJXzWxkÂŽ@lVbUX@VVL@`mbUnÂšÂŽUnÂ™VVÂ¼k@Ulm@mwÂLÂƒb@lmLUK@UÂamÂÂƒWÂkÂƒK@Â£Ua@ÂƒÂ›UkJkUmbVlkX@bWbUÂŽVÂŽnnUVlÂ„@bÂšbVK@VX@lbÂ„V@nUÂ¤ÂšxÂ‚Â²Â„Knblb@xÂ„VÂ„Ã´@ÂšlÂÂÂŽ@b@l@XWxnVl@Â„VV@XLVlÂ‚LUÂŽUXV`ÂšbXXmJU@@bm@UUkLW@UlUKWUUbÂ™wUmÂ™L@nklVVmVXXm@@bUKlÃ†nÂ„Â‚XkllVUVVL@nUbVÂ‚@V@nnV@xUnÂ¯U@JW@UX@xÄ‰@Â™`m@@LÂV@b'],
                    'encodeOffsets': [[
                            113671,
                            26989
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4305',
                'properties': {
                    'name': 'é‚µé˜³å¸‚',
                    'cp': [
                        110.9619,
                        26.8121
                    ],
                    'childNum': 10
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XIlJÂšIÂ„VVK@Ân@VVVKnLVwVmnLVK@UÂ„@ÂšwÂ„J@wVIÃ†ÂšÂ°ÂX@ÃœÃˆÂ„UÃˆxll@kn@VwVaXJWXn@@WVL@UUKVKV_U@@aVKÂ„x@UÂ„aV@lkÂ„@XylbUaV_ÂšVnalÂ@WÂ„U@aÂ„I@aV@@aVUl@XmÂ‚UXÂWaXml@@kk@ma@ÂV_UÂnUVÂ™UUWJUa@kkaWLUmk@@LUVWUkJWkÂK@Â¼UnWJÂƒIkV@b@JUIm@UlÂ™VÂ™Âm@Uw@a@kÂWÂƒXWKUknW@ÂƒWUU@kÂ™mxÂ™UkVmIUJUUÂ™VmI@UkaUÂƒVÂ™UmVkÂ™wVaVmX_WW@ÂƒUw@Â™@kUKWVU_k@Âƒmm@@VkX@lVLUJÂƒÂXÂ°WVU@UIVWUaÂƒIUÄ¡mkVUkWUÂVWkwWXk`mI@Â¥kUVÂƒUÂƒUnÂ±@ÂmÂ›XkWknVÂ„UVmmU@@XÂƒVÂƒUk`@XÂƒÂƒÂƒk@Â¥Â¯Â»mbÄ‰Ã³@mkU@kUÂ™ÂƒÂƒÂ™KmX@Â˜UnmL@lULkKUÂƒWUU@ÂƒbUaUnÂƒ@Vb@lÂ„Â¦Ub@lÂ™@UKmnÂƒKUnlÂ„UVVbUVnÂ„@`Vn@xÂƒb@x@VÂL@nmJ@nU@mmUVkI@xVVVxkXVxmV@bÂƒbXVl@XlÂ‚XVxna@Vn@@VVLÂ‚aXaV@nÂ„Â‚@@V@XÂ`V@@XVJ@XV@UÂºkXVb@xlVVKnbmÂ„@VXLV@nÂ‚lL@ÂVxÂšJVÂ„ULUbÂ„`lbÂ°nXalKnx@Â„lbÂšmn@lbULVÂ„Â„VÂ°ÂšÂ„ÂƒnV@zÂšÂš@VlÂ¼lb@VUV@bÂÂšmLV`Â„Â„@nÂ„KlVnUÂ‚ÂXWVLnnlV@xVLU`VbV@'],
                    'encodeOffsets': [[
                            113535,
                            28322
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4310',
                'properties': {
                    'name': 'éƒ´å·žå¸‚',
                    'cp': [
                        113.2361,
                        25.8673
                    ],
                    'childNum': 10
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â²zVaVlnVl@nÂšVkÂ„Jl_XJlIVmnL@mV@VXn@lV@Â‚XzV@lyVÂ¯Â²U@UlJ@XVKnVVIXl@UVLV`@n@JÂ„I@mlIÂ„KVLnUlVUVVLXaÂšKVLl@nb@ÂŽWÂ„XVÂ°KUnVVÂ„L@xVJÂ„L@b@LUVVVUÂ„Â˜VXbmbVbn@@lUbm@Âx@XVVVÂŽ@Â@Â˜@bkImx@Vm@XbÂƒb@lÂ°XUÂ¤Â„aÂ‚LÂ„mnL@bl@@Â™VUX@VxnVÂ˜anLnÂƒWÂÂƒÂ¥XKVwnUWÂXmVIUWÃ†LVxÂ„LÂ„w@wVmlU@Â¥XÂƒWUkwlÃ‡n_UwÂ„WV@VUÂ°wnÂUÂ—Âƒy@aVÂÂškVlnL@lVnÂ„w@VlJ@bÂ„XÂ„x@bVKnb@U@WVUl@@Vnbl@XLlK@aVLVKnxÃžn@aÂ„LlmUaVUÂ™Âƒm@Ã…knUmaUKmVk@mÂ™kk@UlWUkVm@w@kUU@WÂ™ÂUÂ¯Â™Â¥@wÂ„Ã‡@aVIlUVÂ@kUWU@UUmÂ»@kÂ@mKVkUKUwÂƒaUaUaÂ›@kÂ„kUWJkImaU@UKÂ™@maUzk`@zÂƒy@XmJkL@UUJmUkV@zÂ›@kÂŽkVmK@Â¦UbWL@aÂ@UbmKmwUKÂ™XkÂ›VUUkmVkw@UUKmL@WUIWaÂ—JW_k@@WmI@mk@WÂkWULUUVKUUVm@ÂÂšUÂ„bÂš@Â‚ÂnUÃ‡Âƒ@U@wÂ„Â™V@Ua@aÂƒL@akÂÂ„Â›l@kÂÂ™UÂƒJÂƒwÃ³@@L@V@Â„Â™`@ÂœÂƒJ@xnnÂ™ÂšmV@bkJmUÃ³@ÂƒnÂ—JWÂ„UUmÂƒU@UV@LkÂ„WlnnmVXbmxÂšxV@nbVÂ„V@XVm@UVlXU`ÂƒÂUÂŽkn@lWLÂƒWÂ—zm@UJVXU`@bVÂšUn@lWVÂœLlbVKVan_VxnVVVUXVÂ¤Âƒbnl@bUn@LWlU@@amU@VÂ¯LÂ„ÂšVVUn@V@xÂ„Â„@V@L@VmxUKUVm_ÂƒJUbVV'],
                    'encodeOffsets': [[
                            114930,
                            26747
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4307',
                'properties': {
                    'name': 'å¸¸å¾·å¸‚',
                    'cp': [
                        111.4014,
                        29.2676
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lÂ™UÂ™mkUwUyVÂÂ™@VW@Â¯VaÂ—ÂVmUU@KVUVUVLnaWÂƒnkUÃ“V_@mVU@ÃÂ„w@Âƒka@kVmÂƒUmK@IkaUamKkXWaUWÂ@WUkÂ„Â™@@KVU@aU@Â™L@J@XÃ‡VUKVak_mWkLWakVUbmLUUmlÂUVKUU@kUWW@UImJ@xkLkKm@@XÂƒ@Ã³ÃÂƒ@UUk@UKÂƒVÂ™ÂƒULÂƒKÂƒXkWWbkaÂƒIUÂÂƒWU@mUk@WLÂaUJÄ¡Â™Âƒ@@XÃˆÃ†VIlÂ‚Â„VnzÂ°aV@UÂ„m@X`@XWbkakJ@amLÂƒaUÂ„@V@LÂ°@@bn`Âš@@XWb@VÂœVlÂšUxmb@bUVmVUIÂ™ÂšXVWnÂƒJUÂ„@nnlVLÂƒV@JÂbWzk`m@UÂVKÂ²VÂ‚xÂ„kÂ„LVlÂ„@Vn@VÂ„Â„Â°xVKVkÂœVVlUblx@bUÂ„Â‚Ã†Âœ@@nVnUllÂ„kx@VW@@VkLWxUL@bÃ@kKkVÃµV@bkXVVUVÂƒ@ÂƒVkUkVÂ›LkVÂ™aÂ™@@ÂÂ™ÂƒÂ¯xUxmX@JVbÂÂ°WXkK@Vm@kÂ„VbÂ™bnÂ¤Â‚xUXkJÂƒblxnXÃ†KÂ²lÂ‚_@WnaÂšn@ÂŽUL@bÂ‚JnIlVÂ„@lUÂœ@@Â¯Ã´@lWÈ‚IVKVmÂ„U@aXaV@lwVXn@@K@UVKUUnUÂ‚bn@lWÂšXÂ„ÂƒlJnUÂšLÂšKV@Â„Â„l@Â²a@UlK@aV@naVXÂ„WV_nKlL@KUm@aÂ°UÂ°Â@VXL@a@wWmXal@Â„kÂ„@VLnÂ›V@@bl@VnX@mwVaÂ²aVU@mkÂ@Â'],
                    'encodeOffsets': [[
                            114976,
                            30201
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4331',
                'properties': {
                    'name': 'æ¹˜è¥¿åœŸå®¶æ—è‹—æ—è‡ªæ²»å·ž',
                    'cp': [
                        109.7864,
                        28.6743
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@KÂšL@wnKÂ±ÂnÂƒnmÂ‚Â—@WUkÂ„ÂƒÃœÃˆn@nÂ»@mVamkÂ„mÂšUÂ„Â„l@VÂ™nmmU@wUanÂ¯VKÂšLnÂ„VWlInyWUÂœI@WWk@KXUÂ˜n@mnUmU@WÂœÂƒmkV@ÂƒkXaÂšaVaUmÂ‚IkÂƒÂƒÂ@ÂkaÂƒX@ÂƒUm@ÂUKWU@UkJWkXa@IVy@UmIUVU@UJU@WÂXWmU@Â™VakaU@@Xm@Vm@wnwV@VLÂ„yV@VakUUa@wUUVmlI@KÂ„UVkUamJk@VU@UÂmVaÂƒan_@KmUÂƒ@@anm@ImWX_WWUkÂ¯Âƒ@k@WÂƒ_m`@bULUKUnUWWXkKWaÂVmnU@@bÂ¯UUbVÂŽÂ±K@ÂUKUUVaÂ¯ÂUUmJUÂƒVIXÂmI@UU@WmÂVmkUV@bÂ¯w@lmI@W@aÂƒÂ@mÂ¯LXbmJVLklWL@V@XXÂŽmbVVU@@VUÂ²Ul@VlX@bÂš`XxÂ›zUmkUVÃ’lÂŽ@bXLWxXVlÂš@VÂ„bkLma@nmVÂmULVbmVUb@lnzmbUÃ’Vl@Â°nLVÂ„lJkn@bmJk_ÂƒVmmkblxÃˆx@LUbÂ„xVb@VÂ™n@JmLVÂŽUÂš@Â„nV@Â¦VbnJ@ÂlVVbkxÂ™bm@UxVLV@n`UnVVVÂ„klÂ°zÂ„xVb@VU@@Ã†lXnWmÂ¦nbVK@XVVUVVl@XÂ„KUV@nVL@WnIWÂŽXLVKVLlxUbVKXVWbn@@UnKVLVbÂ„JÂšU@aVUÂ°b'],
                    'encodeOffsets': [[
                            112354,
                            30325
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4304',
                'properties': {
                    'name': 'è¡¡é˜³å¸‚',
                    'cp': [
                        112.4121,
                        26.7902
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lÂšV@XV@Â„mXVlXLÂ„WÂ‚X@l@bVxn@ÂšÂŽÂšUVkn@VJ@I@alUÂ„JXIVm@Â»Â‚LXllIXVVU@Kl@VnXKlb@lVbXIVVUÂšmVVÂU`@Ânbl@@lXLVVVKVbnXWJ@VXbWxXbÂ„UlÂ™VKÂ„Â¦nLVVUVVbÂšbÂ„K@UÂ˜LnK@Un@VxlUV`UnnL@VVL@JV@VUnxnKVbV@@VÂšIVUnJUÂVUl@nWÂ„XlÂlIUaÂ„KVbÃžLVÂ¼Â²`V@VIUwlaVmXa@IWanK@U@mÂ„kVÂƒVUVaX@lÂšnaVLÃˆ@Â‚Â¥@kkJUÂWJUaÂƒXkaUmÂ‚wVÂXJ@_lWUU@Â¥n_Â‚KkamÂUKÂ„Â™@amKÂƒnÂKÂƒbVÂ£Â¯W@kÂ„aWan@@UnwlJ@a@Â—@ÂUÂUU@WÂ‚wn@Va@km@UanaWaÂ—UVÂƒUUVU@K@aÂƒKUI@wÂƒKUUVmÂ¯LWUXÂƒ@Âmak@UKÂ™LWbUKVUkUmVUKÂƒLkJ@nÂƒJ@I@mU_UK@VWkUJmUUL@WkI@VÂ±VUÂ°kzU@Wy@ÂkUm@UWU@@nmKUnkJWIk`ÂƒIUlmÂ™k@mUUkUbÂ±yUX@VUV@bk@WlXL@nVlUÂlÂ‚k@WI@ÂŽkLmÂš@VV@XVmnnVWbnVUblJXkVlÂ‚XXlWXUJk@Â±Â™@nXVWVnL@xUVm@Vn@JÂ—Â„WK@UÂ™VÂ™@UUVUVKUkkxULW`kÂ¦mÂ„@bkJmÂ¦U@ÂƒmUX@`UImUU`ÂƒLVbUVUU@LUbmaU@mJU@UÂ™UIÂƒKmxkLUl'],
                    'encodeOffsets': [[
                            114222,
                            27484
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4306',
                'properties': {
                    'name': 'å²³é˜³å¸‚',
                    'cp': [
                        113.2361,
                        29.1357
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@wUklmUÂUmU@@UVm@wUaV_mmUKmwkIkJmUUnm@Â™ÂÂ™@UUÂƒbUKUÂƒmÂÃ›ammÂ¯xVLkbÃ‡Ã†ÂƒUÂƒVUzkVUlÂƒUUKWLXÂ¦W@ÂƒVUUUaÂƒKUbmLÂKmÂ„@akU@aÂƒmVaUUVIVWkk@wkÂƒÂƒ@@xmLÂlmÂÃ…wmbVlXlÃIWVkK@kkVÂƒL@VWKU@UblnÂaÂƒÂƒm@Âb@bÂšnW`@XUJk@UUWKÂƒk@UÂKÂƒnnÂ‚@xmLUVm@kbVbVÂ„nV@VÂ„bÂ‚Â@KnVÂ„LWÂšXÂŽÃ†VÄ¢Â¦VblÂŽÂšÂ„nÂ„UJWz@Ã†Â™VÃ³UVbkVÂ™aÃ…x@Â¦lVUbVVknWKÂƒÂ„k@ÂƒwÂƒKÂ™VUÂ„Ã…Â„Âƒl@zkb@`m_mJ@xXÂ„mbVbÂœ@llV@nÂ„@llbXLÂ˜UXalUÂšlÂ„alVnwnLVKlÂšVbX@@IÂ„V@blJ@bVL@VVVUXÃˆÂ¤Â‚VnkVÃ‘XmlbnÂšÂ‚Â„VKkÃ‘Ã…Â™@UmaVÃ§@Â±XUlIÂ„xlVÂ„@VaXÂ¯lUVVUÂšVJnÂ—V@Â°Â°nÂŽÂ°Â„VxÄ¸Å‚Â°Â¦ÂšbÂ²Â¦lJ@U@aUK@kUm@_mÂ±VIXal@Â„Kl@Â„bVÂ@KÂ„K@kÂ„m@UmUUaÂƒK@_UJÂƒaXUÂ˜@XmÂš_VmUk@WUkÂ›@kU@a@m@UÂƒaUÂUU@al@nyÂ‚XXWWwkÂly@Â¯n@@bnV@k@mVIÂ‚Â„ÂœVlUUmlUÂ„JUwÂ„IÂ‚bXÂƒVaUalÂ@KÂ„b@ÂƒVKVkXVl@VkUU@ylUÂœVVaVL'],
                    'encodeOffsets': [[
                            116888,
                            29526
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4309',
                'properties': {
                    'name': 'ç›Šé˜³å¸‚',
                    'cp': [
                        111.731,
                        28.3832
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„ÂŽÃ†xXL@lÂ‚VÂ„@Ä¢ÂšVIÂ‚bXKl@nVV@Â„XVÂŽÂ„JlbXalXÂ„WÂ„LVKÂšÂ„Â„UVLl@VVÂ„@Ã´ÃžÂ„@@Wn@lLlK@wnIVJX@VX@lVVULÂ‚VnkVVnKValUXblKnXl`UbVLÃˆU@W@IÂšKV@@bUV@LÂš@lÂƒXVÂ‚@VXXblWnLVblb@JnLÂ„VUn@llb@Â„Âƒx@ÃžUV@nU`VÃ”mlXÂ„mbUKUVUV@LVVUnÂ˜ÂŽUb@Â°UXÂš@UÂ‚VzVxnlVÂškÂšVnlVnaWÂƒ@wnIn`@_la@yÂ„kÃ†ÂƒVÂƒÂšUÂ„LÂ„xl@Â„ÂƒXLlmUUVakU@Â¥Ã†wÂšblUUaÃ´VÂšU@Ã…XyVImÂƒÂ™ÂƒkÂUaÄ¡Â¥Ã…UWÂXÂ™ÂƒKmU@LÂÂÂƒa@UmUUÂƒUalan@VUnK@wmÂÂ„mÂ‚L@VÂ„lXLVVl@VI@WX_Â™m@aÂ™Â¯mKUÂkwWÂ¥UK@_UWWLUVkUWL@WUIkVÂƒU@JÂƒwkLUUmJVI@WkXm@VmkKUIU@mmm_@VUVÂ™@Â™Â„kJÄ‹wUU@KÂUWkkW@IWW@Âkm@klwkWVkkUÂ™VÂ¯m@kWLU`mIkmkXm@@`@L@xUKWkU@VL@JÂUU@mbUKVaÂ¯ÂWVnL@`lXUVkU@xW@UbUWVU@UÂJ@Â„lnU@mÂ‚nÃˆmVÂƒa@bULÂ™wUbÂ™@@VkxmUUÂƒÂ™ÂUVÂ›K@IÂÂƒUÂƒmk@akm@wmIÂƒÂŽkK@bÂ™VWXkm@wULUmm@UVW@UbÂ„ÂmbkKÂƒVnÂ„U@WlÂ„xVÂ„U@UXmWUXmlnbUlÂ¯Lmn'],
                    'encodeOffsets': [[
                            113378,
                            28981
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4301',
                'properties': {
                    'name': 'é•¿æ²™å¸‚',
                    'cp': [
                        113.0823,
                        28.2568
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lVUllXkx@lln@Â‚XX@JlXXlÂ‚V@LVVÄŒxlIÂšÂƒÂš@VU@Un`nnV@VJlLUnn@lW@XUJnIVVlKÂ„x@IÂ„VlUVJ@XXKlVVUXKVX@`VLXÂ¦lxVÂŽnLÂšÂ°Â‚an@Â„Â„Â‚bkmVaV@XL@UÂ„KlU@llLXUÃžJWkUknaÃ†xnÂŽÂ‚knK@wÂ„@lÂ„@xllUXUJVVUbÂ„n@blV@bnÂƒÂ‚LnKVaÂ„LVbVVÂ„UX@WÂ¥XKVLÂ„VVklUVyÂ„UÂ„VÃˆÃ…laUKÂ°wnnÃœbnÂ‚VÂ„VLÂ„aVVÂš@ÂšÂn@VmnVlIlJnaÂ„@Valkn@na@amwm@Â„UXwÂ˜K@aUUVUUaVaÂ—wWK@kU@UaW@kKUUÂƒÂƒ@kÂ™WÂ¯XWanÂ@kÂ„Â™mmÃ…@@I@U@KmLkaVUÂƒKkLWVUÂƒk@UVmU@am@kkkÂ¥ÂƒUÂƒVUKÂ™Â„maUb@ÂŽUbÂ™I@aÂƒKkkWmÂ@WÂÂ¯KÂ¯b@VmaULVxUXlVk@UxVJVbUb@xULÂƒ@ULWWÂ—LÂƒÄ•mxÂVVL@ÂšVbÂ™KUwÂƒaÃ…Â²WwX@@WÂƒUWLU@VbkV@aU@@VUnmJ@VUn@VÂƒLUK@UÂ‚mUIk@UÃ‡mÂU@@UW@ÂJ@LÂƒbUmVI@aUmW@@bkXUx@lmLUbm@UbkJ@V@XmlUbkKm@ma@kUaVU@aUKÂ@mImJUIkVÂƒUÂƒVUakbWwka@UWKkLUamKUXm`Ã…_UÂ˜ÂƒÂULmaU@@lUV@X'],
                    'encodeOffsets': [[
                            114582,
                            28694
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4302',
                'properties': {
                    'name': 'æ ªæ´²å¸‚',
                    'cp': [
                        113.5327,
                        27.0319
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XÂ‚Â‚UnwÂ„Ä–Â˜KXXVKÂ„@VK@wVaUaUIVwl@kUVWUwVKnb@UÂ°aÂ°LXÂŽÂ‚@XnllÂ„L@bÂšJVa@ÂVanbÂšÂƒVLÂ„UÂ„V@al@@UVÂ¯Ã…Ã‡@UmmkÂÂ™w@Â¯ÂƒyVwnUVVVUkÂmWVÂ—nKVUÂƒa@WXkVKn@lUVUÂ„VVVXIlVÂ°VnI@VlKnV@ÂmwVm@LXKWkUÂ¥ÂwWwÂƒÂƒ@k@mÂ„X@KXÂ¯V@VUVa@VnKWkÂœÂƒV@VUkm@aWa@wkUWwkmVÂ£VÃ¿XUVL@mVIXaÃ²@nW@aÂšUÂš@@amÂ™@aUUÂ„UmÂXmWUk@ÂƒÂƒnÂUW@_maVmÂ™wUÂkamaUL@aÂƒwÂƒW@akI@UÂƒxUm@kmKUkÂ™lUÂŽ@bÂ„zVÂ˜mÂÂ¯xUVU@ÂƒXVxm`kÃˆlxXVWÂ„@Â¦kVUn@xÂƒxÂƒKUwÃ…KVXUJWnXÂŽmVUxWLÂ„Â¦XÂŽmÂ„mKÂ—bmUUwW@UV@Âšk@ÂƒÂšVLnÂŽlbÂLm`@Â¦VVkX@`WIUÂŽÂxVnlbÂ„WVbXIVÂ‚lI@lÂÂ¦Ã‡@UKmbkÂ™W@UbUVUÂ„Âƒl@n@VmLXb@JWbUnkbVxUJUxWXXlWL@V@V@XXJWxÂ„zUVVVVKnXW`@bkIUlÂ‚Â„nLVJUbUIWVXlWV@XklVbnn@xlÂš'],
                    'encodeOffsets': [[
                            115774,
                            28587
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4308',
                'properties': {
                    'name': 'å¼ å®¶ç•Œå¸‚',
                    'cp': [
                        110.5115,
                        29.328
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@InWVwÂ°wÂšÂ„@ÂÂš@ÂšblUÂœKlUlVÂ„UÂ„@VUUUlW@aÃ¶UlUlLÃž@@aVKXwlK@UX@@UlwkÂƒVkUm@mÂ›@ÂÃ…VÂƒ@akwVaUkÂ›UUlULÂ¯wÂƒÂƒ@UUmÂƒ@UkÂƒKÂƒlÂwÂ±UULVÂn@l_XyWwÃ…@VÂUUmJUXU@@mmÂƒU@kxW@UaUIWbU@@mU@UxÂƒnUbmKkÂ„WJkUVÂÂalÂƒ@aUkUxÂƒlW_@WUIU@ÂƒbkKWUÂJVnUbÂ™bWbÂ„lU@nlÂ›Â„@XnVmV@nÂ—mWV@LXl@XÂ›JXVmzkJUXmÂƒÂ™KULmÂ°Vb@xnVmnUÂšk@ÂƒÂƒÂ™VÂƒnnlUb@nmÂ¼m@Ã›Ã‡ÂƒÂ„Vl@XÂÂ˜mnmÂ„Â²ÂŽmL@xÂ™K@LUl@nULÃ†x@V@VXVWbXXÂ˜lÂ„@nLlm@bVKÂœXÂ‚WÂ„LÂ°bnUÂš@VaVUÂš@ÂšmÂšÂVwÂ„JnwVKÂ°zn@VÂ‚VbÂ„aÂ„@ÄŠÂ¼'],
                    'encodeOffsets': [[
                            113288,
                            30471
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4313',
                'properties': {
                    'name': 'å¨„åº•å¸‚',
                    'cp': [
                        111.6431,
                        27.7185
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lLÂ„ÂnJ@xln@bnlVÂ„Â‚Â„@JÂœLVUÂšÂŽVÂ„nVlw@UÂš@VaÂšxVK@aÂ„bnUmÃ‡nÂV@km@ÂƒÂ‚I@VUVVXVaX@@wlVVUkW@_mKXUÂ°Â‚UbVLnaV@Â‚V@IUKV@XlVL@w@K@_n@lWlnnJV_XK@lÂ°nÂšU@WVU@kV@nbVKÂ„ÂVÂ—lÂƒ@ÂnLlÂƒÂ„LXU@Âƒlmkw@nW@UKVaÂ¯IVÂn@@aVUUKl@nXVKVnÂ²aÂ˜ÂŽXblKnLlmVI@KUU@akLUaVaÂ‚UXm@aÂƒÂ@wVUVKnLnWlXlÂ‚n@@U@anUVm@UÂ‚Inm@IUK@UmKVmU_kVUwm@@VmLÂ—K@VÂƒLÂ™aUaVUUUmKÂƒÂ¥ULkÂšÂƒVWaXwWa@UXImWUaULUUWKk@WnXbWÂŽÂVWnk@UV@bU@@bÂƒJ@bÂƒV@XkÂŽmbÂ™UU`VbkaWzÂƒ@klU@Âƒb@VÂƒwUL@bV@U`ULVL@VUK@Xm@XWWIUbUxm@@lkkÃ‡wÂƒVÃ›Ã‡W@Â¯ÂÃ…Â™UJ@xÂƒIÂ™xÂƒ@@VULmKUnUxmKULUUm@@Â‚ULÂƒUÂ™JkIWJ@b@LÂJUÂWÂ„kJWnUV@nnÂ˜Ãœ_nJÂšxU@VbÂšnUxlÂškb@lÂš@'],
                    'encodeOffsets': [[
                            113682,
                            28699
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '4303',
                'properties': {
                    'name': 'æ¹˜æ½­å¸‚',
                    'cp': [
                        112.5439,
                        27.7075
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã†`n_VWnLVblKXL@VlbXxlaVbÂ„UÂ„VlUVJnInJÂ‚@VL@bUVVb@lnbn@lLVank@W@UlIVan@VanK@kVwlW@aX@Vn@bUJVnÂ„a@KÂ‚IX@@VV@nÂŽVÃˆl@VJÂn@VVLÂ„K@UVm@UnIVm@UV@@blUUaV@XKÂ„V@XW@XxÃ†Â±Â„bVxÂšLUa@Â™UKWÂkÂ™@wmmUalk@WXUWkXUVJVaUImKÂÂƒVklJ@aX_mWULUUVUÂƒyXwWI@W@U@UXKWkXWVwU@Â±_UÂ»ÃKUaÂƒLVbkJkÂÂƒWmXk@UVVÂŽmIUVÂ™J@UU@UamLmwUVU@mnÂJ@VUnmV@b@Vm@kÂkWmXmKULUV@xÂ„ÂŽ@bWnÂVUbVblK@bVV@LUJknmKkLWaÂ—ÂÂ±bUmULmWk@VLUV@bm@UÂÂ°JUbVLX@@mlxkn@Â„WVÂƒKkÂ„mK@ÂkÂ„'],
                    'encodeOffsets': [[
                            114683,
                            28576
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/jiang_su_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '3209',
                'properties': {
                    'name': 'ç›åŸŽå¸‚',
                    'cp': [
                        120.2234,
                        33.5577
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„n@Â‚Â°Ä€ÃžÂ°@Â¦ULWKkx@bkLWb@lUlVXXJVbÂƒnUKmxXV@bm@@XÂšÂ‚Â„LÃžÂšÃœÂ¦XlVnÂšÂ‚mzVJ@n@Â‚Â²ÃžÃ´kÃ†ÂƒÃžaÈ°Ä‰Â‚wnÇ‰ÃœÃ³Â„Ã©VÃ›nÂÄŠÄ«ÄŒÇ‰Â‚Ä‰@Å@KÃžUlU@ÂƒkklÃ‡ÃˆÃ‘ÂšÃ‘lÄ¡XÉ›@UÄ¡ÂƒÂƒaU@U_ÂƒW@nÂ™@kaUL@VW@kKmkUV@bkbWW@bkzmaÂ@ÂƒJWI@KUKULÂƒ@UÂ¦Â™`@XUJÂ™U@KmXÂƒwÂ¯KXkmy@aUIWJXXmV@KÂ¯UU@@bVL@Â¤VLXbV@@JVXVK@Â„Â„JVn@bkKmakVVXUVVVlI@`U@nzVVÂƒb@Â¤n@@UlKXLVVÂšI@V@nV@VÂ‚@ÃˆUx@ÂšÃ³VÅÂšÂƒkÃ…WÃ³@mU@bk@Ãwk@WbXxm@@J@zV@kVÂƒbVÂ‚nLWVUXÂ™WUXUÂŽWLUÂŽÂ@WlÂ°z@VkxU@UVWIÂxWJkbÂƒÄ¬Â„nW@@bUl'],
                    'encodeOffsets': [[
                            122344,
                            34504
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3203',
                'properties': {
                    'name': 'å¾å·žå¸‚',
                    'cp': [
                        117.5208,
                        34.3268
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XKVX@WnIVx@KÂ°Lnll@@IÂ°KÂ„nVaÂšUÂ°xÂ²mlxÂš@VanU@aÂƒk@akmV@@wÂ™@Ua@aUwVwUw@wÂ›@UK@Â£kaÄ‰lÃ³IÃ‡VkÂŽÂ±@@kUKmVkIkxW@UaÂ¯UUm@UVI@WVIÂ„JVÂ@Âƒ@Um@UanaÂ„U@mÂ‚I@J@XV@XaVÂlkXÂƒVaUUWLUyVIXmWak@ÂƒXkJÃ³kÂƒJUL@KWkk@ULU@WaÂ™lUIkJmIÂ™mkÂ„VbVÂš@lVÂ°kXUKWKULUÂ„mb@VUlVnÂƒb@VÂV@IVKUUmU@ak@@bmV@xklÂƒUÂƒU@UÂKmV@nÂƒJVbkXÂƒKUamLUJÂ¯UUVmIÂ™bVVÂ—Ll`@LÂƒLU`m@kXUVU@VÂ„lxUK@xkIWbUKÂƒx@ÂVÂ‚kVVnÂ™bÂ¯@@UÂ™@ÂƒxkÂ‚mbkLÃ‡KÂ™bÂ™@@XnJ@LmVklÂƒ@@XÂƒlUÂÂƒVkxÂƒakVVb@bVnUbU@@xÂ˜VUÂšVb@ÂšÂ„ÂŽnIÄŠ`ÂšXVVÃ´JÂš_Â„K@xlUÂ²KlkÂ„UÂ„@VaVÂVÂÃˆm@kVUVmnamUUaVÂƒXIVJÂ„@Â‚Ã§@Â¥nkVLnÂ›Â„@@XVK@VUX@JVUV@UnVJVLUJVLUVlÂšnIÂ„bÂ‚KnU@mÂ°Â™VanI@anVÂ‚KVLÂ„anÂ„lKÂ„blÂšÂ„KÃžk@Â¦@Â¤@Â„VKnLVKÂ„LÂ„KVzlWÂšLX@VmV@VbnUÂ°@UalkÂÂ™Â˜WXLVUÂ„KWÂkUUWÂšÂƒ@Â£Wa'],
                    'encodeOffsets': [[
                            121005,
                            35213
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3206',
                'properties': {
                    'name': 'å—é€šå¸‚',
                    'cp': [
                        121.1023,
                        32.1625
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VJ@bnzWlÂ°LÂ„xnW@LÂšVVI@WÂš_VÂ¥Â„@VKVL@LXJÂ„IÂ‚@nbly@aXXla@aVUnllLX@@UVKlbÂš@@mÂ„XV`V@Â„bÄ¢Â„lkÄŒÃ‡Ã†ÂƒÈ˜Â¯ÂšwnÄ•VÄ‰VÃ¿ÂšUÆ’UÄ ÂƒÅ¦ÄŸlÂXÃ‘VÇµ@Â±ÅLÊµÄ–Â¯lÃ‡bÃÃžÂ¯xk@Ã‡kÄ·Ã©Â™nÂ¯@ÄŸÂŽÄ¡Æ´Ç«@kVVlUbÂƒL@xULÃ‡Â‚Ã³LUÂlÂ¤@nkVVÂ°VLkxVb@lÂ™aUXUKWÄ–klVX@Â¤UÂšÂƒUkb'],
                    'encodeOffsets': [[
                            123087,
                            33385
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3208',
                'properties': {
                    'name': 'æ·®å®‰å¸‚',
                    'cp': [
                        118.927,
                        33.4039
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÂšnÅºUÃ´Ã’É´Ã¨ÂƒÂšlÂ¦nÄ–VÂ‚kbmÂšÂ„X@xVlVL@xUb@bUJVnUxÂ‚ÂšÂœÂ„lKVLÃˆxÂ‚mÂ„zXV@lW@XVÂ‚b@bÃˆÂšVxnbÂ‚ÂƒVIXaÂ°LÂ„aÃ†VVaXUlK@aXIÃ†Â„VlXKVUlIXalK@alwXLVK@Â¥ÃÂ¯Â¯Ã¿@ÂÂƒmVk@aX@ÂƒmÂ„Ä«laXIÂ‚wXJVUV@lw@UÂ¯yÂbÂ›UÂaÂƒUÄ¡UÃ…aUKVknaÄ¡m@kUm@wÃ†IVÂ±nLÃ†wÂ„Ã‡nUUkÂƒÂ@Æ…ÃUÂ¯JÃIÂ¯Â¦Ul@bÂƒ@@VVL@l@LÂƒLÃ…mÂƒL@bÂ™@UaVaUWmLUKVÂ¹ÂKÂƒLWKXÂ¥WI@mXk@UmaUVUU@VmL@WÂ™bkIUWÂƒUmVÃ³IkbmmÂ™@UbVLUxmJkU@bkJWbnXU`WzÂ™KUÃžÃˆlVbÂ™Lmx@Â„kÃ¨@Ã†'],
                    'encodeOffsets': [[
                            121062,
                            33975
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3205',
                'properties': {
                    'name': 'è‹å·žå¸‚',
                    'cp': [
                        120.6519,
                        31.3989
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã´Ã¨ÄŠVnXÂ°Â¤Â²Â„lxÆ’ÃˆÃœ@Â²x@J@b@XÂ‚`nIUÃ†Â™UUV@bl@VVnL@L@xÂƒJ@X@blJXnW@@`XbWÂ„kVÂƒ@UbVxÂƒXUxkV@LÃ³xVbUVWÂšÂ²ÂšVJÄ¸klUÇ¬@Ä¢Æ³Ä ÂÂ°@ÂšmÆ’Ä«Â°Â»ÃˆÂÃ‡Â¥ULUUÂ±a@bU@Â¯ÂÂƒU@KnImUVWUkÂ™mXUVU@ÂlIVaUUÂVWKUbUkWKUÂ¥nÂ£WakJUkULÂ›KÂ¯LÂ™KkÂƒVIn@VaUÂƒVUUÂƒÂ›UkVk@ÂƒU@amUkJÂƒ@UUlwXÂ¥W@@UkVmk@JUakLÂ›@kkÂ¯ÃmJUn@nmVXlmbVVkn@Â„UJ@ÂÂ±WUxVÂÂ¯aÂ¯KÅbÃ…Â¼Ã‡xUxÂƒÂšUÂUlWL'],
                    'encodeOffsets': [[
                            122794,
                            31917
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3213',
                'properties': {
                    'name': 'å®¿è¿å¸‚',
                    'cp': [
                        118.5535,
                        33.7775
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XbWnUJVzXKVVUbWÂ„klUÂWbU@@W@IÂJ@nÂƒVmbVbn@@V@Â„UÂŽÂƒIUJ@XUJ@VVnÂ°VVbX@lwlJnUVL@lÂ²@lÂÃˆUÃ´JÄŠklb@Â¤VLÂœ@@xVxUxVx@bVbÂš@@xU@lnÂ„mnXÂ˜mXLVmV@X@lxVnVJÃ´LÂ„LXaÂ‚x@bÂ„@@KVL@bn@@m@Â™@alLUUVaUÂ¥nIVÂ±Â‚I@mXI@aWWXU@LlUXWW_XWmaUwÃ‡Â™@aÂaWUX@@kWUÂƒyÂnÃ‡wUKkLÂ›ÂƒÂÂ™VwUmVI@aVa@wUKUk@wÂƒWnÂ™laUÂmÄ•kÂ¥Â„Â™É³Ã§Ã³Ã‘Å¹VÂ™mmzkVmm@a@IÃ³Âƒk@@LWU@`Â—Â„WbXLWlkImJVn@`nXVbXÂŽmL@Vn@Â‚l@nUVlÂ°XxÂ°U@LVÄ @zÂ°Â˜@Â¦UV@Xn@VJmV'],
                    'encodeOffsets': [[
                            121005,
                            34560
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3207',
                'properties': {
                    'name': 'è¿žäº‘æ¸¯å¸‚',
                    'cp': [
                        119.1248,
                        34.552
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@Â‚lzXxmÃ†VÂ„Â„@@Â¦Â„@l`XnlKÂšXXmÂ‚KnLlaÂ„bÂ„@Â„xmbm@kL@V@Vl@@VUXÂšJXÂ„mbÂš@@Â„Â°Ã†@Ã¨ÃˆzlWÂ°XÄ¢JlÂÃˆ`lInbÂšWV_@mÂšÂ™@UUÄ·nÂƒÃ´wÂ°ÂÃ†mnaVÂƒVÃ›VmÄ¸Â»Ä¢wÂ±Ã@Â@mUInyÂ™ÂUmWkÃ›Â¥ÃÂ™ÂƒKÂ™Â@Wn@@aWUnwVLÂ„mUaWIUWVk@kkJUVWLUkÃ…ÂƒWJ@bkLWVUbÃ…UÂƒbÂ¯KWbUJÂÂ„WXX`WXkV@KWVXX@bWJ@nÂJUÂ²mJVÂ¦UbVVkK@b@Âš@nm@@aUK@LÂƒ@@aÂwWbÂƒKÃ³KUIUmkwW@U@UnWKÂ—nmWÂƒn@bÂ„l@bmVUbÂ™@kwÂ±nÂ¯wÂ™VUb'],
                    'encodeOffsets': [[
                            121253,
                            35264
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3210',
                'properties': {
                    'name': 'æ‰¬å·žå¸‚',
                    'cp': [
                        119.4653,
                        32.8162
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VUXblVVVÂ„b@xV@kzÂ„V@lÂ‚wVLUbVV@VU@VbUbÂlÂ‚b@nkÄ¶Â°IÃžV@Æ†Â„ÂVlmVÂƒÃˆÃ…xmKUÂ²Ã…J@xVn@lÄ¢nmbUlVLÃ†bÄ¢VÂ„VÂ‚bÂœVÂ‚aXkÂ‚@VÂXKVÂVWÂšXVWXUmKUÂÂ„aWaU@Â™Â¥@Â£XWÂ‚UUÂV@@ynam_VWkUVUna@ÂÃ†V@mnkWmXkWUÂ„W@kÂ„@@akklÂƒlWUI@UnKlÂ¥Â™I@VÂVma@a@I@U@a@anK@UmK@Ã…VUnJlÂ™kI@aVwka@mVIUW@UWL@WÃ…bmIÂƒÂƒULkaÂ™UWÂƒUxkLUKWlXL@VÂƒImÂƒÃ…VÂƒUÂ™mÄ‰LÂ™UÃ³lÂ¯IÂ±l@Ã’UbVbUVVXUJUnVV@lnbl@'],
                    'encodeOffsets': [[
                            121928,
                            33244
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3201',
                'properties': {
                    'name': 'å—äº¬å¸‚',
                    'cp': [
                        118.8062,
                        31.9208
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@k@ma@kUUVmVIUWVUUaVa@Ã‘Â²kÂ°JÃ´k@WmkÂ¯KmXÂ¯aUakKÂƒÂƒWUÂ„@XUÂ‚LXaV@@mUaVÂUUl@VmkaUXm@ÂƒWUUnaÂ°IlÂÂÂmVÂ™mÂ™IUWÂ‚Â@Uk@@aV@VVX@Â„VÂ‚IÂ°Â»nmÂ„U@ÂVKVan@mÂ»UaU@U_@WlIUaÂ™aVaUala@Â¯n@Â‚ÂƒkaUkUUWKU@mwkUUmmL@KÂ@ÂƒLmUUVÂƒKÂƒVÃ…ImUÂ—JÂƒÂÂƒVkVVLÂšÃ¨VLVU@WÂ„LÂ„VÂ„Âš@nVÃœULVÂŽUL@bW@XbWbkJÂƒUUVUxVXmVk@WÂUUkVmIÂƒV@Â„nbnVWbÂƒJUÂ„kUULÂƒa@Jma@XkK@VVL@L@JÂƒLUVU@VÂ¼ÂƒnXlÂƒbm@kbUKmn@lVb@VXXVÂ‚UV@b@LVbÃ†xXbl@@lV@UÂ„VV@XVKÂ²VlIÂš`Â„ÂUbVbUlVVn@WXn@@VUV@Â„@KmbVLXÃ’Â›LkKÂƒV@nX@VVUV@bÂ™nVllbÂšmnbÂ„IWVXU@`lLlknVnmlLlbUmVInKÂ°nUÂƒU@l@VU@Vn@Â„Âƒ@alIÂ„`VIXaVaVa'],
                    'encodeOffsets': [[
                            121928,
                            33244
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3212',
                'properties': {
                    'name': 'æ³°å·žå¸‚',
                    'cp': [
                        120.0586,
                        32.5525
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lUU@@y@In@WwXal@Ãžxl@@anVÃ´@Ã†XÂ„lÅŽÂ™Ã´U@Â™Vw@Ã‡UÂU@@m@UÂ™JUUWKkL@Vm@@Â£Â„aUUmyV@@_kJUUVUUWlUnblL@aUmÂƒI@ÂƒULUW@IU@WaUK@Â£UK@aV@Â°V@LnUWWXIlaÂ„VVÂ™@Â£UWlkXÄ•VLVWÂšb@kUalwUKUÂ¯lU@mkÂ£VÂÃ´KÃˆÂVK@wÂ„KVaUkÄ·lUIÂ±Â™ÄŸÂ¥ÃUÅ¹ÂšÂ™ÂŽÂ¯Ã´mÂ¦ÂƒÄ¸Â™Â‚@XXK@VVXUJ@nlbUx@blJkÂšmIUV@Ã†nL@VmL@b@b@V@J@bnbÂ‚U@UÂšJkÂ¦mL@VVJkXkÂ„ll@bÂƒ@@lÂƒXXVWlXnml@nÃ…U@ÂŽmbUVlVUXn`mb@zU@VÂ‚ÂVWX@Â¤ÂšÂ¦V@Xb'],
                    'encodeOffsets': [[
                            122592,
                            34015
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3202',
                'properties': {
                    'name': 'æ— é”¡å¸‚',
                    'cp': [
                        120.3442,
                        31.5527
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nLÂƒÃ’lxUVkLÂ™am@Â™ÂƒkVWUULUxVVVbUV@bVLUÂ‚nnÅºÂ™ÃžVÄ Â¦XÂ™VUUaÃ´w@KlUVwÂ„WUwVaÂ„@lUXÂƒWa@_X@WmkI@a@WÂ„I@w@KmKUUk@@aVUÂšVVÃ…mJÂ_@W@a@IÂ±wÃ›@Æ‘Ã‡kwÂ±ÂƒÂ¯Â£mWÄ‰UÃ³Ã§ÂƒKÂ¯VkUWK@XkVÂ¯UWaÂbÂƒmUaÂ™UUbÂ™lln@b@xÂƒbXÂŽWÂX`@Â„VxUblL@bn@Vb@`m@XbWnn@lÂ¤Â„n@xnVlUÂ„Â™VLÃ†WÂœkV@VbÃžJÂ‚_nÂƒl@nKVU@aUÂ™UÂ@mVkÂ°WVLUVÂ¯bVÂXÂŽÂ˜bXlVn@VmL@xÂ—V@blÂ„ÂšÂ‚@ÂœnW@X@VVJ@Â²VJVU'],
                    'encodeOffsets': [[
                            123064,
                            32513
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3204',
                'properties': {
                    'name': 'å¸¸å·žå¸‚',
                    'cp': [
                        119.4543,
                        31.5582
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„LÂ˜ÂŽnxUbVVÂƒL@xnnWÂ‚nn@VVXn@Â‚yÂœImxÂ„Â„Â°ÂƒÂšLÂ„aÂ‚Â¥n@VkÂšKVwÂ„W@nXÂ„VJ@bÂ‚@UVnÂ„Âƒ@UnUV@LÂ‚b@`VLklVÃžnÂ„Ã†@VaXLlÂ™ÃˆJÂšÂmmVÂUK@aVUUaUUVwVKXVlUÂšÂ„n@ÂšblKVUkwÂ„Ã‘mKUVUI@Â±UI@U@WmX@Â›Â™ÂkÂƒ@aÂ˜U@wnK@UUmWkÂ—aWÂUÂÂ°aVUUKÂ¯XUl@nVÂŽVÂš@bUVmLk@mÂ„Â`ÃIUaU@Â›lÃ…XUKÂƒÂškVmU@wÂƒmkÂ£m@XmWan@@_Uam@@akKVaUw@ÂƒW_XÂWÂÂ„a@w@akmm@mL@UÂJmnUKÂƒ@@XnJWLkKUb@Â„VxkÂ„WÂÂƒLÂ—aWVUImVULUK@L@lkLVVVllbÂÂ„m@@Â°kbVbUbÂšbVbkJ@XV`V@VbnÂ¼'],
                    'encodeOffsets': [[
                            122097,
                            32389
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3211',
                'properties': {
                    'name': 'é•‡æ±Ÿå¸‚',
                    'cp': [
                        119.4763,
                        31.9702
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÂšVÄŠKÂšnÂ„VÃ†UnÂ„Â„J@UWKXkVLlKVwXÂ„ÂšVlbVKÂ„Â„nJÃ†aÂšÂÂ„Ä·nÂ¥Â°Ã³Ã‡IkÂšWKUbÃ…@mÂƒUÃlkUK@_Âa@KVUVmÂ„@mÂƒVUÂ@@aUIWÂƒ@mÂƒXUxÂ™LUlm@ÂÂ¦ÂƒbÂ™KÂ¯Â„ÂƒÂƒnwÂ›JÂzm@UW@UmmXÂmm@wÂ„KUUVamwÂ—ÂÂƒKm@UbUL@ÂŽÂƒVmnÂ¯Â¼ÂJÂƒUW@UUU@@bl@@VÂÂŽVXÂšJÂšnnUÂ‚Â‚kÂÂ¯JmbVVÂ„Xn@VWlbUnk@VVUÂŽVb@nU@WbÂKWVÂƒ@XVÂ„Â„lLVbÂ°bnWÂ°Lnl@X'],
                    'encodeOffsets': [[
                            122097,
                            32997
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/jiang_xi_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '3607',
                'properties': {
                    'name': 'èµ£å·žå¸‚',
                    'cp': [
                        115.2795,
                        25.8124
                    ],
                    'childNum': 18
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„`l@ÃˆblnÂ„@Â„KVLl@Â„V@bÃˆÂŽlnÂšKXkVlVL@Â„lJnbÂ„Â¦VKVVnXÂ„W@wÂ°@VUÂ„mlnÂ„UV`ÂšUÂ„bVUV@Â„xnKVIÂ°KXKVkVL@al@XaÂ„LVlULWVÂ™VVL@bÂ„x@VXVmb@x@VÂ™ÂVV@nnÂ¤Â„ÂšlbÂ°bÂ°KXXWbX`lbXxÂ‚z@xÂ„`VIVUnKÂ„LÂ‚xÂ„WXLVKVbVLVU@wnWÂ°bÂ„@nalXÂ„Â‚mXVJn@UÂ²mKkVlÂ„U@@xlnÂœaVmlKnÂœ@JVLlÂŽnVÂšÂšl@XXÃ†Ã¨VlUX@xVLXVÂšbÂ°W@wnUWmXk@KÂ‚LVwUmUkUKUw@wVaVK@kÂƒÂ@WnkUKWÂkwlmXL@KVUlLVKXmWUÂ„L@aÂšL@mÂalaVk@aÂaÂ‚aÂšÂƒnXÂš@VVUblbÂ„JnÂÂ˜ÂƒXaÂ„VÂ‚wnÂ£Â„K@UWmUk@ÂƒUaWIÂV@bÂ™JWÂ@KÂmmU@aUUUkmKkÂVKlUUÂ™nKVUÂ„lVaVÂ£Ã…Â¥WUUK@UkUUw@Âm@mIkÂƒÂƒUUWÂƒLÂƒKÂ¯ÂUwÂ°Â¯@wUKUbÂƒKmÂƒ@kkKUL@UUKVÂ¥U@manw@k@U@Wm@@ÂU@WwkmÂ„wWaUU@UUmVÂ¯kwÂƒ@@kmÂƒkKkUW@UK@Ã…V@XWWkXa@Ul@Va@KVaUUU@ÂƒaXwla@UkVWaXk@K@ÂlmkUmV@Vmbk@ÂƒÂ»XIÂƒÂ¥VUkÂƒVUVU@anKVUÂƒKUalU@wX@Â˜Â™@a@KÂ—@ÃwÂƒL@ÂŽUnÃ‡lUIkJmn@ÂŽÂƒbVVÂb@VmnkLÂƒVÂ¯U@ÂƒÂ±lÂ—IWmÂƒ@kaUI@aÃ‡U@K@KUIkbWbÂƒJUIUyÂƒXÂ¯ÂƒUbU@mÃ©UUmUkÂ„WKÂ—xWIkJm@VÂ¥U_UJUwmVkÂšÂƒUU@ÂƒÂƒÂƒ@knÂƒwm@UmÂkWJkL@n@VW@@Â‚U@knm@kUml@xÃ…xÂƒ@@XUJlbÂ„@VXÂ„JVxn@lbVÂ„@lULnV@VlÂnV@bWV@bXL@lVLVbÂ„V@blLn@VlÂ„K@xln@bX@laÂšLVbnKUVVbÂ„KlXVVkxÂƒV@nnVUbÂ‚lV@@zÂ—Â°WWkbÂƒIkÂ‚WL@LUJ@bUI@bÂ™`@UmI@mkKÂ¯XWÂ™Â™mUVÂ¯@UUVUUam@@VULWUÂJÂƒIm`ÂIUJÂ›ÂÂKUkW@UxnÂ‚WbnnmlXbmIUVmV@Vnb@VÂ™LUKWLnÃ’VVV@VÂ„UL@Â„kJUV@bÂƒÃˆ@ÂŽÂšÂVÂ°ÂšÂŽ@XVV@l@xUz'],
                    'encodeOffsets': [[
                            116753,
                            26596
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3608',
                'properties': {
                    'name': 'å‰å®‰å¸‚',
                    'cp': [
                        114.884,
                        26.9659
                    ],
                    'childNum': 12
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lxnb@V@bV@ln@Â‚nÂÂ„Â‚lInÂš@blVXKÂ‚nkÂ¼@VUKWL@bÂ™L@`UXU`Âƒ@VÂ¦XLÄ @lJÂ„Â¦@Â„nV@lÂ°nn@Â‚mVXnaÂš@nbÂ‚KÂ„n@lÂ„IVÂƒÂš@VanJ@_lKVVnÂšÂ„L@LÂ‚K@Vn@VbÂšUVanKlLnbnJVbÂšnWVnVVanI@Â‚Vb@LÂ„bVKVanXVbVJVU@aXLllÂ„bÃ´lÃ†Â¼XxVLVK@Xn@ÂƒxnVVVmb@LnVVKVXV@@mnaVXUVnVÂ˜K@_UaUmÂšwnKV_Â‚anKVLÂšÂ»Â„K@ÂÂ¯ÃU@Â›Â™UÂ@ÂkWlUnÂ™lknKÂ‚VnaUkma@ÂƒUIUwlÂ»Ã…w@ÂƒVwV@nÂ™Â‚Ân@ÃˆXlKVmna@kVw@anmÂ‚@n_WWk@Â™Â™mUkÂUK@ImÂ›kLUnÂ›bkm@wV@kÂƒlUnLVÂ±m@UInWÂƒÂkWmbÂƒ@Â¯amX@xUVUKUaULWKÂƒXÂwÂƒKmLUVUJÂƒ_@wÂyWwkaW_XaWWÂ¯LÂ¯akaÂƒÂ™mÂ£@mUUÂšÂ@U@wnaWU@UÂƒw@aUKÂšUXUVKUkÂƒKWbk@@bUKUlWLÂ¯LUJmLÂƒwU@UVÂƒaÂ™VU_ÂƒVkmÂƒnUVÂ¯@@xÂƒXmWUUULÂƒÂ¥makI@ÂƒUKUkWlÂ™LkmÃ‡Â@aÂƒUk@UKÂƒLÂƒ@kmÃ‡ak@Âƒ_VlkL@`lbnÂšlLVanLnbmVÃ†ln@ÂšÂkJlbknmKUbÃmmwULUK@bkLWKULUUma@Kk@UV@L@llbVzÂšxUxnl@bVLmÂŽÂšÂŽ@IVJXÂœVlÂƒLV`@bnÂ²@JÂ™@Â™V@XmbÃ±@WbUJ@bm@@LUÄ¬UÂ‚Â„Â¦lV@xXb@blnUV'],
                    'encodeOffsets': [[
                            116652,
                            27608
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3611',
                'properties': {
                    'name': 'ä¸Šé¥¶å¸‚',
                    'cp': [
                        117.8613,
                        28.7292
                    ],
                    'childNum': 12
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„Â„@Â„VÂ‚ÂšÂ„Â„IÂ°`nÂmÂ¤ÂÂ²@bVJUVVXUl@Vmb@xV@XbmVVÂœ@lkLmbn`VbnUÂ‚@VaÂ„UnbVllUXVÂ„a@wÂ°ÂVW@_VWÂšLÂšÂšnVlbÂšLVbnlÂ„KÂšnVK@IUW@_@am@ÂÂ™Â‚Ã‘UÃ³lK@U@WU@VwU@UI@aUUÂ‚aXÂƒÂƒ@kwmJVÂ@yXÂ@kÂ‚anÂƒÂƒÂ@mkwVmmI@aUU@aUUW@kÂVkV@@anKÂšÂ»Â„XVWnIVUl`@_Â„W@wlUÂœV@UWKnUÂ‚bnÂŽÂ°InJlÂ„UV@VnIÂ‚bÂ„Wn@VklL@l@VnÂ²m@U`kI@bWJÂƒÂnV@Â°VXnJmÂ„XVmx@VVL@bkLmWULUmU@ÂƒbWÂXb@llnX@Â‚xkxVVÂ„nVV@Â¤nLÂ‚nVxnJVXX@Â˜ÂšÂšbn`VIÂ„bÂ„@Â„blmlLnaV@Â„blWXnlUnbl@Â„ÂƒÂšKVanUVmm_XK@kWWnaÂšU@UnaWUXaÂ›ÂƒXamUkKmXUWÂƒLXÂ¯WakKmÂ™nUWwXa@KW_Â„aXWW_@WnIVÂl@XUÂ‚LnWVknK@ImyUUÃ†bXKÂ„Ã›@W@IÃ†UnÂƒVÃlkVK@mUIVwkUVaUm@aVIVyXIÂƒaÃˆwmÂmk@UnanÂVUmÂÃ…aÃ³Â»lwÂšW@kkUVmUK@ÂWKÂLÂƒUmWULkamKÂ™Lk@Wa@wk@UU@ÂU@mbUIWVÂKUXWmkUmVÂmÂ›U@LkakKÂƒw@w@UÂ™Â¯ÂƒÂ‚ÂƒUUnÂ¯l@bmn@xkJWxkL@VkI@mÂƒkmJUI@V@b@VVxnbWlkÃˆkVÂƒLÂƒbkKmVÂƒL@V@Â²nxWÂ‚kLUL@xlKVxÂ„bXÂmVnÂšWJ@ÃžÂ™Â°@nÂ™xUKUwÂ±ÂÂ`UImVmnU@kalm@akwÂƒU@UUJmxU@@UÂƒ@kU@Um@@KnÂÂ™ÂƒVm@kÂ™KmkU@@WUnkLWxkVUwmKmLkUÂ™bmKUbVÂŽ@xUnkJ@nÂ±ÂŽÂÂšUxVXUÂšWJ@LUbÂ™lUnm@ÂƒW@nknUJUVm@kXllknVbÃ†KÂ„VVbÂšÂ¼VÂ„@ÂšUl'],
                    'encodeOffsets': [[
                            119194,
                            29751
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3604',
                'properties': {
                    'name': 'ä¹æ±Ÿå¸‚',
                    'cp': [
                        115.4224,
                        29.3774
                    ],
                    'childNum': 12
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@WUkVUkmaÂƒVUbÂ@mVUam_nalK@kUÂ›nUWaU@@wna@UVkUWVUUI@aÂ‚Â±nÂ£mÂÂ¯_ÂƒJÂ™ÂƒUÂ@ÂƒÂƒÂƒÄ‰Â¦Ul@ÂUVÂ™KmÂ™mLÂlm@ÄŸÂ¹m`UkÂ¯@@UVKÂ¯Â™@UUK@amkmKkVVÂUa@UkUÂƒKÂƒÂŽUaÂ™L@VVXUJÂ™@ÂƒnÂƒ@Â™ÂšÂ™WUbÂƒnVbÂ¯V@LÃ…lÃIÂƒJÃ…kÃÂ™m@UaÂ™WUU@UmUXmmwVÂUUÂKWUXÂ±mÂUam@kWÂƒzUaVmÃ‡w@aÃ…LmKÂXÂƒÂ‚UÂWKkL@WÂ¯IÂƒwVwÂ™lkUÂƒJ@Um@Ã›ÃˆWÂŽÂKUxWkÂƒaUU@KkLVl@Â„UKUXÂ±KUb@nVVUbUVmaUlUL@Â„ÂƒaUL@Â‚@nUlWzX`@Â„V@lxÂ²Â„@Vlb@bÂšVÃž@Â°nl@UxVL@lUbVV@nÂ²xVUVmnUÃžbÂ‚aÂ„J@IÂšVÂ°xnbl@nbÃ†@VwnK@VnXlKÂ°xnUlVXÂ„V@Vl@L@lk@W_XK@KÂƒkWxUL@JÂ„nVx@aX@VVUaÂ˜IXlmL@bVVX@VbnKÂ‚aÂ²XVWÂƒkÂ°aÂ„@UnVÂ¤nbmLmW@ÂXbmJUbVLÂ„aÃžKÂ„L@K@U@aVKlbV@nXlJÂœxV@VnÂšÂŽVÃˆÂšÂ„ÃžKÃ´bÅºÄ•ÄŒmV@ÄŠÂÂšÂŽÂ²xÃ†IÂšÂV@ÃžÂ¦Ä¸Â¼ÃžVlÂŽVÃžnxlnÂ°JÂœkÂ‚LXWVUVUVwnJVI@yn@lXlaXmWI@wÂ—Â»ma@UmK@akKkXmW@_kaWakKWÂk@@K@IÂšWÂƒkUaÂ„Âƒ'],
                    'encodeOffsets': [[
                            119487,
                            30319
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3610',
                'properties': {
                    'name': 'æŠšå·žå¸‚',
                    'cp': [
                        116.4441,
                        27.4933
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â°VÂ°UnÃœ@n@lnLlV@bÂšVÂ°LÂ„lnLllVzVVXlVÂ„V@@L@xX@WlXÂ„m@UVÂƒL@V@nÂ„Â°ÂškVmVUnKlaXxVbÂšnlU@lVVnaVI@aX@VÂ„ÂšJÂš@VÂ„@bÂ„b@ÂšVbÂšÂ‚@X@lUL@ÂŽ@VlIVm@wUÂVanLÂšalVnKnLVxlUXwlKVm@k@Una@mWIXKWUÃ›VÂƒk@a@UVWn@@kl@@WÂ„XlW@_Um@UVK@aÂ„LnalInWV@@xnI@Â¥Â‚KÂ„Â—Âšm@ÂkKmÂƒnk@mlIÂ„Â¤laXbVblknV@UÂ‚KXVlUXaÂ‚@@Unw@Â±mU@ak_Â±a@ÂƒUJUIÂƒVÂKW_Xa@aWUÂ™ÂšÂK@mmUVa@IXa@UWmÂšannlmXÂ¯WKXwVUVwÂƒÂ@ÂXUlK@klJXa@kÂƒÂkmm@UwÂƒw@Â¯ÂƒWÂ¯Âkw@WmbULÂƒaUUU@mVUUÂ™WmkUbÂ™KmkkK@aÂƒkUÂƒÂ¯Â¥UÂƒlÂ—Âƒm@akU@mÂšÂ@KVIVV@KUkUÂVUkaÂƒUWbÂ—Â„mÂÂƒIkaVaUUÂ™@mWÂ™Â„ÂbÂ‚b@bUlkbÂ‚b@nÂ™K@bÂƒKXVWnULkKUV@LWKknlxXÂŽVLml@XÂ„ÂŽ@lULUb@xVxVLVlVnUxÂK@LWlXnmV@xÂ¯XÂ™aWUUK@wVWUkÃ…Ã§m`Â@mn@bUx@lmbUnkLÃ‡Wm@ÂÂmÂšU@Ux@Â„Ã†xkÂ¼VxVJ@Â„nbVlmbÂUmLklmÂškVlX@Â‚VÂÂœÂšV@Â°Ãž'],
                    'encodeOffsets': [[
                            118508,
                            28396
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3609',
                'properties': {
                    'name': 'å®œæ˜¥å¸‚',
                    'cp': [
                        115.0159,
                        28.3228
                    ],
                    'childNum': 10
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@VlbnK@b@JÂšLlUnxÂ±Ä€XxÃ†WÂ„X@lÂšÂ@VÂ„@@blJ@nX@Â˜xUbVVUbVV@bÂ—VmnmJÂœÂ„@bmbm@klUbÂƒLmbÂœÂš@lVb@xUX@bVVVbVÂ¤@LVVÂ„bXlVwÂ‚LXÂÃœÃ‡n@@VÂ„IlVÂškUxÂ„xÂ°J@XlKXLVÂÂ„ÂÂ‚WnLÃ†K@bÃˆxUnVbÂ„ylXn@VbnÂ‚WÂ²XVÂ‚LVVUÂŽnxWnnV@VVVÂšXVbn@ÃžÂšÃ†lÂ„IÃžJÃ†k@KÂ°UUaÂ„mVa@UUUÂšÂ»@wV@VÂƒkkUKUVWÂ£U@UmW@@aXkVUnVlKVVÂ„UUkVmUÂ™@kWaUanUÂ„VVamIXÂ¥W@@aUaUÂVW@_mW@UnIVVn@VbVm@bVL@anKVUkÂƒWKÂ„UXVÂ‚IkxÂ‚@naÂ„bVKÂ„b@nVJÂ„_VÂ›@ÂVwÂ„Â‚VUVVXUlUUaV@X@VblaÂšbnKlkVaXaÂƒÂ¯@m@UÂ„KVUn@WÂƒXkW@@w@KU@UÂƒWkUUUykkmKÂƒkÂ¯KÂ™U@akUmK@k@mmÃ›Â¯VÂ¯U@Â‚ÂƒLÂ™Â¼UKmLÂbU`mLÂ™xVnVb@`Â—LmUVUUWmb@nU@UWULmU@KnaUUmUÂ„wmJÂ¯IUJWIkVkaWVUIUlWaUIUVkKmbUIÂƒÃ’lVUnnÂŽ@VlLUJ@bUXÂ¯@ÂƒaWVUKUXÂƒKUbm@UwÂKWa@a@VkUWnÂ™@Uak@mbXÂ„WJXbm@mLÂ—aWVk@Â™wÂƒL@WmanU@knwWmkaWLÂ—KWUXaÂƒU@Â¥lÂÂ„UVVVbnwÂƒÂ¥nKVÂÂ™Â»@aUk@a@UÂƒJ@kÂƒmÂLmaÂ™@mbUWÂnm@ULÃ‡Âº@LXnmxUÂŽm@UbkbW@@akLmWk@UXmJmUkV@VUXVlULmKUxkL@lmXnJ@XÂ‚lÂ°Vnb@bU@WbÂKUX@VmKUX'],
                    'encodeOffsets': [[
                            116652,
                            28666
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3601',
                'properties': {
                    'name': 'å—æ˜Œå¸‚',
                    'cp': [
                        116.0046,
                        28.6633
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÂšXÂšÂ™Â„@Â„mÂš@VIUW@UÂšKVbÂ„ÂÂ„LlV@VVbUÂŽlUnLnl@bVL@VÂ°ÂšUL@VÂ°@Vln_Ä Âºn@Â‚knKnÂšÂšLVU@ÂVkÄŠÂ¥Vk@Â™UÂƒÂ™Â»UaÂƒUÃ…LUalmkklWn@VUVIlm@mÂ„Xn@VmÂškVa@KXIVÂ™UWVwÂ‚Â™Â²Â@m@U@ÂVK@k@WÂ™ÂUa@Â™Âƒa@aUÂƒÂ™@Â™IUÂƒW@@bUJmbUU@kkVÂ™mUaWwkbmLUVUnÂ™lWbUbklmLÂ™akbUaW@U@VbkVWVUUUVÂƒÂUx@Â‚UÂœÂƒ`UI@mÂƒaULÂƒambÂ@lwÂJWUÂƒVXLlÂ„UVmL@bUK@aUnUam@UUmJ@VnX@`UXVÂŽVb@bX@WÂ¦nJUbÂƒUmVVbXb@lVÂšUnVlÂƒVUUkLmUUVWl@bX@VnV@XÂ¤VUVLllUÂ„U@@xÂ™Â¼VV@V'],
                    'encodeOffsets': [[
                            118249,
                            29700
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3602',
                'properties': {
                    'name': 'æ™¯å¾·é•‡å¸‚',
                    'cp': [
                        117.334,
                        29.3225
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VVX@VbmzÂ„xUlU@mbmL@VÂ²xVbUVVblbX@ÂšVÂškVykÂValKVI@bn@n`lÂVWnX@lÂ„L@Â™WKnÂƒVIVa@Â¯nK@alIXJVIVWUwÂ‚Âƒn@nUÂ˜Â„nK@alI@a@anKm_Â™aÂ—Â™W@UWmIUwÂmmK@Â£UUÂƒmUUlwÂwW@km@kWaXÂÂ„aV@VnVKnXlK@aUK@UnwWUnÂƒmIUW@Â¯mUÂ„ÂXI@alJV_n@mÂ±@U@kkKUlm@ÂƒXÂamJ@UVUkÂƒmIÂ¯JmÂÂamVXL@VÂ›UkV@xÂƒX@`k_UVmJUXÂƒWÂ™Â¼mL@bU@UllÂX@VV@bVV@bnJUnlx@nÂ„ÂŽmÂ„Âb@lWÂŽ@zUÂ‚nIlxÂ„@WÂ„ÂbVV@bVJV@UxV@@X@VkLVÃ´ÂÃ’Â‚Âšn@@b@`VX@J'],
                    'encodeOffsets': [[
                            119903,
                            30409
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3603',
                'properties': {
                    'name': 'èä¹¡å¸‚',
                    'cp': [
                        113.9282,
                        27.4823
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VWnL@UVWÂ‚LXaV@@amaÂ¯UÂk@WmInW@klKVwnLVKUkVW@UlUnVnIVWl@nXlK@bX@laVan@VÂnwWm@KÃˆÂ¹VKÂ¯m@kmU@ÂƒÂƒÂ¥kIÄŸ@WKUÂ¥Â„@V_VW@_ÂšK@aXKVL@UlÂ»ÂmWLkU@amÂ™kJÂƒÂmÂ@ÂkmU@@a@UmakwU@Â›Â„XlÂƒ@VXk`UIWÂ¼kWWX@Â‚ÂœÂ@lÂ‚xVÂ¦XlW@UbnÂ„@ÂŽmUkL@UmJÂ¯UkUWVUaÂƒUÂlm@UXWlÂ„nUJ@LmLUÂ˜nXll@bUVUUmVUnÂ„ÂŽ@Â¦ÂšxlÂŽnn@VÃ†ÃˆUÂ°kbVÂ„VxllnL@VnVVUl@VÂ„Â„anL'],
                    'encodeOffsets': [[
                            116652,
                            28666
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3606',
                'properties': {
                    'name': 'é¹°æ½­å¸‚',
                    'cp': [
                        117.0813,
                        28.2349
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@XV@nlÂšL@lUnÂšÂ„mÂŽ@Ln@@VlVÂ„@@VV@nwVI@VÂ„Vlx@bknlbV@nmnUVJÂ‚_Â²Â‚VxVLÂšw@mÂšÂ¯@ÃXImÂ™nUWÂÂƒaUwkL@wVKlKXÂmw@Â±@UÂ„KnUlLÂ„aÂ„KlUlÃ‡XkmaUw@U@a@UÂƒÂÂ™UkwUJ@zWJÂ™wÂ@WbkVWUÂL@VmUklUaWakbÂƒÂ£kJ@nmlnÂ„lL@ÂŽÂ™nÂƒÂ˜ÂL@Â¦mJ@wU@mXkJmbÂƒK@bUL@VVn@`kXÂƒW@Xk@@lm@UX@V@bÂ„lÃœUXVWLXJ@nmb@V@l'],
                    'encodeOffsets': [[
                            119599,
                            29025
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3605',
                'properties': {
                    'name': 'æ–°ä½™å¸‚',
                    'cp': [
                        114.95,
                        27.8174
                    ],
                    'childNum': 2
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@m@@WULUKWwÃ…Â»Ã³kÂƒakkWK@bUVUIUamWUbULÂƒa@KUa@ÂmJUbmUXUÂ™mUamImakKmLUbÂ™VUam@@UÂL@KÂƒKmÂ™UUkL@`mIUbÂ™@UÂ„@V@bVl@bÂšÂ¼UÂŽmLÂ„Â¦mxUaUUÂƒVkÂŽ@Â¦Â„VWbXVÂ˜LXKlbXnmx@lmVnb@XÂ„KÂšxl@XUÂ˜bnKn@WaXIWÂƒnal@VbÂš@XmlV@U@bXbÂ‚LVxn@VaÂ„LVWVLXUÂ„bÂ°@VW@aVIkK@UmÂVmkUÂ„Ã‘VJnalLVUVJXbVkVJXUlblUXJVIÂ°JnI'],
                    'encodeOffsets': [[
                            118182,
                            28542
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/ji_lin_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '2224',
                'properties': {
                    'name': 'å»¶è¾¹æœé²œæ—è‡ªæ²»å·ž',
                    'cp': [
                        129.397,
                        43.2587
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@WxÄµÂ„mÂš@Â„Ã³Â¤VÂX@@xÃœÂ¼Æ¨ÂšÂ²xWxÂƒVÂ„V@Â„XVÂƒÂ„Â„Â„ÂƒbWÂšXllaÃžUÂ°ÄŠÂ„@Ã´Â¼Â„LÃ´ÃWanÂVÂ¥ÂƒÃ‘nÄ‰Â°Â¥ÂšÃ…XÂ¥Â°Â¯@wÂ°w@Â»Â°ÂkÂ£Â°mÃˆÅ¹Â‚mÃˆbÃ†ÂƒÅŽÂ¦Â„KÂ°z@ÂŽkxlÂ¦UbUÂ¤ÂšÂšÂšklVÂ„KÅ¤ÃžÈ°@@bÂšV@nVVUlÃžÂ¦lUllÂœVlUÂ°Ã‘UÂ¯VÂƒÂ°wÂ„bXxl@VÂŽÂ²Â„Â˜@nÂ„Ã´Â¼ÂƒÃ³Â°Â™kmVkÂ²Ä•Â‚w@wVÂ™ÃžÂÃž@@ÂÄ ÂƒÃ¶Â»Â˜Â¯Âœ@Â‚Â„ÂšbnbÂ°mÃžÂ¯Â°VÂ°Â„ÃˆJmÂXÂ¥mamÂ™UÃ…Â™ÂƒUÂƒlaUÂ¯Â™Âƒ@wÂ™KkÂ—lÂ±n@@wÂƒkÃVUUlÂ±Â¯IÂ¯bÂ™aÂ™lÂƒ@Â™ÂkLmakbÂƒ@Ä¡ÂƒÅ¹Ã©Â°Â™ÃžbÂ°ÂÂšÃ©kÂƒÂƒLmÂ™Â„wXÂ™Â‚aÃ…b@bVlÂƒbVbÂ—Ã’VbUbÂ›UUanwÂƒakbVÂŽUVÂ›akÂ„Â¯Â„UÂŽÂƒLmxVÂ°UxnÃ´Å»X@JÂ„XklÂ‚bkbÄ‰aÂƒbÂƒWUÂ„Âƒ@ÂƒkÂ„WUUÂ¯@@klmÂƒ@@Â™ÂÃ…@aÂƒwWÂXÂlKkI@ÂWbUaVIUanUÂƒÂƒ@Ä•ÂƒÂÂ¯KÂ™Â„mUnWUwm@ÂÂ£Ä‹Ã¨kUmbUmm@@nkJUalwk@@nmWUan_Ã³aWmnwÂ±KÂœIÂƒwl@UmÂƒI@an@@mlUÃ…mV_Â™KUkÂƒ@U`@_ÂƒKUÂmUÂ™@UÂ¯Â™mmbÂ¯@kbÂ™ImVÂ¯ÂƒÂƒLkbÂƒKÂƒÂƒÃ›@Ã‡nÉ±JÃ³aÃÄ¢kb@Â„Â›xÂ—Ã’Ã‡llÂÂœ@Â‚ÂŽÂ²VÂ‚ÂÂ„Ã†UVVÂ„UÂÃ‡Â°XÂ„Ã³xlVÂ¯Â„lV@bÂƒV@nÂ—xÂ›@Â—Â¤@Â„È™ÅŽnxVÂ¼knÂšJÂ‚nÂšKXÂ°Â˜Â¦UlÂnVbUbÃ†VnÃžWVXÂ¦llÂšb@lÂ°ÂœVJÃ´Ã’nLVbÂšbXÂŽ'],
                    'encodeOffsets': [[
                            131086,
                            44798
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2202',
                'properties': {
                    'name': 'å‰æž—å¸‚',
                    'cp': [
                        126.8372,
                        43.6047
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã´lÂ‚zÂšaÃˆVÂ°Â„ÂšK@Â„mÂŽÂ—LWlÂ™nÂÂšVxUVÂ‚Ãˆ@ÂŽÃÄ¬UÃˆnÂ‚Ã´LÂšaÂ‚Â„Â²VmÄ€kV@Â„Ä ÄŠnU@bÂ„V@bÂ˜@nlÂ°UVnÃžaÃ´J@bÂšÂÂ™VÂ„Â¦mlkÂšÂšbmVXxÂ¯@VxmÂ„nbÂƒÂ„ÂšbÃˆKÂ‚V@bÃˆLÂ„wÄ yÃ´nÂšmnbÃœ@nnÂ„VÂ˜x@nÂ²KÂ‚Â„Â„J@kÂ„al@nxÃžUÂ„LÅºÂ±VwkwÂ¯LWWUÂÂšÂ™kÂÅŽÄ«VwÂƒwÂ„ÂÂ°yÂ„ÂVÄ•Â°wÃˆVlkÃ›Â»@wW@UÂÃ´Â£@ÂƒnÂ™Ä¶ÂƒXwWÂÂ™aUamKÃ³Ã‘UIÂ¯Â›@kÂ™akkWÂ¥XUmÃÃ…UVaUaÂ‚mVkÂ—Â¥WÂ¯Â™LÂmÂ™IlmUÂ»mwÈšÅ@ÂƒÂ˜Â£kJUÂÃ‡k@ÂÂamÂÂ¯yÂ¯UVwÂƒa@wÄ¡xÂÂ¦ÂƒKÂƒÂƒÂ¯XÂ°ÄŠÂ¯Â¦UÂ°Ä‹WULÃ…aÂ±bÂ¯@UkÃ…WmÂVÂƒÂ™ÂƒkIUlÃ³ÂŽÄ‹Â¹Â™`Ã³IÂƒlXÂ„WÂŽXxmbÂUÂƒLÃÂÂƒbÆ§@ÂƒxÂ¯bÂƒÃˆÂ—l@xÂƒÂšÂ¯zÂƒaÃÂ¤@nÂšmÂ„VWbÂ²bmnÂ¯JÂ¯Ã’@nÂ„Âš'],
                    'encodeOffsets': [[
                            128701,
                            44303
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2208',
                'properties': {
                    'name': 'ç™½åŸŽå¸‚',
                    'cp': [
                        123.0029,
                        45.2637
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã³Â™Ç©Å@WlwUaÆ‘wÃ›Ã…Ã‡Ã©Ä‰amÂÂKÂƒÂÅÃ‡@IÂƒÂ™Ã´Ä¡VÂƒÈÃ‘Å¹Ã§ÂƒÂ™ÃUÆ§Ä‹Ä‰wÃ³Ã³Ã@Æ‘Â»ÄŸLÂ¯llÂ²@Æ†Ã…V@Â¦mÂ‚Ã…b@nmlUÂ²VxÂšlUnÂ™@VbnWÂ„bÃ‡bkÃ’ÂƒÂšÂ„n@Ã¨lnlÂšUÃ’Â„ÂŽÂ°LÂšx@Â¼Ä‰b@Ã’Â„ÂšUÂŽÄ‹xÃ…ÂÂƒÃ¨nLVxÂƒÃ’ÂƒbÃ…JÂ±a@_Ã…JÃ…nÂƒÂŽVbÂ„KlÂ„nUÃœÄŠ@Â„UÂšÂ™xXVÃ†nÂ„mÂšVÂšÂÂšJÃžÂ¯VÂ™Ä wÂšÂƒXwÂ°xWLÂ„xÂ„KVÂ¦Ã´UÂ„wVÃÇ¬Ã³ÃžÃžÂ™Â¼Â‚Â‚Â„ÃžkÂŽVÃ´È˜xÃžÂ„UÂ„lVnÂ¦ÃžÂšÄŠaÂ°wÂ„bÂ°@ÂšbÃ†wÂ„lÅ¤LÂ²`Â„zÂ°@V@@Â™nJVnl@@Â¥nUmmnÂÂ„@mwnmmUnk@mlwUaÂƒLnÂƒÂ›wnÂ¯Â°anÂƒWakIÂ„ÂƒÃ‡mXwÃ†amUXUlJXaÂ‚UUklKUknmÃžV@ÂÂ‚K@ÂVWÃž@VkUwVÂƒ'],
                    'encodeOffsets': [[
                            127350,
                            46553
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2207',
                'properties': {
                    'name': 'æ¾åŽŸå¸‚',
                    'cp': [
                        124.0906,
                        44.7198
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„ÂšÅºÃ¨È‚Ã’UÂ„Ã³Ä¢Â„Âš@JÅŽÃˆÂ„Â‚Â‚LnÂŽÄŠbÃˆÃªÃœÃ†Æ’xVbkx@XÇªÅ‚Ã´ÂšÂ„kÃž`Â„ÂÂšWÂ„b@nÂ°aÂšbÂšKÂšnVwÂ°`Âš_X`WÂ„ÂšÂ¦Â„ÂÄŠIkmVÂÂšakwÂ‚KÂ„xÂ°UÃžbÂ„U@lÂšÂƒl@Â°Â¦ÂœVWÂ„ÂšaÃžbÂšxÃžI@mVI@ÂƒVÂkÃ…ÂšUWKÂ„Â¥nLÂ‚a@ÂƒÂ„@ÃˆÂÂ„@Â°ÂƒÃ†@nU@KÃžalkUwVÃ©kUWwÂ„Â™kUÂ›VkkÂƒJkÂ¯@Â»Ã³kÂƒVÂ¯Ã†Ã‡I@bÄ‰Ã´Â¯@Â™ÂÄ·wÂ¯nmmÃ…LÂ¯wÂƒVÂƒUÃžy@UÃ³wÃ‡Lkmm@@UÃ³xkkÄ‰ÂmLÂ¯wVwkWWXÂ™mÂLÃµm@kÃ…Â±V_ÂƒÂƒÃ´Â»Ã›ÂƒÃ†Â¯@Â™VaÂÂ™VÂÂšaÄ VÂÂlmÄŸwÄ·UÃ³ÃÆ½Â£Ã‡JkbÇ«aÆ½LW@nxÃÂ¤kzÂƒyÂ¯XÉ…m@VÂšÃ´Ã‡XÂ¯Ä–Â¯ÂºÃnUÂŽnLVlUÃ”mV'],
                    'encodeOffsets': [[
                            126068,
                            45580
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2201',
                'properties': {
                    'name': 'é•¿æ˜¥å¸‚',
                    'cp': [
                        125.8154,
                        44.2584
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„UÂ°xÃ†KnnÂ°mÄ¸xÂšÂÂ°@ÄŠÃ³@aÃˆJÂ°Ã…Â„UÃ´l@Â¼lÂ°Â„IllÂœUlVÂƒÂšXxlVUÃªVxkllnÃˆUVll@VxÂ²IÃžÂ¤VUlVnIÃ´lÃžÂƒlwÃ´_Â„Â›Â„bVaÄ¶LXÃ…ÃžÃ‡@KÂ˜Â¯@wÃ›aÂƒÃ§nÂ¥ÂšÂ¯WÂXyWÂ¯XwÂƒUmmÃ›@maÂ™nÃ³mÄŸzÂƒxÃ‡K@aÂUÃ‡LÂ™aÂ„ÂƒmanÂƒUwÂ°@WwnUÂ™alÂ™nkÂƒÂ¥ÂšUÂ™Â@aÃ³IÃbUmÂ¯VmkÂ—@@aÂƒU@amVÄŸÄ‰@ÂƒlUnÃ¿Â±UÂÂƒÂ™bÃ³KmÂVÃ‡ÃžÄ«@ÂÂÃ‡VUUwÂ‚Â™ÂšmXkÂ˜KnÂ@ÂƒÂ™LÂ¯ÂƒÃ‡UÂ™bÂyÃ³kÅÃ¨@bÂ‚n@lÃX@xÂ¯Ã´@Ã†Â™UÂÂV_maXm@aÃ³ÂÂƒJWxnX@ÂŽVVnÄ–VnUJ@nÅÃ†Ã‡Â¼VÂ¼kxÂƒLklÃw@xÂƒx@zV`Ã…bmxÂUÂ±xUÂ„nnmÂ‚knÂ‚ÂŽÄŸUÂ™bUÂŽÂ‚ÂšUb@ÂšÃ…Â°ÃœÂ„Ã³Â¼Â„Â„U`Ã†Â²@lÃ¶nÂ‚KÂšnXWlXUxÂ°xnKÄŠÂllÃ´w@Vn@lnÃˆKÃ´x@VÃzÂ„V'],
                    'encodeOffsets': [[
                            128262,
                            45940
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2206',
                'properties': {
                    'name': 'ç™½å±±å¸‚',
                    'cp': [
                        127.2217,
                        42.0941
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@UÂšlÂ¦kÃ’Ã†Â°Â„IlÃ’UÂ¤Ã´zÂ„Â¼lJÂšÂ„UÂ„nÂ‚Ã†XVlÂ°@Â²aÃ†bVKÄŒXVÂ¯Â°Â¥Â¯Ä‰Â°WÂ„Â„Â„LÂ‚Â¥Ä¢w@xÂ„bUxÂ°VÂ°znÂ‚Â‚b@ÂÃˆlVÂŽlIÂœ@Â˜w@mÂ„U@akUÂ°ÂƒkUÃ´wWÂƒÃˆÂ¯VÂUÂƒVUÂƒÃ…ÂÂÂ±UÂÂÂ›@kÂÃˆkÂ˜Ã‘Âœw@ÂƒlaÃžÄ¡ÂƒUÃžÂ£@Æ…Â‚KnÃ‘Ä¢Â¯@WÂ‚aUaVUVkkw@aÂ¯Â@Â¯Â™ÂÃÂ™ÂƒVXnW@@WkXmK@xkKUb@bW@UwÂ¯Â„mmÂb@ÂWKUbmUÂbUaWbÂƒJÄ‰IVW@IÂ—lÂ±LkÂšmUÂ™bUmÂ™@ÂƒnkKWaÂ¯nÂ™@Â„`UbmaÂ™Â„Ä‰L@bÃ†ÂšÂ—@W`ÂƒL@nÂ¯Â‚XbÂ‚@kb@xÂ™LÂƒÂ„Â™@VÂ‚kLÂ±Â™ÂÂ™mlUIUÂ¥mL@lÃ…x@_laÂƒÂƒ@UÂ—aÂƒV@kmmÂƒKÂ„Â£ÂƒÂƒÂLÂƒÂƒmKUnÃ…KVbmÂXVlÃ¨Ä‰UUbmlÂ„Ä¢Ã…Â¤ÂƒIlÂŽÂ¯bÃ‡Â¦ÂœlÂ‚@Ã´Â¼Ä¢Â„@xÂ°Â„lÂ¤Â„nÂ„aÂ„l@xÂ™b'],
                    'encodeOffsets': [[
                            129567,
                            43262
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2205',
                'properties': {
                    'name': 'é€šåŒ–å¸‚',
                    'cp': [
                        125.9583,
                        41.8579
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã†lXnÄ xÄ¢Â°lÃˆÂ°ÂšÂ„KÂ„Â°kXmÂ‚@Â¦VbkÂ„Å¤JÂšnÃÂ¤kÂ„VÃžVVkÃˆÂ„bÂ°yÂ„Â™@wÂ˜kÂ„Ã‡Â°aÂ„wÆ¨@Â„aÃžÂÂ„KÂ‚VnaWwXÂWÂƒÂ„kÃ´JÂš_ÄŒÂºÃ´ÂVkÂƒÂ»Ã³yVÂ£kÃ‘ÂƒJÃ…Â¯lÃ‘kÂ¥VÂ™Âša@wÂƒkÂƒbÂƒmkÂ£Â¯Âƒ@wÄ¡ÂƒÃ³Â»Â@Â›kÃˆÂ¥Â°akÂÂ„JÃ†Â£ÂƒÄ¡nkVaÄŠVkÃ§WUnÂUaÃ†LVmnLÂ„Â„Â‚KUÂÂ™Â±@Â—Â„m@aÂ¯UÂ„bmVÂ¯m@_ÂƒKÂ™Â™UÂ™ÂƒaÂƒÃ…Â™WÃ³Â¹Âƒ@UanmWak@@wmI@yÂÂÂ™@mkÂ„JVaÂ™@UaÂƒIkJ@nÂ™@UmÂ±kkxÂƒmÂ™IkÂ„ÂƒbÃ‡m@ÂŽÂ°bXnÂ„V@ÂŽÂ°ÃˆmlÃžÂ¼Â¯XVÂºÂ¯LmÂ„kWWÂXLmVVlknÂƒ@@lÂnWÃ†Â™Â„VxÂbmÂšnÂšmÂ„Â¯lÃaVÃˆÂÃ¨@Â¼VÂ„Â„bÂ™Â„Ã†ÂŽÂ°ÃžUVÂšJÂ„Â„kxÂ›IÂ—xÂƒÂƒÂƒIVÂ¤Â™Ã’Xxmn'],
                    'encodeOffsets': [[
                            128273,
                            43330
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2203',
                'properties': {
                    'name': 'å››å¹³å¸‚',
                    'cp': [
                        124.541,
                        43.4894
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@É†nÂ°WÂ„zlyÃžÂ£mwX@Æ¾KÇ¬blaÃˆIÆ¾Â¤Ã´ÃžÄ¸VÄ xnÂmmVÂƒÂ²wÂ‚VnwÃ†aU_@yÂ„w@wÃžxlkÂ„KlwUÂ»ÃˆÂ»ÅŽÃ…@mVIUmmÄ•UU@ÂmWXwÂ„IÃ´Â‚@bWnnbU`Â‚ÂÂšV@Ã…Â°Ã³@wÃžW@kÂm@aÅŽÃ§ÂƒÂ™@mÂ°Ã‘Â°InmÂ±aXaÂƒUÂ™n@mÆ‘ÂšUÂ¦@ÂšÃ‡ÂŽÂ¯aUÂ£ÂšaUÂ™Ä¡Â¦Ã…Ã’Â™JÅUÅ»Ã³kUÃ‡@Â™Â¥Â¯akÂ¯mUVak@@aÄ‹Ã§Ã…aUÂƒmÂ¦Ã`XbÃ†Â„@nÂ`ÂƒIÂ™xÄŠÃžÅÃžml@ÂšUbÂ@WlÂ™_Â¯JkÂšÃ‡UÃÃ†Ã…b@nÂ™Â„llUbÂ¯Â„Â±a@ÂƒÂ—ÂƒWÂÄ‰JÄ¡Ä€Â¯Â™UnÃ³ÂšmÂ¤ÂœxÃ´aVnÂƒxÃ´I@xÂ„V@bmÃ†Â™Â„@lnLmÃžÂ¯ÃžÂ™xVbÂ¯Ã¾'],
                    'encodeOffsets': [[
                            126293,
                            45124
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2204',
                'properties': {
                    'name': 'è¾½æºå¸‚',
                    'cp': [
                        125.343,
                        42.7643
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Å¼Ã´ÅŽVÂšIÃ†Ã‘Ä¢Â¥VÂšÂ™bVÂ¤Â°bÃˆÂ@Â™VÂ¥Æ’Â™ÃžÂ£lÃ‡UUUÃlÂƒÃžÂ£Â™mÅ£IlÂƒUa@Â¥nÂlWÂƒÂ¯ÂƒLÂ¯Â™kÃ‡Ä¡Â¯ÄŸwWmÃ…kÂ¯UÂƒVUÂ„Â„bWlXlmnÂƒbUxÂ¯xVVknlÂŽUbVÂ„Ã‡KUb@Â„Â™VnbmlnzUÂºÂ±bÂÂmJUbWÃˆnÃ¨mÃ’Â„Âš@ÂX`WL'],
                    'encodeOffsets': [[
                            127879,
                            44168
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/liao_ning_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '2102',
                'properties': {
                    'name': 'å¤§è¿žå¸‚',
                    'cp': [
                        122.2229,
                        39.4409
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â‚IÃžmVk@wXWÃœbnwlLnUÂ„@Â‚ÂnLlbXW@aÂ‚wnbl@XLÂ‚aÂš@ÄŠÂ¥@LULnJ@xVnmV@VXXV@VJkn@VÃœKXXÃ´JlbÂ„xl@Â„IVbnJVLUbnÂ‚lnVwÂ„JVU@ÂƒXUÂ‚aUUlwn@Â°ÂƒnÂ„VKnVÂ°_VJÂšwl@nwlVÂ„IXWlIVVnK@IWmkIVaVU@WÃˆUlmUÂ@UÂ„WUalkXÄ¡Å»@kIÂƒÂ»mmÂ™akÂUmÂ›Ä‰UÅVÂ»Â²Ä¡VÄ•@aUUØIÉƒ`Èƒ@ÂkÂƒw@ÂƒUÂƒmwÄ‰ÂÂ™@ÂƒWÄ·Ã‘ÂIÄ‰ÂÃ‡bÃLkymbÂIÂƒwÃ‡mÃ›bmbUÂ„Â¯ÃœÃµÃˆkÃ†VbÅŽxnXVÃ†nÂšÇªÂ¦Â„bÂšÂ¤UÂšÂ™xÃnÄ‰Ã’mÄŠVÃˆÂ„Â¤ÃˆÂšÂ„bÃ†Â¼Â„Ä€Â„Â„Ã†Ã†ÃžÂ„ÅºbÂ„VVbXÂ„Â‚Â°Â²Â¤'],
                    'encodeOffsets': [[
                            124786,
                            41102
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2113',
                'properties': {
                    'name': 'æœé˜³å¸‚',
                    'cp': [
                        120.0696,
                        41.4899
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@na@UVI@mÂ„Ã‘WÂ™kaVÂ¥UI@wl@Â„aÃˆbÂšm@wVaÂškÂ„@@K@kÂƒÂ™@a@UUmÂƒUUalmUÂ@KÃ‡UÃ…Â±Â¯@Â±kUKVkUaÂƒaÂU@Â¥m@@Â¯k@WLUmkn@mmIkm@amU@wVmkU@Klk@UÂ—mÂ˜aXIWWULÂ™aULVbÂƒmk@UUmUkÂ±Â™_Uym@mbkImaXÂ¯WWÂÂÂ™xWKÂzU@WÂƒkJWwkVÂ™@UÂm@UbVVVVXb@VWXÂ—@WÂŽ@Vkb@VÂ™nUKÂ±aUUlwXÂÂ™Ã‡WKknU@mmUkÂƒLUVÂƒVUUVÂƒUaÂƒwÂ™bkKmwnIÂƒÂ™kJ@nmbÂƒ`ÂkmVkLWwUm@UUUÂ™K@UmaUa@UUaWKÂ@mUÂƒÂÂ¯WkkÂ¯VmUUÂŽÂ„xVXUVmLÂ¯ymXkWUbmXUKÂƒVknWxÂ¯JVnkLÂƒl@VVxnxlÄ€VLÂ²WlXÂ„l@bÃVUn@bnlÃœaXblIVl@ÂšÂš@ÃˆÂ¦@VmbXVÂ‚@@xÂ„VVnUn@`Â°@VnXU@K@Â„VV@VmbnVn@ln@bÂ„xÂƒÂ°Ub@bÂšLV`Ã…nÂƒÂ„W@@lUÂšnnWVU@Vbkl@Xl`XxVÂ„UblÂŽkX@ÂŽÂ°Â¦VÂ„UVVbUlkVÂ›@UbVbkLUxmJkXÂšÂš@bÂ‚bÂœxVKÃ†lXXÂ˜bnÂŽnala@ÂƒUk@UÂ„VVklKVUXKVUÂ°KVan@VUnLÂšKVLÂ„WVaU_@mmUXa@mÂ˜wXwVkVWXkÂ‚k@Â›Â„k@klm@wXKl@UÂ@KVUUUVaUÂƒV@Â„alLÂ„xUx@bÂ°Â°VnnVÂšxlIXJmxÂ„LUVlV@bnX@VÂšbÂ„aVxÂ‚@XJ@bÂ‚n@VÂÂŽVXÃˆÂ„l@llX@lUÂ„VÃ´Â°Â°@ÃžÂ„Vbn@Â‚VÂ„kÂ„@VW'],
                    'encodeOffsets': [[
                            123919,
                            43262
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2106',
                'properties': {
                    'name': 'ä¸¹ä¸œå¸‚',
                    'cp': [
                        124.541,
                        40.4242
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lzXJÂ‚U@ÂšÂ²xÂ‚@@VÂšÂ„@bUVmKUnÂ„Â°n@lnVKÂ„Â„nV@n@VlVÂ„Â°WbXn@Â‚VzÂƒJ@Â¦@bkbÂ‚bUl@bkbÂƒJÂ¯zÂƒWULWbklVÂ„nbÂ™Â¦VJ@Â„Â„KÂ°UÂ„kl@@WÂ„bVnÂ°@Â„VÂšmÂ²UÂ˜nX`Â„UÃœLXmVXlKVbUVVnUbnÂ˜ÂƒX@VUL@lUbWxÂš@Â²kl`n@VÂlbÂ„@nUVWVLVU@aV@Â²bl@ÃˆmÂšxWXÂ„VÃˆUÂ„JVÂ„l@Â„Â„laÂ„WnXÂ‚KÃˆkÃˆ@VaÂ°bÃ†mÂ„@XVÂ°IVVÂ°UnalÂƒVUn@UwVUÂ„@@VVJÂ„I@bl@XK@wWmXUÂ‚UVbkJVXnJVI@mÂƒknwlKXL@`l@VI@UUaVKÃžnÂ„aVm@aÃ‡Â£XWÂ„U@aÃ‡UU@mbkKmÂ£Â™@ÂWWÂ™ÂƒL@Â@Kk@klÂ›UÂ—bWKUkUUÂ¯UÃµÂÃ›ÂƒmUUaVUÂ„U@WU_W@kVkJÂƒ_WKkV@bULÂ™Â¯Â¯ÂƒÂ±mkÂ¯Ä¡ÂƒÄŸÃ‘@UmwÂƒKUaÂkÂƒÂ™Âƒa@aÂ„ÂmÂ¥ÃÂƒÂIUWmk@wÂ™ÂmÅ£Â—LÂ›KÊbÈ—KWÄ¢klVbÂƒX@VVÂ‚knÃ‡V@XUVUblJXn@J'],
                    'encodeOffsets': [[
                            126372,
                            40967
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2112',
                'properties': {
                    'name': 'é“å²­å¸‚',
                    'cp': [
                        124.2773,
                        42.7423
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XJm@Â¯ÂšmXUlÂnVbUJÂƒU@bV@UJWL@VXLmJVbkXlJXxVL@b@V@n@b@`Vbk@lxknV@VVÂ™V@bUL@bV@@bVK@VXLWLXJ@LV@nbWJ@IUVÂ„x@LVJUXVxVx@VV@@LXJWL@VU@@L@VnL@bVVmVX@@VVInJmbnLWVnVULVVU@VVmÂX@@JVzÂ‚l@Â„nVVKVXÃžÂƒ@mk_lmÂ„UUWV_nJlUÃžÃ‘ÃžVVUVÂƒVLÂ„UVJ@IÂ„VnaÂ‚@@KV@XwWknwnKlalUÂ„wÂ„aÄ‰ÃÂšwÂšJl_@aUaÂƒKUUU@WU@WXUÃ†@@UVK@Ân@UnVVÂšblK@bÂœllb@bÂ„bW@Xbl@UlnLlÂ°Â°bÂšÂ¦nKlVnIÂ„V@UWU@WXkÂƒw@am@nm@aVw@I@KUaVImÂ±XÃ‘lknJVnVJÂšaX_VaUaVKmwnkmmn@lU@U@mnaÂšXlKUmUIVmkÂlaUK@UlUVUÂW@UÂ™kVmÂ™a@UUU@JmUU@@bmbÂ—KWVÂ¯XUKm@ka@UVKVk@aUKmLkKUUÃUmbXbÃ‡J@k@WU_@mÂ™Â™@klm@UXKVaUI@KWUXaÂƒÂÃ‡WÂkÂ™aWUkWULÂ±U@lUÂU@ÂƒUÂJÂƒI@VÂ¯JmIm@@aU@UwÂƒaÂ™@UV@VkIÂ›VÂ¯aUkÂƒWkb@bVLÂ„@@VVVUXW@UaÂƒ@@bÂ—Â‚ÃbUVÃÂ„@ÂŽÂƒLmUkVUbVllLUV@LÂšÂšXÂŽWbUXm@U`@Â„kxlnnJlbnIllÂšLXÂ„lVlUXmVKÂ„nÂ‚V@L'],
                    'encodeOffsets': [[
                            126720,
                            43572
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2101',
                'properties': {
                    'name': 'æ²ˆé˜³å¸‚',
                    'cp': [
                        123.1238,
                        42.1216
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÈšÄŠÃœÂ°Â„bÂ„LÂ‚lÃžxUbUnÂ±Â‚@ÃˆnVÃ†L@xnLÂšlUVÂƒbÂƒxkImJkn@VÂ±LUxkV@bÂšbÂšKVKnzVl@LÂ°@VaÂ„xÃžUlbÃ´xVVÂœ@@VÂ±bnÂŽ@ÂllXLÂ˜ÂŽÃ¶XÄ¶ÂŽnal@nkVJVI@aU@@aVK@aÂšUUUU@lmkwl@Ua@_@a@m@U@aUKWwkIlWUanIWK@UXKVIU@@aÂ„VVIUaÂ‚mVknWÂ°Â™n@WI@KÂUÂƒmULWnkVkUWÂƒÂ™KkkmJkamIkmlw@ÂƒV_n@VWXaWÂÂ™Â™@KVUkKUkValUnVÂ„K@ÂÃžÂƒVUÃžaÂ˜Â@aÂ„@VbX@VWUU@UÂƒ@UK@ala@IkKmUUa@U@ÂƒVÂƒkkÂ™WVwU_@KÃœUXbl@VÂ¥XUVmÂƒÂÂƒÂƒXaÂ‚kÃ…ÂƒlÂUUkIm`UIUJW@UIÂKmkm@ÂUUJÂƒImmU@ÂƒVUXU`mIUbUK@LÂƒJUUÂ™l@XÂƒ@UbÂƒJÂ™kU@ÂƒÂŽnÂ„m@Uam@@ÂƒÂ™aUÂmLÂKÂƒwÂƒÂ™ÂmWXUK@kUaÃ‡a@JUIUa@aÂƒKVUÂƒUXmÂƒÂUyÂ™_@lmbkLUKWLX`Â‚n@bVL@JXLÂ„Â‚WX@Vnb@Vm@UbnVmL@V@x@LUbVV@V@LÂƒUVlÂ@mbÂ¯U@xU@UVVV@X@VVblJ@bnÂ„VKUnÂ„x@llnÂLÂ±Â¤Â™b@Âk`VXÃ†K@Â„kV@Â¼kl@bWIUl@VmLnbm@@JXXmb'],
                    'encodeOffsets': [[
                            125359,
                            43139
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2104',
                'properties': {
                    'name': 'æŠšé¡ºå¸‚',
                    'cp': [
                        124.585,
                        41.8579
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„XVlÂ°bÂœUlJ@UVUÂš@Â„bVxV@@bn@nJÂ°I@UÂ„JÂ‚IÂ„VV@VÂ@kÂ²VVKlXXVÂšbÂ‚lÃˆXÂ„ÂŽWbXV@LVJUbWL@Vkn@lÂšÂš@nV`@X@lÃˆIWanaÃžVVVlLnKVL@bUlUL@Vlbn@VLÂ°WXUÂ˜Lna@aV@nV@IVV@VÂšbUnÂšl@VÂ‚XnKVa@UÂ„UnyWkXaÂƒaVk@aÂšaÂšbnm@_WKXmWanU@alaUÂ—l@XJVLVxX@Â˜wnKnVlwÂƒÂƒÂ™@V_@aÂ¯Â¥@UkKWUÂaUUÂ‚anK@IÂƒaUÂ@WUaVw@klUVyUUVUUÃ‡@IÃ´bÂša@mnUma@kXa@UWak@WaÂ—l@aÂ›Â@WÂUÂƒLmUÂ@U`mIUUÂ™`mUk@@UUKÂ±nkJÂƒbUam@kwm@@a@UU@Ua@Â@K@ÂƒVK@kmKU_UKÂƒUUaÄ‰WmkkL@`Â™LÂƒnmlkLkbmK@kÂ™@Ulmb@bÂ™Â„@ÂŽÂ„xUVÂƒIUlmVXXÂƒxm@Â™JUUk@WUk@ÂƒakxÂ±@Â¯xÂ¯UmbÂ™KUUVmUUÂ¯UmVVnÂ™WkÂÃ†Â„ÂlWbÂ„Â„Â„ÂŽUnWVUÂ¦k@WaÃ›V@LV`UxÂšXllUÂ„@Â„@VVbnVlL@J'],
                    'encodeOffsets': [[
                            126754,
                            42992
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2114',
                'properties': {
                    'name': 'è‘«èŠ¦å²›å¸‚',
                    'cp': [
                        120.1575,
                        40.578
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@llÂ°XÂ„ÂŽnVÂ‚@XLVb@VVbnb@VÂšLVV@VVnXxlKnUÂ‚lÂ„_na@mlIÂ„ÂšmJnxlLÂšaÂ„xVbUÂ„VVÂ„UVUÂ„KVlnnV@lmXLÂšÃˆWÂŽkxVVÂ²bVLÂšm@Ula@UXÂÂ˜@XW@UWaUUUUVan@VÂ‚Âš@lUXxlIXÂ„V@Â‚yXLÂšwÂ‚ÂŽXXWÂ°nblJnan@VzÂš`lÂ²nVVVl@Â„nUaVKÂšbVKnXVaUaVUÂšyÂšnXK@kVKÂ‚@XÂ@m@mÂ‚LXaÂ„LWÂƒUÂ¯Â„w@Â™Âƒa@UVwÂ„Â¥Â°Â™Ã³Â¯Â¯yÂ¯ÂÂƒÂUÃ‡Â¯Â»Â›wÂ¯IÂƒmÂ—Â¯Ã‡Â™UUlÂ™Â¯Â»Å£KÄ‹Ã‘Å£ÂÄ·mÂ¯w@mU_Ã³mkÂ¼VnU`Â±IkbVlÂƒnnÂŽUÂ¼Â±Lk`@XÂ™WlÂ¦UbmVUxkXVlkbllUÂ„Vb@bkVmx@XVV@JÂbÂ±aULkKWXkWmXÂ¯aUJmIkVm@ÂƒxU@nÂ„'],
                    'encodeOffsets': [[
                            122097,
                            41575
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2109',
                'properties': {
                    'name': 'é˜œæ–°å¸‚',
                    'cp': [
                        122.0032,
                        42.2699
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÂšXnbÂ°lÂšÂ„VlnXVJÂ„LlVnl@zÃ†xnK@bÂ„blKVLn@@VÂ„aVLVK@L@Vl@XVVInVVKVwlUXwlKÂšLÂ„ÂšÂšVVb@aV@XÂ„lUXbVW@nÂ„lWnXKV@@V@XUVVLUVV@@bVVV@@ln@VbVUXVÂ‚IÂ„xVanJ@UÂšIVWÂšL@UV@@Â¤V@nInwÂ˜WÂ„kÂ„lnIVxÂ‚lnzUVÃ‡JÂÂ¦VVÃœLÄ¸UnW@aV_ÂšWÄŠXXaÂ‚Knkl@nmÂ™LÂ™a@alUVwÂ²K@UlmnIlJÂ„wÂ„aVUÂ™kmK@wÃ…KmU@Ã‡Â²ÂVmVaÃwÂkÂƒKÂƒaÃ›Â¯È™Ä‰Ä·Â¥ÄŸÂ¥Âƒ@kUWkÆÄ«ÃÂƒÂƒ@@akUÂ„K@KWIUmÂ¯nÂƒUÂ¯JmwUVmIkJÃ‡LÂm@Â™UImJUU@aW@U@@nUbÂ™JÂƒaÂƒbXVWnÂ@UVmX@V@bÂ„Âš@l@LÂƒ@Â™lUb@xÂ™nÃ‡aÂƒbk@@xVJUÂ¦lbXÂšÂƒÃ’@nUJ@Vmb'],
                    'encodeOffsets': [[
                            123919,
                            43262
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2107',
                'properties': {
                    'name': 'é”¦å·žå¸‚',
                    'cp': [
                        121.6626,
                        41.4294
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nJ@nlmVnXKl@@Â°n@@Â¦Â‚VÂ„bVbUlVLÂ²lÂ°@Ã†Â²ÃˆV@LVÂ‚knVbÂ„VVnnWVUÂ‚@XmWUÂ„aÂ„bÂšIVa@mV@X@@bVVnIVJ@ÂšÂ‚nÃˆKlInJVUnxÂ°IÂ„VÂ°mVnXJ@LÂƒLlV@bÂ„@ÃžÂ„ÆÄ¬XllVÂ„@Ä Â¦Ä¸Â¦naWW@In@manK@UVkXJ@alk@Â»lU@ÂƒÃ…LUWl_@ÂÂšaÂ²Â£Â‚Kkm@kÂƒwVmULmÂƒ@akIUa@U@WUUVUÂ™aÃ@ÄŸÂÂ›wkÂƒÂƒmÄ‰Â£UWÂƒ@@bÃ‡L@mÂ—a@_mKÂƒlÂƒXUwÂKÂƒLÅ£Ã“@UWw@K@UÂ„I@mÂ™U@UVÂ¥Â„@Â°UnJÂ°@@_Â™KUwÂƒW@UnaWÂUmmI@mÂÂ™Ä·wUaÃ‡LÃ³VÄµwÃÂ™UUWÂ™Â¯ÂšÂƒÂ¦Ux@VÂ„b@ÂšÂƒxVÂ°XÂ„ÂƒKWbÂK@n@nWÂ‚Â@UL@lWLÂ™mÂ™zUVVbUbmWXXWJÂ—bÂ˜n@Vkl@LlVUn@xnV@bln'],
                    'encodeOffsets': [[
                            123694,
                            42391
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2103',
                'properties': {
                    'name': 'éžå±±å¸‚',
                    'cp': [
                        123.0798,
                        40.6055
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lÂ„ÂœxÄ ÂŽÃž@ÂšbV@@wÂ°VnaÂ‚@UkÂ„V@K@UUUVa@K@w@UnKmUVan@@Uma@UXWÂƒÂWK@IUK@aÂmW_XKVLlKna@kmKVak@VUÂ„@VmÂšU@anIÃ†an@Â‚aÂ„ÂšUVnb@blLV`ÃžLlUÂ„bnaÂ‚Kn@naVU@Â¥Â°IVK@anUUKVaÂƒUVakÂÂ™@mJÂƒkXÂƒÂ™UVwkÂƒVUUaÂ°U@WÂƒÂ@WlkXWlIXUlJlaÂœxÂ‚IVVXLÂšll@nLV@lLXlÂ„KÄŠzÂšÂ¥maUÂƒlkXaVKÂ„XÂ°yÂ„Ila@aVkÂala@a@Â¥Â„IUy@ÂWmXaÂƒÂ¯kU@U@mmUÂƒÂƒULkmm@ÂƒÂ¯VmnLVU@aÂ™Âƒ@UÂ@Â±w@Â™ÂVWIkymLUUkJWXÂƒJkUmxk@Â™xUIÂ¯`mUULmÂƒÂ¯Â„m@kxVVÂbWV@Â„UVÂƒIUx@bkÂšVÂšVVÂšxUbVV@V@zÂšJVXUÂ‚lnk@@lkLÂƒlÂƒLUUÂ±JkÂšm@UIUVÂƒLUVU@Â™K@UÂƒnnV@l@LlÂ„ÂƒaUJ@zn`@nWlÂƒIUVUUUVÂ±LnÂ‚@nmL@VUVkLVlUxVLVlÃ…XmaÂ™@@akLmWUX@JUnVJVkXJ@X@`WXÂ„VUVUIlbÂ„W@bVUVL@`Un@Â¦U`@bUV@z@Jm@@XV`Â„LULÂ¯J@IVKmKÃ…I@JÂ™nWVnLnÂšVxVÂ¤Â™z@bmV@VUV@bUL'],
                    'encodeOffsets': [[
                            125123,
                            42447
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2105',
                'properties': {
                    'name': 'æœ¬æºªå¸‚',
                    'cp': [
                        124.1455,
                        41.1987
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lb@VnÂ„lnVVUb@ÂšVJ@nnJ@bmXUx@xVbkbkÂŽWLUxnl@Ul@Â„xWx@nUV@Â¼UllÂ„knkK@bmbnlÂ‚LVJX@VIVJn_lJVVÂšXUmnUÂ°VVVUnVVÂšLnaÂ°VÂ°wÂ²@lwÂ„bl@XVl@VVÂšIn@Â„wWWnUVkÂ„JVUÂƒw@ÂÂšÂƒ@anaVkÂš@@lnLlalKnkÂ„mÂšK@_lKnlÄŠXVbÂ„VVLV`nL@lUL@Â„@L@Â‚VbV@@V@bn@lxn@VbÂ„alIÂ²mVL@Vl@nVÂš_VVnJV_Â‚@nVÂ„KÂ‚V@XÂœÂ‚@bÂ˜kXbl@XblylUUkÂšÂ™@ÂXa@UVIlK@UUWVUÂ„Llm@UUUnKWU@K@UXmÂ„XVa@UÂ°KVUUWUk@aÂšUVKkaWkÂƒKUknaWa@UÂ—Â@Âm@mÂk@ÂƒaUJk@@_WKkLmxÂ„l@nUJmIUWlIUaÂVWVXn@xWLk@@aÂƒJUI@UÂƒ@UVVxm@UVkÂ„mbÂ¯VUUÂ¯JWUÂƒ@Ã…nÂ¯aUbÃ‡@Ã‡lÂLmWÂƒXkbÂƒÂƒk@UÂƒÂƒIÃ‡VÂƒUXWÂ™wÃ‡nk@Â±aU@@bUVUKUXmVÂƒ@kaUÂm@k_Â±lÂ™@XwVa@kVK@UÂ„WmÂ—VaUmVUUakLUWWnÃ›KÂƒVW_Â—mÂ±VÂ™nÂƒUÂ¯@UmÂƒa@Xk@ÂƒlÂ¯V'],
                    'encodeOffsets': [[
                            126552,
                            41839
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2108',
                'properties': {
                    'name': 'è¥å£å¸‚',
                    'cp': [
                        122.4316,
                        40.4297
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÄŠÄ–Ã†ÂnÂ¤Â„Â„Â°ÄŠÂ¯ÅŽWÂšÃ´Â„@xXbÂ‚wnKl@nX@VUVÂƒKmL@VU@UxÃÂ„@VlbÂ„xÂ„U@VUb@bÂ‚kÂœ`Â‚IUlVUnÂ„V@@UV@@JnXlK@bÂš@nbÃ†WUkUKVwUklKVU@UnK@mmÂÂ²KVUVVVUÂ„JXk@mm_@yVIÂ„bkÂƒ@K@kmUÂ„m@VÂšLV@VUÂ„KVUVJn@lÂ™Â²IVVÂ„KÂ„klK@kl@kmVÂUWÂ™I@y@UUUVaÂ™wUUUÂ™lÂ™@akmmÂVaUKmIUaÂƒJk@ÂƒwkaÃ³IWWÃ›L@UlmUIU@WW@UnUUm@wmIVK@KÄ‰Â¦Â™@ÂbWKk@maÂx@bWXkamKÂÂÂƒ@mVkKmxÃ›aWX@xUlÃnÂJ'],
                    'encodeOffsets': [[
                            124786,
                            41102
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2110',
                'properties': {
                    'name': 'è¾½é˜³å¸‚',
                    'cp': [
                        123.4094,
                        41.1383
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Âš`VzÂ„Â‚WnÂ„VUVÂ„L@bVbVJ@IÃˆbVb@lVLXWÂ‚nÂ„ÂšÂ„xÂ‚LnKVÂŽÂšb@Â„n@Vbn@mÂƒÂ„ÂV@ÂšlÂ„IVaÂ„@@WÂškVVÂ„I@KVLVanJV_VWÂ„UV@nnÂ„JVIÂ‚Vn@na@alLlmkÂƒVk@Â»VU@mXwÂƒwk@@VmkVwXKlÂlaUa@wVwnW@amI@mUI@Â™VaUUkmmÂƒ@UkaÂƒL@ÂƒUIÄ‰yÂƒLWkkKU@mKk@Â™kWKUUÂJÂ›wkbkIWVkJWXkl@XÂ„Â‚@XÂ¯VVbUVlÂ„UxÂšVWÂ„Â„lnIÂš@lÂ‚UbÂ„VUbVLmV@bULÂ¯J@Â¦UVmbm@ÂLmbÂƒakVÃKU_kK@amaVUÂƒÂ™Âbm@Ã…bmJ@bÂ™VUnÂƒ@UVl@UbnL'],
                    'encodeOffsets': [[
                            125562,
                            42194
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '2111',
                'properties': {
                    'name': 'ç›˜é”¦å¸‚',
                    'cp': [
                        121.9482,
                        41.0449
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VbÄ¸xÂ‚Âš@nnJVnXÂŽmb@VÂ„XVxÂšL@`Â¯@mIÂ¯VÂƒ@UÂ¦@VÂšV@nÂƒJ@V@LXx@VÅ¤Ã”Â„KÂ‚LVxÂ„WÂ„knL@`Â˜b@nÃˆK@aÂ„@VXÄŠÂ¤Â„nVK@aVU@UnU@aÂšyUÂ£UwmÂ™mKXUÂšm@IÃ†JnLUL@JÂ°IVKÂƒKU_@Wn@@I@yVU@aV_@Â¥Vm@_UKUV@aÂƒXkaVJVUÂƒUXW@_@WWIUlUIVm@IVW@IU@@VU@mÂƒUVVkÂJÂ›_Âl@aVa@UÂƒVÂƒwka@UÃžÂƒVwV@@UnKÂ„LVU@UmWk@mLÂxWa@wÃ³ÂƒUVUIÃ‡Ã†Ä‰Â¦Â¯Â¦Â¯xÊŸJ'],
                    'encodeOffsets': [[
                            124392,
                            41822
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/nei_meng_gu_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '1507',
                'properties': {
                    'name': 'å‘¼ä¼¦è´å°”å¸‚',
                    'cp': [
                        120.8057,
                        50.2185
                    ],
                    'childNum': 13
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„m@ÅkÂƒÂ™ÂŽÂƒklÂƒÃ´Âƒ@Â£kJÂ°Ã½Â™É…Ä·Ã‘Ã³Â¤ÄŸLÄ‰Ã…lÃ‡ÄŸÅWÂ¯Â¯Â›Â™Æ¥Ã³Ã¿lwkÅ£ÃˆÃ©ÃÆ›Ã³Â™Â°ÃžÃ…xVÂ¤Ä‰Ä–WÆ’Â¯lÈ­Å£Ï…ÌƒÉ±Ã¿Ä·Æ…Ë‹ÄŸÉ±Å™ÃÅ£Ï™ÈÆ§ÄŠÅ£@Â¯kWKUKmÂ¹Ã…@Ä·JU@Æ§Ã‘Æ§Â„ÅÂ¥Ë¹Æ†@L@Â„ÃžÂ‚VLnÂš@VÅÄŒWJXÂ¦@JÅ»bU@Å£ÃžmVU@ÈÃ½Ã³bkWWLÂƒÂƒÃ…ÂÂ™Â¯UWÄ¡ÂkmÃ³ÂƒÂ±UÅ¹Ã´VÂ¼Æ½Â¼ÂƒÅ‚Ì¥Ä–Æ½Ç¬Ê‰xÄ‰ÂŽÅ»ÂÈ—KÎ•Ì›ÊµÆ¨ÊŸÃžË¹Â»Æ§ÂÅ£Â»Ç•ÅË·ÈŒÂ±ÈšÊŠÄ UÉ¾ÉœÉ¨mÃœÖžß¼Ë¸Æ…È‚Â¯Ç–KË¢ÄŸÃˆÃ’Ç”nÆ¾ÅŽÅÂ‚@ÂšÄŠbÃ´Ã´ÌÂ¼Æ’@ÄŠÃ´ÄŠÂŽÃžÄ€Â™xÂšÄ–Æ§LÂ±ÂŽÂœÂŽÂ‚UÂšÂ°UÂ„Â°Ä¬Æ’ÄŒÂ°ÃœÂƒÃªÉ´È‚VÅ‚Â°@ÂƒÂ„nxÅŽÃ¨ÂƒbÃˆÂ„ÃžÈŒÎ€Ç¸lÂŽÂ²IlxÄŠlÂ²Ã’mÂšÃ´Ä–Â™ÃˆlÂ„ÄµÂºmÂ„ÃˆÃªVÃ¾Â„xÉ›ÄŒÊ‰Ã‡ÄµVmÂšÂ„Ã’ÂƒÃˆÉ†Ã´ÆÅ°Ç€ÄŠÂ°Ã†Ç¬Ä®Æ¾bÂ„yÄŠ@Ä ÂšÆ’XÇ€Ä‹mÂ»Ã´wÂ°Ã›kÂ¥Ã‡mÂ¯Ã§Â™kkÃ‡Ç«Å£Ç•Ã©X_Ä¶WÇ–Ä«ÅŽaÃ†ÄµÄ¸ÂÄŠ@ÈšÈ˜Â‚Â™ÄŠLÄ¢Ä‰Â„VÃ†Ä‰ÊŠÂÃ‡Ä•Ã³aUÂ¥ÂšÄ‰Â°mkÃ…Â°Ä¡UÂÄ Å™kÂÂ°mÂƒÃ‘ÄŒÃ¿Â˜Ã›Æ’WÄ¸Â£Ê ÂšÃ†xÃˆÃžÅŽÂÃžÂ»ÊˆÂ²ÄŠÃ‡ÄŒalÃ’Â°ÂÅ¤Â±Ä¸zÂ„ÂŽÄŠKÃˆÂ²mÂ¤ÅŽÂ@Ã’Â°Â¼nyÈ‚UÅºÄ«Ç–Æ³ÃˆÄ“Â°@ÂšÃÄ¶Âƒ@ÂƒÃˆÂkÂlÂ¥Ã‡Ã§kxkÂ™Â›JXÂÃ‡ÂƒUÂÃ…@Â˜Â£kÂ»Â„Ã³Æ¿Ä«Ã›@lÂÃ…JlÂ¥Ã³Ã½@Â¯Æ½Ä¡Ã†ÂÃ…anÂ™Ä‹Â™Â°Ã©Â¯Â¹'],
                    'encodeOffsets': [[
                            128194,
                            51014
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1529',
                'properties': {
                    'name': 'é˜¿æ‹‰å–„ç›Ÿ',
                    'cp': [
                        102.019,
                        40.1001
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â™ÆnÇŸÆ¨Ê«ÂšÅ¹É†Ã¿Â°Â¯Ã†VÂ²ÂË¢Â™Å¼Ã¿@ÃÃ†ÅÈ°Â¯È€Æ³Ä‰Ã³Â™Â™@ÄŸkyÂšÂ¹@Ä«ÂšÂ›ÂƒwlÂ£Å¹ÂƒÂƒÂ¯Å¦Ã©@Â™Ã‡ÂÃ‡xÅ‹Ä‰Æ©UUÅƒÅLÂ™Ã‡Â™ÄµÃ³ÃnÂƒÃ³Ã§@Â™Â™Ã³@Ä¡ÂƒÆ±Â„Â¥ÂƒÃ§Â™WUÃ§Ã†ÅÂƒÂ@Ã©Â—Ã§Å¥KÂ™Ã§È­VÒ»Æ½Ì»aWÂ¥ÈÂ£ÊµÇŠÇ“Æ²É³ÃžÂ—Ç”lÂÅ¼ÃžmÄ Ã³Ä¬È‚ÂÉ²È®@ÃˆÄ¢Å®ÅºÃ”nÄ¶Å»Ç ÂšÅŽÈ­ÂœÐ³ÅƒÄ‹Ã³È­Å£Î—Ã†Æ‘ÃžÆ§Ã…Î«Ã³È˜Ç«É±ÈÄ¡lÃ›kÃ‡Â°ÈÃˆnÂšÃµlÂ¯Ã´Â„ÃžÉ›ÃkÄ¢Ã³ÂWÄŠÂ„zÃ‡É¼Ê@Ã‡ÃˆÄ·lUÄŒÃ…ÃœÄ·nÎ­Æ’Ç“KÈ®ÅŽÅŽbÂ°Ä¢Ç€ÅŒ@È¼Ã´Ä¬mÄ ÄŸÅ°ÅÄ–Æ§bÐ‡Æ§Åx@Ä·Ã³Â£Ã…lÂ±Ä€Æ§Ä«XÃÄ¡Ã†ÂƒÃªÄ‰KÂ°ÃÊ‡Æ…@ÎŒÊ‰Å¼Ã…Ã’Ï±Êˆ@ÂËºÆ¾Ö›à¥¤à¡¬Å£àª¶Ã³ÐˆÃ¨ÊžUÂšÂ¤Ò_Þ¸Æ‘Ê É½Ì¦ÃÉœL×ˆÉ›ÏœÃ³È‚JÏšÃˆ@ÇŸÍªaÃžÂ»È®Åº'],
                    'encodeOffsets': [[
                            107764,
                            42750
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1525',
                'properties': {
                    'name': 'é”¡æž—éƒ­å‹’ç›Ÿ',
                    'cp': [
                        115.6421,
                        44.176
                    ],
                    'childNum': 12
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ê¶Ä¬ÄŠIÈ˜Æ¨Æ¨ÂŽ@Ä¬Ã›Ä¢È™Å¤Ä‰Ä¬ÂƒÄ€Ã³ÂšUÂ‚ÃˆÅšÃœÃ¨nÅ¦ÆÈ¤È„Å‚Ï°UÆ¨Å¥Æ¾Ã‘Ü†ÄŸÉ²ÆœÇ”ÂÃˆÃ¨ÊˆÆ²ÄŠÆžÆ’ÂšÉ†Â¯Ì¼VËºÃ’ËºÈ‚Å¤VÄ¢ÃªUÃœÂƒxÂ„Ä€ËŒË˜Æ¨Â„Ã†Â°Ñ¢mÃžÅ¼UÂ¼Ã†lÅŽ@ÄŠÃ§ÅŽnÃˆÃ’ÍªÅŽÅºÂƒÄ¸UÂ°lÅ¼wUbÂ°Â°Â°VÂšÂ£ÃžlÄ Ä‰ÄŠLÃžÂÉ†nÅºÂÃžÂ„nÂ¦ÄŠaÈ‚Ä«Ä¡ÅƒÂ¯IÄ‰Å¯lÂ»kÂƒÂ„Â™Ã‡Ã½Â„Â¥ÅŽÂ¯ÂƒÃ©nÂ£Ä¡Ã‘Â™ÃÈ­xÂƒÃ‡Â™@Ã…Ã§Ä·Â»Ã³Æ±ÅŽÂ¥Â™Ã§WÃ¿ÂmlÂÃ³aÂÂ£Ã‡bÂ™yVÃ…ÄŒÃ‡VÂ»ÃÂUÂ¯Â™KÄ‰Ã½Ç•Ä‹Å£nÄ¡Â¯ÂÂ»Ã‡ÂÅUmÂ»ÄŸÂÂƒÃ‘Â™wÆbÄ‹Ã‡Ã…ÂŽÄ‹wË‹ÃˆÃ›Ã¿Ê‰Ã‘Â°Åkw@Ã³Ã‡Â»Ä‰wÂ™Â¥VÃ‘Å¹UÂ™mWÂ»ÄŸÂÄŸÇ‰VÃ¿Å¤Ã…ÅºÄ«@Å™Â¯ÄŸnÃµÆ@ÃžÃ…nÅVÇ‰Ã³JÂƒwÄŠÃ‘kÄ•ÃwÂ¯nkÂ¥ÅaÃ³Â¦Ä‰ÂƒVÂ¦Ã…`ÄŸÃ‘ÂƒÃ‘Ã@mwnÂÂ¯mÂ±@Ã³Æ’Ã›KËÆÇ“Â±UÂÂšÃÂ™aÂ¯lÂƒÂÅÂšÈ™kÂ„Ã¨ÂƒÄ¬ÃžÂŽÂn@Å¤Ä¡Å°kÂ°Ä‹x@ÂœÄ‰`Æ§Ä•Â°Â@ÂÅ£Ã’Ä‰wmÂÄ‰@ÂƒÂƒnÂƒÂƒaÂ„ÂÂ™Â¥Ä·nÂƒÃžÄ‰VÃ³Ã†Ã³kÄ‰ÂŽÄ·@ÃkÆ§Æ§Ã›aÂƒÂ°Ã‡@ÃÃˆUÂ˜Ã³bÃÂ¼@Â„Ã›Ã’VÂ°Â™@VÂ¼Ë‹LÂ™ÃžÉ…Å¤Å¹Ç VÃžÈ—Å¤Ã‡Ä–Ã…ÂšÅbÈÆœ'],
                    'encodeOffsets': [[
                            113817,
                            44421
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1506',
                'properties': {
                    'name': 'é„‚å°”å¤šæ–¯å¸‚',
                    'cp': [
                        108.9734,
                        39.2487
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ä¶LÂ²Ä¬VÅ‚Æ‘kkl@ÈŽÂ™Å˜WÅ„ÃˆÄ¬È—Â¯Â™Âºlz@Ä ÂšÂšÄŠÃ´Å¦Ã´Â„Ã’Ä Â°kÃžÃœÂšÂ™n@Â¤Â„UÄ¸Ã¨Ä¸bÅŒÃˆXÂŽÄ¸LlÃ’Ä¢xÉ²ÂÃ†Â¤ÃˆÃ›Æ¾JÃˆÃÂ°UÂšÃ…Ä¶Â»Â²VWÂ¯Ä¸JÃ´ÂÂšbkÂ‚V@Ã´ÂlbnÂÄŠyÃˆzVÂÃ´aÂšb@ÂÄ¸Â‚ÃžUlÂÂ°yÇ¬Â²Ç¬mÂ°ÂšÂškÂ„Â±lbnÂÂ°@ÃˆÂ»Â˜JXÂÂ„VÅŽÃ‘Ã†J@kÂ„LÂšÂƒÃ†lÂ²Â™Ä Â²ÊŠÅ¯ÄŠÄ¡Â‚Å™Ã³Æ›ÃžÃ…@mÂ„ÂƒmLUÃ¿Ã³Ä‰Æ§@Â™Â»ÂL@Â„Â›`ÄŒÄ¸mÂšÈ—Ã‘Å£Å¯Â±Ä‰ÄŸlÂ¯Ä€Â™wÃ‡ÂŽÂƒÃ§Æ§Å¤Ã›I@Â±ÃœÄ‰Ç“Ã§ÅÂ°UwÃ´Â™Ç«Å¯Ä·Æ³Ã…Â™Â±bÃ…Â£Â™Ã“Ã‡wnÃ‘Ã³@ÈÆ½@ÂÂ™ÂƒÃ‡Æ§Ä¢Ã³nÂ»ÅÄ•Ã³ÄŠÂ¯bÂ„Ã…Â™Â™VÈ¯Ã…ImÂƒÅKUÂ„Â™LÇ“Â±ÃxÄ‹Â—Å‹Â˜VÂÂ±Ä€È—Â°Â™Â„Å¹lÂ±ÂšÃ›@WÃ’ÈÅšÅ¹ÂÐÅšÃ…Ã¨ÅŒÃ´Â„Â¼Â°È°ÉžÈ‚VÄŠ'],
                    'encodeOffsets': [[
                            109542,
                            39983
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1504',
                'properties': {
                    'name': 'èµ¤å³°å¸‚',
                    'cp': [
                        118.6743,
                        43.2642
                    ],
                    'childNum': 10
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@É²ÅÄ¢Ç‰ÄŠwÆ¾ÅÃžÄ­Â°_ÅŽÅƒÅºÈ¹Æ’UÄŒÃ¿lÂ»Â¯ÂÃ´Ä·VÃ¿Ç¬Æ½Â™ÂÉ…Ä¡Ã…Ã‘Ç«Â»ÌÂÊŸÈ£UÂ™Â¯wVWÃÂÃˆÄ¡WÂ»ÃžÂ¹mÃÆ’É›ÅŽÃ¿ÅŽÅÍ©Å¯VÂ¹ÂÂ›ÅÂÂ™Ã©Ä‹Â™Ã³Å¹Ã…VVÄ¢Ç©Êˆ@Ä–Ä‹@Ä·ÂšÃ›ÂšVÂ°Â¯xÃ‡Ã…Å£Â¥Â™Â»Â°Ã›Ã´Â™Ä‰ÊŸÂ„Â¥WÃ½ÄŒÂ¥Â™wÂ‚Ã§ÂÂ»Â±mnÃ…Ä·Â¥Ë‹VÂƒbUÃ’Ä¡Â»Ã…xÄŸLÆ§Â™ÂƒbWÄ–Ã…xÂšÂ¦UÂ°ÃVÃ³Å°lÃ´Â²@ÂšÂ¥ÃœÃžÃ›Ã´Â„V@Â²Â±`ÂšÂ¦Â™Â„Â™Â¯Ã@Â„ÂŽÃ…Â„VÃ’ÅÂ¼Ã´ÂšÂ™Â¤VÂ²Å¹Ä¬Ã‡ÄŠÆ‘ÂƒÅ£xÂƒÃ§Â¯LkÂ»ÊŸlÆ½Ã½mÅ‚ÃÃ†Æ@mÃ¶Â°Ä @ÅšÅ¹Ä¬Å£Ã†UÄ€Ä ÇŠÄ ÂŽXÂ¼ÂšnÅºVUÃ’ÂšÂ¦ÄŠxÃˆÂ¼@Ã´lxÂ¯Å‚ÊŠÃ’ÃœÄ€ËŒÃ‡ÄŒxÃ†ÂÄŒÃˆÆaÂšxÂ„Ã’Ä ÂŽnÂ¼ÅŽVÃˆÂÂ‚Â¼Ä¢Â°Å¤mÇ–ÄŒÄŠÃ¾ÂšLVÂ°ÃžÂŽUÂ¼Ä‹ÃˆUÃ†ÂšzÃˆaÂ‚Â¤Ã´bkÂŽÂ‚nXÄ€ÂšÃ¨'],
                    'encodeOffsets': [[
                            122232,
                            46328
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1508',
                'properties': {
                    'name': 'å·´å½¦æ·–å°”å¸‚',
                    'cp': [
                        107.5562,
                        41.3196
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â²@Î–Ç€Ý´Ê¶Õ°Ä¸Â„Â˜Æ’Â¦Ä¶Â™Ì’UËŒÂ¼Ó¾Ã‡Æ¾Â¼Ì¨UÃžÄ‰Â˜Æ§Â—Ã©ÃÂ»ÂƒÄ•Ä‰Â—ÆÈÂœÅÇªakÃ³Â‚Ã³Â¯a@Â™Ã´Å£Â™aVÂ¯ÃžÂ¯Â°@Â²Ã©lÂ¥ÄµÄŸÅ¥wÅxÃ³Â¯kÂ±ÂšÂ—VÃ³@ÂÂ™aÃ³bUÂÃ‡yÄ‰zmÂŽkaÃ³ÂŽU@lÂÂ™aÃ³Â‚Ä·IXÂ°Â±UÄµÂ¼Â™Ã†Â¯VÃ‡ÃžÆ½IÃ‡ÃœÃ…Â£É±ÂŽÄ¡wkÃ‘Ä·KWÂÅ‹Ã‡Ä·aÄ·Ã§ÂƒV@Â£ÂšmÃ›Â™lÃÄŸÂ¯ÂƒÃ‘Å¥Ã³Ç¿Æ´È¯Â°Ã…Å‚@ÃžÅ»Ä€Ë¡ÂšÂ±ÂŽÃ…UÂ¯Â°É…Ä€Â™ÅºÆ§Ê¬mÇ ÂšÆ'],
                    'encodeOffsets': [[
                            107764,
                            42750
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1505',
                'properties': {
                    'name': 'é€šè¾½å¸‚',
                    'cp': [
                        121.4758,
                        43.9673
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã´Æ²Ä¸Â¼Ã†Ã¨Âš@Â„ÃˆÈ®wÆ¾Â»Ê ÂÄ¢Â¥VÂÃ†@Â²Â¥@Â»ÅŽÃ‘ÂšÂ¯ÄŠJÅ¤Â£kÂ»Ã†Ã‡XÂ¯Ì¼ÅÂšÄ«Â°aXÂ£Ã´ÂƒÆ¾ÈÅºÂ¥Â„ÂƒÂ™aÃ´ÂÅ¤Â™Ä¢LÂ°ÂƒÄ¸@È®Â¼ÃˆÃ’ÊˆÅšÃ´VXÅ¯Ã†aÄ Æ›ÃˆKÂƒÄ·ÂšÄ‰Ã´Ã¿@ÄŸÃˆÄ‰Â™Â»Ã‡VnÂ™Ä‰VÂ›wXÂÄ ÃÂ°ÂšÄŒÃ¿Ä¸wVÂƒÂ™Â¯Â¯ÇµÂ±Â™Ä‰Â‚Ç«Â™Ã…Ã…mÂ»Â²ÂÅ»Â±Æ½ImÂ¥Å£ÃˆÄ·@Â¯ÂšÆ§JVÂ»ÃžUÃÃ§Â¯UÄ¡ÂºUÂ£Å£ÂŽÃ³aÃ…Ã…lÂƒÂƒÂ™Æ§Ä«Â¯KÂ¯ÃžÃÂƒÄŸLÌ‘ÈÆ½@ÅÅŽÅÄ€Æ‘ÉœnÃžÃÂºXÂ¼Ã‡Ä¢ÃžÂŽUXÂ°xVÂšÊ È¤ÌÂÇ¬Â¼Ã†Ã’É†Ä¢ÂšÂŽÇ«Æ¾UÄ€Ã³Ä¸Â°Â‚kÂ¼Ä‹Ä€Æ‘VÅ¹ÈºÅÅ„Â¯`ÃÄ®Æ½ÅŽÄ‰xÄ¡ÇŠÉ±Å‚ÅÂ¦'],
                    'encodeOffsets': [[
                            122097,
                            46379
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1509',
                'properties': {
                    'name': 'ä¹Œå…°å¯Ÿå¸ƒå¸‚',
                    'cp': [
                        112.5769,
                        41.77
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ê Ç ÃžÄ¸É²ÈºÆ’Ã’È‚Æ›ÅŽaÃ†Â™ÃˆÄ•È˜Å£UÃÅºÇŸÉ†Å£ÂšÃËŒKUÂ»Âš@UÂ¯ÃœÃ‘@ÂƒÃžÂ»Ã´aVÂ—ÃžÃ‡Ãˆ@Â„Â¯ÃœbÆ¨Æ¨ÃžlÄ¸@ÄŠÂÃ´lÃ´Ã…ÄŠUÂ„ÃÄ¸mÂšÂ¦ÂƒÂŽÂ„bmÂ„Â„Â„ÄŠ@nÂ‚ÄŠxÅ¤Ã‘@ÂÂ¯Â‚Æ¨Ä–ÄŠ_@Â›ÄŒwlÂ¯Â™ÂƒÈ­LÂ›ÃÂ„Â»Æ½Â¯Ä·Å¯Â„Ç“@Ã‡Ç“bÄ‹Â™Ã…Ã…Ã†wÂÃ¿Ä Ã‡UÂ£Ã³aÂƒÂ¥Â¯aÅŽÄŸÄ Å£kwÂ°Â»Â¯Å¯lÃÄµkÃ‡Â»ÃÂ°É±Æ§Ç«aÃ³Ã´É±Â»Ã‡kÂ¯ÅƒÃ³ÂƒÊ‡ÅÅ»Â›Ä‰ÇŠÅ»Ä¢Â„ÂŽÂ¯Ã’ÃˆUlÂ°ÂƒxÂ°nÂ„Ã’Â™Ä¬Ã³nÂ™ÄŠÄŸÂ°Ã‡ÅšÄ‰Â¦ÊµVÂƒÂ°Â°Ä¬Ã›Å¼Ã‡JÈÅ„Ê‡Í´Ã³Ë‚Æ½ÅŽÂ›Ã†Å£Â¦'],
                    'encodeOffsets': [[
                            112984,
                            43763
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1522',
                'properties': {
                    'name': 'å…´å®‰ç›Ÿ',
                    'cp': [
                        121.3879,
                        46.1426
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã†XnlÅŽÂ°@LVLÄ Ã¾ÂœxÄŠUÈ®ÄŠnUÂ„ÂÄ ÂV@Å¼aWÂ¯XIÅŽÄ¡ÂƒÂ¥ÃÂ@K@w@K@IËºÅ»ÅŽÂ¦Æ¨ÂƒÆ¨Ã’ÅŽIÃ†@X@VÂºnXÂ°lÅŽ@Æ¾Ä‰Ë¤Æ’È˜Ç·È˜Ã‘ÃÃÂšÂÃžbVÅ£Ä¸Ã¿Å¤xÃˆÄ–ÆÂŽÂÃªÃ‡KnÂÄ¸Â¥Ã´@Â›Ä·ÃžUnÃ’l@UÃ…ÂšaÂƒÄ«Ë‹ÂƒÂ¯Ã‘Æ§x@ÂÂ±kXÅ™ÆÆÃ›Ã©VÂ™Ë‹Â»lÅÂ¯Ä‰Â„Ã…Ã‡Ã“Ç«ÃžÂ—Ä–Ä¡V@ÂÄŸÂ»Â›Â°ÄµÂ„Ã‡ÃžÇ“Â¼Â¯mÂ˜Ã›Ã…ÅƒÄ‰ÂÄ Ã‡Æ¾bÂ²Ã§ÂƒÂ™ÂšÃ©Å¼Â¯VÂƒÂƒÄŸÃžmlÂ»ÅÃ‘VÃ§Â—Â»VÂ¯Â™Â¯ÂšÄ•Ã†UÂ¯yÂ°kÂ¯Â¯VÂ»Ã´Ã‡Â„Ã‘Â°a@Å¹kÂ™Ä¡KÅ£ÂšÃ³ÂŽÂšbÂƒÂ„Å¹Â¦Æ½È‚Ã³Â„WÂ¤Â¯bÂ™Ä¬Ì»ÅŽWÂ°Ã…ÃˆlÂ¼Å£Â¤Ä‰IÂ™Â°ÅÃ’@Â¼Â±Â¦Ã…@UÂŽÄ¡Â¦ÊŸÂŽÆ½Â¼ÂšÃžÄ¢Ã’mÂ¤Â„ÃªÅÂ°ÂƒÂ¦ÃˆÃ¾ÂƒÂšlÂ„kÂ¼ÄŠÅ°Â°JÄ¢Å„ÈÄ¬Â„Â°ÂƒÅ¼nÂ‚Ã‡bVÂ„ÃÂ¼@Â¼Ã³Ä¸Å£Â¤@Â°Ã…nÂšl'],
                    'encodeOffsets': [[
                            122412,
                            48482
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1502',
                'properties': {
                    'name': 'åŒ…å¤´å¸‚',
                    'cp': [
                        110.3467,
                        41.4899
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÅºxÅ¼Ä€Ç”Ã†Ç¬VÈ˜Ä€Å¤Â¥ÂœÃ…Æ¾ÅÃ´ËÊˆÍ³È‚ÅƒÃˆIÃœÅ»Â¯Ä«Â„Â¯ÅmÂ™Â¯É±Ä–Â¯ÂƒÄ·Ã’ÃIÃÂ»Ã…VÂ™ÂƒlÃ…Ã´Ã‘Â„Ä¡Â™ÄŸVmÃžnnÂƒWÃ§kWÃœÂXÆÃ†wUÂ»È˜Ä•ÂšÂ£Ä‰Ã‘ÄŸÂ±Â±ÂšÃ…kÂ™Â„ÂƒK@lÃ…IÅÃ’ÂƒUWÂ‚Â—IÃ‡Â¼Â¯@mÂ‚kaÂƒÂ²Â™lÂ¯Â™Ç«nÇ«Â±Â¯zkÂŽÃVÄ·ÂUÃ´Â™Â˜lÂ²Ã´Â°ÅŽwÅ¦xÄ¶Ä kÂ¦Â±ÃªÂ¯@ÃÂ°UÂ°ÂšbÃ³Å¤@ÂšÂ°bÂÃ´lÃ´Ç©bÂ›ÅŽÆÈŽÄŠÂ˜Â„Ä–ÃžÂ¼Â˜ÃªÂ—Æ¨ÃÄŠ'],
                    'encodeOffsets': [[
                            112017,
                            43465
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1501',
                'properties': {
                    'name': 'å‘¼å’Œæµ©ç‰¹å¸‚',
                    'cp': [
                        111.4124,
                        40.4901
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ê¶UÄŠÂ¥ÃˆÅ™Ä Â¯ÂšÄ‰Ã´mÂšÄ«ÂƒÃ‘Â¯mÂ„wkÂ¯Ã‡VÂ°Ã‘ÂƒÂÅ¼Ä¡ÄŠÇ‰Ç“É±Å£Ç“Â›ÆÃ³XÂ¯ÂƒÉ›Ã’Ã³a@nÃÃ†Ã´ÆœÂÅšÄ‰Ä¢Ê‰Å°ÄŠÃ’Â™Â¤È—Ä–VÂ¼Ã…xWÆžÃ›Â‚lXXÃ¨mÂ„ÃmUnÂšÄ ÂƒÄ¢Ã³Ã’kÃ†ÂšÂ„Ã†UÃžÂ¼ÃžJÄ¸Ã‘Â°Â„É²Ä•ÂšÂ°ÅŽn'],
                    'encodeOffsets': [[
                            114098,
                            42312
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1503',
                'properties': {
                    'name': 'ä¹Œæµ·å¸‚',
                    'cp': [
                        106.886,
                        39.4739
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@È˜Â°Ã‡Ä«XÅƒÂšÅ—@ÈlkÆ’lUÅÂ±Ä«ÄµKÅÂ¼VÂŽÃ‡Ã´XÄ¸Â¯ÂŽ@ÂšÅ¥ÃªÂ„Â°ÅºÂ„kÂ¤Â„xÂ™Âœ@Ä¬'],
                    'encodeOffsets': [[
                            109317,
                            40799
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/ning_xia_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '6403',
                'properties': {
                    'name': 'å´å¿ å¸‚',
                    'cp': [
                        106.853,
                        37.3755
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nLVÂ‚@ÂšVLÂšaÃžbn@@lÂ˜Âš@bUÂVlUVÂ„zVxÂ™Â¤kÃžVÃ¨ÂšXnÂšÂ‚@nmÂ°a@UÂƒÃ‘Â„@VÂŽXnV@VaÂ„UÂšÂŽVKUUU@@UÂ‚@@KVa@UÂ²@Â‚wXkWÂnkÂ„Â±lLnU@UmmVKnIVWnI@ÂUKÂ›@UK@Â@UVKXkmWÂLWUXmlkVwUyVa@wÂ„w@aVIÂ„K@aVÂÃˆwÂ„KlLVV@LnVÂ„VVnUÂ‚ÃœÂ²Â°WÃˆIUÃ†@nÃžÂ¼Â‚Â‚@Â¦Â™@UÃžUVW@UxUxVnÂ„bÂ„KÂ‚bÂ¯ÃžU`VbÇ¬Â™V@XXÃ†VVlÂ°InmnUÃ´ÂƒÂ°Â¯Â‚anamÂ£ÂœWVXÂ‚KXmÂškÃ´aVU@ÂƒVak@@wmaÂƒn@K@UÃ›UWKXUÂƒÃ‡Âƒ@UIÂ™b@alW@akLUKV@@UkwÂ±IÂšÂ›nL@kmwkWmk@JUIÂƒÅ¯VmnÂnU@m@UÂƒKÂ„ÂVKlkUwkÂƒÂƒnVÂUKmbkIÂ±ÂšÂ—KÂƒkmVkKÂƒb@U@aÂƒVkUmnÂ™`kIlaUK@UUKmbUIÃÂšUa@mUa@aÂƒÂ„m@UUULUK@bmKkbWI@WXwlkXÂƒWa@k@ÂkKÂƒLVkkK@L@JUVmzUKlwUUnWÂ˜Â£XVlKUwVU@aXI@aWaUw@W@_nam@Â¯Â‚UkWVkUWaU@nwmJkUVÂkWVUmUkJ@ImbUaÂƒ@@WÃ…_mJknmak@@mÂƒXÂƒaUV@Â„ÂƒxUÂšÂƒÂ„@Â‚ÂƒÂ„@VUnkVÂƒ@Vn@`ULUbWLXVW@kbUJ@XW`Â@ÂƒnÃ…Ä–WJÂƒ@Â—ÂmÂ°@xÂƒxÂšbnÂUaÂ‚wÂ²lÂƒÃžÂ°xÅ¤IVVULÃ›Â‚WbÂšbkVVXÃ†`UbVLÂ„@kxÂ°LlV@VÂœÂ„WbÂƒJÂn@blÂ¤ULVÂ„ÂÂ°@lmL@ÂƒÂƒÂ£U@@aUwmKULVxUVVx@Â„Â™@kUÂ™@mKÂ¯LÃ‡aÂ¯@'],
                    'encodeOffsets': [[
                            108124,
                            38605
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6405',
                'properties': {
                    'name': 'ä¸­å«å¸‚',
                    'cp': [
                        105.4028,
                        36.9525
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â°@ÃˆbÂ°KnLÂš@lVÂš@@ÂƒUwVUUwVKnLVx@bV@Â„Â¤@Â„nK@kÂ‚Â¯UÂƒVKkÂ£@aÂ‚mÂ„IXaÂ›Âƒ@UkUÂ¯KlwÂƒ@UKVaÃ…_UWlUÂ™aXaÃœÂVKUUÅ£JÂ¯wÂ„ÃÂ±kÂxVbmÂŽÂ™aÂ„w@wnÂ¯Â˜ÂÂ„@XIÃ†Ä•Â„mÂ‚@X_@WVIlaX@WUXKVaVK@_UmÂ„@lUVm@UÂ„Âƒ@ÂÂ„ÂƒVÂ™Â„w@ÂƒVUÃ›wm@@W@ImKUkU@UaÂ‚aXÂƒ@wWaUKkw@UVaUamLUÂ™nk@Â»Â±`Â¯@kÂ—W@UaÂ™ykbÂƒIÂ„Â„@VWJkLWUkJÂƒwU@ÂƒnÂÂ¤mLÂ¯wm@UmÂƒÂ²XVWbnV@bmxÂƒVkxUblLUV@ÂkVWKUÂ¼ÂƒÂŽkUÂƒ@mn@JnV@bUnmJUn@Â„kÂ‚@XlxÂšLVVnKlLVV@Âš@LkKULVbk`WL@lkXW@kVÂƒ@UÃžUlÃ‡XÂ™lkaUbmVÂ¯@@L@ÂšÂƒV@bkb@xÂƒlWÂ„Â—bÂƒbW@Â—ÂÂ±@UJ@IU@mVkÂ„VxV@@lÂ„IllÂœn@Vm@ÂƒVUblÂ„@JÂLmKÃ›XmVkUÂ›KULU`@LÄ‰wÂƒKUXÂ„lVUl@VbÂ„JXÂ¦Ì¼bÃžxÅŽxÉœÄ–Ä Â„ÅŽaÃ´@'],
                    'encodeOffsets': [[
                            108124,
                            38605
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6404',
                'properties': {
                    'name': 'å›ºåŽŸå¸‚',
                    'cp': [
                        106.1389,
                        35.9363
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@Vnn@Â°xnKÂ‚Â£Â„mV@Â„xlIXVlKXI@UÂƒÂƒÂ„JlaÂšzVbX@lÂ˜Â°@Â²_@Â¼mlVÂšnKVbUb@VlxVLXb@xWÂ„ÂbVbV@VlnL@J@Xn@ÃœxÂ„bÂ„W@nl@nblmnIÃ†`@XÂ„@Vbna@aVUUWVkÂƒ@kbWakbU@VwÂšW@_l@nmn@@alVlk@UkmVak@@aÂ‚UXaÂƒL@Â¯@KVa@aÂxWI@KnkVaVJn_lJ@Â„X@Â‚m@nVanUVb@mXLlJÂ„ÂVWnLlaÂ„VVaVX@KXVVkVKlknKVa@aVU@KXb@klJUknUmÂƒ@K@_UW@alIUamaUÂ¯kJma@IUK@UÂ„@@UW@@aXLVÂƒVJVaXIÂƒKlaUkUV@ambUÂUJkIWJ@wUIÂ™V@JU@UwV@@Um@Â™nU`@UkUmVUxWUUV@aÃ…b@aWXkKUUÂƒUUaWK@wnm@IVU@aXwm@UmVaUalk@anKUwlÂƒUwlÂkK@wmaÂƒUkmmIk@VmkUUbW@UVUnW@kV@xkVmbVnUÂ‚Â™@UbUV@aÂ›k@kkW@Â„kLWÂ¤@Â„nV@VU@W_UVÂ™UU`VLUV@IUVÃµVULU@UUUJ@wmkUJ@ÂšWI@l@bkKkbVVÂƒbVbUL@UUJ@Vm@@L@xÂbVVVLVlVwX@Vb@bmUkbk@@JWIUVÃ…w@Km@UkWKXxWLÃ…@UVUnWK@xkVWÂ„@KULÂwWVXVWzXVVKVXkVÂ›V@VUbV@UÂ„VV@Âš@LXxVL@VÂ„bÂ‚ÂŽÂ„LnKVLVxXVmb@l'],
                        ['@@@J@aÂƒU@LWKÂ¯UUxVVn@Ä Â„Â„LUÂW@UbUUUa@KUX']
                    ],
                    'encodeOffsets': [
                        [[
                                108023,
                                37052
                            ]],
                        [[
                                108541,
                                36299
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': '6401',
                'properties': {
                    'name': 'é“¶å·å¸‚',
                    'cp': [
                        106.3586,
                        38.1775
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÂšUÂšwVK@UVWÃžUÂšbÂšwÂ„V@knVÂ˜@@KU_VK@KÂ„Âƒn@W_XWlL@Vn@ÄŠw@UlaÂœ@WanamÄ«@aÂƒÂ»Å‹Ã³@aÃ†Ã…É²Ã¿UaV_Â°ÃÂaÂƒLÂƒaUmVwVwX@VUVÃÂš@@Â¥ÂÂÃÂ»@mVÃ…Ã‡JÂ¯XÃ›Â±VÂUmÂƒUmU@KUUkKÂƒLÃ‡xUÂŽ@bÂƒLUJ@bÂƒx@xUbVzUxklWnXVÂ‚KnXWlUL@V@ÂŽVLÂœ@VL@ÂŽmJUXmJULnn@VmVkKÂƒÂ²mlXÂWlÂxÂ±@@VUb@LÂ@@VV@VVULÂ™ÂÂƒVUbU@WmUÂÂƒ@Â„Ã’@VÂ¯bmnÂ@VÂŽÂƒÂ„@lVnUÂšnVWÂŽXÂVl@Â¦VVUn@xÂ‚Âš@Â‚XL@Â¦Â‚lXxÂšÂ„Vb'],
                    'encodeOffsets': [[
                            108563,
                            39803
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6402',
                'properties': {
                    'name': 'çŸ³å˜´å±±å¸‚',
                    'cp': [
                        106.4795,
                        39.0015
                    ],
                    'childNum': 2
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@UÂ¯Ä·Ã³Â±Ã‡Ã›Â¯Â™Ä·mbXbÂ›@kb@VÄ‰xm@@UkKWXX`m@ÂƒÂ„@LULV`@LÂ—@mU@lÂƒUÂ™xÂ™aÃVUX@VULÂ™xÂ™VkLWVÂšÂš@JÂ„nVLXVlÂŽUV@zlÂ‚VL@V@bÂ„Â„n@lUÂ²WVLlLVbUÂŽVxUx@xÇ€LÂ˜xÃ´Ã’ÂœkÂ‚KÂ²ÂŽVaÂ‚U@wXa@ÂWÂ™ÃˆÄ‰Ua@ÂÂ‚bÃˆkÂ„m@Â¯'],
                    'encodeOffsets': [[
                            109542,
                            39938
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/qing_hai_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '6328',
                'properties': {
                    'name': 'æµ·è¥¿è’™å¤æ—è—æ—è‡ªæ²»å·ž',
                    'cp': [
                        94.9768,
                        37.1118
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@Â„ÂVÂ£Â°ÂÂš@laÂœXÃ´Â±ÅºwÂšÂ™Ã´@Â„UlÂƒÅ¼aÃœÂnÂÂ™KÂƒw@UÂ„aÂƒÂ™ÂšaÂ²LÂ‚mÃˆLÃ†ÂšÃˆxlaUaÂ„wÃžmÃœbÃžUÂšÂnJÂ°aÂ„kÃ´ÂƒÂ‚Ã‘kwÃVÄŸwÃ‡@ÃkkVÂ¯Â¥@ÂÃ²ÂÂ„Â»Â„nÅ¤Â¥XImw@mVwÂša@ÂÃ…wÂ™ÂmLkaWÂÂ—wÂƒÂ¥lÂ»kÃ§ÂƒÃ³Â„Â»@ÂƒWÃ‘Ä‰ÂŽÄŸÂ@Ä‰Â„Â™Â‚ÅƒÂ„ÂUwÃ³Å™VÃ³mÂÄµÂ»Â™Â™Ã@VÇ•Â¯kÂšÃÄŠÃ…kÂ™Â°Ã“UklkUÂ±ÂšIÂ„Ã‡ÃžkÂƒÂ±@ÂÂšÂÆ½JÂƒÂÂ™@UÂÄ¡Ik@WÂ¦Â™VÂÃ‘È™Ã“Ã…nÅ¥KULnÂŽÂ¯XÂ›Âƒ@ÂÂÂ¯mUÃ›@WÃ…Â™mÃ³KknÅbÂƒxÃ@ÂƒÂŽU@kw@Ã¿Ã‡LÅ£ÂšÃUkÂšmwÂƒÂŽÂkÂ™lÄ‹VÃ…ÂšUÂ¦Â™ÂŽÂƒLkUWlÃ…Ã‘@aÂƒ@Ã…Ã‘Â±UÃ³Ä¡Å¹Â¼ÂƒÃˆÄ‰mÅ»@@wkwÂ™KlÂ¯UÂ™Ä¡@Â—Â„lÃ‡UÂÂ™Ã“Â¯_ÂƒÂ‚WaÄ‰Â²Ã…lÃ³Â¼VbknÂƒKÃ‡ÂŽÃ…@Æ§Ä¢ÅÂ°Ã@ÄŸÂ„WÂ™Ã…xUUm@Â™Â‚ÃXÃ›Â‚WÂ„ULUÃ¨Â¯@mbUaÂƒLÂƒbUWÄ¡xÂIUJWzÂ™aÂ¯bÂ™yÂ™@ÅÃˆÃ³LU`Ã‡XUlÂ™UÄ‰VÂ¯nÂ›mÃ›bÇ•LklÂƒUÄ‰VÂƒÂšÃ³aÄ¡Â„ÆbÄ¡KÅ£nkbÃmmnÃWÈ­ÃˆÂƒÂŽÃXÅ£WÃ³ÂkUÃ‡lÂ¯UÂ¯Â‚Ä¡UÉ…Ä€@Â°Â¯Â„Â„ÂšÂ¯Â„VÃ†nÂmJ@ÄŠÄ·nÃ³JUbÃXUlVÂškL@lVxnnmb@Â¤VzÂš`ÃžÃžÅ¤@Â„VnÂÃ†JVÂ„Â°bÂ„UÃ´JkzlÂŽkl@Â²Ã³Âš@Ã†Ã‡Â°kÄ–ÂƒÂšÃ‡bÃ›U@lmbÂ™XVÂ˜kzÂƒVÂ™ÂŽÉ…Ä€XË¢lÅ„Â„Ä¬Å¹@Â›Ã©Ã…@Ä‰Å„Ã†Â°ÄŸbUÂšlÂŽÉœ_Â°Â‚@xÅ¦ÂÂ˜ÂškbVbÆ’KÄ¢Â„Å¤VÅŽÂŽÂ°@Å¼ÃˆÅºlÄŠÂ„Ã´KÃ´b@nÃ´xÅ¦Â„Ã†@Ã´ÂŽÅŽL@Ã¾Ã†b@ÂšnnÂšWËŒbÃˆxÂ‚InaÅŽxlU@Ã‘Â²Â±ÂƒÄŸVUÄ¢ÂƒÆ¨bÉ²@ÃžÂ¥Ã´UUÂÄ·WVÂÃ´Â¯ÄŠWÊ¶nÃ´aÅ¤Ë@Â£nmnIÃ´ÂŽÇªKÂ°xUXÃ´@Å¦aÂ°mÂ‚kXÂÃ†ÂÃžVÅŽkÄŠÂ°ÃžLÃˆÂ„Ã´yVaÂšIlwXÂÂ°UVwÄ¢Ã‘ÃœKÃ´w@nV@ÂœmÂ°nmÂŽnÂ„ÃœÂ‚ÉžÂ£VbmÂŽXnÂƒÂ°ÃœÃ’@xÂx@VÂ‚bÂ²UlbkxVnÂšJUnVVÄŠÂÂ°KÄŒÂšmÂ°nxÃ‡nnÂ¤Â±Â¦@ÂŽUXVV@Â„ÂlVÂ„Â„bmVVÃˆÂÂŽVxÂšÃ’Â™Â°ÂšIÂšbÅºaÄŒÂƒÂšbVwÂš@ÂšÂƒVLÂ„Â™Æ¾Ã‘@ÂƒÅ¦ÂÃ´Â¯ÄŠkÃ´Ã‘'],
                        ['@@Â„@ÂšÂƒÂ„@nÂ„Ã²VÂœaÂ‚wÂ²bVxÂšxÃœaÄŒVÃ´_ÄŠJÂšIVmÂšLÂ„aÂ°@ÅŽÂ¥XÂlK@ÂƒÂškÂ„lÂ„KVbUbÂ˜@nUÄ¢nÂ‚aÃˆ@lmÇ¬Â»Ä Â¯ÂœnÂ‚mnÂƒÆ¨ÂVyÂ™Ã‘Ç–Â™Ä Â»É²InÂŽÂ‚@@Ã…Ä¢Æ³@Â¯Â°Â™Ã´VÂ„KÃˆbVIÃ‡Â¥Â¯@ÃÃ³Â„Â™@Ã‘nÄ«WKÂšÂƒkÂ™Â‚k@Â¥ÂšÂ™Â¯Â™Ã…aÂ™XÂƒÂ±VÂÃ…w@Â±Ä Â¯@Â»Â™ÂÂšÂ™nÂ™WmÂw@ÂƒÂ™Â@ÂÂ¯ÂƒVÂƒUUWÃ§ÂƒKÄ‰Â„ÂaÂ±VkkÂƒVÂ¯wÂ™x@ÂšUJÂ‚x@bknÃ‡bÂ™mÃ…@UwÂ±UÂ¯Â¦UÂŽÂ™KmÂšÂ¯IÂ¯ÂŽÅ¥Â¼ÄŸÄŠÂ™@Ã‡ÂƒÅ¹ÃˆÂ¯@ÃÂ»Ã‡nË¡JÂƒbÃ›Ã¨Ã‡nÂƒÂ„Ã…KÂ¯Â„Ä¡Ä Å¹ÂWÂ¼Ã…lmÂ„@Â¤nÂ²ÂƒÂŽÃb@bÂ„ÂšÂ¯lÂƒÂÂ¯@ÂƒÂšÃ…Â¤WÂ„Â™Â¼nV@xÂ„Â„Â°@VxÂ„@lbUblbXÂ¼WÂ‚ÂœÂšÃ‡Â²lÂšUÂŽ@Â¼ÂÂŽVÂ¦@bÃ‡lVxUbVxÃžbVÂšÂœbmÂ¦ÂƒVVÂ„']
                    ],
                    'encodeOffsets': [
                        [[
                                100452,
                                39719
                            ]],
                        [[
                                91980,
                                35742
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': '6327',
                'properties': {
                    'name': 'çŽ‰æ ‘è—æ—è‡ªæ²»å·ž',
                    'cp': [
                        93.5925,
                        33.9368
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@É†Ã¿Ä¢VÂ°ÂÂ°VÃˆklVÃ´ÂÅ¤XÃžWÂ„ÂÈ®Ã‡ÃžXnmÃžnlaÅ¤mÄ¢LÆaÄ¢ÂƒÃ´bÂ„Â™ÄŠUÂ„VlkÇ–KÃœaÂœnÂ°mÄŠUÂšVVkÃˆWV_Ã´KÅŽÃ‡Âš@ÂšzÂ°aÂšbXyVIÂ‚JÄ¢wVXÂ„aÂ„KVbnaÂ°@VÃ§VKXÂƒÃœÂÃžWÂšÂn@VVÃ†wXÂšÄ ÂƒÃž@ÅŽÂ¯Æ¨Ä¡Ã†@ÃˆÂÂ„LlmUaÃ´Â»Ã†kÄŠÂ±XbÂ„ÂÂ°`ÂšÃ”VÂ‚kÃˆÂ˜ÂƒÄ¢@VÂškÂ°ÂšLlx@xÅ¼@ÄŠnÂ„Ã‡ÅºÂ»Ã´Ä¢Â²VÃ†Ã’Â„@@bÃ†Ã’XklVÂ„KÂšÂVÂ¥Ã†Â™ÄŒUÂškÂ‚lÂ„ÂnxlÂ™ÂÃ§ÂƒÂ¥Ä‹Ã§@Â±ÂÂmÂ¥ÂƒwÃ…JÂƒÂ@Â™Â™Â™VÂƒÂ„mÃˆIlÃ©ÃˆaÂ°ÂUÂ¥Â™Â™@kÃžVÂ‚KÂ²Ã‘WÂƒÂ°wÂ²Ã‘Â‚KÂ²Ã±ÂšyÃ†ÂÂ„ÃÂšVmwÂ„Â»kkWÄ‰Â—JWUÂƒVÃ…wÂƒLÂ™mÃ…@@ÂƒmwÂ„knÂ¥VÃ‘ÂƒÂ»Â°Â™Â°@@Â»Â„Â¯Â„LlaÂ„JÃ´ÂnVÂ‚UÃ…Â¯ÂƒU@WÂ¯UmÃ‘Â¯Â¯k@WykU@Â¯Â„wVÂ¥ÂƒkVwÅ£ÂƒkÂ»ÂšwWÃ‡ÂœÄ‰Ä¶Ã§ÂšKÂ„ÂƒÃžÂ™Ã‡aÄ‰bÂƒIÂ™lUÂÂƒ@kwÂƒWÂƒXUÂƒÂ°wÂ™Â±@UÂšKnÂ£WÄ‰Â—KWxÂƒkÂÄ•VÂƒÂšamwXwÂ™@Â™Â„Wmnk@aÂƒVkÂƒÂ™bÄ‰LÂƒlÂ™ImmÂ„wUÂÃ‡Â‚ÂÂWxÂ™nÃJnÂ@Â¥Ã†Â™kwÂƒaXÂƒÃœÄ‰Â™Â¯Ã…VÂ¯Â¤mkÂƒxÂ¯kÄ·ÃœÂ™Â²ÂVWÃ´Å¹VUÂƒÂƒ@VÂ£Â™Â¥@ÂƒÂ°wnÂ@Â™mÂ@ÂÂ¯@UbUÃ´Ä·ÂŽmn@Ã†Ã›@Ã‡Ã½VaUÂÃ‡ÄŠÂVÂƒ@Ã‡lÄŸÂ—Â¯xÃÅ¤Â™lVÃˆÃˆVÂƒxÂ„ÂÂƒÂ¤VxÂ™Â„kK@ÂÂ™@Âƒx@Â„kVÂƒÄ–Ä¡Â¥kIWbXÂŽÅŽx@nÂƒxÃ…UW`Âƒ_Â—@Â±ÂŽUaÂ™LUxÂƒKÂ¯Â„WbkVlbÂ—bmÂŽÂƒLÃ›Ã†WIUwÂƒWkwÃV@ÂkIÂ›ÂŽÂÃ©UbÂ›UUkÂ™VÂ¯KmÂ¯k@UmÃÂÂ¯mÂ¯ÂÂ›mÂ—LÂ›ÃžÄ‰Â‚Ã›UmÂ™Ä¡Â£UxkKmÂ°Â™LÂwÂ›Âšk@kÂšÂƒVmÂ„ÂƒKÂVUkÂ›@Â¯aÂ¯Ä¢Â™mÃ³KUUÂ™xÂ™ImlÃ…nÂ™Â™Ã‡bXÃ¨VVUÂ„Â°Â„@ÂŽÂšÂŽ@Â„Â‚xXnmÂšÂ™ÂšÂšÂŽ@Â¼ÄŸÂ°@Â²Ã†xUÂ‚Â„Â²ÂšWÃ†bÂ°ÂšÂ™Âš@Â¦ÂllÂšÂ™Â„XLmÄ¬@Ã’ÂƒÂšÃžÃ´Â°@ÃˆÂ¦UJÃ‡aÂƒLÃ³UÂ¯Âš@Â°Ä¡Æ´@Ã†Â@mÂÉ±JÄŸÂ¼Ç•ÂšÂšÃ’UzÆ§Â‚mÂ„ÂnÂ›mÄŸÂ°Ç«Â¼knÃ‡@ÂbÄ¡mmVÂ—@VaUaÂƒLÂƒkÂ™l@Â„kLWÂ‚ÅÂ¦Â¯@ÂƒbÂ™KUnÂ™JÄ‰IÃ³`Ä‹UÃ›bÂ™wUwÂ±aÂxÂ›bÃ±UmÂƒÂƒ@Â™Â„Âƒ@Â—bÂƒaÂƒbÃ‡ÂÃ…XmÂ˜Â„Æ’ÃÂ„Ã…Ã´VbÃžÂŽÂ™blÂ„UÂšÃžVÃžÂšÂ„UÂ‚Â°Â„VUxÂƒ@UÂ„VÂÂ„@l`Â™Â¼nL@ÄŠÂ„LWÂ„Â„Â¤kXÄ·WÄ¡XUVVVÄ·Â„UbVb@Â°kVVxÃˆaÂ‚@ÄŒÂ¦ÄŠbÂšaÅºJÂ„U@ÃˆÂšÂ„Â„Â˜VÂœÂƒlÂš@XkÃ´aWÂƒÄ¢Â™Ãž@laÄ¸UÃ†bÂ²mÃžLÄ Â™ÃžÃ‘Ã´bÂšÃ’ÄŠaÂ„JVbmÂ¦'],
                    'encodeOffsets': [[
                            93285,
                            37030
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6326',
                'properties': {
                    'name': 'æžœæ´›è—æ—è‡ªæ²»å·ž',
                    'cp': [
                        99.3823,
                        34.0466
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÃžVÅ¤Â™ÃˆK@Ä€lxV@Â„ÂÃž@Â„wÅŽalmÃ´LÂšnXÃ†Ãœ@nVÂ‚Â°@ÂÂœÂ„Â°WmÂVKÅ¦LÃ†mÈšÃ”Â‚Ã’ÂšUXÂ¥l@Ä¢JVÂÂš@Â„ÂŽÆ¾I@wÂ™WÂ°Â™Â™Ã…nÂ¥Â›kÃ…ÃVwÃ´ÂƒÃˆÃ§Â„@lÃ‘ÄŠÄ•ÂšaÂ„JnaÃ†LVwÂ°knyÂ°UnkÃ†VÄŒÂÄŠllÂ¦Â„VÆ¾@@Â™nUÅºÂƒÃˆÃ‡Â‚InÂÂ°XÂ„wÃžKÃ´Â¦VWVÂ£Â„Â@Â£Â°Ã³kÄ‹Â±IÂÂ™Â™amÂ¯VaÂ™Â»ÄŒÄ‰VÂ¥Â°Â™@mÂ„kÂ„Â¥l@Â„ÂÄŠm@aÂšÂUÂ™mwXÂƒ@wÃ†xÂšmÄ¢_Â„`VnÃ†bÂšKVwÂ„@@ÂƒnUVÄŸVmVVÃ¶IlÂŽl@@Ã§Ã›mÂƒÂ£UÃ‡Â„wÂ°@VÂUÂƒÂ¯Â»mÂ¯ÂƒJÅÄ–Ã…LÂƒa@Â»Ä‰Ä¢Â±`U_k`Ã‡Ã§ÂšÃ³ÂƒkXÂ™lK@ÂÂƒakÃÃžÂƒÂšÂ£WÄ‹kÂÃÂ™kxÂƒJÃÂ¯Ã…wÂ™xÄ·xmIÃ…xÂ„Â@kÂ±J@Ã½Å‹ÂšÂ›Â¤UÂœkÂŽmVÂ™Â°Ã…ÂÃxkwmÄ¡ÂƒnÃVUÂ„ÂšÂ¦ÂƒÅ¤ÂlmÂšÃ³XkÂ¤Â™ÂUKÂƒÃ§Â™@mVkK@klÂÂÄ«ÂƒÂ£mÂšÂ¯VUbÂƒWÂ¯Â¼Ä‹bÂ¯ÂÄµamÂ¼mVXÂ„m@kÂ¤Ã‡XÂÂ‚Ã‡bÂƒUÂƒÂ„Â¯JÂ¯Â„Â¯Ãˆ@Â˜Â™bVXVÃ’Â™Â¤VÂ¼kxÃÂšVÂÂÂ„@lÂ‚VÂ—Â„WxÃ›Â¦WÂšÂ¯ÂšmKÂnlÂŽkÂŽÂ‚ÂšUÂÂÂ‚@nÆ‘UÄ‰Â„Ã@Ã‡ÂºÃ›Â„Ä‹UÄ‰Â¥Â™UÂƒÃžÃ…ÂÂ™zÂ±Ã²ÂLÂ±Ã’Â¯xXÂ„Â±Ã’ÂLÃU@lÂšÂšVÂ¦Â¯Â‚Ã‡bkÃªÃ‡JÂƒnUÂ„ÂšÂš@ÂšÂ„Â‚Ã†IÂ„xnÂ¦Â‚Â‚@Â²ÄŒÃ¨Â„Â¦Â‚Ã¨'],
                    'encodeOffsets': [[
                            99709,
                            36130
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6325',
                'properties': {
                    'name': 'æµ·å—è—æ—è‡ªæ²»å·ž',
                    'cp': [
                        100.3711,
                        35.9418
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VxÂƒÂŽÂÅ„ÂƒÂš@ÄŠÄ ÂŽÄŠÂXÃ’Â°UÆ¾Ä•ÃžmÂ°Â£nb@Â‚@LUUWÂ„Ã›Âº@nlÃ†Ç¬ÂšÄ Â£ÃžVÂ°UXbÂ‚VÈ‚ÇµÂ„Ã©Âƒ@ÂkWanmÂ°@Â™xÂ„zÂ„KÂ°Â¯Ä VÂšÂƒVÂƒkwÂ™LnmÂ°kÃžxÃ†aÂ„Â¥@ÂÂ‚wnÄ‰Ã†Â@Â™Âœ_lÂ›Âš_VwÂšmÄ¸Ã¨Å¤Ã…ÄŒU@Â™Â˜WnÂ@Ã‘mKUÂ™nÄŸÂƒK@ÂƒÂ°Â¯UÃ¿VÂ£nmÂšLlÂ™Â„UÂƒUÃ›Ã©Â±Ã³Ã³kkmÂƒnÂƒakV@Ã‡Â°Ã³ÃXÂƒWÉ™ÃžÅ¥IÅ£xmmÂ™VÃ›UVÂÈ‚Ã“nÂWyÈÄ‰kÂƒVÂÂšÂÂ°WnkÄŠaÂ„Â¥Â‚_ÂœKÂ°Ã¿WÂna@ÂÂƒmUÂÂ¯wÂƒlÃIUÂ¤UXÃ³Â¥ÃLÂƒxÂ¯WmÂÂJÃ‡ÃˆÅ¹Â„mV@ÂšÆ½@ÂƒUkÂ¥Ä‰kÄ‹ÂŽÃ…UmlÂ¯VmzÂ¯lUxÃ…KmbÂƒIÂ™bÄ‰Ä–kÃ’Âƒ@Ã‡Ã¨Ã³Â„UxÃ†ÃžÂœlmÂ¦ÂšÃ†Â¯ÂšÂšX@xÂ™ÂŽ@ÂŽÂ„Â²ÃlÂƒÃˆÂ™JVÂ²klVlÂ¯Ã”lÂšÄ‰Ã†Â™ÃžÂ°lUÇ–Ãž@ÂšÂšÄ¶Â¼nÂŽUÃ´Ã´Åš'],
                    'encodeOffsets': [[
                            101712,
                            37632
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6322',
                'properties': {
                    'name': 'æµ·åŒ—è—æ—è‡ªæ²»å·ž',
                    'cp': [
                        100.3711,
                        37.9138
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÅmÄ¡xÆ½ÂUmÂ±LÇ¿Ã¾Ä¡Ã”Â™@kxmWÂƒbÂ¯IÂ¯Â‚mIUx@bÂƒbÅ¹VÃ‡ÂŽÂƒkÄµbÂƒlÄ‰IÂ¯Â¥ÂƒUÂšm@ÂƒÃ†Â¯Ãˆ@ÂšaÂšÃ³ÂšUlÂƒÄŒÂ»@wÂ›ÂÂœÂ»Â›wXaÂƒÂƒÃ³Â°Å£Ã§ÃÂ„kUÂƒaVÂ¥Ã…bÃwÂ¯lmnÂšKlxUÂ„Â™Â„ÄŸUÂ¯Â°ÂƒLÂƒyÂšwÂ¯@mnXbÂ‚lÂ„@ÂƒÃªÈÇ¶ÂUWaÂ¯VÃUÄŸÂ¤Ç«Â™kÃ…@mÃœÂ¹XÂƒVV@K@ÂmaÂ¯Â¤ÃnÆ½Ä–Â¯V@Â„ÂƒÂ¼Â„Ã´lÃ¨kÂ¼Â„Â¦Â˜xXÂŽlbnKÂšÂÃ†x@ÂŽÂ™bUx@nnxWJÅ£Â¦ÂƒmÂƒÂ¼Ã±Â@ÂŽÂ°Â¦lUÃžlÃˆ@Ä xÃžUlxÂÃ’Ã³Â„ÂƒlÂ¯bmIÂ™ÂŽÃVÃ›aÃnÂƒxVbkbÃ‡wÃ…Â™Ã‡KÂnÂ±KÂ™bÂ„ÂšÂƒb@VÂ„xÂšLmÂŽÃ›ÂŽÅ»bkÂ„ÂƒVÃ³@Â™ÂšÅ¹xÃ³Â²Â›WkbÂ™@Â¯ÂUÂ¤ÂƒÂÅºÄŠ@lUXÂ„Â°lÃ†Ã´UÂ„ÂƒlLXÂÂ‚aÂœVÂ°wÂšxUbÂ°xÃœÃ´ÃˆKVkÃˆmlwÂškÃˆKÂšwÂšKÂ™Â™VUÅ¤Ä‰ÅŽÂ»Â„Â»Â„IlÂ¥naÂ°LVÂ»Â²Â¯Ãœy@wÄ¢ÂƒÂ°ÂÄ¸wlwÄ¢wÂ°Â±Â„_lVkÂš@Â°ÂƒbÂƒÃ†Â¯zÂƒÂ‚Â„ÂšÂ„@l_Â„@Ä¢Â±lÃ…ÂšVlÂUaÃžÂƒÂ„LVÂƒnKlnÃˆÂÂ°IllÄŒaÂ˜wÃžÃ‘Â°xÂ„UUÂ™@wÂƒÂVÂkmÄ LÃ´Â»Â„KÃžÃ½Ã´aÃžÂ¥Ã´Ä€ÃžmÃ†ÂÂ„Â™Â‚mUÂƒÅŽÂVÂ¥ÃˆlÂ°Â²Â°aÂ²Â¥VÂÂ„@@wÂ„amm@Ã‘n@Ã†Â£Å¼ÂƒVÂƒÄ Â£@WÂ„Â¯ÃžÂƒÂšÂl@ÂšÂ»@Uk@'],
                    'encodeOffsets': [[
                            105087,
                            37992
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6323',
                'properties': {
                    'name': 'é»„å—è—æ—è‡ªæ²»å·ž',
                    'cp': [
                        101.5686,
                        35.1178
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã´lÂ²Ã´ÃœÃªÂ„VÂƒVkÂšÂ™KmnUÂ¤VÄ€Â¯Â°@Â„Â„LmÄ VÂšnLÃˆL@alb@al@nÂÂ°VÂš_XmWUÃˆamaVIn@nÂÂ‚aVÂ£ÂœÃ³VWÂƒÂ™UÂ£Â°aÂšxÃˆÂ¥@Â™Â‚aÄŠwÃˆÂ¹@Ã³ÂšaÂ™ÂƒÄŸbmÂ@kÂ„w@mÂƒaÃ†w@ÂƒÂ„InÂ¯mmÂƒ@UkkWÂƒÃ‘Ã…@@kÄ‹ÂÃ…Ã§VkÃJÃ…kVykÅ¹lÂ¥@Â¯ÂšÂ™Ä¢UÃœÂƒXÂ¥Ã²Ã½Â—mmXÂ™ÃÃ…lmU@Â£Â™WlÂÂyÂ™XWÂ»Ã…bÂƒl@aÂIÂ›Â»k@klm@UxUUÂƒVÂƒÂ¼Â¯XÂƒlÂ™aUnÄ·Â‚ÂƒI@xÂ™@Â¯Â„ÂƒKÂ™Â„Ä‰UU`Ã³ÂšlÄŒÂ¯Ã´@Â¤ÂƒÂÃžJÂ„kÂ°xVÂŽÂ„n@ÂŽmbXÂŽÂ¯Ä€Â›LÂ`ÂƒÂ¦Ä‰bmlÂ¯XÂ™ÂŽUÂŽlÂ„È‚ÄŠXzmÂ‚ÈÃ”UÂ‚ÃœVÂšUnnÅ¤wÅ¦JÉšÃÂ„XÃžWÂ¯Ã´@ÃˆlUÂ„bÂ„mln'],
                    'encodeOffsets': [[
                            103984,
                            36344
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6321',
                'properties': {
                    'name': 'æµ·ä¸œåœ°åŒº',
                    'cp': [
                        102.3706,
                        36.2988
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@Ã’Â„bÂšÂ¤Ã†IÂ°Ã´UÂ¼ÂšÂ°UÂŽnnWxÂ™Âš@bÂ¯L@lUUWbXxWlÂ„Æ¨nxVÂUllÂšÂ„XVÂŽUÂŽnL@lÈ€Ã½Â²KVnÆ¾Â‚Ä¢wVÂ»ÂƒÂ@mÃžÂ£nÂÃ†ÂƒÃžÃ‘mLÂ™ÂÂƒKUaVÂÅ¼Ä•ÂƒWVkÂ²ÂÂƒÂƒÃ†Ã@ÂƒXwÂ°@Â„ÂÃ´Â™@aÂ°wÃ³UUÂmIkÂ™Â™aVmÃžwmknyÂƒÂ¹VÃ¿Æ§nÃ…ÂmÂ£XÂ»Â˜Â™naVÂ±Â„ÂÃw@aÂšb@aÂƒmÂ¯Â„Ä‰VÃ³Â¦kÃWKUÂU@WanUÂ™b@Ã´Ã‡ÂºÄ‰xÂb@ÂšÃ‡Â¦Â™wÂ¯bVÂ¤Â„ÂšUXÂ›Ã´UÂ¤ÂbmÂm@UJnbÃ‡bXVWnÂ™`Â¯UmÂk@@bka@bÃ‡K'],
                    'encodeOffsets': [[
                            104108,
                            37030
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6301',
                'properties': {
                    'name': 'è¥¿å®å¸‚',
                    'cp': [
                        101.4038,
                        36.8207
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@kmKVÂUÂÂƒWkÂ™VkUÂmwÂƒÆ§XkWwXaVV@kÂ°K@aÂšÂ™XwmmVÂÂ™Â¯VÂ»Â¯Ã³Ã…JÂ™Â£ÂƒamÂŽÂ—X@ÂšÄ‹VÅ£Ã†Ä·Ã§Â™nUxÂ™`kÂœÂ›`@ÂšÃ…ÂmÄŠÂx@ÂŽÂƒÂ¦UÂ¦Â„blVÃžÂƒÅ¤Ã¨Ã´Â¯Â„Â„WbÂœxÂ›Â¼ÂœÂŽ@xÄ‹Â¼kÂ„Â™VÂ™Ã´Â™bÃ‡@Ã…Â°@Â„Â™nÂ„VÂ°Â¦ÄŠJÂ„kÄ¶aÂ„lÃˆÂÅºUÂ„a@aVwnJÂ°ÂÂ°JÂ„anXlwÂš@Ä¢Ã“'],
                    'encodeOffsets': [[
                            104356,
                            38042
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/shang_hai_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '310230',
                'properties': {
                    'name': 'å´‡æ˜ŽåŽ¿',
                    'cp': [
                        121.5637,
                        31.5383
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@uÅuÂ»GPIVÂ±ÃÉƒÅœ{\\qJmC[W\\tÂ„Â¾Ã•jÃ•pÂ‡nÃƒÂŽÂ±Ã‚Â|Ä›Ã”e`Â²Â„Â Â†nZzZ~V|B^IpUbUÂ†{bs\\a\\OvQÂ’KÂªsÂ†MÅˆÂ£RAhQÄ¤Â‹lA`GÄ‚A@Ä¥WÄOÂ“'],
                    'encodeOffsets': [[
                            124908,
                            32105
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '310119',
                'properties': {
                    'name': 'å—æ±‡åŒº',
                    'cp': [
                        121.8755,
                        30.954
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@`yÂ”Ä‰NÇ•DwÇÂ»ÂƒÃ–LxCdJ`HB@LBTD@CPFXANC@@PGBKNECCBB@EBFHEDDDSNKAUNBDMNqf[HcDCCcFÂ…@EFGLEBa@ACoCCDDD@LGHD@DJFBBJED@BGAEGGFKIGDBDLBAD@FHBEF@RFDMLE@SGANFFJBANPH@@E@FJjRIACDMDOEKLFD@DbDAJI@AP@BGHFBCBGDCC@DCA@CECGH@FKCEHFJGBFDIHACEDNJDCVFBDCRKRLDLITB@CjNJI^DBCfNVDHDFKHAFGDIICDWBIF@@CFAjFJNJBBHD@CJ@AEFJ@@DH@BFBCPDBMFEQGDIFCNDHIP@HDABFACBJFHEBSZC@DP@@JDBÆ¤~'],
                    'encodeOffsets': [[
                            124854,
                            31907
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '310120',
                'properties': {
                    'name': 'å¥‰è´¤åŒº',
                    'cp': [
                        121.5747,
                        30.8475
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@~T~JjZdDbLXDLCB_J@@FHFZJJIAGH@HGR@BENBLID@@LFCDF\\FpDBDb@FAHKFEÂ†@dEDDdC\\GreNMACVMLBTMCCFCEGFAA@DAFDLMHA@OD@BMEWDOC@AS@KGAI_DcKwÂ„Ã•Ã­sÆÂ‘Ã¥Ä†ctKbMBQ@EGEBEJ@@MBKL@BJB@FIBGKE@ABG@@FMFCPL@AjCD@ZOFCJIDICIlKJHNGJALH@@FPDCTJDGDBNCn'],
                    'encodeOffsets': [[
                            124274,
                            31722
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '310115',
                'properties': {
                    'name': 'æµ¦ä¸œæ–°åŒº',
                    'cp': [
                        121.6928,
                        31.2561
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@EN@JJLNHjLJNR^GRYVBNZJRBV@PDvbLNDN@LGNER@nCNQNuT_TIVFV\\Z\\XnDrI|[É„Å›Â²ÃJUHOÆ£}CA@IO@@CYDATGFIEDAEBBAGCO@GJMCEDCJRHEFANOCADAEG@@CI@FE@BDIC@AGIAIMiEEB@DE@AJCXJDCJEHGBELGCUCeMAD]CIJiM@DSAKJKCLQDQACUECDMIFCBDJGECHAEIWCK@GLMCCGEACNKCEJG@MMBMC@@CIJUINT@JAJSTEPZZCP'],
                    'encodeOffsets': [[
                            124383,
                            31915
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '310116',
                'properties': {
                    'name': 'é‡‘å±±åŒº',
                    'cp': [
                        121.2657,
                        30.8112
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@L@BIHFN@@EE@@EFBDGDAADVDD@@EF@CA@IIsRE@GDAF@BF@CV@|FBCHBLCNHAFCADBMDCFZXHILBVEEQA@MWFARJJ@DCX@@TEFBLHAAERE@AJABRPBNK\\BrJ\\VHGND@CNADKDADQjGAGNC@GJ@FCFFHC@JF@@dLBDSFADHVG\\DTEPDDHJALIJkJDJCDIPE@YDCBiK@DONE@EH@BAF@HLJA@EIA@ALKNA@@FIFAFHR@NALadsÃ¦Ä…yQY@ÂƒAÂ±DÅ‰XUVI^BF@FFF@HBJEDFFGFEBSRkVEXGHFBMFIVW@GAEEFOIAIPKABGWEKFSCQLQBSEIBC\\FdBLRR@JGACFDDEF@AWB@LJJYNABBA@CUEGPaO_AIE@MYMFIGAEFECHSAAKAO\\[JEDB@E@MMA@@AGBKMGDFFCDDFEDFJF@NPBAFLHFH@EDDHBADDC@DDCDHHCDDFDABDAD@FEFOBCJ[D@HEDDNJBDDHABJIBBvGLBJAH'],
                    'encodeOffsets': [[
                            123901,
                            31695
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '310118',
                'properties': {
                    'name': 'é’æµ¦åŒº',
                    'cp': [
                        121.1751,
                        31.1909
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@RUNKdOFDJCbRFMLAHPLDN@JGL@@APBWYCKN@TU@SHGCEJIDIJKVIZVNM`iNY@CIE@CA@KBOEGEUFCCSADEIEFCDDDIDDHC@CKIeDCG@IG@DHWFEEGCH@@GO@@O]CNpeEQDBFME[JC]DGF@CKOA@QSB@GB@@GW@@ED@AQIJIAAFE@@DO@CFI@KNG@CDACAFEGKGBEGBDCCAIFCCLIECFI@MBCLDHGNAHSF@DMB@EEKBA@@C]DEICFG@ADBHGFKCDAKKHKD@@FHGAANGEEFCHKCECBCKG@ADKCNE\\[A[I@@mGBDQQEO@BCE@AI[AML@JGACLOAFKEMM@EQKC@CUCBCCBCHEA@FF@@FM@GEAJK@GNF@EXPH@FD@M^@HIADJCFDBER@DK@@DE@CAKFOCCBDHIBCNSB@GFC@GQEEOWFICGDUAEJIDBTAHJHEB@DIF@NE@H|HBDBEH@DKBAHEF@HEEUB@FGFGCCCE@AHOB@NH@PRLVNNFBX@RCÂ€PbAvMtBfH@DJF@ELBFA@EH@HNED@FFB@HLC@CJ@@DJ@PIRf@HE@CFF@GPHD@DKE@FFBEFFD@DEFCA@DD@IjCRFBAHFDKD@HF@@PM@H@BlbDJDBFEF@DLXB@HCD@@IFCBIFEJD@FDC@FBALLF@PAACJERACAJCBD@EL@JD'],
                    'encodeOffsets': [[
                            124061,
                            32028
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '310117',
                'properties': {
                    'name': 'æ¾æ±ŸåŒº',
                    'cp': [
                        121.1984,
                        31.0268
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@DLDFRN@FNELPBDKHB@INK\\BBJF@ADP@RFCRHA@nJ@B\\[\\MFLDBCH@DLDADFGLEDFFMHBBGH@EC@GLLLCBLDHEAGBCH@DEFJ^C@DB@LAFFA@CNE@GTMBGHKCAD@NEJFDKJDDJEDBCDHAAFLHFHBEBDDCH@LMJ@DEP@@CF@BEJBJIBRC@@FX@@HA@@HTA@RPBDLE@CHD^\\INFAERCfFMo^D@PP@@HG@HDFFXECGH@@JDHfCLJ@DGDCCCJCCEDJFCFTBDDVEHFPFLAB@NBFCFKFC@CHIACNOHWHCAAFIDD@CDAGEI@ACFMF@R@R_@GQED@EGFEQEDE_IAHKAEÂXCQUOQCUDEN@ZI\\DDmAMHCICDSOC@EG@BKHIGMIBCGOCSF[CUHCGEBCTKA@cE@@IGDEEEDI@@HMDBHiHCRCBCLMB@DMCGH[UqI[AMLOAAQIB@BQFBFGBAKFE@SW@CDI@QIEBNXB@FRUFKAGJYWDENCCADBBEMGKDGAAD{EU@@DAEE@CB@HQFJt@JDBE@@FC@'],
                    'encodeOffsets': [[
                            123933,
                            31687
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '310114',
                'properties': {
                    'name': 'å˜‰å®šåŒº',
                    'cp': [
                        121.2437,
                        31.3625
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@F@LI@IDKJADKIEJICADGACFECCJ@HKCAFOHAJI@aCBEE@ICAEB[GFGCKL@FGEIFADMLCAEJM@ELQECEIG@BE^QKKLQCA@EHBIGQ[GEHOMGGDHKH@JOECFCjCBEFDNCACMBCILGTABDLEEOEIG@GFIMM@CGKFBFCDE@@GEAGEEACIcGaHMFITIHDN[AKF@FS@OA@BK@IHM@KCGOKBENaQIDECcPMLQVFHFB@BFBKLGD@FAJOVGIACQ@A`LPCB@JEF@RU@ANS@@RCL\\HIFpRBFRBBDKLLDADJDGBFDABHBEDNF@DGBBBADKDAHC@\\JJFBDEH[DEFDH\\LX@XLBLbT@DNJLDCEL@VJABJNDHB@HBHYFBAA@GNFB@@AFB@AFABFLFBHFCL@HJBAFBLC@DN@HN'],
                    'encodeOffsets': [[
                            124213,
                            32254
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '310113',
                'properties': {
                    'name': 'å®å±±åŒº',
                    'cp': [
                        121.4346,
                        31.4051
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÂˆmÃ–oÃ–iÂƒÂ½[s[YEUJU`SCIEBCCWJY_LIICDWU@@FaBCJIB[ICH[@@CDKEE@MK@@IMCAEBCH@AMFI@SMGEFGB@FK@BHCAIFJNQD@FEBDFMBKGACG@ECWH@@CDDTOEEBGEK@GC@EE@GPHFR\\JHGA@FDBKRLL]RAFH@FJFDKR@FINBFKDCNEBFJEHK@DLEH\\HFADB@JFFDA@bIJGBEPDBGLI@DDEFBDCHDBIJJFCLIBCL@JKJE@ADHDBHJ@HIBBDFHBBAEIJ@BJFAVLÂ¢Âˆ'],
                    'encodeOffsets': [[
                            124300,
                            32302
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '310112',
                'properties': {
                    'name': 'é—µè¡ŒåŒº',
                    'cp': [
                        121.4992,
                        31.0838
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@T@@ELE\\BCMJGJSNEbGdHDJFBJAFIEIFCEWG@@gMENSFCVJFAxR~B@IH@AIiI@GE@FGEAFQPDRiV[\\DFSGMHAXHDOMCJCDETBBNVJJI@DD@ANNNH@FILDDMFBDHNDHKL@XDFGLD@EHGFD@DDB@CDDHCDAEAHG@ABOJ@BIaC@CECLKPFNCDCJBiQEIF@@@OGBMIAEEBMTHF@NKEC@QFEGA@EBCKAACHCLJHEFHHB@AFCAIEACIC@HG@KCCDC[ECEED@KC@KJMAAFQ@GHG@BHIJYIGE@EI@A`KDWCaKcCiY}I}S[CYJM@CFDVPRRVWDFÂžLBBG`JCFRFEFFHC@RF@HQ`Q@E@ENBDJ@HFCB@DCCEJBBGDGXMPBDGJ@DEDELEDMA@DJF@DMZ_jMNYUUJILCJIJDFGH@TSVM@DLXZ'],
                    'encodeOffsets': [[
                            124165,
                            32010
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '310110',
                'properties': {
                    'name': 'æ¨æµ¦åŒº',
                    'cp': [
                        121.528,
                        31.2966
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@V@CXJDKJZ`XIDDFADJvSRMDM@mFQHM@KCMKMuaOCU@BDAJSX@HKJGD@PNJCJWAGT@R'],
                    'encodeOffsets': [[
                            124402,
                            32064
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '310107',
                'properties': {
                    'name': 'æ™®é™€åŒº',
                    'cp': [
                        121.3879,
                        31.2602
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@F@@FHDL@HFFAPFCSDC@@XGFDH@BDLHNACEFA@ERCIMJEDBAGL@@EHAFENHHJ\\ONQBQCIBC[MKACKI@GGGH@I_G@CW@[DMHCDIBMTDHN@JNHEH@FJFPKFACSBKHDJNABDMDECAFiDEDFDIPG@GLHCNH'],
                    'encodeOffsets': [[
                            124248,
                            32045
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '310104',
                'properties': {
                    'name': 'å¾æ±‡åŒº',
                    'cp': [
                        121.4333,
                        31.1607
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@RADL\\NCPHFfLJaJ@FWLGMGIK@IFMDOYYFOTSBI@IMSAMSACFIDNDCPWGGBHNET[CU\\QjOCERFBEHF@@HjJBJG@@J'],
                    'encodeOffsets': [[
                            124327,
                            31941
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '310105',
                'properties': {
                    'name': 'é•¿å®åŒº',
                    'cp': [
                        121.3852,
                        31.2115
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@HFFB@HF@DCAELENSJADCNG\\CX@@D`H@JHGHHJ@BINBFUGEDO[MCKQB}AwQEBUIEDMTNF@hH@FXEDFJEJIB'],
                    'encodeOffsets': [[
                            124250,
                            31987
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '310108',
                'properties': {
                    'name': 'é—¸åŒ—åŒº',
                    'cp': [
                        121.4511,
                        31.2794
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@CSG@BQGODUPWTOBQAAFMECKBGEMFKEOHADDJARMR[PGI@TEJBNG@ADBFND@JL@@NFFCL@D\\@DG\\JJADI'],
                    'encodeOffsets': [[
                            124385,
                            32068
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '310109',
                'properties': {
                    'name': 'è™¹å£åŒº',
                    'cp': [
                        121.4882,
                        31.2788
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@bA@E@QHSXBDIMI@OHCLI@GTWBIACQAYIOFGCENBBARSPOXCVHPARH@DT'],
                    'encodeOffsets': [[
                            124385,
                            32068
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '310101',
                'properties': {
                    'name': 'é»„æµ¦åŒº',
                    'cp': [
                        121.4868,
                        31.219
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@NEHFLAFDHDPEAMZUHQQ]IMKJG@EPERABHBGRUCCNGV'],
                    'encodeOffsets': [[
                            124379,
                            31992
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '310103',
                'properties': {
                    'name': 'å¢æ¹¾åŒº',
                    'cp': [
                        121.4758,
                        31.2074
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VDHQGABAFQFOH@LIiKKHEXI@IbAFZB'],
                    'encodeOffsets': [[
                            124385,
                            31974
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '310106',
                'properties': {
                    'name': 'é™å®‰åŒº',
                    'cp': [
                        121.4484,
                        31.2286
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@DLLB\\NPGLFHUDMYABEeKEVMAAJ'],
                    'encodeOffsets': [[
                            124343,
                            31979
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/shan_dong_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '3706',
                'properties': {
                    'name': 'çƒŸå°å¸‚',
                    'cp': [
                        120.7397,
                        37.5128
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Å¤LÂšLllVÅ„Â²Ã¨Â°xÅ¼Ä¢Ä Ã†lÃ’Â„ÂšÅ¤bÂœÂ„VÂ¤ÄŠXnÂŽlÄ¢VÄŠÂ„Ã’ÂšÂ„ÃˆÂ°ÄŠÅ°ÃžÃ¨Â˜LÂ„Â±@ÑŸnÂ»VUÅºÄ‹Â²Â»Ã†kÃ´VÉ†kÄŠÅƒÂ²kÅ¤VVwUUVmUaÂƒÂ@KkU@ÂƒmUmmk@UwUkmW@UVIXa@Âƒmw@aÂ™KULÂƒaÂƒx@Uk@UbWU@yULmKÂ¯@kXÂƒVUwm@@JUUknWKUVÂƒLUbU@Â™wWykIÂƒa@w@mUI@aÂšUVynIWaÂ„kÂ„@@WÂ„bl@@knmÂƒK@wnIlÂ™Â°Kna@ÂVÂ¥ÄŸ@Ä¡UÄ·Â»Â™Â¥@UÅJÂƒXÂ¯Â¤k@Â™wmIÂ¯Â‚k@mwÂƒak@@ÂšlX@bUJ@VÂƒbknWxkLkxlÂŽÂšLVlkLmÂŽÂšb@bU@ÂƒbU@VbU`Vb@nÂ„L@ÂŽmbÂ—U@Â˜VnUVmnU@mmÂ™@kIUWVIUKÂ›VkkUJUnmL@VmLUaÂVWaXamU@Â™Â™U@KUUmVÂƒUÂ—JÂƒUÂ™VÃ‡wÄŸnÂ™mÂƒ@mXÄ‰V@lÂ¯xnÃ´'],
                    'encodeOffsets': [[
                            122446,
                            38042
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3713',
                'properties': {
                    'name': 'ä¸´æ²‚å¸‚',
                    'cp': [
                        118.3118,
                        35.2936
                    ],
                    'childNum': 10
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â˜bXlÂƒl@zlV@lXXmÂŽkbVVlÂšÂ„U@Vn@@Vmb@XÂšKÂšVXÂ„WJ@XXl@Â„Â‚ÂŽÃˆbVLÂšUl`Â„@XXV@VVUxVbUxVbÂšÂ¦Â„@Â‚WnXVJ@bnVUzl@Â„Â°Ã†xÂ„UÂ„KlU@mUUnUlUVWVUnVV@XXÂ°V@VÂšll@VkÂ„aXVl@Ux@bmbXLlKlb@b@bUJn@@Â„Â„b@nÂ°xÂ°K@an@@UlLVKVbXb@bVVnKÂ°LVa@UVa@Â™XwÂ‚KVxnLÂšUÂ°@naV@UWUkWÂƒULmVÂ—wÃKUUla@aÃ³_@mÂƒK@aUU@ÂÂƒWUÂkwVm@aVIÂ°WÂ„@@IUw@aÂ±Â¯@Â¥kUVUÂm@aÂ‚wkwÂ™@ÂƒK@kVKk@maXalI@alLÂ„WXblaVLVUÂ„V@LnKÂš@Â„l@wÂ˜aXaÂšLlnUlÂ„LÂšmV@nÂÂ°J@_VmnIVymÂ£UKmI@WnIVm@anUVmÃ‡_kÂÄ¡IÃ…WUXÃ‡m@U@ÃÂ¯Ã…@ÂƒÂ™@naWÂƒÂ™IVW@IkK@klKn@naWIÂƒmk@ÂƒaÂƒbkKkLWnÂ™WkLWmk_Âƒ@UaVÂƒUKmLUw@mnÂ£WwUmUÂ™ÂƒaÃ³V@UkUm@UKULUwmJUX@WW@XÃ’Â™zVblJXÂŽWXk@UVWKÂ—XÂ‚Â¤UL@xU@Âƒ@ÂƒVUaU@@XmVkLmWkXUyÃLmKXnVÂŽ@n@lÂ™x@bWLnVVnÂ™`knULmxUlÂ„Â„WLXÂŽVb@VÂƒK@zÂ¯xÂ¯Â¼WxÂ™KUn@bk@ÂƒlÂƒVVVÂz'],
                    'encodeOffsets': [[
                            120241,
                            36119
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3707',
                'properties': {
                    'name': 'æ½åŠå¸‚',
                    'cp': [
                        119.0918,
                        36.524
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@l@@UÂšK@ÂŽ@L@bX@@VlL@JÂƒLUVnX@`ÃœXn`VÂ²mJ@bU@@nÂ„b@lÂ°xnnÄ¸VÃ†ÂšÂ°@Â„ÂƒÄŠÂ£Ãž@lWnÃ‘nkÊ¶JmÃ³Â°w@kkÂ»VÂ@Â»ÂƒÂ¥k@V@kw@wVmÂ„aÂ˜Ã…Â„mÂšaÃ´Â£ÅŽÂƒXI@mlnÂ„Kla@mV_UKÂƒ@kUkw@alWÂ™IUÂ»Â™mÂƒÂ—@WUIlÂ±UUÃ…UÂ›bkJÂƒÂ@a@wUKUaVIÃ†mXIWaka@m@UlÂ£XKVw@ÂƒUIÂƒJUkmJÂ™ÂƒVÂkU@aÂ„ÂƒWKÂ—ImVÂƒ@UxmL@bX`WXU@U`Ã‡kUak@@Â°UblXkÂ‚mLUKmL@VULÃ³ÂƒÂƒVk@@Vlbn@Ub@ÂÄ‹aUJUbÂƒIUlVLUVVbVKXÂ„VlVXU@mbÂ¯@Â™VmKUwÂLWx@ÂšUb@VUbÂ¯KmLUU@aWaUaULkK@Vm@@bÂ¯LÂ¯w@mÂƒa@Âƒm@UUU@UÂ¦lJUXÂƒVÂƒmkb@nmÂ„XVWÂŽkbÂ™IVxUV@VUbWLXVÂƒLW`Ux@nk@Vn@x@VkJ@ÂœV`mXkÂŽ@VÂ„xVÂ@lVÂšÂšI@VULÂšÂ˜VUÂ„IV`Â°bVXXxÂ„V@VWVnL@xVÂ„Ub'],
                    'encodeOffsets': [[
                            121332,
                            37840
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3702',
                'properties': {
                    'name': 'é’å²›å¸‚',
                    'cp': [
                        120.4651,
                        36.3373
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„@nUÂ˜JXLÂƒÂ„@blVUÂ‚ÂšÂ„nIVlÂ„IVJ@Â„UxWLkÂ¤@V@nlbXbWJÃ…nUJVbVL@x@bÂ„ÂŽlIÂœaÃ†VVVkÂ²VJ@XÂ„Â˜ÂšnVÂ¼ÂšJkX@blxlVÂ„@VLU`@nkbÂƒLkm@nWJÅÂ„Ã³Â¤Â™bÂƒnÂ—Ã†ÂƒbUn@xlxU@l@Â„Â¦@Â¼UÂŽlÂ¼ÄŠUnWÂ„@ÂšnÄ mÃˆxÂšUÂ„VÂ˜IÂ„VnUVV@LÂšV@ÂšnVWbXbÂ‚UVbnK@UnKVmVIllÂœUVLUJVXlJÂš@nnV@nmVUUm@Â—Â˜Vna@ÂÂƒK@mUaV_UaV@Â„aV@@aÂ™anÂlKUkÂ™KkÂlwlKXwlmÂ„a@UVI@akW@Â™l@Â„bnxl@Â°ÂnJÂšxl@Â°Â£Â„WÅŽIUÃ‘nÂ»laÂšmÃ´Â¹ÅŽÂ¥VaUUkÂƒmkÄ¡WÉ±IUUÅ¹`Â›@kk@Ä‰Æ¨Å™VÂ¥Â_Ã‡@Â™Ä¬ÂƒÂ¤ÃLÂ¯mÂ¯Â£Æ½Ã³Ä·wUWÂ±Ä«Â¯kÅaÄ‰Ä•Â™kÄŸmÃ³Â°ÂƒbW@UKkLUaÂƒVmz@V@ÂŽUxVn'],
                    'encodeOffsets': [[
                            122389,
                            36580
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3717',
                'properties': {
                    'name': 'èæ³½å¸‚',
                    'cp': [
                        115.6201,
                        35.2057
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@Â¥ÂšIVUÃˆmÃžÂ»@UlU@Un@VW@UVmkk@aVUUKVÃ@UVknK@UV@VVnIVÂƒ@wnÂƒmwmKXaWaXI@UV@VyÂ²blkVKkamÂ™U@kb@Um@VmUkmÂƒÂKmkXKWwkU@UlÂƒ@UnK@UVUUmÂ‚KXwÂšUVLÂ„wÂ‚KÂ„UÂ„@@Wl@@wUkVÂ¥Â—@@I@W@_V@VWUw@UUa@aÂƒaWaÂ—@@_mKUwÂ™lÂ¯amzmVÂ—@WKÂ™nU@kÂƒWLÄ·aUKÂbÃVmV@ÂUWÃ‡bÃ›@ÂƒXÂ™Â°UbW@XÂŽmÂ„VlkÂ²UJUbmLÃ‡xÃ…WUzlÂ‚Â¯LlÂ„@VkKÂ™XUbWJ@bU@Â¯@Â™ÂƒkbÂƒLmKkaÂ™Â„@lÂ™_WÂšXÂºVbUz@JÂ‚nÂ²V@Â¤lXÂ„ÂŽÂ„nVÂ°ÂšLn`WbXLÃ´VlKVUÂšxXnÂ˜lXLlU@bVV@Â„XJWLUVnVV@Â„Â„@nÂ‚lÂ„Â°nnÂ‚VÂ„KÃˆbVXÃ†JUÂ°VnXVÂ„kV@@xVLÂ„@ÂšWlb'],
                    'encodeOffsets': [[
                            118654,
                            36726
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3708',
                'properties': {
                    'name': 'æµŽå®å¸‚',
                    'cp': [
                        116.8286,
                        35.3375
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nam_nKlÂVLXaÂ„Il`Âš_@KVVXI@m@wÂ‚ÂƒÂ„@@k@KÂšnÃ´@n`VbV@@LÂ„L@KVVn@VX@Â‚VLÂ„JlÂ„Âš@VUUÂƒU@Uam@UkÂ„wÂšKWaXamÂkJmIUÂVUÃˆblaÂšUnV@kVKl@@lXLÂ°kVJ@VÃˆnVJUX@VÂ‚LXl@xVLnUÂ‚@VKÂ„V@aÂ„IUaV@Â„bÄŠUÂ„xÂ„KÂ‚kVJXUlVÂ„ÂƒÂ„UVaÂšI@WUI@KlUnwÂ„mWk@WXIWÂƒÂ™UÂ™L@Wna@Um@@UÂƒVkÂ™UUlanÂWW@kkU@yÂ„kWkÂ—aWVUlÃbUU@kÂƒJUIU@@ÂƒÂ™JmaÃ³kÂƒLÂKÃ‡ÂƒUUkKWLk@WbkUUaÂƒbmKnÂ¯Â°Â¥V@XwV@VanaVaU_@Wlk@WÃˆ@VUÃˆVVÃ›Â‚mÂ„akÂlKÃˆÂ¯lLVUX@lK@aX@@kV@VmV@VwnJV_UWUwÂƒXÂ™am@kW@wVUkKVIUUVmU@UV@IVK@aUL@aÂƒV@LmÂ„UKmx@ÂŽÂÃ´mLkUWJ@ÂšnXmlUxUL@VknÂ›VUÂšUÂ„@VÂ™LÂ™`UbÂ±LkV@kUKÃ‡bÃ›@ÂƒUÂ™WÃ³_mJÂƒÂ@Wk@@XÂƒ@ÂƒVÂLÂƒxUKÂ™VWxÂLVnUV@VmL@VkÂ„@VlVXxWLnlÂ‚LnÂ„VlUnn@@VlaV@nÂšlbULklÂ±aUzU@@VWJXbWbnLnxmÂ„@xUÂ„mJUUU@@VmLUl@VUÃžVLUV@bllUn@VUXm@@VkV@VÃÂ¼Ã‡nUVÂ™J@Â¦nnÂƒlnVlL@Â„ÃžbÂ°KVV'],
                    'encodeOffsets': [[
                            118834,
                            36844
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3714',
                'properties': {
                    'name': 'å¾·å·žå¸‚',
                    'cp': [
                        116.6858,
                        37.2107
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„Â¤@VmbVXnVVbVJÂšÂšXÂ@ÂŽll@zÂ„lVInl@Â„@bVxUbÄ Â‚l@ÃˆblaÂ„IÂšxXVWb@LÂ™@nÂ‚ULWVXXÂšWWLnL@`@LUVVL@lVnÂ„JÂšU@UUkÂ‚aÂ„Â™nÂšÂ‚VÃ´Ã´Â„bÂ°Â¼VÂ‚ÃžÂXÂšÂ˜Â‚ÂœIÃœbÄŒaÂ˜bÃ´WÂ„XÃžWÃˆzÃ†mnLVJÂ°ÃˆnlVÂ²lbnW@Â™@UÂƒUVÂ™ÂšmnwmkkKWÂƒÂkla@mVIUKUaÂ™aUwmnÂ™JU@@amIk@@bVlkX@mmUkÂlUUÂƒÂƒa@_UaUUÂƒV@wÂƒwÂ™WkXmW@I@WUaÃU@UXaWUU@UUVW@UUUWUnÂ¥nUVa@m@k@alU@wkÂÂ™LWaÂ@UUm@@wnÂmUÂ™wla@anKn_@alK@ÃÂ™_Âƒ@@WUUUmlÂkaÂƒIÂƒyU@UwU_WaÂ¯yU_mWUwkImm@InWWUk@@UVWVÂ—kWÂ¯U@VÂƒL@bÂ¯b@lÂ±Â¦@ÂšVV@lUbVÂ„@ÂškxVnUÂšlÂ¼XV@b@lV@nIWxnbÂƒÂ‚Â™@UUÂ™LÂƒxÃ…xmÂ¯ÂƒaUÂƒÂ™wU@mUÃ…VÃKULm@ÂbmKUXÃ³@'],
                    'encodeOffsets': [[
                            118542,
                            37801
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3716',
                'properties': {
                    'name': 'æ»¨å·žå¸‚',
                    'cp': [
                        117.8174,
                        37.4963
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Vb@`Â„bVÂ„kVlÂnV@nlWUk@al@nJ@bV@ÂšInmVxÂšbVbVLUJ@nkbÂ‚lXÂ„lLnlmxÂ™nUÂšÂ„V@V@ÂšmXnÂ˜lbÄ¸@nnVxÂ‚b@lnXV@UJ@nVxÂšxnxVbÃ†VnÂ¯Æ’Ä•Â‚@@wÃˆÃ§UÃ‡lÄ·VIÂœbÂ‚@Â„Ã‡mk@Â¥k@UkUK@aWakUÃ³JW_UW@wkkWK@U@KÂš@XUÂƒÂƒUkmUUalKXala@U@kkWlkÃˆl@kÂšVÂ„mVIVmU_Â‚aÂ„ÂƒÂƒwnwVW@wÂƒwUÂƒ@wUÂ£ÂƒwkJWIÂyUIÂ±bkÂ‚VÂUJ@nmVÂ™UklÂ„Xmx@lnbWÂ„kVÂƒUkLWÂŽÂƒxkKUUmUkbÂ™JÂ±ÂÂ—LÃ‡xUKmkUmkkWÂ™Â™aÂ„mUaVkÂšJÃ†_Â²KÄ @UÂÂ„W@wÂ„UÂ‚Â¥nUWwÂK@aÃUkÃ…VaVK@akLWÂƒÂƒÂƒÂ¯I@bnbVxÂ¯JWÂ„Ã±ÂšWbUL@ÂšÂƒÂŽnV@VmbkUUV@IÃ‡ak@@bWak@WJUÂœÂJWL@bXV@Â„Â‚@Â„VÂ„Jlb@zUlUÂŽUImÂšnbVÂ‚mz@Â°UV@VÂ™bV@@V@L@xÂLmKUnmJVXÂ„J@VkLW@UVUL@b'],
                    'encodeOffsets': [[
                            120083,
                            38442
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3715',
                'properties': {
                    'name': 'èŠåŸŽå¸‚',
                    'cp': [
                        115.9167,
                        36.4032
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã´@VWnLÂ‚an@VKÃžLÃ†UnVV@ÂšxVÂ„Â„bnÂ°Ã†wÂ„wÂšKVVÂš@Â„ÂmaXwmJU@@k@aWUkÂ»VÂ™Umlw@Â™UÂƒVa@kUU@Â™Â²Â¥@kÂ°a@aÂ„K@UÂ›ÂƒUÂÂ@mmm@Ã³wÂ—Ã‘Â±Â¥Â¯@@wÂ™KmwÂ—IÂ›Â¥kUÂ¯UmakJmIUaÂƒVkKUkm@VUUaÂ™UÂƒ@UaÂƒKUKÂ¯@Â™wÂ™UVÂŽUIUKVwÂ™kÂ™Â¥Â™wÂƒbVÂŽ@xnÂ„@lWnXxlL@`Â„XlJXÂ¦lÂ°XxWÂ¦@Â¦UlÂ™n@ÂŽÂ™@@Um@@VXVmx@ÂÂ¯bllUnUJ@VULVn@bÂ„xVÂ‚VL@bÂ„Â„VlnVVblVÂ„ÃˆnVlIVJÂœLÃ´Â„lJ@xlÂÂ²Â„'],
                    'encodeOffsets': [[
                            118542,
                            37801
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3705',
                'properties': {
                    'name': 'ä¸œè¥å¸‚',
                    'cp': [
                        118.7073,
                        37.5513
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Í¬UÇªlÃ´@Â°UÂœwÂ°ÅÄ Â¯ÂšÂ»Ä¢Ã§Â‚Â»XÃ‡@wÂ™wÆ‘aÂ™ÂÃ‡ÂƒkwVÆ‘Â¯@Ã…Â™Ä·UmmÂ¯w@kÂƒa@mV@@anIUÂ±m_Ã›W@_mWVUÂ„K@IkK@UW@@a@K@ÂÂ™L@Vk@Â±UÂ@UV@lm@mUU@kLmÂ„Â„xVÂ¤@xVÂ„Â„x@xUXmxÂ„xÂƒÂ„ÂbV`UnUJÂƒnÂ™U@lÃ‡kkllX@l@VkbWbkLVbnVVlÂ„Â„WVÂ™@@L@VXLll@xVXX`Ã´IlVXb@bVLVll@@Â¦nlÂƒÃˆÂ@Â›aUJkÄ¸VÃˆÃ‡Ã¨@x'],
                    'encodeOffsets': [[
                            121005,
                            39066
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3701',
                'properties': {
                    'name': 'æµŽå—å¸‚',
                    'cp': [
                        117.1582,
                        36.8701
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â²Â¦Â˜Ã’Ã´xn@nnÂ‚@VÂ‚ÂœÂ„Â°VlXUÂ˜UX@Vl@XVmX@JnnlJVxnXV`Â°zXbV`VxV@Â„zÂ„JlbkÂŽVnVV@XÂ„@Âš`@ÃžkL@bm`mL@bkbÂšxnVmÂ@xn@VVÂ‚@XbÂšKlÂ@xkV@b@l@nUbmVmÂ¦XVVV@VUXVVV@XVWb@VÃžVVb@X@JnXlWÂšXÂ„x@xÂ„UVV@aVKVUX@lK@UÂƒIUWnIVmnLÂ‚K@w@K@UU@Âša@UVU@Â¯nyUÂmanÂ™VJVÂVk@ykaÂƒIÂƒUÂ@@ÂƒWU@aXKÂ‚IVÂ›XIl@Xb@al@Ãˆb@JVUlVna@UmUÂ„Â@Â™VKXaÃ²Â™XÂƒÂ°IUwma@aU@UU@wVW@Ã‘Â„w@aÂ™IÂ±`kbÂƒUkwÂ™UmJ@UkmÃ‡UUkmKknUVÂƒ@mJUkÂaWkÂƒa@KÂÂmKkUÂƒLmyXaÂ¯_@WmImmÂbÂƒLmUkVUbUVÂƒJÂ™bÂƒUkkWJkUÂƒlÂ™IUmÂ™kÂ™LÂƒÂ›Â„ÂlK@knaVmkI@mWaÂƒLUKÂ™UU@@VmLUVÂLWK@UUUÂƒWUkkVmx@Â„VlÂ™Â¦'],
                    'encodeOffsets': [[
                            119014,
                            37041
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3709',
                'properties': {
                    'name': 'æ³°å®‰å¸‚',
                    'cp': [
                        117.0264,
                        36.0516
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nÂ¼ÂšÂŽWÂ„nxÂšL@xÂ°@ÂšÂ¥Uk@ÂƒnwlUVlÂ„XVV@VXLÂ‚KVUnK@UV@ÂšVVLÂ„KXb@nlJUnmb@lkLÂƒÂ‚Â„ÂœÂšKÂšlVnÂšJÂ„klVXIllÂ„VÂšaÂ„IVUValUnVÂ„KÂ‚annnJ@XÂ°`WbnzÂ„KlVnLÂ‚ÂŽ@LÂ„bXlÂ‚bVlnIÂ„@VUU@UmVÂƒ@U@UÂšÂ¥@ÂVmV@@_Ua@mÂ°@@ÂƒÂ„kmUUm@UVmn@nXÂ‚@@aÂ„anJVUVLÂ„mlIVJn@nkVLVa@KVmVLXVVLÂš@@UÂ°bn@VaV@@K@aVkÂœbWaXUVymU@aUImWÂXÂƒ@Â™Â¥UaVwUaVwUUU@WWÂƒ@k_Â™VUKÃ‡aÂÂ@ÂƒÂƒnmxkV@LVJ@XÂ™JUbÂƒVÂƒÂ„kUWVUIÂlÂƒLÂƒwÄ‰VÂƒaU@VbÂƒJ@bÂƒUULÂ@mVUK@wWkÂK@UVWUIÃ‡m@UUIÂ¯lWK@kk@UL@lmUÂ™VkbÃ‡aUVVÂnJlInÂ‚WbXbÂ™LÂƒxVln@VbV@VÂ„UVÂ™@kÂƒÂƒIUK@ÂUWm@UU@LÂƒK@KU@Uam_Ã³@Â™m@L@lÂƒ@ÂÂ„@x@nWJUU@LÂ™`k_ÂƒJWbUKkÂmLn`mb'],
                    'encodeOffsets': [[
                            118834,
                            36844
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3710',
                'properties': {
                    'name': 'å¨æµ·å¸‚',
                    'cp': [
                        121.9482,
                        37.1393
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VbUnVVUxÄŠÂ¼ÂšÂ¼Ã´@ÃžÃ‘Â„Â¯Â‚WÇ¬LÅŽUÃ†WÂ„Â¹UÃ‡ÂƒÅÂ¯Ã‘ÂƒÃkÅ£Â™Â™Å£Ã³Ä¡Â™Ã³LÂ™Å‚Ì¥UÂ™wmÂ¥kÃmkkKÃ³bÃ@UÂ¦@Â‚mbÂ¯LkÂšmJ@xÂ„Lmn@lk@Âƒa@XÂƒ@ÂƒlXbmJUzÂ™V@bVJ@n@xÂ„blJXzÂšxV@VaÂ„KVUXLlmVV@In@VxÂ„UlWÂ°@nLVK@zXVVal@@VÂ„wÂ„bVKÂšL@bnx@Â„WbUJ@VnXVlVxl@nnnV@Â„lV@LÂ„Â‚'],
                    'encodeOffsets': [[
                            124842,
                            38312
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3711',
                'properties': {
                    'name': 'æ—¥ç…§å¸‚',
                    'cp': [
                        119.2786,
                        35.5023
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@UaVUUKVkÂ„JVaVIÄŒb@ÂVam@ka@Ul@Â„UÃ´Â„VK@UnKVLnKlÂkWVa@Â¯l@VbÃˆlV_V@XWW_@anKVwUmVw@Â@UnyÂ„UVblKVLX@Â„aÃ´Â¯Ã³Â¥mÃ›ÄŠÃ¿ÃˆÂ¥ÂšÂ™ÃžÂ¹lÂUÄ«ÂƒÂÂ¯KÄ‰Â¼ÊŸbÃ‡VÂ™UÂ™ÂŽUÂŽÂ™XmakJUnmV@bUnmJ@XnJVLnÂ¤UzmJUn@`Â¯ImÂŽU@Â™nÂƒKVkkmÂ™KWbÂ—b@xÂƒkÂ™@mL@KÂƒUUVUKkbWaÂƒXkK@bkJWbnbl@UL@lÂ„LÂš@lxÂx@bÂ‚nUVlV@Â¦Â²Â°@bVx@JÂƒ@Â¯XUJ@bUnlxVÂŽÂ„X@Â‚VV@bÂ„L@nÃ´`@bkbVVÃžLÂ˜xnU'],
                    'encodeOffsets': [[
                            121883,
                            36895
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3703',
                'properties': {
                    'name': 'æ·„åšå¸‚',
                    'cp': [
                        118.0371,
                        36.6064
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nÂƒlKV@nVn@@kVUÂ‚@Â²VVaUÂƒ@wmKXU@UÂƒUWwUWÂ¯aU_ÂƒJUVÂ™Â—VK@UÂ™JUÂ™@kUÂÂƒw@UlÂnWU_@Â›lI@U@wUml@@mVwX_Â„KWUXKVa@UVUUwÂšJlaXÂWUnÂƒ@mlaÂ„nÂ„UVWkIVÂ¥V@VVVI@a@akakLWKna@aVwk@WUÂƒbUlk@Â™k@UÂ¯UWWU@mUUVUXkVmVVV@nkVÂƒLÂƒVÃ…wÂƒÂ¯k@WVXbÂ›aUl@bV@@b@xkVVXVxkJ@nk@@ÂŽVLUlVbÂ‚VXUVVUzVÂ‚Â™LVbUbVÂ„ÂVWVkLmÂškJ@nÂ±@UxUÂ„VVkV@bÂƒx@Ã’UX@xVVV@Â°JÂ„Â„XÂ„lK@bULUblÃ†ÃžV@bÂ‚LXxmVÂÂ¦ÂƒV@xÂƒXVÂŽÄŸ@Â±LÃ…`Â™IUlVbÂƒnÂšbXÂšllVnnlVLÃˆwÂ˜KÂ²ÂŽÂšIlanVVVlLÂ„wXÂlKÂ„VlUXÂƒma@knwÂƒWlkÂšVnU@mVIUÂlÂÂ²aVJÂ‚zXJlI'],
                    'encodeOffsets': [[
                            121129,
                            37891
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3704',
                'properties': {
                    'name': 'æž£åº„å¸‚',
                    'cp': [
                        117.323,
                        34.8926
                    ],
                    'childNum': 2
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â‚yUUÂ„UÂ„kl@@aVmÂšLXwÂ°Â»Â°w@yÂ„L@UUaWÂXKÂƒÂƒVknwVKlmÂš_UmmUXK@aÂšw@k@mUÂWmUL@Âƒ@Â™@Â£@KÂƒbÃV@akwÂ™aULmÂƒÂƒbUKÂ™LUU@lm@Â—Â°mL@nUJVxVXU`mIUxU@UnU@@lW@@bkLW@UVkKÃ‡Â°kLlÂŽÂƒbÂnUÃœÃ‡UUVÃ‡@@Xkl@XV`UbmbUbU@WxU@Â¯Â¦mÂ°nLÂ„aVblVXal@XKlLVVÃˆÂ„Â‚LÂ„KÃ´lnbÂšI@Â„V@VJÂ„I@lVVÃžaVkXU'],
                    'encodeOffsets': [[
                            120241,
                            36119
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3712',
                'properties': {
                    'name': 'èŽ±èŠœå¸‚',
                    'cp': [
                        117.6526,
                        36.2714
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lmnLVlÃˆVln@VnIÂšVlxÂ„VlaÂ²_ÂšJlUUUVÂƒVwÂ²@@mlInÂ™lKXUÂ‚UUÂƒVaUaÂšKUÂVyUUWVÂUUaVkUK@Âl@@mlIUwUWlU@w@aU@@LU@Ubm@Â¯a@VÂ™@UKWUUKUn@LUbUKmlm@UIkJÂƒnUKUVmIÂƒb@bÂ@mWm@Un@VVnnVÂƒl@Â„Â¯@@nVb@`U@Un@ÂŽÂ™Â¦@V@VUÂ„VnV@'],
                    'encodeOffsets': [[
                            120173,
                            37334
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/shan_xi_1_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '6108',
                'properties': {
                    'name': 'æ¦†æž—å¸‚',
                    'cp': [
                        109.8743,
                        38.205
                    ],
                    'childNum': 12
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â™Ã½VÂƒnIWÂ»ÂƒW@Â»kUÃ‡LÂ—ÃÂƒUÂ¯Â¥Ã‡IUWWÃ‘Â—UWwXÂ¯mÂƒ@Â»nÂ@ÂÃœÂÃˆÄ·Ã´Â™@aÂ±kÄŒÂ±ÂƒwÂ„Ã‘mwÂÃ§Ä‹mUÂ»Ã†kkÂVyÂImÂ™Ä‰Ã¿@ÂƒÃÂ¹ÂƒWnwÃ‡VÂšÂ™Ã…aÂƒzmmÄ‰Â¦Ã³Â™kVmxÂ™xUÂ¼VÂškVm_UlVlkÂ„Â°IVÂ‚kÂmJÂaÂ›Â¦kÂ™Â™LmmÂV@XmKnÂšlUÂÃ´Â›VXbÂƒbÂƒ@UaÃ‡LÄŸÃœÂ™Â™Ã…wÂƒÂ£mKnmÄ‹wÃ…@UkÂƒbmaÂVÂƒÂƒÂƒn@mÂ¯aUÂÂ™Jm_kÂ˜@kWÂXyl@@kÃ…amwÂ™LUÂ™ÃžÂ™ÂƒÂ™mWÃ…zUKÂƒÂšÂ™UkÂÂ±@Â™b@nnKÂ‚bXÂ¤mzVÂšÂÂŽVxÃ‡nÂ„Â‚Â¯Â„@Ã’knWÂƒÂƒVUbkÂÄ·ÂÃˆÃ‘Wkk@VaÂ™ÂÂ™U@Â„mUkbÂƒÃÃ…@ÃÂ¥Ã‡bkÄ¬Â™XV`kLÃ‡ÂVmÂalUUaÂ™nVÂ±nwmkÂƒJ@InÂƒÂ°KVwÂ¯UnÃ…@Â¥Â™ÂƒÂ™UÂ±bÂUUÂ˜Â±ÂœÂmWbÃ›KWnÂUm`UÆ’VK@bmnÂœmÂ‚ÃˆÃ…Â¼@VÂ„L@xÂƒxmÂšÂ„Å¤Â°ÂnÂŽ@VmKÂ™ÂÂ²VlÂšlKkÂ„Ã´@Â„ÃªÃœV@VXLlmÂšÂ¦UÂšÂšVÂ°ÂÈ˜Â¯Â²Ã¿@Â¥Âš@Ã†ÂÄŠÂ˜Â²IÂšmÄ¶nnbÂ°bÂ„KVÂƒÄ¸LlÂ„Ãž@UÈ®ÂšÂÂ™ÃœÂ°IVÂƒÃžÃÃžÂlÂŽÂœx@ÂŽÄ·Ä€WÂŽÂ„ÂUxÂ„Ã¨Ã†Â@ÂšÂ°ÂŽXnÂšlÄŠÄ–Â°mÂ„nÂƒÂšVÂ„Â²VÂ°Ã’Ã†Â¦Â„aÃžÂ„Â„Â˜@zll@bÃžÄ€ÂšlÂšÂ¼nKÄŠÂ¼Ã³ÃˆÂ‚bÂ²Â±ÂšIÇªÃ’Â¯Ä–ÂV@Â„lxnVlkÂ„JlaXwÅŒÄ‰Â„Â„@VnÂŽÂšÂÂšlÃ†Ä•Â„UÃ†LÂœÃ¨ÅŒÅ¤Ã´xÃˆÂšlUÂœ@ÂšxlaUÂÄ‹Ä•XmÂ„IWmnkÂšVVÂƒÂ„VW_@aÃˆWUUmk@ÂƒÂ¯Ã§VmÂÂ»Â™ÂÂ±WÂ¯ÂnÂ¥VÂ™mkXwÂ±Ã‡VwÂÂƒ'],
                    'encodeOffsets': [[
                            113592,
                            39645
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6106',
                'properties': {
                    'name': 'å»¶å®‰å¸‚',
                    'cp': [
                        109.1052,
                        36.4252
                    ],
                    'childNum': 13
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@kkÃ‡mIÂšmUwVkUÂƒÂƒUÂ²WmÂÂšVkm@Âm`mIÄ¢Ä•UÂƒVa@Â™mÂXÂƒÂƒÃ¿VÂVÂkyUÃ½ÂšÄ•@Âl_UmnÂƒWÂÂ„KVkÅ£Â™Â™Â¥Â™aÂƒwÄŸ@Â™Â@aÃ´ÂƒÂ„ÂƒWaÂ„kUmÂƒaÂ¯Â¯Â™aÂ±Â£kxÂ™mmxUwÃ@ÂxmUÂ™bÂ¯KÂ™wÃ³Â„Ã@kmmÂ¹Ub@lklVbmnnVUV@xÂ›UknÆ§JUX@ÂŽÂƒLÃ‡WkwÂ™LÄ·Æ§Ã…wWJkÂ„ÂƒLkÃ¾Ä‰xWzÂ™JUnÃ‡ÂškÂš@ÆkÂ¼ÃœÃ”ÃˆKÂšÃ¨@Â°lÃˆÂ™Ã†kÂ¦lÂ„n@lÂ¼@lÂ¯LÂ™Â°UUÂ™VÃ‡Â°ÂƒÂ¹Â—`mÂ¼mXkÂ‚Â™bUaÂƒV@UÂ¯x@Â¦Â™Ã‡Â™Â„UUmlmUÂVmÂ„nnmlkwÂ™@@ÂšÂƒÂ¦Ã…Â‚Ã‡LmxÂ¯IklÂšÂ„@Â¦mÃ†Â°VUxÂ¯LmÂ„@JÂ„InlmxUÂ²ÂšmVbkVÂ‚bUnÃˆÂŽlKU_ÂšWlÄ«ÃˆaÃžÂ¦Ã†@Â„ÃžlanV@ÂƒÂšVÂšÂUbl@XlÃ‡Ã’Ä¸ÂlÂŽVaÂ„UXÂ„lm@Ã‘Â°ÂƒÂƒÂÃˆmUwÂ‚ÂUÂ™nyWÂ£ÂamL@mÂšaÂ²@lÂÂšVÂ„Â™VLÃ†ynXÂ„ÂšÃÂšVÂšÂšKnxÃ†b@lk@WzXÂŽ@llÂ—n`ÂšIVÂ‚Â°b@nÂ„mÂ„Â„Â‚UnbÂ„aVlÃ†@ÄŒxmnnLÂ„Â¤Ã†xÂšÂšÄ Ã›ÃˆKVbÂ„@Â„aWaÂœUÂ‚Ã³kVmÂ™nL@WÂ‚UnnÂšKlÂšÂœÂ¥Â‚bnIlÂUÂÂ¯JlÂƒUkVkn`lUUÂ™VÂ»ÂšwnwlUÃ´ÂšÄŠÂ¥nnÂ„yÃ†b'],
                    'encodeOffsets': [[
                            113074,
                            37862
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6107',
                'properties': {
                    'name': 'æ±‰ä¸­å¸‚',
                    'cp': [
                        106.886,
                        33.0139
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lKnb@nÂ„lWbÂ°bkxÄ¸wVb@Å‚Â„nlÂŽÂ„ÂƒÄŠÂ¥ÂšL@ÂXÂŽlÂ™ÃˆÂƒVblÂÃˆKÂ‚bÂ„akÂVwÃ´mlÂÂ²`Â‚nÂœ@Â‚nVKÂœlÂ˜kÂ²xÅŽÂƒÂ°Â¦VUÂ„JÄŠw@Ã§nÂWÃ§ÃžÂƒVkUÂÃ³Ã›@Â¥kwÂšÂ™ÂšUmÂƒXÂ¯WÂÂšÃ‘kÂƒ@ÂUymIUwlUnÂ¥Â‚mUkÂ²aÂ°Â¯VÂ»@Â™ÃVÃˆÂ™Â„ÃÄ‹Ã…Ã…VlÂ»Â@lÂ@aÂ°Â±@_kammÃ…bÂ™a@ÂÂƒÂƒm@Ã…Â¼Â™KknÃµÄ Â—@mÂšÂƒÂ„Â¯LÃ…wÂ›Â‚Â—LVxmb@Â¼kVÂ™@mwÂ¯wVakKWÂ»ÂXÂ±Â¼Â¯VkxÂƒbÂ„Â¼WÂŽ@nÂx@xÂ±bÃ³akbÂƒ@ÃmUÂÂ™@Ä·Ã“Ã›LÂ™kÂƒVUmÂ™kÂ¯Â¤ÃLUlÃ@ÃzÂ™ÂšÂ„x@xÂ™Â°Â™Â™Â™bÂƒmÂƒXÂ¯aUJWÂ¯Â—k@bÃ‡WÂƒwÃ›wWxÂƒ@XÂWlÂb@ÂŽÂƒÂ„VÂŽÃˆUlwÂšLnlÂ°VlUÃ´Â¦ÂœUÂ°Â¤VÂšUxVXUxlbkVVlÂƒIÂ„Â°Â„Ã…VlUÂ°m@kÂ„Ã‡UÂ¯xUlÂƒLUlVL@bÂ™Â°Ä InÄ Â°ÃˆnKÂ‚Â„@xÃžaÂ²nÂ‚aUyÂšXUKVkÂšWÃ´Â¼ÃˆaÂ‚zÂ°JXUVÃ‡V_Â„JVÂƒÂšz@ÂŽnb'],
                    'encodeOffsets': [[
                            109137,
                            34392
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6109',
                'properties': {
                    'name': 'å®‰åº·å¸‚',
                    'cp': [
                        109.1162,
                        32.7722
                    ],
                    'childNum': 10
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„bÄŠaÆ¨Ã¨ÂšwÃ´ÂÃ´ÂÂ„Â¼ÂšbÂ°aÂšXVÂƒÃžVUÂÃž@Â‚aXÂƒmÂ¥kImxÂ¯Â¯ÂƒV@anU@UÃ‡Ã©ÄŸL@ÂƒÂ¯Â¥VÂ£mÂƒ@ÃÃˆbÂ„KÂ‚Â™Â„XÂ°wÄŒÃ¿Â˜ÂƒÂ„b@xÃˆblxÃˆÂ¯ÄŠÂ„Â„mÃ†UVÂƒÂ„nÃˆ@Æ¨ÂÃœLÄ¢Â¥ÂƒÅ¹nÂƒÂ°VnnÂ˜KÂ„aÃ´_ÃˆÂƒÂšwUÂÂ‚aXÂmÂnWÂ‚ÂÂ¯ÂklÂ›LXÂƒÃ‡Â™ÅÂ¦ÃaÃ…VmbÄŸUnÂ¥Â±wÃ…Ã©VÂÂƒanÂ¥ÂƒÂÂ„UÂ„Â»Â°amÂ¥Â„Â£ÂƒÃ@ÂƒÂ„wVwÂ™Â¥nUÂ„Ã‘ÂƒUmmVwÂmÄ·IÃ…aÃ³VWxkblb@bÃ³l@ÂœÄŸÃ’Ä‰Â¤Ä‹XÂƒÂ˜Â¯XÂ™xkÂ„Ã‡@Ã³Ã†Ã…x@ÂšÂ™xÄ·_kmÃÂŽÃ‡Â£kblb@`Â¯Â²@bkÂ‚Â‚@kÂ¼Ã†UÄŒÃ†ÂƒÃžÃ‡ÂšÃžU@ÂšUÂ¼Â¯Â°Â±bVlÂnmÂ¦kVVxnJVz@Â‚lÂ„Â™Ã’XÂWÂ°nÂ„Â™VÂ™Âšlx@Â¦Ã´ÃœVÂUlÃÂ„XÃ¨mÂ@Ã¨'],
                    'encodeOffsets': [[
                            110644,
                            34521
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6110',
                'properties': {
                    'name': 'å•†æ´›å¸‚',
                    'cp': [
                        109.8083,
                        33.761
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â²nlÂ‚Ã´bÂšÂ„Â°aVwnKÃžIÂš`Â°wÂšXÃ´wÂ°VÄŠÂ°@ÂŽÃ…ÂšÂ„ÃžÃ†VÂ„zÃžK@xÂšÂŽ@aÂ‚LÃ…Âš@b@ÂŽnLlÂƒ@ÂšlnÂ„mnLVwÂ„aÂ„bVÂƒÂ‚VnbUÂ¼Â„VÂƒÂ°Â„blÂ„ÂšbÃˆ@Ä¶ÂÅ¦bÂ˜@nÃ‡@amIÂyUI@ÂÄ ÂVmÃ´ÂƒUÂÂ™ÂƒVwkwlanJÂ„Â¯lwÃ³Â¥@anÂÂ°JÂš_Â„ÂÂ‚@ÂšÂ™nÃ³Æ’Ã³@Â£lÂ¥UwmaÂšÃ‘@ÂƒÂUmÂ±V_ÂƒJÂ—Â£Â›JÂ—UWÂ¥Â¯@Âƒ_kÂÂ¯Â¼mUÂƒVUÃ¨Â¯b@wmLÂ™Â»ÄŸVmaÄŸIÂ¯Â¤Ä‹IUWÂ™XÂƒKÄµÂ¦Ä·aÂƒJUbÂ™IÂƒlUÂÃ³Vmk@WÃ…Ã…Ã‡@ÂƒmUÂ„Ã…VÂƒnÄ‰ÂƒÃ‡Â°kwÃ‡a@wÂƒaÂ—Â„Ä‹Ä€Â¯xÂƒWÂÂšÂƒLÃ‡a@ÃžnÂ„UÂ¤Â°Â¦@Â„Ä KÃˆÃª@VmV@bÂ„UÂ°Â°nwlJnÂ¦WÂ„ÂbÃ@VÂŽ'],
                    'encodeOffsets': [[
                            111454,
                            34628
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6103',
                'properties': {
                    'name': 'å®é¸¡å¸‚',
                    'cp': [
                        107.1826,
                        34.3433
                    ],
                    'childNum': 10
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@ÂƒÂ„Â£@Â›Â°IÂšb@Â¯Â°ynÅ¹ÂƒaUÂƒlÂƒUÂ£Â„UmÂÂšÄµÄ‰@@ylUÃž@@Â£kWUÂ¯WaUÂ£Â¯Ã‡VÂ¥Âƒ@kbÂ¯wÂƒnÂ™Â¥Ã‡kUÃ‡nUÂƒÂ@ÂÂ¯Â±Â›kULÂmÂ›@ÂmÂ±_kÂŽÃ³nUxlÂŽÂƒbÂaÃ‡LkÂŽUaÃ‡Â„kÂšWÂ@ÂÂ™KÄ‰Â¦ÂƒÂ„kÂÂƒm@ÅUaÄ·xlwÂ¯aXaÂƒk@mmakL@ÂšmÂšÃ›ÂŽ@Â¼mÂ„@lÂ„XV`ÂƒnÂ™KUÂšÂ°Â°@Â²ÂšÂ¤UÂÃˆ@VxmÃ´ÂƒxÂKlÂ„VVÂ²aVwÂ„XlaÂ„Vlx@ÂUVnÂŽÃ‡nkÂ°ÂƒVVLÂ™lkIÂ™ÂšÂƒJÃ‡kÂ¯V@ÂšknÃ†Â˜n@lznmlVkzVÂŽÂ„VVxÂš@UxÂ„z@xÂ±Â¼VxÂxUÂ„lÂ‚kbÂ˜@Â„Â¼ÄŒkÂ˜VXlÄ kÃ´VÂ²wÂ‚LUKlwÂœJ@aÂ‚IVÂ¥ÃžÂƒnÂ¯ÃœnÂ„Â‚Â„@nkÂ˜lÂ²kÃ†@ÂšÂ°Â„aVbnI@Â™ÂšÂ‚Å¤n'],
                    'encodeOffsets': [[
                            110408,
                            35815
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6105',
                'properties': {
                    'name': 'æ¸­å—å¸‚',
                    'cp': [
                        109.7864,
                        35.0299
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@ÃˆÃ´LÂ„xUÂŽÂ°Â„Ãž@mÂŽÃˆnlÂ¤nUÃ´LÂ‚wX`@ÃžÃLÂ™ÂŽUÂšmLÃ´Â„Â„ÂŽÃ´bVbnÂºlnÃž@Ã´ÂƒÂšxÂ°LÂšanVÂ‚wÃž@VxnwÂšnlwÂ²Â¤ÂšbÂ°Â°Â„bVnÂƒlXbÂƒÂ„Ã³Â„@bÂšÂ‚Ä @Â„xÂšbÂšÂ¦Å¤ÂšVÂ™XÄ¡Â„Â£WÂ¥Æ½É½ÂƒÃ³@Ã½Ã³ÆÃÂ»Â„Â£XÂ™mÆ…ÂšÂÄŠkUÂƒÂ„@Â™Â™ÂšÃ³Â„kÅ¥aÄµÂŽÃ‡@Â™akÂƒÂƒaÂ„Â¯ÂƒUVÂ»maÂUUÂ„ÂƒaÂƒbUxmKÂƒnkm@Â™kÂ„mK@ÂÂƒxÃ³@Â¯nÂ¯KÃ‡Â¦@Ã´Ã…Ã¨lxkxÂ°nÂƒÆ¾Â¯KUÂÂ¯WÄ·L@VÃIUbÂ™yWbXÂ¼Ã‡Â°'],
                    'encodeOffsets': [[
                            111589,
                            35657
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6104',
                'properties': {
                    'name': 'å’¸é˜³å¸‚',
                    'cp': [
                        108.4131,
                        34.8706
                    ],
                    'childNum': 14
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÂšIXyÄŠwlÃ½Â„KlÂƒXIVaÄ·ÂƒÂ™Â»ÂaÂ›Â£Â„ÂÂ¯aVU@aÂÂ™Â‚wÃˆÅÂ‚aÂšLÂ²Â»Â‚VÂœUlnÂ°WÃˆÂ¯WÂ»XaÂšzVaÃžJ@UÂƒÂ»@Â¯ÃbÄŸwly@Â£kÃ‘Å£Â±WÃ‘Âƒ@kaÂ™IUÂƒÂƒnÂƒ@Â¯ÂƒÃ³mÅ£UÂ™bÂ™UÂ¯lÃ‡IÃb@Â¤Ã@kV@zÄŠ@Â™Ä¶nÂÂƒVVÂ¤kÂ„VÂ„Â„bmÅºÂ¯z@Â°Â™aÂ¯J@ÂœÂƒÂ¤@Â„Â„bUxÂ™bÂƒÂ„@`Â™xUÃ”Â±ÂºVXÂœWÂ‚Â„UnUJÂ‚LÄ¢Â¯ÃˆKlblmÃˆXÅŽÂ°ÂšUÂ„ÂÂ°LÂšÂŽlkÃžKÂš@Ãˆxl_Â°Ä¶UÃ’kblÂš'],
                    'encodeOffsets': [[
                            111229,
                            36394
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6101',
                'properties': {
                    'name': 'è¥¿å®‰å¸‚',
                    'cp': [
                        109.1162,
                        34.2004
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â°Â²@Â‚Â„ÂmVVÃˆÃˆlÂšÂ¦Â„mÂ°xlaÂ„@UÂ¦Â°ÃˆVÂ¤XbVÂ°lXÃžaÃˆJÂ°kÂšVÂšaÅ¤VÃ´nÂ°Â„Â„@Â„mVÂ„ÂšJlbÂ„@XÃ’Å¤Â²lÃ’@Â¤kzÄ xÃža@Â°Â„Â¼Ä¸KÂ°XVÂ‚Â°LÂ„Æ½Â¯mlwkwÃ†Ã§@Ã³ÃˆÂ¥Â°LÂ°mÃ´@Â„w@aÃ†Â™ÂK@bÂ™Â@wÃLÂƒyÃ…UÂƒÃÃ†Â™@ÂÄ‰Â¯Â¯UÃ³xÂ™WÂ¯xÂ™_ÃJmLUxÂ¯bÂ™ÂƒÃ³akÂÂ±mÃUUÂ„Â™WÂ¯bÂ™aÂƒÂ»Ã³ÂÃ³ÂÂ™xÆ§Ã§Ä‰bÂƒaÄ‰xÂƒIUVÂ¯Â¥ÅÂ„Â±wÂ—l'],
                    'encodeOffsets': [[
                            110206,
                            34532
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6102',
                'properties': {
                    'name': 'é“œå·å¸‚',
                    'cp': [
                        109.0393,
                        35.1947
                    ],
                    'childNum': 2
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã†xÄ¸Æ¨ÂšKlxÃˆXÂ„K@ÂVWÆ¨IlmÂœV@wVUmUnmUalk@kVaUaÃ³aÂƒÂÃ³ÂƒnKVÂ™ÂšÂÃžK@ÃW_ÂxÃ³KmVkÂ£Ã‡mnÂÃ@Â¯ÂƒVÂÂƒwÃ³K@Ã‡Â¯XkmÂ›VÂUÂ±Â¼Â™KÂbÃ‡ÅŽÂxÂ‚Âš@bUVÂ°bÂƒÂÂœÂ¤Â‚bÂšÂ¼Ä¸Â„Ub'],
                    'encodeOffsets': [[
                            111477,
                            36192
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/shan_xi_2_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '1409',
                'properties': {
                    'name': 'å¿»å·žå¸‚',
                    'cp': [
                        112.4561,
                        38.8971
                    ],
                    'childNum': 14
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Vx@lnbnÂ¦WlnnUÂšmÂšÂ°ÂšÂ²VÂšÂVÂ‚VVVnUnÂ„Âºlz@lÂ„Â„@JÂƒ@kXWVXl@LÂƒa@Â„ÂƒKULÂ„ÂŽlbnKlLnKÂ‚LnKÃ†XnÂ°ÂšbVV@bUVlÂ°Un@LnaVJUbW@UXÂ²lÂ‚@ÄŒwlVVIÂšWnkÃ†aÂ°Â„Â„anVÂ‚KnÂÂ°Â™UWÂ¯@Â™aVUVk@Un@Â„aV@ValwUanmWUÂ„k@WVUUanaVwnLVlÂ°@nk@mVU@UVK@wÂ„LVKVU@ÂƒÂ„K@UUKVUV@@bnLÂ„aÂ‚VÂ„aÃ´ÂšlIXmlKX_Â°KVV@bVVÂ„@ÂšzV`kblIÂ„VÂ„UlÂ‚ÂšL@bnV@VÂ„ÂÄŠllÂ„Â„VlIXW@kÂ„aÂ‚UÂ²blKÂšVnIlJÂ„albXXlWVnÂ°JnÂšnL@l@XlJlaX@Â„XÂ˜WÂ²@l_VmnKÂšUÂ„blU@mnkVKÂ„Â¯@U@Âƒma@kXÂ¥VÂƒmakkÂƒLÂƒÂÂa@aÂƒ@WIUUVÂXÂWWnk@aÂ°a@kkm@kUUmJmÂ@WUUUIk`m@VÂ—kaWWkXÂ™KmÂƒXkÂ¯Âƒ@ÂWKÂƒLkak@Â±bÂƒwÂ@ÂƒaÂƒa@akaÂƒ@maÂ¯@ÂƒLÂ—KÃ‡Ã…kKWbkmÄ¡ÂÂ™Â±Ã…UÂƒLUKÂ™VVkÂƒmÂ¯LUVVbÂƒÂ„UwUWÂ¯bmÂ„ÂƒUÂLÂƒxWJÂ—@ÂƒklmkUm@@KnwVkVK@akwÂƒ@@aÂ¯bÂƒKknÂ›VUIÂ™bÂ¯mmbk@UbmKUL@xUUÂƒ@klmLUÂŽlVXIÂ‚VVVUVUÂœU`mLXVWbXnW`Ã…Â²Â°xmÂŽÂxU@mÂÄ‰ÂƒÂƒwU@mbU@UÂƒmbkVWÂ¦kJÂ™@ÂƒX@`Â¯Im@UlUVVnÂb@bWJXnmbÂƒJUUÂ™UUaÂƒ@UamIkaÂƒxÂƒ@@x@b'],
                    'encodeOffsets': [[
                            113614,
                            39657
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1411',
                'properties': {
                    'name': 'å•æ¢å¸‚',
                    'cp': [
                        111.3574,
                        37.7325
                    ],
                    'childNum': 13
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@a@wÂ„@Â„wlbnJVbÂ„@VbÂšVVVÂ„InaWmXI@aÂ‚aUmVUVkn@Â°J@_Â„WÂš@lIXÂ¥lUnaVÂ„V@naV@Â„xÄŠÂ„nÂ‚V@Â‚wnÂÂ¯wÃ†Â±X_WmXaWUnKV_VÂ›VUUUÂUWJkUVÂnKlkÂ¯ÂÂ™@@kmKUaÃ…ÂÂ±KkU@WmI@WUIlUUmVwXÂƒÂ‚w@ÂƒÂUlUVwÂœVÂ‚@Â„LnbÂ‚W@anU@UÂšaVkÃ´@lÂ»n@naÂ˜JnUÃˆLVaÃ†ÂƒUUVmÂ„ÂVKVÂƒÂ²L@mU_lK@UVWkUÂ‚a@a@UÂ¯aUaÂƒÃ‘Ã³Ã‘UbÂ™Â„ÂƒKk@@aÂƒkÂ¯mVaUwVÂÂƒÃ‘kWUÂmK@UUKmXUWÃwUaÂ™LUU@aWJUUU@UaÃÂ„U@WL@VÂKVaVI@WnU@alIVKÂÂƒÂƒ@kIÂƒÂmIkJ@Â™m@ÂƒÂ™Â@@_Â™K@xÂƒ@kaW@UÂ„@Vmn@ÂŽUKÂ@mIÂƒJUXVÂ¤XXWlkKÂƒkkK@XmJVakImJU@Ã³Â™Â¯LWKUV@nUVÂƒLkxmKkLma@kXKmmÂƒLÂƒaÂbÂ™LmK@VÂ@mXVÃ†UxÂƒX@`nLÂ„aV@@VmLUVnLlLÂšÂ˜Â„b@Â„ÂšÂŽÂ°Â²nx@bÂ‚VUxlb@VÂ¯bUV@zVÂ‚XVÄŠXVx@lVn@VnnmÂŽUÂš@LlJXVÂƒzÂ¯VWVXbÂšV@bmnÂ™VUVkÂ„Ã‡Ã¾Ã…Â„@XVxmbUlVÂ„UlnÂ„WÂ„@Â„XlÂ‚@VLXÃ’@bÃžJÂ°Â¦Â„LÂ˜Ã²Â„@nUÂ‚b@Â°Â„X@ÂŽXbmVUÂ„VÂ„nb@xÂ‚x'],
                    'encodeOffsets': [[
                            113614,
                            39657
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1410',
                'properties': {
                    'name': 'ä¸´æ±¾å¸‚',
                    'cp': [
                        111.4783,
                        36.1615
                    ],
                    'childNum': 17
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nWÂ‚@@UnLÂšKÂ‚aÂ„bÂ„KnnWL@lnblKnLlwÂ„KVU@mVUXLÂ°KÃ´ÂšV@nIlJUbnI@WlLÂ„llLXkWWUÂ£VWÂ„InJÂ‚@VL@Ânm@UVÂƒX@lbÂ„@@wÂšL@`Â‚@Â„Âšn@V@lwÂ„@nÂ„VmVXÂ„WmwnUlÂƒÂœa@_lKÂ„wVlUnÂ°xVKVXXWlUÂšVVI@K@KÂ„nÂ°KÂœwlVlU@kna@ÂV_Â„WnÂÂ‚mÂ„UVm@kXml_@mÂ„LlKXwÂ°m@_Ã´JVUV@XÂ™l@UaV@VaÂ°IÂ„lkÂ»VwUkVÂmwÂUmmVÂn@VÂ¯@KÂƒUÂ—wmK@UÂ¯wUVÃ@mJÂƒUÂ—nWKÂ™@@UnKVaÂ„_lykUmKÃ›nm@Â™x@ÂƒUUlwVkÂ™ÂƒXW@ÂÂƒa@UÂƒ@@K@ÂƒkIVÂ™nammVakUlÂƒ@wX@@kÂƒÂ™Â¯@ÂƒVVbml@Â„Â„Â°UbULmlVbnbÃ…KÂ±ÂÂVÂƒKVXUJWaÂ@ULWaUÂU@@U@aWK@UkxUKÂƒLUUUJÂ±UkL@VÂ±kk@kam@UV@l@LWl@Ân@VVUxÂ„LlUUx@VUVÂ™U@aÂƒIUlÂ™L@Â°mLUÂ‚ÂƒbkUUaWUUaUU@aWKÂ—LWJ@bUL@VUVVbU@mÂ@a@ÂÂkmKmnÄ‰lUKÂ™XÂƒWUblbÂ—xmIkÂƒÂƒU@xWb@lkÂšVxÂ™LXÂŽmzVV@bklVVUzmÂ˜@bkÂ„@ÂVx@xlÂŽUÂ„@lUbVÂnl@Â„Wxnl@n@ÂŽUbVÂ„mLÂÂ‚mÂÂƒb@`X@lUX@@xlnkLWaUJnnWVÂ™Vn@lÂ„@bULVV@lÂ™V@XnJVX'],
                    'encodeOffsets': [[
                            113063,
                            37784
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1407',
                'properties': {
                    'name': 'æ™‹ä¸­å¸‚',
                    'cp': [
                        112.7747,
                        37.37
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@ÂšlInJÂ„ÂlJÂ„@Â‚Â„ULkJ@bmV@XUJUbÂ‚L@UXKV@ÃžÂƒVbV@VVXI@bVVÂšKVbÃžxVXnWVL@VnLVÂ‚lXÂ„Ã’UÂŽVxUbÂ°nÂ„l@bl@Â„LÂšÂƒVaÃ´Ã’Â„Ã’VbÂ°b@VnLnnV@lmn@lbÂ„UÂ„V@Â„Â‚JÂœUVVÂ‚Xkl@lUzmJ@xÂšXklÂ‚bUnÂ„JVÂšUbÂ„nUÂ‚lbÂ„V@nlLX@lakÂšV`UbÂ°Âš@XVJnUÂ‚LÂ²KlxnI@KV@lbUbVVÂ„KnVl@Â„zlm@UÂš@nÂŽÂšI@WUaVÂl@@mVUÂ„@XkWÂ@ÂƒnkVKVÂƒÂ„_VwÂ„y@knwVaÂ‚@XalUÂ„@ÂšVnml@Â„X@VÂ„LÂ‚KVaÃžbnnlJÂšIÂ„mVKnÂ„VVVInVlUÂ„@Â„m@Â™mÂXK@UmyUI@mWUUakamw@wUwmLkakwVÂƒmKÂ™w@wUamÂ£Ây@am_ÂƒW@Â™UU@knmmÂÂ„amU@WUa@knw@ÂÂƒUUUUV@nÂƒJmÂ@mVUkKVUUUkKmwÂƒKULÂƒKUImV@lUnÂ™nÂÂŽm@mbUK@Â°Â™bUnmbUmkkÂƒWUb@am@UXkK@aÂ±@Â™VÂ™@Ä‰Ã…Â™Â„VÂ‚UXVxUVkLWlÂ¯@@bULUlm@@nm`Â—XÂƒlWakIkmÂ›VUbUL@Vm@kIÂƒ@@KÂšm@Â—VaXÂÂ‚I@W@aU@kUÂƒVU_Â™KÂƒbÂƒJkkÃ‡ÂŽÂ™b@nkKmLÂ™wÃ…W@kVUUÂƒVU@WUIÂƒJmIXmma@_kyVaUUlkUm@ÂƒkUÂ›xÂ¯LÂƒm@L@LUJÂ™UkVWXUWULÂ¯wVmUkÂƒxkL@`Â›bkÂ„mVnxÂƒXUWUnmÂƒÂƒ@kxU@'],
                    'encodeOffsets': [[
                            114087,
                            37682
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1408',
                'properties': {
                    'name': 'è¿åŸŽå¸‚',
                    'cp': [
                        111.1487,
                        35.2002
                    ],
                    'childNum': 13
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„VlÂ„nJÂ˜wkaVaÂ„XÂšWVLÄŠknmnLÂ‚l@Â@bnÂ‚V@UaVU@UVK@aXIÂ˜KXL@bVVVbXVVblVÂ„aVÂnK@Â¯ÂšKVkÂ„J@bÂšVVU@UVwkVÂƒKVwUUm@@ÂXk@K@kVUn@lbl@Â²l@UlKÂ²VVIVVÂ„KVLlw@VXL@b@VV@VÂŽXbVKÂ‚@XbVIUWÂ„LÂ‚UÂ²ÂÃ†LmaUankVKVaÂƒÂ¯@ÂƒnkUaÂ„UÂ°@Â„ÂšÂ‚Ân@@kWaÂ„UVaXUWÂ@IXKVw@UÂ™ÂƒÂ„Â™WU@W@Â@UUÂƒU@mnÂ@Âƒ`m@UUULkUmJÂ™IUÂÂƒ@@UÂƒK@UÂ@Â›anÂƒÂ™ak_@wmKUwmakVÂ™kmKÂ™VÂ™kÂ¯bÂ™wÂƒ`kwUIÃ‡xÂ¯Â»Ã‡aÃ…ÂƒmnÂ@@Â™mÂƒmUkV@wkKW@kxmLÂ™UkÂÄ‰LÃkÂ™xÃwÂ¯lÃ³VUÂ„mV@Ä€VVXÂ¦WÂ¤kz@`VxÂ°Â„Â²Ä¸Â‚Âš@Â„Ul@xÂ„ÃªÄ¸ÇŠÂ°Â¤VÂ„VlXLWnXxmV@nUl@Â„'],
                    'encodeOffsets': [[
                            113232,
                            36597
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1402',
                'properties': {
                    'name': 'å¤§åŒå¸‚',
                    'cp': [
                        113.7854,
                        39.8035
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â²Â£Âšyl@ÄŒÂÂ˜Ä–@bÄ¸ÂŽÄ¢bÄ¸Â„Â˜ÂXÂÂ„aÂ‚KÅ¤nn@ÅŽÃ´llÃˆxÂ„nVnÃžÃ‡Â„V@bÂ‚nXllLÂ°KÂšbVb@J@bÂ—Â„Â‚Â„@ÂŽUÂ„Â„xlKXLlKlÂXkÂ„Â@UlkÂ„JlkUÂƒVKXUÂƒÃ‡VIVm@_nÃ‡ÂšLÂšaÂšlÂ‚wÂ„VnU@UUwma@aÂƒaÃaÂLmUk@@WÂƒ@U@@XÂ™wVWÃUUUk@@VmLÂƒKVÂ»nwUwÂ™aUL@`mzÂƒJUIVÂƒUaUwÂ™KUaVIlJÃ´anÃ‘lLVUn@ÂšaÂ„@VVÂ„@@UUwVKÂ°Vn_lJÃ†LÂœÃ©W@UUUÃ…@Â»lm@aÃžIVwXWÂ˜UUkkm@U@aÂƒU@ÂmwUÂ£VWU_kWmÂƒXwW_Â°yUkkK@UÃ‡K@kkUVymÂÃ³KÂ—U@KWIÂƒbUak@mJ@bkbmLkÂŽÂ™UmÂƒkVUÂ„WÂ¦@lnb@Â„@VÂƒÂ°ULml@nkVÂƒaÂ™VmLUnk`Â±@Â—XÂƒWW@kbÃ‡Â¦XÂŽÂ¯Â„WxÂI@xmbmxXlWVÂ„Â„@bÃ…ÂŽUz@JÂ‚b@bÃžbÂ™ÂŽU@Wbk@Âƒxk@WXÂ¯VÃ›Â™ÂƒWÃbÃUkVUU@alI@a@akLWaÂ™m@UÂ¯UUmÃ‡L@K@aU@Â¯VUkÂƒKmX@`@ÂœkJ@nVÂ‚Ub@ÂlbVÃ†XVWÂ„ULU`VbkLUV@XWl@bXJÂ˜@ÂÂVbV@Vl'],
                    'encodeOffsets': [[
                            115335,
                            41209
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1404',
                'properties': {
                    'name': 'é•¿æ²»å¸‚',
                    'cp': [
                        112.8625,
                        36.4746
                    ],
                    'childNum': 12
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@UkÂ™Lky@IÂ‚JVaÂÂ@mÃžaWÂÂšy@_ÂW@_WÂƒXVlUVwÂš@nwÂ°K@mÂ„ÂUÂƒVaÂƒmVÂkU@mmmnLVUmKXaÂ™U@IlKVUnK@UmWkX@WV_VÂƒ@akU@aÂ„KWIXyÂƒIUVmUnÂ™Ua@ÂWaXUVKVmkUWVkUÂƒLU@@VÂƒbÂƒKÂbÂƒIUmÂƒ@mbVLÂ—xÂ›WUUknÂ±VÂ¯wÂƒbÃ…JUbmLkbmKÃ…KÂƒbVnUbÂƒVÂ™KUbÂ™KUbmLÂKmÂÂƒbÂ™aÂƒKkUm@UÂŽnnÂ‚VnxUÂVlUxlÂ¼ÂƒkÂ¯JUbU@Vbk@WÂšU@UVÃ³I@`Â¯nWxkLÂƒK@nk`Wn@lUnÂƒVÂnmÂ‚ÂƒXU`@Âmb@lkV@Â„VnklVVUblz@`nbWnnJÂ„IVJ@XUVVÂ„UV@lÃ†XÂšxnKlL@mÂšaÃˆÂllÂ„IÂ„aÂšLV`Â„UlVV@@b@XÂJWÂUb@Â˜Â™n@LÂ„@lJn@@UVKVaÂœUlnlJXbÂ„kÂ˜Wn_@mn@VkVK@aÂ°@XklKVUUwVWUÂÂšÂƒÄŠÃ†Âš@ÂšUÂ²@@blLVWn@@bVaÂ„XllVnnaVmÂša@Â¯VLnan@Â‚ÂÂšmVm@knUVJ'],
                    'encodeOffsets': [[
                            116269,
                            37637
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1406',
                'properties': {
                    'name': 'æœ”å·žå¸‚',
                    'cp': [
                        113.0713,
                        39.6991
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XXWVXVWnnlnn@Ã¨Ã†Â¼@Â„Â„xlÂšÂ„ÂŽVÂ„nblÂšÂšÂšVÂŽÃˆÂUVlÂ‚Âš@Â„blnÂœLÃœÂƒÄŠmUkU@UaÂ‚ÂÂ—@WI@aXk@WVUlKUaV_VKXÂƒWUUÃ…ka@ÂVaUÂ@mlI@Â›@_nWÂ„LVlÂ°UV@@b@LÃˆKVnÂ°V@VÂšnXblK@b@bkJ@bVVlUÃžVÃžaÂ„XÃœÂšÂ°UXWl@Â„wl@XaV@ÂšÂÃa@aÂa@IVyÃ†Â@aÂƒÂƒXUWknwna@wÂ‚JXwÂ°ÂƒWÂÃˆÂ¥kI@W@kmKmÂ™Â¯IUmkXWWkaÂƒbkImJÂ™UkLÂ±aÂVÂƒb@lWXkJÂƒUkÂƒÄ‰kÂƒÂ@UmU@aÂ™KkÂÂƒVÂƒUkJlaU_Â™yÂƒ@UU@aUUÂ¯LW`kLWnkJÃ³Â™ÂƒbÂUÂƒbmK@aU@UVVL@VÂƒL@Â„UVULÂƒK@xUL@VUV@nmlÂ¯@UkmKUxmbVbUV@XÂƒlXVmnVbkxUbU@Âƒbm@@VUlUVÂšbÂ°@VXÂ¯ÂšmÂ‚'],
                    'encodeOffsets': [[
                            114615,
                            40562
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1405',
                'properties': {
                    'name': 'æ™‹åŸŽå¸‚',
                    'cp': [
                        112.7856,
                        35.6342
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lVÂ„LÂšbÂ„anÂÂ‚LnKVaÂšLVaÂšLÂ„UVaUmÂ„aÃ†LnLlanKVaÃ†IÂ„aÂ°xÂ²UlmVVÂœXÂ˜wUKnaÂ„@VnÂ„JÂ‚aÂ„LÂ„a@UV@@alUkKVKnkmmVwUkÂ„w@ÂƒÂ™@kxWUXÂƒW@@mÂƒk@aUa@aÂ¯aÂƒLkKmwkUm@kL@K@aWIXmÂƒVÂƒXÂƒWkUVakL@UVKÂƒw@aUK@UUKmLU@Â¯nÂ™KUwVÂƒUIWJÂUWmkaÂ™@UXÂƒJÂƒk@UkmW@kLWKÂVÂƒx@bmI@VUaVU@aÂ¯@UUmVÂKmXÂ@Â±`ÂkÃKVxULÂ±akL@VÂ™bÂƒLkKmVÂƒ@XÂWVUbÂƒVXb@lm@ÂÂ@lW@@xkÂ„lVUbnnmbUÂšlJ@Â„@LÂ„@@VÂ„b@Â‚WXÂšÂ„UlkxVV@Â„Âšwn@ÃœmnLlVkzÂƒ`UbmL@VÂš@XLÂ˜mÂ„VnIÃž@VUÂ°x@VnLÂ˜xÂ„V@LUÂ°'],
                    'encodeOffsets': [[
                            115223,
                            36895
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1401',
                'properties': {
                    'name': 'å¤ªåŽŸå¸‚',
                    'cp': [
                        112.3352,
                        37.9413
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„@VV@wVKnLVal@naÂ°nÂšaVJÂœUlmÂ„LÂ°a@bÂ„@lx@bULUlmx@Ln@lVknÂ„lÂ˜@XIÂ„wÂ‚KÂ„VnÂƒÂ°aVXVxÂ„ÂƒUaVUÂ°KÂ„nUlÂšUVLÂ„KÃ†VÂšÂ²Ä¢Â‚lnXalLÃˆÃ†Â˜LÂ„KUaVkUanmWUÂ™aÂ@WwkUWUÂ¯yÂ¯Ã‘@anIl@@aVUÂ„mÂ„IÂ„ymUÂƒLUUVakaU@@LmJkwÂ±LÂKmVUI@WÂ¯Â™VaU_lÂ™kbW@kK@mÂƒUkaVÂÂƒmVaUÂ™ÂƒIVmÂalkÂ™W@wnIVy@klkÂWUUÂ›VÂI@ÂƒÂƒUÂƒVkam@knU@mmmK@bÂblVUX@VkLV`@nÂ±KUÂ„ULÂƒÂ‚UnVVÃ…Â„UbÃ‡KmVÂ—Imbm@kÂ¼Ã³@UlÂ™b@VmV@bÂXmaÂƒKÂ@Â›UUxkVÂ‚V@Â„ÂxWÂ„UxVnkVVJ@XnJ@XlVÂ²LÃ†Â‚VbnL@lÂš@Â°Â'],
                    'encodeOffsets': [[
                            114503,
                            39134
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '1403',
                'properties': {
                    'name': 'é˜³æ³‰å¸‚',
                    'cp': [
                        113.4778,
                        38.0951
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â°@nbÂ„@lb@bÂ„bÂ„bÂ‚@Â„xÂ²al@lbÂ„KXU@mÂ‚kUWkkmUUÂƒVwV@XUWÂ@Â™naVklKXblKnLÂ‚ÂƒnLVanImaXKlLÂ„aÂšV@U@KUKWÂÂ„alÂƒXK@Â£WKXUV@VUÂ„ÂƒUUVWÂ„_VÂ™@W@Â@KÂ„@ÂšÂƒUÂƒÂƒIWmXUmÂƒULÂƒnÂ™JkImmÃaUbÂLÂƒK@UÂƒWk@mnÂ™UÂƒ@kVWbÂ@Ubmx@lÂƒzUxÂƒ`UÂ„ULml@Â„XÂWlÂƒ@UV@nk@UÂ‚Vb@XÂ™JmÂÂ™@@VknÂƒyk@ÂƒzÂƒJÂƒnUV@bk@mJ@bÂ°Ã’Â°zXVlVXxÂ‚@ÂšbXVmnVbUlVb'],
                    'encodeOffsets': [[
                            115864,
                            39336
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/si_chuan_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '5133',
                'properties': {
                    'name': 'ç”˜å­œè—æ—è‡ªæ²»å·ž',
                    'cp': [
                        99.9207,
                        31.0803
                    ],
                    'childNum': 18
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÂƒaXamÂƒÂ¯wmÂ@Â±Â°wUwV@UaVwÂ²KÂšÂ™Â„U@UÂƒUÂ„Â¥Â‚aÂ„Âƒ@Â£ÃžÂ™Ã´xÂ‚KnkmÂ™XÂ¥Â™IUÂƒÃÂUwlkÂ°VÂ„Â@ÂƒÃˆÂ™Â‚KUwlkUyVÂ¹Â„mÂšxÂ²XllÂ„Ã‘WÂ»ÂšÂÂ„lÂ„wÂ°UÅŽÂ„nÂƒÂ„Â„Â˜JÂœÂƒlÂ¯Â°V@wÃ´IVÃ‡nÂ™nUllÂšLÂšÂVÃ‡ÂšLÃ´Â¼XÂWÂ£@Â±Â„Â@Â¥k_Ã‡JÂƒkUÃ©ÂƒkÂšÂƒÂƒwXa@ÂƒÂšLlwÂ²Â™VxÂ„bÂ‚mÂšÂ¼ÃˆxlLÃˆÂƒÂ„VWÃžnÂ¯mÃ‡Â™Ã‘UÃlÃ›kwlÂÂÄ‰mÂƒULmwUJÂ™Ã§@wkm@Ã‘lUXÂ™ÂƒÃ‘Ã´Ä¡ÂƒÂVaÂ™ÂƒUÃ‘Â„Â¯@wÄ·Ã“kbVÂ„mnU@@yÂ¯IÄ·KÂƒV@Â¹ÂšaÂƒÃ©@kÂ„mÃžUÂ°Â¥@aÂ¯Â@anKlblUÂ„Â¥@Ã³ÄŸÃ§@ÂÃ‡w@wkÂlaÂ„Ã§ÃÂ±kÂ¯Â±@ÄŸÃUÃ›mÃÂ¯wÂƒ@kbÂ±ÂÂ¯akXWÃœkXUÃ†Ã‡UÂšÂ¤X_ÆwÂ„V@Â¤ÂƒXUÂ‚ÂƒbÂUÂƒÂŽÂƒIUlÃ‡UkÂŽÄ¡@Â™aXÄŒmlUÂlÃ¨UV@Â„mVkÂ¦VxÂÂš@Â¦Â±ÂšÂ¯ÂƒÂƒÂ¯Â¯anlWÂšÂ¯nÂƒÂƒÃ…w@wÂ°KVakÂ£m@klÂƒKknÃ‡UÂ™Â»Ã³KÂšÄ«laUaVÂ£Â@Â™Â™Â¯@Ã†Â™UÂ™VÂÂƒÃ›ÃÃ‡XÂÂƒÃ‡lÂÂ—Ã“lÅ¹Â„Â»WUÄŸJÂ¯Â£mxÂ™LÄµÃ´Â›ÂºXÂÂ„VlUllÂ²blÂ„ÂÂ„lÂŽÂƒxÃ³nnÂ°ÃÂšUÂ¼mJUÂšÂ¯nÂƒÂƒÂƒV@ÃªÄ‰Â°UÄ¸Â™wÂ™@mÂƒ@ÂÂ¯kmÂXamÃ‘Â¯aUwÃKUÂ¥Â„ÂmÃ…nÂ¥WmnÂ™ÂƒÂ¹nÂ±Æ‘Æ†Ã‡Ã´XÃªÂ±ÇŠnÂšÂƒÂ‚UÃ´lÄ–kÈ‚VÃ’Â¯Â¼VnÂƒÈ®Â¯Ä€nÆ†Â˜Ä¢@ÂŽkÂ°VÂ°Â¯Ä¢VlkÂšVxmÂ¼XÂ²Â™ÅŽ@ÂŽVxknWÃœÂ°ÂUÂ‚Â¯nÂ™Ã†ÃÂœ@`Â„Ã´ÃÂ²ÂÃ’ÂƒÂ‚Ã‡znÂ‚mX@xÂ„Ã¨Â°KÂ°Ã…Â„UÄŒÄ¬Ã³Ä–ÃÂ„ÂƒÂ˜Ã³Â¼Ã…ÃªÂƒÃ’ÂƒbmÂšk@VÂ„ÂÂŽÂ˜Â„@Ã’Âl@nÄ‰ÃœÂ›ÃªÂ—x@Ä–mlÃ…ÂÂ›JÂ¯Â¦Ã³xÈ­Â°ÃÂmÂŽÂ¯LÄµÃ¨Â›Ä€@Ã†ÂÂ„lÂ°Å¼ÂÂƒÂ‚ÂšX@xmÂŽkV@z@Â‚Â„ÂÂ°blÂŽnÃžÂ°J@bn@Ã†Â¼UVÂƒUÃ³ÂŽÃ³LÂƒÂ°XÂ°ÃLÂƒxUnÂ„Â°ÂƒÄ¬Âƒn@lnL@ÂŽÃ†@ÂšnÂ„KÃ†xnUnVÂ˜InÄ¬mÃ†nxÅŽÂ¼ÄŠIÄ¢Ã³Ãž@ÄŠÂƒÆ¨bUÂƒÂ‚mVÂÂÂ¥lÂkÂƒÂ‚wnLÂ„mÂšÃ…Ã†Â¥XÂƒÂ˜wÂU@wÂ‚wUÂÃžÂ™@alUUÃ…ÂšÂUÂ™VkkmÂ°aUÂ—Â°Ã“Â°wÂ°UÂ„ÂƒÂ„bÂ°aÂšÂÂ²KÂ˜Â¯ÂœÄ•Â˜@ÃˆbÃžÂÄŠaÂšÂ»Â„XVmÂ°InÂÂ„ÂÂ‚Ä¬kÂ¼VbÂ„aÂšJÂšÃ´ÂšÂ£VÂÄŠanÂ™Â‚kÂ„Å¯Â™Â™nÂƒÃœU@anKnÄ®Â‚bÃˆmÃ†ÂŽÂšÂ»nIÂ‚Ã©ÂœÂ£Ä Â™'],
                    'encodeOffsets': [[
                            103073,
                            33295
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5132',
                'properties': {
                    'name': 'é˜¿åè—æ—ç¾Œæ—è‡ªæ²»å·ž',
                    'cp': [
                        102.4805,
                        32.4536
                    ],
                    'childNum': 13
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@l@@Ã¾Â²I@lÂƒÂ„VLÂ°wnJÂ°UÄ¸Â™ÅŽÃ¨Â„IlwÂ„VÂ°Â¤nÄ®Â™Â¤ÃÂ„lÃ¨Â„L@Â„ÂƒÂ„@xÂ„lÂ™Ã¨Â²Ã´ÄŠ_ÄŠÄ¡VÃˆÃ´JÅ¼Ä«lbXÂšÃ†ÃˆVÂŽkxÃ‡VÂƒÂ„nÂ°Â„Â¦Ãœb@Ã¨@nn@@Â°ÂšUÃˆÂ¥WÃ‡Â„_UalaÂ¯Â¯UÃ‡Â™kÂƒÂ»Â„mVwkÂ»Â˜kÂ²Â°VxlL@Â¤Âœ_@xÂ‚`ÃˆÂÂ‚Ä–Ã¶bÂ˜Âš@lÂ²alXÂ„a@bnKÂ°Â¦VK@nnWmx@nUnl@@lÂƒlÄ‰ÂkÂ°lÂ°UXkmW@UnÂš`kÂ„Ã‡LÂ„ÂŽWÂ„Ã›ÃˆVxÂšVVlVk@lÂ„IXb@ylXÃˆWÂ˜Ä®Â„WÅ¤zÂœy@ÂšmIÂƒÂŽÂ²ÂÂšJÂ‚ÂÂš@nÂŽÂ°@VÂ„Â„JÂ°aÂ„Ã…@ÂƒÅŽkVÃ‡ÂškÂ™aUwÂ„KVwÂ™Â™VÂƒÂ„@nkmÂ™@Â±Ã´kÃ´Â™ÄŠJÂšÂ¼ÂšInÃ‘mÂ±nIÂšÂšÃžÂÂ‚XÃˆÂƒÄŠxÄŠUÃˆbÃœyÃˆÂ£VÂkw@kVUVÂ™Â„m@ÂÂšaÂ„Â»ÃœbÃˆmÂƒUXwÃxÂƒUnÂ¥@ÂÂ°Ä¡Â™Ã…Â‚aÂœJVkÂ™aWÂ¯Ã›@WÂ¥Â—UÅÄ¶Â™@Â¯ÂkUÂƒÅƒ@aÂšI@mmanwÃžÂÂ‚W@ÂÂœÂ™mwÂ°Â»UÅ™kÂ¹Â±WÂ„xVxÂ¯Â¦UÂ°ÂƒzÅ£WÂ™w@ÂÂ°Ã‡VÃ‘kÂ¯@ÂÂ„yÂ°aÂšÂ£Âš@ÂšmÂšnlÂ¼Â„aÂšÃÃakwUÂƒÂ±aÄ‰ImlÄµn@Âƒm@kkVÂƒÂ¯Ã‘mÂ™Ä¸Â™Â°xÂ„ÂlÂ™Âœ@Â˜ÂƒXVÃžmlÃ›ÃÂ™Ä‰UÃ…Â¥mwÃ…Â¥VaUwÂ›Â™XÂÄ¡ÂÂÂÄ‹aVÅ¯Ã›Å¹lwUÂÂ¯ÂUÂ™Ã³ÂÂ±ÂÂ™xÃ›VÂ±Â¯Â¯nÂ¯mÄ‹ÂƒÂLmÂnÄŠmÂ‚Â™@Â™_kJWaÂXmwUÂƒÄ‰KÂ™Â»Â™@mwXÃÂƒUÃ‡Â„kKÃ‡wÂ™Â»ÂnÂƒaUwÂ±ÂškxÂ™K@Â„WbÂ„xÂ™Â„Â„lVÃªÂ„lÃˆIl`@Â¦ÂƒÂŽ@Â²XÂ¤WÂÃ³Â»Â™KUÃˆÂ™ÂŽÂ™KkkmVmÂšUÃˆÃ³J@xÂ¯UkÂ°Â›Â„Â—IÂƒÂƒmÂ„ÅÂƒÂ¯VÂƒxÂƒkÂ™ÂŽXÂ¼ÂƒÃ’kkÂ±WÂ™wÂƒnUÂºVzklVxÂLÃ‡Âš@Â„ÂƒÂŽÂ¯UklVxÃžÂVÂ„ÂšJWÂ¦nÂšmlÂLÃ³wÃÂš@Â¤ÂƒÂ„ÂbÂƒÂ¦Â„V@VÂƒVÂ™ÂšÂ±LUxVbU@VxÂ¯x@Â²nÂ‚Â°xnÂ„WbÂ„b'],
                    'encodeOffsets': [[
                            103073,
                            33295
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5134',
                'properties': {
                    'name': 'å‡‰å±±å½æ—è‡ªæ²»å·ž',
                    'cp': [
                        101.9641,
                        27.6746
                    ],
                    'childNum': 17
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ä¶Ã³ÂšKnwÂ°Â¤Ä IXVÂƒÂ¼kÅºÂ˜Ã”kÂ‚Â„ÃˆWÂŽÃžÃˆÂ„ÃœUÂVÂšÃ…ÂšÂ°@ÂšÂšÂ‚@UÂ¤VbkbÂ™Ä¬Ã´LÂšÂ¼ÃˆVlmÂ„Llkn@lÂ¤UbÂ¯L@xÃ†xÂ„Â„Â°mXÂ™mkÂ°bÂ„Â°Â°Â„Â²Â™@Â¥Â‚Â™UwlÂ¥nU@ÂƒVUkÃ§VÂnkWÄ‹ÂšbÄ¢@lÂÃˆVVkÂ„JÂ„ÂÂ‚VÂ„aVÂÂ„W@Â£ÂƒUÆxW`Â™Â£ÃˆVVÃ…lWXÃ›lWÂ°bÂ²ÂlaÂ„@Â°xnÃžVÃœÄ ÃžÂ²@lÂ°ÃžÂ²ÂƒÃ¨kblÂŽ@xÃˆx@ÂÄ Ã¨nalÂ£nUÂ‚Ã‡Â²@Â‚ÂÃžKÂ„nnÂ¤@Â¼Â˜Â°UÂ¼Â„nVÂ‚ÂšXUÂ‚ÂšbnÂ™Ä UVbUlVÂšÂ°LXÂÂ„@lVÂ„Ã¨ÃœUnK@_ÂƒyÂXVyUwmIUÂ»VÂƒÂ„kÃ‡Â¥ÂšÃ¿kkVÂ¯mÂ±nÂ@ÂƒnÂ¯ÃœanVVÃ†Â„z@ÂŽÂ‚bÂœwÃœbÂ„m@wÂša@kÂƒmkÂ»@ÂÂ™a@ÂVUUÃ³Â„wÂ˜@nbÂ°mÂšÂ„XÂŽmnVbÃžÂŽVÂÃ´anwÂšJÂ‚akÂ£lwÂ„Â˜ÂšLÂšÃ…nÃ@wlÂ¥ÂIÃ‡Ã“Âƒ@UÂ™Â™LÂƒÂ¼kVÃ‡ÂƒÃ…Ã³Â¯kVmmw@Âƒn_Â‚VnÂ»Â°LÃ…Â»@Ã©Ã‡Ã§Å¹Ä«VÃ‡Ã@ÃÄŸUÂ™ÂƒaÂVÃÂ™Â™ÂšÂ¯Ä·lÅ­ÂÄ¡lÂƒ@Ã³ÃžÃ›Â‚Ä‹@Â¯nkUÃ“Â„Â—mÂ±Â™IVÄ¡UwÃ³KUnÂ±Â¯Â—KÂ›wÂÂ»ÂƒKÃÂVÂ„nl@Â„Ã³xUwÅ£ÂÂ›Â£Ä‰ÂƒUmÃ…Â—Ã‡ÃÂƒKÂ™Â„ÃUÂlmKÂƒÂ£ÂUVÂŽ@ÃžÃˆÂŽWÂ¦Â„Ã’@Ä¬ÂšnnyÂ‚@nÃ’mÂœVÂŽÂ—Â¼@Â°Vbl@VlnUUwlÂ™Â°a@Â„ÂœÂ„@llnkÂ°lbnKWÄ€nÂŽUÂ„VxUÂŽÂ‚Â²Ã…Â‚mÂ¦Ã›ÂÂ›Ã‡Ã…ÂšÂƒaUÂ„VbÂÂš@Â¦m`mÃ³XÂÂ™UmmÂ™xÃ…@Â±ÃžnÃ¨Â™Â²Â™UÂ¯Â»mÂ™ÂƒVÂ—m@wÂƒU@wÃÂšÃmÂLÂƒa@Â„Â™VÃ‡UkÂ„lÂ°Â¯Â„VlkVÂƒÂ¦UÂšmxÂƒaULUÃ¨Vx@Â„kIUxmWVÂ¼Â¯VmÃˆÂ¯ÂšUÂ„nlÂ›ÃˆÂ—@mÂ»Ã…Â™ÂƒVWxÃ…bÃ…ÄŸW@kÂƒm@kVVÂ¦mlnn@Â‚ÅÂ„lÂ¦Ã…Ã†Â™xkÂœ'],
                    'encodeOffsets': [[
                            102466,
                            28756
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5107',
                'properties': {
                    'name': 'ç»µé˜³å¸‚',
                    'cp': [
                        104.7327,
                        31.8713
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„Å„lVÂ°ÂÂš@ÅÄµÂ˜VXÂ»Ã†UÄŠÃ‘ÂœJÂ‚wÂ„@ÃˆÂ»mÂ»ÂšÂ£Â°KÂšk@Ã‡nÃ‘Ã†ÂÂš@Â„wÂ°JUwnw@wÂšbVbÂš@VlÅºLUwÂ„aÂƒÂ»Â„aUklyUUVakwWÂXwWÂƒUxkLÂƒmnÂ¥mÂÂšwkÂ™Â˜UXÂ™lJÂ„w@aÂƒIkÂÂ°XÂ„Â¥WÂƒÂ²ÂlÂ¥ÂšaUÂ™Â„IlmkklÂƒÃˆL@mÂ°nlWUÂ™ÂaWÂ—Âš@VÂƒÂ„@UaVÂ¥@aÂšk@Ã‡kÂ¹ÂƒK@aÂ™K@kÂƒKkÂšÃ‡X@VU@kxÂ±VÂ™Ã¨kIWwUVUkkKÃ‡@Âƒa@wkmlÂ¯@kUWnÂ£WaÂ„aVwnaVÃÂƒwÂ¯@UaWxÂ—nÂ›JÃ…Â„UxUÂšma@L@Â„mbUÂŽÂUÂ±VVnkxUÃ†Â™Â„VÂŽm@kÂkKWÂ°Â„X@Â¤Ã‡UkÃ†Ã‡nUÂ¦Â¯ÂŽkÂƒmLVwÃ…K@UÃ³bÃ‡Ã†ÂVÂƒÂ¦Â™L@Â‚Â±ÃªXÂ¦mVÃžÂškÃœÃnWUÂ—Â„Â›@kÂšÂƒÂŽÂ¯wÄ·ÂšnÂšÂ°Ã’UÂ„lln@@Â„Ä¶mnkÄŠJÂ²bVÂ„lxÃžbÂ™ÃžÂƒbkÂ»Â™mÂ™nÂ™@Â™Â¤Â¯bÂƒz@ÂŽlÂ°UÃ’Â¯Ãˆ@ÂŽÂšxÅ¤XÂ„yVÂ¯Â°Â¥UwÂƒwÂ²XlÂºVÅšÂ¯Â¼nxÂ›Âš@ÂŽÂXÃÂmxnb@nÂ™J@b'],
                    'encodeOffsets': [[
                            106448,
                            33694
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5117',
                'properties': {
                    'name': 'è¾¾å·žå¸‚',
                    'cp': [
                        107.6111,
                        31.333
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@UxnÂ°Â‚bnÂŽlUnÃ’Ã†Âƒnn@nÂ‚Â¤Â„LnxlUÂ„ÂšÂšV@Â„Ã†lÂ„xÂ°XXxl`XÂœÂƒVWÂ‚ÂœLÂ˜Ã¨Â—Â„Â±nÃˆbÂƒÂŽÂ°b@ÂšÂ²xÂ°KÃœÂ¼ÂÂ°Ä‰Â„VÂ¦lJnU@Â¦ÂšÃžÂ‚JÃžÄŸÂ„mÂšLÃžÂ»ÂšxUÂ„lbÂ„VÃ†annÂ„alÂŽÂ„VÃ†ÂX@lnÅŽVÂ„mUÂ™maÃ…XÂƒa@aWmÂœ@Â‚Â£@wÄ‰JVÂƒkkÂ‚kkmÂƒnk@Âƒmna@ÂÂšalÂÂ„KÂšÂ™Â‚J@ÂÃžwÂmÂ‚Ã…Ã…Âƒ@ambkUÂƒÂƒ@Â™Â™KUÂÄ¡KÂU@mÂ‚akÂ¯Â±ÂƒÂ„a@aÄ‰Ã‘Ã…aVwÂšXlwÂƒÂ±Â—ÂVÂ¥l@@aÂ™kÂƒÂ›Â@@Â£ÂšmÂƒÂÄ‰ÃÃ³nWV@ÂŽÂnÃÃ‡Ã‡xÂ—UmbÂƒaVkkÂk@mÂÂ„Â@mÂ°ÂƒÃÃ½XmÂ›akÂÃ…Ä«Âƒ@@ÂƒmbÂ@@xmÂšnbÂƒ@mxÂšÂŽkÂWL@ÂƒÂ¯b@WUXmWÂœÂWKkbm@kxÂ™Xmm@LUlÂ„xlÃªÃ³KÂ™nUÂšÂ„allÂ™LÂƒlÂLÃ³Â°mÂÂ¯JVÂšUÂÂ„KÂ„Â„@xÂ˜KÂ²Ä€Ã´Â¦lÂ°'],
                    'encodeOffsets': [[
                            109519,
                            31917
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5108',
                'properties': {
                    'name': 'å¹¿å…ƒå¸‚',
                    'cp': [
                        105.6885,
                        32.2284
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã†LÂ„ÂÄŠxÂ°Â»Å¦Â¦Â˜WÂ„Â™ÂšLÃˆÂ„@xÃžKÃœÂ°ÃžnVxÃ…Ä€lÃ’nJÂ°a@wÂ„ÂVÂ¯l@XÂWknKnwÂ˜VÃˆÂšÂ°XXaÂ˜lXÂ°VIÂ°bÂ„WÂ„nÂšaÂšÂšÂšÂ¥@ÂÂƒwÂ°Â™n@ÂšyÃ†@nkÃž@Â°Â¯lJnÂ„Â°IÃˆlÂ‚UÂšlXÃ…@Ä·lUVÂ¥VUUÃÃžÂ™UUÂƒ@UwÂƒJUkÄ‰m@Ã½ÂƒÂƒlkÂ™WUwVwÂÂWJk@VÂUKÂ™ÂlUkaVÂƒUÂƒmLkÂ„m@ÂƒÂƒÂ@UÂƒÂ›Ik`@Â„Â™UmlUkVÂÂ¯Ã‡XKÃ_mmÂ¯@UÂÂƒ`kwmÂÂƒlÂÂ¼Â±KVÂ¯Â—Â¯VkÂ±VkÂ±kzmaÂ™KUnÃ‡Â±Â™bkÂ¦Â±ÂŽXÂ„ÂƒÂ¦Â¯WlÂÂ„J@bÂƒxkIWÂšÂ—VlÂšÂ™xnÂŽmÂ¦Â„nlKVwXÂ„WxXÂŽlxUbVVkzVlÂƒbÂ„Â¼ÂƒbVxÅ¹KUkÂ™@UaÂ™a@xmxVxÂ¯IÂƒxÂ™@Ã…ÂŽmÃ’@ÃˆÂ™lÂ¯LÂ™Â¤nÂ¼'],
                    'encodeOffsets': [[
                            107146,
                            33452
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5118',
                'properties': {
                    'name': 'é›…å®‰å¸‚',
                    'cp': [
                        102.6672,
                        29.8938
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ln@xÂšÃ¨VInxVKnÂ„Â‚ÄŠkÂlxkÃœVÃžÂšÃ’nÃˆmÂ°nxÂš@ÂšÂ¼ÄŠLVÂ„nxÂ‚WXblIÂš`Âš@nÂmÄ‰nÂÂ‚KÄŒÂ„Ã´Ã…lÂUÃ‘mUÂ„KÂ²Â¹@ÂÃ‡Ã…VÃ“Ã…Â¯VÃ½ÃžWÂ„ÂÂ‚UVmXÂ„Ã†bnwÂšKUÃ¿Â‚ÂÂ™@UmmIUbÂ¯Â¥UwÂƒÂ™Â¯Â™Ã‡mÂšÂ™Â„Ã§manUmÂ»UUÂƒlÂ—kÂƒÂ¤ÂƒaÂ¯bVÂ™U_WÄ•ÂmÃ‡Ã…ÂšÂ±Ä¢UlÂƒUÂlÂ™Ã›VÂƒÃ§kUÂƒ@WÂŽÂ¯KUÂ™VkUaÄŸVmÂšÂ™aVÂÂ™WUÂÂƒmVÂ»Â—Â¯@Â»mÂ£ÂƒmÃLÂÂŽÂ±@ÂÃˆmVkÂ¤mb@Ã´ÂƒÂ¦kVkamL@bÂ°Â‚@bÂ¯Â¦ÃVÂƒn@lÂ„ÃªÂ™b@ÂºÂ„UÄ¸LÂ°J@zV@nmUÂƒlaÄ¸Ã”@xÂƒÂ°VÃ’ÂšÂ„UbÂ„Â‚Ã³Ä¢Â„Ã’WÂškV@Ã’'],
                    'encodeOffsets': [[
                            104727,
                            30797
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5115',
                'properties': {
                    'name': 'å®œå®¾å¸‚',
                    'cp': [
                        104.6558,
                        28.548
                    ],
                    'childNum': 10
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VlÃˆnlÂ‚XnWLX`mÂ„Â²nVÂ‚@bÂ°xÄ¢Ã§lnÂšVmÂ‚nnÂ„@@Â„Â°Â‚UzÂšlVÂ°nÃžÂ˜Ã’kxlÂÂ„wÂ„`UnVbÂ„mÂšL@albÃžKÃˆÃ›ÂšmÃœÂ¼Â°@XÃ‡ÂšÂ@wmW@Ã…Â„KÄŠLÂ„lVÂ„ÂšLVÂÅŽÃ§ÃžLÂ²Â±Â‚ÄŸkw@ÂUÂÂƒy@Â¹lKXÂ™lKVa@wÂ™Â™ÄŒ@Â‚w@ÂÂaÂ˜Ã‡UÂ¯nÂ™@Â@wÄ¡akÂ—Â™aÅÂ‚ÂƒÂÂƒK@ÂÃ…Â»VakUWmÄ·wkbÄŸÂ¥mLÂ™akÂšÂ™@Ä¡ÃžÂƒÂ°Â¯xVVÃž@VÂÂšxVÂšÂ—VWxÂ„XlxUÂ‚Â™@kÂ²WVÃ…ÂƒULmÃ¨ULVÄŠklÄ Â„VÂÂœJVxÂ±nÃ…ÂƒÂ¯Â¦mwÄŸ@mÂƒÂƒlÄŸkklÂ±@kÂšUk@Â¯Â±Ã‡Â™KÂƒÂ—kxlÂ¤ÂbÂ™Imx'],
                    'encodeOffsets': [[
                            106099,
                            29279
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5111',
                'properties': {
                    'name': 'ä¹å±±å¸‚',
                    'cp': [
                        103.5791,
                        29.1742
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@kÂšVÂŽkÂ„ÂšÂšÃ†kÂšVÂ²UlÂºÃˆIlxÂƒLXÃ¨ÃœlUÂ„Â„XUÂ‚mkÂƒbVÃ¨Â„xÂ°@Â„Â@Â¼Â°Knnn@mÂ˜Ã†IUbnJ@bVIÂ°bÂ°Â±@ÂnK@mVakkÂƒKlÂ¯nbÂšmÄ¸ÂÂ„Ã¨l@VnÃˆlÂ‚UUwÂ„wmwnmÂ°Â¥Â„LÂ„Â™lLnÂU@VaÂ™ImbkÂƒmKÂ„ÂÂƒÂƒnk@mÂƒbÂ™ÂƒÂƒLVÂÂ„JVUUÂƒÂ„VnkVÂmb@aÂ¯JUaÃ†kkÂ¥Â„IWÂ¥Â„KlwÂ—Ã‘mÃUÂ¯Â™kVyÂ¯Â@ÂƒÂƒ@mmnÂÂ™UkmÄ¡Ã¨Â¯w@aUÂÂ±mnÂƒW_XKWmkÂÃ‡mUkÃ³bUÂÃÂUanmWÂÂ™ÂƒÂ¯nmaÂ—@ÂƒxVÃ´UV@ÂÂšb@Â‚lÂ¼Â„n@lÂ™b@xÂƒnÃ›aÂ›xÂa@ÂÂƒyUÃ…mUÃ›bmÂ°@Â„mÂ‚nÂ²UÂ°llÂ™Ä€ÃˆÂ¦ÂƒlUÂ„VÂ¼nJVxUzÂ‚WÂ„z@`mL'],
                    'encodeOffsets': [[
                            105480,
                            29993
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5113',
                'properties': {
                    'name': 'å—å……å¸‚',
                    'cp': [
                        106.2048,
                        31.1517
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÃˆÂ²VmÂšLnblylÂ²Â²UUlÂ˜Â°UÂ°Â²LÂ‚Â»Â„knÂlxÂ„_VÂŽÂ°@nnÃž`WLÂ°ÃˆUÂŽVlnkÂšV@Âƒl_ÂœJVÂ„Â‚@Â„Â„n@lÂƒnKVÂ£Â™Ã‡ÂšÂƒÂ„UVÂ¯ÂšmÂ„@laXÂÂ˜UÂ„Â‚UbVxÂ„@VkÃ´JUÂÂ°JnÂ™@Â™Â‚wUkÂ°wnÂUÂƒV_nJmknmmÂ¯VwkÂ¯Ã³Â¥Â±Ã¿Â—L@wÂƒÂƒÂƒLVÂUÂ™kUÂ›bXÂ¯mykI@aÂ±KkÂ¦ULmaXÂƒÂƒVmÂ¯ÂƒKÂ—zÂ±ÂƒklUIVbÃ‡JÂšÂƒkLÂ¯Â™lÂ™ÂƒUÂ™Ã¿Â™UÂƒlUÂkJÂƒUmÂŽUUkVVklKk@@aÂ™U@Â„Â™JÂ„Â²ÂƒxÂƒÂ¦kÄ¬@Â¼Â±ÂºXnWbÂ—xÂƒU@xÂƒx@lÂšL@bÂ„LlÂº@ÃˆÂ™l@bUÂ¦VbÂƒ@UÂ„Â™@XÂ˜Â‚bVÂškXÂ¯m@nÃ‡KkÂ„llknÂƒJVÂš'],
                    'encodeOffsets': [[
                            107989,
                            32282
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5119',
                'properties': {
                    'name': 'å·´ä¸­å¸‚',
                    'cp': [
                        107.0618,
                        31.9977
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VÂ„UÂ„lbkVÂšÂŽVLUÂŽl@XIÂ‚ÂŽUxVxÂšXklÂ„Â„@Ã¾ÄŠnVlÂ„IVxÂ„@VVÃÂšVÃžUVUÂ¦kV@Ä¸WÃ†Ã´Â²Âš@VÂÃžnÂš@VaÃ´bÂ²W@ÂÂ‚K@ÂXUmÃ‘UWÂ°Â¯Â°Ina@yÂ„_lWnÂ¼lLUbÃ´Â¼Â„Kla@Â™nkUyÃ´Â—Ã†xÂ°@ÂšÂnÂ£Â™Ã@Â¥mVkIUÂ¥ÄŠÂƒÂ‚Â¯Ã›Â»Â¯LÂ±w@Â™Â¯aÂ„ÂÃ‡aÂ²mÂ˜ÂƒÂ—Ã§Â›KXÂÂ„UWÂ›k_WwÂ¯WÂƒwÃ…k@ÂƒÂ™UÂƒÂ™kVmwÂƒKÂÂ£@mmmÃ…Â„mÃ‘kVmÂÂamnnlmIU`VÂ„mÂÂ¯xVlÂx@ÂšmÂšÂ¯IVÂ‚Ã³IUlÂƒ@UwVaÂƒÂÂ—VWÂ‚kbÂƒ@Â™nUÂ°ÂƒVÂ™Â„ÂšÃˆUÂ¤'],
                    'encodeOffsets': [[
                            108957,
                            32569
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5105',
                'properties': {
                    'name': 'æ³¸å·žå¸‚',
                    'cp': [
                        105.4578,
                        28.493
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VVXwVKnÂ„Â˜wnVÂƒnÂ„l@bÂ¯xmKUbVnÂ°Â°XÂ°@blLÂšÃ¨nVÂ„@VnÂ‚l@UÂ„LnmmUnaÂ„VV_Ä¶V@wnJÂ„Â„l@@kkKVÃ³laUwnJmÂÂ„wUÂlm@aÂšÂUaÃ´KVÂnJWbÃžÂš@VÂšwVLXÂ¥VVÂš_Ãž`ÂšwÂ„ÂWÂƒÃžÅ¹mmnInÂ¥WÂƒ@kÂ„WVÂÂ¯@ÂƒÂ°kIÂ™ÂŽÂƒLkÂ¼Ã‡@kÂ¤Â±XkÂ˜Â™nmÃÂ¯UlÃ…Ã›KWVÂ¯kÂƒlUwkLÂƒÃ“Â™@UÂ—@ÂƒÂ‚w@Ä¡XVÂ„ÂÂ˜WXÂ„Âš@UbVbÂšÂVÂ›Âš_kÃ‡VÂ™lUÂ°lnwÅŽÂ¦ÃžaÃ†Â¯nmmÂ¯ÂšUÂ„Â™mÂ¥nkVmkÂƒl_Ã³Â¥Â¯UÃ‡lÂ¯@Â™ÂƒÂ™LÂ™kÂƒ`Â¯ÂÄ·LUyÂ¯@mwÂ—Â¼Ä·Â°Ä¡_Ã…Â™UÂ°mlÂšnÃ‡VUÃžÂšÂ„@Â‚ÂƒÂšÂ_ÂƒJUnVÂ‚UXÂšblÂ˜Ä¢b@x@ÂmÂšVÂ°Â—ÃˆÂ‚b@Â‚ÂxÄ‹@ÂšÂš@xUbkLWÂškL@ÂºÂ„zVÂ‚@ÂlxÂÄ Â±Â²'],
                    'encodeOffsets': [[
                            107674,
                            29639
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5101',
                'properties': {
                    'name': 'æˆéƒ½å¸‚',
                    'cp': [
                        103.9526,
                        30.7617
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â°nÂ°mÂ²Â°ÃœUÂšwÂ²ÂŽÃ´ÂVÂšÂ°ÂŽVÂkxÃœÅºUÅ°ÄŒbÂ‚ÂŽÄ¢ÂlaÃˆLÂ„Â»ÂƒÂ@kÂ„wVÃ‡Â‚@Â„ÂƒnÃ›Ã†Â»ÃˆÂ™UÃÂ°Kl_Â„VÂ°UÂš`Vbn@VbÃˆLÂšaVU@ÂÆ¨Â»VÂ™nIlÂ™ÂšUUaÂ„Â±lIkÂ±Âš@VÂnKmÂÃ…@WaÂƒKÂÂ¦Â™lVÂÅÂškKÂ™ÂÃ@maXÃ‡mwÂ¯IUÂ‚@kÂƒVÂƒwUmVIÂƒÂƒÂƒÃ§Â—Ã¿ÂƒUÂ±ÂŽÃ…@Â¯Ãˆ@xÂƒK@wÂƒLUbÃ‡KÃ…Â@mÃÂ£@yÃ³UÃ³Ã³UxkI@WlIUaÂƒbÂƒaÂÂŽVÄ€Â™LmxÃ…aWÂƒUnÂVÂƒÂÃXUÃ¾Ã†Â°UÃ”ÃˆÃ†@ÂÂ±ÂºÂƒLnVVÃ’kÂÃ³Ã†'],
                    'encodeOffsets': [[
                            105492,
                            31534
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5120',
                'properties': {
                    'name': 'èµ„é˜³å¸‚',
                    'cp': [
                        104.9744,
                        30.1575
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„Ã¨Â„Â„UJVnÂ„xÂ„U@lVÂÂ°JnxWÃˆnbÃž@ÂšÂŽlLÅŽÂ™UÂÂškÂ‚Â¥Â„LXbÃ†@nÂŽmLUÂ‚@zlbXmlnVynLÂ„Ã§ÂšJVbÂ‚UnÃ³mUnamUÂ„anÂ¥lKV_Â²aValWÃ´Â„n@nÂƒÂ‚bVÂÂœKÂ°Â¯VblW@kkÂƒlUnlVÂ£Â°W@wÂ„UXkÂ°KVwÂƒmVÂkwVyVI@wkmÂƒVÃ…_Umm@UÃ¿mbkÂ£Â™xUaVwÂ±VÂÂ¼VÂ¤kLWxU@UkÂ™bÂƒyÂƒXÂÂšÃ³mÂƒÂ°V@@zÃÃ’kKÂƒnÂ™Â±U@@_VVkÂƒÃ‡aVwnLWaÂlm@@kkVVlÂ™Â¦kIV`Â±n@wÂ„KÂƒÂƒkÂ²Â™aÂƒVUUVÂ¤Â™nkxmUkVWVnLUbVbÂƒ`kUUÂ„mLUÂ‚mX@`Ã…bÃ‡ÂšXbWLXÂŽÂ›n'],
                    'encodeOffsets': [[
                            106695,
                            31062
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5104',
                'properties': {
                    'name': 'æ”€æžèŠ±å¸‚',
                    'cp': [
                        101.6895,
                        26.7133
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„bÂ‚KÃžnÃžÂ™@xÂ„V@xÂ˜nÂ„UnÂšÂ°Â¼ÂšVÂšÂ±mÃ§Â²ÃÃ†@ÂšwnnÂšVWÂŽnÃ´n_@Â¥Â‚Â™UaVÂƒÂ„bÃ†Â™ÂœÃˆÃœÂŽnÂ¥Ã†ÂÂÂ±VÂUwVÂƒmÂXÃ¿mLkalÂ¯km@kÂ›Âƒ@ÂƒÂ¯bkÂšVxmVUkk@Ua@Â¯Â˜Â»UÂnÂ›mÃ‘Â@mzÂ™m@Ä«ÂƒÃ‘XÂ¥Ã‡Â@ÃÂ™xUÂ¦ÂƒÂšÃ…ÂŽÃ‡Ukx@ÂšlbÂ„UWVXÂ„mV@xÄµÄ–Â±@@ÂŽÂ¯xUÂšÃ†LnÃ†mÂ„Âšx@nXLÂ±lUUVwÂKWak@WxkbÂšÃžÂƒÂŽÄ‰bUn@Â‚Âƒ@@xÃ³Â¦Â„ÅŽ'],
                    'encodeOffsets': [[
                            103602,
                            27816
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5114',
                'properties': {
                    'name': 'çœ‰å±±å¸‚',
                    'cp': [
                        103.8098,
                        30.0146
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„ÂšVxÂ°Â¦VanJVnÂš@Â„bÂ„aVbkJ@XlJVwÃ´Ã´Ã´V@zÃžÂ¤@nÃ†ÂŽÃˆLVaÂ„K@xÂ„L@wÂ°Ã‡Ã†@Â²ÂÂ„VÂ˜Ä€ÂœmWÂXKWaÃˆÂ™Ã†a@_nWVÂnKVÂƒlVÂ„_UaVamKXUWwnmmwÂœÃ‘mÂ£@ynUÂƒkWÂƒÄ‰UkWVkkVÂ±Ã§kJmÂkKÂƒÂšÂƒKÂ¯Â¦mnnxÂƒxVxÂVÃ‡kUmk@ÂƒÃ§Ä·ÂÂ™nmakÂ°Â„LllUb@nmL@Â‚Â¯Â²Â¯aUJ@amIVaÃ…JnÂ—m@mmÂ¯L@Â»ÂƒÂŽÂ¯@ÂƒwUÃ§Â„anlVÂÂƒWVÂƒÃ›kWÃ§Â„KkwÃ‡JkÂ¹Â±VÂ™UÃ…lÂ™Â™Ä¡VÂ™Â²ÃˆÃ†Â‚nXÄ–V`UÂšÂ°aÂ„bÂ„Â£Â˜lÂ„kVVnÂ¼mVnbÂƒÃ¨Â™ÂšÃˆnÂ°Âš'],
                    'encodeOffsets': [[
                            105683,
                            30685
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5116',
                'properties': {
                    'name': 'å¹¿å®‰å¸‚',
                    'cp': [
                        106.6333,
                        30.4376
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„VlIVÂ‚Â„kÂšVÂšÄ€Â„VkÂšÂ°ÂšlKÂ™Â„ÃˆIUaVJlkÂ²Â„Â˜yÂ„LnÂ°Â„UWÂ„nbVKlÂ¥Â²L@blJnzWÂ°ÂœalVÂ°InÂÃ´Â¯Â‚KÂ„kÂšKkkÂƒbVÂ™ÂšmÃ´LkÃ©ÂƒwVk@KnnÂšWlwn@laXLÂ›ÂŽnXVW@XÂ°a@Â„XKlÂÂ™ÂnwÂ„@manÂ™@wÂ‚@na@Â„Â„@ÂƒwÂ™Ä•Ä¡Ä¡Â™wUÂkUWb@mk@Â™Â¦ÂƒÂ¥mUÃ›bÂ±yÃ…n@bml@ÂkV@Â„ÂƒlknVbmVnlmÂšÂ—bÃ‡kÂ¯bWyk@V_UamJ@IÂ—@WaÂƒVXamIVWkUkbVaÂƒUUxÂƒ@VnkVUÂ¼Â›bkKUxmKÂ™Â„Â@WÂšÂƒxnV@n'],
                    'encodeOffsets': [[
                            108518,
                            31208
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5106',
                'properties': {
                    'name': 'å¾·é˜³å¸‚',
                    'cp': [
                        104.48,
                        31.1133
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nUWÂ¥Â²Ã©@ÂÂšKÂ„Â¥Â‚UÃˆÃ…Ã´a@VÃ†LUxnKlÂ„Â°ÂVÂ¥ÃˆmlÃ…ÃˆV@Â£ÂƒWXÂ¯lLlÂn@UÂÂšÂƒVÃ…lwUmÂ²UÂ‚VVÂna@Âƒ@KnbVÂ™VwÃ†ÂƒÂœIÂ˜mXwWÂƒkIVwÃÄ•ÂVUaÂ™IÂƒÃ¨mKUzkmWnka@yÂ™@lÂ²kJÂƒÂ²VbÂ™VkÂšmJUÂšÆ§Â¼@ÂUVÂ™bÃ‡KUam@UaÂ™_Â¯VÂƒUk`Â¯LVÃžÃ‡ÂšÃ…Â¼mÃœÂƒÂ„Â@UÃˆÂƒx@lÂ„ÂÂƒÂ¼Ã‡KkbWÂŽÂœÂšVxUbÃ†Â¦nxÃ†Â¦ÄŠV'],
                    'encodeOffsets': [[
                            106594,
                            32457
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5110',
                'properties': {
                    'name': 'å†…æ±Ÿå¸‚',
                    'cp': [
                        104.8535,
                        29.6136
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â²Ã¨lUUllXÄŠVXÂ„Â„lmV@znÂ¤Â›Ã’nxmnXxlUnVlwÂšmUÂ£VVÂ„UÂšblÂ±Â„Â„ÂƒL@xÂ²mU_lJÂšÂ¥UklU@ln@Â‚kXbmKUxÃˆblÂ„UU@`V@ÂšÂ²Â„mlLÃžÃ‘@yU@Â„Â¯Ã´nÂ‚Â™Â„WÂ„zÂšaVlV@XwlKUÂ£Â‚Â»Â—aVaUwm@mwUVUwkÂƒlÂVÃ‡Â²LlÂƒÂ„KVÂ™m_@yÂkUmÂƒ@mUÂ™Ã§kKmxkIUÂ‚ÃÂ„@LUJ@nÂ±Â„kÂºÂ‚LXbÂ™Â¼@mmIXaÂ™@mamnkWÂ™ÂÂƒKUÂƒÂƒxÂƒ_U`UklwUwÂ™mUbÂƒVÂ™Â²ÂƒakbÂƒmkn@`Â„UmÃ’Â™ÂšVxUbÂ™IÂ™`UÂÂƒaÃÃˆ'],
                    'encodeOffsets': [[
                            106774,
                            30342
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5109',
                'properties': {
                    'name': 'é‚å®å¸‚',
                    'cp': [
                        105.5347,
                        30.6683
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÃžÄ–UxlJXÂ„VbÂ°@Â„xUÃžmbUxÂƒbXbmÂ¤VX@lkÂ°ln@xÂ„bÃˆ@lLVlVUXxlJÂšÃ§Â²UlwV@@UÃˆWlÂ™Â„LÂ„w@wÂ„VÂ˜wXaWmÂ²Â¹@Â»lÄ«Â„Â¥Â„wÂƒÂ±ÂšI@ÂƒÂšV@bl@kLUllUVVnÂ@mmUÂ„wXÂ™Ä‹bVbÂ@VUkbmamÂšÂW@kÂƒa@Â™Â™k@ÂƒlaUaÂ™@Â¯b@ÂÂšmmwÃ³@@lkXUaÂ¯Â°Â›LUÂ‚ÂamÂ„m@Ã³ÂƒkXUbÂ±bU`kLmÂ¦ÂƒbnVmbnVmÃ´'],
                    'encodeOffsets': [[
                            107595,
                            31270
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5103',
                'properties': {
                    'name': 'è‡ªè´¡å¸‚',
                    'cp': [
                        104.6667,
                        29.2786
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lIÃžÃ‡Â„bVÂŽÂš_ÂšJVaUwÂšÂ™nÃ‘ÂƒV@_lmÂ„nlaÂ„bÂšÂ±Â„UVaÂšnVxkxVlV_Â„`Â„wVÂ„Â„LÂšÂlXnmnbÂš@WbnJ@nÂšÂ»WaÂKlÂ¹Â²Âƒ@mVI@KÃžÂƒVÂlJnw@aWÂ¯Â¯Â¯UmVanLÂ°w@aÂƒkÂ„mmUÂ—xmÂƒULWxUUÃKÅÃ¨UÂÂ™KUÂƒÂƒkÄ‰KÂƒL@Ã†nX@xÂ™Â‚WÃˆÂ¯@Ã›Â»Â™nÃ‡ÃœÃLka@bÂ™KÂƒnUaVmÂƒ_ÂƒxkÂÂƒLXÂ¦ÂƒJlÂ¦Ã…lVbÂ°I@bnaUÂŽmlÂƒUVÂ„UVÂƒIUÂŽÂ„KÂšÂ„Â„a@nmlÂ„Â„ÂƒÂŽnLlÂ„naÂšJUbV@'],
                    'encodeOffsets': [[
                            106752,
                            30347
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/tai_wan_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [{
                'type': 'Feature',
                'id': '7100',
                'properties': {
                    'name': 'å°æ¹¾',
                    'cp': [
                        121.0295,
                        23.6082
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@\\sÂŽ@pSÂ}ÂaekgKSuÂ™ÂSsMÃŸ`Â¡CqZÂ·be@Q^o@Â‹gieMpÂ‹Â‰]}Â•}Ä½c_KkÂ…{Â™Ã¹Â“ÂAÂ¡rÂ‰[uom@Ã‘ÂÄ¥JiqÂ©mÅ‰qÂ¯Bq]Ã™YgSÃ¥k_gwUÂ­isTÂEÂ…Â“ÂÂ‘Ä•iqiUEkuÂe_Â‰OSsZÂ‹aWKoÂ¡ÂÂ­qÂ“ycÂYÂ£w}Â‹Ä©Â™Ä•SÂ§ZÂ©SÂ™NÂ¥SyLÃ‘Â¡Â±Ks^IYÂ‰PdÂƒY[UoÂ†Fp}Â´\\Â¬\\j]ÂˆeÃœÂÃ²Â‹Â¤Â¡Â–ÄÂ a\\bnÂ™UÃ£ÂºÂ¹ÃŒsÂ¼jÂ®[cÃ­ÈˆEÂŽÄÄ†`Ä¼fÂ¶ÂŠÂ®K|VÃ˜DÂdKGpVnUÂ‚FjpHÂ—F`Â†BÂ’[pMÂºxÃ–jbpÃŽxpÂ€Â¬Â‚|ÃŽÅ¸ÃœÃ’CÂŠÂ²Â®Â‚ÃœApÂ„ZG~Â€ÂŠdÂ˜ÃžÃ VÂ¨|Â¸Â€`|ÂŒÂ²tx~\\~|dFf^zGÂ€Ä„ÅšhÂœdL\\hÄ¸ÂžÂ¼Â†ÂŠOÂªPÂ®lV`p\\]XpllÂ˜Ã¦Â¤ÂœCpQ|oF}fMRiÂ†NSon_Â²qÃ¤mÂœMÂ„NMÂ‹\\Â•'],
                    'encodeOffsets': [[
                            124853,
                            25650
                        ]]
                }
            }],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/tian_jin_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '120225',
                'properties': {
                    'name': 'è“ŸåŽ¿',
                    'cp': [
                        117.4672,
                        40.004
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@EUDAEI@WNMNCBFAHFFNACDJDPBD@@GD@DIFFHEFGDBDEQOFG@EI_KG@OcJQM]RMEKBGPG@[LaCIICBWKÂCEEG@WBQHCDFD@HSLEJI@IHWECFGAAEKCGDBFCBSBIDCKKHEADMJMFABKOKEQAA@IEEG@GIQAEK@OZEESMOLÂ“lu@SLUTYFQCMG@@SQUAYKAACA@IB@BDB@B@DC@@BGAEFAA@BEGKJCC@AGAIHA@@JC@QEIP@@A@EGIDC@O@C@@@@CJCWKABFLBBEBSQGBAAMIEM@AKBcJEN@BEBCFMAEFEF@J@BG@BFABECKFG@AFQ@@F@BEB@@A@@AAAKAE@GFGDECEFEECBKIKDELDFEDYH@EIACDCHKBEB@BAAC@ADBHABKJIAIJICEDGDCD@@A@A@DHCHJHDFEFGBKRKBGIK@GIMHSBCH_BOJECCJCFKKMD@DNJEDEGC@OJCJHRUL@HRJ@H[DCNKDZHCTFDHCFFKR`TANVDFZRDLFARB@HPAPG`ILAR@TERNDFNHDLCLDDCXDYbHF@FEB@LDDVE@JPNfXPINCVDJJD@NJPAJHLXHDNANHhB@DPNLRMTBFRBHHr@`NBFEBOCCBIAQJDHCHLHFA@HSDCRLFTB@HEFLNF@PELBDJALFLTC@EPFLLP@tUHQJDfIHGTB^JTCPDLKAIBATFPADIEGECEMJ@JIAIHGECFEAGDI\\SPOXAFCL@BQTQBBTMZECYGAHA@GJAE@HCAEME@IECFKJADDBABLTHHG@ILEAMNDJCDHEBF@@JNFJELDFKTOT@JETBFFHBHEHKI@@IJEJ@XKEOUMS@AF@CEB'],
                    'encodeOffsets': [[
                            120575,
                            41009
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '120114',
                'properties': {
                    'name': 'æ­¦æ¸…åŒº',
                    'cp': [
                        117.0621,
                        39.4121
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@FWÃ´Âµ@IFCLIB@EHNBp]AGEAKAEDMGZKFGBGME@ILGP@HEFB@BXMEAHUGC@IHCLOD@X[NWHWPKAEF[@EKIOL@EKGBNMJ@EIEHKBIC@BAKMIACCFQZCF]DB@ERAKADIHGEIBCGIIECFaGLZO@EFCNGAGDGAKL@BMG@IE@ADSDEH[JGC@CGA@BMDeK@EIACFE@@GG@FIAMM@CCGC@EM@ADE@CFMAAGHBDKIEAJG@DOGCDEKAGIS@KFCHKAEHIE]BeKNO[IFIOELC@A]GMBKVYCDDgGAICARc@MW@AQE@DGI@@AQ@@BKBAIQQYEFW@CEADIGGBCEIiMEMF_LGEKMBBDWEBGRC@E_CHYGCH_IAED@FFBQh@FGJaJ}AHRAREF@bE\\C@CT`FHC@\\BBF@BID@HGDDJ@@FAHKBARECKDAZBJIVNHCTA@EREAMLHDAFFBVFFC@RNRETHD@FOJMACH@CAB@P@DF@@FGDWE@FFSIEMKQDYCCHKb^JADOCIDGNDBdBCFJB@EC\\A@BJEA@JAAAD@HHD@LFBCFF@BERDHNhZQHMBGHOACCEBWEGD@PSJKCGEUD@CINLFGHE@AJK@HDABBHTB@F`DBFLBBHEDARCFG@ABJBAPVFE^FBGLGCFG_BMLEXGAAFE@@JNRVJHFALFBEHQJCTbNDHCF@PlFLJSXCHFHfVBTNJ\\BPJXC^FAVNFCHFB@FFH@JF@\\ABCFD\\BDMCAAJKQBGAILOEGHILECQLWFENJHADC@QxNHFJNLDFA@CBA@DÂ˜UÃ‚mR@FBL@BD'],
                    'encodeOffsets': [[
                            119959,
                            40574
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '120115',
                'properties': {
                    'name': 'å®å»åŒº',
                    'cp': [
                        117.4274,
                        39.5913
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@TZbB@JHD@DODCLM@AP@LL@BNH@ETFN@`E@DNG@CHLBCJA@AICFKDDBKA@\\N@AFNAGRBFjFFFL@DHLBLFQPcXAZMJ]GAVHAIZJFNE@JpDRRDCLFDGXA@EFF@CFFPDfEBDB@DCHCFCJDJIJBLI@I@CB@@ADBB@FALADGDC@@H@BB@FZGFCCE@@FMLALJDAFFFEFDFCB@@AHCF@L@@BBB@BB@FC@E@@R@BEL@HEFD@G@AH@AIB@@@FEFEBALDDEFAFO^IF@JCBBFPNJJ@D@PRDCEKBAXL@BIFD@T@JE@BHHJORFDI@@B@JGH@@B@BDDLIFFHCD@D@DEE@BAAAB@DAF@B@H@NGLJLMRDNMfGIEPMI@GDAKK@KIDIJ@GE@CFDN@FE@GFEPGV@TCDFKHBBF@RW@DD@@ID@TJFKIKLI@EP@IGBCLAEKLEN@KSHIGYACSD@SEAMBBMGEBMQBCMIGKFB[D@HDLPHDBC@IFITDLG@IIIFGVBNJDLN@VIRI@YIAIHIC@CLKZCBEE@JECEIHEAKGDGECBGEEM@@DA@CCCBBEGA[GEDBBoNAAH]MKiIAWKQoIIPMFQAEEDMH@FMSUYIeF@EK@BIOEKJEBICFKaKPÂFAFSE@LWCCFMHDDEKESBOGBKIEIODLG@CCDEQCEDWEMDIEIB@EHGEEDAEAa@@HqDEJGF[AECCFa@WCEIKAAEQB@FCAE^YDERDDJBLNABD@AJGLJF@FNIAMLH@FPKLJ@FE\\BFOLGXMXW\\C@KPGD@JHDGVFBWN@AEAGFO@KH@JNFAHEHYLNHFCLBFBBHo^MAFGA@KJED@JÃ³Â¶EX'],
                    'encodeOffsets': [[
                            119959,
                            40574
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '120223',
                'properties': {
                    'name': 'é™æµ·åŽ¿',
                    'cp': [
                        116.9824,
                        38.8312
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@NGFMDATCNDR@CCbINEHNJA@C\\EEGVE@IhEÂ–[Â˜wÂ”epcÂ¢Â·Â²Â›^QEKIEKIgiQDkehYÂ£uSDBMkUDOJDHC@GF@CAFBFEN@CÂ‹Q@BeP@@G@HD@@MHQKi@[IGCOCESE@GMA_OcCGDu`aÂˆ@VZzKDkJBLNXGDqKEWE@cFEFA@ÂƒISIi@@KMABJGBcMuFEzGVH\\ATSEUBeAÂLCEMG@CEBUHUCGXaBPtUBBFIBFTDFF@DDKBFNGBJPHXDDMDCLJ^mBIHIL@LR\\@LCR[@@z@NFD@LLBNb@RHDBNTPT\\F@BJF@BXCFBHHBDLFB@HODADE@@JHVXCPDHCFTLBBFNCDCCCU@@GAABEHHZHBCAEdEjFDD@GfD@DXFCHF@ERFDLBH@'],
                    'encodeOffsets': [[
                            119688,
                            40010
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '120221',
                'properties': {
                    'name': 'å®æ²³åŽ¿',
                    'cp': [
                        117.6801,
                        39.3853
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@BFLBFJXDb@DEFD\\BHEFIrC@Gb@FBCBFFGH@FJAJFNCXFFCRDCFDDH@CKJPJFALPHTALFCFGCENDDKXF@ETEBOÂ‚bLELJDFALIPFAJL@@FfEZJTVENG@CNFFRBNEJOpJLRBXjJNLG^BBpMAAFC\\HHBAFDADDB@@CN@FFAHFDCHLHFBJGFCFUNKJJTD\\XUXF\\^F@DDDQXXBRLRCBDFEVCDLVDpUl@LEDJHAPRFGL@CETGPBTCDDVI@CFF@GFDCCVGLKEK[Y@MECISG@BKNSCGCKWEAaEBEKNGFSECO@GGM@GYI@DÃ…CMLHPTF@DJHAVVNKEGDETJ^[TJNNd@NOAMFYJ@@GFANDPEJB^aOadSTQSI@MHBDIEOKCG@EEFCKCqXO@@DMFENCDDHCCGJ]AKFoDaGGHYFDHKJiCMFGC@EQ@AEHGAC@IEAATKOHGIC@IXIFEoÂƒGE[JCFCDHNmRADFZMF[EEBMO{GU@AOW@@]ZeHBDEHBKEfQkuIWBsÂ‡@EC@d[@[^EDMTKCEEcI@cDAB@FCBCACmOCG{PYHeBgPwPFDDALFFFCHQGSD@BHFAR[TaFYXMASUiGFL@DQNCJI@@D@PLDN`ETEFIGMCGBCEÂ‘~CAIFDPEHGEQPHJADFJGHCJLB'],
                    'encodeOffsets': [[
                            120145,
                            40295
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '120109',
                'properties': {
                    'name': 'å¤§æ¸¯åŒº',
                    'cp': [
                        117.3875,
                        38.757
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@JFFLÂ°_`ONJKDDFIFZNÂ xlb~yFVNRÂŒrdJGzDPVFBCTNND\\UR@E`F@@Ip@IWGUoawOEE@ÃDgK{Ä°EEMFÃ«CÂ—bÂ…Â™@Â—KwOCDHHKBDJCDEEEAGHOABFABMCgDLSQ@CFEBÂ‰MgYIDQINE@AUSwSAdYEHQMEyK[KI@GRMLE@@OqOoBOnpJ@BmEAFHL^FDB[C@BBDVFAHFJENB@sNEjQAMYsUgCSBGDJH@\\LjGR@NC@@G@HO@AfR@DÂŒM@EFEADBE@@HGDICCPlVANTCÂ¤vgZlfRChjLJ'],
                    'encodeOffsets': [[
                            120065,
                            39771
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '120107',
                'properties': {
                    'name': 'å¡˜æ²½åŒº',
                    'cp': [
                        117.6801,
                        38.9987
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@|ODHnPBDADEDA@CB@ddJFFLDNSFC\\]\\@@cFDÂˆ@nACOMW@M@ITURBRZNHNWRQÂšoOÂ•jÂ½fÂ‡cqÂŸAqeiDÃ¿ÃyÃ“Ä¯FL|Ch@ÃFFxPpbHVJXo@@JCTR^BPABQA]^MB@bE@@FQBFVJRH@FXtPNZSBAja@@NÂƒDTÂŽLJrQTHFXZFB`'],
                    'encodeOffsets': [[
                            120391,
                            40118
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '120111',
                'properties': {
                    'name': 'è¥¿é’åŒº',
                    'cp': [
                        117.1829,
                        39.0022
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@LHAHRHATh`LHNHDG`HDGZ`D@FQDAHXFACNAFLVRTBFOfHDCVBFQH@HSXHEPFB@LDBF[bDbLFKJBFLADBDjLvCPEI]FGEIGCBEUSjcFiBIVWfaHCjN^HtwBBFGPBJGjFBEGECGDONMFAP]TDHQOWCMGAMHKIJEIGQ]aDlUG]VGEGDCÂ„{PEbBZmE@@GH@BCA@FMQCFMYMJECELCMI_PÂ¯`]RÂ±ÂœÂ¡Â¸odÂ“fÂ—xÂ•\\gF@JUFFH[F@DIBGMMFaJDDQ@MCSDCBENMH'],
                    'encodeOffsets': [[
                            119688,
                            40010
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '120113',
                'properties': {
                    'name': 'åŒ—è¾°åŒº',
                    'cp': [
                        117.1761,
                        39.2548
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ROHFFGCOJEDBÂ’}DFHANDJHFEFSM_KC@O@CJ@DIRM@CEKKAÂ…LÂ…FKACHoLSJSIBETDJaEIIE]E]K[MYUYQILC@GF[MGNKEK@A@BCWECAIFEFYAGFOMI[OFuDiKACBCEKIAELaKaCE\\CA@KEAFOWGGTG@ERUACDeGEPSAUQKHE`FNjNFJADHHCJFB@DEXZFRRBJLA@AR@@BJ@CHF@BRX@@NQdDBBJhHCCZDLUNA^H@BKDPFEJ\\JMPfL^AJFFGLBDGLET@HJLBCFHDCPH@BIJFCLGABHNBDEF@BCN@@FHDDDN@BNEJH@@HF@DEJB@FfLNC@AHB@DHD\\IFGTCBCF@@JNH@ALKHBHCHBDMFEP@KYbHDEJF'],
                    'encodeOffsets': [[
                            120139,
                            40273
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '120110',
                'properties': {
                    'name': 'ä¸œä¸½åŒº',
                    'cp': [
                        117.4013,
                        39.1223
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ZV\\N^L^FJFFJIbSCAFTJTIpKDGLBÂ†EÂ†KLBjHTVNBZWbE\\SBQGE@ATCRHDGEEKECBECxOhOfAZGA_YEEWSGqRKISÂÂ„C@Mb@BiTAMYsOEWG@IQEURA@EF@@acUOXQRYCUDCHDTEF[SUEgAYDcVGJM`iAWDWLQRMHUHgDsDBLHJFCFDFGHBFFVEAGHCJN@RJFÂ‡PIhBD\\FENCPWA@LFBAFHBEJUEARCDIAEDQBRNa^'],
                    'encodeOffsets': [[
                            120048,
                            40134
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '120108',
                'properties': {
                    'name': 'æ±‰æ²½åŒº',
                    'cp': [
                        117.8888,
                        39.2191
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@LMEI\\MTABKN@FCDMH@COAcH[AoÄ“AÂ™MÂ¡Wa[MeqÂÂ™pQRMXMGQYQASV@J@NNXDPmBAtJXlveRLFGACFGAYf@^X@BPV@|HNPFA\\FNEEYBCnQGMDCDE\\IHFpÂ„EFWJ@JJDGHLPBSFB@JBDGHBFR@@FHDNEjDLICGZEHGbHpCLE^BHIDDCGDCFMNE@CP@rWLDEDFFH@'],
                    'encodeOffsets': [[
                            120859,
                            40235
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '120112',
                'properties': {
                    'name': 'æ´¥å—åŒº',
                    'cp': [
                        117.3958,
                        38.9603
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@TLv@CNHFFBHGZFETNPhCVGNGRQXKXCjBN_HIdUZChBVF\\TFECSDGVCZDRQPWdVNA^]RBBAAOQ]DSE@F_Q@[VMCSMADUECOHycIÂ‹qMQEU}zkaÂŸwENRDENB@ADG@@HF@YnaAOFÂƒ|CDFHUHH^kVbCR^JHIFLJNGHBDNPXGRSCO^EBMNCPDHHFAFiEIHOAEH'],
                    'encodeOffsets': [[
                            120045,
                            39982
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '120103',
                'properties': {
                    'name': 'æ²³è¥¿åŒº',
                    'cp': [
                        117.2365,
                        39.0804
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@d@hZNFdcLYXKRCtCMOFSYEGHEAGEDMu@SKAAsx]GMTGt'],
                    'encodeOffsets': [[
                            119992,
                            40041
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '120102',
                'properties': {
                    'name': 'æ²³ä¸œåŒº',
                    'cp': [
                        117.2571,
                        39.1209
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ZBVFFIGABEEA@KXBDOFM[EACJgÂˆOIE@QIMGDBHUFEEGAEHECEDGIAKQDWLKZcdQPEP@FOFBJTJ@HNORJf@DBCN'],
                    'encodeOffsets': [[
                            120063,
                            40098
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '120104',
                'properties': {
                    'name': 'å—å¼€åŒº',
                    'cp': [
                        117.1527,
                        39.1065
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@NMVDCG\\E^B@HlB@YEDS@CÂ…HsNSiMGDebUXAJEjidVTAFHDFJ'],
                    'encodeOffsets': [[
                            119940,
                            40093
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '120105',
                'properties': {
                    'name': 'æ²³åŒ—åŒº',
                    'cp': [
                        117.2145,
                        39.1615
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@DBXFADB@L@LFHM\\NHED@JKZRb]QMRAFCJBDCBQYADMCAe@QIMP@GSIAIPE@E[EGH@ZEF]^HJAXK@KF'],
                    'encodeOffsets': [[
                            119980,
                            40125
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '120106',
                'properties': {
                    'name': 'çº¢æ¡¥åŒº',
                    'cp': [
                        117.1596,
                        39.1663
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@J\\PNHEZBFEJELEL@BWGI^]FEkA@G]A[FDHUCMNEHJ^'],
                    'encodeOffsets': [[
                            119942,
                            40112
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '120101',
                'properties': {
                    'name': 'å’Œå¹³åŒº',
                    'cp': [
                        117.2008,
                        39.1189
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@DÂ†T@FCHG\\FFOROMEgYc@'],
                    'encodeOffsets': [[
                            119992,
                            40041
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/world_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'offset': {
            'x': 170,
            'y': 90
        },
        'features': [
            {
                'type': 'Feature',
                'id': 'AFG',
                'properties': { 'name': 'Afghanistan' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@à¡ªÍ‡ÙˆÅÇ¬Ï ÚÅ¶Ó‚Ê®ÇšÚ¦Û¾ÇŒÆ€ÌšÐ†É£ÊªÒ´MÙˆÇ¯Ê²Ä¹ØŒË’Ë°Ç‹Ë–ÏªÔˆiÅ¼Å¬Ä˜ÍºÎ²ÌˆÒ”ÈÄÊ±ÊªÂ¡Ã½Û·ÍªËŸÌŠÇ°ÏŽÄŠÔ¼Ï–×‚Ã—à¢€AÆ¬Ê‹Ó§Ä¥ÑÆ¹à¥­Ä­à£—Ç­Ó«Î»È¤Î£ÄªÐ»Ð»Î›Â–Í‘É³Ì¡ß›Â€Í¦Ö‰Õ—É…Î¥Ô•Â²Ô‹Í¡É¿Ì³Ã¾ÙÅ‹ÄŸÉ»Ø³DÒµÓ‡Â‡Üàª¥Î“×‘Ã´ÇÈÔ‡Å†à ¿Å±à¶§Ñ–Þ€Þ€Ã¥Õ¦ÙÆšÃŸÕ”ËŸÚ¢Î¬Ò¢Î¹Å®É²Ø’Î‚à¨¸'],
                    'encodeOffsets': [[
                            62680,
                            36506
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'AGO',
                'properties': { 'name': 'Angola' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@È¸ØµÊŒÔ‹È˜Ë•ÍÑ¯ÖŠÃ¦Ë¤Å Ò¬ÅŸÅ²É€É‚Ó¨Ô¶ÂÂ®Æ¤Ñ–HÃ±Ì¡à§´RfÕ‰ÇžÍ•Å«Ô‘Ã–Ô«ËªÌ·Â­à§ƒÈ¼Ã¼ÎºsÔ´Å´Ï¦Â¹Ä˜Ê¹Ä©Ð¡Æ¨Ï¿Å¯Ì¿Ã®Ìáƒ§ZÂá¦µÖ¤Û‹ÕºÔ½à»³ÎáŽÅ ×‹Ð–â‚­Â—ÅµÃÔƒÏžÕ¯~Ô‰ÆÐ™Ç…Ã¿ÕˆÅœÝŠÌ‚Þ’ÂªÎ°ËšÝ¶È¨Î†Ó˜Õ¼ËÏÄ˜Ø¬Â«ÓŠÊ£ÌœÉ¡ÔšÈµÔŽÂ®Ç¨Ê¶Í¬Ê­ß¼Ç£ÖšÑÕÄ„ÇŽÎŒÅ”Ê’gÌŽÄ¸áŸœ['],
                        ['@@É‰Ä—É£Ù„Í¼Î´ÊªÆ˜Í€Ë½Ì©Ç¯ÆÉÎ»']
                    ],
                    'encodeOffsets': [
                        [[
                                16719,
                                -6018
                            ]],
                        [[
                                12736,
                                -5820
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'ALB',
                'properties': { 'name': 'Albania' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÅƒË·Å¢Î­Î’È³iÉ™Ë—Å§Â»Ë™Ï·Ð¡Æ›ÃgÈ‚Ò¯Ë°Ã±ÐÃ®Ö¶Å–Ê¼Æ—Æ‚Ã‰ËŒÎ¸Ð°Ã‚Æ¿É¨Ã´Ç´É¥ÈªÄÃŠÌ§'],
                    'encodeOffsets': [[
                            21085,
                            42860
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'ARE',
                'properties': { 'name': 'United Arab Emirates' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Æ¬Â¤ÂŒÉ±Ú‚Æ‚ÛžuÔ–{ÖºÖªØ¸Õ ÕŽÔ®Ç†Ë¹Å–Ú‘Ñ•GÃ§Õ³ÆªÅÏÇ‘EÎ…Ê“ÎuÍ·ÇÇ±á¡‹ÑŠÍà¡šÂÈš'],
                    'encodeOffsets': [[
                            52818,
                            24828
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'ARG',
                'properties': { 'name': 'Argentina' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@ß—Â§Ñ“Ì”Ô‘xà£‘@AáˆžÍ’ÏµÑ€Ø¿àª¨Ô‹à­²È¿Ï™Ð¿'],
                        ['@@Ó´Ø‡Í Ú°à¥ Â“ÆŠÇ·à»¶àµ‹ÛŠÅ·à¨†Ø§à¡¾Í¡Å¦Ï‡à ¡à±§à¡’É­à¤¼Å·Ú”ÆˆÞ‚Ù¢ÆŽÝÐ¶ÇˆÑ„ÓiÚ£Û»Ò©ÖŸÎà¥…à ƒà«­à¬§È½Ú¥É£à¡¹Tà ·Ç½È‡ÃÕ«Ã‹Ñ«à©¨Ü™Å—×ƒÕ€Î½Â§Ð§ß¯àªà°›Ò‰á‹Ç©à¤‰ÄŽÇ°Ô…Ç£Ø»ÆºÑ‰Ô‹Ìà¡±Å™ß±ÌªÍ•É—Åœà ³Ö¨Ê§Ò Ë†Ê¢Ñ§Þ›Ê»Ú­Ô¹Å«à¡‹È£Ò‡ßEÚƒÑ™Ê‹Ø¿à žØ™ß¦ÇË¿Ý­à¦³ÓƒÕ±à¦ŸÞÍ§Î…Ï¿Ë”à¢Ö”Ó¡ÎŸÂ¨Þ©Æ€áŽ“Å’Î‘ÓªhØ¾Ö“ÃƒÌÌ¨Ã³à¢ºÙ¤Ï†ËˆÕ’Ä­ÑŒÑ¾Ü”Ì¬à«˜Ä›Ó²Î¾Ç„Ä™Í„ÏµÇšË¢ÎœÏ›ÍˆÈà¥ºÍ¸Ç¢Æ™à¨€È à¡²É¤Ý¢ÔŠÌ¨Ê­à EÞšÙŽÕ¸oÛ°Ó’à ŽDÞœÉ“Æ¶Ï­à¸Ô¬à¡ºÃ¿à €ÌœÞ„Õ¼ß‚×¦ÔºÊ¥Í¢Ç¬Ë”à¶”à£¶Ð´Ì€à¢ŽÄ¹É‚Û¬Ýºàª¶È±']
                    ],
                    'encodeOffsets': [
                        [[
                                -67072,
                                -56524
                            ]],
                        [[
                                -66524,
                                -22605
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'ARM',
                'properties': { 'name': 'Armenia' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@à­žÆ€Ç¨É™ÍŒÆ£Ç›ÉÒ„Ë½ÊË‹Î¦É«Ï˜Æl×‹Ì£}ÎƒÓ¢HÅ¼Ï‡CÊÉ¤Ç©uÍ§Ê–Ø±È¼Ä„Ð¤Æ›Ì’'],
                    'encodeOffsets': [[
                            44629,
                            42079
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'ATF',
                'properties': { 'name': 'French Southern and Antarctic Lands' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Õ¨ËƒßÄ¿ÂˆÇ…É½Ï£à²‡ÃƒqÒ‚Å®ÎŽÃŠÇ¢'],
                    'encodeOffsets': [[
                            70590,
                            -49792
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'AUS',
                'properties': { 'name': 'Australia' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@ßºÌÒœÅ˜Ù¾ÇŠÔŽÃ‰Ãà¦½Ë½ÌÄ“Ú¯Ì‰É°××‘Ç§Â®Ô«Â€Ô­Ü˜Å—ÖˆÓÜ¸tÏ¬Õ¼Ãµ'],
                        ['@@Ì¢Ú‡Õ¢Í„Ë¦Î¡Ð–ÍŸÄ‘Ï‹Ç´Ü›Å¸Ð½É„Ä¹É¬Ü•Ä…Ñ¥Ë–Ö­à£¬Ñ­×¦Ð‹ÖžÎ»Å‹È¯Ó”ÕƒÍœà£§Í²È‚Í¾Î·È´ÅºÆ¢à¢¹×¬Ô©Ï¸Í‹Ú€Ú¹Ê€Ú­tÓÃ‹Ô³ÐÜ‹ÂµÝ“Æ¡ÏµÉ©Ý¡jÓ•Ç•×»Ï‡Þ‡Ø«Ð­Ì«Ù±Ë«Ð³ÊÜ§Í•Ð½É…Ø»Å‰×ÂªË‡Ó•Ì‡à¤µÂ‰Þ¡Î‡Ï«Í™Ô•Î­ÛŸÏˆÔ¥ÆªÅ¼Ñ¬ÒÇƒÝØ‰Ü©ÉªÓ‰Æ„Ó‘Ã”ß¿ÊÕ«Ô®Æ»Ù’È›ÑŒÐ­Í¾ß±Ä¸Ë¢Ð È¯Ø²Ð§×‰ÝÆ·Ñ®Ò¬Å¶ÓžÍ˜Ð¬Ã£Ø¬ÛÜ‘Ô¿Ë½ÍÚ›Ù½ÎŠ~Ò€Ô¿ØŒÑ¹Í€Ç‚È˜àªƒÔš×Ÿzß¯Ð¦àº“Äàª›Ìà¥™Ë«ß¡Ãˆà¢»Ñ™Ü¯È—Ç‰Ñ±Ì³Í¿Ü‰qÕ…ÃµÝ‘Æ¶×¿ÄŸÖ½ÂÔÒƒÊ•ÂœÑƒÊÐ—Ë‹Ø•ÂÖ›Bà¢½ÕœÒ‹Ç„lÓ–ÐºÅ˜ÆšÈ’Â‡Ì Äº×Ä£Ó¼Ñ»à¡–ÆÓ’Â˜ÓŽÍ­Õ¶sÊšÏ‹Í°Ä½Ú„Ó“Ú”Å™ÎªÏ„ÎµË³Þ¬Ð¸Ê‘ÊžÍ—aÑ˜ÐµÚŽÄƒË„È›Ê¦Ä Ó Ç¢È¸Å˜Ñ€Ä™Ó®ÎŽØ€ÃšÙ•Î¢×€Û€Ë¬Ð¦ÎªÙœÌ°Ï¤Ã É´Ä»ÚŽÌºÔšÄ¤Å¶È€ÉžÃ¼Ò¬oà¢¨Ê–ÒšÏŽÉŠÒ†Ó²ÑÂœÍ²vÒ˜×˜ÜŽÎ Ü©Î¦ÇšÌ—ÐˆË‚Ð¢ÏˆÇ»Ä¸Ù–Ò Ð°È®Í¨Ñ†Æœ`É¼Ï„Ä­dÉ‚Ï„Å¦ÐžÅ”Ø¨Ï«Ò²Ó½Õ‚MÕ–Ã¿Ç±Ò¦Ð”ÚªÏœÉ˜Å¿È¾ÎºÓ’Ô˜Ì’Ñ˜Ä±ÛºÇ‚eÑ–Ø›Ë¢Ò‚ÅªÖŽÈ»Ò€Î‡Û¼É‹ÊˆÄÔ¶ÊµÓ¬ÊŠÍ‚Ã±È ÇŠÏ¬ÐµÉ¡Ò‡Í‰Í»Ë¿ÂƒÄ®Í±Ê™Ð¿Ì—Ð­Ã”ÊÚœÒ«Ù¨ËÑ ÌØˆÓ»Ê‚BÑ°ÉÅ¶Ê·ß¤ËµÖˆË¼ÇÒŠÇ ÏŒÄ¾Ò¤Ê°ÚžÅÐžÃ”Ê”Ä«Ó”ÅŒÙ†ÇˆÇ Å½Ë¬È®Ñ¾Ç†Ò¦tÊˆÌ¸Ì¾Ê‚Ð©ÃŽÕƒÈ¾Ä·Â˜Î›Ì¨Ñ‘ÃšÓ‡Â‡Ì¥']
                    ],
                    'encodeOffsets': [
                        [[
                                148888,
                                -41771
                            ]],
                        [[
                                147008,
                                -14093
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'AUT',
                'properties': { 'name': 'Austria' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã›ÎƒÓCÇŽÇ»Ë§Õ§Ç‡Æ—Ü½sÑ‰ÈÛ›Ãžà®¯ÉÈ‰ÌŠà §Æ£Ä­Ç…Ô—Å¢Ñ•xÏÆ¶ÅºÈ´ÂÆ¬ÊªÂ²ÑŒÉ¹Å¤ÉœÝŽÂ•×¸Æ®Ð–}Ë€Ç£Ã¾ÆœÅ¡Õ¸Ì Å„Ì’Ï°Ø²Ë“Ó€Î†ÌÃšÙ¶Ê±Ð‚ÂªÏ°ÇÃ£ÅƒÄŒÌ…'],
                    'encodeOffsets': [[
                            17388,
                            49279
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'AZE',
                'properties': { 'name': 'Azerbaijan' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@ÊžÉ£ÏˆDGÅ»Î„Ó¡Ö½Å’Ñ‰Ï°ÆƒÍ†Çªv'],
                        ['@@ÏŠÃ‹ÆžÉˆÔˆÍºÑ´ÑµÑ’×­ÏºÂŸÊ¸É§Û—Ã£Æ£ÙµÆŸÌÌ­ÈvÐ·È½Â¥Ô»Ñ²Ì‚Ð´ÊÊšÌ¿Ã—à¦¯Ø¥k×ŒÏ—ÆÎ¥É¬Ê‚ËŒÒƒË¾ÇœÉ‚Í‹Æ¤Ç§ÉšÈ¶ÆŽØ¶ÊÒÂ¹Å˜Ä²Ð±Ò”É”ÅšÊ€Â…×€Ô™']
                    ],
                    'encodeOffsets': [
                        [[
                                46083,
                                40694
                            ]],
                        [[
                                48511,
                                42210
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'BDI',
                'properties': { 'name': 'Burundi' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ãà§¦ÉƒÏ¢ÔœÃŸÊ²ÓŽÒ€Ã…Â¸Í§Ç¸ÈTË—È¹Ç­Í›Ñ«Ì§Ì¥ÎÂŸ'],
                    'encodeOffsets': [[
                            30045,
                            -4607
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'BEL',
                'properties': { 'name': 'Belgium' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ØœÃ¡ÞªÇªÕÎ¿Ò¦ÈÄ§Ö§É•ÂÄÒ»Ü¿Ï¦Ñ›ÃŸ×“Ð†Ï·Í¶Ï·`Å©Ì’ÚªÇ”'],
                    'encodeOffsets': [[
                            3395,
                            52579
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'BEN',
                'properties': { 'name': 'Benin' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Û›Ä¯È¹×†ÂžáŠžÇ›Ç¦ÂÐ®Ì‡ÌŒÊ±ÊžÅ†Ñ¶Ì€Ä¨Ç Î¾ÐªÄ€È€Ê¤Ë®Ê˜Ì FÙ˜Ó™ÂË©ÈŽÓ½Ç“Í·Ä˜É§Ð¡Ô³ÊµÊ³ÇÕ‰tÕ—Âµà´£'],
                    'encodeOffsets': [[
                            2757,
                            6410
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'BFA',
                'properties': { 'name': 'Burkina Faso' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ö¹ÉÏ½Â‹ÌÉƒÏ—Ç°Æ¥Ë¦Ï™Ç¾Ã…Ó¦É®Î¤oË´ÚšÛ¢Å¬Ö¼É²È´ÐžÅ“ÎšÇ¢Å˜ÉŽÙ´Ï–Ç†Ë€Þ¼Î’Ò¦Å¢É€Ç‡Õ JÃ¡Ð¡Å”Ï£Ó€Õ¹Â€Ðà¥ºÈmÖ»Ç¿Ê£Ð©Ã¿ÇŸÎ½Ë¿Ä§ÝlÏ³Ã¢Ë“Æ‰Ï‰Ã–à¸£Â¡qÓ‰Å˜Ù…'],
                    'encodeOffsets': [[
                            -2895,
                            9874
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'BGD',
                'properties': { 'name': 'Bangladesh' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@i×½Ì‰Å¶Ã†Ú¯Ê‰Ñ¬ÂµÑ”Ç…ÐšÎ•Ó¨ÞŸÂ’Ã¼Î‹ËƒÒ³Î§Ç Å©ÆµÊƒÄ Í—Ã¸Å½Û–Ì…Ù„ÆœÔ’Ô«É¤È†ÌªÕ€Ì¼Ø…Ñ¼Ì”Ö®Ú–ÎµÐ’Â£Ã´×ßžÅ™Þª^ÓžÆ›Ï¯Ü…Ï•ÂµÊ·ÓÒ¢Ñ¥ÆŽÕžÉ¶FÑ¶à³¯'],
                    'encodeOffsets': [[
                            94897,
                            22571
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'BGR',
                'properties': { 'name': 'Bulgaria' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÊŽÎ‰ÍšÃ–Ù¦Å¿à¯¾Â«Ð¸ÉŒà¦¬ÈœØ’Ì©Ó´Ä•Ñ¥ÎÌ«×¹Ë”ÓÜ£Å’à¡¥ËƒUÐ»Þ…Ã¿×¡ÌŠÚ§É±Ø©|Ã‘ÖŠÑËÆ’Å¢ÄÄ´Æ˜ËŒÍŒË€Ð¡Î´Ã·Ì¬È¸È'],
                    'encodeOffsets': [[
                            23201,
                            45297
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'BHS',
                'properties': { 'name': 'The Bahamas' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@ÈµÂ£É‡ÓœÌ¿ÊÇ¾Õ”Ê¨Â‘ÌŽÛ£JÓ¥'],
                        ['@@à£·Æ…ÃÌ´Ð‚Ã¤Öˆ{~É•'],
                        ['@@ÆŸ×¯Æ·Å†`Ñ®Ï“ÍªCÄªÚÏ—']
                    ],
                    'encodeOffsets': [
                        [[
                                -79395,
                                24330
                            ]],
                        [[
                                -79687,
                                27218
                            ]],
                        [[
                                -78848,
                                27229
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'BIH',
                'properties': { 'name': 'Bosnia and Herzegovina' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ì¦FÈ¿ÏƒÐœÍ“Å«ÐƒÈ¡Â™Æ½Ã»Ë™È›Å«Ò¥Ý“ÍˆÍ…Î˜Í‹È„Ï­Ì¾Ç»ÊºÐ©Ï¾Ç¬Î’ÌžÈ•Ç¼Ç¨Ï¾nÜ Æ“×ˆ\\ÏžÈ…'],
                    'encodeOffsets': [[
                            19462,
                            45937
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'BLR',
                'properties': { 'name': 'Belarus' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ß¼Mà£°Í„ÈšÓ„ÛËÃ¿Ï”ÔœÆšà£˜Í–à¢®ÉÅ¢È»Ñ²Ä´à ’È§ÄŠÐÇ·É§Õ„Õ½Î‚Æ³Â»Æ±Ö¦Æ©ÊŽÉ¡ÍÇ¿Ú³ÂˆÇ‰Ã¿È Ë§È¸ÕÜÂ¹ÊµÈÃƒÑ…Í­Ä†Ý·Â¡É™ÈžÌ¿Æ¥ÍÅ¨Újà¤«È¬à¡•Ã Ù±mÒ¡É©Ð“ÂeÏÊ·Ï´ÔŒÇ¢LÍ°É·ÍŒÂ™ÏŠ'],
                    'encodeOffsets': [[
                            24048,
                            55207
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'BLZ',
                'properties': { 'name': 'Belize' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@OÅ®Ä¸ÂžÆ´Ä±ÌžÔ”Ç„ZHÅ«Ç„GaÉ­Æ‹ÎµÃ´Å»Ä•ÌÃ€ÄƒÄ«Ñ‰Ç“ÉŸÆ±Ç“Ì…Ê£@Ã à¥†PÚ˜'],
                    'encodeOffsets': [[
                            -91282,
                            18236
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'BMU',
                'properties': { 'name': 'Bermuda' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@OEMA]NOGNG\\Q^McMOI_OK@CQSGa@WNLVWHFLJXVFGJ`ZRTDLeeWKIHGIK@@[MQNi`]VDTBHCJAPBJLVFjT^LV\\RJZRn^RH`TfJjZHHOTTFJP_NOX[EYQQKMEJOLANJH@HQHAARF@ZEPS[U_IcRQXE@EEKKOCGGCQCOGISKYGUC'],
                    'encodeOffsets': [[
                            -66334,
                            33083
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'BOL',
                'properties': { 'name': 'Bolivia' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@à¥ŸÂ”ÍŸÚ¯Ó³ØˆàªµÈ²Û«Ý¹Ø…Å—Í¡à­†Ò‹à¤ºË†ß¾Ñ³Î¢ÅØ†Ð«Ö²ÕŒà£¢Î±ÛºÈ–Ë°Æ­Ì¶Í Ñ€hÜŽÂ¤× Ç¸Ë¶Ü©à´ Ø²Ã­Ñ nÈˆÊªÝ€Í¾Ñ¶Í‚àª¸ÆšÄ™Ø½Ä¼Í“Ã£Ö›à£°Ý«à¤´Æ‘Í¦Ì»Ö¨Ç•ÎÊ‘ÕˆTÓ¦ÊŸÂšÓŸÇÊ•ZÎ³Ê“aÍ’à¦à¾–Â“Å«ÓŸÄœÍ§ÒžÉ½È¤Ô¹Æ«Ú‹É¯ÏÄ„ÓÊ¿Ç¥aÊ¶Þ³Ñ˜Þ­^à¸±Ê“Ð•Ý‹sÒ‹Í¥à§•Æ‰Ç¸'],
                    'encodeOffsets': [[
                            -64354,
                            -22563
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'BRA',
                'properties': { 'name': 'Brazil' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@à«®à¬¨à¥†à „Ö Î‚Û¼ÒªjÚ¤ÑƒÓžÐµÇ‡Ç’ÓœÅ–Ó¼BÒ¦Ì¡Æ´Ì¿Æ‹Ì»ÂœÄ¯Í”Ã½Þ”Æ¿Ê¤Ö¥ÉªÎƒÇà¢±ÇˆÃˆà¬œÊÒ´Ë€Ç¦ÄƒÓÉ°Ï‚Æ¬ÚŒÈ£ÔºÒÉ¾Ä›Í¨Å¬Ó à¾•Â”Í‘à¦Ê”bYÎ´ÇÊ–Â™Ó Ó¥Ê Õ‡SÎÊ’Ö§Ç–Í¥Ì¼à¤³Æ’à£¯Ý¬Ã¤ÖœÄ»Í”ÄšØ¾àª·Æ™ÑµÍÜ¿Í½È‡Ê©ÑŸmØ±Ã®ÓƒÆŸÏ¡ÄªÃˆà±¨ÛÓ·ÝvÍ…Ò„ÖÂ¶Ç²Î°Ò±ÔžÎ“Ý´ÉœÆ¶AÎ¢Ô–ÊŽÄ‹Ò”ÉŠÌˆÃ”Ï¼à¥¦Ö²ÛŽÇŠÅ”Å´Ý´ÂŸÏšá˜°pÎ¸Å¿Ó”ÏÌ¬LØÓ€Æ’ÇšÄ“Â†ÍÓ¯Ä”YÕ€à¿–kË¦Ì‚É¸Ë‰ÇÓ·Ç‚Ä¼Ò¨Ñ»Ù¸Ã†ÇŒÊ²Ø´ÈžÎŠÆÄ®Î¤×¸Ê†Â¯Ç®Ü…Ã°Å›ÕŠÂ’ÖžÏ“É’Ç€Ã¾Ø¬Å…ÚœÈ¿ÊÈ¤Ø€Å¾à¤²Ì¾Ì®ÍŽÅÊ‚ÑªÂšÈœÈ—Å‰ÏƒÌ€ÅµÈ–Ï·É·ÌÆ…ÜÉŒÑ‹Ã”Ï³Ô¬Ï¿Ð®Â¥Ä¢Ç’Ë†Â˜Ï Æ¦ËšÉ¢Ò¬Ã­È²ÂŠÒšÃ§Ã¸Ç¢Æ—Ç˜ÄŽÊÍºÃµÐˆÄ’Ó”Ç±Î¾Ç¥ÊºÉªÈŠÂ•Å˜É¿Ð”Ã’Í’ÍŠÊ´Ø¤Ó¼Þ’ËºÂ¢ÈºÒ«Ò¼à¸½ÒˆÆ‘x×…Ù…Û•Ê¾Ê©à¹¤ÆÂŠà¡ƒÙ”Ö€à©ÌŸà¶ŠÔ¡Ð¨Ó±ÆÒ«à¦ŽÊ¶à¿Ñ¹à°´ÂŽà°”Ûà©¸à¤µÙªÊÜ–Â‘Ì¦Ë…Ë¸à©­Æ”Ô—Í¯àµ¹Ñ‘Õ·à®…à­¡Õ™à¥‹Ø«Ü¯È¿gÉ»Ø¡Ã’à¼½É¹à²“Ä™Ö…Ë‡Í§Æ«à«±à¡›àª±Æ›à¢Ú¹Î·ÈŸÔ‹à£¯Fà³•Í“×¡Ïà¤µÊ—à¦©ÚÜ…à ¯Å©Ø·Æ”Ò«Æ½à¡“ÈÐ§×—Ò¥à¤Ÿà¹•Ý‰Ú—Ö¯Ï½Ï¥ß›Ö‰Ó‘É·ÓˆÏˆÐŠÓŸÖ²Ú‡Ò¬à¡¹Õ Ì¹{à¡…Ù°Õ±Ä™'],
                    'encodeOffsets': [[
                            -59008,
                            -30941
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'BRN',
                'properties': { 'name': 'Brunei' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Í¬Ì¾ÜŽÒ¢Â›Ð¯Â·Õ›Ð‘Â€Ç­Ë¹Ï¥Ñ¦'],
                    'encodeOffsets': [[
                            116945,
                            4635
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'BTN',
                'properties': { 'name': 'Bhutan' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Î‚ËÃÔ©Û‡{Û¿ÃˆÕ‡Å¿Þ…ÍŠkÇšÖŒØ²Ò’Éˆ×¸È™ÑºqÏ€É¥'],
                    'encodeOffsets': [[
                            93898,
                            28439
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'BWA',
                'properties': { 'name': 'Botswana' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÇœÆ­Ë„Ó¡à¥Žà¤‡Î®ÄDÌ‘ÊšÕ‘Ù°Å¹ÕšÏà®‘Ø£Ý­Ø¹Ë©Ö“Ê§ÍÒ™Ã£Æ§Ð“ÄÊ½ÕÈ›ÛÂ¤Ð‘É¾ÎŸÄ¸Ð¥È™ÈµÐ“Ð‰Ê§Ð¿Ï‘×»Ä‘È‡ÌÃ¼Ô Ó½ßšÉ§Å²Aážšà ¤Âˆ|á²¾Ø´Â„à²–ÌŽÍŽÎÕœÍ¤Ê®DÓ‚ÈŽÆ°Ã™Í”Ú£'],
                    'encodeOffsets': [[
                            26265,
                            -18980
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'CAF',
                'properties': { 'name': 'Central African Republic' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÛœÃšÆºÉŽÆ”gÈ¾Èà©”ÍÎ¤Í Ñ¬ÌŒÄ‰ÌÊ‚Ã¼ßºÂ½ß†Ï´ØŠà£ºÑŽÍ¾ÕÆœÄªÎ«ÓœÔ¿FÎƒÆ‹Î“Ã„Ê»Ì†ÊÙ–Î¿Ò¢Í»TË—Ö Ñ«Î–ÎµÉ†Ô‹ØºÍ©ÆŠË‰Ë£Ä™Õ¡pÙƒÄ˜Ì¹Ã¯Å³È±Ë•}Í§Ç²à¤§Ð½Ï¥ÄŽÅ—ÃÊ¥Ô•Ø·ÇØ™ÄŠÕ—Ì´Û“Ë¸Ò‰Ë“Í›ÑÃ¹×“Õ£Â²Ö©Æ˜Ô…Ñ»Ñ¯Þ±Ä—ÊÂ›Ï¦Ï§Ë”Ì³Ñ Ã¯Ì Ð‡Ñ®Ã¦Ê¢Ä‹ÎžÃžÙ´È¬Æ´Ñ†à¡œ'],
                    'encodeOffsets': [[
                            15647,
                            7601
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'CAN',
                'properties': { 'name': 'Canada' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@ØŽÅ“ÞªxÐ¯Î…ÌµÃ…à©¥Î¦È¿Ë¬Í†Ê¸ÌŽÐ¡'],
                        ['@@Ð¥càªË‚Þ¯Ð†Ì„Ã®à«†Éà¡®Î—|Æ·'],
                        ['@@Ñ…Åàµ¡Ï¢Ê¥Ì˜Ý©ÌŒÆ¯Êˆà¡»Æ°Í•ÒœÃ°Èšà¢¨Ç¿Ô¨Åµß„Ä—ËºÌƒÐ´Ð‹à ¼ÎÎŒÒ©'],
                        ['@@Ö‰Ü¿Õ¸Ë´Ö ÇµÌÌ‰ÝšÉ±Ï°È´à ¼ÊµÊ¹Ø›×˜ÆžÅ†Ñ¿Ê¼Ô·ÎÝ‰ÏÂ‹ÖƒÇ‚Ç¾ÛŒÉ»Å„à¦‡Ü¯Ô…Â†×¦Ð‚ß«È²à£™Â¹à¿…~Å¹Ê Ô¼ÌÎ»É¬Û¸Ô’à¢„à³¾Ô¶ÓŽÜ²Ì‚Ï¶Â™Ç‹É«Ò…Õ‰'],
                        ['@@@@@@@@ß°Ã¤Ê¥à¥“Ü¶Ú¯Í¯DÔ‘ÏªÌµÏ®Ñ‡Ê¾Æ»Ï„ÂºËŽÐ‚Å‹'],
                        ['@@Í¡Ñ³Ï‡Ã®É™Ê¢Â ÃŽÍ–Ê¦Î†kÉˆÇ£'],
                        ['@@à¦Ò§×¥nÇ¿ÉªØ²Ï²à¬¼SiÇ'],
                        ['@@Æ¼Ï…Ñ˜Å¼Ó¨É—à¤‚Ë½à¥ªÊ½Ã¶ÐØ¤Ãž×¶Ë¥Ý™Ëƒà²³È¬Ò½Ïšà ­Òà®¡Ñ£Ë¿Ó®à¬—ÄƒÜ´Ð´Å†ÚŒËºÞ”ØˆÃ¥'],
                        ['@@à¤·Â¥È¿ÐªÎ¦Ò¼Þ–ÅœÙ¾É·XÎ­Ä§Å™Õ±Ê›'],
                        ['@@Ô·Ìà¬‰Ê¬ÛƒÄŸà¬«Ï˜ÝŠÊ¼×˜Î¶à¢¼ÊƒÔŽÆ¯Ê¦Ç…Ô Í'],
                        ['@@Gà¡­à«°Ú„à§Õ¥Ê¡Ø­ß¾Ö¥à¢šØˆØ–Ü¨Â°à¤ˆà®žÃà°”Å«à«¼Ð¹Â¼Ð·Ø³Òƒ×¤Ò‡ÅƒÐ£à¿©×—à­¡Å»à¢ƒÊ¨Ê£ÑƒßµÛ½Ê“Î¿à¦‡Ö©à®³Ã‡ÚÎ¡Ã‡Õ±à¦Ä¿à¨‰Ú»à£­à¥Í™ÚÂ±à¦‰à°‚Æ•ÏœÞ»Ï¼Ù‘à­²Ç”à¼žÎµà¡€Í‹×ºÐ…à©†É³à¢¸ÎŸàµ¶Âµà£´Ä…ÆÜ«Ê¼à¡‹ØŒà¤³à°¨ß—Ù¨ËšÒ”à¡ºÑ­à³¢×£Ñ¶à´ŽÐ€à¥’×œÒ®×”Ã§Ö˜Ö­ÜŒà§·Ù„à¦²à¢¤Î½Ý¾Ë«à²¾×’È˜à·¸É«à¡¸Ä‡Û ÉšÞ´Ëµà¨šÓ£Ê®Í™àº„Ã›}Û·Ëªà©›ÞŽÅ¿ØŒÓµà¯–Ò°ß¦à¤”ÖŒÏ¸ÙºÝ£àª¬à©³à¤˜à§™ÍµÕ…à«¤ÓÝ°Ó“à´‚ÉÕ¢ËÍ¬ÜƒÙ¼ÅÍ¶Í…Ã–à¤»ØÍ×½Ìàµ¯Ì—à©Û‘à·‡Æ‹á…›Ç®à±Pà¢‡ÃÛ±×½à©³Ï‰à¯‰à«—à¥µÞ¡ÜŒÆà´˜à«„á„ˆÛªà°¸ÄŒÝ”Ð«ßÖŸËŠà£ŸËœÙ‡àª¤Ð¿àµ¸Å¨à¡†à¥€ÃŽØÕªÌ¥à¨£Õ½á‡·Ôà ¯Í½à¤¯ØÙ“Ã–ÂÜ†à¸¤Ûžà´Âƒà¤£Ä¹Õ»Ó†Bà¬¨ÏÊÖ›Æ›Ë§ÉšÙ™Ù‰Ê±Ù¹Ì•Ï¡Î¥Å½ËÂ¥ÄÈ¹à»½Aà±¥MÏ›Æ·à¢µØƒÄ¿ÃŸËÍÞ—Bà ›GÏ›Æ…ÆŠÇ‘Ã¸Ê¯eÄàª·Ð»à¡½Å¿à¦‰Ò…É@Ë·Æ‚Ä¥Å¦nÄ”È‚ÌŽÐ‚Ò¦Ê˜ÓºÇ™Ü´ÇµÞ‚à¢•Ð‚Ä¾Æ¬Å«ÄºÉ³@Ç›Æ†Â¥È¤ÇÄ“É¥Â€Â¾ÄŠÈ¡ÄŠÄ‡ÉšÙµËÚ¹Ëªà ‘Í˜ßÌ¨Ý§ÊƒËSà¨•É”Ú»Å‰à Êºà¡«Æ†×•Â¾Ê»ÆœÆ«Ò¤Ë³IEÍ“áƒBá®Aá­¯@á¡ƒ@á ¿@áŸ™@á¢¡@à ›@á @á›·@Å‘Fà¾½à œ×µÎ´àº½ÎÒ³Ý–Å¤Ô¨à©»Î¨Æ§Ú´à§­ØŽiÑ Ò²ÐšwÕŒà·™Õ˜à¡­à¥ Õ×¾Þ‘ÏšÖ£ÎˆÑ¿Ñ¢à¡‡Ë•à ‡Ò¹Ý›Ö‚×“Ï€à ‹É¸à Ÿ|Jâ·ŽNá·²à¼¬È­à³˜Ð™à¢˜Ã»Ý†Î–à§°Ë€à°¢Ä¹à°¼Ï„àµ˜È¾Ö¾Î‘Ø¸È ÈŠÐ„×ˆÄ™à·†Ý«à«¦Ö¬Å–Ù‘à¨”ÆÍ†Ê–à§°Â·à±¼Î›á‹¸Ì­à­„Æ›à –Ã„à¬ŠÑà®Ð·àº¶Ç·á—˜Ä²Ü’Æ¦à£†Ô‹à£´ÑŒà¡©Î¦ÕªË¼à§¾ÂžÚ¦ÄŽÚ´È©à¡ŠÒ—à¤°Ã¤à¹¢Ï›à²¬Æ„à¯¬oÄ­ÔºÝžÆ¦à²¦ËµKß‘Õ–Ú Ú°uÏžà¡Šà£‘Ô°à¦•ÍºÃ¤à¤˜à¦¶ØŽà«ŒÆ‡à¡˜Ï‡à¬žà¥…Ý—Ð­à¼ Ç'],
                        ['@@Ð½Ï¿áˆŽÊ¬à­ Ñ‰à¥ŠÑ–ÞËŸÛŒà ›Ñ„Î’×­à¡°ÝŠÅ¬à ²Æ‡à¤¶Í¹Õ†à ‰Ê¼×¥à¶®Ðµàº°Ð‰ÄÏƒàµ¡Ã£ÕšÍ“Ë±Ì¯àº¹Æ‚à¸ƒÉªà¦‹Â»à½…Ë·á’ƒÅ±à¹»ÄÒ•Ð†à¬«É®Ý™Ä£à¨›Ú–Ö”Äšà²˜Æœà®ˆÂ›àª°Æ¦à¾·Èžá…—Ã£à®—jÑ·Ì´á‹ŽÍ²à²—[à¸·ÉšÛ¶Ù€×’Í®á–¬Ô à¡¬Ç‹'],
                        ['@@Ý‰Ö‡à²¹×šË¸Åžà«¸Â’Ù”È'],
                        ['@@Ã¶Éµà¢¿|à£Ÿjà£¿Å‘Ê‘Â¼à¤Ñ¾Â˜Ì Ð˜ÃˆáŠÄ›à¸ŠÒ£'],
                        ['@@ÚŽÔ½Þ¤Ú´á’†Îˆà·ºà¢…Å¯Õ»á€’Ê’ß’Í®áˆ€Ñ‹à­„ÐÅŠÎ½à¼šÈà¢˜Õ—áŽÍ©Ü¸Í¹ßÞ»à»¯Ï¹áŒ˜Õ¹à³²Èà¯€Þ™à³–Ã‡Ê½×›à¹‰à¦‹à¨—Î¬à³“ß²àª™Ä¿ÅÓ•à¢ªÓ¥à¬œÏ¯ÎŒÉŸÕ´à ©Ì×¿à©•Éªá‘Ú¨à®ŽÜ£à¢”Ô•ÆŽÌ‰á—±Í²á…©Ó¤à§³Ð¦ÌŒÊ‚à°¯Ñœà¯¥Ð¢`Ê‘á¡Æ…ÜƒË¾Ö†Ø¤à½ˆdá‚¸Å†Ë«ÌœÌŠÐ¾àªšà ŠÉ³ÏŠÍ•Ë¾à±¿Ð á³ËºÕžÉ†à¢·ÔºÝ‹Â´ÚË¸Ò‡Ê›àº¿Å…áµÈˆá„«Êšà´¹Å´Û¥Ìà¢žÏ¦à®HË‰à¡šÙ¦Ý¨à¡ºÎ„á“ªÉ¢Ø£Õ«'],
                        ['@@à§ŠÇ¯àº„Å„É–Ê‘Þ·Ð•à±œÎ±Æ±Ý³àµÍ—ß³Ãª×‰ÍŽá¡Ù®jËŽá‚–Ä½à¤Õ¼à¦¸Ð '],
                        ['@@à£“Ø¹à¥ŸÂŒÔ½Ý†`ÐºÑ®Î¨à °É®áƒªÂ‡à¾ˆÈ±à°³ÝŸà§‰Ç'],
                        ['@@á•Ð™Ñ·Ï‚áŠ¹ÑºÎ®Î¤×ŒØ˜Ü°Ö‚à ‘Ô¦á­ŠÆ€à®¬Ç§á’°Â±à „Ê‘à£–Îà©Éƒá×Ÿà¨«×™@Î½'],
                        ['@@Ò™Í™à¯Ã˜à§±É–Ò‚Ïšà¯€É¨Ü¼ÌÌ¬Ë‡'],
                        ['@@ÙžÏµÂ€Ñ™Ï£Ø³àµ±Ä‘à£—ÆˆjÓ¬àµÃÃÙ®à£œà±ŒËºà®‚ÂµÃœÅŽ'],
                        ['@@Í¢Ì™Ý Æ˜à¢¢Â™ÆªÐ©ÔÐ‹á­—Å½á‘¯Î·à±©mÅ…ËœáƒžÏŠâ‘£Ä³à­¯Æ®à¬ªà ßˆÉ¾á›„Ë³à¹¶Ó»à¸ºÃ›à®±ß¨Þ”Ìªà¢„Ä­Ë²Ð'],
                        ['@@à¤¢Ë“á€€FÜ¨Ë¡È‘Íà¥®ÈÕ”È§à¬ŠÂ™à¯¬Ã«à³¸Ç¼á‚ŠÃ°àµ€Ãà£’Í…ÈŠÎÔ½ÉŸà°­Ç·à©½Ä¸áœ±Å»á‚«cà´«Ä¼á–Ë”ÌƒÒ¦Ä¹Ð¶à¡‡Î¾áƒ‹Äºà¦…Ê¼Í‚Îˆá‚¾Ã'],
                        ['@@Å—Ù£Ù©Ì‡Þ¹Â£à¼Î«à´Å¹à¬—Ç¼@@à·”Ø¼á‚®Õ®à²†[à¬¸Å¬'],
                        ['@@Ï£yà¼½Ã‚É¡É¼áœ]×žÆ»ÄµÄ©'],
                        ['@@à¼©Ê‹à°Ë”Ú¼ËŽà¯®Äà®ˆÅ¿Ë©Ê¥'],
                        ['@@à§½Çà¶‰BbÅ¤à¡´Ê¦ÒŒÂàª¦Ç'],
                        ['@@à°•Ç¥ÛƒÈšÎ­Í‚Ã¡ÎŽàªœÂ‘ÓªÃ…à§Ì‡É«Ì£'],
                        ['@@ÍœÎ•àµÄ¤àµ©Ë˜áˆÂŒßºÊ à§«È®Ã•Íà¿¶Å•á—¢Ì«ÙžÐ'],
                        ['@@à§¦Ë•à¬½ÊŸà¼‡Ùƒà¹¥Ã“áƒ“Å†à£—Î„^Ì¦Ú”É¢à»¡Oà¤Ë¨Õ‘Ï ×ŒÏŽ×ŠÊ²à¡´ÃŽÎ¿È–á‹œÂ¨à©¶Ò…à¶¸ÇµàµžÇƒÚ’Ö‡'],
                        ['@@á–¢ÃŸá…®Å…à»¤É«Â™É¡á…Î·áŽ™ÇŸÝ»È‰á†¬JáŒ¡Ô™àµ‡Êƒà·¯Û‡á‚¿Æ“Õ™Ç¡á¡·Ä›à­ˆÄ¿×‡Æ­ÛžÐ±ß™Ë½à²›ÊƒÐ‹Í¡à­«Ê£ÅžÈà·¬ÂlÈ³á–ŸÔ‹á”§É´áž¿Å»à°§Ä¸à½ŸÂªÄ¿Ð–à¼ŠÈÐ±Ø†Ô¢Ãá–¤Î³à¬©Õ¢à´¹ÇˆÚ¼Í˜à¹°È¨Ê„ÌŠà®‹Í Î¥Ñ á˜žÂ—Ú’Äà²¼Ìªá‰ƒÄ¬á°½Ãà¹£Ë¸Û©Í¼à¦—Ê˜ÈËºà°¦Çˆà¦˜Â‚à¿²ÆŒà°‚Ìºà¨¬Â©à£¤É½Ù”Ò’à«ÆˆàºšÄ¢á¢²Â–Ò€ÄášÆšá†”Ãá†’Ã']
                    ],
                    'encodeOffsets': [
                        [[
                                -65192,
                                47668
                            ]],
                        [[
                                -63289,
                                50284
                            ]],
                        [[
                                -126474,
                                49675
                            ]],
                        [[
                                -57481,
                                51904
                            ]],
                        [[
                                -135895,
                                55337
                            ]],
                        [[
                                -81168,
                                63651
                            ]],
                        [[
                                -83863,
                                64216
                            ]],
                        [[
                                -87205,
                                67234
                            ]],
                        [[
                                -77686,
                                68761
                            ]],
                        [[
                                -97943,
                                70767
                            ]],
                        [[
                                -92720,
                                71166
                            ]],
                        [[
                                -116907,
                                74877
                            ]],
                        [[
                                -107008,
                                75183
                            ]],
                        [[
                                -78172,
                                74858
                            ]],
                        [[
                                -88639,
                                74914
                            ]],
                        [[
                                -102764,
                                75617
                            ]],
                        [[
                                -95433,
                                74519
                            ]],
                        [[
                                -123351,
                                73097
                            ]],
                        [[
                                -95859,
                                76780
                            ]],
                        [[
                                -100864,
                                78562
                            ]],
                        [[
                                -110808,
                                78031
                            ]],
                        [[
                                -96956,
                                78949
                            ]],
                        [[
                                -118987,
                                79509
                            ]],
                        [[
                                -96092,
                                79381
                            ]],
                        [[
                                -112831,
                                79562
                            ]],
                        [[
                                -112295,
                                80489
                            ]],
                        [[
                                -98130,
                                79931
                            ]],
                        [[
                                -102461,
                                80205
                            ]],
                        [[
                                -89108,
                                81572
                            ]],
                        [[
                                -70144,
                                85101
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'CHE',
                'properties': { 'name': 'Switzerland' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÂÆ«Å¹È³ÏžÆµÑ–wÃ¡Î…Ï‡Æ™Ø©Å€Ç»Í¹ÐÆ¡Æ„Ò»ËµÐ›Â¡Î±Ç¶Ë½Ï‚Ð‘Å¿^Ï ØšÒ¾ÂÉˆÏ¤Ã»É²ÆžÜŽMÇ¦Ç¼à£’Ê±'],
                    'encodeOffsets': [[
                            9825,
                            48666
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'CHL',
                'properties': { 'name': 'Chile' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@Báˆà£’@Ô’wË§Í»Ü›Ê»Ð­Â‚Ó»Ã¤ØÊ¨à¢ŸÅ¨à©‘Ò¸à¡«ÒŽà­ƒà¤¶Û˜Ç­à­¼Ö—à«œÌŸÑ¢Ï¬Ë˜ÖºÞ ÎŽ×°Ä±'],
                        ['@@Í¢à­…Ø†Å˜ÄºÉË¿à¢à£µÐ³Â€à¶“Ç«Ë“Ê¦Í¡×¥Ô¹Õ»ßÌ›ÞƒÄ€ß¿Ô«à¡¹Ï®à¸É”ÆµCÞ›Ó‘à pÛ¯ÙÕ·FÞ™Ê®à Ô‰Ì§É£Ý¡ÈŸà¡±Æšà§¿Í·Ç¡Èžà¥¹ÏœÍ‡Ë¡Î›Ï¶Ç™ÄšÍƒÎ½ÇƒÄœÓ±Ì«à«—Ñ½Ü“Ä®Ñ‹Ë‡Õ‘Ù£Ï…Ã´à¢¹ÌÌ§Ö”Ã„gØ½Î’Ó©áŽ”Å‘ÞªÅ¿ÝPÐ™È·Ý·Ì£Æ‰Þ¹Î£oà¥…Ëšà¥§×’@@à¨³Ó”ËÕ’Ê„Ó°Ñ…Ö’Å…à·¤Î¦ß°à¢´Ù°à±£Ê”ßžÝ’Ë¸à¶Šà¤¤ÌÑ®áƒ’ÖÉ Ê¿à¨»Õ‰Å Ë‚à®²Ëºà¼’Ï®Ö¸Êà ŽÃ©à¥‚Î Â„Ô¨à´ª×ˆà´ŽÎ¤à°¬È—à°¼Ê¤ÛšÄµà¨žÓ®à¨†Æ°à¾ºË’áƒœË€áˆ¤Ã•àµ˜Ç©à®„ÑœÉŒÉ¦ÑšÐ¬Ö±ÅØ…Ñ´Î¡Ë…ß½ÒŒà¤¹']
                    ],
                    'encodeOffsets': [
                        [[
                                -70281,
                                -53899
                            ]],
                        [[
                                -69857,
                                -22010
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'CHN',
                'properties': { 'name': 'China' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        [
                            '@@Ô‘à´“Î«ÛÑ·Ü‚Ä©Ø®Ó¶à œÚ¦ÙŽÏ¨Ê¡Æ£Ô“',
                            '@@Ü©Ð—ÛÊºyÜ¢Ð°Ï à£¾É¾ÓšoÈŠÍÏƒÏƒÈ™ÓŸ'
                        ],
                        ['@@à¸¬Ëà¦º×¯Í¼ßƒà±¨CÜ°Í¨àµ¸ÊœÑ³Ý±Í™Ì­Ë½à¤ƒÖ¡à ‡à§µÆªÜÌ‘ÉœÜ™Å¥à¦³Ñ•wLÑÕ©ÓºÍ¯Ò»à²™Î±Æ€Ñ¹Ü©ÂŒÐË‚Ö½×­à¤‘Ò‹ÛƒÕ¡à­­Ê‘Ø£Ï½à£É­Ò‚Ï´Ç­ÍžÚ–Ö Ñ¹Ñ²Ü·Ì“à¥‰×Ô«Õ©à ™Â¡Ñ“Ï»Ñ¸Ö©ÛŒÆÂ„Ï•Ú”Ê•à¤¸×¶ÝšÍÕ¬uÆŒÑ±à®“É»Ï»Òà ‡ÑƒÑ›×™à£œÒ¥Í¦à ÔžÞ“Ö®Ù¥_Ø¯Õ…É¯ÈªÒƒÓ¶Ê»Å»ÛƒÉ‡Ú—Ò·Ã·Ø—à£§Ú¹àª¿Þ­à§‹à¬¿Þ¡à­ŸÛ»à¥ƒÄ©Ô£ÏÌƒË˜Ó‡Ð¹à­­Ñà¢µÅ¹Ë»à¢±Ò­Â·É™ØŽÈ¦Í˜à«»ËÐ‡Æà¡É”ÐÎ€Æ„ÓœÞÆ¶Ð™Í€Ü‘Òƒà ‡Ä«Ú¡JÒ‰È³Ñ¥Å«Å¶à¥¥ÒƒxÃ·È¢}ÎŽØÊ“ÎµÆ¸Ø±Í‚Ê”Û¤ÕÇŽÈ§Þœà¢±Æ“Ä´à¦¾ß”Û®Â”Ûš{Ù Î½È¨Ë­Ó¶Ó­Ã™à£ŸÅ²Ë´ÎœÏ¿Ôº×³ÎÛµÈ¸à¥·Õ—Þ‡Ø³Ú³Ä¿Î¿É¦Ñ¹r×·ÈšÒ‘É‡Ö‹Ø±Ã«ÚŒÔŸÇ­à¦“Äˆà¥‹È–Ú¿Ï„ÙµÇ”Ë¯Ð–Ò½Å¦à¡“Õ¸Ú©Ê´Î‘È©à­×˜à ›Õ’É½à¤×¾Å‘Â‚Ñ–Í­Ñ˜ÄÛ†à£™à¦ àµ§Í¼ÊÙ¦Ø©Ï¼Æ«ÊŒÅ³ÓŽÂˆÍœÔ›È”ËŸÄÉ‡Þ¨ÊˆÈ”Å›È ß¤Ðˆ×ˆÇà¢¸Å‘Í†Õœàª‚Ä²ÌšÍ®à³œÒ”Å ÈÃ£ÓÖ¼É”Ý±à¸¦á€˜Í²Ñ˜ÈˆØ†àº’á€ Ë¡Ò²ÏžÂ¢à¡†Û¦Ä€Ù–Ö”Í¢Ã¨Éš×•Û¸Ñ½à®ªÌ¿×†Ú±Í•à¦™Ì¢Î·à§‚Æà¬†Åà§ªÔ»Ô²Ä¡Ï¤ÞŸÓ²Ó¿à¤’náƒ„È‰à«¤Åœà ¦Å¯à°”Ô›à§®BÏŒÊ½à¦ÒŒà´¬Ìˆà°¾ÂŒà¦˜Ì’×¾Òˆ×šË°Æ‹Ë¤ËÍ”Ñ´Õ¨Ó€Ã¹à¡ºÇà ¸Ñ¾à±²ÍšØžÖŠ× Ê†à¯ ÅÚÄ¥Ä Ì˜Ý¿×–Ú«ËÙ¥Ì³à £Å¾Ó‡ÅƒÉÎ†×¨à ¾Ð¦Ùˆà§šÍƒà®†ÕŽQÏ„Ý¸à¢¾Ò²ËWÒªÒ£È¦ÛœÐ¼à¨°Æ²à«œvà°¸Ê¡ÝˆÌ±Ô°à¡Í€Î±ÌŠÔ©Ì¶à •']
                    ],
                    'encodeOffsets': [
                        [
                            [
                                124701,
                                24980
                            ],
                            [
                                112988,
                                19127
                            ]
                        ],
                        [[
                                130722,
                                50955
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'CIV',
                'properties': { 'name': 'Ivory Coast' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ï£U×•Ç’ÕŸWà¦¹Æ¥×Êà «Ì¯Ç‹vÃžÛ–Ä„Å€}Í¨Î£ÎšË‰ÃˆÊ•É²Ç¾ÏŽÄÐžÂ Ê”Æ„BÂ¸Î¾ÃÇŒÄ„ÅœÌ¸Ä¶È¹Ú¨È—ÎŽÃ¦Ë¸Ç˜ÃžÅŠÃºÉ¸Å³Ù®OÆ¸Ê–Æ¢gÊŽÄ¦Å¾Î«ÈžÅ‚ÎŒÅ°ÏšÇ½Æ¦Ë¥Ï˜Ç¯ÌŽÉ„Ï¾ÂŒÖºÉÉ à®¡ÎŸÛ·É•à¥‡Î¸Ü£Â›Í§'],
                    'encodeOffsets': [[
                            -2924,
                            5115
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'CMR',
                'properties': { 'name': 'Cameroon' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ä½Â°Ó»Å‡ÔÅ’Ð‹Ã…àµ…nÅ¬Ú’ÍŸÖŠÏ§ÆšÇŸÏ–É‹Å¦XÉ¶ÉŽ×ªÐŽß¸Ê’RÔ„Ó®ÍˆbÒ¾Î‰Ö¾Ë²Ä€Î”ÈŒÍºÅ¾ÑŒÒ†ÎŠÇž×šÇ²ÈŠÅ¢Ñ¨ÉœÕšÛ¾Ù²Â¬Ë¨Ä Æ²Í«Í°Â‚ËŒÊ‚Â¶Í®ÕŸÃŠÖÂ‹ÖÒœÞ…Ò·TÊÃÏ¥ÄŒÇ»Ð…Ó¸Ó©Î¼Æ›Å ÎË†×ƒÅ¿É©Ñ…à¡›È«Æ³ÃÙ³ÄŒÎÃ¥Ê¡ÐˆÑ­Ã°ÌŸÌ´ÑŸÏ¨Ë“ÂœÏ¥Ä˜ÊÃ“Ò‘Ú›È¤Ú·Éœà©—Â'],
                    'encodeOffsets': [[
                            13390,
                            2322
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'COD',
                'properties': { 'name': 'Democratic Republic of the Congo' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â»à¦™Í¶Å•Ë‘Ì—Í“ÉŸÍÑ«Ç¯Ï·Â±Ú«È›ÍOÙ‡ÊÉ¹Â‹ÔƒÅ—ÃÃ½ÒŸÉ„Ï¡Ã‚à§¥Æ°ÞÄ‹Ñ§Ç˜Ó£Ó¤Ò¹Ò’à©•Í¥Ä’à«¿Æ™É£ÄµÊ‡Õ™ÈŠÏ‡Æ«à¦·Ä»à¡‡É¨Æ«×˜ÍÉ²Æ´Ã¬à£ŸÙŸRÎ‡Ò¦Ì³Î¨ÙŸÅ È‹Ñ°Ô£Ë…Ú§ÅžË«Ï¢Õ•Ã¼Ï½qÂµÊ¾ÌrÏ¥ÂºÔ³Å³Î¹tÈ»Ã»Â®à§„Ë©Ì¸Ã•Ô¬Å¬Ô’ÇÍ–eÕŠà§³QÃ²Ì¢Ñ•GÂ­Æ£ÔµÂÉÓ§Å±È¿Ò«Å Ë£ÅŸÖ‰Ã¥ÍÑ°È—Ë–Ê‹ÔŒÈ·Ø¶áŸ›\\ÌÄ·Ê‘hÎ‹Å“ÅŸÊ¼ÉŠÄ˜Â€Î¼ÆŽÉŽÌªÇ°ÉšÄ‘Ë¼ÍÒœSÃ„ÊƒÌ¼Æ©Ó¶Õ„Ó¨Ð¨É†ËÂƒÛ”Î¸à †Ï¬ÑžÖ„ÐœÄªËŒtÌ°ÆŽÌ†Â«ÓŠÅ€Ý–ÇÔ¾Ê¦ÒˆÂ¸Ô”Ãº×”ÍœÑÒŠË”Û”Ë·Õ˜Ì³ØšÄ‰Ø¸ÇÊ¦Ô–Å˜ÃžÏ¦Äà¤¨Ð¾Í¨Ç±Ë–~Å´È²ÌºÃ°Ù„Ä—Õ¢oË¤ÄšÔ˜Û™Ï˜Ä·É¤Æ–Ï²Ã…Ò¶Ç²È¦Î«ÝŠÖ'],
                    'encodeOffsets': [[
                            31574,
                            3594
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'COG',
                'properties': { 'name': 'Republic of the Congo' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ì¿Ë¾Ê©Æ—Í»Î³Ûà¢¸Ù–ÒªÍƒÖŒË¾É‚Ö¦ÄºÃ¤ÏŒÒ†Ð—ÝÂ•Ê´ÐˆÅ‚Ö’ÄÚ€Ð‰ÓºÎ¶à¦„È½Ç˜Ø³Ã§É»Ñ¢Ã”Î¾à©˜ÂÚ¸É›ÚœÈ£Ã”Ò’Ñ°Þ²Ô†Ñ¼ÖªÆ—Õ¤Â±Â·Ô“Ê¥Ò‡ÇÔ½Ä¿Ý•Â¬Ó‰ÆÌ…sÌ¯Ä©Ë‹ÖƒÐ›Ï«ÑÎ·à …Â„Û“É…ËÓ§Ð§ÓµÕƒÌ»ÆªÃƒÊ„Ò›TË»ÍÉ™Ä’'],
                    'encodeOffsets': [[
                            13308,
                            -4895
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'COL',
                'properties': { 'name': 'Colombia' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Î«È¤Ð­Ë¨Ê…Æ…Ü‰ÅœÈ±Î°Æ½_à ¿Ó’Å•ÊºÌ¼ÃšÂ›Ñ‚È¢Ì¦Ð¸ÃŠÎžÕ†ÍÑ´Ì³È¦Ç„Ó¦ÈÞÇ¸ÉšÆƒÜ„Í»Ò„Å†Ð¢Ë”Ã‘Ç‚Ê È›Ó¶ÄºÅ¬Ñ¢Ù€×”ÎŒÄšTË¦ÆºÜ‚Ó–Ï¸ÕŠfÃ¤ÇªÚ‚Ã©ÚŒÑŠÍžÈŠÐžÐšÌ–Â»ÉšÉ›ÇË±Õ£Æ•É‡Ð¿Í—Ê‹Ê“Ì·Ä¹×µÉ·Ó­Ñ¢Ã‡Å†Ï­È„ÈÃ¢Í¹Ä³ÌµÂˆÇ«È¸Ã©È¨Ì‰àªŠÄ„Ó¦Åƒ×¢Ü¡Í¼ÄšØ‚Â­ÓÄªÌ”ÆŸÆ±ÒÈ‡Ë¯ÃŸ×»ÇœÖ‘Ê†ÊŸÂ†È‰ÑÐ»Ì¨ÈƒÉ Ì‹Ê°à ¹ÇÄ»ÇÓ¸É·ËŠË¥Ìà¿•lZÔ¿Ó°Ä“Â…ÍÇ™Ä”Ò¿Æ‘KØÏŽÌ«Æ€Ó“oÎ·Ï™á˜¯Ð¿Ò‚Ê£pÕªà¡¤ÙŸÏ¾ÔÃ¯Ì£Æ¤Ò§ÉØµÅ€Óµà¢¤Ï³ÉËÐ†Ö‘ÐŠÉ¡Ä'],
                    'encodeOffsets': [[
                            -77182,
                            -155
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'CRI',
                'properties': { 'name': 'Costa Rica' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ò—È†ÇŸÇ®Ä¬Æ¤Â‰È„É·ÈªÍ¥Ç”ÌÅ†Ã…Ê–É™Æ®Ã„Ê‘Ç—È©È“É¸Ë‘ÄŠÅ—ÇžLÊ®ÅŽË†ÊÅ È–ÇŒÅ´ÅˆÖ†ÉÈ–ÅŠËŠÃ©Æ”Ç¥ÊœÃ‡ÈªÇ²ÉˆÒ™Í–Í·Ð‚Î©Í—ÃµLÍ·ÇªÅ±Å±Ä±ÂÆ±Ã«ÇŸÂ©Ç•'],
                    'encodeOffsets': [[
                            -84956,
                            8423
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'CUB',
                'properties': { 'name': 'Cuba' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ü¨Ã‘ÚŠWß„Ë¹Í®Ì­ÞºÄ¨Ì”È¡ÜˆÔ³ÔºÏ›Ë¢\\Ô†ÇŸÃ•ÊØ¦Â“ÙŒÎ…Ä±ÈŸÖ‘ÅƒÖ¡Â¥×ƒÃ¢à®³Ä…ÖœÒ¶ÎÉ”Õ§ÃˆÌƒÊÈ¥ÓŽÓƒÂÞµÉ¦Ê¥Ç¬àª­Å¾Ì‹ÇÍ€É€à —Â¨×¿Ñ§Î[Å¥È³ÐµÄŸÎ«Ä‚ÑºÊ¸Ç¼Ì¤ÏžÈˆÑ–ÇŽÙŽÄ„È°Ä¢'],
                    'encodeOffsets': [[
                            -84242,
                            23746
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '-99',
                'properties': { 'name': 'Northern Cyprus' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÃJÅ¨È®Ø„YÞ†Ê¢Ö§Î§Ã”Æ¿Ä™ÂˆÇ‡Ã™Å±jÂ¥ÂiÄŽÃ‘Â¾Ç‹VÉ«Ã¯Æ¿Â¬'],
                    'encodeOffsets': [[
                            33518,
                            35984
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'CYP',
                'properties': { 'name': 'Cyprus' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â€Ã£à¡±Í¿Ð©ÅŠÈŸÍ¶ÐŽÂŒÇ€Â«É¬Ã°ÇŒUÃ’Â½jÄÂ¦ÂŽÅ²iÇˆÃšÄšÂ‡'],
                    'encodeOffsets': [[
                            34789,
                            35900
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'CZE',
                'properties': { 'name': 'Czech Republic' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ï¯Ç‚ÐÂ©ÙµÊ²ÌÃ™Ò¿Î…Ø±Ë”ÓƒÎ°Ñ•È¬Ä—Î Æ§Ê Ø’Ç¾Ì¸È¾×¾ÇŽÉ‚Ç†ÉœÄ«Ï’Ä–ÐŠË“Ø¼Ã±Â¿É³Ò˜Ç§Å²É’Ö¼Ä¥Ä„Ê¿Ø²Â»Ï®Ð¯Ê¡CÅ½Æ¯È•Â—Ã…È‘Ç‡Â¡wÃ½Ë¹Ä“Ï‹bÅ¡È'],
                    'encodeOffsets': [[
                            17368,
                            49764
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'DEU',
                'properties': { 'name': 'Germany' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@dÍ—à¡”È›SÌ—à¡¢Ç‚Ò¾É°à¥ŠÍ§Ð†Ë‹ÈžÑ‘É¹É£Ì¨Ì™ÈºÒ…ÃŸÌÎˆÕ›Ï‘Ä•É›Ä¬ÉÇ…×½ÇÌ·È½Ø‘Ç½Æ¨ÊŸÄ˜ÎŸÑ–È«Ó„Î¯Ì‘Ï¯ÌŸÅƒÅ¢Õ·Ã½Æ›Ê¿Ç¤Ð•~×·Æ­ÝÂ–Å£É›Ñ‹ÉºÊ©Â±à£‘Ê²Ç¥Ç»ÜNÅ„×´ÑŒÖºà¯…Æ¸Ð‡É˜Â´Ï‚Ç—ÈÄ¨Ö¨Æ—à¢¢ÔŽ@ÉˆÍ‚È¾Þ”Æ¿Ë´ÇÇ²Û°Â°Æ¼ÈƒÖ®Ð²È“Í€ÂÓˆÙŒÅÕ Å¸'],
                    'encodeOffsets': [[
                            10161,
                            56303
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'DJI',
                'properties': { 'name': 'Djibouti' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@È¤Ê¹Î‘ÓÈ©Î®É¯Ì±Ò‡È…Æ¬È­ÃÒ·b_Ê®ÃŸÉ¶Ë´Ð€ÌÏŠÎ®Ã±ÊªÈ´'],
                    'encodeOffsets': [[
                            44116,
                            13005
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'DNK',
                'properties': { 'name': 'Denmark' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@Ô‹Ú¹à¢ŸÓ„ÅÎ’à¯¼Ë¨ËŽÑƒ'],
                        ['@@ÈµÍƒÊ¡ÄžØØÉ®Ð¥ÕŸÅ·Ù‹ÅŽÍ½Ò²}à¡¬Æ”ÉªÊŒÊ¦ÝŒÃ€ÌÉ´Ú®Ê‚ÂƒÑÊŸË™Ä¶É½Ò˜Åµ']
                    ],
                    'encodeOffsets': [
                        [[
                                12995,
                                56945
                            ]],
                        [[
                                11175,
                                57814
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'DOM',
                'properties': { 'name': 'Dominican Republic' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Å€ÆžÙ¾IÓ¾ÉÉœtÆ´Ì•Ò hÂÊ¡ÏÂ‰Ð®Ì¯Ì·Í¿ÐÇ¼Ï«Â•Ë¡Â¢Æ±ÆµÍ‘Â½Å·È²Ë£Å¥Í³Ö»ÉÆ†Â§ÊŽjÉ¬ÉÊ¦È²ÆšÃžÍ’Ã³Òœ'],
                    'encodeOffsets': [[
                            -73433,
                            20188
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'DZA',
                'properties': { 'name': 'Algeria' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@á®©à½½á©à¿·à®‡Ï‘à¤ŸÄ‡UÕ˜ÏµÆŒÔ¹ÊŠÈ§Ð€á¬»á†´á¬»á†´á¹•áŽ fÇŒ@ÃŠQà¦ºà´¬Ø¨à ¼Å¸ÛŽÉ¦ÍŽÑ‚à¦šÍªÂ˜Ø¬Ó¢Ã²ÏžÌ¶àª¸ÆšÆ¸ÍœÉ›Ç²Ìƒà¢²Â¹ÔžÍÕ ß°Ò à£¦Æ¢ÕŒÎŽß¶Ê°à·ŽÆ¬àµ¼Ã¦ÑˆÅ¯ßŠÍ¨à£ŒPÎ€ÈÖºÂ¾ÇŸÑ›Æ„ßŸÈ¡Û™Ô­ÒµÃ´Ù…ÛŠÔƒRÈ¯Ô®Í¹ÎªàºË–ÝÂ°ÏµÆ§Û‡Ã”Ï¥ÅƒÒŸÃ²Õ‡Í«Î—ÓºØ“ÂŽÎ­Ì˜ÒµÏ¼Æ¸Ú’Ï·Ï‚Õƒ'],
                    'encodeOffsets': [[
                            12288,
                            24035
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'ECU',
                'properties': { 'name': 'Ecuador' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ò‚ØºÇ»Î¾ÍÏµÔ‰Ï‚ÇžÊ€Æ™Þ„ÌŽÅ´ÆºÔ¼Í†Õ¦ÃÎ„Ò¢Ç¸×€Í°à¡€Ó‘Æ¾`È²Î¯ÜŠÅ›Ê†Æ†Ð®Ë§Î¬È£ÅžÙ“Ê½Õ³à£·à¢Ÿà§ŸÍ§Ô¥ÜµÇƒÖ£Ó…Î‹Î™ÑŠÍ»ÄžÎÃ¡wÌ®ÊˆÈ¨Ä±Î”'],
                    'encodeOffsets': [[
                            -82229,
                            -3486
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'EGY',
                'properties': { 'name': 'Egypt' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@É½Í·Ç¹Ù‰É«Ñ©ÈÆ¥Ë©Ë”Ï›Ï’×µà®¸Ä‘Ã¹Îà¢¯Ôªà¡‹ÙŒà²µÌ´Ò™Ë’ÓƒÝ®à¤›Ç—Æ£Â‚Õ³à¦’Ý­Æ¨Ç£á¿»@á½‰@â©@@á¶¶@á²´Ê¥Ú²ÉÔ°Å»Î¬Ì¤Ð–à«¦bß²Éà ²Ê›Ï´Å¿Ù¨ËŠÎŒÊŠÝŽÃª×°ÅƒÉ®ÐµÈœËœÚ¨È£Ù¼Â³Ð°É„Ö‚à·½'],
                    'encodeOffsets': [[
                            35761,
                            30210
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'ERI',
                'properties': { 'name': 'Eritrea' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ë»Ë–Î‰Ó°Ï‹Ë’ÉÌ„Ü·Í¶Ö»XÈ­Ç¬Ó¯È¡Ô›Ï¢Ê½Ø·à¦‘Ç¬Ä™Í´Î²à°€ÄŠÖ’Ë†Ê´Ø¤ÆÑŒÓ’Ó¦à¦ƒÉ´Þ—Ò¢Ð£à¬¬ßÒ²ÓÒ–ÓË€Ë¿Ð°Ê§Ê©È³Î­Ã²'],
                    'encodeOffsets': [[
                            43368,
                            12844
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'ESP',
                'properties': { 'name': 'Spain' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â¦×´ÎƒÎ¸à®’Ø†à¨ŠÆ±à«¾Nà£‚ÆÛ¦Âªà´®ÂƒÍ°Í›à»ºÏ¡Ì¨Çºà¥€Ïà¦†ÅŠÂ®Ó¥ß“Ö“àªÇ¯ÃµË±Ô©Ò¯Í•ÛÍžÓ‘ÓŸÏ‘Ç¹Õ³Ù‰Ç—×©Ù¥à©§_ßŸhÕƒÌ“ÍÍ…Ð©ÃªÌµË´ÊƒÓšÞ·Å¾Ã©Ë¦Ì¶Í€ÅšÉ¬ÌƒÊ¢É¶Ö€Í³ÔŒÎ´Ã¨Â’ÐˆÆŽÅ¬ZÙ¾Ï²ÉªÉ»Ñ„Ó©ÂˆÆÅÓ¹CÉÐ¬ÎƒÅ«Ì¥É‡'],
                    'encodeOffsets': [[
                            -9251,
                            42886
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'EST',
                'properties': { 'name': 'Estonia' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ä®Ó¸Ì±ÅÕ“Ì˜Ã±Ó˜à©žÉ¼à©”Å¨à£®Æ‘à¢‚|Å´Æ£×¯ÓÊžÞµÎ«Ë‰Û™DÜ¡Ì¸ÏÄ¼ÜÆ©'],
                    'encodeOffsets': [[
                            24897,
                            59181
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'ETH',
                'properties': { 'name': 'Ethiopia' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÔœÏ¡Ó°È¢È®Ç«Ö¼WÜ¸ÍµÉÌƒÏŒË‘ÎŠÓ¯Ë¼Ë•ÌÏ‰Ë³Ï¿Ã Éµ`Ê­Ò¸aÈ®ÃÈ†Æ«Ç½Ì•Ì´Ò§Ì´Ð™ÍŽÌ›á©¨à¦½ÛºNá››á¡ƒàª«Â™ÝŸ×£Õ¡eÉ¯Ë…Ö·BÍ¹Ë´ÞÎ™ÊÎ“Ö•Ã ÈƒÄ¬ÈŸwË‡Tà©ŸÜŒ×‘@Ë¹Ë¢@Ò¾Ñ§Æ˜Ó»à£´Ï¥ÈšÆ§Í´ÑÐ¦Ô§Ã’Ë¸ÓÒ€rÅ²Ê°[Ý²Êžà¢ ÐŠÉ¾ÄŽÎ„Î®ÙœÔ”Ð¸Î€à  Æ†Ü à¦’Ç«Ê¾Ø¸'],
                    'encodeOffsets': [[
                            38816,
                            15319
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'FIN',
                'properties': { 'name': 'Finland' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Å«×™à²€Ö“Þ¡Ù‰à¦Žà¥™Ö¡Ü›Ý´Ø³Î…Õµà°˜Ö»ÍÑ“Þ­ÓŸá…¡à©µà»ƒÃ¡à¹‘Ì¯àµƒÇ¯Ó¡Òžß¿Ë Èˆà ¢Ð¡Ý¶ÐÓªÞ‚Õ†áŠŽà£®Ö–Ç¬Ä“Î¢à­ŸÐˆË³Íœuà²’à²»Ö²à«©ÐªÔŠÉžà¤¤Ñ»àª²Â¦à£˜È­ß ÏŠÐ¬Øžà²¬Ë¶àª„Í¯Î¡×›'],
                    'encodeOffsets': [[
                            29279,
                            70723
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'FJI',
                'properties': { 'name': 'Fiji' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@Ì‚ÊÆ“Ñ­Ô³Å—Ò©Ä¼Ä…Ï„Í–Ì€Ï¤Ä»È¼Æ'],
                        ['@@Õ›Ç¯Å…Ì¼Ð¾Ç¤ËŠÂ°Ó°Ë€@Ð§Õ•È·'],
                        ['@@Ã©Â­@Ð¨Ç¨ÂžÄ½Ð—']
                    ],
                    'encodeOffsets': [
                        [[
                                182655,
                                -17756
                            ]],
                        [[
                                183669,
                                -17204
                            ]],
                        [[
                                -184235,
                                -16897
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'FLK',
                'properties': { 'name': 'Falkland Islands' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@à§˜ÔŒÜŽÈ¿ÔŒÍ´Ú¦Ï™Ê¥Ì‹à¬‹Ê¥Ï™ÌŒÜ‹Ï™Ð¿Ïš'],
                    'encodeOffsets': [[
                            -62668,
                            -53094
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'FRA',
                'properties': { 'name': 'France' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@Ë£Ù­Ï¡Ç È™Ö¢ÇœÌºÕ¨ÍŽÆœÜ›'],
                        ['@@×”Ð…ÑœÃ Ý€Ï¥ÈŠÃ±ÊŽjÐˆÉ—à¯†Æ·Ñ‹Ö¹Åƒ×³É±ÆÏ£Ã¼Â‚É‡Ø™Ò½]ÏŸÐ’Æ€Ë¾ÏÂ“ÊÊšÌ¿Ì…Ê¯ÉÙ±Ò–ÅƒÄ©Î·Ý¿Ó…á€…É¬à¯§Ë—Ä©Ô‘à¦…Å‰à¤¿ÏžÌ§Ç¹à»¹Ï¢Í¯ÍœÑ¢ÔŽÇ†á€°à¢à¢¤Ø¥ÑŽà±¹Í’ÄØ–àª Ç¾à¶®ÉË‡à¥ŽßŒÎ­á‹ Ù¾Ê¨ÛŽÜ¾ÇžÅªÌ‘Ï¸_Ï¸Íµ']
                    ],
                    'encodeOffsets': [
                        [[
                                9790,
                                43165
                            ]],
                        [[
                                3675,
                                51589
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'GAB',
                'properties': { 'name': 'Gabon' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@à¡¹à¡”Ö‰ÛšÔ™à¢„Â‚Ë¨Ç¾ËŽÈ²Ø”ÇœØ®Ë´Â¶à¯¢SOà§ ÐŒÃ†ÔžÅ‘Ó¼ÅˆÄ¾Â¯Ã“Î½É¼Ñ¡Ø´Ã¨È¾Ç—Îµà¦ƒÐŠÓ¹ÄžÙ¿ÅÖ‘Ê³Ð‡ÝÂ–Ò…Ð˜Ã£Ï‹Ö¥Ä¹Ë½ÉÍ„Ö‹Ù•Ò©'],
                    'encodeOffsets': [[
                            11361,
                            -4074
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'GBR',
                'properties': { 'name': 'United Kingdom' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@Ò‰Ö½Ù‹Ç¦Ô±[Ç¦ÒŠÇ¥ÒˆÛ´Â–à£”Ô³'],
                        ['@@à£‹à£§à¡¦Å˜à¤„IÉ•Û…Ý¯Ý©à¢„ÃƒÃ¤Ä•Ý à¦±ÖºÆ‡Ô¬à¥ÊˆÍ§à§°Ç…Ä·ÕÑ“Ê—Í²Ñ£Ý±Ñ¯à«³Rà·É±Ï»Ç’Ö‰Ï¿Þ¥Äª×ÍÒÇ˜à¯¼à¢¨ÝªÇºOBà²½Æ”ÊƒÍ°à¢œÊºÒ¡ÒÇ†Õ¼à°¢Ã·D@Å®Ó¤Ö›Ô®_\\à§µÆ¨È§É¬Ì¨Ï’Ë¡É´ÒÐ‡Â·ß¶Ñ‰Ñ”Ì¨à¢†Ù¶Ú¾Ú¤Ã¡à§¦Ã¬']
                    ],
                    'encodeOffsets': [
                        [[
                                -5797,
                                55864
                            ]],
                        [[
                                -3077,
                                60043
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'GEO',
                'properties': { 'name': 'Georgia' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Å²Î¬È¿Ö´ÓŸÌ²Ò­Ä¬Ì¯Ê´ÄºÄ²Ü„Æà°†Æ‹à¬¦Ð•Æ¦Æ»ÔšÆ‚Þ¶Ç­Ê´Î‡Õ†È™É“Å™Ð²Ò“Å—Ä±ÒÂºØµÊŽÈµÆà­Å¿ß³Ð®à£…Â¡'],
                    'encodeOffsets': [[
                            42552,
                            42533
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'GHA',
                'properties': { 'name': 'Ghana' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@à³‰Ó¯Ò³Ë½Ý³Ê‘Ý¡Ê†ÂœÍ¨Î·Ü¤É–à¥ˆÎ Û¸ÉŸà®¢Å—Ù†rÓŠà¸¤Â¢ÏŠÃ•Ë”ÆŠÏ´Ã¡Ã•Ê¿Î–ÑŸCØÄ„ÚÉ‚Ì«È…Ý³Ã¤Ð¹É¢Õ“ÈˆÌ'],
                    'encodeOffsets': [[
                            1086,
                            6072
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'GIN',
                'properties': { 'name': 'Guinea' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÊƒtÇ¡Í·ÊJÇÇ´ÃˆÍ¶Î—Ô¨É•Ä§ÇµmÉ³Â³VÌ®Æ‡É˜Â‚Ê”Ç»ÎœÉ¹ÌœÚ¥DÈ›ÇÉµoÆÇ·Ä«É¹Ò…ÏƒÏÓ¼Í›Í¢É‹ÅŠÈ¿Ç–Ä§ÏŠÅ«È‚Ê“ÆÏŽÐ¦Ê®eÉ–Æ˜È„DÆ„ÅŽÃ¯Ë¨Ä¢Ä–dË¶ÐœUØ€È±È„lÃšÄ¤ÒœÃ¡Å¨Â´Â¶Ì­Æ†BÉ–Å’Æ”ÂƒÉ¸É‡Î¬Ã£É²ÇºË–Å’È¬Å ÇšuÈˆÈÄ´É³Î†Î™Ç£ÉÂË™Ç´ÄŠÅ€Ä¯Â«Ê¡Ê²ÊÇ—ÃÃ¥Ë·È˜ÎÈºÚ§Ì·ÄµÄƒÅ›ÃžÇ‹Â·Î½ÆƒA'],
                    'encodeOffsets': [[
                            -8641,
                            7871
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'GMB',
                'properties': { 'name': 'Gambia' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Å†ÏŒà£¶zÈŽÈ¦ËŠ`Í¨È·Ê¼IË¢ÆšÇžÊÎµÈ‹Î¹dÎ­Ç°Ì·È—Æ­QÈ«ÅÞ‡l'],
                    'encodeOffsets': [[
                            -17245,
                            13468
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'GNB',
                'properties': { 'name': 'Guinea Bissau' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ò…Î˜ÎÃˆÈ•Ê€LÅ¸Ê¯Ç´ÃÇ¶Ñ¼ÆŒË¦ÂÉ¦Ä¨à¼ˆÂ•cËµÄ¡Ä•Ã°Ë§ÆƒÅÈƒCÉ•Æ—Ê­fÏÐ¥'],
                    'encodeOffsets': [[
                            -15493,
                            11306
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'GNQ',
                'properties': { 'name': 'Equatorial Guinea' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Æ¿Å´Ì€à¤¼àµ†mPà§Ÿà¯¡TË³Âµ'],
                    'encodeOffsets': [[
                            9721,
                            1035
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'GRC',
                'properties': { 'name': 'Greece' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@Ò Ë±ÙºÂ¶Ø´Ã‘qÆ£ÒœÄ¶Ä¿Ê›à¯ƒÃ­TÆ’à¨ÇŽÆºÎ¦'],
                        ['@@Ê¹ÕÈ¥Ä¥ÔŸ|Ñ«Ä€à§±É“×ŒÒ¿ÑÆ‹Ò³AÑ»ÑžÆ¿ÈÈŠÔ…Ñ€ÐÍƒÇ¿Ò´Ï¯Ð¶Ê‘^Ó…Þ¥É ÊœÑ•Õ“Ä•ÍˆÝÖYÛÎ¼Ì¿Ú¦Æ§Ö’ÍÏ®Ñ™ÓÃ‰Ê†Ï¸Ð¢Â¼ËšË˜Å¨jÉšÕ¼Ã¶ÍŒÈ€Ò–gÆ’Æ¦Ç†Â„Øª{Ú¨É²×¢Ì‰Þ†Ä€VÐ¼Ð¦É']
                    ],
                    'encodeOffsets': [
                        [[
                                24269,
                                36562
                            ]],
                        [[
                                27243,
                                42560
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'GRL',
                'properties': { 'name': 'Greenland' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@á¬œÔ†á±’Â›à©´Ì´á²ˆÄ„ä€¦Ä¿ã‰ŠÚ—à¼…Í•á»™Â™â­Ä‡ÑˆÆ«á²Ä á¡šÌà¿ˆÊ´Û¦Ìà¤‡Ó§á’žÌºâœ˜Íšá ¼Ç‹Ò¾Î«âƒ×±ÓƒÈ•á§‘Æ¡á‹ˆÂ¡à¦›Ø•Ú¯Õ¯Â€à¤§à§šÕ·à²½Â“àµ§Ë‡à¼‚Ñ½È¢Ü‹à£Ã½àªžÜ¡áˆ…Ã‘à¦ˆÎËŸÌ‘à®‡Å½à­¥Eà©†Ö©\\Ïá€•ÎÑ›É£à¬ŒÈ¿àª¼Ô£ÍˆÚ±àºÇ‰Ù«Í–à¨£Ó˜Ë¼Ö­à¦‰Ñµá•–Â•à­†Â¯á–¯Üµá—¿Úáž§Ìà¤“Ià¢…Í“à­Ÿà¢±á…µ×›×…Â“à«§È·à®½ÈÜ›Ô±[×›Ñ‹Õ¿àµ‹Ú§ÍºÙ¿Ï—ÛÑ™à à®…Â½à°Ûˆá€¿Là Ò¢Ö•à à¸à¨²ÑÕ¸Å—Ý®à­“Þ¢Ì¢Ø¦Ö—Ì’à ªà¦šà±ŠÌºÍ¨Î˜Ç¬Ú€à¥¡Ì•Ò›Å¯Ý¯Å£à¨ËœÃ‰Ö°Í¢Ò‚Þ¬\\á‚”ÉŸà·¿Õ”Ý©Ë¾à ·ÅŸÛ«È¼à¤®Þ´ÔÌºÚ—×ˆà§¡à¢¼à©¯ÍšXÎšá–·Ó®á„»Ã–á–ŸÂ‘á…Ã—à¦‡ËŒà¸§Õˆá•‚Ë„ášÂ¬â‰¹É–á‰‰Î„ÅšÍœáºŠÐ˜á¶ŽÐ˜Í˜Ìªá——Ì ÜºÍ°á¯²×–à¯¢ÄšÎ“Ï˜áŒ²Éœá£šÆ‚á£–Rà£ºÊ½á•ºÒ¨á˜Ì½à­ºÃ¡áƒžË™á…ÒÅ˜Î®'],
                    'encodeOffsets': [[
                            -47886,
                            84612
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'GTM',
                'properties': { 'name': 'Guatemala' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ñ›Æ¦Ô»fÏ©Ç–ÒÎŒrÊ–Ä®È Å¡Æ¾ÐšÛ†àª„FtË¸Æ‹Â¾Ä¡ÇºÌµÈšÌ¹Ë¬ÏœDBÓ‚Þ¸BÞ¦UOÚ—ÃŸà¥…Ê¤@ËšÆ±Ã²Å°Ê˜ÅƒÏ¥ÍÐ‰É»ÃÇ‰Ã¢Ç‘Ç§É‡ÈŸÂ½Â¬Ä±Æ¿Ä¡Ë½Éƒ}Å­'],
                    'encodeOffsets': [[
                            -92257,
                            14065
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'GUF',
                'properties': { 'name': 'French Guiana' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Í‘Í‰Ð“Ã‘Å—Ê€È‰Â–Ê¹É©Î½Ç¦ÉˆÎªÃ²Ï¤Æ¢Î®Í›Ó¸Ã¡ÖºÑªÜ Ë¸ÄŸØ¤È¥à¢¸Û¿Æ”Î‡Ó»Þ‘Ê³Ø£'],
                    'encodeOffsets': [[
                            -53817,
                            2565
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'GUY',
                'properties': { 'name': 'Guyana' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ö€Ì¯Ô´ÕµzÑŸÍ„oÒˆÐ§ÍªÌ‡Æ‡Ý±Ô›É•Â°È£Æ¹ÑŸÏŠØËAÅŽÓƒÔ¢Ü³È±Â‰Ò«Ã®Ë™É¡ÏŸÆ¥Ë…Â—Ä¡Ç‘Ð­Â¦Ô«Ð€Ã“Ï´É‹ÑŒÆ†ÜÉ¸ÌÈ•Ï¸Ë¿Å¶ÅŠÏ„È›È˜Ñ©Â™Ö©Ù’É¬É²iÏ²Ô¬ÆŠÈ¾Æ¾Ë½Ì¸Ã´Ì¬Ú–Ó²'],
                    'encodeOffsets': [[
                            -61192,
                            8568
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'HND',
                'properties': { 'name': 'Honduras' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Æ¡Ë€Ê­Ã²ÃÍ´Å—ÄžÇ£Ã’ÏƒÄ³Â‹Å”Ê©ÆˆÇ·ÇšÊ›Ã¬Ç¨ÉˆÃ¡Ç’ÃÇŠÐŠÉ¼Ï¦ÍŽÄ”ÂÈ‚Æ¨ÊŠ\\Ã¾Ã¥Å¾Â¦Ï¸Ã¹Ï²vË’Ä¢Ä°Ä¦ËŽÂ©ÈªÃ‰É˜nÇ–Ã²Ï¨Å›Æ„kÊ²Æ¿ÊÈ‰Ì¨Å¹ÉœÉ³Ë½jÅ›Å•Ì‡Å‹ÉƒAÈ…ÅƒÇ™ÂœÆ›ÅºÄ•{Å‡È©ÄƒRaÇ¥Ì‰É³Æ¹Ä±Ä‘Ä½Ê›ÇžÇ¹É£Ç«PÈŸqlÐ­Å«QÄ¿È“Ê½Â“'],
                    'encodeOffsets': [[
                            -89412,
                            13297
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'HRV',
                'properties': { 'name': 'Croatia' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@È²Í—ËŠÊ‡Í“ÍƒÏÈ†×‡[ÜŸÆ”Ï½mÇ»Ç§ÌÈ–Ç«Î‘ÐªÏ½Ç¼Ê¹Ï®Ì½ÍŒÈƒÍ†Î—Ý”Í‡Ä¡Æ›ßƒÌ¶Ó£Ì¢Þ‘Ê Û¹Ø¤ÇžÃ˜Ï¥ÎžeË²Õ¥Æ„Ê±Î³ÊË®nÌ†ÂŠb×’Â…Æ¸ÆšË¸ÆÍ¤gGÉ¼ÌˆÄ’ÄˆÍºÚžÉ ËŠÄ»Ø¼Î­ÛœÇ‰Ì¼Å²'],
                    'encodeOffsets': [[
                            19282,
                            47011
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'HTI',
                'properties': { 'name': 'Haiti' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ô¢Â™Ü°ÆÃ´Ò›ÃÍ‘È±Æ™ÉŽÊ¥iÉ«ÖÆœÐ…ÃÔ¡Ã”Ï½Æ¿Ò‰Ê¾Ã¶Ë”ÞœÅ›ÙŠÃ£Ì¢ÈˆÏ§Î¸PÍŽÕ‹Å¾ÈŒÉ¶'],
                    'encodeOffsets': [[
                            -74946,
                            20394
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'HUN',
                'properties': { 'name': 'Hungary' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ë¨Õ¨ÇÇ¼Ó‚DÃœÎ„Ñ’É‹Ì²ÄŸÛ¸Ä¼Ã¤ÇšÍ®~Ð¦Å¾ÄœÃƒÐ‚Å€È È¢Ë Â¼à£’Ê­Ç´Ä’Ò²É­ÃŽÉ£Ô¡Ç­Ð‰Ö«Ô•Ö­Ú©ÇÔ½ÂšÙ¡É™Ì»Å±Û›ÇŠØ»Î®Ë‰Ä¼ÇË´Æ—V'],
                    'encodeOffsets': [[
                            16592,
                            47977
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'IDN',
                'properties': { 'name': 'Indonesia' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@Î›eà«×šÞ´Ç’Ñ´Ê­ÌŽÊ­Â»É©'],
                        ['@@Ü™ÈÄ³Ä¶Ã¸Ë¸Î°Ô¢à ¨Í¬ÄÇ“fÊ«Õ·Ø¹'],
                        ['@@Ì¢É£Ô²Ã¨È¼Î¥à¥¿Ç›×‰Å‘ÒPÌ€ÓšÒ¤PÉ¤Ì–'],
                        ['@@Å«Ò±à±…Ê…à«£Ä¾EÌ¬ÚšÇªÕ‚Ê¥Ö”ÃœÝ¬Ì®'],
                        ['@@à¾”Ä‹È‚ÎŒà¼˜Ð—ÌªÕ¯à±€Æµà¨Ó¿à¥ŸÍ‹à¤Í¸Ý»wà¢Ã˜Þ»Æ°à¦…ÍŽØÄŒÎ“Åà»•ÎŒÆ£Î°Þ‘Ã˜Ö¼ß¤à§¶Â·Ú´Í¡Î’Ã›Å˜Ì—'],
                        ['@@ÑÖ±Ä‡Ù†Æ¬Ì Ç¬Ë´È’Ê—CÐ'],
                        ['@@Ì¿Ë¥×…Æ¸ÇÎ°à¡˜Â¢È¾Ë£'],
                        ['@@Ì¨ÙÛ¿ÎŒÛ¯Ã¬ÓƒÃ…×‡ÂˆÈ¦Ò¦à¨ Â”à¤ŽÊ•'],
                        ['@@É¼à´¯à¢ˆÔ‰Û°à¢¼à¥®Ô”ÝœBÜ˜Ì‰Ø®Ì›à£˜Ç‡bá©‘bá©‘ÝŸÛà¡ŸÇœÈ·Ê‡à©¡}Î¦Û‚ÕˆÉºÉ•à£²Ð•Û¸à¿ƒÜ†Û—Ãªà±ƒÞ¦Ê›Ð£Í‘Ã³ÈÌ®GÎºÙ›Ð®à£žÌ¢×´gÃ«É à¯µDÍ©Ô„Ý¥ÆºÎ¡Ð´à¬ˆÈ°ÑšËœà´˜Î‡Æ‚Ì¹'],
                        ['@@Ú­à ­ÙƒÇ‰ß±Çà¶“Â¥Ü½Å§Å£ÙÝªÝ›Ò’Ï à¼ªË¸Ã§Ï¯Î»ÅªÎ¹Ó¯Ý‰Í™ß’à©¿ÆµË¿Ý²à¥»QÕ¿Ò…Ê™Í¡ÌÐœÛŒà ™Í—È»É¶ÅŠÍ–Ø…Ó²Ã˜à ŒÖ•Ê­Ã®à¦“Â”à®±Õ“Å©Î¯ÊšÊŒÞœÅ½ß¸Î›PÊ»ÖºÎŽÕ¾Å¤ÚšÑ„à±ŽÇ®ÎŽÜŽØ°Ù¾Ê›à©–Å›à¥´Â–à ¨ØŽÆ¦È‰'],
                        ['@@Â©Ü½ÑŸÄˆÅ·ÔÎŒÑ·É½ÄµÍ¹Õ’ÊŸà©ºÇšÚ¤Ë¨Ì¨Ã”ÒÓ¸Ã³Ä€Îƒ'],
                        ['@@à¤¸Þ§à¦¹Ä¯Ë«ÖµÂšÝ¿ß±Ö·uà ·Í•à±»Å­Ìšà¥•Ï™Í«Ô¤×³Â´Ð»Ëà§ƒÌŸÌ©ÐžÕ½Â¯Û—Ä¬Å¹à«ºÐ½ÉºÐ•Ü˜ÅÝ€Ä®ÞªÔ‚ÖÆ–Ö—Ö¸Ó…Õ¨Ç ÕœÃ‘ÓªÑŠÐ–Ã´ß’É½Û†Ç¶Ñšà­ Í”ÌˆÌ†à¥˜à¥²@Ü°Æ™ÓÝ·Ø¢ß“Æ¡Ï­'],
                        ['@@à¤›kÛ»Û°àª…ÛŠÎ­ÔšÙÛ„Ð·Ø¾Ù•à­´Ý…ÛªÊ™Ü Ì³Ú€ÝµÕŠÑ­Ü˜Ù…Òºà¢—à¤’Ã³Ñ’Õ¦Â‘à²¢Ç‹Ý”à “Ù®Ö«ÒªÎ“ß”à£™à¡¢_ÛºÖ¹Ó Û³Ù˜Ï¥Í³Û‰Ó–Ì…ÌžsÆœ×•ÌŠÒµØ ÃµÐ¤ÕÉà¨±Â‘à²Ÿ']
                    ],
                    'encodeOffsets': [
                        [[
                                123613,
                                -10485
                            ]],
                        [[
                                127423,
                                -10383
                            ]],
                        [[
                                120730,
                                -8289
                            ]],
                        [[
                                125854,
                                -8288
                            ]],
                        [[
                                111231,
                                -6940
                            ]],
                        [[
                                137959,
                                -6363
                            ]],
                        [[
                                130304,
                                -3542
                            ]],
                        [[
                                133603,
                                -3168
                            ]],
                        [[
                                137363,
                                -1179
                            ]],
                        [[
                                128247,
                                1454
                            ]],
                        [[
                                131777,
                                1160
                            ]],
                        [[
                                120705,
                                1872
                            ]],
                        [[
                                108358,
                                -5992
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'IND',
                'properties': { 'name': 'India' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@à£šà¦ŸÄÛ…Í®Ñ—ÂÑ•×½Å’É¾à¤à œÕ‘à­ž×—Õ‘ÏŸÍ›Þ»à €Í…ßŠÐ­àª°Ò»à¬¸Å‰ÓœÑ‘Ù®Äà§ ÈÛªbÄªÍªÅ‹Õ–ÃžÎ²Ô Ç®Ã¬Ú‹lÇ™Þ†Í‰ÕˆÆ€Ü€Ã‡Ûˆ|ÃÔªÎËŽÚ´Å€ÞˆØ´à¥¸Õ˜Û¶È·×´ÎžÐ€Ô¹Ë³Î›à£ Å±ÃœÍ‡ÌÆ·Ã¨Ô«×·Æ²àª›×…~Ó“Ò©ÛµÂ§Ð¥ÏÛ—ÚÈ’Âà¢‡ÈË¹ÄšÎ£Ð³È¥Ñµà³°ÉµEÆÕÒ¡Ñ¦Ê¸ÓŽÏ–Â¶Ï°Ü†ÓÆœÞ©]ßÅšÃ³×Ð‘Â¤Ú•Î¶Ì“Ö­Ø†Ñ»Ô¿Ì»È…Ì©Ô¬É£Æ›Ô‘Ì†ÙƒÅ¾Û•Å£Ì«Ö±Zà¨›Ç©Â´ÙƒÒƒÓ»à¯ƒÖ¡à¤³à¦©ÙƒÕ‹à ·Õ»CÏ­Ð»È¹Ý³ÌÏ½Â«Ê¥Ù™Çªàª§Â®Û¡Î£ß™Ià·—Ñ£Â¡Ï£Ù™Ê°Ë£Þ‹ÊƒË±Ö¯ÍµÊß‘Þ¸Ï³à­´Í‘à¡’ÌÐˆÑ¿ß°È»à©‚Æ¡Õ€Þ…à¬¼Î‘à¿€Ê£à©¾Hà§°ÇÞ¾à¯£Ô‰×£Ä¶àª±à§²Ð˜Ì¤ÊÍ¤à¦¡ÜŠÖ”Ö–á‡œCÇ—ÜžÒ½ÑŽÄ©Ù¨Õ»Ï˜à¤’à¢¢à¦ŠÃ™à¢žà¢¢Õ„à¡žà „à¡ˆ_×´Ü’Ó Ú³Ð´Ì‡ÖªÌ•Ý‚Ð¬Î²à±¤È±à¤ªÅ°ßºÛ¸'],
                    'encodeOffsets': [[
                            79706,
                            36346
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'IRL',
                'properties': { 'name': 'Ireland' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Æ’×·Ù‹Ý£à¹¯Ó¹à®‘Å¶Ú¼à¢šÑ­à¡¢à¬¤Ú„ÙŒÏ¼Ç¦Ò‡Ç¥Ò‰Ô²\\ÙŒÇ¥'],
                    'encodeOffsets': [[
                            -6346,
                            55161
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'IRN',
                'properties': { 'name': 'Iran' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÝˆÇŒ×°Ó”Öš{Ï„Æ¾×°Ã½à¤˜ÑÚ¤ÄŸà¥¤Ý“Ø¸Â‰Ã²Û»Îà¨·É±Ø‘ÎºÅ­Î«Ò¡Ë Ú¡Ã Õ“ÙÆ™Ã¦Õ¥Ý¿Ý¿Ð¶ÑµÍ¸Ô“ß¦Ï…xÝ‰Ð”Æ‹ÃªÏ¯à¯‰Ñ¡Íƒà¦‰à½Êªà£·È–à¥‡ÅŠÎ§à¨Ð•ÆªÙ£Æ­à¡‘Ðà¨‡Ë¦à¡‘Ù¦ß³ÊˆÖ—ß˜Ø§à«ªÒÆ‹Õ•Ë¦Ì»ÍÒ­Ñ´SÒ‚Ë@ÆØŒÑÙ”à¨Ò¢×‰ßœÈœÙ¾Ñ†Ì‚Ã™Ó¬Õ¿Ê¨Õ­à§ŠÒŸÚ¨ÇÊ¼Ê¿à¥¬Ö¼ÊˆÆ„Í…ÑŠÏ¯Ö¾Å‘Ì¤~à¦°Ø¦Í€Ã˜ÊžÊ™ÌÐ³Ô¼Ñ±È¾Â¦ËˆØ¥ß–Ç©×ŽÑƒà® ÆŸà²¾ÉžÄ„Èž'],
                    'encodeOffsets': [[
                            55216,
                            38092
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'IRQ',
                'properties': { 'name': 'Iraq' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ö€Ê§ÃšÓ«Ñ…ÌÈ›Ù½×Šß›à¨ŽÒ¡ÑžÙ“ÆØ‹ËŽ@TÒÒ®Ñ³Ó¿Â¤ÖŸÃªØß­à¼ŸÃ¤á›á–à°«×šà§¡ÉªÍ¹à§¾á‡¶à¢”Í†à§¬ÄØ˜Ò¢ÈºÑ˜Ô¾Î°Å¾à¦ŽÅ‡ÌÉ‰Ð–ÆšÕ®à§‰'],
                    'encodeOffsets': [[
                            46511,
                            36842
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'ISL',
                'properties': { 'name': 'Iceland' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@È™Õ«à¥ŠÖµàª¥Ù™á“Ö¹Ü£Æµà«‰Å®áš‘Ëˆà  Ïˆá†§Ðªà¹ªÇŽÂ—Ê˜á„‹ÈœÖ¨Õ¶à± Å°à²¸Ö­à±¨Òœà©’ÊƒàµŒÒ„à¶†Ã‘'],
                    'encodeOffsets': [[
                            -14856,
                            68051
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'ISR',
                'properties': { 'name': 'Israel' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Æ¥Ë…Ì£ÅœÇ«Ö“É‚Ä¥É‹Å™Â—É›Ð„Å–pÍ›Ð½à´‰Öà·¾Ê”Ë¢Ã‹Â¶ÉžÏ¼Ç ÙŠÅ¤É†zVË¬CÃ¾Æ¦É¤\\`Î‡Å•ÅµhM'],
                    'encodeOffsets': [[
                            36578,
                            33495
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'ITA',
                'properties': { 'name': 'Italy' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@ÌŸÚ‹Å²Ê¹Ç­ÑÙÍ„Ñ‘Äžà­©ÑÅžÑœà¦œÃ»à¡ªÄ Ù’Ã²'],
                        ['@@ÔŒ×­ÅŸà«•Ï£Ã‚ÎË«Í‡ÉžÂ‘à§¨È“Ó’Ò¨Â¥Ñ€Ê¼'],
                        ['@@à®°ÉÄÐ¯È¬Î§ÚÅªÛÌ—Â²Ð·Ä»Ê‡Ë Ñ‘ß€Ñ‡Ñ†Û›à¤¦Ú±Ú†LÈ²ÈƒÉ½Ç—ÝªÌ¥Ø Ê©ÜœÑ«Ä”Æ¿Æ½Ì›Ò¯Ï¼Ü³ÆÎÕ«ØˆÌ·Ä±Ñ«Î—Â¹Ò…Ü›Î•ÃHÊ²Ç¢ÒŠÇ¼Ç¶ÍÓ¤Ê±ÑˆÎ‘Å€Ê›Î´Õ£Æ´ÎµÍ¶Ø«Ã†Ù¿ÏœÞ‘Õ´Ö¯ÓœÊ¿à ªÐ¹Ä®ÛË¤Ï¯Å•ÓÏµÎ“Ã•ÄªÎ¸Ò•Å„ÉÙ²Ì†Ê°Ê™Í€Â”Ê‚Î²ÇµÐœÂ¢Ò¼Ë¶Æ¢ÆƒÐÂ€Ç¼ÍºØªÄ¿ÏˆÆšÃ¢Î†Ô˜Å¡Ä®Ç†à ¨Æ¤ÈŠÌ‰']
                    ],
                    'encodeOffsets': [
                        [[
                                15893,
                                39149
                            ]],
                        [[
                                9432,
                                42200
                            ]],
                        [[
                                12674,
                                47890
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'JAM',
                'properties': { 'name': 'Jamaica' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ö¢Ã·Ò€È«Æ”É¯×ŸeÊ­Æ—Ò¹ÆŠÓ‘ÌªÄ¶È”ÎœÃŽÈ’Âƒ'],
                    'encodeOffsets': [[
                            -79431,
                            18935
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'JOR',
                'properties': { 'name': 'Jordan' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Æ¦Ë†à¤ªÍ«à¿ªà£†Íºà§½Ç…Å³á…Ñƒà ¸à ¿Ë£Æ›Æ‘Ë­Ù™Å™È©Ì¡ÎµÊµà¤§Æ†ÂƒÅ¨Ð¾à´ŠoÍœÅ®Êš@Ô¤'],
                    'encodeOffsets': [[
                            36399,
                            33172
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'JPN',
                'properties': { 'name': 'Japan' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@Å†Ë½Ò¿Ô•Î‰ËÑ™È›ÉÓ­Õ·ÊˆRÐŠÒ¬Ô†ÓŒÄ«ÎŠÎœØ Ç¹'],
                        ['@@ÍÚ¡Æ¤ÑÑ©×£à©¹Ðƒà¹Â½à®£à¥¡Ö¡Í”Â“Øºà¸©Èƒà¦·Ðƒà¦eà¡žØ£Ö—à·—Õ«ÎÐÍœÈ¶Ý¶ÕÊ’Í¿Ö¾ßÊ¶Ñ²Õˆà¡ŒÑ¢ØžÖ¸á€¬Ê¤à£ŽÇ£à¢ à¹ºÖ”Ð‘à¯¾à¡€ÓŒÍœÕˆà¨ˆÆŸà¤¾Î¢ÕŽà£€Æ¸Òžà­—}Ú»Þ¥à¡bà¢'],
                        ['@@× Çµ×¨Î¤Èˆà¤¹à°É¯Ýà ±à³“Ö¸Ò›à¤à¤£]Å™à ´Ð´Ù¨à£ŒÂ²Ê–à­ÊœÙ¼à¦¨à¢“Ù¤Ë¯']
                    ],
                    'encodeOffsets': [
                        [[
                                137870,
                                34969
                            ]],
                        [[
                                144360,
                                38034
                            ]],
                        [[
                                147365,
                                45235
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'KAZ',
                'properties': { 'name': 'Kazakhstan' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ó•Æ¹à«×“Î¿×¹Ì¹KÉ±ÐŠà©«Â‚Ç¡ÛŽÐ¥NÃšà¡†à§“Ø˜à··ÃŸà¦¡Å©ß£Ý¶Û‹Í†à²¥×¼Æ½Ã°á“—Ó¹Âá¶½Ñ™Â£×™Ú†Ö§É¼à¥•Ç©Ï‡Ë§Â±È²È¶Î–Ç…ÌŠà¦…ËºÏ›Ý®Ò©É†Â…Ëœà ŠÄÂŽØ˜ÜŽÆŽÜ¼Å±Æ²à ŽÆ­Ô²à ¿Â£ÜÈ´à¦ƒÏƒÞµÇ­ÑÆŒÄÑžÕ™Ö˜Ø¯wÜ‰Ö¬ÓžÙÊ•Ç¢Ú¢à¤Šà¡ºÓ£Å€Ø˜áƒ„à£´à²¾tá‡¢×‰à¦ºÍ»à¢¼Î à³°jà©ºÑ¥Ê”Ê à­¼Â—É‚ÐŠà´·×€ß®Ð¦Æ¿É®ß®É”Ø…ÖºÏ¬Ë¼á¸®ÌˆÐ¨Èºá‘†Ì´Ý°Î’àº¢Ç¹Ë„à¢‰à¢šÈ²àª†Ë¹Ã©Òß®Â´á‘ŒßŽÌ­Ëà©¶Ù­áˆ á’‘Ò„Ñ°à­„Ó›à¯€ÉŽÒªÆ¯ÐšÓŸ×˜Ç‹Î¨Î¥àªŽÅ’Ñ¾Ô£Ù•Ö“Û¥Ã¿Â¡à¡…Ò±Ïá€ŸË¢Ø…àº‘Ñ—È‡á€—Í±Ý²à¸¥Ö»É“Ã¤ÓÔ­Å¬ÑƒÌ à°Ä–à¶ƒxÌ§Ä¡à®¥ÎžÓ‰Ç§Å½Ó¹àµ©Ì‚ÖƒÅŸÈ‰Ï'],
                    'encodeOffsets': [[
                            72666,
                            43281
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'KEN',
                'properties': { 'name': 'Kenya' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ó¾Û™×™Í±È¹Î•Ì¿Ã•Å¡×£Ë‘Í¹ÇÖ‘Í·Ë¥à®»à¡€Ã‹Ó¤áµá‚ŒÆ™Ä¢Sà¢ºÊŠÍ¾Ð°ÖŒÌ¨Ø”Ïƒà¥°Ä¯Ñ‚Ð‰×ŽÔ¬ÔˆÖ¬Ö†Ñ¨Æ—@Ò½ËºË¡×’@à© Ü‹ËˆSÈ xÈ„Ä«Ö–ÃŸÊžÎ”ÞŽÎšÍºË³Ö¸AÜ½à¥‘Xáµ£'],
                    'encodeOffsets': [[
                            41977,
                            -878
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'KGZ',
                'properties': { 'name': 'Kyrgyzstan' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÈŠÏ‚Ö„Å àµªÌÅ¾ÓºÓŠÇ¨à®¦ÎÌ¨Ä¢à¶„wà°žÄ•Ñ„ÌŸÔ®Å«ÅŸÈà³›Ò“Ì™Í­àªÄ±Í…Õ›à¢·Å’×‡Çß£Ð‡ÅœÈŸÊ‡È“à½ŸÅµà¨¡Ë˜à£«ÃÄ‚Óœà£´Æ•Ì®Ê¸Ù–Ä‰à©¾Ø‚à¦»Ñ¸×±È½Ø¥Í‚Û¶Õ®ÊŸÄŠ'],
                    'encodeOffsets': [[
                            72666,
                            43281
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'KHM',
                'properties': { 'name': 'Cambodia' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÎÑ¬Ñ‹à¢„È£à§¨Õ Û¨àª˜Ç†ß€Å¥ÛšÍ¡Ïž×„Ý–Ì±ÈœÖ•Ä»à§•à¶³Ù§Ï„Ô™à¢¥Ã“Ü«Í·Û±Åª'],
                    'encodeOffsets': [[
                            105982,
                            10888
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'KOR',
                'properties': { 'name': 'South Korea' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ü¨à¦¯ÈºÕ­Pà¥·ÍƒÒ¥Ý½Ç‰Ú¥ÎÝ³Ã¯Ä¥ÒšÆ¼Ù€Ï‡à¢”Ø°ÆšÖ»Ü˜Ã‚ÃºÏ’Â‡ÍžÏœ×¦Â¢Î¨ÃˆÅ¨È®'],
                    'encodeOffsets': [[
                            131431,
                            39539
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'CS-KM',
                'properties': { 'name': 'Kosovo' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â›Ç£ÅƒPÃ‰Ì¨È©ÄÇ³É¦Æ¾ÈŒÈªÃ’ÅœË¨Æ°Â²Å¢ÅŸÆ¾Â¿ÅŒÆ…Æ’ÂŸÇŽÆ»Å¢LÄ¥È³Ä³Ä³Â„Ã—È‰ÂÓ¹Å»'],
                    'encodeOffsets': [[
                            21261,
                            43062
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'KWT',
                'properties': { 'name': 'Kuwait' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ç¬Ï‡ÃµÈ“Ë”Ù‡×©uÈ½ÐÝŸÄ†Øžß®Ö Ã©'],
                    'encodeOffsets': [[
                            49126,
                            30696
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'LAO',
                'properties': { 'name': 'Laos' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ËšÏœÂœÜ†Ú¹Ü¸Â¿à ¦Ù•Ú¾ÙÃŽÇ›Ì‰Ó¯yÊ£Æ¨à¢¯Ô…oÝ¬È¸à¢®Ö§ÂžÂ³ÔŽÎ·Ê¸Ç´Ì²ÜÕ¶Ã¸È¡Ò„wÅµà¥¦Ñ¦Å¬Ó®ÚÏ–Þ…à¨šOÍšÜ¹ÕÉ—Ê‰ÌŸà§”Ô‰Û¦à¦³ÕŒÝ‹ÙŽ×É„×¥Æµà ¿Ý•Ì²Ï×ƒÛ™Í¢'],
                    'encodeOffsets': [[
                            107745,
                            14616
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'LBN',
                'properties': { 'name': 'Lebanon' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@É£[Ã½Æ¥Ë«DÌ˜Û„Ð¼×¢fÂˆÏ˜Â§ÆÍ£Ò›ÍƒÈ·ÒŸ'],
                    'encodeOffsets': [[
                            36681,
                            34077
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'LBR',
                'properties': { 'name': 'Liberia' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@É—Qà¡½ÐÞ…Ù–ÜÒ¢Ö£Õ¨ÈªËÂ¬Ê”ÏœÒ˜ÏºÏºÇ¶nÉ–Ä¨Î˜Ô§Ã‡ÍµÇÇ³Ê‚IÇ¢Í¸Ê„sÂŸÊ“ÄŽÐÇ½ÏÊ–É±ËŠÃ‡Î¤Î™~Í§ÄƒÄ¿ÃÛ•'],
                    'encodeOffsets': [[
                            -7897,
                            4470
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'LBY',
                'properties': { 'name': 'Libya' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@×§Ì·Ò¿Ò¤à³§Î²ÏÕ„Ú‘Ï¸Ï»Æ·Ì—Ò¶ÂÎ®Ó¹Ø”Í¬Î˜Ã±ÕˆÅ„Ò Ã“Ï¦Æ¨ÛˆÂ¯Ï¶Ë•ÝÐ¨ÈœÃ°Î Ä—Î’Ö¾Í”Ê¶ËÐ¦ÊŒÂ´Ù¦à¦¦ÌÎœÃ°Û®Æ“à«žÏ“Ð€Ý›Ý®Çà®†Î™à£†Ð¹Ð¦É”Ð–Ï®È›Ù Ë‚Ð¤Ø„Ð€×‚Å˜à¬’Ç£ËºÏ‘ÌºIËŒÆ›à ´Ä±È²Ë£Ì£Ð•Å¼Î«ÉÔ¯Ê¦Ú±@á²³@á¶µ@á€·à¥±GYÎ™â€§à¾â€§à¾’à¡“ÒŸ'],
                    'encodeOffsets': [[
                            15208,
                            23412
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'LKA',
                'properties': { 'name': 'Sri Lanka' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Å³à¢“Î™Ê‡ÜµÈ“ÐÚœÆ«à¯€Ï à´¼×†Ò±Ïº×¡Ðžà¢“'],
                    'encodeOffsets': [[
                            83751,
                            7704
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'LSO',
                'properties': { 'name': 'Lesotho' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ì†Ê©Ê³Ð£Æ›Ë›Ò³Å¿Æ¹ËÌ›Ä‹Ø¿Ù¨Ò„ÕÒ–Í¢Ï¼Ç Î¾Êµ'],
                    'encodeOffsets': [[
                            29674,
                            -29650
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'LTU',
                'properties': { 'name': 'Lithuania' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã£ÉŠÄšÉ²Ï‡Æ„à¢¡Æ¨Ç±Û¸à¥¨Ê´à¶¬Ãà œÄŠÅžÇ©Ò‚Ãƒß²Ð¡Ä€Ï“ÛËÈ™Óƒà£¯Íƒß»NÈ«Ê¶Ñ™Äœ'],
                    'encodeOffsets': [[
                            23277,
                            55632
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'LUX',
                'properties': { 'name': 'Luxembourg' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ç˜ÈÂ³ÏÊiÈ‰Ã²ÄžÒ¼É–ÂŽ'],
                    'encodeOffsets': [[
                            6189,
                            51332
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'LVA',
                'properties': { 'name': 'Latvia' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â†Ù†Ð®Õ†ßŠË¼ÚœØ¹ÚªhÇŠÙ¤ÜÆªÏ‚Ä»Ü¢Ì·ÛšCÐšÈ•Ã®Ð¡Ë’Ó·à£—Í•Ô›Æ™ß±Ð¢ÒÃ„ÅÇªà ›Ä‰à¶«Ã‚à¥§Ê³'],
                    'encodeOffsets': [[
                            21562,
                            57376
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'MAR',
                'properties': { 'name': 'Morocco' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ô’Î¥ßœÃŽà¢ŠÈƒÎºUÍ‚ÕŸÂºÔÌ„à¢±ÉœÇ±Æ·Í›àª·Æ™ÏÌµÓ¡Ã±Â—Ø«à¦™Í©ÍÑÛÉ¥à »Å·à´«Ø§Rà¦¹Å·@@@pÒ‰Ô±ÂË“È‘Ï¡@Ì¥ÅŠÛ¹Ä›Ë›Ù»Ê¿Ã•Ðà©•à­Ÿà£¡Ë£à­‹Î…Ï—ÄµÌ¡á‰…Ã£aDÂ Ï¶Í’É®ËžÑªÃƒË¶Ì€×¤Ò´Õ–Ë²ÆŠÉžÓ¬pÒ‚Ì¤Ô²Ö”ÌªÕ’à¡¬f\\Ñ†Í”Þ°Ä¢ÚŽÖ¸Ñ‚É Û®Û®È¿à¨¶ÍŠÜ¢Å”Ñ¶Õ¤Ö¨à¡ˆÏ¦Ø®ÎÖ˜à¢ˆË„ÔªØ¤I'],
                    'encodeOffsets': [[
                            -5318,
                            36614
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'MDA',
                'properties': { 'name': 'Moldova' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@È¨Å®Ö’ÄŠØ¤Ê½ÎŠÂÏžÉ¥Ã‘ËµÌªÆÅ¨Î—ÌŠÉ‡ÃÅ±Æ¾ÄÉÃ—Ó·|Ä‰ÅœÇ«Ã£Ã’Æ­É±ËÆ¥Ë½ÉÄÆ¯Ï¦Ä˜ÎªÏ‚ÓÔ‚Ë‰Î Ê¹Ê Ê¯Äˆ'],
                    'encodeOffsets': [[
                            27259,
                            49379
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'MDG',
                'properties': { 'name': 'Madagascar' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@É Î¥ÈºÖ‰ÆŠà§É’Ï½Ä‰Ð—Æ©Ê™Ë·Ó°ÇÊÇˆØ«ÃµÎ¥ÉµÈ—Â¿Ü…Í§à¦“Ð±à­…Ô¯à½§Í‘à­ŸÏ›à¦‡ÛÈ£Ü»Î¡Ó›ÉŠÚ™ÌœÉ³ÑºÃ‡Ý˜Ì‘Ú Ã¹Ø‚Æ®Ø„Ï°Æ¢DËªÐ”ÙÃ¸ÕšÈ™ÐˆÇƒÕŒÃ£Þ ÌŠÒºÅ”Õ’Ð¼ÂŒÒ¶Ç¤Ì¶Æ²Ï„\\ÓÓŽÛ–Ô®Ê¦Ñ†Å—Î¬Î¦ÄµÒª×ŽfÔË¦Ï”ÌŠÎ¯'],
                    'encodeOffsets': [[
                            50733,
                            -12769
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'MEX',
                'properties': { 'name': 'Mexico' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Í™Ý…Æ¥ØÃ•à«·Ä…Ð§Æ¤Ò›ÊºÐ§ÇšÙ³ÖŽØ³ÈžÓÍ¢Ð±à¢¾ÉÎÎ™Ý„É¾ÙšÄŽØ¼Æ°ÕŠÆ Õ–Î‚È¨Ó¬Ã¨Û¸Æ¢Ê–Ö¬Éšà¢¶ÈšÝ”Â‡ÔšÃ®È¬Ç±Â…Ð™Ò‹ÔÈ¥ÔÆ¸Æ¥Å±Î³ÉÙ½É…ÉŽÇ­cÇƒYÌÔ“Æ³Ä²Ä·ÂPÅ­Þ¥VÞ·AAÓÏ›CÌºË«Ì¶È™Ä¢Ç¹ÆŒÂ½sË·àªƒEÐ™Û…Å¢Æ½Ä­ÈŸqÊ•à¥à£žÑŸË˜Û‡É–Ò·Ã“Ú«ÍÑ‡Ä‰×¥ÉœØ¿Ç„Þ¹Ï¬Ø¿Å à¥Ï¸Û±Ð’ÉƒÉ¤Ò¹Âºà¡¯ËˆÎ“Ï¦à£—ÓŠÑÕŒÈ§Ð¦ËªÄˆÄ‘ÊˆÈ–É”JÌ„Ë±Ï˜Ã¹Í®Ë­ÑŠÝ‹à ´à¡‹Ú€Ð£Ô¼ÜÎ„Æ·È´Å¸Ô²Ñ“ÈžÓ¹Ð¤È½×”ÒÃ¦Ó£Ñ¸Ï¿Ð¤Â™Ë€ÒÙˆÌ“Ù ^Í”Ø‡Í¬Ë«Â™Ó‘É´Æ‡Í¿Æ”Ð•Ä†ÙÌ€Î‹Ø®×Æ’È¡Å¸Ã“ÅŽË½Æ¬\\ÇœÕ©Ê®É‡Ç´Ì•Õ†Ñ‘Ë¨Þ¯Ê ÏÉ¸Ï¿Â²Ñ·ÐšÂƒÍ¶Ï¡Ì¨Ï‘qÆ­ÎÌ±Æ«JÉ›ÔžÕ»ÓŽØƒÐ Ñ—ÉˆÂ„ØšÅµÒ–ÐÊºÖ¿Ï’ÅÅ‡ÉƒÉ–Ô­È°Ó·Ó¦Ã–ÃšÎŠÂ³Ì¸Ì¼ÂŽÏœÙ©×¶Ó±É¶Ì±Õ€Ì·Õ¾Ï³Ú¦Í¿Ý²à¥–Ãžà©ªÄžÃ¿Ç‘à±”Ð¡áŠ€×£á€ªPÚ˜@DÎŒà¸œ@ÌªÌ•Ñ˜Ë‡Ô€ÏƒË¨Ñ­È¾Ò¥Ñ¢Ê©Û¤Ê¥ÕŠÚ’ÛŠh×¤Í±Ñ„Ö¹Ì„Ó¯Ó¸ÓÈ‚×—É¾ÐƒÙ¾Ê¹×®ÈÍž|'],
                    'encodeOffsets': [[
                            -99471,
                            26491
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'MKD',
                'properties': { 'name': 'Macedonia' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Å„OÂœÇ¤ÓºÅ¼ÈŠÂËºÂ¶Ï´bÑ‚ËÃ’Ö‰Ç…ÂƒÆ‘Æ¥Ò•hÍ‹Ç¿Õ»ÃµÎ‘È´Å¡Î®Å„Ë¸'],
                    'encodeOffsets': [[
                            21085,
                            42860
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'MLI',
                'properties': { 'name': 'Mali' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ë°Æ¶Æ˜Ó¶ËŠp×–É»Ó„Ç–Í–Ã‡Å´Èˆâš^Èˆ×šÆ£Ä¼Ð›â‹ˆÐ›â‹†à±¾dá¬¼á†³á¬¼á†³È¨Ï¿ÔºÊ‰Ï¶Æ‹VÕ—à¤ ÄˆFáŠ«ÒŸÖ—Ã­Ô­Ý›Æƒà¬©Ã¯Ì³Ì—Õ¡ÂÕŸIÈ¿ÇˆÒ¥Å¡Þ»Î‘Ç…Ê¿Ù³Ï•Å—ÉÎ™Ç¡ÐÅ”É±È³Å«Ö»Ú™Û¡pË³É­Î£Ã†Ó¥Î‹Å¯ÈÅÅ½Î¬ÊÄ¥Æ¡hÆ·Ê•Ù­PÉ·Å´Å‰Ã¹Ê±ÊŽÂ¬Ê¢Ä¿Ä°Ç³Ä‰ÂËšÇ¤ÉÎ…ÎšÄ³É´È‡È‚Ç™vÈ«ÅŸË•Å‘É±Ç¹Î«Ã¤É·ÉˆÆ“Â„É•Å‘Æ…AÂµÌ®ÂžÊ¾Ã­Í˜Ì½Ê€Ç“Ó”ÂÔº'],
                    'encodeOffsets': [[
                            -12462,
                            14968
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'MMR',
                'properties': { 'name': 'Myanmar' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ó«Î·×¥Â›Ï¥à£¥ÎŸÆ³ÐžÝ…Õ”Ø—ÎˆÖ…Ì­ÜµÌƒÆ¹ÈªÑƒÖ–Ú™ÄªÒ·_ÏµÍ Þ‹Ò£ÞµÐ¡à¡·ÄƒØ°Ê´Ù Ë¯Ó¼Ã¦à£¸Í½Ñ¤Ë›à§”Æ±à©šÎµÛ¢Ö…Ñƒà¥•×³Ò½Ã¶Ô³È Ì‚à¨ªÇ«Þ¾Ú…à¥ºÄ¼Ì¢Ó­Å†×­Û†Ã…Ú°ÌŠÅµj×¾Ð´È¦Ä™Î¤ÈËºÂŽà¢ˆÚ‚È‘ÏÛ˜Â¨Ð¦ÒªÛ¶}Ó”àªœ×†×¸Æ±Ã§Ô¬ÌŽÆ¸Ã›ÍˆÓ®ÃšË®ÓµÎ¾È§|ÙŸÂ“Û™ß“Û­Ä³à¦½à¢²Æ”È¨Þ›ÕÇÊ“Û£Ø²ÍÎ¶Æ·ØžÊ”~ÎÜÕµÇ³Ì±Ó“È—'],
                    'encodeOffsets': [[
                            101933,
                            20672
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'MNE',
                'properties': { 'name': 'Montenegro' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÃÇ€Î·Ð¯ÃŠË‹Ç«ÃžÉ½ËžÎµÇ–Ä¢ÆœÅ¬Ò¦ËšÈœÆ¾Ã¼É ÆŸÅ¬Å›Ë Ä›ÍŒÇ§Ã§Ã¯Æ½È‹É§Ã³'],
                    'encodeOffsets': [[
                            20277,
                            43521
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'MNG',
                'properties': { 'name': 'Mongolia' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@à¢®Æ¢à¾„Ü¤à±¬Ð„Ü´Ê³à¢š]Ö˜Ï½à ¼Â‰à¯Éà ˆ×’Í¿Ó¶à¢Šà¢Šà¤¶ÎÞ‚Ä¯à¦¨ÉÇˆØ¿à®œÎ›ßÆºà©žÅŒà¡†Åà –Ð—ÔšÑ•Þ¬Tà©’Æ‹ÞœÈ¼à«ˆÆ’à¯¸×¤ÔŒÄÑ°Ë­à§ŒÃªÐ¥Ù‡×§à ½ÉÎ…ÓˆÅ„à ¤Å½Ù¦Ì´Ú¬ËÞ€×•ÄŸÌ—ÚÄ¦à¯ŸÅ×ŸÊ…ØÖ‰à±±Í™à ·Ñ½à¡¹ÇžÒ¿ÃºÑ³Õ§ËŽÍ“ÆŒË£×™Ë¯×½Ò‡à¦—Ì‘à°½Â‹à´«Ì‡à¦Ò‹Ï‹Ê¾à§­Aà°“Ôœà ¥Å°à«£Å›áƒƒÈŠà¤‘mÓ±Ô€Ï£Þ Ô±Ä¢à§©Ô¼à¬…Åžà§ÆžÌ¡Î¸Í–à¦š×…Ú²à®©Í€Û·Ñ¾É™×–'],
                    'encodeOffsets': [[
                            89858,
                            50481
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'MOZ',
                'properties': { 'name': 'Mozambique' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ù„Ã¦à§žÊÉ–Å„×’tÌšÊ¦ÔŒaà¤€ÍœÚžÓ¤ÆŠÏ•Â“à ·Ä¾Ý…Âà²¿Æ¨Ð«Ê£×·Í™×Õ—ÔµÞÍ‰à¥ƒÐ¡à¥‰à£•Í“Æµ×•×¯Î‹È—Ã­×³ÐŒÙÇ”Ó±ZÊ£ÆªÂ¦{à —Æ‹Ï·È¤ÆÅ±Î“Î—Ì—Û—Ë³à§ŸÒ•ÏÌ³Ã°ÎŸÉŠÃ‰Ã­ÑµÙ‘RÃ¯ÏŠÅ¯Ï–Ã­Ì Æ¬à¤ªÉ“×°Ð“à®‚à¢¬à¥”ÉœØ†Å¶ÃºÄ¨Ó¶Æ‰ÊžÂ˜ØºÇ×ŒEà© Ñ¥Ë’ÐÃ”Ç¹È¼Ï³Ç°Û«gÃ…Ì¼Ä×°á¢ˆÛ˜ÓšÐ•É´Ã¼Í¨É…Â¸ÍµÇ¯Ï·Ã˜×¡Õ¸Ô±Ê²×ŒÎ¶Ç°Ã­àªŠÎ™ØˆÌ£Ë–Ì…]É½àª¦É¾Ù”'],
                    'encodeOffsets': [[
                            35390,
                            -11796
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'MRT',
                'properties': { 'name': 'Mauritania' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ö‡Ö¾Ô—Ø¤ÖÉžÐ“ÊšÒµUÐ§Ç½Ð¹Ã°Ë½ËÃ¯ÒÉºÐ°Å€ßŠÄ£à ¨ÄµÐºÄŒÐ¼É‘ÐŽÑµÎ´Ç¾Ë¬á¾”MÇƒà¯ŽÈ´Ñœß€Ã¸Âá’¸áª‚Â©Fà±žá¹–áŽŸà±½cÐœâ‹…Ðœâ‹‡Æ¤Ä»È‡×™â™]Å³È‡Í•ÃˆÓƒÇ•×•É¼Ë‰oÆ—ÓµË¯Æµ'],
                    'encodeOffsets': [[
                            -12462,
                            14968
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'MWI',
                'properties': { 'name': 'Malawi' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@É½Ù“É¾àª¥Ì†^Ì¤Ë•ÎšØ‡Ã®àª‰ÎµÇ¯Ê±×‹Õ·Ô²Ã—×¢Ç°Ï¸Â·Í¶Í§É†É³Ã»Ó™Ð–ÑµÉ”Ê®Þ®Ë„ÌˆÇ‡Û¢ÇšÚ¼ÆžÉªÉ‰ÜŒÐ…Ïà ˜Æ½ÇœÉµË¶Ï¹É¾à¬¡'],
                    'encodeOffsets': [[
                            35390,
                            -11796
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'MYS',
                'properties': { 'name': 'Malaysia' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@Ã Ñ›ÖˆÄ¶ËžÎˆÈ˜Ã½Ó¸Ô“ÎœÖ›Â¶Ö£Ä™Ï¡Ä†Ë¿Ã–Ó»Ì’ÉµÍ¤Ý‘eË³×«Ã‰ß‘Ø®à¦µÚšÄ¯Ñ’ÓŸÖšÅ›Û Ì¡ÒœÄ Ø”ÈƒÎ¤Æ¤Æ®ÛˆÏ'],
                        ['@@Ø£Ë¹Ü¯Æšà¥±@Ì…à¥—Í“Ì‡Ñ™à­ŸÛ…Çµß‘É¾Ð•Ã³Ó©Ñ‰Õ›Ã’Õ§ÇŸÖ·Ó†Æ•Ö˜ØœË½Ù®Ç€ÇœÜ†Î¬Ç‚à§–Çº×¾Ú”Ð¬ÕÏ¦Ñ¥Ç®ËºÐ’Â¸ÕœÂœÐ°Ùª×ÑˆÚ€Í¼HÑœÑ‹ÂžÎ¹Ö†É»Û¬Ê§Ã‘Í¡ÖÂ¥Æ®Ð§']
                    ],
                    'encodeOffsets': [
                        [[
                                103502,
                                6354
                            ]],
                        [[
                                121466,
                                4586
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'NAM',
                'properties': { 'name': 'Namibia' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ø±ÙŒÍ¡Ø–Èƒà ŠÈ·ØŒË¯à²’mà§’Å…ÒžÍ›ÎŒÑ¡ÛœÑ³à§˜Ç½Õ†Ûƒà Â»Ù¢ÐšÇ†ÔŠÆžÕ°}Ô„ÏÅ¶Ãâ‚®Â˜×ŒÐ•áŽžÅŸà»´Î‚ÛŒÈ’Õ°ÂµÍ¨ÈPÃ©ÓÈÊ­CÕ›Í£ÍÎŽà²•ÌØ³Âƒ{á²½à £Â‡Báž™Aá·‹Ý£Ñ•Ò‹Ã•Õ‡Ç„Ï—Ã”Æ—Î¬Í©É°Ð“Ð³'],
                    'encodeOffsets': [[
                            16738,
                            -29262
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'NCL',
                'properties': { 'name': 'New Caledonia' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÛÔµÑ¨Ï­Í‰È«Ò¥Éª×¹ÏšÕ§Ñ¼Ö‰×¤Å›Ë¶Î²[ÒºË¹Ï†Ë·ËŽÉ»'],
                    'encodeOffsets': [[
                            169759,
                            -21585
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'NER',
                'properties': { 'name': 'Niger' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nÖ¼à¥¹ÈÐžÒ¿ÕºÅ“Ï¤Ã¢Ð¢Õ¢ÂÌ´Ì˜à¬ªÃ°ÝœÆ„Ã®Ô®Ò Ö˜EáŠ¬à®ˆÏ’áªà¿¸á®ªà½¾à³¨Î±Ó€Ò£×¨Ì¸È¸à²¯Ì¾É“`Ë‹Î”Ë½Ç»Î¯Í•á»Â«àª§à©³ß‹Î³à«‰Î”ÌµCÕ¥Õ¢mÄÐƒÊÂµÂË‹Æ»mÖ©à¤‚ÈŸÂ’ÚÒ·Ù±Ê”ÒÂ¸ÊÅŸÓ¯~Ó·Î§Ñ“qà§¯Ñ¢Ð‰ÈµÑ“bÌ¿Í†à¡…Ì¼à£—Ä±É•Ç»ÅŸÓ—Ê‹Í¹ÃÝ£Ù—ÓšÌŸEË­Ê—'],
                    'encodeOffsets': [[
                            2207,
                            12227
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'NGA',
                'properties': { 'name': 'Nigeria' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@à¢Ì¡Í‰Â¬Í“È‰Ú¥lÒ‡Õ‚Ë¡ØŠ×©Ö†ÙƒYÝBÂ¶à´¤sÕ˜Ç‚ÕŠÊ¶Ê´Ð¢Ô´Ä—É¨Ç”Í¸ÈÓ¾ÂËªÃŽÝ¤ÊŒÍºÅ Ó˜É–Ç¼à£˜Ä²à¡†Ì»Í€Í…Ñ”aÐŠÈ¶à§°Ñ¡Ñ”rÓ¸Î¨Ó°}ÊÅ ÒŽÂ·Ù²Ê“Ú‚Ò¸È Â‘Öªà¤Æ¼nÍ¬Í¯ÄŸÆ±Â«Ë§Û½Ù±É›Õ™Å¡Ñ§Ç±È‰Ç×™Ò…Î‰Å½Ñ‹È‹Í¹Ã¿Î“Ö½Ë±Ò½ÎŠÍ‡aÔƒÓ­Ê‘QÐß·É×©'],
                    'encodeOffsets': [[
                            8705,
                            4887
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'NIC',
                'properties': { 'name': 'Nicaragua' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÌƒË†Ï½ÍºÈË²ÎŸË„ÑÏœÄ¤Å¾Æ’ÅµÃšÃ’Ê¾Â”Å€È”Å¬RkÐ®È rÇ¬OÇºÉ¤ÊœÇÄ’Ä¾ÆºÄ²ÌŠÉ´bÇ¦Ä„QÅˆÈªÄ–|ÆœÅ¹ÇšÂ›È†Å„É„BÌˆÅŒÅœÅ–Ë¾iÃ¯ÄƒÂ§È‰ÄÌ«È—Ë¹Ä›Í·ÂÏ…Â®ÉtÏ™Å¹Ä‰Ã½Î«ÃŒÉ›Ç£É‹Â É©ÅºÆÈ©Ç±Ê›ÃˆÆ“Ç¦Ë‰ÃªÈ•Å‰Ö…ÉžÅ³Å‡'],
                    'encodeOffsets': [[
                            -87769,
                            11355
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'NLD',
                'properties': { 'name': 'Netherlands' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Û¦yÇ€Ë³È½Þ“É‡ÍÔ@Æ˜à¢¡Ò¥ÈžÕÏ€Þ©Ç©Ø›Ã¢Ñ É²Ý€à°†à¬²Î˜'],
                    'encodeOffsets': [[
                            6220,
                            54795
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'NOR',
                'properties': { 'name': 'Norway' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@á¥†Ø™àªÉ£à¤„Õ…à·›ÍµÚµÃ»Î¢×œàªƒÍ°à²«ËµÐ«ØßŸÏ‰à£—È®àª±Â¥à¤£Ñ¼Ô‰ÉÔ·Â“Å«Öƒà½“ÆŠÉÒµß­HÖ‡×±à ¿à¤à²«à®Ì¨Ë¹Ì‡Í«à ¯bÕ±Þ¿Â¾à«ŸÕžÑË¥à¦§Û§Ö»Ï…Ó›ÖÔªá€‹à¦à««ÈŸà­Ñ”Ì›à£šË‡áŠ¶ÞžÕ¦á• Û¶á€Œà¢‚à»¤à­¦áºà¾´à¶¦Ù„á˜¼à©Šá‡ŽÏ€àµªÂ­à±®Û¢à»–Â›àºžÇ˜'],
                        ['@@áˆÎ…à¹Èœ×†ÉÔ•ËŽáƒ”ÇšÍ®Ì¿à¯ŠÈ'],
                        ['@@áª–Øµá‘ŸÍ¥Ò±Ø£Ý…ÇÐÛ¡à§£Âá…µÔ¢Þ‚Ì˜à°½Êà¿•Ü‚Ù·Ú„á˜ŽÌœÒ¢Ì‹à®¦\\ÍŠË¼à¯¾Âˆà©–Ì‹'],
                        ['@@à¿®Ìà°Òá±Ä±áŸ™Æ–Æ«É´à®¹dà¤Ï¬á£´É¼à¯žÈ«à¡˜Ê¤á‘ºÈ½']
                    ],
                    'encodeOffsets': [
                        [[
                                28842,
                                72894
                            ]],
                        [[
                                25318,
                                79723
                            ]],
                        [[
                                18690,
                                81615
                            ]],
                        [[
                                26059,
                                82338
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'NPL',
                'properties': { 'name': 'Nepal' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÃÎ±ÅŒÕ•Ä©Í©Û©aà§ŸÈžÙ­Ä‚Ó›Ñ’à¬·ÅŠàª¯Ò¼ß‰Ð®ß¿Í†ÍœÞ¼Õ’Ï Î’ÈªÚªÊ³à¡”Õ·Ò¾Å¥Ë°Ð•Ù¶Ç“Û€Ïƒà¥ŒÈ•à¦”Ä‡'],
                    'encodeOffsets': [[
                            90236,
                            28546
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'NZL',
                'properties': { 'name': 'New Zealand' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@È’Î‹×°Í¾ÊÎ¡BÎÌ¹Ï³Õ¹Ø¥Ñ—Í·Ì´Ð—Ù­YÜ—ÍƒÉ£Õ»Ó‹à¡—Ú‡Ï“Ð½Ê‡ÞlÕ­Ë¢à£±ÃÆ—Ì°ÒŒØ°à©à ¦ÕªÇ€×¾ÍŒÜœÑ°ÔŽÑ¦ÏŽØ¸ÍˆÉ†Å°Ò¶×œÏ´È†Î§'],
                        ['@@ØŒà¢«lÖ¸ÏœÉ¯Å²Ù‹Ú°Ë›Ö¨Ã£Ó’ÍŽÑŽÄ­È¯Ý—Ê¯Ó«Ù›jÉ¡Ê­Ã¾Î±Å«Æ»Í…ÒÐ·Ö¹Ù­Í¯ÆŸÉ˜Î•Å¨ÓžÛ”ËŸÒ¨à£›Í²zÌ¦ØˆÌŒÆšÙ¨ÂŸÕ¬Í»ÖœvÆªÐ‘ÎŽÚ‹Ý”Î—×ªÌ¸Ã ÒšÒ±ÙºÉ‘Ê‚Ý¡']
                    ],
                    'encodeOffsets': [
                        [[
                                177173,
                                -41901
                            ]],
                        [[
                                178803,
                                -37024
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'OMN',
                'properties': { 'name': 'Oman' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@Ì»Ö¹ÏŸÂªÇ©È§Æ‰ÑÄ¼Ö—Ã¿Ä»Ï¯FÔ½Ì»Ä‡Ð¥È“Ç¯Ô¹PÍ¡ÉƒJÍ»ÐŸÉ·Ò©Ä‚Ö—Ë³Ï±Â³Ë×˜Ù¿àµ´á ¾à ¾Ö–á‚Ï©×ªvÍ¸Ê”ÎFÎ†ÏžÇ’Æ©ÅžÃ¨Õ´Ñ–HÏ–ÖµÒ¸Ì§ØžÅ‹Ó¼Æ³ÏœÓ•É¨Ë§ÌžÅƒCÈ‰Ì©ÔƒÆ…É½ÎŸË'],
                        ['@@Å‰Æ³Ç…ËºÊ”ËºÄ¾Ã±ÄÎ']
                    ],
                    'encodeOffsets': [
                        [[
                                60274,
                                21621
                            ]],
                        [[
                                57745,
                                26518
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'PAK',
                'properties': { 'name': 'Pakistan' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ØªÏ»ÊžÙ¥àµ¨Í»ß¹Û·à¤©Å¯à±£È²Ð«Î±Ì–ÝÌˆÖ©Ú´Ð³Ü‘ÓŸ`×³à ƒà¡‡Õƒà¡à¢à¢¡à¦‰Ãšà¤‘à¢¡Õ¼Ï—ÄªÙ§Ò¾ÑÇ˜Üá‡›DÖ“Ö•Ø›É†Ê£Ø€Ù­Ù˜à»»Çà´¿eà®ƒÅÍ„à¦Šà¯ŠÑ¢Ã©Ï°Ð“ÆŒwÝŠß¥Ï†Í·Ô”ÐµÑ¶à¶¨Ñ•à¡€Å²ÔˆÅ…ÇžÈ‚×’Ã³àª¦Î”ÂˆÜŽÒ¶ÓˆØ´CÄ É¼ÙžÅŒÌ´Ã½Í¢Ê€Â±ÔŒÎ¦Ô–Õ˜É†Í¥ÖŠßœÉ´Ì¢Â•Í’Ð¼ÎœÄ©Ð¼È£Î¤Ó¬Î¼à£˜Ç®à¥®Ä®ÑÆºÓ¨Ä¦'],
                    'encodeOffsets': [[
                            76962,
                            38025
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'PAN',
                'properties': { 'name': 'Panama' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ë«ÊŽÇµÒ’ÈºÉ¢É…ÃŽÆ¿Ë¤Ð»É¸Î¿ÃÇÌ‡Í»ÉÇ½Â‡Ä‰Ç©Ð’Ò—É¯Å…Å§Å­Ï·Â©Æ¡ÔˆÅ‹Æ›Ë¡Â¸ÇÍ¸Î‡ÃˆÉ“Ä°Î­CÇ»Ä©Å¶ÂªÇ–Ã¬Ç ÂÆ²Å²Ä²Ç©Å²KÍ¸Í˜Ã¶Ì ÌiÇ±Í²Â›Ä€Ã¦É´ÈµÐ®Ã”Î¨É„ÔœÇžËºÊ¤Ò¬Â·Â‹Ä‰Ò¶Â…ÏŽÆ¡ËœÊ§Í„ÉµÄ¹Å«ÈœÓµÇÊŸË“Ã’Å…Ð¡'],
                    'encodeOffsets': [[
                            -79750,
                            7398
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'PER',
                'properties': { 'name': 'Peru' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@É¥Ñ™Ñ›É‹à¡…Ó˜Ã±Îˆá€›à¡Šàº—à£¾Ù«Ô°ÎÛœÆÊŽÜ…àª¾à £à¼„ßá€®Î…Ï¤ËƒØ¤Ù·Õº×±Í¼Ë–Ï’ÐŸß¢Ê¼×šÚ¢ÕŽÄ²Î“Ê‡È§xÌ­ÎŽÃ¢Í¼ÄÎšÑ‰Ó†ÎŒÇ„Ö¤Ô¦Ü¶à§ Í¨à£¸à¢ Ê¾Õ´ÅÙ”É¢Ä‚Ö’Ð‰ËŽÐ…Ï´ÉÓ¶à¢£Ø¶Ä¿Ò¨ÉžÌ¤Æ£ÔŽÃ°Ù Ï½Õ©à¡£Ê¤oÑ€ÒÝ³Â Å“Å³ÛÇ‰à¥¥Ö±Ã“Ï»É‰Ì‡ÄŒÒ“Ô•ÊBÎ¡É›ÆµÎ”Ý³Ò²ÔÇ±Î¯ÖÂµÍ†ÒƒÝuÛÓ¸Ã‡à±§Ï¢Ä©Ó„Æ Üªà´ŸÇ·ËµÂ£×ŸgÜÍŸÐ¿Æ®ÌµÈ•Ë¯Î²Û¹Õ‹à£¡'],
                    'encodeOffsets': [[
                            -71260,
                            -18001
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'PHL',
                'properties': { 'name': 'Philippines' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@ÄÖÂºÒ½Ë¹Þ‘Ì«à¡¨Ï½ÑËŽØ¥Ê‰Ï¿à¦©Ó¦É¿ØŠÊ°ÐŽÕ‘ÐˆËÎ‘ÐƒÂØ«ÒµÆ‘Ê–Í¢Û¾ÕŒÊ€ÒœÍ„Ì”ÏÙ”É°ÆŽÏ’×¨vÂ·Ù°Ú¼Ð‹ÃªÑ…ÃÌ±'],
                        ['@@ÌŸË¡ËÕËƒÊÔ«×ˆÇ¦É¤É‚É¾Ä¢Ô¸Ò¨Â¸Æ‰Ö£Ø¬ßºÄß¡'],
                        ['@@à«£ß•Ð¬×˜ØˆÔ°ÔŽ×ŠÑ°à ²Æ®Û…Ö‡Ò§Ñ³Ö¿'],
                        ['@@ÔŽÊ¹Õ˜BgÎ—Ï³Î£Õ•Ê§Â‡Ï¸Ã’Ñ”Å½Ð'],
                        ['@@Ê€à¤­Ù«ÉžjË­È¶Ô¯ÐÈ‹Â•×¢Ê§ÂªÆÔ˜Ó¶Ã£YÍˆÔ£Ùœß®mÉ´Ì»'],
                        ['@@ÉŸÜ©Î­Ð¾Ñ“Ù˜ÜšÂ‰ÌˆÌ¡'],
                        ['@@Ô®Ê‰Ê¶É–Ã¼É‡ÆÎ‘Ë¼×»É›Û¥Ó·Ë¥ÆÚ³ÈŠÚÑ¾Ä¡ÏŠÄ²à¨¾Ò¯ÄƒÒ™ËœÈ«Ä“Ï¯Ù»Ð®ÌµÑ´ÉÌ¯Õ—ÔŠÞƒÅ¯Ð»È†Â¨ÎŽË€ÉŠÊ£È˜Å‡Ì¡Ð±ÓšÅ±Î¼Âß¨ÍºË¡Ä”à³„ËœÞ€Ô˜A']
                    ],
                    'encodeOffsets': [
                        [[
                                129410,
                                8617
                            ]],
                        [[
                                126959,
                                10526
                            ]],
                        [[
                                121349,
                                9540
                            ]],
                        [[
                                124809,
                                12178
                            ]],
                        [[
                                128515,
                                12455
                            ]],
                        [[
                                124445,
                                13384
                            ]],
                        [[
                                124234,
                                18949
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'PNG',
                'properties': { 'name': 'Papua New Guinea' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@É½ÄÎµÍ”ÏÕ”Ç·Ù˜ÅœÄ†ÄœÊ¡Ê¬ÈÐ Õ‘ÐˆËµÅÉ½'],
                        ['@@Ñ¯Ã§ÆƒÉ½ÒŸÈ±Ñ›ÈŸÑ½BÛÊ”Ó‘ÉºÃªÊºÝ¬Å©Ò Ã Å¶Ð–Å¦rÄ†Ñ½ÓÃœÊ‚Ë¼Ò¸ÌšÄ¡Ó¸ÔŒfÇœÆgÒ¯Ë¯Ô¡'],
                        ['@@Ý¤Õ¿Õ²à¢»Ó–Â„Â‘Ï‰Ù¬Æ›Ê¥Çà£€ÎÄ¡ÊÖ‹ÃÈ·É”ÜŸÄ¦à¡•Å´Ù·ÕšÓ‰Ò¦Ñ§Ý€àª­Ï€Ü‡Ê‡Ô¡Ë£Å„Ø¥Ú‡Ë¿Ò»Æ–à¢…Â–aá©’aá©’à¸ ×ƒà¼ŠÓ“×„Ñ—Ò´Ñ…Å¸Óµà¶”Ô±È²Ñ½Þ›Ä›È„Ö•'],
                        ['@@Ê¿É¡ÇÓ¸ÈÍ˜ÏËžÓÎªØ‡ÊšÉºÈ®Ò’É»Ë¸ÈÎœÈ«Í´Î›ÍŠËÄ¶Ñ§']
                    ],
                    'encodeOffsets': [
                        [[
                                159622,
                                -6983
                            ]],
                        [[
                                155631,
                                -5609
                            ]],
                        [[
                                150725,
                                -7565
                            ]],
                        [[
                                156816,
                                -4607
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'POL',
                'properties': { 'name': 'Poland' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Î‡ÕœÃ Ì‚È¹Ò†Ì§ÌšÉºÉ¤ÈÑ’Ö¸Ê˜à²¼Ï´à©’Ë´à ¼Æ™ÃšÈ±ß¸Yà¨šÄ§à»¶^ÑšÄ›È¬ÊµÂšÏ‰É¸Í‹KÍ¯Ô‹Ç¡Ê¸Ï³fÏÑ†Ü»Ä›É½Ð·Ä¯ÞƒÛ¥É’Ï—Ç¿Â¶ß™Í”ØÅ¡Ð‡Ä’Ó¹ÇµÑ‡Ì–Î‰Å•Â³Â¼Ï­Ð°Ø±Â¼ÄƒË€Ö»Ä¦Å±É‘Ò—Ç¨Ã€É´Ø»Ã²Ð‰Ë”'],
                    'encodeOffsets': [[
                            15378,
                            52334
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'PRI',
                'properties': { 'name': 'Puerto Rico' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ñ˜ÃµÆ°Ç•É‹ÉƒÙ…LÓ«Â‡Â·Î¬Å¢Å¬ÛŒK'],
                    'encodeOffsets': [[
                            -67873,
                            18960
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'PRK',
                'properties': { 'name': 'North Korea' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÅžÆ¥Í‰ÂºÎ·ËµÊ£Ë·ÂŽ×½Ñ£È…Æ«Æ§ÍƒÊÖ“ÆÎ·É¥Î·Ä¯Ä¡Í°Æ‹ÓˆÏƒÅ§È­Î§Ã‡×¥Â¡ÍÏ›Ï‘ÂˆÃÃ¹Ð¡Ç†ÄµÆ¿Ê™Ã©Â‡Ç€É‘Ã¼É¥Æ†É°Ï†È¤Ä°ÃµÆ¶É†Ò’Ã…ÆŽÓ©Ä Ð‡É¤Û„Õ¢à¤’ÒŒÖ¾×®ÐŽËÜªÂ‹Å¿Ñºà²šÎ²Í°Ò¼ÕªÓ¹'],
                    'encodeOffsets': [[
                            133776,
                            43413
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'PRT',
                'properties': { 'name': 'Portugal' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ì¦ÉˆÎ„Å¬É‚Ð«ÓºDÆžÅ‚ÓªÂ‡É¼ÑƒÏ±É©YÙ½ÆÅ«Â‘Ð‡Î³Ã§Í´Ô‹ÉµÕ¿Ì„Ê¡Å™É«ÌµÌ¿ÃªË¥Í·É“Ñ·Å ÑŸÄ¡Å¸Ú‚Ã¿Ô¬Ï“Ã¾È©ÍˆÃ¤Õ¼Í°Ì¨Ã’Í¼ÇªÔŽkÎ¤Ç™Ì Â™Ë²'],
                    'encodeOffsets': [[
                            -9251,
                            42886
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'PRY',
                'properties': { 'name': 'Paraguay' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Í¦à§–tÒŒÐ–ÝŒà¸²Ê”Þ®]Þ´Ñ—bÊµÊžÒ³Ã‡à¬›à¢²Ç‡Î„ÇÖ¦É©Ç€Ê£Ã¾Þ“Ä°Í“Ì¼Â›Í€ÆŒÌ¢Æ³AÒ¥Å•Ó»Ç‘Ó›ÆÝÞÙ¡Ú“Æ‡à¤»Å¸à¡‘É®à ¢à±¨Å¥Ïˆà¡½Í¢à¨…Ø¨Û‰Å¸à»µàµŒ'],
                    'encodeOffsets': [[
                            -64189,
                            -22783
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'QAT',
                'properties': { 'name': 'Qatar' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã‡Ø”É¨Ñ²É°ÄœÊ¬ËdÓ¯Ç½Ó³ÉµÃ‘Ê«Ç–'],
                    'encodeOffsets': [[
                            52030,
                            25349
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'ROU',
                'properties': { 'name': 'Romania' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Î´Ç¶Ô´Ä¡Õ GÏ¸È³ËºÅºØ¨Ä„É„È Î @Ê°Ä‡ÊºÊŸËŠÎŸÓžÔÂ€ÏÄ—Î©Æ°Ï¥Ï’Æ¹Ð‚ÆŠÏ ÆŸpÉÐŸÇ¹Ê¯Ä€É»à§¥Ó³Ä–Ø‘Ìªà¦«È›Ð·É‹à¯½Â¬Ù¥Æ€Í™Ã•ÊÎŠÆµÆ¦ÈšÆ˜È·Å€ËƒÈ‹Ó©Ê”ÃŸÎŒÔŸÈ¢Ä¥ËŒÒ•Í¤ÚªÇ‚Ô–Ö®ÐŠÖ¬Ô¢Ç®'],
                    'encodeOffsets': [[
                            23256,
                            49032
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'RUS',
                'properties': { 'name': 'Russia' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@à¡Œà¹«à°•Ë¤Ô«à¯à Œà¡³y×•ÙÔ’Õ½Ù±Æ»Û¸Ä¤à ŠÄ§à£¢ÈšÙŒÂšà«´Ó¯à œÃ´à¬°Þ¦Ï®Í­Ï´ÏÅ É”Ö‰Ì†ßµuà ŸÎŽà¡‘'],
                        ['@@à»µ]à¨™Ä¨È’Ï„à­ŠËšà¢¢Æ§ÏˆÆƒÄ™É±Ã¤É‰'],
                        ['@@Ö¦È½È›Øá—¸Å±à¿¨Þ»à ­Î»àµ›Ä“sà ‘Í³Ç©Þ½~Ù—ÌŠà«£Ê–È‰Î¸à¡ŸÆŽà¥—Å‰Ò—ÌŽÇ¼Ì¸à§“È¥ÏšÐƒÓ‰Î£@â€žášÙ›á”ºà ³Ã¯Ô·'],
                        ['@@à¤ƒÂ©Æ­ËŒà©²Î–@Ö·'],
                        ['@@àª³Â»@Ö¸ÅˆÂ–ÜˆEà¯’Ê‰Ã¯Å—à¡½È©'],
                        ['@@à±¡Má‚£Ä¤Æ§Â¬ß˜Íªà©€Ã¾à®žÍÄ¸É™'],
                        ['@@à¥¿Í©à´‰Ã¸à¼›Í¨ÈªË–à¼¨Å³á‘”É—'],
                        ['@@Ú‰Ø±á¶½zà¶ƒÈ£á€™Õ²ÒŽ×€à«ŽÇ‚á•žÂ™á´¬Ñ½'],
                        ['@@Ó¹Ã³á©£ÅŠÉŸÏŽàº¹É¦Å«Ò’à¡®Ç¶Â…Òžá€žÜ’Þ™Äºá¨Ý†É©Ï¢áˆ¤ÑºáªªÕ¢á« Ç€à·´Ì¸à¿ÅŠ×Í©ÖŸÊ»á²—Ð·á¢­Ðá¤™ßà°«à à³‰ß±Ç Û¥à¾ŽÛ'],
                        ['@@É¨Ð³ÞÈ²áž¤Yá‰ˆÐ§Ú¬Ì¿È½Ñ§à¤™Êá•…Ò¯ÙÊŸà¨¬ÅŸà°–ÉƒÝ´Ç„Ñ”Õ¡Ï„É”à´ŠÆ‚á§ªÆ‘È´Ï½â†²Å¯Â´Ùœá„¼Æ¥à´„Là´¬Ñ·Ï®ÕÓ¹Î™à©ŒÚ‹à³”Í¿ß¸à¢¦à´–Ï™à·¢É¦à¾¼ÊµØ¤Ê€àµ–ÅŸØ…Þ®à«Î¶ä¢€Õ±ÜÓ¿á”²Ù›â‚ŽÇ„á€¬Æ‘ÛªÎÄ¹Ø™à¨œÊ‡à«´Ç¤à¹°và½šÇ‘à½ªÄ¢à¸°Ý›à¨ªËŽÚ·ÕžÏÏŽá§†É»áƒ¤Âºá‚Ð‘à­²Î½@â€MKàª‡ÏƒàªÃ–Ý¶ÒÔ„Û•Ï²É§Ä®ÎÉ‘Éà¼§Ç¾ášÙ…Ý›Ä­à±½×Ÿà¯›Ô§Ì±Ï£à®¯×Šá”—Ú‡Ï£Ì¸ßµÎ«à«±Å˜Ë“Öà§™ß½ÂŠÍ»à¥œÈ‹Å‘à¯£Þ­Â‹Î«Û±Î”Î±à¸½Ñ•Ì…à¥¡à°­È³Ê¥à¡Ÿà¯‡Þ³Ì³×‚Î­à¯¬ÒµáˆˆÐ˜à­˜Ü€Ô†ÂªÏ¾à²°ÈŠàºŠà©’à¸„à¡ºàº¢Ú¢Ú®à®†à§·Ã«ÔÛ—á’‰à¤‡Ûà¨–á“§Ë·á‘ƒà¶§ÛšÔ§áˆ™É•à²Ä“Ã”ØŠà²¯Å¶à¨©Ð­á¢µÆ áªÊŸá¨©à¿›á»§áŒà³šÅÐ°Õƒà „È…ÕžÐ¾à¤ˆÃƒà¯Œà¤Â†ÜÚà ½Ã«à§Ï›à´‰à±à¯“Ë¯×‡à¬™à¦‘à¬‡à¥»Õ©Ó¹à«©Ó±Õ‰YÕ‡Ð¤à«»Ø™Å¿Ë©ÅÆ¦KÑÑ–xÅ¦à¦´É›ÜšÜžÌ’à§¶Æ©Ö¢à ˆË¾à¤„ÍšÌ®Ñ´Ý²àµ·Ê›Ü¯Í§à±§DÍ»ß„à¦¹×°à¸«ËŽÌµà –Ì‰ÔªÌ¿Î²Ô¯à¡Ý‡Ì²à°·Ê¢à«›uà¨¯Æ±Û›Ð»Ò¤È¥XÒ©Ò±Ë‘Ý·à¢»RÏƒà®…Õà§™Í„à§‹Ã©Ñ¯Ë®Ô‹Äžà¯·×£à«‡Æ‘Þ›È»à©‘ÆŒÞ«SÔ™Ñ–à •Ð˜à¡…ÅŽà©Å‹ßÆ¹à®›ÎœÇ‡Ù€à¦§ÉŽÞÄ°à¤µÎŽà¢‰à¢‰Î€Óµà ‡×‘à¯É‚à »ÂŠÖ—Ï¾à¢™^Ü³Ê´à±«Ðƒà¾ƒÜ£à¢­Æ¡Í¡Ã§Ñ½Ô¤àªÅ‘Î§Î¦×—ÇŒÐ™Ó Ò©Æ°à®¿Éà­ƒÓœÒƒÑ¯áˆŸá’’à©µÙ®Ì®Ë‚á‘‹ßß­Â³ÃªÒžàª…Ëºà¢™È±Ëƒà¢Šàº¡ÇºÝ¯Î‘á‘…Ì³Ð§È¹á¸­Ì‡Ï«Ë»Ø†Ö¹ß­É“Ç€É­ß­Ð¥à´¸Ö¿ÉÐ‰à­»Â˜Ê“ÊŸà©¹Ñ¦à³¯ià¢»ÎŸà¦¹Í¼á‡¡×Šà²½sáƒƒà£³Ä¿Ø—à¡¹Ó¤Ú¡à¤‰Ê–Ç¡ÓÙÜŠÖ«Ø°xÕšÖ—ÄÑÑÆ‹Ï¥Ó½ß¿Æ‘à ³à¢Þ†ß•Ä‰Ö£à£¼à¦«Ô‡Í¹ÆÉ‡Ï‰ÃŒÖ¿ÔšÉ¿Â†Õ…ÈšÊ³ÎˆÞµÇ®Ô™ÆÆ¥Æ¼à¬¥Ð–à°…ÆŒÜƒÆžÄ¹Ä±à©±Ü‚à¥ŸÍ„Ü©Ó´Ø’ÆˆÛ¤Û°Ò¹Íªà°ŒÎ„uÈ€Ý¯Æ‰Â‚ÏŽÑ É¼ß¼Ã–Æ„ËªÈ…ÒªÎ€Ñ°WÊšà°‰ËšÓ­UÔ¯Ð€Ù¡Æƒà©©ÌlÇ’Ì—Î¸ÚŸÂ¤Ã©Ê¼É€ÇžÕÓˆà¢‹Ä…Ê­Â¦ÉƒÈ‘Ì½Â”È·ÕžÈŸË¨ÇŠÄ€Ú´Â‡ÍžÈ€ÊÉ¢Ö¥ÆªÂ¼Æ²ÎÆ´ÕƒÕ¾Ç¸É¨Ä‰Ð‚à ‘È¨Ñ±Ä³Å¡È¼à¢­É‚Ë‘Ó¸Ã­Ð¢Ð™È–Î¬ËŠÊÞ¶×°ÓžÅ³Æ¤à¥˜Ò¬à¢¡ÐŽá…¢à©¶Þ®Ó Í‚Ñ”à°—Ö¼Î†Õ¶Ý³Ø´Ö¢Üœà¦à¥šÞ¢ÙŠà±¿Ö”Å¬×šÚ¶Ã¼à·œÍ¶à¢€Ìˆàµ¦Ô•á˜¨È§á¹ºà¥‹Ù¤Ð‹Ã†Ö“à¤ŸÑ³àµÉ¡â·Ù”ØŸÅƒàµŒØ›Ã‚ÏµÃ†à¡«àªŒÊ¯Ú‚É“ÅˆÐ Ô‘Î°Õ˜ÍˆáŽ–Ô¹Û¾È²Ö£Øœá‹¦à –Þ¢ÂµÞ¸Ì‹Óª×€Û«Ô„ÐªÔŠØ¡Ô¶áš Ë‘Ó”Ò¹à©¡Ä»NÒ³ÚŒË½à²œÇ¼È¶Õšáƒ¶Ðá°ªÜžÙŠÂ£à £Ô™à¨¬Ä•×¼Ë¼à¼¾xà°¢Îà¥žÔà¥–ÖŒà¢¡Ó¢ÑªË¤áŸ¢Ê«à­’Ê¿á´¾à¥£ÖšÑ°à¡¡Ñº{Ç´à§£ÄˆË¢ÐŒÒ…Ù¼}Ëà¼„Ý¾Ö€Þ†Ø²Ç’á•®É›Ç¬Ò±ß•Ú½ÔºË‹Ë’×—Èà¬µà¤’Ô§Î­Ö•à¿«à®à¥¦Å­Í®Ì¢à¤ŽÉŽÉžÐ¶Ü®ÐŽÓ©ÓŒÏ¼Öˆà£¿ÃªÈ«Ò²Ú¢à¡ˆàª£Û†àº’Ö¦È™×°Ð¼nÑ´Ò¯Í§ß·à£ÆµÏ¥Ø„à¶¤Í¦áƒšÂ¬à¼ˆÓÝ›ÛªÄ‹à£†à¸¨Çžá¾Â™á†˜ÅŒÛÑ®à¦‚Ö‚à¥²xà¿ŽÐ¸á• ÅËªÉ²á•‚Ã¾ÛŒÈ‹áˆ´Ò€à»²aÉ¶Î´ß¤Î¨áŒ¤Îˆà·¸Ë—à¬¥È·á‰ Å¹'],
                        ['@@âµ™Í•à»žà«€Û’Ä¦Ù‚Ãƒá’ˆÓ‹ÊŸÍ¿'],
                        ['@@à«½ÅÝ±Ã›Å›Æà¦™Æ‘à£«È¦ÓÊ¾áˆ~à¿žÆ¶à±¨XÇ¢É§Ó˜È¬ßŠÆà°žÇ¿Í—Å·'],
                        ['@@á†³Ä¿áš‰ÊŽà¶…ÍŽÙ£×¾à¬©Ç”á”†Ö¸á†ŽÈŽà¿ŒÑ‡áŠ¬ß»È¹Ý¯']
                    ],
                    'encodeOffsets': [
                        [[
                                147096,
                                51966
                            ]],
                        [[
                                23277,
                                55632
                            ]],
                        [[
                                -179214,
                                68183
                            ]],
                        [[
                                184320,
                                72533
                            ]],
                        [[
                                -182982,
                                72595
                            ]],
                        [[
                                147051,
                                74970
                            ]],
                        [[
                                154350,
                                76887
                            ]],
                        [[
                                148569,
                                77377
                            ]],
                        [[
                                58917,
                                72418
                            ]],
                        [[
                                109538,
                                78822
                            ]],
                        [[
                                107598,
                                80187
                            ]],
                        [[
                                52364,
                                82481
                            ]],
                        [[
                                102339,
                                80775
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'RWA',
                'properties': { 'name': 'Rwanda' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Í¬ÓƒÂµÓµÊÅÑ¿Ã†Ê±ÓÔ›Ã Ã¾Ò Å˜ÃžÂŒÔ„ÊŽÉºÈ°ÄÔˆÊ¸'],
                    'encodeOffsets': [[
                            31150,
                            -1161
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'ESH',
                'properties': { 'name': 'Western Sahara' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@oÒŠÅ¸@@Ã‰eÇ‹Eà±áªÂªÂ‚á’·Þ¿Ã·È³Ñ›Ç„à¯á¾“NÇ½Ë«Â˜Î¢bCá‰†Ã¤Ä¶Ì¢Î†Ï˜Ë¤à­Œà­ à£¢Ð‚à©–Ë€Ã–ËœÙ¼ÛºÄœÌ¦Å‰Ï¢@Ë”È’Ô²Â‚'],
                    'encodeOffsets': [[
                            -9005,
                            27772
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'SAU',
                'properties': { 'name': 'Saudi Arabia' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Å‰ÎªÊ©Ê¨ÃÍ²Ñ¡ÌžÒƒÛ´ÊÛ†×‡×€Ï‘ÆÖ‹ß Ä«×Â–Ó¾Ó•à¤žÏ¿Í Ò‘Ç¨Ë¡Ó–Â°ÈŽÉ¹Ñ¦Ê•ÈŠÍØ²ÔŸÚ´Ñ“Ö¾Ð»IÅ¾Ò¦ÂœÌŒÄ¼Í²à¤¨Æ…Î¶Ê¶ÈªÌ¢ÙšÅšÆ’Ë®Ë¤Æœà ·à¡€á†Ñ„Ç†Å´à§¢É©à°¬×™á›Žá•à¼ Ã£Ý Ä…È¾Ð×ªvÍ Ü¥Ð°È“Æ ÌÖ´Î›Â¼ÎÄ‹Ë©Å‚Ë¯ÊŽÉ½ÅËŸÅ²ÈµÊ¬Ç•É¶Ã’Ç†ÍÂŽÈ™Íà¡™á¡ŒÑ‰ÇžÇ²Ïª×©Ö•áá ½à ½á‘Í‘Þ·Ï™×»à¢¥Ï¹Æ•ÉË¬ÍÂ§ß»ÄŽÆ·ÄŒà¥¹mÉ«Ã¹Î‰É”ÉÐ­Ä’ÎŸÏË‹'],
                    'encodeOffsets': [[
                            43807,
                            16741
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'SDN',
                'properties': { 'name': 'Sudan' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Å›hdÐ¼ÄµÌ€ÑŸÍ¨ÄµØ„Ä¶Ø¨Ï³ÃŒÃÈ‡ÔÂ©È¬Ê•Ã°ÔÒ£Ò£Ð»Ø…ÑŸÄ‘Û¹ÓªÍ…Ç¥Ä‘Ê“ÑŸÇƒÂ…Ç¥à µ@Å™Ç¦ØƒÂ†Ì¡ÆÉ³Ã®ÑÓ¬ÆŸÉ²ØƒÅ—É±ÏµÉÝ£Ë¿ÇÊ³ÄŸÃ¥Â Ì…ÊŽÃƒÊ¼ÆŒÎ”EÎ„Ó›Õ€Ä©Î¬ZÈ°Ì±ÊœUÓ¦Ç­Í–ÌÂµÄŽÌ°É’Î–Ä§ÎË¢Ê´Ç«ÈžÉžÔ°Ï¨Ø¦Ü¦ÃÂ¥â€‚ZÎšà¥²H@á€¸âª@á½Š@á¿¼@Ë”à —ÈÆ³Åªà¡»Ì°à§ÍŒÈ·Ò Ì³Ñ‹Ó‘Ø£ÆË…Ê³Ä‰Ö‘Î±à¯¿ÄšÍ³Æ…ÜŸÍ¿à ŸÔ“Ð·Î­Ù›ÄÎƒÐ‰É½Êà¢ŸDÄ³'],
                    'encodeOffsets': [[
                            34779,
                            9692
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'SDS',
                'properties': { 'name': 'South Sudan' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XÙ½Å±Ê¯Ñ¿qË·ÓÔ¨Ã‘ÑŽÐ¥Æ¨Í³Ï¦È™Ó¼à£³Ö«Ö…Ô«Ô‡Ô«Ï­×¡FÚ¯ÈŸÕ•ÈŠÎ‹É­Ý‰ÖÈ¥Î¬ÒµÇ±Ï±Ã†É£Æ•Ï—Ä¸Ô—ÛšÆ‰ËŠØ¹ÍªÉ…ÔŒÎ•Î¶ÖŸÑ¬SË˜Ò¡Í¼Ö¯Í Ê´Ä Ì€Ç‚ÉÝ¤É²Ï¶Ø„Å˜Æ É±ÑžÓ«É´Ã­Ì¢ÆžØ„Â…ÅšÇ¥à ¶@Â†Ç¦Ñ Ç„Ä’Ê”Í†Ç¦ÛºÓ©Ñ Ä’Ð¼Ø†Ò¤Ò¤Ã¯ÔŽÈ«Ê–ÔŽÂªÃŽÈˆÏ´Ã‹ÄµØ§Ä¶ØƒÑ Í§Ä¶Ë¿cÐ»Åœg'],
                    'encodeOffsets': [[
                            34779,
                            9692
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'SEN',
                'properties': { 'name': 'Senegal' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÎÙºÐ½ÌšÏ†Ç„Ð ×žÈ¦ÑœË¾ËÐºÃ¯Ð¨Ç¾Ò¶VÐ”Ê™ÖŽÉÔ˜Ø£ÖˆÖ½ÂžÔ¹Ç”Ó“Ì¾É¿Ã®Í—ÂÊ½Å§Â³Ò›Ã¢Ã™Ä£Èƒk×¿È²Ð›Và¼‡Â–É¥Ä§Ë¥Â‚Ñ»Æ‹ÆÙ¢ÞˆkÈ¬ÅžÆ®RÌ¸È˜Î®Ç¯ÎºcÎ¶ÈŒÇÊË¡Æ™Ê»JÍ§È¸Ë‰_ÈÈ¥à£µy'],
                    'encodeOffsets': [[
                            -17114,
                            13922
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'SLB',
                'properties': { 'name': 'Solomon Islands' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@É¾Ë¿×—NÍ‰Ô¬ÔˆÈ¯ÇœÂ‰'],
                        ['@@ÍmÔ§ÄŽÇ«Å¼Ã€Í®ÖˆÆËœÇ­ÆŽÉ™'],
                        ['@@Å³Æ¹Ø­Ü°Ç«ÔˆËº@Ì Ú¥Í´Ð—'],
                        ['@@Â–Ç›Ú…Î¦ÒŸÌ Ì¿ËªÅ°ÄÏ®È«ÛÏ­È¢Ë‰'],
                        ['@@Ç—Â³Î¿È’Î‡ÎŠÂ¨Æ–ÔˆÎ¡Í°Ë›']
                    ],
                    'encodeOffsets': [
                        [[
                                166010,
                                -10734
                            ]],
                        [[
                                164713,
                                -10109
                            ]],
                        [[
                                165561,
                                -9830
                            ]],
                        [[
                                163713,
                                -8537
                            ]],
                        [[
                                161320,
                                -7524
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'SLE',
                'properties': { 'name': 'Sierra Leone' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@É§Ã˜ØÍºÑ©ÒˆÆ§Ì¬Ä¹ØªÒ†Ï„Ä¬ÉºÆžÇ¸É¶pÈœÇ‚Ú¦CÉºÌ›Ç¼Î›ÂÊ“ÆˆÉ—UÌ­É´Â´Ï¹Ï¹Ï›Ò—Â«Ê“È©Ë'],
                    'encodeOffsets': [[
                            -11713,
                            6949
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'SLV',
                'properties': { 'name': 'El Salvador' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ä¡È¡Ó¡^Ì¡Ä„ÎÇ˜Ò±Ã€ÊƒÇ¶~Å®Ë¾É„Ç€Ä¢Â«Ä²È Â¾ÊœÃ«Ç¸Ç™ÊªÆ‡ÂŒÅ“Ï„Ä´Ç¤Ã‘Å˜ÄÃÍ³'],
                    'encodeOffsets': [[
                            -89900,
                            13706
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '-99',
                'properties': { 'name': 'Somaliland' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ï›Ô©×“Û«Û¹Má©§à¦¾ÍÌœÌ³ÐšÌ³Ò¨Ç¾Ì–Ì²ÒˆËšÆ¹Ç’ÎÏœÎ—ÐºGßŠÉŒà£´Ä´ÝŒÊ¼Ð¸Ã†ÌšÆ¶ÓŽÂˆKaEÎ‹Aà¡‘@Ñ«'],
                    'encodeOffsets': [[
                            50113,
                            9679
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'SOM',
                'properties': { 'name': 'Somalia' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ñ¼ÄŽÐŠË¾ÍˆFpÉµÃ½Ó§HÑ³Ç¯Ì£Êà£¥Ð™à¤¯Ô±à©·Üà¯·Ü“à¤µà¦§à¬©à¡Ú¹à°·à ¯Þ³Ù•à¤à§±È—Ñ·ÈÈ£Ó½ÛšWáµ¤Ü¾à¥’É°Ë†Õ¢fÝ ×¤àª¬Âšá›œá¡„×”Û¬ÏœÔª@Ñ¬Bà¡’FÎŒLbËhÏ°Å°'],
                    'encodeOffsets': [[
                            50923,
                            11857
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'SRB',
                'properties': { 'name': 'Republic of Serbia' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ô È¡Ã Î‹ÓªÊ“Ë„ÈŒÈ¸Ä¿È™Æ—Æ¶Æ¥È·ÈÃ¸Ì«Ð¢Î³Í‹Ê¿Æ—Ë‹ÄžÄ³Æ‘Å¡Ï³aË¹ÂµÂƒÃ˜Ä´Ä´Ä¦È´Å¡KÇÆ¼Æ‘Â Å‹Æ†Æ½Ã€Å¡Å Æ¯Â±Å›Ë§È©Ã‘Ã¨Ã°Í‹Ç¨ËŸÄœÅ«ÅœÉŸÆ È¢ÂšÅ¬Ð„Ð›Í”É€Ï„Ì¥EÍ”Í„Ë‰ÊˆÈ±Í˜Ù¢ÉšÔ¾Â™Ò–Í£Ä¦Ë‹'],
                    'encodeOffsets': [[
                            21376,
                            46507
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'SUR',
                'properties': { 'name': 'Suriname' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@à§”Ç™ÄžÆ°Ú¶Ã”à£šÉ¥Ñ©ÜŸÃ¢Ö¹Í¤Ó½Æ¥Î¯Ã³Ï©É‰Î›Ó“Ç²Ð‡Ä‘Í¹Ã¶ÄÊÆ˜Ç—Ã·Ç¡Ò™Ã¨Ô¡Ü´ÅÓ„ËBÏ‰ØÆºÑ Â¯È¤ÔœÉ–ÆˆÝ²'],
                    'encodeOffsets': [[
                            -58518,
                            6117
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'SVK',
                'properties': { 'name': 'Slovakia' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â´Â»ÎŠÅ–ÑˆÌ•ÓºÇ¶ÐˆÄ‘Ø‚Å¢ßšÍ“É·É“ÇÍ¹Ç³Ä‘à£‘Ê®ËŸÂ»ÈŸÈ¡ÐÄ¿Ä›Ã„Ð¥Å½Í­}Ã£Ç™Û·Ä»Ì±Ä Ñ‘ÉŒÄ‹Ì†Ã¤Å„Å¢È‚ÏŒaËºÄ”xÃ¾ÇˆÂ¢Ã†È’È–Â˜Å¾Æ°Ê¢D'],
                    'encodeOffsets': [[
                            19306,
                            50685
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'SVN',
                'properties': { 'name': 'Slovenia' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÛœÃÑŠÈÜ¾tÇˆÆ˜Æ˜UÇŽË³ÚÉŸÄ‡Í¹Ì‡Ä‘HÉ»Í£hË·ÆŽÆ·Æ™×‘Â†ÈˆÃºÈ«Î¨ÄžÐ°'],
                    'encodeOffsets': [[
                            14138,
                            47626
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'SWE',
                'properties': { 'name': 'Sweden' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@à ×•Æ€Ô¥à³¹Ú­à¾±Ü¡Ø“à®ƒ×²×£ß¦Ò¯Þ—à¥…à¢‘ÈÍà¶­Ó‹Þ¿à§³Ä†Ó…Ú—à¦ƒÂË‰ßÛ³à¥”Ù“à®Ï†ÓœÛ¨Ö¼Ë¦à¦¨ÕÑŽÂ½à« Õ²ß€à °aÌˆÍ¬Ì§Ëºà²¬à®‚à¡€à¤žÖˆ×²ß®GÉžÒ¶à½”Æ‰Å¬Ö„Ô¸Â”à«ªÐ©à²¼Ö±và²‘Ë´Í›à¸ƒÊƒ'],
                    'encodeOffsets': [[
                            22716,
                            67302
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'SWZ',
                'properties': { 'name': 'Swaziland' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ç¡ÏÓ­Ä›Ô…Ò–SÌ„É°Í€Ä‚Ê”ÊÃ’ÑˆÆµÅ°Ï•Ã°Ï‰'],
                    'encodeOffsets': [[
                            32842,
                            -27375
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'SYR',
                'properties': { 'name': 'Syria' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@à¿©à£…à¤©Í¬gNÅ–Å¶_ÎˆÈ¸Ò ÒœÍ„ÆÍ¤Ï—Â¨Ã¿ÙžÈ¶ÎŒÉ¤È€É¤È€Â°Ò¸ËžÇà¤ŽÉºÒ‚Æ¿Û–Fà¥´Í€Òaà¥˜Å¾Ñ—Ô½Ò¡È¹Ä‚Ø—Í…à§«á‡µà¢“'],
                    'encodeOffsets': [[
                            39724,
                            34180
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'TCD',
                'properties': { 'name': 'Chad' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÄŽÐ„Õ¡nDÕ¦Î“Ì¶Î´à«Šà©´ßŒÂ¬àª¨Í–á¼Ç¼Î°Î“Ë¾_ËŒÌ½É”È·à²°à¡”Ò â€¦à¾‘â€¦à¾Â¦â€Ü¥ÃÏ§Ø¥ÉÔ¯Ç¬ÈË¡Ê³Ä¨ÎÉ‘Î•ÄÌ¯ÌŽÂ¶Ç®Í•VÓ¥Ì²Ê›YÈ¯ÕÆ›ÑÍ½Ø‰à£¹ß…Ï³ß¹Â¾ÊÃ»ÄŠÌÑ«Ì‹Î£ÍŸà©“ÍÈ½ÈÆ“hÆ¹ÉÛ›Ã™Æ€ÉªË…×„ÅŸÎÎ»ÆœÓ·ÓªÇ¼Ð†Ï¦Ä‹Ê‚ÃÒ¸SÒ›Þ†ÂŒÖÃ‰ÖÍ­Õ '],
                    'encodeOffsets': [[
                            14844,
                            13169
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'TGO',
                'properties': { 'name': 'Togo' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ú±Ç³È‡ÌŽÉ¡Õ”Ã£ÐºÈ†Ý´ÉÌ¬ÄƒÚŽDØŽÎ•Ñ Ã–Ë€Ý‚kÅ…ÑµÊ²ÊÌˆÌ‹ÂŽÐ­ÇœÇ¥ÂáŠÈº×…'],
                    'encodeOffsets': [[
                            1911,
                            6290
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'THA',
                'properties': { 'name': 'Thailand' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ý­Ï¬Ü—eÅ¬ÚˆÝ‰KÃ¡à¤‹Ò‘à¯¯Ë™ÝÃŒØ‹Õ¶Î€Þ‹Æ°Ü­Ò¶Ó“ÔšÄ­Ñ¤Ñ§ËÎ‡Ö‡ÄµÃŸÑœÛ‡Ï‚Æ£Æ­Í§Í’ÆÐ¶ÒÓ„ÐŸÐŒÆÓ³ÇƒÒ²Ä Ô¾Êšß¬Ð¢à¡¸Ò¤Þ¶ÍŸÞŒ`Ï¶Ä©Ò¸Ö•ÚšÈ©Ñ„Ì„ÆºÌ®Ü¶Î‡Ö†Õ“Ø˜ÐÝ†Î Æ´Ï¦à£¦×¦ÂœÓ¬Î¸Ó”È˜Î¸Ê·Â´ÔÖ¨ÂÈ·à¢­pÝ«à¢°Ô†Ê¤Æ§Ó°zÇœÌŠÙŽÃÙ–Ú½Ã€à ¥ÚºÜ·Â›Ü…Ë™Ï›Þ¿Å¦àª—Ç…ÕŸÛ§È¤à§§'],
                    'encodeOffsets': [[
                            105047,
                            12480
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'TJK',
                'properties': { 'name': 'Tajikistan' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ì­Ê·à£³Æ–ÄÓ›à£¬Ãžà¨¢Ë—à½ Å¶ÉˆÞ§Ë ÄÔœÈ“Â‡Í›Å´Óà¡¿B×Ã˜Ô»Ï•ÏÄ‰Ì‰Ç¯Í©Ë Ã¾Û¸Ê©Â¢ÄžÊ²Ò“ÈÎ±Ì‡Ä—Í¹Å»Å«Ô‡jË•Ï©Ë¯ÇŒØ‹Ë‘Ê±ÄºÓ€à¡˜Ç¹Ø¶ØŸÈ¨É”Ï†Û®ÂŸÐŒÒ¬ËŒÕ¢à«²ÈœÇ©ÏµÅ¤É¹ÎŽv'],
                    'encodeOffsets': [[
                            72719,
                            41211
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'TKM',
                'properties': { 'name': 'Turkmenistan' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã±Û¼Ø·ÂŠà¥£Ý”Ú£Ä à¤—ÑŽ×¯Ã¾ÏƒÆ½Ö™|×¯Ó“Ý‡Ç‹Æ»×¨Åªà¢žÙ½Ë¶ÉŽÖºÖÂ¸È†Û¾ßŠÈµÝˆËŽØ“ÔŽÊ‰Ó”Ú±É‹ÄØ›Ê¿Õ°ÏˆË¨à¥–ÇªÖ¨É»×šÚ…ÑšÂ¤à¥†\\ÆÑ†Ü–Ì‚Û¾Ó¦à¬†Ñ¹ÄœÚ¡ÍÇ£à£¦ÂžË®Æ³Ð°à¡½à¥¦×‡Õ¸Ðƒà¢žÐ©à«¤Î«wÔ¥Ê©Â€Ð…É¤Å¿Ì™Û½Ç‹Ç™Ú¥ÓÊ­ÚÅµÇ«ÏŸÙ‡Åà¡©Íˆ'],
                    'encodeOffsets': [[
                            62680,
                            36506
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'TLS',
                'properties': { 'name': 'East Timor' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ä²È¤Ü¢ÈŒ×–Â†Ë€Å€Í†Ä½Ì¯É«à¢•Î¿Û³Ê‹eÊ¬ÄÇ”'],
                    'encodeOffsets': [[
                            127968,
                            -9106
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'TTO',
                'properties': { 'name': 'Trinidad and Tobago' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÓšÅŠÇ®Â‡Â‘ØµÛ­Ä¡Æ¯ÃºÊ’É²iÍª'],
                    'encodeOffsets': [[
                            -63160,
                            11019
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'TUN',
                'properties': { 'name': 'Tunisia' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Î©àºžÔ­ÍºQÈ°Û‰Ô„Ã³Ù†Ô®Ò¶È¢ÛšÆƒß Ç Ñœà£¶Íº×šÄµ}Ñ‹ÜŠÌ²Ã’Ç‰Ð¿Ð«MÏ±Ì†È½ÅÜ«ÖƒÑ…Ç„Ò›Ñ¤aÉ„ÐÍŠÅ¿Â³Ù¥Ð¥Ê‹ÊµËÖ½Í“Ä˜Î‘Ã¯ÎŸÐ§È›'],
                    'encodeOffsets': [[
                            9710,
                            31035
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'TUR',
                'properties': { 'name': 'Turkey' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@à®ºÍ—à¦Å¼Ü¤Ãµà¦²Ñ¬à£†Â¢ß´Ð­ÆœÌ‘ÄƒÐ£Ø²È»Í¨Ê•Ö»Ê‡Ë€à¥«ÇÊ»Ò Ú§Ð•Æ™ÌÉŠà¦ÅˆÎ¯Å½à¥—Å½Òbà¥³Ì¿Û•EÒÇ€à¤É¹ËÇÂ¯Ò·É£Ç¿É£Ç¿Ì±Ï ÍˆÍ‚ÔŸÃ­Û±È–Ö¿Ó™à±£Ä¥Ú¹ÒŠà£ŸÂ†È—Î‘×‡Ä³ß»Ò„à£»eÓ½à ¶Ø—Ò°Ð¦Ù¸Õ“Ð’à¤ ß¨à²’Â’ÎœÙ”à¾€Åà§žÕ°à¦’Ê„àµ¼là¸¸×£'],
                        ['@@Û«ÒËƒÏº\\Ç¦È¦Ä¦ÊºÕ‚Ð¥Éžà¡¦Ë„Ü¤Å‘Ä´Í“Ü¼Ë“ÆµÈµà¦¿Â±Î©Ê·']
                    ],
                    'encodeOffsets': [
                        [[
                                37800,
                                42328
                            ]],
                        [[
                                27845,
                                41668
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'TZA',
                'properties': { 'name': 'United Republic of Tanzania' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÆšÄ¡áµ‚á‚‹ÃŒÓ£à®¼à ¿Ï±à¨™Â¸Ó‰Õ Ì©~É“É³Ô“Â¶Ê­Ã‡Ð“ÌŒÕƒÎà ¡Ì°Ç¿ÚÓ£à£¿Í›Ô‹bÌ™Ê¥×‘sÉ•Åƒà§Ê‚ÙƒÃ¥É½à¬¢ËµÏºÇ›É¶à —Æ¾Ó‰Ê¨Õ•Æ˜Í¯Æ˜Î—ÉˆÒ‘à©–Ó£ÒºÇ—Ó¤ÄŒÑ¨Æ¯ÞžÎŽÂ Ì¨Ì¦ÍœÑ¬ÈºÇ®SË˜Ç·ÈÂ·Í¨ÊÅ‚Â¶Ó¶Í«Ó„ÌŽÄ¶à¤„[á‚ŽÃ '],
                    'encodeOffsets': [[
                            34718,
                            -972
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'UGA',
                'properties': { 'name': 'Uganda' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@à¤ƒ\\ÌÄµÔ‡Ê·È¯ÄPÙˆÈœÍŽÂ²Ú¬Ç°Ï¸ÍŽÑ¬Í”É Ë’Ì˜ÍµÅ–Â¼à¦šÎŒÉ®Õ–È‰Ú°È ×¢EÔ¬Ï®ÐŠ×Ä°ÑÏ„à¥¯Ì§Ø“Ð¯Ö‹Ê‰Í½Tà¢¹á‚ÃŸ'],
                    'encodeOffsets': [[
                            32631,
                            -1052
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'UKR',
                'properties': { 'name': 'Ukraine' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ì¾Â“É„È’Ê®Â¥à¢ŒÄ†ÕžÓ‡È¿ÇÃªÊ»Ú Â£Ì˜Î·kÇ‘à©ªÌÙ¢Æ„Ô°Ï¿Ó®Và°ŠË™XÊ™Í¿Ñ¯È†Ò©ÆƒË©ß»Ã•ÑŸÉ»ÂÏÚ¡Ã£Ö‘Ë•Þ½Â«Ü£Ì»Â¸Ô¹ÐªÈ­à¡¨Â¼ÇÌ›à¤Æ¡à¬›ÓŸÒ±Ç È„Ð‚à£½Ê˜Æ¨ÇˆßªËªÊ‘È”à²¯É†Ã‹Ì¼Þ©Ä»Ì·Ò§Ù±Ø©ÏŸÆ ÐÆ‰Ï‘ÆºÉ‚ÄžÆ¦Ë¾É²ËŽÃ‘Æ®Ç¬Ã¤ÄŠÅ›Ó¸{ÉžÃ˜Æ½ÄŽÃÅ²Ì‰ÉˆÅ§Î˜Ì©ÆÃ’Ë¶ÏÉ¦Î‰ÂŽØ£Ê¾Ö‘Ä‰È§Å­ÎŸ@ÉƒÈŸØ§ÄƒË¹Å¹Ï·È´ÕŸHÔ³Ä¢Î³ÇµÃÉ¤Ò±É®ÇÍºÉ¸É”È€ÂµÉ‘Ï˜Þ„Û¦Ð¸Ä°ÄœÉ¾Ñ…Ü¼Ð”ÂÒ¢ÉªÙ²nà¡–ÃŸà¤¬È«ÚŽiÍ‚Å§Í€Æ¦ÉšÈÝ¸Â¢Í®Ä…Ã„Ñ†Ê¶È‚ÜžÂº'],
                    'encodeOffsets': [[
                            32549,
                            53353
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'URY',
                'properties': { 'name': 'Uruguay' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Õ²Äšà¡†Ù¯Ìº|à¡ºÕŸÚˆÒ«Ó Ö±Ï‡Ð‰É¸Ó‡ÎµÕ‡à¥‰Ò±Ø§ÇšÒ“Ä›Þ¥Î°Ö«ÂÔŸÒ¬ÃžÕ¬Ç¾ÈˆSà ¸É¤à¡ºÈ¾Ú¦'],
                    'encodeOffsets': [[
                            -59008,
                            -30941
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'USA',
                'properties': { 'name': 'United States of America' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@Å©Æ•È½Å¤|É¾Æ“Ì¨Â¦Ä¤Æ¤ÆŽÃÇ”Â¸Ã¾ÃœeÍÆ™Æ¬Ã±ÆŒÅ‘ÉŠÌqÂ¯ÍŸÇµËÅ¿'],
                        ['@@Ë­Ã‘ÆŸÇ®Ä«Ã¨QÃ€ÄˆÃ®Ì˜ÄÉ˜Å¹Ã«Äµ'],
                        ['@@ÄÒ‰|ÃšÄ¸Ð°Â•'],
                        ['@@Â­ÂµÃ“ZÌ‡ÂˆÅƒÈ’ÂÂ’É¤ÅšÃªÃƒÊË¥'],
                        ['@@Ä±Ä‰Ë±Æ´ÂªÃ–Å¸ÄˆÈ˜ijÈ'],
                        ['@@Æ¬Ò£Ê¼Æ›×–Â½à¡¬Æ…à ‚Ê¹Ú¼ÅŠà¨–É“ËžTÝ¨Ê„ß‚Ì§à ’Í—ÚºË©Ù¶ËÄˆÉ™È¢Ä‰Â½Ä‰É¦ÇŽÄ”Â¦È£ÇœÆ…É´@Å¬Ä¹Ä½Æ«à¢–ÐÇ¶ÞÇšÜ³Ê—Ó¹ÐÒ¥ÈÌmÄ“Ä¦Å¥Ë¸ÆÉ‚@à¦ŠÒ†à¡¾Æ€àª¸Ð¼fÄÃ·Ê°Æ‰Ç’ÏœÆ†à œHÞ˜AËŽÍžÅ€Ã à¢¶Ø„ÏœÆ¸à±¦Nà»¾BÄŽÈºËÂ¦Î¦Å¾Ì–Ï¢Ê²ÙºÙšÙŠË¨É™ÖœÆœÏŽÊAà¬§Õ¼Ó…Æ¢Ëà£‹ÐŸà¡·Ìƒà¢±ÊÑ»Ó¿Æ›È‹SÑ½Ë¤Ñ½Î’sÄ—Ì¬Ê¦È‡Ã£Ê‡Ö¥Æ‹Ð—hØ©Æ¥Î»Â¥Ó¥Â¥Û«Êà°€Ç‚Ê Çƒà­³Ê¥Õ—C|ÄºÊ­É·ÊšÂÇ¹×½Ø‘Ù§Ã—ÉŽÈÂªËŸÉ€ÇªÒÈ¼Æ­^Í…ËÍ›Ò¿Ú¡Ã»ÂÊºÖ²Ñ•ÍŽÄ¯Û¦Ç‰ÎµÇ´Õ‘Ö‡Æ€×‚Ë“Â˜ß›ÊŠÃÄ–ÌƒÅ à¡Õ•Ø¯à¢‡ÊÖÓ±Ð½ÃÑÌ±Å£Ë­à¤‡Õ±ÓÐÐ…Ó½Å»×¯Æª×Ë¬Ü—ÏŽ×©LÎµÐŠà¦…ÂÖ¥Â—Í›È¿Ô¡Ê£ÅƒÐ¯ÄºÆÏ‚Í‹È–Ñ»Ü¢Ï¹ÙžÅ±Í¢Ç¤ÖÉ½Ò¦Ù»Û²ÍŸÅºà¡‘Ï¡Æ­Â¦Ð¡Ï¼ÕƒÈºà¥‹ÅÝ—Ä¤Ù™ÃÎÅ¿Æ²ÉŸaÍ½Ç´Ç“Ç‡ÅÌµÅ®ÍÇƒØÂ€Ø·ÑºÜ»Ä¿ØÈšÔ¹ÃÛ»ÈÞ‡Ø­à ³Î³ÒÐ‘È•Ï—U×…Â¨Ð•Ç„Ë¹Í{×­È‚Ù½ÊºÉ½Ð„È×˜Ó·ÓÌƒÓ°ÑƒÖº×£Í²Û‰gÕ‰Ú‘Û£Ê¦Ñ¡ÊªÈ½Ò¦Ë§Ñ®Ó¿Ï„Ñ—ËˆÌ©Ì–à¸›@CÎ‹Ú—@á€©Oá‰¿×¤à±“Ð¢Ä€Ç’à©©Äà¥•ÃÆ™Ñ–Õ­ÓšÏ»Ä´ÄŸÊŒÒ»Â¦ÌÉªÞ­ÄŠÉ‰ÆŒÄ¹Ò¢à à¡ŠÛ©à­ ÂˆÈšÏ‡Ë¤Ù¯Û´Å™Û†ÒƒÒžÈ€Û¢Â…ÜœËÙ¢Í ßŠÄ¸Þ‚ÄºÞ‚Æ±à«¼Ë‡Ü˜Ê“Ï¶Ä¸Çà¯’Ë·Ò‚ß‹ÈºÉœÆ‡ÛË·ÛŽá›¸@á ‚@à œ@á¢¢@áŸš@á¡€@á¡„@á­°@á®žBáƒAFÍ”Ë´J'],
                        ['@@à ½Í‹Ñ•ÉÅ½Ð€Þ„Ì˜Ò†Å¸ÖÃ‰Î¤Ê»Ü«Ð'],
                        ['@@Ô§Å½Õ½Æ¾Ô›É®à ¦ÆžÚšÃ¹Ä‚Í‘'],
                        ['@@Ô°Ç…Ô¾Ä’Ú¸É›à ²Å‘Ã©ÄÙÇ±Ù•Ç¾Í‹Æ²ÝÂµÈ§Ã´ÂºÍ„'],
                        ['@@ØŠÏ›ÏŽÇŒà·„Â»Â¹È•à±¾Æ›à¡¨ÄŒá„šË…à¾¤ÄÙ¨Å‰à«¦ÆŽà±¢Ê§à£²Å@@Má·±Iâ·à  {à ŒÉµ×”ÏÝœÖà ˆÒºà¡ˆË–Ò€Ñ¡Ö¤Î‡Þ’Ï™Õ‚×½à¡®à¥Ÿà·šÕ—xÕ‹Ò±Ð™Ò¥Í‚ÝËŒÊƒÜºàªÚºÒßŽß¯Ã„à³·rà¦ŸÊŒáƒ‰à¢Žß©Ç„à¸½Ìœà­‘Ã­à¿»Ï¬à§ƒÎ¨à¤ŸÇ¯Ç¦×Ò«Ãà¦Ç«Ý‰Ë±à¤Ç³Å¥Ó¶Ïšà šà£€Ê¶É±É‚à©±ÒµÖµÖ‘à¯…×±ØšÐ¡ß×¿à£—Î—à¡Ê±È»Ï‰à²½Ñ¡Ë…Ï¿à¦›Î«Ö½ÃžÞ·É»à¡Ë¹Û§Ë«à·¹Ê‰Å¿Æ˜à¤€Ï¾à ”Ê¸à£†Ò à¨¬Ä¨Ð²Îˆà­˜ÔŠÈˆÇšØ¨Ì’Æ¢Ù’Ñ’Ó¸à¥¹Ê«Ë“Æ Ò•Ì§Õ·ÑŽÉ§ÌÌ½Ð¼à ¿Í³Ô©BÃ¯Ô„Æ²Ì®Õ¥Ìšàª¥Ç‡ÜÐ€Ö·È¬IÓˆÙ©ÎªÍ˜Ó˜Û†Ò¸ÌšÑšÚºÃ–Ö¾Æ‡Ú´ÐœØŽÃ¯Ù˜Ê¼Æ»Ï¨Ò¹Æ°Ø¬Í–Ô©Wà¢»Ç½Ê¯ÈƒÚÈ„à®Ä¥à¯·È¬Î›Í¸à©ŸÓ¦à­¾Î˜áˆ˜Ð¨Û”@Å•Ð½á„¢ÂŽÚ½Ô¶à¨•ÍŒ×±Ñ€ß«Î¨à¬½ËˆÒºÑ²à¹°Â‚à©šÏ¦È¨Ð¤à¡¬ÐŽà ŠÄªà½ªÏŽÞœÃ‰à²Ò„à±šÇ­']
                    ],
                    'encodeOffsets': [
                        [[
                                -159275,
                                19542
                            ]],
                        [[
                                -159825,
                                21140
                            ]],
                        [[
                                -160520,
                                21686
                            ]],
                        [[
                                -161436,
                                21834
                            ]],
                        [[
                                -163169,
                                22510
                            ]],
                        [[
                                -97093,
                                50575
                            ]],
                        [[
                                -156678,
                                58487
                            ]],
                        [[
                                -169553,
                                61348
                            ]],
                        [[
                                -175853,
                                65314
                            ]],
                        [[
                                -158789,
                                72856
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'UZB',
                'properties': { 'name': 'Uzbekistan' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@xÔ¦à«£Î¬à¢ÐªÕ·Ð„à¥¥×ˆÐ¯à¡¾Ë­Æ´à£¥ÂÍÇ¤Ä›Ú¢à¬…ÑºÛ½Ó¥Ü•ÌÆÑ…à¥…[Âá¶¾á“˜ÓºÆ¾Ã¯à²¦×»ÛŒÍ…ß¤Ýµà¦¢Åªà·¸Ã à§”Ø—Ã™à¡…Ð¦MÇ¢Ûà©¬ÂÉ²Ð‰ÌºLÏ€×ºà«Ž×”Ó–ÆºÊ Ä‰ÛµÕ­Ø¦Í×²È¾à¦¼Ñ·à©½ØÙ•ÄŠÎuÅ£ÉºÇªÏ¶à«±È›Ë‹Õ¡Ð‹Ò«Û­Â É“Ï…Ø È§ÇºØµÒ¿à¡—Ù‡Ç°Ò³N'],
                    'encodeOffsets': [[
                            68116,
                            38260
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'VEN',
                'properties': { 'name': 'Venezuela' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@yÈ£Ó±Ä­ËœÏ¡YÑ­Ï…Ó¥Í†Ú™Î´Ã†ÈŒØˆÊ»Ì’Â§ÙŽà¨¶Î€Å™Ð†ÌŽË†Ìž×Ÿ×œ_Õ´ÒµÂË§Ý®Qà£ŒÄ”Ó–Ï•ÙžÄ»Ò¼Ê¾XÉ„à¨¨Â¼à§–\\Ü‰Ê›Ë¼Ð‡Ú¦Ã—ÙÐ¯Æ†Ú§Ñ¬nÍ¢È£Ú•Ó±Ã³Ì«Ë¾Ì·È½Æ½Ô«Æ‰jÏ±É«É±ÖªÙ‘ÅÊÌ­Íà¤±Ì½×¿Å½ÊÈ£Ú›É€Ø«Å†Æ¿Ã½Ï”É‘Â‘ÖÅœÕ‰Ü†Ã¯Â°Ç­×·Ê…Ä­Î£Î‰ÆØ³ÈÇ‹Ê±Ù·Ã…Ò§Ñ¼Ê¯à ºÉŸÌŒÌ§È„ÑŽÐ¼Â…ÈŠÊ…Ê Ç›Ö’Ã ×¼ÈˆË°Æ²ÒŽÌ“Æ ÓÄ©ØÂ®Í»Ä™×¡Ü¢Ó¥Å„àª‰ÄƒÈ§ÌŠÈ·ÃªÂ‡Ç¬Ä´Ì¶Ã¡ÍºÈƒÈ‚Å…Ï®Ñ¡ÃˆÉ¸Ó®Äº×¶Ê”Ì¸Í˜ÊŒÉˆÑ€Õ¤Æ–'],
                    'encodeOffsets': [[
                            -73043,
                            12059
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'VNM',
                'properties': { 'name': 'Vietnam' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@à«­Ü—Û«ßÈ×Ù à¢­Þºàª³Þ‚Ô±ÔžÚ«Ïªà¼Å•à¹“Û«Öƒà¥§Õ¥Û‡Û«à¨·Þ±Ì§Õ Ê€Ö¬Ø¯ÓŒÜ¬Í¸à¢¦Ã”ÏƒÔšà¶´Ù¨Ä¼à§–È›Ö–Æ¶à¡€Éƒ×¦Ù×Õ‹ÝŒÛ¥à¦´à§“ÔŠÊŠÌ ÕžÉ˜Í™Üºà¨™PÏ•Þ†Ó­ÚÒŠÈ´Ú¢Ià ˆÄ¬Ü’Ò„ÐšÌ¿ÞÆµÆƒÓ›ÐÍ¿à¡ŽÉ“'],
                    'encodeOffsets': [[
                            110644,
                            22070
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'VUT',
                'properties': { 'name': 'Vanuatu' },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@Ë£ÅË­Ï‚ÂŒÉ¤Õ†Ó—'],
                        ['@@ÆŒÚ±É¥Å€Ç©Â­Å¥É´iÙ¢Ð”Êµ']
                    ],
                    'encodeOffsets': [
                        [[
                                171874,
                                -16861
                            ]],
                        [[
                                171119,
                                -15292
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'PSE',
                'properties': { 'name': 'West Bank' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@Ô£Å­Ê™ÐƒÅ•Â˜ÉœÉŒÅšÉÄ¦Ç¬Ö”Ì¤Å›'],
                    'encodeOffsets': [[
                            36399,
                            33172
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'YEM',
                'properties': { 'name': 'Yemen' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ø‰É¥Ç‹ÏoË¹à ·ÎŸà´‡Ï»Ý©×£Ï…Â±Ê¥ÂºÓ­Î‘Õ—Ç‰Û·Â©ÉƒÂµÇ¿É›É™Ã•Å»É‡ÐµlËÅ“×‰Â¨É“Ó¬zÒ ÆÊœÇ‘ØªÊ‹ÎŠÇšÂ¤Ä‘Ï¨Ä¸ÇŠÂ™Î¾Ï‚ËŒÄ‘Î ÉžÐ®ÎŠÉ“É¬Ãºà¥ºnÆ¸Ä‹ß¼ÄÍÂ¨É‚Ë«ÏºÆ–×¼à¢¦Þ¸Ïšá’Í’Ú€àµ³Ëž×—'],
                    'encodeOffsets': [[
                            54384,
                            17051
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'ZAF',
                'properties': { 'name': 'South Africa' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': [
                        '@@ÇÅ§Î£ÑÉ»Ñ›Ó‡×»à¥‹à¢×£Ô‹Ù‹Ï£à¢›Í™Ñ“Â«Å‡É·Ô›Å°ÐµÇ…à£«ÇŠÔ™Ä¹ÎÂ¬à¡¿Í©Ü“ÆƒÔ±Í…Ï¡oÎ£ÌšË³fÎ±Ï’ÂŸÅ›ÅÉ¦LÓ°Ë™ÖžË”Æ´sÙ¤Õ½Þ¼Ñ…ÜˆAF×½àª¤Ð”Ð´ÍªÉ¯Æ˜Î«Ï˜Ã“ÕˆÇƒÒŒÃ–Ý¤Ñ–Bá·ŒÉ¨Å±Ó¾ß™Ã»ÔŸÈˆÌ×¼Ä’Ñ€Ï’ÐŠÊ¨È¶Ð”Ð¦ÈšÎ Ä·Ð’É½Û‚Â£ÕžÈœÄÊ¾Æ¨Ð”ÒšÃ¤Ê¨Í‚ËªÖ”Ý®Øºà®’Ø¤Î‚UÐžÆ›Ë²Ä¶Ò‚Ä‹Ð”à®É”×¯Æ«à¤©Ã®ÌŸÑ‡Æ¶ÊÃ‘ÄÊ“É¯Ì¿TÌƒÔ†Ò•Ó®ÄœÇ¢ÏŽÙ’QÈ¿Ø‘Ä±Û¥É‘Ï›ÖµÑ‰',
                        '@@Î½Ê¶Ï»ÇŸÒ•Í¡ÒƒÕÙ€Ù§ÌœÄŒÆºËŽÒ´Æ€ÆœËœÊ´Ð¤Ì…Êª'
                    ],
                    'encodeOffsets': [
                        [
                            32278,
                            -29959
                        ],
                        [
                            29674,
                            -29650
                        ]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': 'ZMB',
                'properties': { 'name': 'Zambia' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ð†ÏÉŠÜ‹ÆÉ©Ç™Ú»ÇˆÛ¡ËƒÌ‡Ê­Þ­Ñ¶É“á¢‡Û—Ä‚×¯ÙÅ™ÓÍ¯Ä¹Ì…Ì›ÃŸÜµÛ“Ò­Õ­Ë³oË—Ä¬à¤±Ä Æ¯ÃšOÃªÍ§ÈŽÕ¯Â¶Û‹È‘Õ¹Ô¾Ö£ÛŒÂžá¦¶áƒ¨YÃ­Ì‚Å°Í€Æ§Ð€ÄªÐ¢Ä—ÊºÌ‚qÂ¶Ê½Ï¾rÕ–Ã»Ë¬Ï¡Ú¨ÅÔ¤Ë†ÈŒÑ¯Ù ÅŸÌ´Î§ÎˆÒ¥Ù QÃ«à£ É±Æ³×—ÍžÉ§Æ¬Ä¼à¡ˆÆ¬à¦¸È‰ÏˆÊˆÕšÉ¤Ä¶à¬€ÆšÍ¦Ä‘Î˜É‡Í°Æ—Õ–Æ—ÓŠÊ§'],
                    'encodeOffsets': [[
                            33546,
                            -9452
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': 'ZWE',
                'properties': { 'name': 'Zimbabwe' },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÒÄŒË±ÄµÐÆœÎVÕ™ÏžÙ¯ÅºÊ™Õ’CÌ’Î­Äžà¥à¤ˆËƒÓ¢Ç›Æ®Í“Ú¤à¤²ÄŸË˜Ä«Ë´pÒ®Õ®Ü¶Û”ÌœÃ ÄºÌ†ÓŽÍ°ÙŽÅšÃ†Ì»Û¬hÏ´Ç¯ÇºÈ»ÐÃ“Ñ¦Ë‘Fà©ŸÇ×‹Â—Ø¹ÆŠÊÄ§ÓµÅµÃ¹É›Ø…à¢«à¥“'],
                    'encodeOffsets': [[
                            31941,
                            -22785
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/xiang_gang_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [{
                'type': 'Feature',
                'id': '8100',
                'properties': {
                    'name': 'é¦™æ¸¯',
                    'cp': [
                        114.2784,
                        22.3057
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â™@}ScTÊŸ@cWuJÃÂ–]Â„lÂ¦RLjÂ¼BÄ„Ã Â˜Â ÂŽH@TOHCTDDDHDNAT@PEHDDNJLX@BABALHFF@DKHADBBLDHHFBLEJB@GDBBFBADDB@@KFAFBBJJA@BB@@FFDDADFF@FADDDBJC@AFBD@@DDD@DAA@D@DB@DHHBFJBBFEHDFAN@DGDC@DLCBDDCFDlAFBFCBEF@BC@GDAB@FD@DZJÂ‚XÂ´HÄMja@Ã`Âp_PCZ@lLnRGSDMFK|a\\ÂYÂ}Â­ÂƒÂ§ÂÂ™ÂÂMÃ«n'],
                    'encodeOffsets': [[
                            117078,
                            22678
                        ]]
                }
            }],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/xin_jiang_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '6528',
                'properties': {
                    'name': 'å·´éŸ³éƒ­æ¥žè’™å¤è‡ªæ²»å·ž',
                    'cp': [
                        88.1653,
                        39.6002
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â˜@ÃˆÃ’ÄŠanwÅŽVÂ„Â™È®Â¦ÍªÅƒÄ¢Â„ÃœÅÈ‚Ã§ÄŒÃ©ÆÂÅ¼LÉ†Ã³ÄŠÂ‚ÄŠaÊŠÅÂ±Â¯Â²UmÂ»ËŒmÃˆÂ»VÂ™Ê Å£WÃ‘Ã…Â¯Ç“Ã©ÂƒÂ™Ã´Æ‘Æ’ÄŸÃ†Ä«ÅŽÄ«@Ç·Â™wÃ´Â™ËºLÃžÂ¯Æ¨VÇªÃ‘Æ’ÂšÄ¢Â™È˜VÂ°wÄ¢ÂŽÃ´kÂ°Â¯Æ’Â»Î€@È‚Â»Ä¸ÂŽÇ”@Î€ÂƒÍ”Ã´Ã´LÉ†Ã³ÌÃÉœLÉ²ÅÍªÂƒÆ¨Ã³Å¤K@Ä«@IUÂÜƒÃ›mÈ»Å£Ç©ÃË¹Ã›Ç‰Å¥Ç“Ç«Å@ÆÂ²Â¯VÃ§ÅKÍ¿ÅÎ—Ã‡Å£Â»Æ½Â™É…ÂÆ‘LÂÃ“ÅÂÃ…Ã…É±V@ÃÄŠUÂ¯Ã‘ÄŠÄ­ÃžLÂšÃžÅŽJÂ±ÌƒXÈ£ËŒÅlÂƒUÂÃˆÂ¯ÅŽKÃ†Æ…Â°Â™XÃ‘ÃœÂ±nÅ—Ä¡VÂ¯Â™Ã³aUÂƒÆ§UÅÅÂ„Ã‘Â™Â±Â„Ã§É²Â¥lÄ‰kÄŸÂ°ÂƒkÂ¥Â˜ÂƒnÄŸÅ£LÂ¯ÃÃUÆ½Ä¬ÎlÄ·Â°@Â„ÅÂ„XÃ¿ÃÂ¯VÂ»Å¹LÊ‰ÃžÉ±Å¤Ä‰ÂÃ³Â°ÃJÂ™Â¦ÃKÃÂ£Å£ÃœÂ™ÃˆÄ‰@ÂƒxÇ©UÄ‹ÂÆ‘@kyÍ“Â¹Â™`UÂ²Ä‰VÄ¡Â»ÄŸaÂ¯Â¥Å¥@Ä‰ÂÂ™Â‚Ã³@Å»Ã›Ã›JÂƒwÂ¯nÃ³Â¯Ä¡WÆ½Ê©Ä·ÃÉ›wÄ‰Ä•ÃÂ¼È­ÃžÄ·ÂÅ@Ã³Â£Ã…Î€Æ‘ÂŽÂ¯Ã´È¯ÃžÂ¯È°Â™Ã†ÅÃ¨Ä‰XÃ‡Â¼Ã³@ÃÂšnÂºÂƒÄ¸Â„ÃžVÆœÄ¸ÈšUÊ¶ÃµË€ÄµÄ–É±ÅŽÃÄ–Và¢°Ó’Ñ¢Â°Ë˜nÏšVËŒÂ™ÃˆmÉ¼ÄµÅ¦WÂ¤Ã¶ÊŠÃµÊ”@Â°ÃˆXVÂŽÂ™Ã¨nÅŽÈbÂ¯ÂÇ«ÂÄ‰Â„Â±ÃˆÄŸ`Ä¡wÅÃ”ÄŸÂ»mVVÂŽÂÂ„ÃÂ¥Ã³@Â™Ä¸Ä·Ã´@ÂšÂšbXÂ„Ä¶mVÂ²Â²`Ãž_Â˜Â˜É´bÍªÃˆÂ°Â„ÃžWÄ¸ÃˆÅŒmÃžÂ„ÂškÉ²ÂŽÃˆUÃ†Â»nÂ¼Ç¬VÄ·Ä¸ÅºÃ´Â¯Â°nÂ¦É„Ã‡ÂœÃˆ'],
                    'encodeOffsets': [[
                            86986,
                            44534
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6532',
                'properties': {
                    'name': 'å’Œç”°åœ°åŒº',
                    'cp': [
                        81.167,
                        36.9855
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Æ¨Â¥ÂšÃ¨ÅºÙ¨Î˜Æ‘á©„bUà¢¯ÃžÄ•É²ÅÄ¶Ä•Ã¶Ê¿VÊµÄ·È™UÆ›ÂƒÃÂ„Ä·mÂ¹ÃžÂ™Ã´@ÃˆÂ»ÄŠWÅŽÃ§ÂšÃ…Â°È¯È°ÃÂ°Ã³Æ’ÂÃ†Í¿Ä‰Â»Ì½Ã§nÂƒmÂÉ±ÄµÆ§ÂºÃ³UÂ™Â™Æ½@Â±wÃ³LÂ¯Â°Ì»LÂ±Ã†Â¯VÂÆ´Ä·bÂ¯VÃ‡Â¥ÄŸÂ²Ç•bkÂ¥Ã‡KlÂÂÃ…É±Ä¡@Ã‘ÂƒÂ™Ã³K@Â™Ã‡aÃXÄŸÂÅ£xÄ‰ÄŒÇ«ÂÄ·ÃªÂ¯K@Ã‘ÂƒaÅ¹Â„Æ‘KÂƒÂ¼Â¯VÃ³aÃ³nÄ¡wÂ™Ã³ÃžÃ©UÂ™Ä¡bÃ³Ä‰ÄŸÃ‡lÂ¹Â™aUÃ³ÄŸKWÂÂ„ÂVÃ…Â¯ÂnÂ›Ã‡Å‹Æ‘Â›Ä·nÊ‡Â»Ã³xÄ‰wÂ™Ã§Ã‡Â°Ã…wÂ™Â°Ä‹Â„XÂŽÂ™Â„Ã³bÂ±ÂƒkÃˆÃ‡JÂ—ÂƒmÂ²Å£x@Ã’ÃÂŽÂšÅ¦Ã‡ÂºnÂ„Ã³Â¼nÂ°Ã‡bUÃ’Â±Â¼XÄ¸Ä Å‚Æ½XmwÄ‰ÂºÂƒzÃˆÃœmÂnxmxÂ²Ä–mÃ’ÂšbnÂŽÆ§ÃªUÂºÄŠÃªÃ†VÃ³Ä–Ã³UÄ‰Â¼Ã…Ä¬Æ‘Â°É†Æ†Å»ÅšlÅ‚ÃžLÂšÂ¼nÄ ÂƒÂ¼@ÃžÂ™ÂšÃžÅº@ÅŽÃžÂ°VÂšÉ„É´Ð¶Ï¼ÙÍˆÅŽÂ„'],
                    'encodeOffsets': [[
                            81293,
                            39764
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6522',
                'properties': {
                    'name': 'å“ˆå¯†åœ°åŒº',
                    'cp': [
                        93.7793,
                        42.9236
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@WnÅÃ†Ä¶LÄ¢Â¦Å£ÂºÅºÂ„lxÃ…Ä¸Æ½ÅšÂ‚É„Â—Ä®Â˜Ã¨@Ã´Â²ÃžUÄ”ÆÅ„VÂ°Â¯Ä¸XÂ¦ÆmÌbÆ’Â»É†aÎ€ÂšÄ¢Â™ÆLË¤Â™È˜Ã‘nÂƒÐ†Ç‰Ä¸Ã¿nÂ¯Ä¶aÅŽÂ¯Ä¢Ä•È˜Â¯Â°ÂÎ‚ÂœlaÂ¯Â¥Â™Ç•Ç”wË¤Ó±lÅ¥ÐžÌ»nÅ»mÂÉƒÄ•Ä‹Å£UwÂ°WUÃ³Æ¨Ã…Å£Ä·Â°Ã½VÂ±Ã³Ã…Ç“Ã©Ê‰Â¯Æ½ÅÂƒÃ©ÅÇ–ÈÃÆÅ¯Ç•wË¹Ç«È—Ç“Æ§Ç•VÃ½Â™Ã©@Ä¬Å£LÆ§Ã´Í©Â„É±ÅŽÉ›KÌÃžÉ…Ã´Ã³K@Â²@Â°ÅÅ˜ÂšÂ¼lÅ¦Â¯Å°Ã³ÆœÃ›lVÂ¼Ä·Â¼ÂƒÂ°kÈ°Â™Å°Â„Ä ÂƒÇ¬Â™ÅšÃÅŽmÄ–Â`@ÂÃ‡ÃœnÂ„'],
                    'encodeOffsets': [[
                            93387,
                            44539
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6529',
                'properties': {
                    'name': 'é˜¿å…‹è‹åœ°åŒº',
                    'cp': [
                        82.9797,
                        41.0229
                    ],
                    'childNum': 10
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': [
                        '@@VÃ†ÂšxËŒÅŽÃžÅŽÂƒÂ°nÂ„È‚Ã’Â°Â²VÄŠÂ¯VÄŸÆ¾ËÇ¬Æ¨ÃžÃžKÃˆÃžÄŠVÅºÃ´É†ÃžÄ¢Ã¨ÅŒÂÃ´WÄŒÂ²Å¤VÃžÄ¸Ê¶blÂ‚Â¯Ã´n_VÃ†Ä¸lmÃžnVÅº_Ä¸Â¼È®mÇ–Â„ÂšÃ©Ä¸ÂWÂ°Â°Â„Ä¸JÂ„kÊ Â¼Ã†wÂ°Â¤ÃˆÂƒlxÉ†zÄŒÂºÄ¶IÂ²Ã†Ç”UÂšÂ°Ã´@ÃžÂ¦Â‚ÂƒUÂnUÄ Â¼ÅŽÃ“Ä¢xÄ _Â²Ã‡ÄŠÂƒÇ¬ÂÂ°ÂŽÈ‚amÅÂšÃ§UÂÃ‡W@Â¯Ã¶Ê“ÃµÊ‰XÂ£Ä¶Å¥nÉ»ÂšÃ‡UË‹mÏ™Â¯Ë—Ó‘Ñ¡á©ƒaÎ—Æ’ÂœÉœÂ°xWÆ´UxÉƒÃ’Ë£Â¤É…wÄŸÂ„Ê‰ÅÃ³ÃÅ¹ÂÂ±Â°È—@Â¯Â„Ã†Æ’Â²Â¼',
                        '@@ÅÂ™Ð³wÈÂ¥Æ§Â°Å¹Ã‘Ä·VÂ™Â¼ÃžÃªÄŠÂ»Â‚lÄµÂšmÂ¦Ã…W@Ä€Ã´ÃˆÅºaÉœxÃˆbÃžÃ†Ä¶IÐžÅ˜nIÃ‡ÅƒÃ›ÃÄŠÃ‘Ä Æ'
                    ],
                    'encodeOffsets': [
                        [
                            80022,
                            41294
                        ],
                        [
                            83914,
                            41474
                        ]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': '6543',
                'properties': {
                    'name': 'é˜¿å‹’æ³°åœ°åŒº',
                    'cp': [
                        88.2971,
                        47.0929
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@É²Ë£ÄŠIÃˆÂ¥Â‚Ã…UÂ±ÄŠÃ½kÅÂ°ÂƒÄ‰Æ½Ã³Â»Ä¶Æ½XÃ³ÊµÊµÂ™È¯Æ‘Ã…ÈÉ…Â¯Ä‰@Ã‡áˆ—KÖ›@@Ë¤VÖœÊµÑ€Æ’Ç¬VÄ¸Æ‘ÅŽ@Æ†Ï¯Ã‘Ã³ÂŽÄ·@Ê‡Â»Ä·Â¦Î­mlÃˆÄ¸ÄŠXÂ¼WÅºÃ›ÃžÃÑ¸Â‚Ä¢ÄŒÃ¾Â„Ä€ÄŠÃ´Î¬VÃ¶Â¼ÄŠUÆ¨Â°Â°Ã¨ÅŽÄŒUÃœÃ†ÂÃ³Ã´VÃ´Ã´ÂŽÂ²ÃªÈ˜lËŒÃ§Â°`nÂ²Ç¬ÂŽÄŠaÂšÂ™ÂƒÃ›Â°Â±kÂÄŸmmÂ»Âš@Â°ÃÉ†Ã›Ã…Ã‡VaÃÂVmÍ”ÄŸÃ´ÃÃˆbÂ‚ÂÂ„@Â„ÂÂƒÂ™nÂ¯ÂšÂ™ÃœUÄ¢Ã‘ÄŠ@ÅºÄ«Å¼WÅ¤ÃˆÇ–WÃ´ÅÃ†IÂ²Ã“Æ¨L@ÂŽÄŠXÂ„mmÃ‘Ã†Â»È°Ã‘kÂƒÄ¶Å@Ã½Â°mÂ—Â¯'],
                    'encodeOffsets': [[
                            92656,
                            48460
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6531',
                'properties': {
                    'name': 'å–€ä»€åœ°åŒº',
                    'cp': [
                        77.168,
                        37.8534
                    ],
                    'childNum': 13
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': [
                        '@@ÄŒ@Â°ÂƒÄ Â„Ã´Ã“Ã´@ÅŽÄ‰@Æ³Ä¸@Å¤Â£Ä¢lVÂÃ´WVÂÃ³Å™XÄ‰Å¤ÃªÃž@ÆÃ’Ä¢Ã‘lÃ¨ÃˆV@ÂšÄ IkÂ°Ã†Å˜@ÃˆÃˆÄ€@Ç¶Å¥Ã’ÄŸ@ÂšÂ„@Ã’Ä‰lÅ»_@ÂšÆ§Ä–Ã…Ä¬ÅÃ†@bÅºÃžnÂƒÆ’lVÂœÃÄ¬ÂšWÃ†Â¼Ê‡Â„ÂƒÃÃ…@Ã‡Ã…ÃˆwWÃ³Ä‰Â±ÄŸzÂ‚Ä¬ÄŒÆ¨Ã†Â‚ÃIÄ‰ÃÂ¯bÃ‡Ã‘Ä‰ÂƒÂ¯ÊˆVÂÂ°xUÅ°ÄŠÂ¤Æª_Ã´Ã“ÉšI@lÈšXÈ®Â™ÅŽlÉ´È˜Õ˜ÂšÂ„Â¦É²Ã†Êˆ_É´ÂŽÅºÂŽÃ´ÃžÊŠÅŽÄ ÂƒÉ†xË¤Â£É„Ã‘VwXÆ³Â¯wÂ›É›Å¹Ù§Â™Ã§Æ§Â¦ÅÂƒÙÍ‡ÐµÏ»ÉƒÉ³UÂ™ÃÂ¯@ÅÃÅ¹ÂšÂ™@ÃÂ„Â»mÄŸÂ™Â»ÃKkÅÅ¼Å™É…Æ…Æ’Â¯Ã†Ä«ÄŠÂ»Ã´VÃ´Ä•Ã…UÄ‰Ã©VÂ¹Æ¨Ã©mÂÂ™anÃ‘Â±Ä•nwmwnÂÃ‡Ã›Â„yÄ‰Â¹Å¹lÅkÄµÃ¨Ä·mÅÃžÄ¡KÃ±Ã”Ä‹KÃ…Ã¨Ä‰zÂƒÂŽÂ„Ã´mxÈ—Ã¿Æ¿I@Ã¾Ã…ÄŒÃKÃÂ°@Â¼ÃˆÂVÂºÂš@Ã…Ä¢ÂšÃ†UÂÄ‹Å‚nÂ„ÃÃ†Ç•ÄŒÄµJmÂ£ÃJÂÂ¦@ÄŠÂƒxVÂ°ÆLÄ‹Â¼Ç©Â™@Â™m@Ã…Ä¢Ã³mÃ‡Ã†ÄŸÂ¹Ã‡ÂšÂ™Ã†ÂšÄ–ÃžKÂšxÂ„wÃ´Â¦Ã†Ã‘Ã†LÂ²Ã†Æ¾ÂŽUÂÂ„ÂŽÂ±ÅšÃ…ÂÅ»Ä–@Ä¬Å¤ÃˆÃ±Â„@Ç”Ã‡xÂ„ÃˆÃ‡Æ’',
                        '@@VÂÃ‡Â™Å£Â°ÄŸUÄ ÂÂ¯mkÂ¯Ã³Â¥Ä·IÄ¡Ã¿ÆbÂƒÂ„Ä‰aÂ±Ã’Ä¸Ä€lKUÂÂ„_mÂ»nwÂšÂŽÂ„m@ÃˆÅ¤Â¦Ä‰bÃžÂ°Â±ÃžÅ¼Å‚Ì¦Â°Ä¢ÅVÃ©'
                    ],
                    'encodeOffsets': [
                        [
                            76624,
                            39196
                        ],
                        [
                            81507,
                            40877
                        ]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': '6542',
                'properties': {
                    'name': 'å¡”åŸŽåœ°åŒº',
                    'cp': [
                        86.6272,
                        45.8514
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': [
                        '@@Î®nÄ¸Â¥ÊˆÂ¼Ä¸@Ã´ÂÏ°Ã’@Æ…Æ’ÅUÄ·Æ‘Ç«Ê¶Ð¿UÖ›ÜƒLÚ«K@Î‹Ä¸@Ã†Â£ÃžÄ¡ÂÃ…Ä Ä‹ÂšLVÃÂ„Â»Â™@Ã…Â»ÃnmÂ¯ÂšÂ»nÅ»ÄŠ@nÂÄ·Åƒ@Â¯Ã³mÃ³Ã›ÃÇŸÂ¯aÃÃ³È­Â¥ÂƒÂšÅUmxÄ‰bÃ‡Ã‘Â—@Â›bUÂºÂ¯XÂ¯Ã†Æ§bVÃ’Ä‰nÇ•wÂ¯Â°Æ‘ÂŽVÂ„Â—ÂŽÃ‡@kxÂ±UÂƒÂšÉ±nÂ™ÂŽÃ…KÂƒÂ„Â¯Æ’Ä Ç UÂ°ÉœL@Â°ÂƒxnÄ¬Â‚Ä€Å‹ÅŽÃ‡LÂƒÂŽÄŸÂšÏ±ÃžÎ­ÆœkÃ´Ã…Ä€Ç•Å‚ÂƒÄ¸ÄŠÅ¤UÅ°Ä¢Â°Â„Â¦È‚Ï°ÃœÉ¨Â°x@Â°Å¼Ç Ã†ÆˆÄŒVÄ Â»ÄŒLÂ°Ã‡ÂšbÄŠÃ‘ÌÃ³ÃžlÄ¶wÃžÂ„É†VÃžwÇ¬xÇªÅ£ÃˆÂ¼ÃœLÅÄ¶Ë¢@',
                        '@@Ã³KÄµÄ€VÍˆÄ‰Å‚Æ¾ÇŠÃ†Å¤ÂƒzXlÂ°ÂƒÃ†LÂ²Â¼ÅºÂŽÃ´ÃˆÄ¢Ç”Â™Â¦lÂ„Ã´Â°ÉœÃžÊŠÂÄ ÄŸÃ…ÂƒmÂ»ÊµÆ³Æ‘ÊÈ—Ä«VÂ¥Â¯Ä‰Â°Ã‘@ÅƒÃ…IÂ™Â»Ä‰ÂmÄŸnÂ™ÂƒaÂšÂÂƒÄ‹Æ¨bÂšÂ™VÄŸÂ—wÂ›Ä¡Â¯@UÂÅaÂ™Ä‰ÃJÄŸÃ‘Ã†ÅŽkÅŽÃžÄ€lÅºÂƒÂ¦'
                    ],
                    'encodeOffsets': [
                        [
                            87593,
                            48184
                        ],
                        [
                            86884,
                            45760
                        ]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': '6523',
                'properties': {
                    'name': 'æ˜Œå‰å›žæ—è‡ªæ²»å·ž',
                    'cp': [
                        89.6814,
                        44.4507
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@áˆ˜L@ÃˆÂ°ÄŠÈ‚É†Æ’Ã†ÄŠÂ£Â„Å¥Ã´ÂWÃ“É†bÄ¢Ã…ÅŽÂƒÃ†Â¦ÄŒÃ‘WÂ¥Â°Ä·UÂ¯ÆÅƒVÄ“Â±Ã@Ã³Â—Ã§Â˜Ä­ÂÉƒÆ¾Å™Ã†Ä·kwÅ¹ÂƒÅ¤Â¹Ä¡Â¥ÄµKÅÃ…XmËÂÑ‰wÇ“Â¤Æ‘Â@wÃ³ÂÅVÄ·Â£É±ÂšÄ¡Ã´Ã›aÂ±Ã’ÈÂ„Ã³Ã¨Å£IVÂŽÆ½Â¼kÂ¤Ã³Â¹Ä¡JmxÂ—Â»ÃUÂƒÂ²Â™@Ã…Ã†ÂƒÄ¸Ç«ÅŽÂ„ÄŠmÅŽÇ¬Õ˜'],
                        ['@@ÃžÃ´Â°bÃžÇ Ã´ÃœÃ´n@Â°Ä¸Å„Â˜Ç¶kÅ‚ÂƒÂ¼UÃžÂ™KÄŸÄŒÂ‚Ã†ÃÄ¢Ã…Â¤Ä·@@ÎŒÚ¬LÜ„K@Ë£È‚Ë­lÄ‰Ã…Â„WÂ¥ÄµVÃ†Ã½@ÅƒÃžÄ“UÅƒÈ—Æ…@Å¹Æ©Ç•Ä‰Â»kÂ»Ã‡Â™VÄŸÃ³Å™XÂÂ™ÂÅ»KÆÂŽÄ‹ÃªÈÃ¨Ã›ÅŽÄ¡ÂƒÍ©Å„']
                    ],
                    'encodeOffsets': [
                        [[
                                90113,
                                46080
                            ]],
                        [[
                                87638,
                                44579
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': '6530',
                'properties': {
                    'name': 'å…‹å­œå‹’è‹æŸ¯å°”å…‹å­œè‡ªæ²»å·ž',
                    'cp': [
                        74.6301,
                        39.5233
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ËŽÇ«Ä Æ½Â°UUÄ‰Â¯Â±ÈÃ‘mÂƒÂ„Â¯ÃÅË‹ÅÂ™wUÃ…Â±Â»Ã…Æ‘Â°ÂƒÈ˜@Â²Â¯É³ÂÊ‡`É±Ã…ÂƒÂ¥Õ—Â™É³È—ÅkÈ­ÂšÈ™W@kÉ™JÃ³Ã”Æ©`Ä‰Â£VÅ¯Â¯wUÂÂ°Ê‡ÄŠÂ„ÃˆÃ’Â°aÄŠÃžÃžJÃ…ÂÄ‹Æ§ÂÄ«Ä yÄŠÂ²XÃ´Ã‡xÃˆÃ†Ã†@Â„ÃžÊˆÂƒÃ…Â»Â™XÃžÄ«UÂ›Æ‘kmÂ„Å¹Ã@aÅŽÃ…Ã†Ä«Æ¨Ä•@Â™Å¼`ÄŠk@Ã‘Â™ÂƒÄ @Å¦Ã‘@ÇµÃ‡Ã¿@Ã‡Ã…Å—lÂ¯ÄŸJ@Â™Ã‡UkÃ§Ä¡Ã’ÆÃ‘Ã@Å£Ã©WÄŠÃ´ÅšUÂŽÃ³XUÂÄ¡kÅ£Â¤Ä·@@Æ´ÅÄŠÃ³@Ã³Ã”ÄŸÂƒÂ¯Â„Ä‹@@Ã’ÂšÂ¤kÃ´Ë£Å°Í“Â„kÂ»ÂƒKXÂ¯Ä‹wÆ§Ã´ÄŸÉÂšÃ’Ã´IVÃ†Â™ÂšÂ¯UÄ·Ç¬Ä·ÂšnÂŽÂ™Â¼Ã´bÂ°Ã’È°VVÃˆÃžÂ°ÂƒÄ¸Ã³Â¤VÂ¼Â°Â„VÂ°Â²ÃªÂƒlÄ¢Ã’Â‚UÆ¨Â¦Ã´ÂÈ°Æ´ÄŠVVÂ¼Ç–IÄ‹ÄŠÂ„ÃžÉœÃ©ÂšnÄŒWË¸Ç¸ÂšaÂ„Å™ÃˆwÂ±Ä«ÂšÃ§Ä¸Â¤ÄŠÂÂšÃ´ÂšwÂšÂŽÄ¸UÄ¢Â¦Â˜Ã©Ç–Ä¬Â„Ä€Ã´Â¼lÃžkÃ’Â°xÂ°Æ†ÃžxÂ„ÂšÃ†VÂ²ÂÇ”Â»Â„bÂ°wÃžÂŽÈ˜Â¥Â°nÂ„ÂšÅŽV@Â°Â„Â„Ê Ã¨Â‚Å°È‚b'],
                    'encodeOffsets': [[
                            80269,
                            42396
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6521',
                'properties': {
                    'name': 'åé²ç•ªåœ°åŒº',
                    'cp': [
                        89.6375,
                        42.4127
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ã´KÂ„Ä‰ÇªaÂ²Â¼lÃœÃ´@Ê ÃªÂ°Ä¬Â™Ã´È‚ÂƒÂ²Ã‘ÃœbÄ¢Ã³É²Â™Ä¸Â¤ÅŽUÃ´Â@xÆ’ÂŽÇ”Â£ÑŠxËŽÂmÂƒÃˆÃ›@ÂÂ‚_nÄ•ÃžÅÂšÅ™Â„Ç«ÂƒÄŸÂšÅ¯lÈ¯Â„Â¯Ä¸Â»UÂ»ÃœkÃ´Æ›Â°Å¯kÅ¥Â™Â»ÅŽÅ—@Â¯@Â±Í“Ã³Í¿Â„Ç“@Ä·ÂÈÂ¼Í¿@Æ‘Â¼Â¯Â°Ã³lÄ¡ÂÂ¯xÈ—UÄ¡ÂšÆ‘Â™Ç©Ã’Æ§UÃÂ°Ë¹KÃ³ÂšÂšx@Ç¸ÅÄ¬Ã…Ä¬Æ‘Ä Ã³Æ’Â„ÂšÇ”ÃªÃ†Â°XÃ’ÊŸÅ¤UÂšÃ‡Â¼Ë‹nnÂ¼Â±VÂ²Â°È‚UÅŒÃÂœbÊŸÇ”É…Ã´@Å¼Ç¬aÒŽÃˆ'],
                    'encodeOffsets': [[
                            90248,
                            44371
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6540',
                'properties': {
                    'name': 'ä¼ŠçŠå“ˆè¨å…‹è‡ªæ²»å·ž',
                    'cp': [
                        82.5513,
                        43.5498
                    ],
                    'childNum': 10
                },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@Ä‰Â„Ã†Å˜ÈÌmÃžÂ¯Ä€XÂ°Â±Â¼@Æ¾Â¯Æ´Â°ÅŽÃÃ¾Å‹Â¦WÃœÃžbÈ‚Ä‰ÅºUÂœÃ‡mwVUÈ‚Ã³Ã´@È°ÃÎ€ÂnÂÃ†JnÂ™Æ¾Â™Ê Â™ÅŒLÄŒÃ³ÇªÂ¯ÂœÂ¥Ç”aÇ–ÂšÅŒaÃ´ÃÄ¢LÂšxÂ„ÂƒÃ†LÂšÂÉ²mÂ„Â™Â²VlwÃˆ@Â˜ÂUÂƒÆ’ÂÂ°Â¯Ç–xÄŠmUÃ‘Æ¨aÂ°Ã…Â°WVÂ¹ÂœaÂ›Ã‡ÉƒÃˆmÂ¥Â°Â¯Å¹Ã³Ä¸Ä·Ç«UmÂ»Ã…Â¼Ã‡VÉ±ÂÂ™lÃÂƒÅ‹nÄ·Ã‡ÃXÂ¯ÂƒÍ©Ã‡É³aÂ—Â—Ã`Â±_UÂ±ÄµnWÂƒÂ™a@Â™Ä¸Ã³ÂšÄ·Â™Â¯Ç“VÂ±Ã…ÄµJÄ‹Â¹É…ykwÃ‡Â„Â¯Â£Ã…xÊŸÂ»ÂƒlÄ·IÂ¯ÂƒXÂ¯Ä·Â‚Â™ÃªÇ•ÂƒÈ­nÄ·Â»Å¹`Â±Â„kÃž@ÂŽÂšÂ„ÃÃ´@ÃžÂ°xÂšÅ¤ÅŽIÆ¨Ã†UxÅÂšÂ¯Â²Ç”Ä¬Ç¬lUÅš'],
                        ['@@ÃžÄ€lÅºÂƒÂ¦Â¯Ä¸Å¤KÃžÂ™ÂšÂÂƒÄ‹Æ¨bÂšÂ™VÄŸÂ—wÂ›Ä¡Â¯@Å£ÂÆ½J']
                    ],
                    'encodeOffsets': [
                        [[
                                82722,
                                44337
                            ]],
                        [[
                                86817,
                                45456
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': '6527',
                'properties': {
                    'name': 'åšå°”å¡”æ‹‰è’™å¤è‡ªæ²»å·ž',
                    'cp': [
                        81.8481,
                        44.6979
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Î®Æ›Ï²ÃÄ Â™Â„ÂÃˆKÅŒÅÂÃ¿mÄ«Â„w@Â¯É›KVÂ¯ÄŸÇŸÂ°Æ‘Â™wÄ¡KÃ³ÃžÅ‹bÇ•Â™Ç“bÂ›Â¦Ç©Â°Ä‹Ã´Å‹KÊŸÂšÆ½ÂšmÂšÃ…ImÂŽÍ¿ÂŽÈ¯ÃžÃ³@ÈÃ´UVnxÂ›ÃˆÅ¹VÈÄŠÃaÂbÅ»Â£Â¯Â°lÂ„Ã³xÈ‚Å¤Ä¸kÄŠÂšÃžyÄŠÃªÄŠmÄ¢xVÂ„Æ¨ÂÃˆÂŽÄ XÂ„ÂŽÎ˜Ã†Ä Ã”ÅºÂ‚É†Å£Â°LXÂÆ¾ÂÅ¤ÂÅ¤b'],
                    'encodeOffsets': [[
                            84555,
                            46311
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6501',
                'properties': {
                    'name': 'ä¹Œé²æœ¨é½å¸‚',
                    'cp': [
                        87.9236,
                        43.5883
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÂšÂŽWÂŽÃ´ÅšUÄ ÃˆÂšlÂ¼ÄŠÂ¼ÆªÇ–@ÅºÈ˜Æ†@Ã½lÃœÂšXVÅ˜ÃžÂ™ÂšÂ¦VÂ¼kÄ–Ã³Ã’ÂƒÃ¨kÄŠÈË®Öœ@Ç«Õ—nÅÂƒÄ‰Ç¬ÅÂ„Ä·Ã†Ã…Âš@Â„Â±ÃžVÂ˜Â¼nwÄ¢IÃ´ÂºlÂ£Æ¾Â»UÂÅ¤JÃ´Ã§ÂšÃ³Â¯Ä«ÊŸÃ©Ã³@kÃ›Â±Â»Ç©bÂƒÄŠÃ³LÒÃ‡Ç«b@Å»É†Ã³Ê Ç“Â›aÅ‹ÃžÈVÊ‰Å‚Ä‰bÄ‰ÂÉ…Ã´'],
                    'encodeOffsets': [[
                            88887,
                            44146
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '6502',
                'properties': {
                    'name': 'å…‹æ‹‰çŽ›ä¾å¸‚',
                    'cp': [
                        85.2869,
                        45.5054
                    ],
                    'childNum': 2
                },
                'geometry': {
                    'type': 'MultiPolygon',
                    'coordinates': [
                        ['@@ÉœÃžÊŠÂÄŠÃ½VaÃ…ÂƒmÂ»ÊµÆ³Æ‘ÊÈ—Ä«VÂ¥Â¯Ä‰Â°Ã‘@ÅƒÃ…IÂ™Â»Ä‰ÂmÄŸnÂ™ÂƒaÃÂšÅ£LÂ°Ä·Ã³KÄµÄ€VÍˆÄ‰Å‚Æ¾ÇŠÃ†Å¤ÂƒzXlÂ°ÂƒÃ†LÂ²Â¼ÅºÂŽÃ´ÃˆÄ¢Ç”Â™Â¦lÂ„Ã´Â°'],
                        ['@@Æ¾IÅ¤Â@UUwÅaÂ™Ä‰ÃJÄŸÃ‘Ã†ÅŽkÅŽ']
                    ],
                    'encodeOffsets': [
                        [[
                                87424,
                                47245
                            ]],
                        [[
                                86817,
                                45456
                            ]]
                    ]
                }
            },
            {
                'type': 'Feature',
                'id': '659002',
                'properties': {
                    'name': 'é˜¿æ‹‰å°”å¸‚',
                    'cp': [
                        81.2769,
                        40.6549
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nIÃ‡ÅƒÃ›ÃÄŠÃ‘Ä ÆÅÂ™Ð³wÈÂ¥Æ§Â°Å¹Ã‘Ä·VÂ™Â¼ÃžÃªÄŠÂ»Â‚lÄµÂšmÂ¦Ã…W@Ä€Ã´ÃˆÅºaÉœxÃˆbÃžÃ†Ä¶IÐžÅ˜'],
                    'encodeOffsets': [[
                            83824,
                            41929
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '659003',
                'properties': {
                    'name': 'å›¾æœ¨èˆ’å…‹å¸‚',
                    'cp': [
                        79.1345,
                        39.8749
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@VÃ©VÂÃ‡Â™Å£Â°ÄŸUÄ ÂÂ¯mkÂ¯Ã³Â¥Ä·IÄ¡Ã¿ÆbÂƒÂ„Ä‰aÂ±Ã’Ä¸Ä€lKUÂÂ„_mÂ»nwÂšÂŽÂ„m@ÃˆÅ¤Â¦Ä‰bÃžÂ°Â±ÃžÅ¼Å‚Ì¦Â°Ä¢Å'],
                    'encodeOffsets': [[
                            81496,
                            40962
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '659004',
                'properties': {
                    'name': 'äº”å®¶æ¸ å¸‚',
                    'cp': [
                        87.5391,
                        44.3024
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„Ã§Ã´Ã‘lÄ•UÂ»Â™Â¥ÃÂšUÅ—Â™WkÃ›@Ã¾VÅ„ÃÄ”@Å„Ã…Ã¾Ä¶UXÂ¦Ã†Âƒ'],
                    'encodeOffsets': [[
                            89674,
                            45636
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '659001',
                'properties': {
                    'name': 'çŸ³æ²³å­å¸‚',
                    'cp': [
                        86.0229,
                        44.2914
                    ],
                    'childNum': 1
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lÅÂ—ÇµmÂ‚Ä‰@mÅ¼Â™Â¼nÂ°ÃžmÃ†Â¼Âš@'],
                    'encodeOffsets': [[
                            88178,
                            45529
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/xi_zang_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '5424',
                'properties': {
                    'name': 'é‚£æ›²åœ°åŒº',
                    'cp': [
                        88.1982,
                        33.3215
                    ],
                    'childNum': 10
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Æ¨Ê”Ä¸bÃœÂºÃžwnxÅºbÃžÂ°Ã´@Â„ÂÄ¶ÂŽÄ¸IÃˆÂ¼ÄŠJÅŽÃˆÃ´UÂšÃÆ’Â¤Ç”LÃžÂÅŽ@Ä¢ÂŽÈ˜blÂƒÃ´LÂ„Ã‡ÅºÃ§ÃˆÂ¤Ã´LÂšÂ¥ÃžIÃžÂ¯Ä¶xÊŠÅ¥Æ¨Â™Æ¿Ã‘Ä‰XVÄ·Å¦Â¯È‚KÃ‡Ç•ÂšÃ‘Â¯IUÂÂšÂ£Â¯Ã“Æ¿Â£VÄ•Ã…ÂÃžÃ¿Ã†wÂƒÆ‘Â„Â£Ç–xÃžÄ•Â±Ã‡ÃaUÃ‘ÃˆÂƒUÂ¯Â‚ÂUÅÃˆÃÂƒwWÅÄµÂ™Â±ÃÂ„Ã³Ä¢Ã¿Â°IÃžÂ±mÃ…Ä¢Â¯mÃ¿Â„Â¥Â°UnÃ‘Å¤ÂÄ¢Ä•Ä¶wÇ¬Å»ÍªwÅŽÂ¼ÅºÃ‡Ä¢Â„Ä Ä•ËŽÅÂ°Ã³Æ¨Â¼ÃˆaÂ‚mÂÂ@Â¥Â°wÇ”Â„Ç–ÂÂ°ÂŽÆ¨Ã‡Å¤ÂœÂšÄ¡Æ¨Â„ÅŽÅƒÃ´bÃˆÃ›ÅŽÄŠÂ°@Ä wÂ²Ã‘ÃžJÃ†ÂƒÃ†bÂ²ÂƒÂ°ÃªÄŠUÃžÂ‚lÃˆÂ²ÂƒVÂ„ÃˆKÄŠÃ’Ä¸Ä‰Â›Â»Ã…ÂÃ´Å¥UÃ…Ã‡ÂƒkÂ¯@Ã‡Â‚Ã‘kÂlÃ‡ÂÃ…lÂ™Ä¢Â™VÃ‘Ã³Âƒ@ÂÂ°@Â„Ã›Ä¸ÂƒVÂ¯ÂƒÃ‡ÄŠÂ™nÂ¯UÄ•ÂšÂÆ½Â¯mÂ›Â¯bÂ™Ãˆ@Ã’Â°Ä¬ÂƒbÄµÂÂ›Â¼Â„Â‚kxÄ·Ã½Ã‡JkÂ£ÃaUÃ‘Ã…Ã³Ä¶ÇŸkÃ“Ê‰nÄ‰ÂƒÃÂ¼Æ‘Â„Ã³Â»ÃžmnÂ£mÂ™ÄŒÂ¯@ÂƒÈ®Ã¿VÂ¯Ä¸ÂƒÂ™k@ÃÃ³wÂƒÂ»ÄŸÂ„Ä¡Â±Ç“LÅÂ„ÂƒÂšVÂ¼ÆÃ¨Ä·Ä‰Â™Ã¨Â±b@Ã’Å£Â„UÃ‘Ã³akÂƒlÂ£Â™Ã“@ÂÂ¯L@Â™Ã‡lUÃ³ÈÂšÂ¯aÄ¡ÃˆÃ…Ä•ÃLÄ·ÂÂ¯Ä–Â¯@WÄ¬Â—xÂ‚Ã’ÃˆnWÂ°Å£Ã´UÂ²Ç“Ã“Ä¡Â²VÂ°Â¯Ã´ÂƒÇ”ÃLÂ—ÂÄ‹ÂškÂ™ÂšÂ»ÃÂ»ÃÂšÂ¯ÃžÂƒVÂƒwÃ›Â„ÃÃ‡ÅÍ©ÃˆÄ‰Ä‹Â»Ä‰mÂ¯Â£WÂ¥Å£KkÃ³Ä¡ÆÂW@Â¯Â±kÅÂŽÂÃˆÂ›b@Ã’Â—ÂšÃ‡aÂƒÃ†Â¯aÂ™Â„ÂƒkÃ³ÂŽÃ›ÂƒÃ‡Â¦ÃaÂ¯ÂšÃÂ™Ä‰@Ã‡Â»Ã›Â„mÂƒÇ“xÄ·Æ›Â¯lVÄ€Ã…ÃžÄ¡bÂ™Â™Ã‡JUÂÃ…VÂ™Ä–Æ‘WÂ™zÅÂ»ÅÂšÂƒWÂ™n@Ã¨Â¯ÃžÃ³VkwÆ©nkÅºÃ‡ÃžÂ„Ã’Â™ÃžÂ¯ÂƒÂƒÃ½ÄŸÃ‡UxÃ†ÃˆnÃ¨Â±bÄ‰ÂÃÂ»ÃˆÅƒÂƒwÂšwÃž@mÂ»ÃˆV@Ã½Ã‡Â°Ä·Â™ÂxÂƒaÂ„ÃÂ¯XÄ‹Â¥ÂƒÃˆÃ³W@Ã´kxlnÂxVÃˆÃ³ÄŠkÅ¤Ä¡Â¼@Â°Â¯Å°Æ‘LÌ»Å°Â±ÅŽÃVÂ—ÃžÂ›VÂÂƒÃ‡ÃžÃ…ÂŽÃ‡akÆžÂ‚Âš@Ã¨ÄŸÅŽÄ¸Å¼ÂšÆ¾Â°Ã’ÂšLÃžÃ´Ä KÈ°Ä–ÅºVÃˆÃ’Ä ÂÂ„Â¤Â™ÂVÃ´ÂšÂŽUÂ„ÃˆÃ¾Å¥L@Ã´Ç¬ÃžlÃœÃˆnÃ‡Ã’UÅšÂ™@ÂÂšÄŠÆ¨WÂ°Â™Â°XÂÂƒÂ‚@ÄŒÃ‡Ã¾Â„Æ´Ä‰Ã’Ä·Â¦@ÂŽÄ¢Ã´WÄ€Ã´Å‚UÃžÄ¢Ç¬Â™ÅºÂ°Â¼Âš@ÂƒÃ´VÂ°Â„bUÃ†nzmÂ¤Æ½Ä¸ÂƒÃˆ'],
                    'encodeOffsets': [[
                            88133,
                            36721
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5425',
                'properties': {
                    'name': 'é˜¿é‡Œåœ°åŒº',
                    'cp': [
                        82.3645,
                        32.7667
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„Ã‡Æ¾Ä·nÂ£myVÃ…ÂƒaUÂ¯Â„Ã³Â™@Â¯Â»ÂšÅ¹Ä¡Ç«VÃÃ³ÅXÃ¿Ä¡Ã³@ÂÄ¸Â¥ÄŠÃ‘ÂƒÆ³ÃˆÃ½@Ä‹Â„ÂWÂÂšÂ¯XÂ¯Ä‰Æ§Â‚Â™Âš@VÅ™ÃˆÃ‘Ã‡mkÃ›Ç«Ã@Ã³Å¦KÃ‡Ã½VÂƒÂ™ÂUÃ³ÂšÂÂƒÂ£ÄŸÂÃ‡Ã‘Å¹UÈ¯Ä•ÄŸLÃÃ³Â™KÂ¯Ã‘Â™Æ½Ä·Å»Ä Å@Ã§ÂÂ™lÆÃˆbÃ†ÂÃˆÃÂ‚Â„ÂœUÂ˜ÃÃžUÂ²ÅÌ¼Å¯Æ’KÂ°Å¯@Â¯UKÂ±ÂÂ—ÄŠÆ§bÅÃ‡mÃ§ÃˆÄ¡ÂƒÃ³ÂšÃ…Ã³bÂ™Â™ÅºÃ³ÂšÂ¥kÄ«Ã†Â¯Ã³lÂ™Ã§Â™KÃ´ÄµUÂƒÃ…Â„VÅƒÄ·Â¥nÃ…ÅmÂ¯Â¹Ã…Â‚Â™Â»@Ã‘Ã‡ÂÃ³xÃkÊ‡È¤UÂ¤Ä·b@Æ’Â¯ÄŠÃ‡xÂ¯Ä¸Ä‰KmÂ°ÂšÄ€kÂ¦lÂ„Â„KnÄ¬È€Æ¾Ã›Â¦WÃ†Ã…ÂmÇŠÄ‰Â°ÅUÅ£Â¤UÂšÅŽÂÂ°ÂšÅŽKÃžÅ‚Ã†Â„Ç“Â¦ÂƒÃžÂ™Â‚Â™ÂÂ„Å™Â¯bmÂUÂÃlÂ¯UmÂ™ÄŸlÂ¯Â£È™wÃ…ÂŽÇ«aÃnÄ‰Ä¶Âƒk@Â¯Â™KÂ™ÂšÅÂ»Ä‰nÂ™aÃžÂ»Å¥nkmlÂ™Ä¸Â¥UÃ…ÂšÅ»kÃ‘Å¥ÂƒÂÄ‰VÂ™Ã´Ã³Â°LÃ´Ä«Ä UÂ„Ã¿Ä‰Ç•Ã…zÂ±KÂƒÂ¤Â„Â²ÅÂ¤Â¯Ä–Â¯UÃÂ¥VÄµÂ™Ã³ÃˆÅ¥ÃwÄ·ÃˆÂ™Ã‘kÂ¤Ã³Â„Â™ÂƒWÃ½ÄµÄ•Â™Â„VÄ ÂƒVÃ³ÂÂƒÂŽÇ“Â„Ä·Â°kÂÂ±VUÂ±Å£Â¦UÇŸÃÃ…Â™JVÃ‘Â™Â¥XUÄ‹UÃ…ÂŽlÂÃ›Æ†Ç•Ã†È—Æ†Â¯wÅÃžÃ…@Â™ÂšÄ‰lÃÂÃ³ÂŽÂƒÃ’Â™nUÃ´Ã…Â„lxÃ³lÃÃ´Ã›ÂŽÂ±Â™Â™LÃ›Ã´ÃL@Â‚Ä¡Â¯XÂ¯Ã‡UÃ…Â¼Ã³aÃ³Â¤Â›Â¼XÃ’Ä¡ÅŽÃ³LkÂ¦Â‚Ã´Ã…Â¼Ä¸Ä Â™Â¼Â™KÄ¡Æ†Ã´Â¦Â„Ã†Æ‘Ã”Ä‰Ä¶Â¯ImÃ’Â°Â¦nÂ°Â¯ÃžlÂ˜ÃÄŒnÂ„Æ’Ã’ÂšKÄ ÃžÂšÄ•kÂƒlÃ½Æ¾Å¥ÂœÂšÃ´IÂ‚Ä–Å¤Ã’nÆœmÂ¼Â¯lnÅ¼Ã³Ãž@Å®Ã³Â¦Â™Ã´Æ½Ä–Ä‹ÅšnÂ°ÃÂ°Ã´ÃˆUÆœÂƒblÃžÃ³ÂŽ@ÂŽÇ–Ã´Â°UÃˆÆ†Â°XÂ„Ã¾Ã´ÂŽÃ´ÂÂ‚lÑ¢ÂÂšÂŽÂ²Ä–mÂ¦Â°Âš@Â¤Â™ÂXÂŽÄŠblÃœÂšzkÂºÆ’Ä–mXÂ„ÂšÅŽWVÂšÃ³ÃžnÂ°lÂÄ xÈšaÂ°Â»Å¼LÅºÂƒÂ„b@Ã†Â°XÄ ÃÈšxÄŠÄ•Å¤aÈšÂÂ‚Â°Ãˆ@Â„Â„@Ã¨Å¤Â¦ÃœÂ¼ÂœWÂ˜ÃžkÂŽÃˆ@VÂÂ°lÅ¤kÅŽÂ±Â²Â¦ÆUÂšÇ‰Â°aÃˆÃ‘ÅŽbÄ¢ÂƒÅŽbÃ†Â¥ÃžIÈ˜lÂšÂšÃ´VÃˆUÂ‚Â™ÂšbÂ„kÉ²Ä¶nÂ„mnXbÌ¼Ã²Æ¾Ä–ÅŽ@Ä¢ÂÈ‚Ã‘Ã´Ã“Ä Ä–ÊŠÂšÄŠÃ”'],
                    'encodeOffsets': [[
                            88133,
                            36721
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5423',
                'properties': {
                    'name': 'æ—¥å–€åˆ™åœ°åŒº',
                    'cp': [
                        86.2427,
                        29.5093
                    ],
                    'childNum': 18
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Ä¶Ä–XÃ¾ÂšÂ„Ã´ÂƒlÂ£ÂšÃ’Ä¸Ã‡ÃžxÃ‡Å¦ÂšÃ´UÄ¶ÃžÂ¦Â°VÂ°Ä•ÅŽÂ£ÂƒÂ±Â„Â£Â²LÃ†yÄŠÇ–ÂƒÄ€ÄŸVÃ³Ä¬Â¯KÃ³Ã´UÂšÂ‚ÄŠÅ¦Â„lÃ’Â™Å¼VÃ†Ä·Â¦kÂšlnÅ¦mÃÂ¼ÂšbÄŠmÅŽÂ¼ÂšÂ™ÂšL@Â°Â„lÄŠÄµÃžmÇ¬bÃ†ÂÈšxÂ°Â¤Ä knÂšÂ°VÃžkVÂnÂÂ°aÂƒÅšÂšÂ‚ÂšÂÂ„ÃÇ”Â¥Ã…ÂƒÃÅÅLÂ¯Â™ÅÂVÂ™Å¤Â£ÅŽVÄŠÂ¯nÇ‰Ã†ÂXÃ…ÃœÂ¥Ç¿Æ½mÄ«ÂƒLkÂƒlÂ¥Â™Ã¿nÂ¯ÄŠLÂ°Ä·ÃˆwÂ°Ä‰@Æ‘Ä¸aVÂ£ÊˆÈ£ÃžlÃ´wÃˆÂŽ@Ã’ÂšÂ¼Ã†ÂÂ°ÂºÅnmÃ†Ä¸Â¦UÅ„Ã†ÂƒVÂ„Ã³Ä¶ÂšLÂšÃ¨Ã´kÃ…Â°lÄ¬Â™Â¦Å¹Ã´ÂšÂšÃ´aÂ™Ã†Â„Ã´Ã‡Ä¢nÃ¨ÅŽÃˆÆ¨aÂ˜Ä‰Â²Â‚VLÄ¢Â»lÅ£Ã´Ä‰UÃ‡Â‚wkmlw@Ã³Ã´XÂ„Ã‡ÄŒÂ¦Â°WÂƒÃžÂ„bÂ‚wÄ¸ÂšÃˆÂ¯@Ã¾Ã‡UnÂ¼Ã@Â™xÂ„xÃ‡Å„ÃžÂ¼ÄŠÂŽÂ²amÃ§Ã…Ã‡VwÄ ÃˆÂ„Ã¾Â°Â„ÂšÃÂƒÃ‘ÃˆÃlÅ¹ÆªmlxÃ´UÂ°Ã@Ã§ÂšmÂ„XÅŽÂ™ÅŽÂ¼ÂšyÆ’XÂšÄ•Ã†UVÂÃˆIÂšÂšÄ¢aÃ†ÃUÃ¿Â°kÄ¸ÆœÇ”wnÂ„ÃœÂƒÃˆÂ¼ÄŠ@ÃžÂšÂ°Â™ÃžbÃˆÂ¥ÃœÂ„Ã´ÂÂ„lÂšÂƒÂ°bÂ„Ã…ÃˆbÂ˜Â™@Ã‘ÂœaÂ‚Ã‡Â¯UUÂ¯VÄ¡ÂšÂ»ÂƒÂ™Â¯aVÂÂ¯Ã‡Â°Ã…Â™mnÃ‘Å¤Ã§Ç¬VÇ¬Â™Â±Ä‰Â¯Â¥VÄ•Â¯ÃkÂ£Â˜ÅÂ—w@Â±Ä¡Ã›Â°Ã‡VÃ‘Â—Âƒ@Ã›Â˜a@ÂÄŒLÂ™Æ³Â™Â„ÂƒÂÃ‡aÂ¯Â¤ÃIÄµÂ¼UÂ¥Æ¿ÂÅÄ·Ã…Å£Å»Ã³kÃÃ³Ä•Â‚Â¥Â¯Â™UÂ»Ã†Â£XÂ¯Ä¡ÅƒÃ›kÃÂ°VÂ°Ã³Â¼Â¯Ã¨WÃ´ÃžÄ–Â„ÈŽÂƒÂŽkÄ€Æ§Ä€Ã³wmÂ¥Â¯JÃ…Â¹ÃJÃÂ™ÅVVÃ…ÂaÃÂÆ‘@ÂƒÂ˜ÄŸÅ­Ã‡Â‚Â¯_ÂƒÂ˜ÄµÂ—Â›VnxÃ…ÂƒÃ³nÂ›ÂƒÄµxÃ‡Ä–Ä‰VÃÃˆÄŸVÂ™Ã’Ã³ÂƒÂ¯ÂÂ±Å»Ä‰Â£Ä·Ã†Ã…LÂ™ÇˆÄ‰Ã½Â˜Å£Ã›ÂƒÂ¯VÂƒnVÂ¤ÃÃˆ@Â°Ã…ÃžÃÂ¤Â™Å°ÄŸÅmÂ¦ÃxÃ³KÂƒÂ¥É±ÃˆUÄ Ã´ÃªVÃ´Ã›Â¼Ã‡WÃÃ§ÄµaÅÂ¦Ã³Ä–Æ§lÃ‡Ä¢Æ‘ÂŽnÅŽÃ‡Â„VÂ¼ÂÂ¼Â‚ÂºÃ›@mÂ¦Æ½Â„Ä‰mmÂ¯ÃKÃ›Ã§Â¯bÅÅ‚ÂÄ¬Â™bÂƒÂ¼Ã…LmÂŽÂ„xÅ¥Â°Ã…UÂ™ÂšÃXkÂŽÃmÄ‰Â¦WÂ„Â¯KÂ„Ã’knÃaVÂ„ÃÃ¨Â¯KÉ…Å„ÃKnÃžÂ¯Â¼'],
                    'encodeOffsets': [[
                            84117,
                            30927
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5426',
                'properties': {
                    'name': 'æž—èŠåœ°åŒº',
                    'cp': [
                        95.4602,
                        29.1138
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â‚VÃˆÅ‚VÃ´Ãˆk@ÂšÂ°K@ÂŽÂšÃ”kÂ¤lÂ„Ã´bVÃ’Å¤Âƒ@Ã‘Â²aÂšÃ§Ä¸ÄŠÆÃ§UÂ»Â„Â™ÅŽÂƒÇ”KÄ¢Â²Ä ÂƒÂ„Â¼Ã´x@ÃžÂšlÆ¨Ä¬Â„UlÂ¯ÃˆLVÂ‚ÂšÂÃžJÂ„Â°ÃœnÊŠÂÂ„wÃœbXÃªÂ‚VÃžÂ¯Â°ÂšÂšanaUÂÂ°wÃ†Â¼É´Ã‘WÃ‘Â°mÃˆÃ½ÃˆamÂ¥ÃžÂ£Å¤@Â„Â¥Ã´blÃžÄ¢Â„ÅºÂ¥Ã´xÃˆÃ…mÃÂšÂ™ÂƒÄ•Ã…ÂƒVÂ»Ä‰ÅÅ¤ÅnÃ³ÂƒÂ»ÃˆÄ«Ä·IUÂƒÄ Ã‘Â°Ä¡Ä¸LÃžÂ¯VÃ’Ã†Â‚@Ä€ÂbÂšÂ¼WÃ´Ãˆ@VÂ¼Ã´Ã³Å¤KÃˆÃ‘UÂ»ÂšwVÇ«Å¼nWÃ’ÃˆxÂ™Â¼Â‚lÅ¦Â£ÄŠÅÅ¤xÂ²Â¯@ÂƒÃ†ÂƒUÂ¯ÂšÃ§Ã†@Â„Â¤Â°Â£Â„Ã©Â°kÂ°lÂšÅ¯ÃˆÃ³@Â¯Å¤Ã‡ÃˆÄ‰ÂƒkkÃ¿Ã³Â¥ÃXÄ·Ã‘Â™Ãœ@Ã’Ã³ÅšÃÂ¯Â°Ä‰Ã³wÂÃ‡Â±Â¦Ã…JUÃ’Ä‰Ä€Ä·wÂ¯Â°mÄ–Â¯Â„Â±akxÃÃ…nÂƒÂ™Â»lÃ‘ÂƒK@ÂÂ¯lUÂ™Â¯UVÃ‘Â¯Ã³ÄŠÂ¯mÅÄŸVÇ“Æ…ÂƒÃžÂƒWÃÃˆÃ›@Æ¿Ã´Â¯ÃœÄ¡zÃ…Ã¾Â¯ÂÃ³lmÃ´Ê‡ÂÄ¡ÄŠÃ…UÍ¿Å™ÅÈË‹ÅÃ³Ã‡Ë¡ÅÆ§ÂƒÃ‡bÂ™wÂÂ°Ä¶Ã´kÂ¦ÂšÃ’ÂƒnUÃ¾Ä¡Ã’Â™Ã”kÇ”Ä·Ã¨Ã³@ÂƒÂ²@Å˜ÅÅ„ÄµyÂƒzÄ¡aÃÂ¤Ã…IÂƒÂ¤ÉƒÂÅ¥Â¦ÄŸÃ‘Â¯Â¤Ä·bÃ³ÂšÂ¯Ã³Â±ÂŽUÂ²Â°Â¤ÄŒÂÃœVnÃˆÃ†Â‚Â„ÅšÅŽÂ°Ã´Ä¢Â„Ã¾Ã†zÂÃ¨VÄ€Ã‡ÂŽÂÄ€Ã‡Â˜ÂƒXÅ¹Ã‘Â¯Â¤Ã³wÄ‹Ä·kÂ¦ÂšÅ‚UÃ’Ä¡zÃ‡@ÂÂƒÂ™Ã†Ãx@Â²Ãž@Ã†Â¤Â„UÃ´Â¦UÂšÂ°xÂ„U'],
                    'encodeOffsets': [[
                            94737,
                            30809
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5421',
                'properties': {
                    'name': 'æ˜Œéƒ½åœ°åŒº',
                    'cp': [
                        97.0203,
                        30.7068
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â™ÂŽVÄ–mÂ°Ä‰ÂšÂ„ÃˆUÂ°Ä·Â„ÂƒÃœÂ¯@@ÂÃ´Â„UÃ’Ä¡ÂškÂšÂ‚Ã†kÃˆlÂŽÂÃ’@ÃˆlÂ°ÃˆÂ„VÃ†Ã³Å¦Ã†Â‚ÂœÂ¼Â‚aÂ„Ã…Ä¢Â™É„wnÂÅw@Â¥ÅŽÂ¦Â°Å¹ÃžmVÂšÂ°wnÃ¿ÂƒwÂ„wÃw@Â¯ÂšmÃžÅ—Â°wÄ Â˜Ä¸kÃžÄŸlÄ”Â²Â¦Â°@Â„Ä•Ä¸wVÃ³Âšal@nÄ¢Ã‡ÄŠnÂ°@Â¦ÂšÂŽÅºUXÃ§Ç”Å¯Ä¸VÂšÂ™Ã†KÂ„ÃˆÃÄ ÂšÂ²Ã…Ä”Ã´@lÂÂšÂŽÃˆ_mÂ˜Â„zÇ–ÂlÂ„ÂšaUÂ¼Ã´wVÂ°Â¯Â¦Â‚Ä¬ÃˆaÂ„l@ÄŒÃ‡ÂŽÂ„Â¼Â™Â„nÂŽÂ˜IÂ„xÃ´Â»Éœ@Æ¨Â¥É†ÅÂ„ÅƒÇªÈkÆ›Æ¨ÈÊŠÈ¡Ã³Ä­Â›@Â—ÃˆÃ‡VÂƒÅ¯ÃžÂƒÄ¸Æ…mÄ“Æ¨Å¥Â™Ã…ÃˆÊ‰VÇµÂ°Ä¡VÅ­Ã…É§Â°Ã¿nÉ›ÂšÂ£mÂƒÄ·ÂÂ²ÅƒÃ³Ã‘UÄ‰Â°mÃ‡Â»Â¯@mxUÄ€Â¯Ã¨Å£ÂÂ°ÈÃÃ§Â„Ä¡UÂ¯Ã†Ã‡Å£Ãˆ@Â°Ã‡Ã´Â™Å°Â¯kÂ¯lÂƒÃªÂ¯Â¤ÂƒÂ£Ã…@Â™Ã¨VÂ°Ã…Â„@Â„Â±Â°Å£wÄ‰ÅŽÅ¥Â¤ÂkÂšÂ»Ã‡wXÃ‘Å»mUÇ¬Â™xVÂ¼Ã‡Ã’Å£LÃ³Ã´UÂ»Ã‡@XÃ³Â™Â»Â‚a@Ã¿Ã…ÂUÃ‘ÃÂ°Ä·KÂ¯Ä¢ÄŸÃ’VÂ„Ä¸JÃ‡Ä¬Â„Â¼mÃ´Å£ÅŽÄŠÅŽUÂ¼Ã†Â„Â„Ä–Â™ÂšnÃžÃ‡Ã†Ã³wÅ¹Â¦Ä¡ÂƒkÃÃ³aÂƒÂ¦Å£@ÃÂ¤nÂ¦Ã‡bÃ‡Ã¾Â¯nXÃ’É³Ã’Ã…Â»Â¯xVÂmbÂ™bÂ¯Â™ÃÂ°ÂUWÃ©Ã›aÂƒxÊ‰ÂÃ›mÂƒÂ¯ÃIÂ™Â‚UÂÃ‡KkÂ°ÂƒVÆ§Ä«Ä·Â„UÂ°È­Ä€@Â„Ä‹Â°nÂšmÂ¤ÃnÃ´Â¼Æ’ÂƒÃžÂ»ÄŠÂ„ÊŠmlÃ”ÄµÇ Ã†Ã´VÃ’ÃžblÂ¤ÃˆIÄ¸Ã¾lwÂƒÂÂœÂ»Ä¶ÂŽÂ„aÂ¯Ä«@Ã‘ÂšÃ‡Â°anÂœÆ¾Â°'],
                    'encodeOffsets': [[
                            97302,
                            31917
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5422',
                'properties': {
                    'name': 'å±±å—åœ°åŒº',
                    'cp': [
                        92.2083,
                        28.3392
                    ],
                    'childNum': 12
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â°ÃžUÄ–Â°Â¦Â²ÄŠÃ´Ã‡ÃœLÇ–Ä€ÉœÂŽÈ˜Å°ÃžLÄ¸ÂÅºÃªÃž@UÂÃœUÅ¤Â°ÉžÂ¯ÃœÂ„Â°WÅ¦Ä€mÅŽÂ„Â¦Ä¢yVÃ‘Â™ÅlÂ¥ÄŒÄ¸Ã´xÂ°Â£ÅºÃ’Â„WÃˆÂ—Â‚Ã¿ÃˆÂUÃ¿Â‚Ã§Ã…yÂƒÃ½Ã³Ä¡ÅÂ¯ÂƒÅ™Ã…ÂmÃ‡Ã›UÄ‹ÂŽÂ¯Â£VÂ±Â²ÂÂ°Ã´Ã´Â™Ä¸aÂ°Â£Ä Ã’Å¦Â¥É„ÂŽÂ„Â£Ã†JÃžÂ£Ä¢bÂ„yÄ¶zÅŽÅƒ@Å—Â„Â±Ã´@Ä¸Ã§lÇ“ÂšÃ“Ä¢Ã‘VÃ½Â„mÂ™Ã‘lÂ¥ÄµÃ³Â‚Â¯Ì»Ì¥Â™Æ›Ç«ÃÒ»Ã‡Æ§ÂÄ‰yÅ£Â¼ÒÄ“VÄ¶Ä‰ÅŽÂ°Ä¸mÂšÃžVÃÄ¸Â™Ã’Ã›aÄ‹Â„Ã³Â™Å¹Ä–ÂƒÃ¨ÃˆÃˆlÂ¼kÂ¤ÃX@`ÃžÂÅÂ¼ÂÃ†ÅÂ¼Ã‡Ã§Ä‰KUÃÃÂ£ÄŸÂ¤@Â¦Ä¡lÂ¯Ã’Ä¡ÂÄ‰Â¯Ã³ÂšÂ™mÃ³xÃÃžÄŸVÂšÆ´Ä‹K@ÂÂ—b@ÃœÂ˜Â„UÃ’Â¯ÃˆÄ¢Ãœ@Â²Â˜xÂ—ÅŽlÂ¤'],
                    'encodeOffsets': [[
                            92363,
                            29672
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5401',
                'properties': {
                    'name': 'æ‹‰è¨å¸‚',
                    'cp': [
                        91.1865,
                        30.1465
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÅŽÂÂ²l@Â°Â‚XÄ¢ÆlÃ´Å¤LXÂ¦Â°Â¤ÄŠnÄŒÂ¼Ã‡ÄŠÅŽÍªÃžÃˆÃœÂƒÂ„xÂ„UÂ°ÃÃžÂ™ÃžÂ¼Â™Â¼lÂšÄŒÂ™Â˜ÂŽÃžKÂ„Ç“Â°Ã³UÂ¯Ä¢Â±Ç”Ã”VÂ±Å¤Ã³XÂ¯Ã‡mÂÃ‘Â˜wXÄ«Â°@Â°Ä•Ä¸ÂÃžKÃ†Ä–Ä¢Ã‡Â°bÈ‚Â™Ã‡ÅÂUÂƒVÂ¯wVÂ™Ã³Â¥ÂƒVÃ…Â£Ã@@Â±ÃžwÂšÃ…Â‚Â„Ãˆ@ÂƒÂ¥nÅÅ¥Ã¿Â¯XÃ›ÂƒÉÂ°Å£Â¯Ã›VVÂÃ@Å¹Ã©Ä·ÂÃKÈ—Å¯É›ÂÇ•Ã¿Ã›KÃ³ÃˆÇ«ÂšÇ«UÅ£Ã¨mÃ’ÂšnÂ¯Ã†Â°ÃˆUÂ‚Â°bÂ„ÂšÂ™Â¼UÄ¢VÂ°Â°V'],
                    'encodeOffsets': [[
                            92059,
                            30696
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/yun_nan_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '5308',
                'properties': {
                    'name': 'æ™®æ´±å¸‚',
                    'cp': [
                        100.7446,
                        23.4229
                    ],
                    'childNum': 10
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@UÂ‚Ã´Â²Â‚a@ÂŽÂ²Â²Ä¶Â¥ÂœVÂ°ÂšÄ¶ÂÂ²blÂ¤kÂVxlÂ‚@ÂÂœÂ°Â‚ÅšÂ²@Â˜Â„Â„yÂ„@Ã´Â¦Â¯Â„@xÂƒxVxUÂ„VÂšÂšbVÂšÂÃœmÂ¼ÅŽÂ„Â„Ä¢mÂºXXWÃ†@Ä€ÂœÂšmÂŽmXUÂ°Ã…Ã’mÂ¼ÃžxÂ°wÂ„@Â°Â‚XÃªÄ ÂÂ°Â»nVÂ°UÂ„l@kÂ„@VÂ±Ã´Ä«@Â£Â‚ÂƒÄŒÅƒÃ†Â£Â„KÃžÃ½@Â¥Â‚k@yÂ„a@Â—nWVÂÂ„UVÂƒÂšwÂƒmÂƒÂ£ÂJÂƒknm@wmknÂÂ‚XÂ„Â˜ÂšXÂ„Â¥mUUÂlUnbÂšÂ¯Â°ÂŽnkÂƒÂVInÂlIUwÂ°ÂnÂ™mÂk@@mlanXlanmÂšk@wVWUwÂ™_@Ã©Ä aÂšÂnmUaÃœÂ£ÂƒmXÂÂƒÂ¥Â¯@@Â„Ã³UmÃÂ¯Â¯ÃžÃlKnxÃ´Â£ÂšÂ»Â„Â»Ä ÂÂ„JÂ°aVÂÂ„UÃÃ¿VÂ¥Ã›bÂƒI@wmÂŽÃ³nÂ¯yÃ›L@ÂƒWkÃ…ÂŽmÃˆÂ™`ÂIWaÂ¯K@Â¯mUnÂmaXmÂ™bmakÂ„Â¯ÂŽÂƒÄ¢Â™Ã’ÃmÂ¯ÂmVÂ¯KÃ‡bÂ¯KÃ›ÂœWWÂ™X@aÂ™VÂ™ÂknÄ‹LUWVÂ™kXÃ³W@kÂ™a@ÂƒÃ³bÂ¯UÂƒwmbÂÂ¥UUlaUÂ¥UÂ£maÄ·ÂšÂƒKXkÂƒmÃ@kwmÃ‘Â¯ÂkÂ±Ä‹bUUVakaÄ¡Â¦ÂƒÂƒkL@`ÂƒÂœÂ™aÂ¯xÂƒmÂ™ÂÃ…ÂƒÂ™LUWÂƒ@Ä‹nÃ…ÂŽUVÂ°LkL@bÂ°Â°@Â¤ÂšÂ²ÂƒÂ‚ÂšnÃ´Ã´kÂ„lÂ°kÃ¨Â›Ã’ÃˆzVÂ¤ÃˆÂ„WÃ´Ã´ÂƒnV@Â„ÂƒÂ¦@Â¼Ux'],
                    'encodeOffsets': [[
                            101903,
                            23637
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5325',
                'properties': {
                    'name': 'çº¢æ²³å“ˆå°¼æ—å½æ—è‡ªæ²»å·ž',
                    'cp': [
                        103.0408,
                        23.6041
                    ],
                    'childNum': 13
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â°Â°nÃžÃ´V@ÂƒÂ°@Â„Â¦WÂŽÂ„nÃ›Â¤VbmnÂ™ÂÄŸb@ÃªÂš`VxUX@xÂšÂ„Ã†ÂÃžUnnÂ˜WÃžÄ¸Ä¢ÂƒÂšÃˆ@ÂŽÃ‡Ã¨@zÃ›ÃœWÂšÃ…ÃªlÂšÂ²Â„Â˜KnVÂ¯Ä–ÄŠx@bk@@Â„Â°JÃ†Â£ÃˆblÂÂ„nnmÂ°nlÂUkVUUwVmÂ„KnÂ„Â‚nVÂŽÃžxVLXÂ¥laX@@xl@VzÃˆÂŽVmÂšk@bÂ°ÂšÃˆÄ¸mÂŽVÂ¦Â`WÂ„XÂšÂƒbUbÂ‚bXÂ¼Â°x@aÂšVVkn@lÃ¾nXUlVxÅ¤Ã…Â„yÂ‚IUÂƒkaÂ‚IÅŽÄŠ@lXx@bÂ„z@Â‚Ã´Â„ÂƒÂ¥Â„_V@lÂ‚n@Â„ÂÃ´y@al_l`nÂmÂƒÃˆÂ»@kÂƒmXwWKÂ™UÂ¯Â»Â™aÂ™Ã…@wÂƒmUÂÃKUaÂ™UUÂƒÂ™wWÂƒ@wÂ²Â»@kÃ†ÂƒVÂ£Â—mmÂ£VKkÃ‘V@@Â»nwÂƒÂ¥Â™Âƒ@kÃ†Â™nllIVlnLVakalknJÂšÂWmnaUaVÃ‘VVÃžÂnÂ¥mÂ@ÂƒÂ„Â¯UÃ¿lÂ™@Â™Â™Â™VÃ§ÂƒaXaVÂ¯UyVLVkÂš@nJlÂšXLlÂŽkxlblaÂ²Ã’l@nÂVJVkÂšxÂ„KlkUaÂVÄ·ÂÃÃ‘UÂ@Ã…mÂ¯@Â±Â™UÃ³Â°ÄŸÅ„Ä·Ä mUÂ™Ã‘@Ã‡Â¯Â¯Ã…Â¼@nml@Â°Â¯ÂÂ¯`@wÂ™Â£@Â¯Ã‡Âƒk@ÂƒÂ»nmÄ‹Â¯UÂ»Â™IÂ™ÂŽÂ¯LÃ‡Ä¶Ã›n@bÃ³Â°Â™UÂ›ÂšÂwmÂŽÂ¯Â„Â™UmÃ‡Â¯aÂ„Â™ÂƒÂ™ÂƒI@ykIÂƒVUÂŽÂ¯bÂƒIÄŸÂŽÂƒÂ¼Â™Â¼Ã³Â¤mwkLÃÃž'],
                    'encodeOffsets': [[
                            104243,
                            23429
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5326',
                'properties': {
                    'name': 'æ–‡å±±å£®æ—è‹—æ—è‡ªæ²»å·ž',
                    'cp': [
                        104.8865,
                        23.5712
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÂšwÃ´Â„Âš@Â²Â¯maUmÃ´UÃ†xÂš@XÂšÂ˜bÃžInlVUVwÂ„JVaUÂÂ„KÂ°Â¥Â„xmÃžXnlKlnnaÂ°@ÄŠÂÄŒÂ„Ã†wUmnkl@Â°ÂƒÂƒÂ£nyn@VÂV@VakÂ™Âƒ@@kÃžÃÂ„bmxÂ°VnwÂ°klÂÃžInÄ–ÃžVlKlÂ™@ÂXaÂ°Â„Â„KlVÂ„U@ÂÂšJnxÂ‚U@ÃˆÄ¢bUKlm@ak_Â‚wÂšanWUkÂ°ÂƒlÂ»Â„k@Wk@lwU_Âƒ@UalÃ³UÂ¥ÂƒÃ‡nÂÂƒÂ™kJWÂÂƒ@ÂÂmVXxÂ±bÂƒK@nÂVÂ±a@Â™Ã…aÂ™Â£ÃKÂ²ÂƒWknamKknÃ‡ÂkÂ¯ÂƒaVÂ™Â™VÂ¯Ä€ÂƒUÂ™Â„Â™Ã’ÂÂ¥ÂƒI@mmÂ¯Â¯xÃ…ÂW@@`k@Ã³Â»ÂƒUUÂÂ¯lmÂ£Ã…WlÄµÂ„w@mmwÃ…mWÂÂU@yÂ±UÂ—xmwUÂ„Â¯UÂƒÂ¥ÃÂ¥Â¯Â£m@kÂŽÃ‡VUÂVÂ°VbklÂƒLÂ™wUlUImÂ‚k@Â±Ã‘kbkalwkÂWKkÂ™mIÂ™@UlUKVzUÂ°WbÂ„bUÃ¨ÂšÂš@ÂškÂšVÄ€ÂƒÂ°@Â„nÂ‚mÂ¦ÃÂŽUUUÃ’VbmbXnÂ™Â‚mIkllbUbmKUkkJmkÃ…Âš@lÂšÂ„Â„Â¦mx@Â¼U@lÃ’ULnÂ¤Â˜nUÂ¤Ã…Â„@lÂ±Â¼@xXÂ„ÂšxVÂ„ÂšVVbÃžLVÂŽÂ„n@xÂšÃ†ÂšbÂ°Â¼ÂšV'],
                    'encodeOffsets': [[
                            106504,
                            25037
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5303',
                'properties': {
                    'name': 'æ›²é–å¸‚',
                    'cp': [
                        103.9417,
                        25.7025
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÃˆÂ¦lKÃžÄ•UÂVÂÂ¯UmÂ¯Â„Ã‡VUnVVUÂƒÄ‰nÂ™ÄŠÃ‡Æ¾LnÂ°Â°ÃˆÂ„JÃ†wÂ„@lbÃžaÂ„Â¦VÂ„XJÂ°Â¯WÂ¯Â„aÃžJVkUÂÂšaÂ„Âƒ@ÂlKnÃ…mWUkÂ¯aÂ¯Â»@ÂmÂ±@Ã‘ÂƒkkbWWX_WÃ“UÂ»Â_lÂ™kÃ‘m@UÂ»m@Âl@IWÄ‹nÂ¯l@VanVÂ„UVÂ™UÂVwVxÂ„KÃˆÂ„VmUÄ“Â‚@Â„Âƒn@VÃÃ†LÂ„wÂ„VVwnVlmkUVÃ‘Ã‡Â°ka@kÂ™Ã¿ÃaÃžUlÂ£Â™Â›ÂÂ—Ä‹Ä•XÂ±Â±Ä‰Âƒa@UnVnalÃ³nk@wlÂ™UVmkÃJÂ—aWÂ™Â™@Ã…wÃ³VVnnbÂ±Â°Â™@Ã³ÂƒÂ™xXLWxÂ„n@lÃ‡Â¼nÂ„mÂ‚k_k`@bÃ³zÂƒÂ‚m@kÂU@Âƒ`Â„Â¦Ã³Âƒ@nWÂš@ÃœÃ…XWwÂ@ÂƒyÂƒbÂÂ¦@Ã’lnUb@xÂ™lÃœÂkÂ‚@Â²Ã‡@UÂƒÂ¯bmy@ÂkV@bÂƒbÂ„Â¦U`lLVx@bÂ—LlÂ¼ÃžÂ¤@Â„Â°VVÃžÂ„U@WÃžÂUbÂ›J@nnÂš@lnnmÂ„ÂšxUÂŽÂƒUUbÂƒK@ÂšÃ‡wklkUÂƒVWakn@ÂŽlbU@@Â„ULVxkKUnÂ‚Â°Â¯Ã’@Â¼Â™Â„kmÂƒÂ¦m@klÂ™È°@lUÂ„lÂ¦Â„@VlÂ°wÂšnnÃ¾ÄŠUÃ†bUxÂ™bÂ„ÂŽVÂ„ÂšÄ–UÂ°Â„aÂ‚nnaÂšVÂ„al@@b'],
                    'encodeOffsets': [[
                            106099,
                            27653
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5323',
                'properties': {
                    'name': 'æ¥šé›„å½æ—è‡ªæ²»å·ž',
                    'cp': [
                        101.6016,
                        25.3619
                    ],
                    'childNum': 10
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@mÃ’ÂXU`WnÂšÂšÂ™@XlÂ±Â¦ÂšÂ„UxnblÂ°knmKUxÂ„Â„ÂƒxVÃ´UxÂ°Â¼Ã´Ã’ÃˆÂ„Â°JlnÃžKÄ ÂÂœWÂ°Â¦ÂƒÂ„VxÂ²JVwÂš_Â°Â¥@UV@@wnymknKÂ¯I@ÂÂ‚Â™Â²bÂ°ÂƒÂšÂ£VÂ¥ÂšwUÂÂ‚VÂ„Â¤nLÂškÃ†JÃˆwÃ´Ã´Â°Â„lÂ»ÄŒÂ¯ÂƒÄ¡VÂƒUU@Â@ÂƒÂ°ÂƒÂƒÃXÂl@UÂ»Â°Ã…Â„@UÂÂ„Â¯@wÂ±Â¯VmÂUUlm@mÂ™Â„Ã‘nIVyUwmakÂ£VwmÂ±Â—@Ã‡w@nÂƒ@UxkwlÃ‡nLÂ‚mkÃ…Â™@Â±ÂŽkÂ™ka@kÃ³JVÂ¯Ã‡Â»UÂ£lwÂ¯Â™XalblÂ¥Â¯UXÂƒ@aÂ˜Â™UaÃˆL@Ã‡VIVÂƒkaUÂ¯mmÂ™akLWkUJÂ¯UmxnÂšÂƒ@ÂƒkUxÂ¯xÂƒÂ„mWÃ…Ä«ÃkkbÂƒÅ¤ÂƒbkxWmXwWkÂ¯wÂƒKkÂƒÂƒLÃ…Â¤Ä‹Å„ÂÂ„@Â¤Ã³Ä¬UÂ²Âƒ@@lÂƒkÂ¯VmUÂ¯Â¼@xV@kÂ°lÂ°kbUÂšÂ°nmÂ‚VnUÂš@Â°Â„ÂšÂ„UVÃ¨ÃžÂƒÃ†bUÃ’ÃžnUÂ¦Â›VÂ—Â¼lÃ´Â„@Vl'],
                    'encodeOffsets': [[
                            103433,
                            26196
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5329',
                'properties': {
                    'name': 'å¤§ç†ç™½æ—è‡ªæ²»å·ž',
                    'cp': [
                        99.9536,
                        25.6805
                    ],
                    'childNum': 12
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lbÂœKVIUaÂ˜@Â²m@bÂ™xÃ´Ã’ÃœxXLmbnÂšl@ÂšÂ„Â„KÂ°ÂšÂšÂ¼kÂ„UÃ´Â‚xÃ´lVÂ¦nJÂ„UÂšÂ™Ã†nÂšmÂ„@ÂšxÂ„ÂÃ†wÂšbXÂšÃ†ÂÃ´Ã´Â„LUÂVwÃ´K@wlmÂšaVwÂœ@WknmÂƒIUmlÂnJla@_Â™@kÃmKUaÂšÃ‘mÂ¯XwÂ°aUaVÂlÂ»Â²JVÂÂ„bÃ†JkÃ´Ä¶Ä€Â²VVkÂ„mÂšbVwUÃ³Â„wÂƒÂƒVwnLlmkÂ¯maVwÂ™ÂƒÂ²Â¥WkÂš@Â™Â™XmV_Â‚WnÃ‘UkÂƒ@kÃ³Â˜Â»ÂœUVÂ¥ÃmVÃ‘Ã…aÃÂ„UÃ§ÂƒVÂƒÂ™@Â¯VÂ™UmnÂÂ¯mVÂ™lakÂ¯lÂ¯U@@wÄŸÂŽWÃ©Â¯ÂÂƒ@Â¯xÃwÂ¯ÂšÂ¯JÄ‹aÂ¯ÂUÂ¥mLUÂ¤Â„bÃžÈ¤ÂƒbÃ‡LÂWUwmIUVWÂ¼kbÂš`UÂ„VbÂ¯LÂ±ÄŠÃ›kÂƒÃ¿ÃKkwÂƒKÅ£ÃªÂ™UÄ‰Ã¾ÂƒÃˆÂƒVÂ¯ÃžVbUÂŽÂ°KVÂškÂ²ÃÂ‚mIÂ—ÂƒmV@kÂƒmÂ™UkÂšVxmÂ„Â¯KXÃˆÄ·JUÂ¦VÂ°ULWxÂšL@mÃ´ÂƒÂšb@bkxÂ±LnVUÂŽVLnkÃœWnwlLÃ…Æ’mW@kkJU_ÂƒVÂ„ÂšWÄŠÂ„Ãž'],
                    'encodeOffsets': [[
                            101408,
                            26770
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5309',
                'properties': {
                    'name': 'ä¸´æ²§å¸‚',
                    'cp': [
                        99.613,
                        24.0546
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â‚xÄ¢Â„l`Â²XÂ°ÂŽVÂ„Âšx@xÂ°ÃžÂ°KXaÂšÄŸUÃ‘ÂšWÂ‚bnIl`XÂ²Â°bÂ„xlÂ°Â„Â„ÂšV@xVxkÂ¦mbÂ„l@xÂšXVÂ‚Ã†zXÂ¤Â™ÂÃ†Â˜kÂÂ°Â„kx@lÅºÃªlaXÂ»VUnJVxÂ‚XÃˆKÂ„aÃÈ£ÂƒaVÂ£nKVÂ¦Â°Â‚ÄŒbÂ°IÂ°Â™nÂ»Ã†Ã‘VÂ¯nWnÂÂ›Â™@Ã¿XÃ…WWnÂ¹ÂƒÄ¡ÅÂƒnÂ»Â‚Ã›UÂ™Â™aUÂ™VÂƒUwÂ„w@wÂ°ÂƒÃ³Â¥Âƒ@ÂƒzÂ—ÂƒÂ±@ÂÅ™Â›Â¯@ÂkÂUwlÂkÂ£Â±aÄµÂŽÂ¯Â™Â›UÄµÂ¦Â±Â±@ÂÂbÃ³Â±VÂÃ@Ã³Â¤ÂƒwÂ¯I@mÃ…Â„Ã³mÂ±ÂXÂŽÂ¯IÃ³lÂƒK@ÂÂšÂ°UllbÂ™zkKlln@@Ã”Â™ÂºÂƒUmVkÂ²Ã´Ã’Â™xÂ™ÅŽUVÃ³LÂƒbÂ„ÂŽmÃˆnÂŽmbnlÂ‚aÂ„x@zÂ„@Ã†ÂŽÂ„Â¦kÂš'],
                    'encodeOffsets': [[
                            101251,
                            24734
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5334',
                'properties': {
                    'name': 'è¿ªåº†è—æ—è‡ªæ²»å·ž',
                    'cp': [
                        99.4592,
                        27.9327
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@WÂ™XwÂƒÂ™@akk@yÂ›Â—kÂÂ°Ä«XÂ¥Â›UÃ³Ä·Â¯w@ÂnÂ»UaVaUÃ›ÂƒÂÂ¯ÂƒmÂVÂ¼kÂ‚Â™ÃžÄ‹Ã´@nÂ¯xÃ›Ã’mÂ„VÂ‚Â¯Ã”@xÂƒÂ‚@ÂškÂÂ™wmÂ™Ã…a@ÂƒUaÂ‚ÃÂÂ¯VÃ…ÂƒyVÂÂ„a@Ã¿ÂšÂnÂ»ÃVmankÂ™mmÃžÃ…Ã´Âƒ@nÂ£Â±Â›ÄŸzÃ‡mUÂ¦Â™VmÂ„nÃœmbnÂ@Â°nV@xmzÃ…@mÂºVÂ¦kÂ°lnÂÂ¤ÂšÂ¼ÃµÃ´Â„n@xkÃ†ÂƒIUxUÂš@Å¤ÂƒÂ¦VÂšmVkmkXWÂ¤XzVx@Ã†ÂšxÂ™Â¼ÂƒÃžÂ¯b@lVÂšÂ™Ä¸ÃžÂŽVÂ„mÂ¼XÂŽmÂ¦VÂ„ÂÂŽÃž@Ã†ÂŽÂšÂ¹VÃ³nÂ¥Ã†KnÂ„Â‚KXÂÂ¯x@Ã¨ÄŠÃˆÂ±Å‚XÂÂšaÃ†xnlV@UÃ›lÈ»kÄŸVÂ¥Â„ÂmÂÂ²Ç‰mÃ…ÃžÄ•Æ’Æ›mÂ°Â„Ã†mÂXÂ¤mznÃ†ÂƒÂŽVÂ¦ÃžVVbÂ°bnÃžWbnÂŽÂ°l@ÂVÂ„Ãˆ@Â„Â‚VÄµÄŠÂ±@Ã³Â„InxÃ†wÂ„Â¥@Â£ÃžÂ›WÂ¯Ä¸Â£UÂƒUKÂ‚ÂƒkÂÂ±akkkbmWmÂÃˆÄ·Â„aÃ†Ã‡UÂ—ÃˆÂƒÃ†W@wmknmUÂ¯'],
                    'encodeOffsets': [[
                            102702,
                            28401
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5306',
                'properties': {
                    'name': 'æ˜­é€šå¸‚',
                    'cp': [
                        104.0955,
                        27.6031
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@mÂƒnK@wmÂƒUÃ…Â™Â¥mÂšÃ³XÇ“ÅmX@ÂŽÂ—VÂƒÂmL@xÅ£ÂÂ™nk@mlUÂšÅ»Ã’ÄŸÅ‹@ÂÂƒL@mmLkmÂ™Âš@bÂ™XÃ…ÂŽWÂ¼kaÂ¯lÃ‡Å¹Â¯aÃ‡Â»Â™ÃÃ_@mÂ„@@aÂ™@UklwUm@ak@ÂƒbÂ™UmbÂmÂƒbVÂ¯Â™Ä•UÂƒÂƒÂÂšaVwÃ…aÄ‰VmÃ½Â™mÂ¯xUkÂƒ@kÂ¥VÂƒUXÂƒÂ¤VÃˆm`@Â„Â—Å„Ã‡Ãœ@Ä€knÂ‚Ä”kÆžÃ†Ä Â„Â™ÃžÂšÂ‚UÂ„VÃ´Æ†ÃžI@ÂŽUxÃ†Â¦nÂ„l@ÄŠÄŠnxUÃ’Â°Â¦VbÂ¯WUnWÂŽÂIml@xnÂ„UbÃ´Â¤Â‚Â¼ÃˆxlIÂ„Â»ÂšKVÂšÂ„@ÃˆÃ”Â‚JkÂšUÄ–Â±Ã†Vb@nÂœÂ„VÃœVUVÂƒÂšLÂ„wÄ lÂ„knÂ„Ä @nxÂ°Â¥Ã†Â„Â²mUwÂƒ@mÂÂ™mÃ…UlÂ¯UÃ‘ÂšÃ‘UmÂ„LllÂ„IlÂ±Âš@VÂkwÂƒW@wÂ°@UÂ»Â™kUÂÃ³IÂ°ÂƒÂ„Â»Ä¢Ã‘Â‚LÂ„Â™Âš`nUÄ Â²lmÂ„bÃ´V@nÂ„JUxÃ†Â¦XÂ¦l@ÂšÂ‚ÅŽÂUÂƒVÂÂ„@lVÂ„KVÃ…Â™ÂVÂ£UaÃžUÂ™ÂƒnW@Â¯VU@Ã³Â™Â'],
                    'encodeOffsets': [[
                            107787,
                            28244
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5301',
                'properties': {
                    'name': 'æ˜†æ˜Žå¸‚',
                    'cp': [
                        102.9199,
                        25.4663
                    ],
                    'childNum': 11
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@n@VkÂ‚VUnÂ²Â°@xÂƒÂ°VÂÂƒ@Â¯Ã†VÂ¼k@WÂŽÂ„ÃžÂ¯Â„@Â„@Â‚VVUÂ„Â„Ä¢Ä‹Â°kÂ¼VÂ„ÄŠxÂœÂ¤ÅŒÂÂœxÂ°mVkÂƒÃ‘ÃˆÂÂšLÂ‚Â°Â„xÂ°XÂœÂ°VmÄŠLVxUÄ–Â°bXÂ¦VW@kÂšÈ¯lkn@Â„Â¥lnÂšÂƒ@Â»Â°Ã‘ÂÂ¯VmlLUwVK@ÂƒV@ka@ÂlmXbÂ„UlVlkÃˆx@Â™Â„LVaÂ„VVÂÂ™wnÂƒmm@kmÂ™@mÂœIVaÃÂ@XÂƒVUÃÂ¯U@ÂƒÃÂ£kÂ»Â˜K@aUwkKV_ÂƒÂ¥Â„a@alU@ÂnzÂ°aVÂ„Ãˆ@@Â±lÂÃ›ÂÂšk@wVakm@Ã‘Â‚Â¥Â„aÂ„zÂ‚@XxÃ†W@Ã›XÂ™@m@ÂÂƒy@aWw@kÅÄ‰ÂJlbVÂ„ÂJÂƒzÅ£Ã†UwVkmWkÃ½m@UlÂ™U@bÂ¯wVÂºÂƒUÂ™VUÃªÂšÄ ÂƒXUaUbVÄŠUÂŽWXUmkKÂ™Â™WnUUUÂ™VÂ™ÂÂƒÂƒVVÂÂ™Ã@kkÂ±Â‚Â™Â¯ÂƒÂƒLÂkÂƒÂšÂ±WkXlVklÂƒ@ÂƒwXbmLÂÂƒÂ›VUIVmk@Ubma@kkaVKUÂƒÂ™kmlXLWnÂ™JÂ¯Ã’ÄŠÂ°@zkÂºlLUÅ¤n@@nÂ›Ã´Â@lÃ†ÂnmKkÃˆlxVwÂ„@@mÃˆxÂ˜@nÂ²UxlÂ¤nbVxUzmJÂƒÃ’nÂš'],
                    'encodeOffsets': [[
                            104828,
                            25999
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5307',
                'properties': {
                    'name': 'ä¸½æ±Ÿå¸‚',
                    'cp': [
                        100.448,
                        26.955
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lÂ@Â™Â„Â@wÂ°Ã“UÂnÂƒÃœÃ‘Â°w@mÄŒÃ³ÂšÃlÂUÂ»nÂÂ°Â„Â„ÂVÃœUbVbmÂ¼@ÂŽÂ°xÃ´Ä¸ÂœVWÂ¦Â¯Ä¬lÂÂœÂ˜@zll@bÂ„ÂšWxXÂšÂ‚aÂ„ÂX@Ã†Ä Ã†aXwl@XaÃ†Â¦nÂ¼Â˜JnÂ@mnKWÂ¯ÃˆÂ»VÂ¯Â°akÂ™VanXVwl@VyUÄ•VUÂ„bÃˆÄ«laUkÂ°ÂƒkÂ¯lÂƒÂ²VÂ˜UkÆ›Ã´Â@ÂƒÂ„I@mVwÄŠaÂ„Â™ÂƒÂVakaÂ„Â™Ã†bUÂŽVLÂšaXIWKUwÂ™ÂƒÂ„aWÃ‘Ã…KUaVkÂ°Âƒ@ÂUwÂ„ÂƒÂ¯Â¥Â›XÄŸÂÃLkmÂ¯IÃ‡ÂƒÃ³Ã‘Â¯Â»Â™aÂƒnUlÂ±UÄµÃ¿lÃ³Ã…IÂƒaUÂ‚Â±IkÂ¼UÂŽVbÂ¯bWxnÂ°Â™Ã’VbnLlÃžÂš@@`kbmIkÂŽVnÂ„JmnXlÂ›@UxÂ™bkn@xÃ³LUxVÂŽÂƒKÃ³Ã³Ã…ÂWÂ™Â™aÃ…xÂƒÂŽÂ™wÂƒ@Â™nÃ…mÂ™ÂšÂƒVÂ™Â„ÂƒÃ´XÂ„ÂƒLlVUÂ¤ÂƒbÂÂ¦mÂ¼Â™ÂŽ@Ä€ÂƒbUÂ‚Â„zUÃ†Â‚Â°ÂÃžVb@Â„Ã†bnÂšÂšx'],
                    'encodeOffsets': [[
                            101937,
                            28227
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5328',
                'properties': {
                    'name': 'è¥¿åŒç‰ˆçº³å‚£æ—è‡ªæ²»å·ž',
                    'cp': [
                        100.8984,
                        21.8628
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lÂ²Â°ÂŽnÃ’lxÃž@Â„nWlÂ„LÄ¸Â™nbVÂ¤VÂ¦kbVVÂ‚Â¦naÂ„xÂ°VÃ´a@Â„Âšb@lÃ´XlWUÂšVXÄŒKlmÂšÂÂšU@bÂšWXXÃœÂ›Â°LÃˆaÂ°LnUÂ°Â‚ÃžnÂšÃ‘Â„Ä¡Â°ÂlÂƒnbÂšaÂƒÂ¯Â¯KWÂƒÂœÃ³@kmK@UÂšÄ‰V@kÂÂ°ÂÂ„VVÂ¹Â„a@yÂ‚_ÂÄ‹l_nÃ“lL@anI@ÂƒÃ³WlÂ£VUÂ—ÂƒlÂ™kÄ•lÂ™ÂšKVwÂ„U@Â™kVÂƒamÂ¯Ã…L@bÂƒÂ‚Ãk@VnÂ„UbÃ‡bÃwÃ…@Ä‹Â¥Â¯lkÂÂ‚Â¼Ã…ÂŽÂ™Ã’Â°b@Â¦nlUn@ÂŽÃ‡VÂ„ÂmÃ†ÂbWÃ´U@ÃÃ…ÅmÂ™Â¯ÂƒaUÂ™Â™mkÂÂ™WWwÂ—@Â±ÂƒÂ™nÂ¯UÂ™Ã¨Â™aÂ™LÂƒÂÂ¯mÂƒLÂ™ÂškwÂƒl@Â°mnÃˆÃ’Â¯ÂšÃ³w@VÂ™xÂƒÄ€UÂ¤Â°Ä®ÂƒÂ°Xl'],
                    'encodeOffsets': [[
                            102376,
                            22579
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5305',
                'properties': {
                    'name': 'ä¿å±±å¸‚',
                    'cp': [
                        99.0637,
                        24.9884
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XÂ°Â„IlÂ‚@Â¦ÂƒÂŽÃˆÂ¼mÂ¼ÃžaÃžÃ…lÂ„ÃˆxVÂ¼ÂšlVÃ´ÃˆÃ†lLÃžÂ£ÃˆÂºlkUÂƒÂ‚ÂƒUwÂ„Â¯UÄ•VwÄŠ@nÂ¦mlnVÄ¸IWÃ‡Â°LnÂƒUwlÂ™ÂšVÂ„n@lnUÂ˜Â„nJÃžÂlÂ±UÂ™Â¯LVÂUaÂ°ÃÂ„UÂ„Ã‡ÄŠÃ½ÂšVÅ¤Ã©Â„LlxÃžLÂ„Ä€ÃœlÂ²Ä‰Â°KUaVÂƒÂ™_Å¹Ã©@klwÂ¯ÂƒlÂÃ…Â—ÂšÂWÂ£Ã…yUÂÂ™W@wÂƒknalÂ¥Uw@wÂ™UÂƒÂƒkÂ¯ÂƒwÂ¯aWÂ±k_mJÂaÂ™XVÃ’Â™Ä WbÂ¯LÂ¯Ã@wÂ™wUÂƒÂ¯ÂÂ±Wk_Ä¡ÂƒÂwÂƒwÅKmb@Â¤Â„bkÂ°lÄ–ÂƒÃ´Â„ÂUJÂƒÂšVnÃ…lÅ¥ÂUÂšÂ¯Â°VbnbWxXÂ„mÂ„ÃžÂšÂšWUÄ€Â™LÂ™yWzÃ›KmbUxVKknÃÂƒkÂŽVÂÂšÄ€Ä‹Â¤UxÂ„Â@ÂŽÂ¯ÂŽm@ÂƒÂ¦'],
                    'encodeOffsets': [[
                            100440,
                            25943
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5304',
                'properties': {
                    'name': 'çŽ‰æºªå¸‚',
                    'cp': [
                        101.9312,
                        23.8898
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lÂ„Â„LÂ°xXlWxXnlwÂ„aÂ„Å£laÃžlÃ†Ä¬nXÂ„ÂƒÂ°wVwÂ„lÂ„@mÂ™nwÂ°VVIXllKÂšbnnVÂ°lbUÂ„UJ@ÃˆÃ‡KVbÂ—Âš@bWÂ„Â°VkÂ¦kaWbÂ°ÂškxVÂ¤ÃˆÂ¼UÂ°Ã´I@llblÂšÂ²ÂÂš@Â‚@ÂœÃ³@mm@VÅ£kKlÂ¹@yÄ‰Â¯Â°Ã‘ÂšIXmWKnkÂšlVÂ„ULlb@lnbVal@UnVJÂœUÂ‚Â„nKWaÂ„xÂ„@lkkUlWÂ²XÂ„Â™Â‚lÂ„KÂ°Â„ÂÂšlÂ²@lÂšÃžUÂŽÂ„UÂ‚Â„UÂšVÂšVVXmÂšÂšlLVnXWVÂUÄ‰VaVbÂ„WÂ™ÄŸVÃ©ÂšUÂ„VUÂ¹WÂ»ÂaVaÂ„aWÂ™XÂƒÂ‚_UÂ¥nÂÃ‡Ä·Â¯Â™@aÂ™lUnÃ‡ÂUyk@@wW@kbWÂ¦UKÃwUÂÂmmÂƒÂƒLUnVxUVVlkÂÂ¯mmnÂƒmkÂÃ‡aÃ…Â¤Â¯I@Âƒl@@aÄ‰wÂ°Ä•mUÂ—LÂ±ÂƒkÂ™Ã†Ã©XÂ™ÃœÃ›@yÃˆÃ§@ÂÂ™Ã‡Ä¡Â„ÃÄ·Â—XmmÃVÃ…ÂÂ™ÂƒÂ™lmnkbmWkb@nl@nÂŽmÂšÂ¯ÂVxkJmÂUJÂ„ÂmlÂ¯ÂÂ™Â°makVVÂnVÂƒÂ¦Â™WÂƒÂ—ÂWmÂnl@xmnÂ„lÂ‚IÂ„Â¤Â„nÂ™xUÂ„ÂƒVUÂŽmX@Â˜Âƒb@zÂl@Â¦ÃÃ¾'],
                    'encodeOffsets': [[
                            103703,
                            24874
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5333',
                'properties': {
                    'name': 'æ€’æ±Ÿå‚ˆåƒ³æ—è‡ªæ²»å·ž',
                    'cp': [
                        99.1516,
                        26.5594
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@WyXÂ£lWlnnUUÂ™Â„Â¥@Å£VÂ™VwÂ„JlÃ…@wÂƒmÃ¶Ã³Â™Â»Â‚Â£kmlÂ¯UÂ¥nÂ¹Ã†@ny@wmU@Â¯mÂnamÃ›nÂƒÂšUVÂ¥ÃˆnÄ yÂ²ÂœmÂ¤Â„@Ã†Ã³nÃÂšnmlnbÃžUÂ‚Â¥Â„aVÂ£kUÂ„KWÂƒÂ„Ã³ÂšÂƒmIUÂ¥Ã³kÂwVÃ³lÂƒÂ™Â»Â¯Â™ÂƒLÂ™Âƒk@mÂ™naWKÃ›wÃ³Ã‘Âšw@aÂ±nÂ—@VbUJÂ›LkaÂƒÃXÄ‰ÂƒÂ™Â„UV`lI@lnXÃ†Æ‘kKmxÃ›XmlUKVÂmUÂ²Klw@aÂ™aÃ³Â„@nÂ™KXwVKUÂ¯VÂ¥mUnkmÂ¥Ä‰@UxVÄ–ÂƒÂ°VxÂÂ„VÂ„klmÃžÂ™ÂkKWÄ€kVWÂšnlÂ°Lnm@ÂÂ°ÂŽUxlV@nkÂ¦Â™JVÃˆÂ°ÂŽVÃ’@nXÂ°@Ã†lÂUÃ´mlnÃ´ÂƒÂ²nxmÅ‚nVVÂ„Â¯x@ÃˆmÂ°XblVUÂšlÂ°@xkXUÂ¤WXXÂ‚WÂ„XÃ†ÂƒÂ„mkÃ…JmÃžÂwÂ±bÂƒxUÄ«kKmÂÃ…VUÄ–ÃÃ¨VÂ„kx@ÂšÂ›lXÂ„lnkÂ¤ÂƒLkÂŽÂ‚Ä–kÂ¦Â‚xUÂšÂšLÂ°Â‚Â¯Ä–@LnK@bÂ°xVIÂ„Â¥UaÂ°Ã‘@Â»nm@Â¹Â‚KÅŽÃžÃˆWlnÂ²n'],
                    'encodeOffsets': [[
                            101071,
                            28891
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '5331',
                'properties': {
                    'name': 'å¾·å®å‚£æ—æ™¯é¢‡æ—è‡ªæ²»å·ž',
                    'cp': [
                        98.1299,
                        24.5874
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„Â¥n@Â°Â@ÂÂƒÂVwÄŒÂ£Â™Ã¿UÂlÂÃžÂ„lmULVwnaÃœLXyÂšzÂšKVÃ¿Â™XÃÂ™nÂƒWÂƒXwmaUaÂ°Â¯VÂ™Å¦ÂŽÃ†kUmÂ„Â™VIÂƒÂÂ„Ã³kÄ•lÂ¯Âƒa@Â£namaÂ™@Â¯mÂ¯ÂœÃ³@Ã³yÅ£bÄ¡kÃ…mÂ±ÂÃ›ammVkÂƒLÂwU`Wk@VÂƒkUmÃ…ÂƒlUUKmbkkUVUwÂƒÂ¦Ã³ÂŽÂ°Â¼ÂšbnÂ°Ã´Â¦lÂºÂƒz@xÂšÂŽÂ¯Â„Â™@UÂŽÂ°nÂƒÂšUÂ¤Å£UÂ„Â°VÆ†@ÃˆmlnzÃžlÂ°Â¦Ã†aÂ„xUxÂƒLkxWÆ’n@Â‚ÂšÂ²Å°ÂšWÂ„Â™Â‚@Â°ÃˆXlÂ°Llx'],
                    'encodeOffsets': [[
                            100440,
                            25943
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/util/mapData/geoJson/zhe_jiang_geo', [], function () {
    return {
        'type': 'FeatureCollection',
        'features': [
            {
                'type': 'Feature',
                'id': '3311',
                'properties': {
                    'name': 'ä¸½æ°´å¸‚',
                    'cp': [
                        119.5642,
                        28.1854
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@VÂ‚bVl@XnÂ‚UXÂƒKVÂŽ@Â¦nxlUXVÂ‚nÂ„KVmnLÂ‚ÂUV@bnÂ¤lLXKÂ˜Â²Â„`nnlJXIVJÂ‚IÂ„VnnÂ°KnnVll@VLXWV@UkVaVKÂ„zV@Â„ÂƒÂšVVaUK@ÂUÂ»VUl@@WnUUÂƒ@wVLn@Vwl@XWÂ°LVbn@VUÂ‚@XÂ„l`@XnKVbkl@XVJlUnlVÂ„Â„xlL@lnXlÂ„@VÂšUnVÂ°ÂÂ°Â„@aÂ„UVLXblWVXn@VVUV@LÂšÂ¤VLVÂ„UÂ‚VbnalLUUVÂX_laVaÂ„WVzXKV@@a@KUÂmImmXama@kÂU@yVIUKÂ‚aVa@kXK@aWU@VÂIUmW@kkVmÂ„UÂš@VwUa@K@k@UÂƒ`@kUKVk@UV@VaUmÂ²ÂVy@klUUWUkVmUa@_ÂƒKVaXaÂ›ÂXmÂƒU@mUÂlWkaUXÂƒ@mmkL@wÂ™JÂƒnVVÃ…bWKXaÂ™@@I@aÂƒJUUÃ‡@VÂ„ULÂ™W@akLmb@K@aÂ™XXw@mÂƒVmUVkUy@Â£@aU@@VkUWm@kUKÂƒXUWU_mW@wkkmJUUkLWWUXÂƒW@IkJ@k@mW_kÃ“Âƒ_UlÂ™LÂƒm@I@aUaÂ¯m@kÂƒaÂ¯LUJÂƒ@mVVxUbÂ™a@LUKkXÂƒbm@Uak@@a@Um`ÂƒIUbUJ@nUVW@@LnVV@lÂšUbVlUX@`ÂÂš@blXklWÂ„UÂšmÂ„XlmÂ¦U@@VÂ¯bml@Âš@nUb@llnn@VbX@lV@ÂŽUVULmU@JVnÂ„bVbkbÂ™VWxU@@nUVk@'],
                    'encodeOffsets': [[
                            121546,
                            28992
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3301',
                'properties': {
                    'name': 'æ­å·žå¸‚',
                    'cp': [
                        119.5313,
                        29.8773
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@X@lÂ„Â°KXXlWÂ„b@Â²Â„`ÂšÂšÂšbÂ‚IÂ„ÂšX`l@Â„Â@bWl@n@VnLUV@VÂ„@Â°Â¦@Âšl@XVlU@Âš@xVbUb@Vkb@Â‚@XVJVzÂ™J@LÃžÂš@VmLUxUJ@LUÂ„VxÂ‚bÂ„xXUl@VaÃˆwÂ„bÂ‚aÃža@Vl@XUVx@V@VÂ„LlbnVÂ„al@lbÂ„VnnÂ‚LnKnL@VlbVJXalIÂšb@KUU@mVInJÂ˜Â„UÂ„Vl@xUÂšVLnUÂš@UÂÃžaV@lkV@UanKÂ„L@UlKVUnbÃ†mn@@nUlVnVJl@@UXUÂ„L@WVIVJVxVLXV@IÃœKnbn@VÂ¥V@@I@ÂƒÂƒÂÂ„yÂ°b@UUwnkÂ°Ã†Æ¨VlUÂšÃ§XmÂ›Â£ÂaÂƒÃ‡Â™IkVÂƒ@WVÂ@@aWIUWUIkb@WW@UnÂƒK@UU@kaWVkÂƒVIVVnU@ÂUWVUV@VmVÂkKkÂWIkVWaULU`UImJUImmÂ—U@ÂƒÂƒwmwUVÂ™IUWVkUamaU@mVÂ—kÂƒb@KVU@aVU@anKULVJÂ‚U@kÃ›UÂ™JUVÂ›kkÂƒVakU@ÂÂƒaVwkW@UWkXmWaULUaUK@XÂƒJUUmÂƒVU@UÂVÂƒUkJ@ImwmKU@kÂ„@lUÂ„W@@akKmÂ„kamIkWl_UwVm@UkaVUUaÂƒ@UamakbWlkL@aUalU@mkL@U@UÂ™lmK@XkKm@Ãakb@xÂƒnXbÂƒ`ÂƒnUUU@Â›Â™U@Â™wU@@ÂƒmKkkÂƒVÂ¯U@lULUbVbUb@VÂ‚a@LÂ™ÂºÃb@bÂLmKÂ™x@VUL@bk@mxULWl'],
                    'encodeOffsets': [[
                            121185,
                            30184
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3303',
                'properties': {
                    'name': 'æ¸©å·žå¸‚',
                    'cp': [
                        120.498,
                        27.8119
                    ],
                    'childNum': 9
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ll@xnXV`VXÂ„WVL@lXnlV@UV@@b@Â¤VzUlnVÂ„U@nWxÂšW@b@LnalK@bÂšXVKUÂƒÃˆ@VVÂ„I@b@JÂš@WbXLÃ†aUUÂ„mÂšI@xlKnnÂ„@VWlbkXVÂ‚@nÂ„VWnÂœÂ‚WbUbÂ„L@`VbUnVlVXkV@lUzÂ±Â‚VnUbU@@VUlVL@lÂ„_@V@l@LVbV@XLV`VÃˆlxn@lU@aÂœaVVÂ‚kÂ„@XJ@nl@@LU`Â°LVbÂ„LÂ°a@aÂ„UVy@anI@aÂ„aÂ‚nV@Â²wÃœJX@VÂšVVÂ°kÂ„Âna@WVkÂ„aWwÂU@m@Â™ÂƒkÂƒaUÄ•Â™ÃÂšÃÅ¤nÃˆaÂ„aÃ³IÂ›Â»@Â±XÂ™WkUÄ·@kVÂ±kwÂ™ÂƒUkWwÂ„Â™UÂƒÃÂ»Ã›kÉ³lÂImaUaWÃ³XÃ¿Ç¬kÂ‚UnWVÂmmÂkÂ™KÅ£nÅÃžÄŸlÂ™Â„UlUx@XWbÂ„V@JkXÂƒÂ°mb@VULVxUVk@@LWWk@WIkÂšÂƒUkJmUkVmI@yÂƒ@UaÂ™ÂkLmÂ‚U@mUUUkaVkÂ™@mK@UÂlUU@UmKmbUUUJ@n@KVLUL@VkJWXX`mnULWlkL@JVLVb@Â°kxkU@LVÂŽÂ™V@Â„VLV`UL@VUX'],
                    'encodeOffsets': [[
                            122502,
                            28334
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3302',
                'properties': {
                    'name': 'å®æ³¢å¸‚',
                    'cp': [
                        121.5967,
                        29.6466
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@ÄŠÂ¦Ä¸Ä€Â°Â‚nXÃžVÂšKÂškÆ¨Æ‘ÅºÃ¿Â°Â»nÂÂ„Â@wÃ´Â¥ÃœbÂœUÂ°ÂÃ†XÃžWÃ³Ã§Ä‰ÃÂ±IUÂƒÃˆÂ¥@UÂ°wÃ†Â»Â²mm_@aXÂƒVKÃžVlk@akkÂ›Ì…@Â£XÂ»VwÃ†ÂXÂWaÂ¯aÈ—bÂ™KÆ½Å°ÂƒÄŠÂ™xÂƒLÃ³ÂŽk@ÂƒÂƒÂƒ@Â¯nÂƒKUL@xkLÂ›Ã‘kWULUUmJUXVÂŽU@mÂŽUXÂ¯@V`mbXbV@@nnÂ¤WXÂšx@ÂškJ@nVVUVlÂ²UbÃVUVk@Wx@V@Â„ÂƒVXzmlÂaÂƒL@VlLU`Â„XUVVVUnl@VbnJlnUVVnÂƒlUKkbmnnÂ„VxlJnxmbU@UL@KUVÂ™X@xmb@lk@mnVVUÂšÂ™Ã¨'],
                    'encodeOffsets': [[
                            123784,
                            30977
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3309',
                'properties': {
                    'name': 'èˆŸå±±å¸‚',
                    'cp': [
                        122.2559,
                        30.2234
                    ],
                    'childNum': 3
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lÎ¢Æ’ÂÊ Ã¾Ã†VÄ¢LÄŠÂƒÇ¬XÄŠÃœÂ„XÃ´VÂ„Ã‘Ã†wÂ„ÂƒlÂÂšÆÃˆÃ³VÄ­VÇ“@ÂƒÄ‰wÉ›kmK@Ä‰XÄ«WaÄ‰UÄµÃmÂƒÂ¯Ä‰ÂƒwÄ‰Â±Â±nÃ…Â¼Â¯x@VÃ‡Â¦VÂ„Â²JÄŠÃžÃ´Ã¨ÃXÃ…WÂ¯ÂÂ›VÃ›aÃ³Â¦@xÂƒÂŽmÂŽÂ¯Â¼Å¹Ä€'],
                    'encodeOffsets': [[
                            124437,
                            30983
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3310',
                'properties': {
                    'name': 'å°å·žå¸‚',
                    'cp': [
                        121.1353,
                        28.6688
                    ],
                    'childNum': 7
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@lVÂ„IVWVz@bXJl@Xal@Â°Â„nLll@nVxnVÂ„K@ÂUJVbÂƒÂ¦Â°Â„k`UIWJXnÃ†Âš@bUJÂ„Xl@lbÂ„Wn@UzVV@bVVÂšmVnnJVXnaÂ‚bÂšKUKnUVVUnVLlKVLXaÂ„JmÂ£@mU@WanaU_Â°@VWnÂV@UÂVWnIVVVKlXÂœÃ’lK@wVKÂ„LÂ°mÂ„@Â„Â„l@Ã´ÂÂ„KÂšwÂ„Ä‰Æ¾Å¯UÂƒlÂ£@Â»UÂÂƒÂVkÂ„m@Æ…UÂƒÂƒaÃ›IÅmUk@mÂ„w@aÂ™Â£ÂƒWk@Å£ÂšÂƒImÂ±@ankÃ´UlaUÂ™UwÂ¯ÂƒÅaÂƒbÃ‡bÅ£mÂ™ÃžÂšÃžVÄ–Â„bÂ„l@Âš@nÂ‚VXxÂƒbUl@XmbÂƒÂŽÂ¯lUUUÂ™W@Ã›IÂ±xU@ÂmÂƒb@bmJ@bUzÂƒV@bÂ¯bÂƒKUaÂ¯KV_@Kk@@mWIÂƒ@ÂlUUÂ›b@bkVm@kwUÃ‡U_WKU@UxÂ™@ÂƒVUnllX@VnÂ‚J@UXV@bWL@lUbÂbVLUJ@zÂ‚V@lnbWbnnnJVÂŽ@L'],
                    'encodeOffsets': [[
                            123312,
                            29526
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3307',
                'properties': {
                    'name': 'é‡‘åŽå¸‚',
                    'cp': [
                        120.0037,
                        29.1028
                    ],
                    'childNum': 8
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@nbVbÂ„@VbUVlb@VUnVxk`lXnJlbnÂƒlL@bX@VÂƒ@klÂƒV@nLnx@JlIÂ„VÂ‚U@VUVnÂ„VVÂ„I@WVLVbVKXbWnXl@VlXUxÂ„b@ÂŽlVUblÂ„ÂœlVUÂšIÃœVnalKX@@bV@@aUUlUÂƒwUwÂ„@naWWÂ„UVaUUÂšaVbÂ„LlxXJVkÂ°ÂƒUÂƒlkUÂ¥@kÂ„a@LVlXLVlÂšVWznVn@lxÂšJl_@WX_@mVaÂ„a@alU@kVVnaÂ„KVLlKÂ„b@UUaVaÂšbnUWmXU@k@yVI@aÃ…Â™WmXIVJl_Â¯ÂƒÂ„Â¥UaVI@ÂÂƒLmUUw@mkkmKÂ¯Âƒk@Wbk@WI@aUyUXÂƒJkU@bU@WLUyÂƒXUbkbW`UÂVVkKmbUaVÂUÂƒUKÂ™Â£@KVUUUm@UWkXWaUKÂƒV@bÂ¯ÂƒÂ¯ÂmUÂ™V@UkÂƒmW@kkKÂƒwUÂƒmkkVUI@WlkUamL@Wk_WÂƒÂ@UVm@UaÂ¯KWXk@Uxm@UK@xVÂ„mV@Xk@UVVÂ¼@Â‚VLUbÂ™UÂƒÂ„U@ÂƒyULUbVlU@@XlVUVVbÂƒU@lXXVW@XUVl@@VUVÂƒÃˆn@VVUÂ„@lVa@Â„UÂ„mL@`ÂX@`WL@VUX@lUL@xlx'],
                    'encodeOffsets': [[
                            122119,
                            29948
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3308',
                'properties': {
                    'name': 'è¡¢å·žå¸‚',
                    'cp': [
                        118.6853,
                        28.8666
                    ],
                    'childNum': 5
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@XkVKnwl@@aVK@UÂšwnLÂ‚K@aÃžaÂšÂ¹@KÂb@UVaUaVaVK@kÂ°VÂ„UllnL@Â„V@ÂšxV@ÂœÂšV@VVÂ„mÂ„_WaÂ„m@wlaÃžbn@lL@WnLÂšk@V@VlK@nkVVb@blKXklakw@wVK@kVW@UXK@_Â‚W@_nKVÂƒ@ÂƒUb@kVÂƒUUm@Â„Ã‡VU@Uk@VU@WUXWW@kÂ„VUaVUkU@WWXUKk@UkmmÂ¯LmmÂƒUÂJUIWJkImmÂƒ_Â—Â±WLkKmÂ£@aVUÂÂmKUnÂƒLÂmWUkVmw@Â¥UÂÂ„LVWmÂ@WUkÂa@UmÂmLÂmm@@bUXÂ™@@WUIm@UVUK@UVUUUÂ™VVJmb@bÂ„XnÂ‚mVÂƒÂ¼nnnÂ¦mJUVÂƒLÂ„V@VW@UzUlVnUbl`UnVl@XU@kl@bmÃˆUxÂ™Vk@@J@Â„ÂƒÂ¼W@Ã…aVVnzmVÂƒÂ„Â@WJk@kÂWJ@ÂÂƒlXbWbXxmVnÂšlLXb@Â°lKVXnWÂšbWVÂ„Â„XÂ„mbV@XlÂ‚bÂšI@Kn@@x@ÂšVLlm'],
                    'encodeOffsets': [[
                            121185,
                            30184
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3306',
                'properties': {
                    'name': 'ç»å…´å¸‚',
                    'cp': [
                        120.564,
                        29.7565
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@Â„x@Â„Â˜VnnVJnIVJV_VKXblUXJlÂŽlLUÂŽUnU@UVVX@ÂŽmVUUUJlÂ„XUlbV@@VÂ„LVmX@@XlaVJVXXJ@bÂ‚@XUÂ„@lUÂšJÂ„ÃˆÂ‚bÂœÂ¤ÅŒÂÂ„JÂšÃ§VÂ™UUnml@@kna@wÂšWVU@LVKV@namwkIUwmÂƒnmlaVLÂ„kUmVUkmmIUak@VmUUVUÂƒWV_kK@UÂ„KÂ‚bnkWyÂ„U@Âƒ@UXwl@VUÃžUVakÂ±VUUU@mlI@Â™Â™wXWÂƒIWbUKkLUKVmUUmVVLÂ™LÂambUWmIUmÂ™nUU@aUUVym@ÂƒXkak@ÂƒW@z@lWVXnmVÂ™aUbVb@VÂƒakLUKÂƒLmbUU@lkV@bÂƒbUb@nW`@Xk`Â™Ikwm@mUXyÂ™UUkWKUk@KÂƒb@lVÂ¦klVÂ„Â¯Â„UlWIkwÂƒKUaÂ™bVVUbÂƒVXXmbÂƒ@VxÂ„xkVVV@bU@@aW@kLmb@lÂVUIVKmL@bUV@bUV@LÂ„aÂ˜lnUV@nbVbUlVXÂšJVUnx'],
                    'encodeOffsets': [[
                            122997,
                            30561
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3304',
                'properties': {
                    'name': 'å˜‰å…´å¸‚',
                    'cp': [
                        120.9155,
                        30.6354
                    ],
                    'childNum': 6
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@@blIX@@VÃœVUnn@lÂ‚kÂ„lKnIÂ°Ãžl`Â²LVKVbnbVaVLUVn@WÂ¦@VkVVbÂ„@VIÂ„`@blLnLÂ‚aX@Â„VVb@UÂ‚@XlVaÂ„@@kVaUKVÂ»U_lWXUÂƒÂƒ@albÂ„k@VllnLVKn@@UVIUw@yÂ°IVVXU@VV@lwÂ„m@wVkÆ¾aÂœJÂ‚LkÎ¡Æ§Æ’Â™lÂ™LÃUmWÂ¯ÂÄ·Ã¿Ä‰Â¥ÂƒIÅ‹ÂŽWnÂ™Ã¨kVÆ§UÂ¯Ã…mlVx@VÂ¯aÂƒzÂ„ÂŽ@Â„@JU@UÂ¦m@@ÂšnVmn@VÂ„LVÂ‚'],
                    'encodeOffsets': [[
                            123233,
                            31382
                        ]]
                }
            },
            {
                'type': 'Feature',
                'id': '3305',
                'properties': {
                    'name': 'æ¹–å·žå¸‚',
                    'cp': [
                        119.8608,
                        30.7782
                    ],
                    'childNum': 4
                },
                'geometry': {
                    'type': 'Polygon',
                    'coordinates': ['@@kLlÂƒkÂm@VmÃ›U@UW@kJ@aUÂÂƒK@UnmmU@Â™maÃ›L@JWUUKUwUIUJ@XÂƒKWV@Vk@UIUmVk@mm@Ã…nmaUVkL@VÂƒKmLVbU@klU@ÃbVÂÂ™@mVUKVÂ™@wUkVÂƒÂ—ÂƒmIUJ@nVV@LÂ™akJWbUIka@UmKmLÂKmmÂƒUUVk@@nmLX`WXUV@ÂŽ@nUlÂ™kmlU@UbÂ„Â„ÂƒxVVÂšIlVÂ„ÂŽÂšnnÂÂ„@@nÂ˜Â„UÃ’Âš@Â„Â°n@@xmb@Â„VbnV@ÂšÂšÂ„@b@`@L@L@x@blVklVbnnV@Â‚aXbÂ°VlU@WÂ„bÂ°UÂ„LXWVUVÂ™Â„Â™VwÃˆwÃœÂ»Ä¸aÄ nUÂVwÂ²X@V@lVU@wlaUUVm@knUVÂ›'],
                    'encodeOffsets': [[
                            123379,
                            31500
                        ]]
                }
            }
        ],
        'UTF8Encoding': true
    };
});define('echarts/chart/gauge', [
    'require',
    './base',
    '../util/shape/GaugePointer',
    'zrender/shape/Text',
    'zrender/shape/Line',
    'zrender/shape/Rectangle',
    'zrender/shape/Circle',
    'zrender/shape/Sector',
    '../config',
    '../util/ecData',
    '../util/accMath',
    'zrender/tool/util',
    '../chart'
], function (require) {
    var ChartBase = require('./base');
    var GaugePointerShape = require('../util/shape/GaugePointer');
    var TextShape = require('zrender/shape/Text');
    var LineShape = require('zrender/shape/Line');
    var RectangleShape = require('zrender/shape/Rectangle');
    var CircleShape = require('zrender/shape/Circle');
    var SectorShape = require('zrender/shape/Sector');
    var ecConfig = require('../config');
    ecConfig.gauge = {
        zlevel: 0,
        z: 2,
        center: [
            '50%',
            '50%'
        ],
        clickable: true,
        legendHoverLink: true,
        radius: '75%',
        startAngle: 225,
        endAngle: -45,
        min: 0,
        max: 100,
        splitNumber: 10,
        axisLine: {
            show: true,
            lineStyle: {
                color: [
                    [
                        0.2,
                        '#228b22'
                    ],
                    [
                        0.8,
                        '#48b'
                    ],
                    [
                        1,
                        '#ff4500'
                    ]
                ],
                width: 30
            }
        },
        axisTick: {
            show: true,
            splitNumber: 5,
            length: 8,
            lineStyle: {
                color: '#eee',
                width: 1,
                type: 'solid'
            }
        },
        axisLabel: {
            show: true,
            textStyle: { color: 'auto' }
        },
        splitLine: {
            show: true,
            length: 30,
            lineStyle: {
                color: '#eee',
                width: 2,
                type: 'solid'
            }
        },
        pointer: {
            show: true,
            length: '80%',
            width: 8,
            color: 'auto'
        },
        title: {
            show: true,
            offsetCenter: [
                0,
                '-40%'
            ],
            textStyle: {
                color: '#333',
                fontSize: 15
            }
        },
        detail: {
            show: true,
            backgroundColor: 'rgba(0,0,0,0)',
            borderWidth: 0,
            borderColor: '#ccc',
            width: 100,
            height: 40,
            offsetCenter: [
                0,
                '40%'
            ],
            textStyle: {
                color: 'auto',
                fontSize: 30
            }
        }
    };
    var ecData = require('../util/ecData');
    var accMath = require('../util/accMath');
    var zrUtil = require('zrender/tool/util');
    function Gauge(ecTheme, messageCenter, zr, option, myChart) {
        ChartBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.refresh(option);
    }
    Gauge.prototype = {
        type: ecConfig.CHART_TYPE_GAUGE,
        _buildShape: function () {
            var series = this.series;
            this._paramsMap = {};
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].type === ecConfig.CHART_TYPE_GAUGE) {
                    series[i] = this.reformOption(series[i]);
                    this.legendHoverLink = series[i].legendHoverLink || this.legendHoverLink;
                    this._buildSingleGauge(i);
                    this.buildMark(i);
                }
            }
            this.addShapeList();
        },
        _buildSingleGauge: function (seriesIndex) {
            var serie = this.series[seriesIndex];
            this._paramsMap[seriesIndex] = {
                center: this.parseCenter(this.zr, serie.center),
                radius: this.parseRadius(this.zr, serie.radius),
                startAngle: serie.startAngle.toFixed(2) - 0,
                endAngle: serie.endAngle.toFixed(2) - 0
            };
            this._paramsMap[seriesIndex].totalAngle = this._paramsMap[seriesIndex].startAngle - this._paramsMap[seriesIndex].endAngle;
            this._colorMap(seriesIndex);
            this._buildAxisLine(seriesIndex);
            this._buildSplitLine(seriesIndex);
            this._buildAxisTick(seriesIndex);
            this._buildAxisLabel(seriesIndex);
            this._buildPointer(seriesIndex);
            this._buildTitle(seriesIndex);
            this._buildDetail(seriesIndex);
        },
        _buildAxisLine: function (seriesIndex) {
            var serie = this.series[seriesIndex];
            if (!serie.axisLine.show) {
                return;
            }
            var min = serie.min;
            var total = serie.max - min;
            var params = this._paramsMap[seriesIndex];
            var center = params.center;
            var startAngle = params.startAngle;
            var totalAngle = params.totalAngle;
            var colorArray = params.colorArray;
            var lineStyle = serie.axisLine.lineStyle;
            var lineWidth = this.parsePercent(lineStyle.width, params.radius[1]);
            var r = params.radius[1];
            var r0 = r - lineWidth;
            var sectorShape;
            var lastAngle = startAngle;
            var newAngle;
            for (var i = 0, l = colorArray.length; i < l; i++) {
                newAngle = startAngle - totalAngle * (colorArray[i][0] - min) / total;
                sectorShape = this._getSector(center, r0, r, newAngle, lastAngle, colorArray[i][1], lineStyle);
                lastAngle = newAngle;
                sectorShape._animationAdd = 'r';
                ecData.set(sectorShape, 'seriesIndex', seriesIndex);
                ecData.set(sectorShape, 'dataIndex', i);
                this.shapeList.push(sectorShape);
            }
        },
        _buildSplitLine: function (seriesIndex) {
            var serie = this.series[seriesIndex];
            if (!serie.splitLine.show) {
                return;
            }
            var params = this._paramsMap[seriesIndex];
            var splitNumber = serie.splitNumber;
            var min = serie.min;
            var total = serie.max - min;
            var splitLine = serie.splitLine;
            var length = this.parsePercent(splitLine.length, params.radius[1]);
            var lineStyle = splitLine.lineStyle;
            var color = lineStyle.color;
            var center = params.center;
            var startAngle = params.startAngle * Math.PI / 180;
            var totalAngle = params.totalAngle * Math.PI / 180;
            var r = params.radius[1];
            var r0 = r - length;
            var angle;
            var sinAngle;
            var cosAngle;
            for (var i = 0; i <= splitNumber; i++) {
                angle = startAngle - totalAngle / splitNumber * i;
                sinAngle = Math.sin(angle);
                cosAngle = Math.cos(angle);
                this.shapeList.push(new LineShape({
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase() + 1,
                    hoverable: false,
                    style: {
                        xStart: center[0] + cosAngle * r,
                        yStart: center[1] - sinAngle * r,
                        xEnd: center[0] + cosAngle * r0,
                        yEnd: center[1] - sinAngle * r0,
                        strokeColor: color === 'auto' ? this._getColor(seriesIndex, min + total / splitNumber * i) : color,
                        lineType: lineStyle.type,
                        lineWidth: lineStyle.width,
                        shadowColor: lineStyle.shadowColor,
                        shadowBlur: lineStyle.shadowBlur,
                        shadowOffsetX: lineStyle.shadowOffsetX,
                        shadowOffsetY: lineStyle.shadowOffsetY
                    }
                }));
            }
        },
        _buildAxisTick: function (seriesIndex) {
            var serie = this.series[seriesIndex];
            if (!serie.axisTick.show) {
                return;
            }
            var params = this._paramsMap[seriesIndex];
            var splitNumber = serie.splitNumber;
            var min = serie.min;
            var total = serie.max - min;
            var axisTick = serie.axisTick;
            var tickSplit = axisTick.splitNumber;
            var length = this.parsePercent(axisTick.length, params.radius[1]);
            var lineStyle = axisTick.lineStyle;
            var color = lineStyle.color;
            var center = params.center;
            var startAngle = params.startAngle * Math.PI / 180;
            var totalAngle = params.totalAngle * Math.PI / 180;
            var r = params.radius[1];
            var r0 = r - length;
            var angle;
            var sinAngle;
            var cosAngle;
            for (var i = 0, l = splitNumber * tickSplit; i <= l; i++) {
                if (i % tickSplit === 0) {
                    continue;
                }
                angle = startAngle - totalAngle / l * i;
                sinAngle = Math.sin(angle);
                cosAngle = Math.cos(angle);
                this.shapeList.push(new LineShape({
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase() + 1,
                    hoverable: false,
                    style: {
                        xStart: center[0] + cosAngle * r,
                        yStart: center[1] - sinAngle * r,
                        xEnd: center[0] + cosAngle * r0,
                        yEnd: center[1] - sinAngle * r0,
                        strokeColor: color === 'auto' ? this._getColor(seriesIndex, min + total / l * i) : color,
                        lineType: lineStyle.type,
                        lineWidth: lineStyle.width,
                        shadowColor: lineStyle.shadowColor,
                        shadowBlur: lineStyle.shadowBlur,
                        shadowOffsetX: lineStyle.shadowOffsetX,
                        shadowOffsetY: lineStyle.shadowOffsetY
                    }
                }));
            }
        },
        _buildAxisLabel: function (seriesIndex) {
            var serie = this.series[seriesIndex];
            if (!serie.axisLabel.show) {
                return;
            }
            var splitNumber = serie.splitNumber;
            var min = serie.min;
            var total = serie.max - min;
            var textStyle = serie.axisLabel.textStyle;
            var textFont = this.getFont(textStyle);
            var color = textStyle.color;
            var params = this._paramsMap[seriesIndex];
            var center = params.center;
            var startAngle = params.startAngle;
            var totalAngle = params.totalAngle;
            var r0 = params.radius[1] - this.parsePercent(serie.splitLine.length, params.radius[1]) - 5;
            var angle;
            var sinAngle;
            var cosAngle;
            var value;
            for (var i = 0; i <= splitNumber; i++) {
                value = accMath.accAdd(min, accMath.accMul(accMath.accDiv(total, splitNumber), i));
                angle = startAngle - totalAngle / splitNumber * i;
                sinAngle = Math.sin(angle * Math.PI / 180);
                cosAngle = Math.cos(angle * Math.PI / 180);
                angle = (angle + 360) % 360;
                this.shapeList.push(new TextShape({
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase() + 1,
                    hoverable: false,
                    style: {
                        x: center[0] + cosAngle * r0,
                        y: center[1] - sinAngle * r0,
                        color: color === 'auto' ? this._getColor(seriesIndex, value) : color,
                        text: this._getLabelText(serie.axisLabel.formatter, value),
                        textAlign: angle >= 110 && angle <= 250 ? 'left' : angle <= 70 || angle >= 290 ? 'right' : 'center',
                        textBaseline: angle >= 10 && angle <= 170 ? 'top' : angle >= 190 && angle <= 350 ? 'bottom' : 'middle',
                        textFont: textFont,
                        shadowColor: textStyle.shadowColor,
                        shadowBlur: textStyle.shadowBlur,
                        shadowOffsetX: textStyle.shadowOffsetX,
                        shadowOffsetY: textStyle.shadowOffsetY
                    }
                }));
            }
        },
        _buildPointer: function (seriesIndex) {
            var serie = this.series[seriesIndex];
            if (!serie.pointer.show) {
                return;
            }
            var total = serie.max - serie.min;
            var pointer = serie.pointer;
            var params = this._paramsMap[seriesIndex];
            var length = this.parsePercent(pointer.length, params.radius[1]);
            var width = this.parsePercent(pointer.width, params.radius[1]);
            var center = params.center;
            var value = this._getValue(seriesIndex);
            value = value < serie.max ? value : serie.max;
            var angle = (params.startAngle - params.totalAngle / total * (value - serie.min)) * Math.PI / 180;
            var color = pointer.color === 'auto' ? this._getColor(seriesIndex, value) : pointer.color;
            var pointShape = new GaugePointerShape({
                zlevel: this.getZlevelBase(),
                z: this.getZBase() + 1,
                clickable: this.query(serie, 'clickable'),
                style: {
                    x: center[0],
                    y: center[1],
                    r: length,
                    startAngle: params.startAngle * Math.PI / 180,
                    angle: angle,
                    color: color,
                    width: width,
                    shadowColor: pointer.shadowColor,
                    shadowBlur: pointer.shadowBlur,
                    shadowOffsetX: pointer.shadowOffsetX,
                    shadowOffsetY: pointer.shadowOffsetY
                },
                highlightStyle: {
                    brushType: 'fill',
                    width: width > 2 ? 2 : width / 2,
                    color: '#fff'
                }
            });
            ecData.pack(pointShape, this.series[seriesIndex], seriesIndex, this.series[seriesIndex].data[0], 0, this.series[seriesIndex].data[0].name, value);
            this.shapeList.push(pointShape);
            this.shapeList.push(new CircleShape({
                zlevel: this.getZlevelBase(),
                z: this.getZBase() + 2,
                hoverable: false,
                style: {
                    x: center[0],
                    y: center[1],
                    r: pointer.width / 2.5,
                    color: '#fff'
                }
            }));
        },
        _buildTitle: function (seriesIndex) {
            var serie = this.series[seriesIndex];
            if (!serie.title.show) {
                return;
            }
            var data = serie.data[0];
            var name = data.name != null ? data.name : '';
            if (name !== '') {
                var title = serie.title;
                var offsetCenter = title.offsetCenter;
                var textStyle = title.textStyle;
                var textColor = textStyle.color;
                var params = this._paramsMap[seriesIndex];
                var x = params.center[0] + this.parsePercent(offsetCenter[0], params.radius[1]);
                var y = params.center[1] + this.parsePercent(offsetCenter[1], params.radius[1]);
                this.shapeList.push(new TextShape({
                    zlevel: this.getZlevelBase(),
                    z: this.getZBase() + (Math.abs(x - params.center[0]) + Math.abs(y - params.center[1]) < textStyle.fontSize * 2 ? 2 : 1),
                    hoverable: false,
                    style: {
                        x: x,
                        y: y,
                        color: textColor === 'auto' ? this._getColor(seriesIndex) : textColor,
                        text: name,
                        textAlign: 'center',
                        textFont: this.getFont(textStyle),
                        shadowColor: textStyle.shadowColor,
                        shadowBlur: textStyle.shadowBlur,
                        shadowOffsetX: textStyle.shadowOffsetX,
                        shadowOffsetY: textStyle.shadowOffsetY
                    }
                }));
            }
        },
        _buildDetail: function (seriesIndex) {
            var serie = this.series[seriesIndex];
            if (!serie.detail.show) {
                return;
            }
            var detail = serie.detail;
            var offsetCenter = detail.offsetCenter;
            var color = detail.backgroundColor;
            var textStyle = detail.textStyle;
            var textColor = textStyle.color;
            var params = this._paramsMap[seriesIndex];
            var value = this._getValue(seriesIndex);
            var x = params.center[0] - detail.width / 2 + this.parsePercent(offsetCenter[0], params.radius[1]);
            var y = params.center[1] + this.parsePercent(offsetCenter[1], params.radius[1]);
            this.shapeList.push(new RectangleShape({
                zlevel: this.getZlevelBase(),
                z: this.getZBase() + (Math.abs(x + detail.width / 2 - params.center[0]) + Math.abs(y + detail.height / 2 - params.center[1]) < textStyle.fontSize ? 2 : 1),
                hoverable: false,
                style: {
                    x: x,
                    y: y,
                    width: detail.width,
                    height: detail.height,
                    brushType: 'both',
                    color: color === 'auto' ? this._getColor(seriesIndex, value) : color,
                    lineWidth: detail.borderWidth,
                    strokeColor: detail.borderColor,
                    shadowColor: detail.shadowColor,
                    shadowBlur: detail.shadowBlur,
                    shadowOffsetX: detail.shadowOffsetX,
                    shadowOffsetY: detail.shadowOffsetY,
                    text: this._getLabelText(detail.formatter, value),
                    textFont: this.getFont(textStyle),
                    textPosition: 'inside',
                    textColor: textColor === 'auto' ? this._getColor(seriesIndex, value) : textColor
                }
            }));
        },
        _getValue: function (seriesIndex) {
            return this.getDataFromOption(this.series[seriesIndex].data[0]);
        },
        _colorMap: function (seriesIndex) {
            var serie = this.series[seriesIndex];
            var min = serie.min;
            var total = serie.max - min;
            var color = serie.axisLine.lineStyle.color;
            if (!(color instanceof Array)) {
                color = [[
                        1,
                        color
                    ]];
            }
            var colorArray = [];
            for (var i = 0, l = color.length; i < l; i++) {
                colorArray.push([
                    color[i][0] * total + min,
                    color[i][1]
                ]);
            }
            this._paramsMap[seriesIndex].colorArray = colorArray;
        },
        _getColor: function (seriesIndex, value) {
            if (value == null) {
                value = this._getValue(seriesIndex);
            }
            var colorArray = this._paramsMap[seriesIndex].colorArray;
            for (var i = 0, l = colorArray.length; i < l; i++) {
                if (colorArray[i][0] >= value) {
                    return colorArray[i][1];
                }
            }
            return colorArray[colorArray.length - 1][1];
        },
        _getSector: function (center, r0, r, startAngle, endAngle, color, lineStyle) {
            return new SectorShape({
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                hoverable: false,
                style: {
                    x: center[0],
                    y: center[1],
                    r0: r0,
                    r: r,
                    startAngle: startAngle,
                    endAngle: endAngle,
                    brushType: 'fill',
                    color: color,
                    shadowColor: lineStyle.shadowColor,
                    shadowBlur: lineStyle.shadowBlur,
                    shadowOffsetX: lineStyle.shadowOffsetX,
                    shadowOffsetY: lineStyle.shadowOffsetY
                }
            });
        },
        _getLabelText: function (formatter, value) {
            if (formatter) {
                if (typeof formatter === 'function') {
                    return formatter.call(this.myChart, value);
                } else if (typeof formatter === 'string') {
                    return formatter.replace('{value}', value);
                }
            }
            return value;
        },
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.series = newOption.series;
            }
            this.backupShapeList();
            this._buildShape();
        }
    };
    zrUtil.inherits(Gauge, ChartBase);
    require('../chart').define('gauge', Gauge);
    return Gauge;
});define('echarts/util/shape/GaugePointer', [
    'require',
    'zrender/shape/Base',
    'zrender/tool/util',
    './normalIsCover'
], function (require) {
    var Base = require('zrender/shape/Base');
    var zrUtil = require('zrender/tool/util');
    function GaugePointer(options) {
        Base.call(this, options);
    }
    GaugePointer.prototype = {
        type: 'gauge-pointer',
        buildPath: function (ctx, style) {
            var r = style.r;
            var width = style.width;
            var angle = style.angle;
            var x = style.x - Math.cos(angle) * width * (width >= r / 3 ? 1 : 2);
            var y = style.y + Math.sin(angle) * width * (width >= r / 3 ? 1 : 2);
            angle = style.angle - Math.PI / 2;
            ctx.moveTo(x, y);
            ctx.lineTo(style.x + Math.cos(angle) * width, style.y - Math.sin(angle) * width);
            ctx.lineTo(style.x + Math.cos(style.angle) * r, style.y - Math.sin(style.angle) * r);
            ctx.lineTo(style.x - Math.cos(angle) * width, style.y + Math.sin(angle) * width);
            ctx.lineTo(x, y);
            return;
        },
        getRect: function (style) {
            if (style.__rect) {
                return style.__rect;
            }
            var width = style.width * 2;
            var xStart = style.x;
            var yStart = style.y;
            var xEnd = xStart + Math.cos(style.angle) * style.r;
            var yEnd = yStart - Math.sin(style.angle) * style.r;
            style.__rect = {
                x: Math.min(xStart, xEnd) - width,
                y: Math.min(yStart, yEnd) - width,
                width: Math.abs(xStart - xEnd) + width,
                height: Math.abs(yStart - yEnd) + width
            };
            return style.__rect;
        },
        isCover: require('./normalIsCover')
    };
    zrUtil.inherits(GaugePointer, Base);
    return GaugePointer;
});define('echarts/chart/funnel', [
    'require',
    './base',
    'zrender/shape/Text',
    'zrender/shape/Line',
    'zrender/shape/Polygon',
    '../config',
    '../util/ecData',
    '../util/number',
    'zrender/tool/util',
    'zrender/tool/color',
    'zrender/tool/area',
    '../chart'
], function (require) {
    var ChartBase = require('./base');
    var TextShape = require('zrender/shape/Text');
    var LineShape = require('zrender/shape/Line');
    var PolygonShape = require('zrender/shape/Polygon');
    var ecConfig = require('../config');
    ecConfig.funnel = {
        zlevel: 0,
        z: 2,
        clickable: true,
        legendHoverLink: true,
        x: 80,
        y: 60,
        x2: 80,
        y2: 60,
        min: 0,
        max: 100,
        minSize: '0%',
        maxSize: '100%',
        sort: 'descending',
        gap: 0,
        funnelAlign: 'center',
        itemStyle: {
            normal: {
                borderColor: '#fff',
                borderWidth: 1,
                label: {
                    show: true,
                    position: 'outer'
                },
                labelLine: {
                    show: true,
                    length: 10,
                    lineStyle: {
                        width: 1,
                        type: 'solid'
                    }
                }
            },
            emphasis: {
                borderColor: 'rgba(0,0,0,0)',
                borderWidth: 1,
                label: { show: true },
                labelLine: { show: true }
            }
        }
    };
    var ecData = require('../util/ecData');
    var number = require('../util/number');
    var zrUtil = require('zrender/tool/util');
    var zrColor = require('zrender/tool/color');
    var zrArea = require('zrender/tool/area');
    function Funnel(ecTheme, messageCenter, zr, option, myChart) {
        ChartBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        this.refresh(option);
    }
    Funnel.prototype = {
        type: ecConfig.CHART_TYPE_FUNNEL,
        _buildShape: function () {
            var series = this.series;
            var legend = this.component.legend;
            this._paramsMap = {};
            this._selected = {};
            this.selectedMap = {};
            var serieName;
            for (var i = 0, l = series.length; i < l; i++) {
                if (series[i].type === ecConfig.CHART_TYPE_FUNNEL) {
                    series[i] = this.reformOption(series[i]);
                    this.legendHoverLink = series[i].legendHoverLink || this.legendHoverLink;
                    serieName = series[i].name || '';
                    this.selectedMap[serieName] = legend ? legend.isSelected(serieName) : true;
                    if (!this.selectedMap[serieName]) {
                        continue;
                    }
                    this._buildSingleFunnel(i);
                    this.buildMark(i);
                }
            }
            this.addShapeList();
        },
        _buildSingleFunnel: function (seriesIndex) {
            var legend = this.component.legend;
            var serie = this.series[seriesIndex];
            var data = this._mapData(seriesIndex);
            var location = this._getLocation(seriesIndex);
            this._paramsMap[seriesIndex] = {
                location: location,
                data: data
            };
            var itemName;
            var total = 0;
            var selectedData = [];
            for (var i = 0, l = data.length; i < l; i++) {
                itemName = data[i].name;
                this.selectedMap[itemName] = legend ? legend.isSelected(itemName) : true;
                if (this.selectedMap[itemName] && !isNaN(data[i].value)) {
                    selectedData.push(data[i]);
                    total++;
                }
            }
            if (total === 0) {
                return;
            }
            var funnelCase = this._buildFunnelCase(seriesIndex);
            var align = serie.funnelAlign;
            var gap = serie.gap;
            var height = total > 1 ? (location.height - (total - 1) * gap) / total : location.height;
            var width;
            var lastY = location.y;
            var lastWidth = serie.sort === 'descending' ? this._getItemWidth(seriesIndex, selectedData[0].value) : number.parsePercent(serie.minSize, location.width);
            var next = serie.sort === 'descending' ? 1 : 0;
            var centerX = location.centerX;
            var pointList = [];
            var x;
            var polygon;
            var lastPolygon;
            for (var i = 0, l = selectedData.length; i < l; i++) {
                itemName = selectedData[i].name;
                if (this.selectedMap[itemName] && !isNaN(selectedData[i].value)) {
                    width = i <= l - 2 ? this._getItemWidth(seriesIndex, selectedData[i + next].value) : serie.sort === 'descending' ? number.parsePercent(serie.minSize, location.width) : number.parsePercent(serie.maxSize, location.width);
                    switch (align) {
                    case 'left':
                        x = location.x;
                        break;
                    case 'right':
                        x = location.x + location.width - lastWidth;
                        break;
                    default:
                        x = centerX - lastWidth / 2;
                    }
                    polygon = this._buildItem(seriesIndex, selectedData[i]._index, legend ? legend.getColor(itemName) : this.zr.getColor(selectedData[i]._index), x, lastY, lastWidth, width, height, align);
                    lastY += height + gap;
                    lastPolygon = polygon.style.pointList;
                    pointList.unshift([
                        lastPolygon[0][0] - 10,
                        lastPolygon[0][1]
                    ]);
                    pointList.push([
                        lastPolygon[1][0] + 10,
                        lastPolygon[1][1]
                    ]);
                    if (i === 0) {
                        if (lastWidth === 0) {
                            lastPolygon = pointList.pop();
                            align == 'center' && (pointList[0][0] += 10);
                            align == 'right' && (pointList[0][0] = lastPolygon[0]);
                            pointList[0][1] -= align == 'center' ? 10 : 15;
                            if (l == 1) {
                                lastPolygon = polygon.style.pointList;
                            }
                        } else {
                            pointList[pointList.length - 1][1] -= 5;
                            pointList[0][1] -= 5;
                        }
                    }
                    lastWidth = width;
                }
            }
            if (funnelCase) {
                pointList.unshift([
                    lastPolygon[3][0] - 10,
                    lastPolygon[3][1]
                ]);
                pointList.push([
                    lastPolygon[2][0] + 10,
                    lastPolygon[2][1]
                ]);
                if (lastWidth === 0) {
                    lastPolygon = pointList.pop();
                    align == 'center' && (pointList[0][0] += 10);
                    align == 'right' && (pointList[0][0] = lastPolygon[0]);
                    pointList[0][1] += align == 'center' ? 10 : 15;
                } else {
                    pointList[pointList.length - 1][1] += 5;
                    pointList[0][1] += 5;
                }
                funnelCase.style.pointList = pointList;
            }
        },
        _buildFunnelCase: function (seriesIndex) {
            var serie = this.series[seriesIndex];
            if (this.deepQuery([
                    serie,
                    this.option
                ], 'calculable')) {
                var location = this._paramsMap[seriesIndex].location;
                var gap = 10;
                var funnelCase = {
                    hoverable: false,
                    style: {
                        pointListd: [
                            [
                                location.x - gap,
                                location.y - gap
                            ],
                            [
                                location.x + location.width + gap,
                                location.y - gap
                            ],
                            [
                                location.x + location.width + gap,
                                location.y + location.height + gap
                            ],
                            [
                                location.x - gap,
                                location.y + location.height + gap
                            ]
                        ],
                        brushType: 'stroke',
                        lineWidth: 1,
                        strokeColor: serie.calculableHolderColor || this.ecTheme.calculableHolderColor || ecConfig.calculableHolderColor
                    }
                };
                ecData.pack(funnelCase, serie, seriesIndex, undefined, -1);
                this.setCalculable(funnelCase);
                funnelCase = new PolygonShape(funnelCase);
                this.shapeList.push(funnelCase);
                return funnelCase;
            }
        },
        _getLocation: function (seriesIndex) {
            var gridOption = this.series[seriesIndex];
            var zrWidth = this.zr.getWidth();
            var zrHeight = this.zr.getHeight();
            var x = this.parsePercent(gridOption.x, zrWidth);
            var y = this.parsePercent(gridOption.y, zrHeight);
            var width = gridOption.width == null ? zrWidth - x - this.parsePercent(gridOption.x2, zrWidth) : this.parsePercent(gridOption.width, zrWidth);
            return {
                x: x,
                y: y,
                width: width,
                height: gridOption.height == null ? zrHeight - y - this.parsePercent(gridOption.y2, zrHeight) : this.parsePercent(gridOption.height, zrHeight),
                centerX: x + width / 2
            };
        },
        _mapData: function (seriesIndex) {
            var serie = this.series[seriesIndex];
            var funnelData = zrUtil.clone(serie.data);
            for (var i = 0, l = funnelData.length; i < l; i++) {
                funnelData[i]._index = i;
            }
            function numDescending(a, b) {
                if (a.value === '-') {
                    return 1;
                } else if (b.value === '-') {
                    return -1;
                }
                return b.value - a.value;
            }
            function numAscending(a, b) {
                return -numDescending(a, b);
            }
            if (serie.sort != 'none') {
                funnelData.sort(serie.sort === 'descending' ? numDescending : numAscending);
            }
            return funnelData;
        },
        _buildItem: function (seriesIndex, dataIndex, defaultColor, x, y, topWidth, bottomWidth, height, align) {
            var series = this.series;
            var serie = series[seriesIndex];
            var data = serie.data[dataIndex];
            var polygon = this.getPolygon(seriesIndex, dataIndex, defaultColor, x, y, topWidth, bottomWidth, height, align);
            ecData.pack(polygon, series[seriesIndex], seriesIndex, series[seriesIndex].data[dataIndex], dataIndex, series[seriesIndex].data[dataIndex].name);
            this.shapeList.push(polygon);
            var label = this.getLabel(seriesIndex, dataIndex, defaultColor, x, y, topWidth, bottomWidth, height, align);
            ecData.pack(label, series[seriesIndex], seriesIndex, series[seriesIndex].data[dataIndex], dataIndex, series[seriesIndex].data[dataIndex].name);
            this.shapeList.push(label);
            if (!this._needLabel(serie, data, false)) {
                label.invisible = true;
            }
            var labelLine = this.getLabelLine(seriesIndex, dataIndex, defaultColor, x, y, topWidth, bottomWidth, height, align);
            this.shapeList.push(labelLine);
            if (!this._needLabelLine(serie, data, false)) {
                labelLine.invisible = true;
            }
            var polygonHoverConnect = [];
            var labelHoverConnect = [];
            if (this._needLabelLine(serie, data, true)) {
                polygonHoverConnect.push(labelLine.id);
                labelHoverConnect.push(labelLine.id);
            }
            if (this._needLabel(serie, data, true)) {
                polygonHoverConnect.push(label.id);
                labelHoverConnect.push(polygon.id);
            }
            polygon.hoverConnect = polygonHoverConnect;
            label.hoverConnect = labelHoverConnect;
            return polygon;
        },
        _getItemWidth: function (seriesIndex, value) {
            var serie = this.series[seriesIndex];
            var location = this._paramsMap[seriesIndex].location;
            var min = serie.min;
            var max = serie.max;
            var minSize = number.parsePercent(serie.minSize, location.width);
            var maxSize = number.parsePercent(serie.maxSize, location.width);
            return (value - min) * (maxSize - minSize) / (max - min) + minSize;
        },
        getPolygon: function (seriesIndex, dataIndex, defaultColor, xLT, y, topWidth, bottomWidth, height, align) {
            var serie = this.series[seriesIndex];
            var data = serie.data[dataIndex];
            var queryTarget = [
                data,
                serie
            ];
            var normal = this.deepMerge(queryTarget, 'itemStyle.normal') || {};
            var emphasis = this.deepMerge(queryTarget, 'itemStyle.emphasis') || {};
            var normalColor = this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data) || defaultColor;
            var emphasisColor = this.getItemStyleColor(emphasis.color, seriesIndex, dataIndex, data) || (typeof normalColor === 'string' ? zrColor.lift(normalColor, -0.2) : normalColor);
            var xLB;
            switch (align) {
            case 'left':
                xLB = xLT;
                break;
            case 'right':
                xLB = xLT + (topWidth - bottomWidth);
                break;
            default:
                xLB = xLT + (topWidth - bottomWidth) / 2;
                break;
            }
            var polygon = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                clickable: this.deepQuery(queryTarget, 'clickable'),
                style: {
                    pointList: [
                        [
                            xLT,
                            y
                        ],
                        [
                            xLT + topWidth,
                            y
                        ],
                        [
                            xLB + bottomWidth,
                            y + height
                        ],
                        [
                            xLB,
                            y + height
                        ]
                    ],
                    brushType: 'both',
                    color: normalColor,
                    lineWidth: normal.borderWidth,
                    strokeColor: normal.borderColor
                },
                highlightStyle: {
                    color: emphasisColor,
                    lineWidth: emphasis.borderWidth,
                    strokeColor: emphasis.borderColor
                }
            };
            if (this.deepQuery([
                    data,
                    serie,
                    this.option
                ], 'calculable')) {
                this.setCalculable(polygon);
                polygon.draggable = true;
            }
            return new PolygonShape(polygon);
        },
        getLabel: function (seriesIndex, dataIndex, defaultColor, x, y, topWidth, bottomWidth, height, align) {
            var serie = this.series[seriesIndex];
            var data = serie.data[dataIndex];
            var location = this._paramsMap[seriesIndex].location;
            var itemStyle = zrUtil.merge(zrUtil.clone(data.itemStyle) || {}, serie.itemStyle);
            var status = 'normal';
            var labelControl = itemStyle[status].label;
            var textStyle = labelControl.textStyle || {};
            var lineLength = itemStyle[status].labelLine.length;
            var text = this.getLabelText(seriesIndex, dataIndex, status);
            var textFont = this.getFont(textStyle);
            var textAlign;
            var textColor = defaultColor;
            labelControl.position = labelControl.position || itemStyle.normal.label.position;
            if (labelControl.position === 'inner' || labelControl.position === 'inside' || labelControl.position === 'center') {
                textAlign = align;
                textColor = Math.max(topWidth, bottomWidth) / 2 > zrArea.getTextWidth(text, textFont) ? '#fff' : zrColor.reverse(defaultColor);
            } else if (labelControl.position === 'left') {
                textAlign = 'right';
            } else {
                textAlign = 'left';
            }
            var textShape = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase() + 1,
                style: {
                    x: this._getLabelPoint(labelControl.position, x, location, topWidth, bottomWidth, lineLength, align),
                    y: y + height / 2,
                    color: textStyle.color || textColor,
                    text: text,
                    textAlign: textStyle.align || textAlign,
                    textBaseline: textStyle.baseline || 'middle',
                    textFont: textFont
                }
            };
            status = 'emphasis';
            labelControl = itemStyle[status].label || labelControl;
            textStyle = labelControl.textStyle || textStyle;
            lineLength = itemStyle[status].labelLine.length || lineLength;
            labelControl.position = labelControl.position || itemStyle.normal.label.position;
            text = this.getLabelText(seriesIndex, dataIndex, status);
            textFont = this.getFont(textStyle);
            textColor = defaultColor;
            if (labelControl.position === 'inner' || labelControl.position === 'inside' || labelControl.position === 'center') {
                textAlign = align;
                textColor = Math.max(topWidth, bottomWidth) / 2 > zrArea.getTextWidth(text, textFont) ? '#fff' : zrColor.reverse(defaultColor);
            } else if (labelControl.position === 'left') {
                textAlign = 'right';
            } else {
                textAlign = 'left';
            }
            textShape.highlightStyle = {
                x: this._getLabelPoint(labelControl.position, x, location, topWidth, bottomWidth, lineLength, align),
                color: textStyle.color || textColor,
                text: text,
                textAlign: textStyle.align || textAlign,
                textFont: textFont,
                brushType: 'fill'
            };
            return new TextShape(textShape);
        },
        getLabelText: function (seriesIndex, dataIndex, status) {
            var series = this.series;
            var serie = series[seriesIndex];
            var data = serie.data[dataIndex];
            var formatter = this.deepQuery([
                data,
                serie
            ], 'itemStyle.' + status + '.label.formatter');
            if (formatter) {
                if (typeof formatter === 'function') {
                    return formatter.call(this.myChart, {
                        seriesIndex: seriesIndex,
                        seriesName: serie.name || '',
                        series: serie,
                        dataIndex: dataIndex,
                        data: data,
                        name: data.name,
                        value: data.value
                    });
                } else if (typeof formatter === 'string') {
                    formatter = formatter.replace('{a}', '{a0}').replace('{b}', '{b0}').replace('{c}', '{c0}').replace('{a0}', serie.name).replace('{b0}', data.name).replace('{c0}', data.value);
                    return formatter;
                }
            } else {
                return data.name;
            }
        },
        getLabelLine: function (seriesIndex, dataIndex, defaultColor, x, y, topWidth, bottomWidth, height, align) {
            var serie = this.series[seriesIndex];
            var data = serie.data[dataIndex];
            var location = this._paramsMap[seriesIndex].location;
            var itemStyle = zrUtil.merge(zrUtil.clone(data.itemStyle) || {}, serie.itemStyle);
            var status = 'normal';
            var labelLineControl = itemStyle[status].labelLine;
            var lineLength = itemStyle[status].labelLine.length;
            var lineStyle = labelLineControl.lineStyle || {};
            var labelControl = itemStyle[status].label;
            labelControl.position = labelControl.position || itemStyle.normal.label.position;
            var lineShape = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase() + 1,
                hoverable: false,
                style: {
                    xStart: this._getLabelLineStartPoint(x, location, topWidth, bottomWidth, align),
                    yStart: y + height / 2,
                    xEnd: this._getLabelPoint(labelControl.position, x, location, topWidth, bottomWidth, lineLength, align),
                    yEnd: y + height / 2,
                    strokeColor: lineStyle.color || defaultColor,
                    lineType: lineStyle.type,
                    lineWidth: lineStyle.width
                }
            };
            status = 'emphasis';
            labelLineControl = itemStyle[status].labelLine || labelLineControl;
            lineLength = itemStyle[status].labelLine.length || lineLength;
            lineStyle = labelLineControl.lineStyle || lineStyle;
            labelControl = itemStyle[status].label || labelControl;
            labelControl.position = labelControl.position;
            lineShape.highlightStyle = {
                xEnd: this._getLabelPoint(labelControl.position, x, location, topWidth, bottomWidth, lineLength, align),
                strokeColor: lineStyle.color || defaultColor,
                lineType: lineStyle.type,
                lineWidth: lineStyle.width
            };
            return new LineShape(lineShape);
        },
        _getLabelPoint: function (position, x, location, topWidth, bottomWidth, lineLength, align) {
            position = position === 'inner' || position === 'inside' ? 'center' : position;
            switch (position) {
            case 'center':
                return align == 'center' ? x + topWidth / 2 : align == 'left' ? x + 10 : x + topWidth - 10;
            case 'left':
                if (lineLength === 'auto') {
                    return location.x - 10;
                } else {
                    return align == 'center' ? location.centerX - Math.max(topWidth, bottomWidth) / 2 - lineLength : align == 'right' ? x - (topWidth < bottomWidth ? bottomWidth - topWidth : 0) - lineLength : location.x - lineLength;
                }
                break;
            default:
                if (lineLength === 'auto') {
                    return location.x + location.width + 10;
                } else {
                    return align == 'center' ? location.centerX + Math.max(topWidth, bottomWidth) / 2 + lineLength : align == 'right' ? location.x + location.width + lineLength : x + Math.max(topWidth, bottomWidth) + lineLength;
                }
            }
        },
        _getLabelLineStartPoint: function (x, location, topWidth, bottomWidth, align) {
            return align == 'center' ? location.centerX : topWidth < bottomWidth ? x + Math.min(topWidth, bottomWidth) / 2 : x + Math.max(topWidth, bottomWidth) / 2;
        },
        _needLabel: function (serie, data, isEmphasis) {
            return this.deepQuery([
                data,
                serie
            ], 'itemStyle.' + (isEmphasis ? 'emphasis' : 'normal') + '.label.show');
        },
        _needLabelLine: function (serie, data, isEmphasis) {
            return this.deepQuery([
                data,
                serie
            ], 'itemStyle.' + (isEmphasis ? 'emphasis' : 'normal') + '.labelLine.show');
        },
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.series = newOption.series;
            }
            this.backupShapeList();
            this._buildShape();
        }
    };
    zrUtil.inherits(Funnel, ChartBase);
    require('../chart').define('funnel', Funnel);
    return Funnel;
});define('echarts/chart/eventRiver', [
    'require',
    './base',
    '../layout/eventRiver',
    'zrender/shape/Polygon',
    '../component/axis',
    '../component/grid',
    '../component/dataZoom',
    '../config',
    '../util/ecData',
    '../util/date',
    'zrender/tool/util',
    'zrender/tool/color',
    '../chart'
], function (require) {
    var ChartBase = require('./base');
    var eventRiverLayout = require('../layout/eventRiver');
    var PolygonShape = require('zrender/shape/Polygon');
    require('../component/axis');
    require('../component/grid');
    require('../component/dataZoom');
    var ecConfig = require('../config');
    ecConfig.eventRiver = {
        zlevel: 0,
        z: 2,
        clickable: true,
        legendHoverLink: true,
        itemStyle: {
            normal: {
                borderColor: 'rgba(0,0,0,0)',
                borderWidth: 1,
                label: {
                    show: true,
                    position: 'inside',
                    formatter: '{b}'
                }
            },
            emphasis: {
                borderColor: 'rgba(0,0,0,0)',
                borderWidth: 1,
                label: { show: true }
            }
        }
    };
    var ecData = require('../util/ecData');
    var ecDate = require('../util/date');
    var zrUtil = require('zrender/tool/util');
    var zrColor = require('zrender/tool/color');
    function EventRiver(ecTheme, messageCenter, zr, option, myChart) {
        ChartBase.call(this, ecTheme, messageCenter, zr, option, myChart);
        var self = this;
        self._ondragend = function () {
            self.isDragend = true;
        };
        this.refresh(option);
    }
    EventRiver.prototype = {
        type: ecConfig.CHART_TYPE_EVENTRIVER,
        _buildShape: function () {
            var series = this.series;
            this.selectedMap = {};
            this._dataPreprocessing();
            var legend = this.component.legend;
            var eventRiverSeries = [];
            for (var i = 0; i < series.length; i++) {
                if (series[i].type === this.type) {
                    series[i] = this.reformOption(series[i]);
                    this.legendHoverLink = series[i].legendHoverLink || this.legendHoverLink;
                    var serieName = series[i].name || '';
                    this.selectedMap[serieName] = legend ? legend.isSelected(serieName) : true;
                    if (!this.selectedMap[serieName]) {
                        continue;
                    }
                    this.buildMark(i);
                    eventRiverSeries.push(this.series[i]);
                }
            }
            eventRiverLayout(eventRiverSeries, this._intervalX, this.component.grid.getArea());
            this._drawEventRiver();
            this.addShapeList();
        },
        _dataPreprocessing: function () {
            var series = this.series;
            var xAxis;
            var evolutionList;
            for (var i = 0, iLen = series.length; i < iLen; i++) {
                if (series[i].type === this.type) {
                    xAxis = this.component.xAxis.getAxis(series[i].xAxisIndex || 0);
                    for (var j = 0, jLen = series[i].data.length; j < jLen; j++) {
                        evolutionList = series[i].data[j].evolution;
                        for (var k = 0, kLen = evolutionList.length; k < kLen; k++) {
                            evolutionList[k].timeScale = xAxis.getCoord(ecDate.getNewDate(evolutionList[k].time) - 0);
                            evolutionList[k].valueScale = Math.pow(evolutionList[k].value, 0.8);
                        }
                    }
                }
            }
            this._intervalX = Math.round(this.component.grid.getWidth() / 40);
        },
        _drawEventRiver: function () {
            var series = this.series;
            for (var i = 0; i < series.length; i++) {
                var serieName = series[i].name || '';
                if (series[i].type === this.type && this.selectedMap[serieName]) {
                    for (var j = 0; j < series[i].data.length; j++) {
                        this._drawEventBubble(series[i].data[j], i, j);
                    }
                }
            }
        },
        _drawEventBubble: function (oneEvent, seriesIndex, dataIndex) {
            var series = this.series;
            var serie = series[seriesIndex];
            var serieName = serie.name || '';
            var data = serie.data[dataIndex];
            var queryTarget = [
                data,
                serie
            ];
            var legend = this.component.legend;
            var defaultColor = legend ? legend.getColor(serieName) : this.zr.getColor(seriesIndex);
            var normal = this.deepMerge(queryTarget, 'itemStyle.normal') || {};
            var emphasis = this.deepMerge(queryTarget, 'itemStyle.emphasis') || {};
            var normalColor = this.getItemStyleColor(normal.color, seriesIndex, dataIndex, data) || defaultColor;
            var emphasisColor = this.getItemStyleColor(emphasis.color, seriesIndex, dataIndex, data) || (typeof normalColor === 'string' ? zrColor.lift(normalColor, -0.2) : normalColor);
            var pts = this._calculateControlPoints(oneEvent);
            var eventBubbleShape = {
                zlevel: this.getZlevelBase(),
                z: this.getZBase(),
                clickable: this.deepQuery(queryTarget, 'clickable'),
                style: {
                    pointList: pts,
                    smooth: 'spline',
                    brushType: 'both',
                    lineJoin: 'round',
                    color: normalColor,
                    lineWidth: normal.borderWidth,
                    strokeColor: normal.borderColor
                },
                highlightStyle: {
                    color: emphasisColor,
                    lineWidth: emphasis.borderWidth,
                    strokeColor: emphasis.borderColor
                },
                draggable: 'vertical',
                ondragend: this._ondragend
            };
            eventBubbleShape = new PolygonShape(eventBubbleShape);
            this.addLabel(eventBubbleShape, serie, data, oneEvent.name);
            ecData.pack(eventBubbleShape, series[seriesIndex], seriesIndex, series[seriesIndex].data[dataIndex], dataIndex, series[seriesIndex].data[dataIndex].name);
            this.shapeList.push(eventBubbleShape);
        },
        _calculateControlPoints: function (oneEvent) {
            var intervalX = this._intervalX;
            var posY = oneEvent.y;
            var evolution = oneEvent.evolution;
            var n = evolution.length;
            if (n < 1) {
                return;
            }
            var time = [];
            var value = [];
            for (var i = 0; i < n; i++) {
                time.push(evolution[i].timeScale);
                value.push(evolution[i].valueScale);
            }
            var pts = [];
            pts.push([
                time[0],
                posY
            ]);
            var i = 0;
            for (i = 0; i < n - 1; i++) {
                pts.push([
                    (time[i] + time[i + 1]) / 2,
                    value[i] / -2 + posY
                ]);
            }
            pts.push([
                (time[i] + (time[i] + intervalX)) / 2,
                value[i] / -2 + posY
            ]);
            pts.push([
                time[i] + intervalX,
                posY
            ]);
            pts.push([
                (time[i] + (time[i] + intervalX)) / 2,
                value[i] / 2 + posY
            ]);
            for (i = n - 1; i > 0; i--) {
                pts.push([
                    (time[i] + time[i - 1]) / 2,
                    value[i - 1] / 2 + posY
                ]);
            }
            return pts;
        },
        ondragend: function (param, status) {
            if (!this.isDragend || !param.target) {
                return;
            }
            status.dragOut = true;
            status.dragIn = true;
            status.needRefresh = false;
            this.isDragend = false;
        },
        refresh: function (newOption) {
            if (newOption) {
                this.option = newOption;
                this.series = newOption.series;
            }
            this.backupShapeList();
            this._buildShape();
        }
    };
    zrUtil.inherits(EventRiver, ChartBase);
    require('../chart').define('eventRiver', EventRiver);
    return EventRiver;
});define('echarts/layout/eventRiver', ['require'], function (require) {
    function eventRiverLayout(series, intervalX, area) {
        var space = 5;
        var scale = intervalX;
        function importanceSort(a, b) {
            var x = a.importance;
            var y = b.importance;
            return x > y ? -1 : x < y ? 1 : 0;
        }
        function indexOf(array, value) {
            if (array.indexOf) {
                return array.indexOf(value);
            }
            for (var i = 0, len = array.length; i < len; i++) {
                if (array[i] === value) {
                    return i;
                }
            }
            return -1;
        }
        for (var i = 0; i < series.length; i++) {
            for (var j = 0; j < series[i].data.length; j++) {
                if (series[i].data[j].weight == null) {
                    series[i].data[j].weight = 1;
                }
                var importance = 0;
                for (var k = 0; k < series[i].data[j].evolution.length; k++) {
                    importance += series[i].data[j].evolution[k].valueScale;
                }
                series[i].data[j].importance = importance * series[i].data[j].weight;
            }
            series[i].data.sort(importanceSort);
        }
        for (var i = 0; i < series.length; i++) {
            if (series[i].weight == null) {
                series[i].weight = 1;
            }
            var importance = 0;
            for (var j = 0; j < series[i].data.length; j++) {
                importance += series[i].data[j].weight;
            }
            series[i].importance = importance * series[i].weight;
        }
        series.sort(importanceSort);
        var minTime = Number.MAX_VALUE;
        var maxTime = 0;
        for (var i = 0; i < series.length; i++) {
            for (var j = 0; j < series[i].data.length; j++) {
                for (var k = 0; k < series[i].data[j].evolution.length; k++) {
                    var time = series[i].data[j].evolution[k].timeScale;
                    minTime = Math.min(minTime, time);
                    maxTime = Math.max(maxTime, time);
                }
            }
        }
        var root = segmentTreeBuild(Math.floor(minTime), Math.ceil(maxTime));
        var totalMaxY = 0;
        for (var i = 0; i < series.length; i++) {
            for (var j = 0; j < series[i].data.length; j++) {
                var e = series[i].data[j];
                e.time = [];
                e.value = [];
                for (var k = 0; k < series[i].data[j].evolution.length; k++) {
                    e.time.push(series[i].data[j].evolution[k].timeScale);
                    e.value.push(series[i].data[j].evolution[k].valueScale);
                }
                var mxIndex = indexOf(e.value, Math.max.apply(Math, e.value));
                var maxY = segmentTreeQuery(root, e.time[mxIndex], e.time[mxIndex + 1]);
                var k = 0;
                e.y = maxY + e.value[mxIndex] / 2 + space;
                for (k = 0; k < e.time.length - 1; k++) {
                    var curMaxY = segmentTreeQuery(root, e.time[k], e.time[k + 1]);
                    if (e.y - e.value[k] / 2 - space < curMaxY) {
                        e.y = curMaxY + e.value[k] / 2 + space;
                    }
                }
                var curMaxY = segmentTreeQuery(root, e.time[k], e.time[k] + scale);
                if (e.y - e.value[k] / 2 - space < curMaxY) {
                    e.y = curMaxY + e.value[k] / 2 + space;
                }
                series[i].y = e.y;
                totalMaxY = Math.max(totalMaxY, e.y + e.value[mxIndex] / 2);
                for (k = 0; k < e.time.length - 1; k++) {
                    segmentTreeInsert(root, e.time[k], e.time[k + 1], e.y + e.value[k] / 2);
                }
                segmentTreeInsert(root, e.time[k], e.time[k] + scale, e.y + e.value[k] / 2);
            }
        }
        scaleY(series, area, totalMaxY, space);
    }
    function scaleY(series, area, maxY, space) {
        var yBase = area.y;
        var yScale = (area.height - space) / maxY;
        for (var i = 0; i < series.length; i++) {
            series[i].y = series[i].y * yScale + yBase;
            var eventList = series[i].data;
            for (var j = 0; j < eventList.length; j++) {
                eventList[j].y = eventList[j].y * yScale + yBase;
                var evolutionList = eventList[j].evolution;
                for (var k = 0; k < evolutionList.length; k++) {
                    evolutionList[k].valueScale *= yScale * 1;
                }
            }
        }
    }
    function segmentTreeBuild(left, right) {
        var root = {
            'left': left,
            'right': right,
            'leftChild': null,
            'rightChild': null,
            'maxValue': 0
        };
        if (left + 1 < right) {
            var mid = Math.round((left + right) / 2);
            root.leftChild = segmentTreeBuild(left, mid);
            root.rightChild = segmentTreeBuild(mid, right);
        }
        return root;
    }
    function segmentTreeQuery(root, left, right) {
        if (right - left < 1) {
            return 0;
        }
        var mid = Math.round((root.left + root.right) / 2);
        var result = 0;
        if (left == root.left && right == root.right) {
            result = root.maxValue;
        } else if (right <= mid && root.leftChild != null) {
            result = segmentTreeQuery(root.leftChild, left, right);
        } else if (left >= mid && root.rightChild != null) {
            result = segmentTreeQuery(root.rightChild, left, right);
        } else {
            var leftValue = 0;
            var rightValue = 0;
            if (root.leftChild != null) {
                leftValue = segmentTreeQuery(root.leftChild, left, mid);
            }
            if (root.rightChild != null) {
                rightValue = segmentTreeQuery(root.rightChild, mid, right);
            }
            result = leftValue > rightValue ? leftValue : rightValue;
        }
        return result;
    }
    function segmentTreeInsert(root, left, right, value) {
        if (root == null) {
            return;
        }
        var mid = Math.round((root.left + root.right) / 2);
        root.maxValue = root.maxValue > value ? root.maxValue : value;
        if (Math.floor(left * 10) == Math.floor(root.left * 10) && Math.floor(right * 10) == Math.floor(root.right * 10)) {
            return;
        } else if (right <= mid) {
            segmentTreeInsert(root.leftChild, left, right, value);
        } else if (left >= mid) {
            segmentTreeInsert(root.rightChild, left, right, value);
        } else {
            segmentTreeInsert(root.leftChild, left, mid, value);
            segmentTreeInsert(root.rightChild, mid, right, value);
        }
    }
    return eventRiverLayout;
});
var zrender = require('zrender');
zrender.tool = {
    color : require('zrender/tool/color'),
    math : require('zrender/tool/math'),
    util : require('zrender/tool/util'),
    vector : require('zrender/tool/vector'),
    area : require('zrender/tool/area'),
    event : require('zrender/tool/event')
}

zrender.animation = {
    Animation : require('zrender/animation/Animation'),
    Cip : require('zrender/animation/Clip'),
    easing : require('zrender/animation/easing')
}
var echarts = require('echarts');
echarts.config = require('echarts/config');

echarts.util = {
    mapData : {
        params : require('echarts/util/mapData/params')
    }
}


require("echarts/chart/line");

require("echarts/chart/bar");

require("echarts/chart/scatter");

require("echarts/chart/k");

require("echarts/chart/pie");

require("echarts/chart/radar");

require("echarts/chart/chord");

require("echarts/chart/force");

require("echarts/chart/map");

require("echarts/chart/gauge");

require("echarts/chart/funnel");

require("echarts/chart/eventRiver");

_global['echarts'] = echarts;
_global['zrender'] = zrender;

})(window);
